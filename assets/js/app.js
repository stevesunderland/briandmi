"use strict";

/*!
 * jQuery JavaScript Library v2.2.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-04-05T19:26Z
 */

(function (global, factory) {

	if (typeof module === "object" && typeof module.exports === "object") {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ? factory(global, true) : function (w) {
			if (!w.document) {
				throw new Error("jQuery requires a window with a document");
			}
			return factory(w);
		};
	} else {
		factory(global);
	}

	// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};

	var version = "2.2.3",


	// Define a local copy of jQuery
	jQuery = function (selector, context) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init(selector, context);
	},


	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	    rdashAlpha = /-([\da-z])/gi,


	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function (all, letter) {
		return letter.toUpperCase();
	};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function () {
			return slice.call(this);
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function (num) {
			return num != null ?

			// Return just the one element from the set
			num < 0 ? this[num + this.length] : this[num] :

			// Return all the elements in a clean array
			slice.call(this);
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function (elems) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge(this.constructor(), elems);

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function (callback) {
			return jQuery.each(this, callback);
		},

		map: function (callback) {
			return this.pushStack(jQuery.map(this, function (elem, i) {
				return callback.call(elem, i, elem);
			}));
		},

		slice: function () {
			return this.pushStack(slice.apply(this, arguments));
		},

		first: function () {
			return this.eq(0);
		},

		last: function () {
			return this.eq(-1);
		},

		eq: function (i) {
			var len = this.length,
			    j = +i + (i < 0 ? len : 0);
			return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
		},

		end: function () {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function () {
		var options,
		    name,
		    src,
		    copy,
		    copyIsArray,
		    clone,
		    target = arguments[0] || {},
		    i = 1,
		    length = arguments.length,
		    deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// Skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !jQuery.isFunction(target)) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {

			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {

				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {

						if (copyIsArray) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = jQuery.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
							target[name] = copy;
						}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function (msg) {
			throw new Error(msg);
		},

		noop: function () {},

		isFunction: function (obj) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function (obj) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function (obj) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;
		},

		isPlainObject: function (obj) {
			var key;

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for (key in obj) {}

			return key === undefined || hasOwn.call(obj, key);
		},

		isEmptyObject: function (obj) {
			var name;
			for (name in obj) {
				return false;
			}
			return true;
		},

		type: function (obj) {
			if (obj == null) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function (code) {
			var script,
			    indirect = eval;

			code = jQuery.trim(code);

			if (code) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if (code.indexOf("use strict") === 1) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild(script).parentNode.removeChild(script);
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect(code);
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function (string) {
			return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
		},

		nodeName: function (elem, name) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function (obj, callback) {
			var length,
			    i = 0;

			if (isArrayLike(obj)) {
				length = obj.length;
				for (; i < length; i++) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function (text) {
			return text == null ? "" : (text + "").replace(rtrim, "");
		},

		// results is for internal usage only
		makeArray: function (arr, results) {
			var ret = results || [];

			if (arr != null) {
				if (isArrayLike(Object(arr))) {
					jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					push.call(ret, arr);
				}
			}

			return ret;
		},

		inArray: function (elem, arr, i) {
			return arr == null ? -1 : indexOf.call(arr, elem, i);
		},

		merge: function (first, second) {
			var len = +second.length,
			    j = 0,
			    i = first.length;

			for (; j < len; j++) {
				first[i++] = second[j];
			}

			first.length = i;

			return first;
		},

		grep: function (elems, callback, invert) {
			var callbackInverse,
			    matches = [],
			    i = 0,
			    length = elems.length,
			    callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for (; i < length; i++) {
				callbackInverse = !callback(elems[i], i);
				if (callbackInverse !== callbackExpect) {
					matches.push(elems[i]);
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function (elems, callback, arg) {
			var length,
			    value,
			    i = 0,
			    ret = [];

			// Go through the array, translating each of the items to their new values
			if (isArrayLike(elems)) {
				length = elems.length;
				for (; i < length; i++) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}

				// Go through every key on the object,
			} else {
					for (i in elems) {
						value = callback(elems[i], i, arg);

						if (value != null) {
							ret.push(value);
						}
					}
				}

			// Flatten any nested arrays
			return concat.apply([], ret);
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function (fn, context) {
			var tmp, args, proxy;

			if (typeof context === "string") {
				tmp = fn[context];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if (!jQuery.isFunction(fn)) {
				return undefined;
			}

			// Simulated bind
			args = slice.call(arguments, 2);
			proxy = function () {
				return fn.apply(context || this, args.concat(slice.call(arguments)));
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if (typeof Symbol === "function") {
		jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
		class2type["[object " + name + "]"] = name.toLowerCase();
	});

	function isArrayLike(obj) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
		    type = jQuery.type(obj);

		if (type === "function" || jQuery.isWindow(obj)) {
			return false;
		}

		return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	}
	var Sizzle =
	/*!
  * Sizzle CSS Selector Engine v2.2.1
  * http://sizzlejs.com/
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2015-10-17
  */
	function (window) {

		var i,
		    support,
		    Expr,
		    getText,
		    isXML,
		    tokenize,
		    compile,
		    select,
		    outermostContext,
		    sortInput,
		    hasDuplicate,


		// Local document vars
		setDocument,
		    document,
		    docElem,
		    documentIsHTML,
		    rbuggyQSA,
		    rbuggyMatches,
		    matches,
		    contains,


		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		    preferredDoc = window.document,
		    dirruns = 0,
		    done = 0,
		    classCache = createCache(),
		    tokenCache = createCache(),
		    compilerCache = createCache(),
		    sortOrder = function (a, b) {
			if (a === b) {
				hasDuplicate = true;
			}
			return 0;
		},


		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,


		// Instance methods
		hasOwn = {}.hasOwnProperty,
		    arr = [],
		    pop = arr.pop,
		    push_native = arr.push,
		    push = arr.push,
		    slice = arr.slice,

		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function (list, elem) {
			var i = 0,
			    len = list.length;
			for (; i < len; i++) {
				if (list[i] === elem) {
					return i;
				}
			}
			return -1;
		},
		    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",


		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",


		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
		    pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" + ")\\)|)",


		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp(whitespace + "+", "g"),
		    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
		    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
		    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
		    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
		    rpseudo = new RegExp(pseudos),
		    ridentifier = new RegExp("^" + identifier + "$"),
		    matchExpr = {
			"ID": new RegExp("^#(" + identifier + ")"),
			"CLASS": new RegExp("^\\.(" + identifier + ")"),
			"TAG": new RegExp("^(" + identifier + "|[*])"),
			"ATTR": new RegExp("^" + attributes),
			"PSEUDO": new RegExp("^" + pseudos),
			"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
			"bool": new RegExp("^(?:" + booleans + ")$", "i"),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
		},
		    rinputs = /^(?:input|select|textarea|button)$/i,
		    rheader = /^h\d$/i,
		    rnative = /^[^{]+\{\s*\[native \w/,


		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
		    rsibling = /[+~]/,
		    rescape = /'|\\/g,


		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
		    funescape = function (_, escaped, escapedWhitespace) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ? escaped : high < 0 ?
			// BMP codepoint
			String.fromCharCode(high + 0x10000) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
		},


		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function () {
			setDocument();
		};

		// Optimize for push.apply( _, NodeList )
		try {
			push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
			// Support: Android<4.0
			// Detect silently failing push.apply
			arr[preferredDoc.childNodes.length].nodeType;
		} catch (e) {
			push = { apply: arr.length ?

				// Leverage slice if possible
				function (target, els) {
					push_native.apply(target, slice.call(els));
				} :

				// Support: IE<9
				// Otherwise append directly
				function (target, els) {
					var j = target.length,
					    i = 0;
					// Can't trust NodeList.length
					while (target[j++] = els[i++]) {}
					target.length = j - 1;
				}
			};
		}

		function Sizzle(selector, context, results, seed) {
			var m,
			    i,
			    elem,
			    nid,
			    nidselect,
			    match,
			    groups,
			    newSelector,
			    newContext = context && context.ownerDocument,


			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

			results = results || [];

			// Return early from calls with invalid selector or context
			if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

				return results;
			}

			// Try to shortcut find operations (as opposed to filters) in HTML documents
			if (!seed) {

				if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
					setDocument(context);
				}
				context = context || document;

				if (documentIsHTML) {

					// If the selector is sufficiently simple, try using a "get*By*" DOM method
					// (excepting DocumentFragment context, where the methods don't exist)
					if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

						// ID selector
						if (m = match[1]) {

							// Document context
							if (nodeType === 9) {
								if (elem = context.getElementById(m)) {

									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if (elem.id === m) {
										results.push(elem);
										return results;
									}
								} else {
									return results;
								}

								// Element context
							} else {

									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {

										results.push(elem);
										return results;
									}
								}

							// Type selector
						} else if (match[2]) {
								push.apply(results, context.getElementsByTagName(selector));
								return results;

								// Class selector
							} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {

									push.apply(results, context.getElementsByClassName(m));
									return results;
								}
					}

					// Take advantage of querySelectorAll
					if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {

						if (nodeType !== 1) {
							newContext = context;
							newSelector = selector;

							// qSA looks outside Element context, which is not what we want
							// Thanks to Andrew Dupont for this workaround technique
							// Support: IE <=8
							// Exclude object elements
						} else if (context.nodeName.toLowerCase() !== "object") {

								// Capture the context ID, setting it first if necessary
								if (nid = context.getAttribute("id")) {
									nid = nid.replace(rescape, "\\$&");
								} else {
									context.setAttribute("id", nid = expando);
								}

								// Prefix every selector in the list
								groups = tokenize(selector);
								i = groups.length;
								nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
								while (i--) {
									groups[i] = nidselect + " " + toSelector(groups[i]);
								}
								newSelector = groups.join(",");

								// Expand context for sibling selectors
								newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
							}

						if (newSelector) {
							try {
								push.apply(results, newContext.querySelectorAll(newSelector));
								return results;
							} catch (qsaError) {} finally {
								if (nid === expando) {
									context.removeAttribute("id");
								}
							}
						}
					}
				}
			}

			// All others
			return select(selector.replace(rtrim, "$1"), context, results, seed);
		}

		/**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
		function createCache() {
			var keys = [];

			function cache(key, value) {
				// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
				if (keys.push(key + " ") > Expr.cacheLength) {
					// Only keep the most recent entries
					delete cache[keys.shift()];
				}
				return cache[key + " "] = value;
			}
			return cache;
		}

		/**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
		function markFunction(fn) {
			fn[expando] = true;
			return fn;
		}

		/**
   * Support testing using an element
   * @param {Function} fn Passed the created div and expects a boolean result
   */
		function assert(fn) {
			var div = document.createElement("div");

			try {
				return !!fn(div);
			} catch (e) {
				return false;
			} finally {
				// Remove from its parent by default
				if (div.parentNode) {
					div.parentNode.removeChild(div);
				}
				// release memory in IE
				div = null;
			}
		}

		/**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
		function addHandle(attrs, handler) {
			var arr = attrs.split("|"),
			    i = arr.length;

			while (i--) {
				Expr.attrHandle[arr[i]] = handler;
			}
		}

		/**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
		function siblingCheck(a, b) {
			var cur = b && a,
			    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

			// Use IE sourceIndex if available on both nodes
			if (diff) {
				return diff;
			}

			// Check if b follows a
			if (cur) {
				while (cur = cur.nextSibling) {
					if (cur === b) {
						return -1;
					}
				}
			}

			return a ? 1 : -1;
		}

		/**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
		function createInputPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
		function createButtonPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return (name === "input" || name === "button") && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
		function createPositionalPseudo(fn) {
			return markFunction(function (argument) {
				argument = +argument;
				return markFunction(function (seed, matches) {
					var j,
					    matchIndexes = fn([], seed.length, argument),
					    i = matchIndexes.length;

					// Match elements found at the specified indexes
					while (i--) {
						if (seed[j = matchIndexes[i]]) {
							seed[j] = !(matches[j] = seed[j]);
						}
					}
				});
			});
		}

		/**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
		function testContext(context) {
			return context && typeof context.getElementsByTagName !== "undefined" && context;
		}

		// Expose support vars for convenience
		support = Sizzle.support = {};

		/**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
		isXML = Sizzle.isXML = function (elem) {
			// documentElement is verified for cases where it doesn't yet exist
			// (such as loading iframes in IE - #4833)
			var documentElement = elem && (elem.ownerDocument || elem).documentElement;
			return documentElement ? documentElement.nodeName !== "HTML" : false;
		};

		/**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
		setDocument = Sizzle.setDocument = function (node) {
			var hasCompare,
			    parent,
			    doc = node ? node.ownerDocument || node : preferredDoc;

			// Return early if doc is invalid or already selected
			if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
				return document;
			}

			// Update global variables
			document = doc;
			docElem = document.documentElement;
			documentIsHTML = !isXML(document);

			// Support: IE 9-11, Edge
			// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
			if ((parent = document.defaultView) && parent.top !== parent) {
				// Support: IE 11
				if (parent.addEventListener) {
					parent.addEventListener("unload", unloadHandler, false);

					// Support: IE 9 - 10 only
				} else if (parent.attachEvent) {
						parent.attachEvent("onunload", unloadHandler);
					}
			}

			/* Attributes
   ---------------------------------------------------------------------- */

			// Support: IE<8
			// Verify that getAttribute really returns attributes and not properties
			// (excepting IE8 booleans)
			support.attributes = assert(function (div) {
				div.className = "i";
				return !div.getAttribute("className");
			});

			/* getElement(s)By*
   ---------------------------------------------------------------------- */

			// Check if getElementsByTagName("*") returns only elements
			support.getElementsByTagName = assert(function (div) {
				div.appendChild(document.createComment(""));
				return !div.getElementsByTagName("*").length;
			});

			// Support: IE<9
			support.getElementsByClassName = rnative.test(document.getElementsByClassName);

			// Support: IE<10
			// Check if getElementById returns elements by name
			// The broken getElementById methods don't pick up programatically-set names,
			// so use a roundabout getElementsByName test
			support.getById = assert(function (div) {
				docElem.appendChild(div).id = expando;
				return !document.getElementsByName || !document.getElementsByName(expando).length;
			});

			// ID find and filter
			if (support.getById) {
				Expr.find["ID"] = function (id, context) {
					if (typeof context.getElementById !== "undefined" && documentIsHTML) {
						var m = context.getElementById(id);
						return m ? [m] : [];
					}
				};
				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						return elem.getAttribute("id") === attrId;
					};
				};
			} else {
				// Support: IE6/7
				// getElementById is not reliable as a find shortcut
				delete Expr.find["ID"];

				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
						return node && node.value === attrId;
					};
				};
			}

			// Tag
			Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
				if (typeof context.getElementsByTagName !== "undefined") {
					return context.getElementsByTagName(tag);

					// DocumentFragment nodes don't have gEBTN
				} else if (support.qsa) {
						return context.querySelectorAll(tag);
					}
			} : function (tag, context) {
				var elem,
				    tmp = [],
				    i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName(tag);

				// Filter out possible comments
				if (tag === "*") {
					while (elem = results[i++]) {
						if (elem.nodeType === 1) {
							tmp.push(elem);
						}
					}

					return tmp;
				}
				return results;
			};

			// Class
			Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
				if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
					return context.getElementsByClassName(className);
				}
			};

			/* QSA/matchesSelector
   ---------------------------------------------------------------------- */

			// QSA and matchesSelector support

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			rbuggyMatches = [];

			// qSa(:focus) reports false when true (Chrome 21)
			// We allow this because of a bug in IE8/9 that throws an error
			// whenever `document.activeElement` is accessed on an iframe
			// So, we allow :focus to pass through QSA all the time to avoid the IE error
			// See http://bugs.jquery.com/ticket/13378
			rbuggyQSA = [];

			if (support.qsa = rnative.test(document.querySelectorAll)) {
				// Build QSA regex
				// Regex strategy adopted from Diego Perini
				assert(function (div) {
					// Select is set to empty string on purpose
					// This is to test IE's treatment of not explicitly
					// setting a boolean content attribute,
					// since its presence should be enough
					// http://bugs.jquery.com/ticket/12359
					docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";

					// Support: IE8, Opera 11-12.16
					// Nothing should be selected when empty strings follow ^= or $= or *=
					// The test attribute must be unknown in Opera but "safe" for WinRT
					// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
					if (div.querySelectorAll("[msallowcapture^='']").length) {
						rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
					}

					// Support: IE8
					// Boolean attributes and "value" are not treated correctly
					if (!div.querySelectorAll("[selected]").length) {
						rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
					}

					// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
					if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
						rbuggyQSA.push("~=");
					}

					// Webkit/Opera - :checked should return selected option elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":checked").length) {
						rbuggyQSA.push(":checked");
					}

					// Support: Safari 8+, iOS 8+
					// https://bugs.webkit.org/show_bug.cgi?id=136851
					// In-page `selector#id sibing-combinator selector` fails
					if (!div.querySelectorAll("a#" + expando + "+*").length) {
						rbuggyQSA.push(".#.+[+~]");
					}
				});

				assert(function (div) {
					// Support: Windows 8 Native Apps
					// The type and name attributes are restricted during .innerHTML assignment
					var input = document.createElement("input");
					input.setAttribute("type", "hidden");
					div.appendChild(input).setAttribute("name", "D");

					// Support: IE8
					// Enforce case-sensitivity of name attribute
					if (div.querySelectorAll("[name=d]").length) {
						rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
					}

					// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":enabled").length) {
						rbuggyQSA.push(":enabled", ":disabled");
					}

					// Opera 10-11 does not throw on post-comma invalid pseudos
					div.querySelectorAll("*,:x");
					rbuggyQSA.push(",.*:");
				});
			}

			if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {

				assert(function (div) {
					// Check to see if it's possible to do matchesSelector
					// on a disconnected node (IE 9)
					support.disconnectedMatch = matches.call(div, "div");

					// This should fail with an exception
					// Gecko does not error, returns false instead
					matches.call(div, "[s!='']:x");
					rbuggyMatches.push("!=", pseudos);
				});
			}

			rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
			rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

			/* Contains
   ---------------------------------------------------------------------- */
			hasCompare = rnative.test(docElem.compareDocumentPosition);

			// Element contains another
			// Purposefully self-exclusive
			// As in, an element does not contain itself
			contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
				    bup = b && b.parentNode;
				return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
			} : function (a, b) {
				if (b) {
					while (b = b.parentNode) {
						if (b === a) {
							return true;
						}
					}
				}
				return false;
			};

			/* Sorting
   ---------------------------------------------------------------------- */

			// Document order sorting
			sortOrder = hasCompare ? function (a, b) {

				// Flag for duplicate removal
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				// Sort on method existence if only one input has compareDocumentPosition
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if (compare) {
					return compare;
				}

				// Calculate position if both inputs belong to the same document
				compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

				// Otherwise we know they are disconnected
				1;

				// Disconnected nodes
				if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {

					// Choose the first element that is related to our preferred document
					if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
						return -1;
					}
					if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
						return 1;
					}

					// Maintain original order
					return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
				}

				return compare & 4 ? -1 : 1;
			} : function (a, b) {
				// Exit early if the nodes are identical
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				var cur,
				    i = 0,
				    aup = a.parentNode,
				    bup = b.parentNode,
				    ap = [a],
				    bp = [b];

				// Parentless nodes are either documents or disconnected
				if (!aup || !bup) {
					return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

					// If the nodes are siblings, we can do a quick check
				} else if (aup === bup) {
						return siblingCheck(a, b);
					}

				// Otherwise we need full lists of their ancestors for comparison
				cur = a;
				while (cur = cur.parentNode) {
					ap.unshift(cur);
				}
				cur = b;
				while (cur = cur.parentNode) {
					bp.unshift(cur);
				}

				// Walk down the tree looking for a discrepancy
				while (ap[i] === bp[i]) {
					i++;
				}

				return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck(ap[i], bp[i]) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
			};

			return document;
		};

		Sizzle.matches = function (expr, elements) {
			return Sizzle(expr, null, null, elements);
		};

		Sizzle.matchesSelector = function (elem, expr) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			// Make sure that attribute selectors are quoted
			expr = expr.replace(rattributeQuotes, "='$1']");

			if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

				try {
					var ret = matches.call(elem, expr);

					// IE 9's matchesSelector returns false on disconnected nodes
					if (ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11) {
						return ret;
					}
				} catch (e) {}
			}

			return Sizzle(expr, document, null, [elem]).length > 0;
		};

		Sizzle.contains = function (context, elem) {
			// Set document vars if needed
			if ((context.ownerDocument || context) !== document) {
				setDocument(context);
			}
			return contains(context, elem);
		};

		Sizzle.attr = function (elem, name) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			var fn = Expr.attrHandle[name.toLowerCase()],

			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

			return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
		};

		Sizzle.error = function (msg) {
			throw new Error("Syntax error, unrecognized expression: " + msg);
		};

		/**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
		Sizzle.uniqueSort = function (results) {
			var elem,
			    duplicates = [],
			    j = 0,
			    i = 0;

			// Unless we *know* we can detect duplicates, assume their presence
			hasDuplicate = !support.detectDuplicates;
			sortInput = !support.sortStable && results.slice(0);
			results.sort(sortOrder);

			if (hasDuplicate) {
				while (elem = results[i++]) {
					if (elem === results[i]) {
						j = duplicates.push(i);
					}
				}
				while (j--) {
					results.splice(duplicates[j], 1);
				}
			}

			// Clear input after sorting to release objects
			// See https://github.com/jquery/sizzle/pull/225
			sortInput = null;

			return results;
		};

		/**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
		getText = Sizzle.getText = function (elem) {
			var node,
			    ret = "",
			    i = 0,
			    nodeType = elem.nodeType;

			if (!nodeType) {
				// If no nodeType, this is expected to be an array
				while (node = elem[i++]) {
					// Do not traverse comment nodes
					ret += getText(node);
				}
			} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
				// Use textContent for elements
				// innerText usage removed for consistency of new lines (jQuery #11153)
				if (typeof elem.textContent === "string") {
					return elem.textContent;
				} else {
					// Traverse its children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						ret += getText(elem);
					}
				}
			} else if (nodeType === 3 || nodeType === 4) {
				return elem.nodeValue;
			}
			// Do not include comment or processing instruction nodes

			return ret;
		};

		Expr = Sizzle.selectors = {

			// Can be adjusted by the user
			cacheLength: 50,

			createPseudo: markFunction,

			match: matchExpr,

			attrHandle: {},

			find: {},

			relative: {
				">": { dir: "parentNode", first: true },
				" ": { dir: "parentNode" },
				"+": { dir: "previousSibling", first: true },
				"~": { dir: "previousSibling" }
			},

			preFilter: {
				"ATTR": function (match) {
					match[1] = match[1].replace(runescape, funescape);

					// Move the given value to match[3] whether quoted or unquoted
					match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

					if (match[2] === "~=") {
						match[3] = " " + match[3] + " ";
					}

					return match.slice(0, 4);
				},

				"CHILD": function (match) {
					/* matches from matchExpr["CHILD"]
     	1 type (only|nth|...)
     	2 what (child|of-type)
     	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
     	4 xn-component of xn+y argument ([+-]?\d*n|)
     	5 sign of xn-component
     	6 x of xn-component
     	7 sign of y-component
     	8 y of y-component
     */
					match[1] = match[1].toLowerCase();

					if (match[1].slice(0, 3) === "nth") {
						// nth-* requires argument
						if (!match[3]) {
							Sizzle.error(match[0]);
						}

						// numeric x and y parameters for Expr.filter.CHILD
						// remember that false/true cast respectively to 0/1
						match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
						match[5] = +(match[7] + match[8] || match[3] === "odd");

						// other types prohibit arguments
					} else if (match[3]) {
							Sizzle.error(match[0]);
						}

					return match;
				},

				"PSEUDO": function (match) {
					var excess,
					    unquoted = !match[6] && match[2];

					if (matchExpr["CHILD"].test(match[0])) {
						return null;
					}

					// Accept quoted arguments as-is
					if (match[3]) {
						match[2] = match[4] || match[5] || "";

						// Strip excess characters from unquoted arguments
					} else if (unquoted && rpseudo.test(unquoted) && (
						// Get excess from tokenize (recursively)
						excess = tokenize(unquoted, true)) && (
						// advance to the next closing parenthesis
						excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

							// excess is a negative index
							match[0] = match[0].slice(0, excess);
							match[2] = unquoted.slice(0, excess);
						}

					// Return only captures needed by the pseudo filter method (type and argument)
					return match.slice(0, 3);
				}
			},

			filter: {

				"TAG": function (nodeNameSelector) {
					var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
					return nodeNameSelector === "*" ? function () {
						return true;
					} : function (elem) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
				},

				"CLASS": function (className) {
					var pattern = classCache[className + " "];

					return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
						return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
					});
				},

				"ATTR": function (name, operator, check) {
					return function (elem) {
						var result = Sizzle.attr(elem, name);

						if (result == null) {
							return operator === "!=";
						}
						if (!operator) {
							return true;
						}

						result += "";

						return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
					};
				},

				"CHILD": function (type, what, argument, first, last) {
					var simple = type.slice(0, 3) !== "nth",
					    forward = type.slice(-4) !== "last",
					    ofType = what === "of-type";

					return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function (elem) {
						return !!elem.parentNode;
					} : function (elem, context, xml) {
						var cache,
						    uniqueCache,
						    outerCache,
						    node,
						    nodeIndex,
						    start,
						    dir = simple !== forward ? "nextSibling" : "previousSibling",
						    parent = elem.parentNode,
						    name = ofType && elem.nodeName.toLowerCase(),
						    useCache = !xml && !ofType,
						    diff = false;

						if (parent) {

							// :(first|last|only)-(child|of-type)
							if (simple) {
								while (dir) {
									node = elem;
									while (node = node[dir]) {
										if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [forward ? parent.firstChild : parent.lastChild];

							// non-xml :nth-child(...) stores cache data on `parent`
							if (forward && useCache) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[expando] || (node[expando] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

								cache = uniqueCache[type] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = nodeIndex && cache[2];
								node = nodeIndex && parent.childNodes[nodeIndex];

								while (node = ++nodeIndex && node && node[dir] || (

								// Fallback to seeking `elem` from the start
								diff = nodeIndex = 0) || start.pop()) {

									// When found, cache indexes on `parent` and break
									if (node.nodeType === 1 && ++diff && node === elem) {
										uniqueCache[type] = [dirruns, nodeIndex, diff];
										break;
									}
								}
							} else {
								// Use previously-cached element index if available
								if (useCache) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[expando] || (node[expando] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

									cache = uniqueCache[type] || [];
									nodeIndex = cache[0] === dirruns && cache[1];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if (diff === false) {
									// Use the same loop as above to seek `elem` from the start
									while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {

										if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {

											// Cache the index of each encountered element
											if (useCache) {
												outerCache = node[expando] || (node[expando] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

												uniqueCache[type] = [dirruns, diff];
											}

											if (node === elem) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || diff % first === 0 && diff / first >= 0;
						}
					};
				},

				"PSEUDO": function (pseudo, argument) {
					// pseudo-class names are case-insensitive
					// http://www.w3.org/TR/selectors/#pseudo-classes
					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
					// Remember that setFilters inherits from pseudos
					var args,
					    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

					// The user may use createPseudo to indicate that
					// arguments are needed to create the filter function
					// just as Sizzle does
					if (fn[expando]) {
						return fn(argument);
					}

					// But maintain support for old signatures
					if (fn.length > 1) {
						args = [pseudo, pseudo, "", argument];
						return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
							var idx,
							    matched = fn(seed, argument),
							    i = matched.length;
							while (i--) {
								idx = indexOf(seed, matched[i]);
								seed[idx] = !(matches[idx] = matched[i]);
							}
						}) : function (elem) {
							return fn(elem, 0, args);
						};
					}

					return fn;
				}
			},

			pseudos: {
				// Potentially complex pseudos
				"not": markFunction(function (selector) {
					// Trim the selector passed to compile
					// to avoid treating leading and trailing
					// spaces as combinators
					var input = [],
					    results = [],
					    matcher = compile(selector.replace(rtrim, "$1"));

					return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
						var elem,
						    unmatched = matcher(seed, null, xml, []),
						    i = seed.length;

						// Match elements unmatched by `matcher`
						while (i--) {
							if (elem = unmatched[i]) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) : function (elem, context, xml) {
						input[0] = elem;
						matcher(input, null, xml, results);
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
				}),

				"has": markFunction(function (selector) {
					return function (elem) {
						return Sizzle(selector, elem).length > 0;
					};
				}),

				"contains": markFunction(function (text) {
					text = text.replace(runescape, funescape);
					return function (elem) {
						return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
					};
				}),

				// "Whether an element is represented by a :lang() selector
				// is based solely on the element's language value
				// being equal to the identifier C,
				// or beginning with the identifier C immediately followed by "-".
				// The matching of C against the element's language value is performed case-insensitively.
				// The identifier C does not have to be a valid language name."
				// http://www.w3.org/TR/selectors/#lang-pseudo
				"lang": markFunction(function (lang) {
					// lang value must be a valid identifier
					if (!ridentifier.test(lang || "")) {
						Sizzle.error("unsupported lang: " + lang);
					}
					lang = lang.replace(runescape, funescape).toLowerCase();
					return function (elem) {
						var elemLang;
						do {
							if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {

								elemLang = elemLang.toLowerCase();
								return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
							}
						} while ((elem = elem.parentNode) && elem.nodeType === 1);
						return false;
					};
				}),

				// Miscellaneous
				"target": function (elem) {
					var hash = window.location && window.location.hash;
					return hash && hash.slice(1) === elem.id;
				},

				"root": function (elem) {
					return elem === docElem;
				},

				"focus": function (elem) {
					return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
				},

				// Boolean properties
				"enabled": function (elem) {
					return elem.disabled === false;
				},

				"disabled": function (elem) {
					return elem.disabled === true;
				},

				"checked": function (elem) {
					// In CSS3, :checked should return both checked and selected elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					var nodeName = elem.nodeName.toLowerCase();
					return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
				},

				"selected": function (elem) {
					// Accessing this property makes selected-by-default
					// options in Safari work properly
					if (elem.parentNode) {
						elem.parentNode.selectedIndex;
					}

					return elem.selected === true;
				},

				// Contents
				"empty": function (elem) {
					// http://www.w3.org/TR/selectors/#empty-pseudo
					// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
					//   but not by others (comment: 8; processing instruction: 7; etc.)
					// nodeType < 6 works because attributes (2) do not appear as children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						if (elem.nodeType < 6) {
							return false;
						}
					}
					return true;
				},

				"parent": function (elem) {
					return !Expr.pseudos["empty"](elem);
				},

				// Element/input types
				"header": function (elem) {
					return rheader.test(elem.nodeName);
				},

				"input": function (elem) {
					return rinputs.test(elem.nodeName);
				},

				"button": function (elem) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === "button" || name === "button";
				},

				"text": function (elem) {
					var attr;
					return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
				},

				// Position-in-collection
				"first": createPositionalPseudo(function () {
					return [0];
				}),

				"last": createPositionalPseudo(function (matchIndexes, length) {
					return [length - 1];
				}),

				"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
					return [argument < 0 ? argument + length : argument];
				}),

				"even": createPositionalPseudo(function (matchIndexes, length) {
					var i = 0;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"odd": createPositionalPseudo(function (matchIndexes, length) {
					var i = 1;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; --i >= 0;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; ++i < length;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				})
			}
		};

		Expr.pseudos["nth"] = Expr.pseudos["eq"];

		// Add button/input type pseudos
		for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
			Expr.pseudos[i] = createInputPseudo(i);
		}
		for (i in { submit: true, reset: true }) {
			Expr.pseudos[i] = createButtonPseudo(i);
		}

		// Easy API for creating new setFilters
		function setFilters() {}
		setFilters.prototype = Expr.filters = Expr.pseudos;
		Expr.setFilters = new setFilters();

		tokenize = Sizzle.tokenize = function (selector, parseOnly) {
			var matched,
			    match,
			    tokens,
			    type,
			    soFar,
			    groups,
			    preFilters,
			    cached = tokenCache[selector + " "];

			if (cached) {
				return parseOnly ? 0 : cached.slice(0);
			}

			soFar = selector;
			groups = [];
			preFilters = Expr.preFilter;

			while (soFar) {

				// Comma and first run
				if (!matched || (match = rcomma.exec(soFar))) {
					if (match) {
						// Don't consume trailing commas as valid
						soFar = soFar.slice(match[0].length) || soFar;
					}
					groups.push(tokens = []);
				}

				matched = false;

				// Combinators
				if (match = rcombinators.exec(soFar)) {
					matched = match.shift();
					tokens.push({
						value: matched,
						// Cast descendant combinators to space
						type: match[0].replace(rtrim, " ")
					});
					soFar = soFar.slice(matched.length);
				}

				// Filters
				for (type in Expr.filter) {
					if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
						matched = match.shift();
						tokens.push({
							value: matched,
							type: type,
							matches: match
						});
						soFar = soFar.slice(matched.length);
					}
				}

				if (!matched) {
					break;
				}
			}

			// Return the length of the invalid excess
			// if we're just parsing
			// Otherwise, throw an error or return tokens
			return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
			// Cache the tokens
			tokenCache(selector, groups).slice(0);
		};

		function toSelector(tokens) {
			var i = 0,
			    len = tokens.length,
			    selector = "";
			for (; i < len; i++) {
				selector += tokens[i].value;
			}
			return selector;
		}

		function addCombinator(matcher, combinator, base) {
			var dir = combinator.dir,
			    checkNonElements = base && dir === "parentNode",
			    doneName = done++;

			return combinator.first ?
			// Check against closest ancestor/preceding element
			function (elem, context, xml) {
				while (elem = elem[dir]) {
					if (elem.nodeType === 1 || checkNonElements) {
						return matcher(elem, context, xml);
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function (elem, context, xml) {
				var oldCache,
				    uniqueCache,
				    outerCache,
				    newCache = [dirruns, doneName];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if (xml) {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							if (matcher(elem, context, xml)) {
								return true;
							}
						}
					}
				} else {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							outerCache = elem[expando] || (elem[expando] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

							if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

								// Assign to newCache so results back-propagate to previous elements
								return newCache[2] = oldCache[2];
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[dir] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if (newCache[2] = matcher(elem, context, xml)) {
									return true;
								}
							}
						}
					}
				}
			};
		}

		function elementMatcher(matchers) {
			return matchers.length > 1 ? function (elem, context, xml) {
				var i = matchers.length;
				while (i--) {
					if (!matchers[i](elem, context, xml)) {
						return false;
					}
				}
				return true;
			} : matchers[0];
		}

		function multipleContexts(selector, contexts, results) {
			var i = 0,
			    len = contexts.length;
			for (; i < len; i++) {
				Sizzle(selector, contexts[i], results);
			}
			return results;
		}

		function condense(unmatched, map, filter, context, xml) {
			var elem,
			    newUnmatched = [],
			    i = 0,
			    len = unmatched.length,
			    mapped = map != null;

			for (; i < len; i++) {
				if (elem = unmatched[i]) {
					if (!filter || filter(elem, context, xml)) {
						newUnmatched.push(elem);
						if (mapped) {
							map.push(i);
						}
					}
				}
			}

			return newUnmatched;
		}

		function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
			if (postFilter && !postFilter[expando]) {
				postFilter = setMatcher(postFilter);
			}
			if (postFinder && !postFinder[expando]) {
				postFinder = setMatcher(postFinder, postSelector);
			}
			return markFunction(function (seed, results, context, xml) {
				var temp,
				    i,
				    elem,
				    preMap = [],
				    postMap = [],
				    preexisting = results.length,


				// Get initial elements from seed or context
				elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),


				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
				    matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || (seed ? preFilter : preexisting || postFilter) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results : matcherIn;

				// Find primary matches
				if (matcher) {
					matcher(matcherIn, matcherOut, context, xml);
				}

				// Apply postFilter
				if (postFilter) {
					temp = condense(matcherOut, postMap);
					postFilter(temp, [], context, xml);

					// Un-match failing elements by moving them back to matcherIn
					i = temp.length;
					while (i--) {
						if (elem = temp[i]) {
							matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
						}
					}
				}

				if (seed) {
					if (postFinder || preFilter) {
						if (postFinder) {
							// Get the final matcherOut by condensing this intermediate into postFinder contexts
							temp = [];
							i = matcherOut.length;
							while (i--) {
								if (elem = matcherOut[i]) {
									// Restore matcherIn since elem is not yet a final match
									temp.push(matcherIn[i] = elem);
								}
							}
							postFinder(null, matcherOut = [], temp, xml);
						}

						// Move matched elements from seed to results to keep them synchronized
						i = matcherOut.length;
						while (i--) {
							if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

								seed[temp] = !(results[temp] = elem);
							}
						}
					}

					// Add elements to results, through postFinder if defined
				} else {
						matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
						if (postFinder) {
							postFinder(null, results, matcherOut, xml);
						} else {
							push.apply(results, matcherOut);
						}
					}
			});
		}

		function matcherFromTokens(tokens) {
			var checkContext,
			    matcher,
			    j,
			    len = tokens.length,
			    leadingRelative = Expr.relative[tokens[0].type],
			    implicitRelative = leadingRelative || Expr.relative[" "],
			    i = leadingRelative ? 1 : 0,


			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator(function (elem) {
				return elem === checkContext;
			}, implicitRelative, true),
			    matchAnyContext = addCombinator(function (elem) {
				return indexOf(checkContext, elem) > -1;
			}, implicitRelative, true),
			    matchers = [function (elem, context, xml) {
				var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			}];

			for (; i < len; i++) {
				if (matcher = Expr.relative[tokens[i].type]) {
					matchers = [addCombinator(elementMatcher(matchers), matcher)];
				} else {
					matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

					// Return special upon seeing a positional matcher
					if (matcher[expando]) {
						// Find the next relative operator (if any) for proper handling
						j = ++i;
						for (; j < len; j++) {
							if (Expr.relative[tokens[j].type]) {
								break;
							}
						}
						return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
					}
					matchers.push(matcher);
				}
			}

			return elementMatcher(matchers);
		}

		function matcherFromGroupMatchers(elementMatchers, setMatchers) {
			var bySet = setMatchers.length > 0,
			    byElement = elementMatchers.length > 0,
			    superMatcher = function (seed, context, xml, results, outermost) {
				var elem,
				    j,
				    matcher,
				    matchedCount = 0,
				    i = "0",
				    unmatched = seed && [],
				    setMatched = [],
				    contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]("*", outermost),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
				    len = elems.length;

				if (outermost) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for (; i !== len && (elem = elems[i]) != null; i++) {
					if (byElement && elem) {
						j = 0;
						if (!context && elem.ownerDocument !== document) {
							setDocument(elem);
							xml = !documentIsHTML;
						}
						while (matcher = elementMatchers[j++]) {
							if (matcher(elem, context || document, xml)) {
								results.push(elem);
								break;
							}
						}
						if (outermost) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if (bySet) {
						// They will have gone through all possible matchers
						if (elem = !matcher && elem) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if (seed) {
							unmatched.push(elem);
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if (bySet && i !== matchedCount) {
					j = 0;
					while (matcher = setMatchers[j++]) {
						matcher(unmatched, setMatched, context, xml);
					}

					if (seed) {
						// Reintegrate element matches to eliminate the need for sorting
						if (matchedCount > 0) {
							while (i--) {
								if (!(unmatched[i] || setMatched[i])) {
									setMatched[i] = pop.call(results);
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense(setMatched);
					}

					// Add matches to results
					push.apply(results, setMatched);

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {

						Sizzle.uniqueSort(results);
					}
				}

				// Override manipulation of globals by nested matchers
				if (outermost) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

			return bySet ? markFunction(superMatcher) : superMatcher;
		}

		compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
			var i,
			    setMatchers = [],
			    elementMatchers = [],
			    cached = compilerCache[selector + " "];

			if (!cached) {
				// Generate a function of recursive functions that can be used to check each element
				if (!match) {
					match = tokenize(selector);
				}
				i = match.length;
				while (i--) {
					cached = matcherFromTokens(match[i]);
					if (cached[expando]) {
						setMatchers.push(cached);
					} else {
						elementMatchers.push(cached);
					}
				}

				// Cache the compiled function
				cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

				// Save selector and tokenization
				cached.selector = selector;
			}
			return cached;
		};

		/**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
		select = Sizzle.select = function (selector, context, results, seed) {
			var i,
			    tokens,
			    token,
			    type,
			    find,
			    compiled = typeof selector === "function" && selector,
			    match = !seed && tokenize(selector = compiled.selector || selector);

			results = results || [];

			// Try to minimize operations if there is only one selector in the list and no seed
			// (the latter of which guarantees us context)
			if (match.length === 1) {

				// Reduce context if the leading compound selector is an ID
				tokens = match[0] = match[0].slice(0);
				if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

					context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
					if (!context) {
						return results;

						// Precompiled matchers will still verify ancestry, so step up a level
					} else if (compiled) {
							context = context.parentNode;
						}

					selector = selector.slice(tokens.shift().value.length);
				}

				// Fetch a seed set for right-to-left matching
				i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
				while (i--) {
					token = tokens[i];

					// Abort if we hit a combinator
					if (Expr.relative[type = token.type]) {
						break;
					}
					if (find = Expr.find[type]) {
						// Search, expanding context for leading sibling combinators
						if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice(i, 1);
							selector = seed.length && toSelector(tokens);
							if (!selector) {
								push.apply(results, seed);
								return results;
							}

							break;
						}
					}
				}
			}

			// Compile and execute a filtering function if one is not provided
			// Provide `match` to avoid retokenization if we modified the selector above
			(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
			return results;
		};

		// One-time assignments

		// Sort stability
		support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

		// Support: Chrome 14-35+
		// Always assume duplicates if they aren't passed to the comparison function
		support.detectDuplicates = !!hasDuplicate;

		// Initialize against the default document
		setDocument();

		// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
		// Detached nodes confoundingly follow *each other*
		support.sortDetached = assert(function (div1) {
			// Should return 1, but returns 4 (following)
			return div1.compareDocumentPosition(document.createElement("div")) & 1;
		});

		// Support: IE<8
		// Prevent attribute/property "interpolation"
		// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
		if (!assert(function (div) {
			div.innerHTML = "<a href='#'></a>";
			return div.firstChild.getAttribute("href") === "#";
		})) {
			addHandle("type|href|height|width", function (elem, name, isXML) {
				if (!isXML) {
					return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
				}
			});
		}

		// Support: IE<9
		// Use defaultValue in place of getAttribute("value")
		if (!support.attributes || !assert(function (div) {
			div.innerHTML = "<input/>";
			div.firstChild.setAttribute("value", "");
			return div.firstChild.getAttribute("value") === "";
		})) {
			addHandle("value", function (elem, name, isXML) {
				if (!isXML && elem.nodeName.toLowerCase() === "input") {
					return elem.defaultValue;
				}
			});
		}

		// Support: IE<9
		// Use getAttributeNode to fetch booleans when getAttribute lies
		if (!assert(function (div) {
			return div.getAttribute("disabled") == null;
		})) {
			addHandle(booleans, function (elem, name, isXML) {
				var val;
				if (!isXML) {
					return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
				}
			});
		}

		return Sizzle;
	}(window);

	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;

	var dir = function (elem, dir, until) {
		var matched = [],
		    truncate = until !== undefined;

		while ((elem = elem[dir]) && elem.nodeType !== 9) {
			if (elem.nodeType === 1) {
				if (truncate && jQuery(elem).is(until)) {
					break;
				}
				matched.push(elem);
			}
		}
		return matched;
	};

	var siblings = function (n, elem) {
		var matched = [];

		for (; n; n = n.nextSibling) {
			if (n.nodeType === 1 && n !== elem) {
				matched.push(n);
			}
		}

		return matched;
	};

	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;

	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow(elements, qualifier, not) {
		if (jQuery.isFunction(qualifier)) {
			return jQuery.grep(elements, function (elem, i) {
				/* jshint -W018 */
				return !!qualifier.call(elem, i, elem) !== not;
			});
		}

		if (qualifier.nodeType) {
			return jQuery.grep(elements, function (elem) {
				return elem === qualifier !== not;
			});
		}

		if (typeof qualifier === "string") {
			if (risSimple.test(qualifier)) {
				return jQuery.filter(qualifier, elements, not);
			}

			qualifier = jQuery.filter(qualifier, elements);
		}

		return jQuery.grep(elements, function (elem) {
			return indexOf.call(qualifier, elem) > -1 !== not;
		});
	}

	jQuery.filter = function (expr, elems, not) {
		var elem = elems[0];

		if (not) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
			return elem.nodeType === 1;
		}));
	};

	jQuery.fn.extend({
		find: function (selector) {
			var i,
			    len = this.length,
			    ret = [],
			    self = this;

			if (typeof selector !== "string") {
				return this.pushStack(jQuery(selector).filter(function () {
					for (i = 0; i < len; i++) {
						if (jQuery.contains(self[i], this)) {
							return true;
						}
					}
				}));
			}

			for (i = 0; i < len; i++) {
				jQuery.find(selector, self[i], ret);
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function (selector) {
			return this.pushStack(winnow(this, selector || [], false));
		},
		not: function (selector) {
			return this.pushStack(winnow(this, selector || [], true));
		},
		is: function (selector) {
			return !!winnow(this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
		}
	});

	// Initialize a jQuery object

	// A central reference to the root jQuery(document)
	var rootjQuery,


	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	    init = jQuery.fn.init = function (selector, context, root) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if (!selector) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if (typeof selector === "string") {
			if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [null, selector, null];
			} else {
				match = rquickExpr.exec(selector);
			}

			// Match html or make sure no context is specified for #id
			if (match && (match[1] || !context)) {

				// HANDLE: $(html) -> $(array)
				if (match[1]) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

					// HANDLE: $(html, props)
					if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
						for (match in context) {

							// Properties of context are called as methods if possible
							if (jQuery.isFunction(this[match])) {
								this[match](context[match]);

								// ...and otherwise set as attributes
							} else {
									this.attr(match, context[match]);
								}
						}
					}

					return this;

					// HANDLE: $(#id)
				} else {
						elem = document.getElementById(match[2]);

						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if (elem && elem.parentNode) {

							// Inject the element directly into the jQuery object
							this.length = 1;
							this[0] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
			} else if (!context || context.jquery) {
					return (context || root).find(selector);

					// HANDLE: $(expr, context)
					// (which is just equivalent to: $(context).find(expr)
				} else {
						return this.constructor(context).find(selector);
					}

			// HANDLE: $(DOMElement)
		} else if (selector.nodeType) {
				this.context = this[0] = selector;
				this.length = 1;
				return this;

				// HANDLE: $(function)
				// Shortcut for document ready
			} else if (jQuery.isFunction(selector)) {
					return root.ready !== undefined ? root.ready(selector) :

					// Execute immediately if ready is not present
					selector(jQuery);
				}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray(selector, this);
	};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery(document);

	var rparentsprev = /^(?:parents|prev(?:Until|All))/,


	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

	jQuery.fn.extend({
		has: function (target) {
			var targets = jQuery(target, this),
			    l = targets.length;

			return this.filter(function () {
				var i = 0;
				for (; i < l; i++) {
					if (jQuery.contains(this, targets[i])) {
						return true;
					}
				}
			});
		},

		closest: function (selectors, context) {
			var cur,
			    i = 0,
			    l = this.length,
			    matched = [],
			    pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

			for (; i < l; i++) {
				for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

					// Always skip document fragments
					if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

						matched.push(cur);
						break;
					}
				}
			}

			return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
		},

		// Determine the position of an element within the set
		index: function (elem) {

			// No argument, return index in parent
			if (!elem) {
				return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if (typeof elem === "string") {
				return indexOf.call(jQuery(elem), this[0]);
			}

			// Locate the position of the desired element
			return indexOf.call(this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem);
		},

		add: function (selector, context) {
			return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
		},

		addBack: function (selector) {
			return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
		}
	});

	function sibling(cur, dir) {
		while ((cur = cur[dir]) && cur.nodeType !== 1) {}
		return cur;
	}

	jQuery.each({
		parent: function (elem) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function (elem) {
			return dir(elem, "parentNode");
		},
		parentsUntil: function (elem, i, until) {
			return dir(elem, "parentNode", until);
		},
		next: function (elem) {
			return sibling(elem, "nextSibling");
		},
		prev: function (elem) {
			return sibling(elem, "previousSibling");
		},
		nextAll: function (elem) {
			return dir(elem, "nextSibling");
		},
		prevAll: function (elem) {
			return dir(elem, "previousSibling");
		},
		nextUntil: function (elem, i, until) {
			return dir(elem, "nextSibling", until);
		},
		prevUntil: function (elem, i, until) {
			return dir(elem, "previousSibling", until);
		},
		siblings: function (elem) {
			return siblings((elem.parentNode || {}).firstChild, elem);
		},
		children: function (elem) {
			return siblings(elem.firstChild);
		},
		contents: function (elem) {
			return elem.contentDocument || jQuery.merge([], elem.childNodes);
		}
	}, function (name, fn) {
		jQuery.fn[name] = function (until, selector) {
			var matched = jQuery.map(this, fn, until);

			if (name.slice(-5) !== "Until") {
				selector = until;
			}

			if (selector && typeof selector === "string") {
				matched = jQuery.filter(selector, matched);
			}

			if (this.length > 1) {

				// Remove duplicates
				if (!guaranteedUnique[name]) {
					jQuery.uniqueSort(matched);
				}

				// Reverse order for parents* and prev-derivatives
				if (rparentsprev.test(name)) {
					matched.reverse();
				}
			}

			return this.pushStack(matched);
		};
	});
	var rnotwhite = /\S+/g;

	// Convert String-formatted options into Object-formatted ones
	function createOptions(options) {
		var object = {};
		jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
			object[flag] = true;
		});
		return object;
	}

	/*
  * Create a callback list using the following parameters:
  *
  *	options: an optional list of space-separated options that will change how
  *			the callback list behaves or a more traditional option object
  *
  * By default a callback list will act like an event callback list and can be
  * "fired" multiple times.
  *
  * Possible options:
  *
  *	once:			will ensure the callback list can only be fired once (like a Deferred)
  *
  *	memory:			will keep track of previous values and will call any callback added
  *					after the list has been fired right away with the latest "memorized"
  *					values (like a Deferred)
  *
  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  *
  *	stopOnFalse:	interrupt callings when a callback returns false
  *
  */
	jQuery.Callbacks = function (options) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

		var // Flag to know if list is currently firing
		firing,


		// Last fire value for non-forgettable lists
		memory,


		// Flag to know if list was already fired
		fired,


		// Flag to prevent firing
		locked,


		// Actual callback list
		list = [],


		// Queue of execution data for repeatable lists
		queue = [],


		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,


		// Fire callbacks
		fire = function () {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for (; queue.length; firingIndex = -1) {
				memory = queue.shift();
				while (++firingIndex < list.length) {

					// Run callback and check for early termination
					if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if (!options.memory) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if (locked) {

				// Keep an empty list if we have data for future add calls
				if (memory) {
					list = [];

					// Otherwise, this object is spent
				} else {
						list = "";
					}
			}
		},


		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function () {
				if (list) {

					// If we have memory from a past run, we should fire after adding
					if (memory && !firing) {
						firingIndex = list.length - 1;
						queue.push(memory);
					}

					(function add(args) {
						jQuery.each(args, function (_, arg) {
							if (jQuery.isFunction(arg)) {
								if (!options.unique || !self.has(arg)) {
									list.push(arg);
								}
							} else if (arg && arg.length && jQuery.type(arg) !== "string") {

								// Inspect recursively
								add(arg);
							}
						});
					})(arguments);

					if (memory && !firing) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function () {
				jQuery.each(arguments, function (_, arg) {
					var index;
					while ((index = jQuery.inArray(arg, list, index)) > -1) {
						list.splice(index, 1);

						// Handle firing indexes
						if (index <= firingIndex) {
							firingIndex--;
						}
					}
				});
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function (fn) {
				return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function () {
				if (list) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function () {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function () {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function () {
				locked = queue = [];
				if (!memory) {
					list = memory = "";
				}
				return this;
			},
			locked: function () {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function (context, args) {
				if (!locked) {
					args = args || [];
					args = [context, args.slice ? args.slice() : args];
					queue.push(args);
					if (!firing) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function () {
				self.fireWith(this, arguments);
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function () {
				return !!fired;
			}
		};

		return self;
	};

	jQuery.extend({

		Deferred: function (func) {
			var tuples = [

			// action, add listener, listener list, final state
			["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
			    state = "pending",
			    promise = {
				state: function () {
					return state;
				},
				always: function () {
					deferred.done(arguments).fail(arguments);
					return this;
				},
				then: function () /* fnDone, fnFail, fnProgress */{
					var fns = arguments;
					return jQuery.Deferred(function (newDefer) {
						jQuery.each(tuples, function (i, tuple) {
							var fn = jQuery.isFunction(fns[i]) && fns[i];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[tuple[1]](function () {
								var returned = fn && fn.apply(this, arguments);
								if (returned && jQuery.isFunction(returned.promise)) {
									returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
								} else {
									newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
								}
							});
						});
						fns = null;
					}).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function (obj) {
					return obj != null ? jQuery.extend(obj, promise) : promise;
				}
			},
			    deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each(tuples, function (i, tuple) {
				var list = tuple[2],
				    stateString = tuple[3];

				// promise[ done | fail | progress ] = list.add
				promise[tuple[1]] = list.add;

				// Handle state
				if (stateString) {
					list.add(function () {

						// state = [ resolved | rejected ]
						state = stateString;

						// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
				}

				// deferred[ resolve | reject | notify ]
				deferred[tuple[0]] = function () {
					deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
					return this;
				};
				deferred[tuple[0] + "With"] = list.fireWith;
			});

			// Make the deferred a promise
			promise.promise(deferred);

			// Call given func if any
			if (func) {
				func.call(deferred, deferred);
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function (subordinate /* , ..., subordinateN */) {
			var i = 0,
			    resolveValues = slice.call(arguments),
			    length = resolveValues.length,


			// the count of uncompleted subordinates
			remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,


			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),


			// Update function for both resolve and progress values
			updateFunc = function (i, contexts, values) {
				return function (value) {
					contexts[i] = this;
					values[i] = arguments.length > 1 ? slice.call(arguments) : value;
					if (values === progressValues) {
						deferred.notifyWith(contexts, values);
					} else if (! --remaining) {
						deferred.resolveWith(contexts, values);
					}
				};
			},
			    progressValues,
			    progressContexts,
			    resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if (length > 1) {
				progressValues = new Array(length);
				progressContexts = new Array(length);
				resolveContexts = new Array(length);
				for (; i < length; i++) {
					if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
						resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if (!remaining) {
				deferred.resolveWith(resolveContexts, resolveValues);
			}

			return deferred.promise();
		}
	});

	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function (fn) {

		// Add the callback
		jQuery.ready.promise().done(fn);

		return this;
	};

	jQuery.extend({

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function (hold) {
			if (hold) {
				jQuery.readyWait++;
			} else {
				jQuery.ready(true);
			}
		},

		// Handle when the DOM is ready
		ready: function (wait) {

			// Abort if there are pending holds or we're already ready
			if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if (wait !== true && --jQuery.readyWait > 0) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith(document, [jQuery]);

			// Trigger any bound ready events
			if (jQuery.fn.triggerHandler) {
				jQuery(document).triggerHandler("ready");
				jQuery(document).off("ready");
			}
		}
	});

	/**
  * The ready event handler and self cleanup method
  */
	function completed() {
		document.removeEventListener("DOMContentLoaded", completed);
		window.removeEventListener("load", completed);
		jQuery.ready();
	}

	jQuery.ready.promise = function (obj) {
		if (!readyList) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout(jQuery.ready);
			} else {

				// Use the handy event callback
				document.addEventListener("DOMContentLoaded", completed);

				// A fallback to window.onload, that will always work
				window.addEventListener("load", completed);
			}
		}
		return readyList.promise(obj);
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
		var i = 0,
		    len = elems.length,
		    bulk = key == null;

		// Sets many values
		if (jQuery.type(key) === "object") {
			chainable = true;
			for (i in key) {
				access(elems, fn, i, key[i], true, emptyGet, raw);
			}

			// Sets one value
		} else if (value !== undefined) {
				chainable = true;

				if (!jQuery.isFunction(value)) {
					raw = true;
				}

				if (bulk) {

					// Bulk operations run against the entire set
					if (raw) {
						fn.call(elems, value);
						fn = null;

						// ...except when executing function values
					} else {
							bulk = fn;
							fn = function (elem, key, value) {
								return bulk.call(jQuery(elem), value);
							};
						}
				}

				if (fn) {
					for (; i < len; i++) {
						fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
					}
				}
			}

		return chainable ? elems :

		// Gets
		bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
	};
	var acceptData = function (owner) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || ! +owner.nodeType;
	};

	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function (owner, initial) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if (owner.nodeType) {
				owner[this.expando] = value;

				// Otherwise secure it in a non-enumerable, non-writable property
				// configurability must be true to allow the property to be
				// deleted with the delete operator
			} else {
					Object.defineProperty(owner, this.expando, {
						value: value,
						writable: true,
						configurable: true
					});
				}
			return owner[this.expando];
		},
		cache: function (owner) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if (!acceptData(owner)) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[this.expando];

			// If not, create one
			if (!value) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if (acceptData(owner)) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if (owner.nodeType) {
						owner[this.expando] = value;

						// Otherwise secure it in a non-enumerable property
						// configurable must be true to allow the property to be
						// deleted when data is removed
					} else {
							Object.defineProperty(owner, this.expando, {
								value: value,
								configurable: true
							});
						}
				}
			}

			return value;
		},
		set: function (owner, data, value) {
			var prop,
			    cache = this.cache(owner);

			// Handle: [ owner, key, value ] args
			if (typeof data === "string") {
				cache[data] = value;

				// Handle: [ owner, { properties } ] args
			} else {

					// Copy the properties one-by-one to the cache object
					for (prop in data) {
						cache[prop] = data[prop];
					}
				}
			return cache;
		},
		get: function (owner, key) {
			return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
		},
		access: function (owner, key, value) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if (key === undefined || key && typeof key === "string" && value === undefined) {

				stored = this.get(owner, key);

				return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set(owner, key, value);

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function (owner, key) {
			var i,
			    name,
			    camel,
			    cache = owner[this.expando];

			if (cache === undefined) {
				return;
			}

			if (key === undefined) {
				this.register(owner);
			} else {

				// Support array or space separated string of keys
				if (jQuery.isArray(key)) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat(key.map(jQuery.camelCase));
				} else {
					camel = jQuery.camelCase(key);

					// Try the string as a key before any manipulation
					if (key in cache) {
						name = [key, camel];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ? [name] : name.match(rnotwhite) || [];
					}
				}

				i = name.length;

				while (i--) {
					delete cache[name[i]];
				}
			}

			// Remove the expando if there's no more data
			if (key === undefined || jQuery.isEmptyObject(cache)) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if (owner.nodeType) {
					owner[this.expando] = undefined;
				} else {
					delete owner[this.expando];
				}
			}
		},
		hasData: function (owner) {
			var cache = owner[this.expando];
			return cache !== undefined && !jQuery.isEmptyObject(cache);
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();

	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	    rmultiDash = /[A-Z]/g;

	function dataAttr(elem, key, data) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if (data === undefined && elem.nodeType === 1) {
			name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
			data = elem.getAttribute(name);

			if (typeof data === "string") {
				try {
					data = data === "true" ? true : data === "false" ? false : data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
				} catch (e) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set(elem, key, data);
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function (elem) {
			return dataUser.hasData(elem) || dataPriv.hasData(elem);
		},

		data: function (elem, name, data) {
			return dataUser.access(elem, name, data);
		},

		removeData: function (elem, name) {
			dataUser.remove(elem, name);
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function (elem, name, data) {
			return dataPriv.access(elem, name, data);
		},

		_removeData: function (elem, name) {
			dataPriv.remove(elem, name);
		}
	});

	jQuery.fn.extend({
		data: function (key, value) {
			var i,
			    name,
			    data,
			    elem = this[0],
			    attrs = elem && elem.attributes;

			// Gets all values
			if (key === undefined) {
				if (this.length) {
					data = dataUser.get(elem);

					if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
						i = attrs.length;
						while (i--) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if (attrs[i]) {
								name = attrs[i].name;
								if (name.indexOf("data-") === 0) {
									name = jQuery.camelCase(name.slice(5));
									dataAttr(elem, name, data[name]);
								}
							}
						}
						dataPriv.set(elem, "hasDataAttrs", true);
					}
				}

				return data;
			}

			// Sets multiple values
			if (typeof key === "object") {
				return this.each(function () {
					dataUser.set(this, key);
				});
			}

			return access(this, function (value) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if (elem && value === undefined) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get(elem, key) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());

					if (data !== undefined) {
						return data;
					}

					camelKey = jQuery.camelCase(key);

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get(elem, camelKey);
					if (data !== undefined) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr(elem, camelKey, undefined);
					if (data !== undefined) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase(key);
				this.each(function () {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get(this, camelKey);

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set(this, camelKey, value);

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if (key.indexOf("-") > -1 && data !== undefined) {
						dataUser.set(this, key, value);
					}
				});
			}, null, value, arguments.length > 1, null, true);
		},

		removeData: function (key) {
			return this.each(function () {
				dataUser.remove(this, key);
			});
		}
	});

	jQuery.extend({
		queue: function (elem, type, data) {
			var queue;

			if (elem) {
				type = (type || "fx") + "queue";
				queue = dataPriv.get(elem, type);

				// Speed up dequeue by getting out quickly if this is just a lookup
				if (data) {
					if (!queue || jQuery.isArray(data)) {
						queue = dataPriv.access(elem, type, jQuery.makeArray(data));
					} else {
						queue.push(data);
					}
				}
				return queue || [];
			}
		},

		dequeue: function (elem, type) {
			type = type || "fx";

			var queue = jQuery.queue(elem, type),
			    startLength = queue.length,
			    fn = queue.shift(),
			    hooks = jQuery._queueHooks(elem, type),
			    next = function () {
				jQuery.dequeue(elem, type);
			};

			// If the fx queue is dequeued, always remove the progress sentinel
			if (fn === "inprogress") {
				fn = queue.shift();
				startLength--;
			}

			if (fn) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call(elem, next, hooks);
			}

			if (!startLength && hooks) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function (elem, type) {
			var key = type + "queueHooks";
			return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
				empty: jQuery.Callbacks("once memory").add(function () {
					dataPriv.remove(elem, [type + "queue", key]);
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function (type, data) {
			var setter = 2;

			if (typeof type !== "string") {
				data = type;
				type = "fx";
				setter--;
			}

			if (arguments.length < setter) {
				return jQuery.queue(this[0], type);
			}

			return data === undefined ? this : this.each(function () {
				var queue = jQuery.queue(this, type, data);

				// Ensure a hooks for this queue
				jQuery._queueHooks(this, type);

				if (type === "fx" && queue[0] !== "inprogress") {
					jQuery.dequeue(this, type);
				}
			});
		},
		dequeue: function (type) {
			return this.each(function () {
				jQuery.dequeue(this, type);
			});
		},
		clearQueue: function (type) {
			return this.queue(type || "fx", []);
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function (type, obj) {
			var tmp,
			    count = 1,
			    defer = jQuery.Deferred(),
			    elements = this,
			    i = this.length,
			    resolve = function () {
				if (! --count) {
					defer.resolveWith(elements, [elements]);
				}
			};

			if (typeof type !== "string") {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while (i--) {
				tmp = dataPriv.get(elements[i], type + "queueHooks");
				if (tmp && tmp.empty) {
					count++;
					tmp.empty.add(resolve);
				}
			}
			resolve();
			return defer.promise(obj);
		}
	});
	var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

	var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

	var cssExpand = ["Top", "Right", "Bottom", "Left"];

	var isHidden = function (elem, el) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
	};

	function adjustCSS(elem, prop, valueParts, tween) {
		var adjusted,
		    scale = 1,
		    maxIterations = 20,
		    currentValue = tween ? function () {
			return tween.cur();
		} : function () {
			return jQuery.css(elem, prop, "");
		},
		    initial = currentValue(),
		    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),


		// Starting value computation is required for potential unit mismatches
		initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

		if (initialInUnit && initialInUnit[3] !== unit) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[3];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style(elem, prop, initialInUnit + unit);

				// Update scale, tolerating zero or NaN from tween.cur()
				// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
		}

		if (valueParts) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
			if (tween) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = /^(?:checkbox|radio)$/i;

	var rtagName = /<([\w:-]+)/;

	var rscriptType = /^$|\/(?:java|ecma)script/i;

	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [1, "<select multiple='multiple'>", "</select>"],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [1, "<table>", "</table>"],
		col: [2, "<table><colgroup>", "</colgroup></table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

		_default: [0, "", ""]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	function getAll(context, tag) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];

		return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval(elems, refElements) {
		var i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
		}
	}

	var rhtml = /<|&#?\w+;/;

	function buildFragment(elems, context, scripts, selection, ignored) {
		var elem,
		    tmp,
		    tag,
		    wrap,
		    contains,
		    j,
		    fragment = context.createDocumentFragment(),
		    nodes = [],
		    i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			elem = elems[i];

			if (elem || elem === 0) {

				// Add nodes directly
				if (jQuery.type(elem) === "object") {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

					// Convert non-html into a text node
				} else if (!rhtml.test(elem)) {
						nodes.push(context.createTextNode(elem));

						// Convert html into DOM nodes
					} else {
							tmp = tmp || fragment.appendChild(context.createElement("div"));

							// Deserialize a standard representation
							tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
							wrap = wrapMap[tag] || wrapMap._default;
							tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

							// Descend through wrappers to the right content
							j = wrap[0];
							while (j--) {
								tmp = tmp.lastChild;
							}

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(nodes, tmp.childNodes);

							// Remember the top-level container
							tmp = fragment.firstChild;

							// Ensure the created nodes are orphaned (#12392)
							tmp.textContent = "";
						}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while (elem = nodes[i++]) {

			// Skip elements already in the context collection (trac-4087)
			if (selection && jQuery.inArray(elem, selection) > -1) {
				if (ignored) {
					ignored.push(elem);
				}
				continue;
			}

			contains = jQuery.contains(elem.ownerDocument, elem);

			// Append to fragment
			tmp = getAll(fragment.appendChild(elem), "script");

			// Preserve script evaluation history
			if (contains) {
				setGlobalEval(tmp);
			}

			// Capture executables
			if (scripts) {
				j = 0;
				while (elem = tmp[j++]) {
					if (rscriptType.test(elem.type || "")) {
						scripts.push(elem);
					}
				}
			}
		}

		return fragment;
	}

	(function () {
		var fragment = document.createDocumentFragment(),
		    div = fragment.appendChild(document.createElement("div")),
		    input = document.createElement("input");

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute("type", "radio");
		input.setAttribute("checked", "checked");
		input.setAttribute("name", "t");

		div.appendChild(input);

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
	})();

	var rkeyEvent = /^key/,
	    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch (err) {}
	}

	function on(elem, types, selector, data, fn, one) {
		var origFn, type;

		// Types can be a map of types/handlers
		if (typeof types === "object") {

			// ( types-Object, selector, data )
			if (typeof selector !== "string") {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for (type in types) {
				on(elem, type, selector, data, types[type], one);
			}
			return elem;
		}

		if (data == null && fn == null) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if (fn == null) {
			if (typeof selector === "string") {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if (fn === false) {
			fn = returnFalse;
		} else if (!fn) {
			return elem;
		}

		if (one === 1) {
			origFn = fn;
			fn = function (event) {

				// Can use an empty set, since event contains the info
				jQuery().off(event);
				return origFn.apply(this, arguments);
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
		}
		return elem.each(function () {
			jQuery.event.add(this, types, fn, data, selector);
		});
	}

	/*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
	jQuery.event = {

		global: {},

		add: function (elem, types, handler, data, selector) {

			var handleObjIn,
			    eventHandle,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.get(elem);

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if (!elemData) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if (handler.handler) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if (!handler.guid) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if (!(events = elemData.events)) {
				events = elemData.events = {};
			}
			if (!(eventHandle = elemData.handle)) {
				eventHandle = elemData.handle = function (e) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// There *must* be a type, no attaching namespace-only handlers
				if (!type) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[type] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = (selector ? special.delegateType : special.bindType) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[type] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test(selector),
					namespace: namespaces.join(".")
				}, handleObjIn);

				// Init the event handler queue if we're the first
				if (!(handlers = events[type])) {
					handlers = events[type] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {

						if (elem.addEventListener) {
							elem.addEventListener(type, eventHandle);
						}
					}
				}

				if (special.add) {
					special.add.call(elem, handleObj);

					if (!handleObj.handler.guid) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if (selector) {
					handlers.splice(handlers.delegateCount++, 0, handleObj);
				} else {
					handlers.push(handleObj);
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[type] = true;
			}
		},

		// Detach an event or set of events from an element
		remove: function (elem, types, handler, selector, mappedTypes) {

			var j,
			    origCount,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

			if (!elemData || !(events = elemData.events)) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// Unbind all events (on this namespace, if provided) for the element
				if (!type) {
					for (type in events) {
						jQuery.event.remove(elem, type + types[t], handler, selector, true);
					}
					continue;
				}

				special = jQuery.event.special[type] || {};
				type = (selector ? special.delegateType : special.bindType) || type;
				handlers = events[type] || [];
				tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

				// Remove matching events
				origCount = j = handlers.length;
				while (j--) {
					handleObj = handlers[j];

					if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
						handlers.splice(j, 1);

						if (handleObj.selector) {
							handlers.delegateCount--;
						}
						if (special.remove) {
							special.remove.call(elem, handleObj);
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if (origCount && !handlers.length) {
					if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {

						jQuery.removeEvent(elem, type, elemData.handle);
					}

					delete events[type];
				}
			}

			// Remove data and the expando if it's no longer used
			if (jQuery.isEmptyObject(events)) {
				dataPriv.remove(elem, "handle events");
			}
		},

		dispatch: function (event) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix(event);

			var i,
			    j,
			    ret,
			    matched,
			    handleObj,
			    handlerQueue = [],
			    args = slice.call(arguments),
			    handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
			    special = jQuery.event.special[event.type] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if (special.preDispatch && special.preDispatch.call(this, event) === false) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call(this, event, handlers);

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
				event.currentTarget = matched.elem;

				j = 0;
				while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

						if (ret !== undefined) {
							if ((event.result = ret) === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if (special.postDispatch) {
				special.postDispatch.call(this, event);
			}

			return event.result;
		},

		handlers: function (event, handlers) {
			var i,
			    matches,
			    sel,
			    handleObj,
			    handlerQueue = [],
			    delegateCount = handlers.delegateCount,
			    cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {

				for (; cur !== this; cur = cur.parentNode || this) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
						matches = [];
						for (i = 0; i < delegateCount; i++) {
							handleObj = handlers[i];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if (matches[sel] === undefined) {
								matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
							}
							if (matches[sel]) {
								matches.push(handleObj);
							}
						}
						if (matches.length) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if (delegateCount < handlers.length) {
				handlerQueue.push({ elem: this, handlers: handlers.slice(delegateCount) });
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function (event, original) {

				// Add which for key events
				if (event.which == null) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
			filter: function (event, original) {
				var eventDoc,
				    doc,
				    body,
				    button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if (event.pageX == null && original.clientX != null) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
					event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if (!event.which && button !== undefined) {
					event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
				}

				return event;
			}
		},

		fix: function (event) {
			if (event[jQuery.expando]) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i,
			    prop,
			    copy,
			    type = event.type,
			    originalEvent = event,
			    fixHook = this.fixHooks[type];

			if (!fixHook) {
				this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
			}
			copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

			event = new jQuery.Event(originalEvent);

			i = copy.length;
			while (i--) {
				prop = copy[i];
				event[prop] = originalEvent[prop];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if (!event.target) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if (event.target.nodeType === 3) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function () {
					if (this !== safeActiveElement() && this.focus) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function () {
					if (this === safeActiveElement() && this.blur) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function () {
					if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function (event) {
					return jQuery.nodeName(event.target, "a");
				}
			},

			beforeunload: {
				postDispatch: function (event) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if (event.result !== undefined && event.originalEvent) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function (elem, type, handle) {

		// This "if" is needed for plain objects
		if (elem.removeEventListener) {
			elem.removeEventListener(type, handle);
		}
	};

	jQuery.Event = function (src, props) {

		// Allow instantiation without the 'new' keyword
		if (!(this instanceof jQuery.Event)) {
			return new jQuery.Event(src, props);
		}

		// Event object
		if (src && src.type) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&

			// Support: Android<4.0
			src.returnValue === false ? returnTrue : returnFalse;

			// Event type
		} else {
				this.type = src;
			}

		// Put explicitly provided properties onto the event object
		if (props) {
			jQuery.extend(this, props);
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[jQuery.expando] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function () {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if (e) {
				e.preventDefault();
			}
		},
		stopPropagation: function () {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if (e) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function () {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if (e) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function (orig, fix) {
		jQuery.event.special[orig] = {
			delegateType: fix,
			bindType: fix,

			handle: function (event) {
				var ret,
				    target = this,
				    related = event.relatedTarget,
				    handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if (!related || related !== target && !jQuery.contains(target, related)) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply(this, arguments);
					event.type = fix;
				}
				return ret;
			}
		};
	});

	jQuery.fn.extend({
		on: function (types, selector, data, fn) {
			return on(this, types, selector, data, fn);
		},
		one: function (types, selector, data, fn) {
			return on(this, types, selector, data, fn, 1);
		},
		off: function (types, selector, fn) {
			var handleObj, type;
			if (types && types.preventDefault && types.handleObj) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
				return this;
			}
			if (typeof types === "object") {

				// ( types-object [, selector] )
				for (type in types) {
					this.off(type, selector, types[type]);
				}
				return this;
			}
			if (selector === false || typeof selector === "function") {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if (fn === false) {
				fn = returnFalse;
			}
			return this.each(function () {
				jQuery.event.remove(this, types, fn, selector);
			});
		}
	});

	var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,


	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,


	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	    rscriptTypeMasked = /^true\/(.*)/,
	    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Manipulating tables requires a tbody
	function manipulationTarget(elem, content) {
		return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript(elem) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript(elem) {
		var match = rscriptTypeMasked.exec(elem.type);

		if (match) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	function cloneCopyEvent(src, dest) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if (dest.nodeType !== 1) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if (dataPriv.hasData(src)) {
			pdataOld = dataPriv.access(src);
			pdataCur = dataPriv.set(dest, pdataOld);
			events = pdataOld.events;

			if (events) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for (type in events) {
					for (i = 0, l = events[type].length; i < l; i++) {
						jQuery.event.add(dest, type, events[type][i]);
					}
				}
			}
		}

		// 2. Copy user data
		if (dataUser.hasData(src)) {
			udataOld = dataUser.access(src);
			udataCur = jQuery.extend({}, udataOld);

			dataUser.set(dest, udataCur);
		}
	}

	// Fix IE bugs, see support tests
	function fixInput(src, dest) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if (nodeName === "input" && rcheckableType.test(src.type)) {
			dest.checked = src.checked;

			// Fails to return the selected option to the default selected state when cloning options
		} else if (nodeName === "input" || nodeName === "textarea") {
				dest.defaultValue = src.defaultValue;
			}
	}

	function domManip(collection, args, callback, ignored) {

		// Flatten any nested arrays
		args = concat.apply([], args);

		var fragment,
		    first,
		    scripts,
		    hasScripts,
		    node,
		    doc,
		    i = 0,
		    l = collection.length,
		    iNoClone = l - 1,
		    value = args[0],
		    isFunction = jQuery.isFunction(value);

		// We can't cloneNode fragments that contain checked, in WebKit
		if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
			return collection.each(function (index) {
				var self = collection.eq(index);
				if (isFunction) {
					args[0] = value.call(this, index, self.html());
				}
				domManip(self, args, callback, ignored);
			});
		}

		if (l) {
			fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
			first = fragment.firstChild;

			if (fragment.childNodes.length === 1) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if (first || ignored) {
				scripts = jQuery.map(getAll(fragment, "script"), disableScript);
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for (; i < l; i++) {
					node = fragment;

					if (i !== iNoClone) {
						node = jQuery.clone(node, true, true);

						// Keep references to cloned scripts for later restoration
						if (hasScripts) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(scripts, getAll(node, "script"));
						}
					}

					callback.call(collection[i], node, i);
				}

				if (hasScripts) {
					doc = scripts[scripts.length - 1].ownerDocument;

					// Reenable scripts
					jQuery.map(scripts, restoreScript);

					// Evaluate executable scripts on first document insertion
					for (i = 0; i < hasScripts; i++) {
						node = scripts[i];
						if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {

							if (node.src) {

								// Optional AJAX dependency, but won't run scripts if not present
								if (jQuery._evalUrl) {
									jQuery._evalUrl(node.src);
								}
							} else {
								jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove(elem, selector, keepData) {
		var node,
		    nodes = selector ? jQuery.filter(selector, elem) : elem,
		    i = 0;

		for (; (node = nodes[i]) != null; i++) {
			if (!keepData && node.nodeType === 1) {
				jQuery.cleanData(getAll(node));
			}

			if (node.parentNode) {
				if (keepData && jQuery.contains(node.ownerDocument, node)) {
					setGlobalEval(getAll(node, "script"));
				}
				node.parentNode.removeChild(node);
			}
		}

		return elem;
	}

	jQuery.extend({
		htmlPrefilter: function (html) {
			return html.replace(rxhtmlTag, "<$1></$2>");
		},

		clone: function (elem, dataAndEvents, deepDataAndEvents) {
			var i,
			    l,
			    srcElements,
			    destElements,
			    clone = elem.cloneNode(true),
			    inPage = jQuery.contains(elem.ownerDocument, elem);

			// Fix IE cloning issues
			if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll(clone);
				srcElements = getAll(elem);

				for (i = 0, l = srcElements.length; i < l; i++) {
					fixInput(srcElements[i], destElements[i]);
				}
			}

			// Copy the events from the original to the clone
			if (dataAndEvents) {
				if (deepDataAndEvents) {
					srcElements = srcElements || getAll(elem);
					destElements = destElements || getAll(clone);

					for (i = 0, l = srcElements.length; i < l; i++) {
						cloneCopyEvent(srcElements[i], destElements[i]);
					}
				} else {
					cloneCopyEvent(elem, clone);
				}
			}

			// Preserve script evaluation history
			destElements = getAll(clone, "script");
			if (destElements.length > 0) {
				setGlobalEval(destElements, !inPage && getAll(elem, "script"));
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function (elems) {
			var data,
			    elem,
			    type,
			    special = jQuery.event.special,
			    i = 0;

			for (; (elem = elems[i]) !== undefined; i++) {
				if (acceptData(elem)) {
					if (data = elem[dataPriv.expando]) {
						if (data.events) {
							for (type in data.events) {
								if (special[type]) {
									jQuery.event.remove(elem, type);

									// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
										jQuery.removeEvent(elem, type, data.handle);
									}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataPriv.expando] = undefined;
					}
					if (elem[dataUser.expando]) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataUser.expando] = undefined;
					}
				}
			}
		}
	});

	jQuery.fn.extend({

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function (selector) {
			return remove(this, selector, true);
		},

		remove: function (selector) {
			return remove(this, selector);
		},

		text: function (value) {
			return access(this, function (value) {
				return value === undefined ? jQuery.text(this) : this.empty().each(function () {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						this.textContent = value;
					}
				});
			}, null, value, arguments.length);
		},

		append: function () {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.appendChild(elem);
				}
			});
		},

		prepend: function () {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.insertBefore(elem, target.firstChild);
				}
			});
		},

		before: function () {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this);
				}
			});
		},

		after: function () {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this.nextSibling);
				}
			});
		},

		empty: function () {
			var elem,
			    i = 0;

			for (; (elem = this[i]) != null; i++) {
				if (elem.nodeType === 1) {

					// Prevent memory leaks
					jQuery.cleanData(getAll(elem, false));

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function (dataAndEvents, deepDataAndEvents) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function () {
				return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
			});
		},

		html: function (value) {
			return access(this, function (value) {
				var elem = this[0] || {},
				    i = 0,
				    l = this.length;

				if (value === undefined && elem.nodeType === 1) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

					value = jQuery.htmlPrefilter(value);

					try {
						for (; i < l; i++) {
							elem = this[i] || {};

							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
								elem.innerHTML = value;
							}
						}

						elem = 0;

						// If using innerHTML throws an exception, use the fallback method
					} catch (e) {}
				}

				if (elem) {
					this.empty().append(value);
				}
			}, null, value, arguments.length);
		},

		replaceWith: function () {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip(this, arguments, function (elem) {
				var parent = this.parentNode;

				if (jQuery.inArray(this, ignored) < 0) {
					jQuery.cleanData(getAll(this));
					if (parent) {
						parent.replaceChild(elem, this);
					}
				}

				// Force callback invocation
			}, ignored);
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function (name, original) {
		jQuery.fn[name] = function (selector) {
			var elems,
			    ret = [],
			    insert = jQuery(selector),
			    last = insert.length - 1,
			    i = 0;

			for (; i <= last; i++) {
				elems = i === last ? this : this.clone(true);
				jQuery(insert[i])[original](elems);

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply(ret, elems.get());
			}

			return this.pushStack(ret);
		};
	});

	var iframe,
	    elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

	/**
  * Retrieve the actual display of a element
  * @param {String} name nodeName of the element
  * @param {Object} doc Document object
  */

	// Called only from within defaultDisplay
	function actualDisplay(name, doc) {
		var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
		    display = jQuery.css(elem[0], "display");

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
  * Try to determine the default display value of an element
  * @param {String} nodeName
  */
	function defaultDisplay(nodeName) {
		var doc = document,
		    display = elemdisplay[nodeName];

		if (!display) {
			display = actualDisplay(nodeName, doc);

			// If the simple way fails, read from inside an iframe
			if (display === "none" || !display) {

				// Use the already-created iframe if possible
				iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[0].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay(nodeName, doc);
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[nodeName] = display;
		}

		return display;
	}
	var rmargin = /^margin/;

	var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	var getStyles = function (elem) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if (!view || !view.opener) {
			view = window;
		}

		return view.getComputedStyle(elem);
	};

	var swap = function (elem, options, callback, args) {
		var ret,
		    name,
		    old = {};

		// Remember the old values, and insert the new ones
		for (name in options) {
			old[name] = elem.style[name];
			elem.style[name] = options[name];
		}

		ret = callback.apply(elem, args || []);

		// Revert the old values
		for (name in options) {
			elem.style[name] = old[name];
		}

		return ret;
	};

	var documentElement = document.documentElement;

	(function () {
		var pixelPositionVal,
		    boxSizingReliableVal,
		    pixelMarginRightVal,
		    reliableMarginLeftVal,
		    container = document.createElement("div"),
		    div = document.createElement("div");

		// Finish early in limited (non-browser) environments
		if (!div.style) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode(true).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
		container.appendChild(div);

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild(container);

			var divStyle = window.getComputedStyle(div);
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild(container);
		}

		jQuery.extend(support, {
			pixelPosition: function () {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function () {
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function () {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function () {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function () {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
				    marginDiv = div.appendChild(document.createElement("div"));

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild(container);

				ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);

				documentElement.removeChild(container);
				div.removeChild(marginDiv);

				return ret;
			}
		});
	})();

	function curCSS(elem, name, computed) {
		var width,
		    minWidth,
		    maxWidth,
		    ret,
		    style = elem.style;

		computed = computed || getStyles(elem);
		ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
			ret = jQuery.style(elem, name);
		}

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if (computed) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" : ret;
	}

	function addGetHookIf(conditionFn, hookFn) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function () {
				if (conditionFn()) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply(this, arguments);
			}
		};
	}

	var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	    cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},
	    cssPrefixes = ["Webkit", "O", "Moz", "ms"],
	    emptyStyle = document.createElement("div").style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName(name) {

		// Shortcut for names that are not vendor prefixed
		if (name in emptyStyle) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
		    i = cssPrefixes.length;

		while (i--) {
			name = cssPrefixes[i] + capName;
			if (name in emptyStyle) {
				return name;
			}
		}
	}

	function setPositiveNumber(elem, value, subtract) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec(value);
		return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
	}

	function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
		var i = extra === (isBorderBox ? "border" : "content") ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,
		    val = 0;

		for (; i < 4; i += 2) {

			// Both box models exclude margin, so add it if we want it
			if (extra === "margin") {
				val += jQuery.css(elem, extra + cssExpand[i], true, styles);
			}

			if (isBorderBox) {

				// border-box includes padding, so remove it if we want content
				if (extra === "content") {
					val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
				}

				// At this point, extra isn't border nor margin, so remove border
				if (extra !== "margin") {
					val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

				// At this point, extra isn't content nor padding, so add border
				if (extra !== "padding") {
					val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			}
		}

		return val;
	}

	function getWidthOrHeight(elem, name, extra) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
		    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		    styles = getStyles(elem),
		    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

		// Support: IE11 only
		// In IE 11 fullscreen elements inside of an iframe have
		// 100x too small dimensions (gh-1764).
		if (document.msFullscreenElement && window.top !== window) {

			// Support: IE11 only
			// Running getBoundingClientRect on a disconnected node
			// in IE throws an error.
			if (elem.getClientRects().length) {
				val = Math.round(elem.getBoundingClientRect()[name] * 100);
			}
		}

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if (val <= 0 || val == null) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS(elem, name, styles);
			if (val < 0 || val == null) {
				val = elem.style[name];
			}

			// Computed unit is not pixels. Stop here and return.
			if (rnumnonpx.test(val)) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

			// Normalize "", auto, and prepare for extra
			val = parseFloat(val) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
	}

	function showHide(elements, show) {
		var display,
		    elem,
		    hidden,
		    values = [],
		    index = 0,
		    length = elements.length;

		for (; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}

			values[index] = dataPriv.get(elem, "olddisplay");
			display = elem.style.display;
			if (show) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if (!values[index] && display === "none") {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if (elem.style.display === "" && isHidden(elem)) {
					values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
				}
			} else {
				hidden = isHidden(elem);

				if (display !== "none" || !hidden) {
					dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for (index = 0; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}
			if (!show || elem.style.display === "none" || elem.style.display === "") {
				elem.style.display = show ? values[index] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function (elem, computed) {
					if (computed) {

						// We should always get a number back from opacity
						var ret = curCSS(elem, "opacity");
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function (elem, name, value, extra) {

			// Don't set styles on text and comment nodes
			if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
				return;
			}

			// Make sure that we're working with the right name
			var ret,
			    type,
			    hooks,
			    origName = jQuery.camelCase(name),
			    style = elem.style;

			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// Check if we're setting a value
			if (value !== undefined) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
					value = adjustCSS(elem, name, ret);

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if (value == null || value !== value) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if (type === "number") {
					value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
					style[name] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {

					style[name] = value;
				}
			} else {

				// If a hook was provided get the non-computed value from there
				if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[name];
			}
		},

		css: function (elem, name, extra, styles) {
			var val,
			    num,
			    hooks,
			    origName = jQuery.camelCase(name);

			// Make sure that we're working with the right name
			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// If a hook was provided get the computed value from there
			if (hooks && "get" in hooks) {
				val = hooks.get(elem, true, extra);
			}

			// Otherwise, if a way to get the computed value exists, use that
			if (val === undefined) {
				val = curCSS(elem, name, styles);
			}

			// Convert "normal" to computed value
			if (val === "normal" && name in cssNormalTransform) {
				val = cssNormalTransform[name];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if (extra === "" || extra) {
				num = parseFloat(val);
				return extra === true || isFinite(num) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each(["height", "width"], function (i, name) {
		jQuery.cssHooks[name] = {
			get: function (elem, computed, extra) {
				if (computed) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function () {
						return getWidthOrHeight(elem, name, extra);
					}) : getWidthOrHeight(elem, name, extra);
				}
			},

			set: function (elem, value, extra) {
				var matches,
				    styles = extra && getStyles(elem),
				    subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);

				// Convert to pixels if value adjustment is needed
				if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {

					elem.style[name] = value;
					value = jQuery.css(elem, name);
				}

				return setPositiveNumber(elem, value, subtract);
			}
		};
	});

	jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
		if (computed) {
			return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
				return elem.getBoundingClientRect().left;
			})) + "px";
		}
	});

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
		if (computed) {
			return swap(elem, { "display": "inline-block" }, curCSS, [elem, "marginRight"]);
		}
	});

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function (prefix, suffix) {
		jQuery.cssHooks[prefix + suffix] = {
			expand: function (value) {
				var i = 0,
				    expanded = {},


				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [value];

				for (; i < 4; i++) {
					expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
				}

				return expanded;
			}
		};

		if (!rmargin.test(prefix)) {
			jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function (name, value) {
			return access(this, function (elem, name, value) {
				var styles,
				    len,
				    map = {},
				    i = 0;

				if (jQuery.isArray(name)) {
					styles = getStyles(elem);
					len = name.length;

					for (; i < len; i++) {
						map[name[i]] = jQuery.css(elem, name[i], false, styles);
					}

					return map;
				}

				return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
			}, name, value, arguments.length > 1);
		},
		show: function () {
			return showHide(this, true);
		},
		hide: function () {
			return showHide(this);
		},
		toggle: function (state) {
			if (typeof state === "boolean") {
				return state ? this.show() : this.hide();
			}

			return this.each(function () {
				if (isHidden(this)) {
					jQuery(this).show();
				} else {
					jQuery(this).hide();
				}
			});
		}
	});

	function Tween(elem, options, prop, end, easing) {
		return new Tween.prototype.init(elem, options, prop, end, easing);
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function (elem, options, prop, end, easing, unit) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
		},
		cur: function () {
			var hooks = Tween.propHooks[this.prop];

			return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
		},
		run: function (percent) {
			var eased,
			    hooks = Tween.propHooks[this.prop];

			if (this.options.duration) {
				this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
			} else {
				this.pos = eased = percent;
			}
			this.now = (this.end - this.start) * eased + this.start;

			if (this.options.step) {
				this.options.step.call(this.elem, this.now, this);
			}

			if (hooks && hooks.set) {
				hooks.set(this);
			} else {
				Tween.propHooks._default.set(this);
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function (tween) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
					return tween.elem[tween.prop];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css(tween.elem, tween.prop, "");

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function (tween) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if (jQuery.fx.step[tween.prop]) {
					jQuery.fx.step[tween.prop](tween);
				} else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
					jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
				} else {
					tween.elem[tween.prop] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function (tween) {
			if (tween.elem.nodeType && tween.elem.parentNode) {
				tween.elem[tween.prop] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function (p) {
			return p;
		},
		swing: function (p) {
			return 0.5 - Math.cos(p * Math.PI) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};

	var fxNow,
	    timerId,
	    rfxtypes = /^(?:toggle|show|hide)$/,
	    rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout(function () {
			fxNow = undefined;
		});
		return fxNow = jQuery.now();
	}

	// Generate parameters to create a standard animation
	function genFx(type, includeWidth) {
		var which,
		    i = 0,
		    attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for (; i < 4; i += 2 - includeWidth) {
			which = cssExpand[i];
			attrs["margin" + which] = attrs["padding" + which] = type;
		}

		if (includeWidth) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween(value, prop, animation) {
		var tween,
		    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
		    index = 0,
		    length = collection.length;
		for (; index < length; index++) {
			if (tween = collection[index].call(animation, prop, value)) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter(elem, props, opts) {
		/* jshint validthis: true */
		var prop,
		    value,
		    toggle,
		    tween,
		    hooks,
		    oldfire,
		    display,
		    checkDisplay,
		    anim = this,
		    orig = {},
		    style = elem.style,
		    hidden = elem.nodeType && isHidden(elem),
		    dataShow = dataPriv.get(elem, "fxshow");

		// Handle queue: false promises
		if (!opts.queue) {
			hooks = jQuery._queueHooks(elem, "fx");
			if (hooks.unqueued == null) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function () {
					if (!hooks.unqueued) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function () {

				// Ensure the complete handler is called before this completes
				anim.always(function () {
					hooks.unqueued--;
					if (!jQuery.queue(elem, "fx").length) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Height/width overflow pass
		if (elem.nodeType === 1 && ("height" in props || "width" in props)) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [style.overflow, style.overflowX, style.overflowY];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css(elem, "display");

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

			if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
				style.display = "inline-block";
			}
		}

		if (opts.overflow) {
			style.overflow = "hidden";
			anim.always(function () {
				style.overflow = opts.overflow[0];
				style.overflowX = opts.overflow[1];
				style.overflowY = opts.overflow[2];
			});
		}

		// show/hide pass
		for (prop in props) {
			value = props[prop];
			if (rfxtypes.exec(value)) {
				delete props[prop];
				toggle = toggle || value === "toggle";
				if (value === (hidden ? "hide" : "show")) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if (value === "show" && dataShow && dataShow[prop] !== undefined) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

				// Any non-fx value stops us from restoring the original display value
			} else {
					display = undefined;
				}
		}

		if (!jQuery.isEmptyObject(orig)) {
			if (dataShow) {
				if ("hidden" in dataShow) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access(elem, "fxshow", {});
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if (toggle) {
				dataShow.hidden = !hidden;
			}
			if (hidden) {
				jQuery(elem).show();
			} else {
				anim.done(function () {
					jQuery(elem).hide();
				});
			}
			anim.done(function () {
				var prop;

				dataPriv.remove(elem, "fxshow");
				for (prop in orig) {
					jQuery.style(elem, prop, orig[prop]);
				}
			});
			for (prop in orig) {
				tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

				if (!(prop in dataShow)) {
					dataShow[prop] = tween.start;
					if (hidden) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

			// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
				style.display = display;
			}
	}

	function propFilter(props, specialEasing) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for (index in props) {
			name = jQuery.camelCase(index);
			easing = specialEasing[name];
			value = props[index];
			if (jQuery.isArray(value)) {
				easing = value[1];
				value = props[index] = value[0];
			}

			if (index !== name) {
				props[name] = value;
				delete props[index];
			}

			hooks = jQuery.cssHooks[name];
			if (hooks && "expand" in hooks) {
				value = hooks.expand(value);
				delete props[name];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for (index in value) {
					if (!(index in props)) {
						props[index] = value[index];
						specialEasing[index] = easing;
					}
				}
			} else {
				specialEasing[name] = easing;
			}
		}
	}

	function Animation(elem, properties, options) {
		var result,
		    stopped,
		    index = 0,
		    length = Animation.prefilters.length,
		    deferred = jQuery.Deferred().always(function () {

			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		    tick = function () {
			if (stopped) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
			    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),


			// Support: Android 2.3
			// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
			temp = remaining / animation.duration || 0,
			    percent = 1 - temp,
			    index = 0,
			    length = animation.tweens.length;

			for (; index < length; index++) {
				animation.tweens[index].run(percent);
			}

			deferred.notifyWith(elem, [animation, percent, remaining]);

			if (percent < 1 && length) {
				return remaining;
			} else {
				deferred.resolveWith(elem, [animation]);
				return false;
			}
		},
		    animation = deferred.promise({
			elem: elem,
			props: jQuery.extend({}, properties),
			opts: jQuery.extend(true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function (prop, end) {
				var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
				animation.tweens.push(tween);
				return tween;
			},
			stop: function (gotoEnd) {
				var index = 0,


				// If we are going to the end, we want to run all the tweens
				// otherwise we skip this part
				length = gotoEnd ? animation.tweens.length : 0;
				if (stopped) {
					return this;
				}
				stopped = true;
				for (; index < length; index++) {
					animation.tweens[index].run(1);
				}

				// Resolve when we played the last frame; otherwise, reject
				if (gotoEnd) {
					deferred.notifyWith(elem, [animation, 1, 0]);
					deferred.resolveWith(elem, [animation, gotoEnd]);
				} else {
					deferred.rejectWith(elem, [animation, gotoEnd]);
				}
				return this;
			}
		}),
		    props = animation.props;

		propFilter(props, animation.opts.specialEasing);

		for (; index < length; index++) {
			result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
			if (result) {
				if (jQuery.isFunction(result.stop)) {
					jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
				}
				return result;
			}
		}

		jQuery.map(props, createTween, animation);

		if (jQuery.isFunction(animation.opts.start)) {
			animation.opts.start.call(elem, animation);
		}

		jQuery.fx.timer(jQuery.extend(tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		}));

		// attach callbacks from options
		return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	}

	jQuery.Animation = jQuery.extend(Animation, {
		tweeners: {
			"*": [function (prop, value) {
				var tween = this.createTween(prop, value);
				adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
				return tween;
			}]
		},

		tweener: function (props, callback) {
			if (jQuery.isFunction(props)) {
				callback = props;
				props = ["*"];
			} else {
				props = props.match(rnotwhite);
			}

			var prop,
			    index = 0,
			    length = props.length;

			for (; index < length; index++) {
				prop = props[index];
				Animation.tweeners[prop] = Animation.tweeners[prop] || [];
				Animation.tweeners[prop].unshift(callback);
			}
		},

		prefilters: [defaultPrefilter],

		prefilter: function (callback, prepend) {
			if (prepend) {
				Animation.prefilters.unshift(callback);
			} else {
				Animation.prefilters.push(callback);
			}
		}
	});

	jQuery.speed = function (speed, easing, fn) {
		var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if (opt.queue == null || opt.queue === true) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function () {
			if (jQuery.isFunction(opt.old)) {
				opt.old.call(this);
			}

			if (opt.queue) {
				jQuery.dequeue(this, opt.queue);
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function (speed, to, easing, callback) {

			// Show any hidden elements after setting opacity to 0
			return this.filter(isHidden).css("opacity", 0).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback);
		},
		animate: function (prop, speed, easing, callback) {
			var empty = jQuery.isEmptyObject(prop),
			    optall = jQuery.speed(speed, easing, callback),
			    doAnimation = function () {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation(this, jQuery.extend({}, prop), optall);

				// Empty animations, or finishing resolves immediately
				if (empty || dataPriv.get(this, "finish")) {
					anim.stop(true);
				}
			};
			doAnimation.finish = doAnimation;

			return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
		},
		stop: function (type, clearQueue, gotoEnd) {
			var stopQueue = function (hooks) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop(gotoEnd);
			};

			if (typeof type !== "string") {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if (clearQueue && type !== false) {
				this.queue(type || "fx", []);
			}

			return this.each(function () {
				var dequeue = true,
				    index = type != null && type + "queueHooks",
				    timers = jQuery.timers,
				    data = dataPriv.get(this);

				if (index) {
					if (data[index] && data[index].stop) {
						stopQueue(data[index]);
					}
				} else {
					for (index in data) {
						if (data[index] && data[index].stop && rrun.test(index)) {
							stopQueue(data[index]);
						}
					}
				}

				for (index = timers.length; index--;) {
					if (timers[index].elem === this && (type == null || timers[index].queue === type)) {

						timers[index].anim.stop(gotoEnd);
						dequeue = false;
						timers.splice(index, 1);
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if (dequeue || !gotoEnd) {
					jQuery.dequeue(this, type);
				}
			});
		},
		finish: function (type) {
			if (type !== false) {
				type = type || "fx";
			}
			return this.each(function () {
				var index,
				    data = dataPriv.get(this),
				    queue = data[type + "queue"],
				    hooks = data[type + "queueHooks"],
				    timers = jQuery.timers,
				    length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue(this, type, []);

				if (hooks && hooks.stop) {
					hooks.stop.call(this, true);
				}

				// Look for any active animations, and finish them
				for (index = timers.length; index--;) {
					if (timers[index].elem === this && timers[index].queue === type) {
						timers[index].anim.stop(true);
						timers.splice(index, 1);
					}
				}

				// Look for any animations in the old queue and finish them
				for (index = 0; index < length; index++) {
					if (queue[index] && queue[index].finish) {
						queue[index].finish.call(this);
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each(["toggle", "show", "hide"], function (i, name) {
		var cssFn = jQuery.fn[name];
		jQuery.fn[name] = function (speed, easing, callback) {
			return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function (name, props) {
		jQuery.fn[name] = function (speed, easing, callback) {
			return this.animate(props, speed, easing, callback);
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function () {
		var timer,
		    i = 0,
		    timers = jQuery.timers;

		fxNow = jQuery.now();

		for (; i < timers.length; i++) {
			timer = timers[i];

			// Checks the timer has not already been removed
			if (!timer() && timers[i] === timer) {
				timers.splice(i--, 1);
			}
		}

		if (!timers.length) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function (timer) {
		jQuery.timers.push(timer);
		if (timer()) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function () {
		if (!timerId) {
			timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
		}
	};

	jQuery.fx.stop = function () {
		window.clearInterval(timerId);

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};

	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function (time, type) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue(type, function (next, hooks) {
			var timeout = window.setTimeout(next, time);
			hooks.stop = function () {
				window.clearTimeout(timeout);
			};
		});
	};

	(function () {
		var input = document.createElement("input"),
		    select = document.createElement("select"),
		    opt = select.appendChild(document.createElement("option"));

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement("input");
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();

	var boolHook,
	    attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function (name, value) {
			return access(this, jQuery.attr, name, value, arguments.length > 1);
		},

		removeAttr: function (name) {
			return this.each(function () {
				jQuery.removeAttr(this, name);
			});
		}
	});

	jQuery.extend({
		attr: function (elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if (typeof elem.getAttribute === "undefined") {
				return jQuery.prop(elem, name, value);
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
			}

			if (value !== undefined) {
				if (value === null) {
					jQuery.removeAttr(elem, name);
					return;
				}

				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				elem.setAttribute(name, value + "");
				return value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			ret = jQuery.find.attr(elem, name);

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function (elem, value) {
					if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
						var val = elem.value;
						elem.setAttribute("type", value);
						if (val) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function (elem, value) {
			var name,
			    propName,
			    i = 0,
			    attrNames = value && value.match(rnotwhite);

			if (attrNames && elem.nodeType === 1) {
				while (name = attrNames[i++]) {
					propName = jQuery.propFix[name] || name;

					// Boolean attributes get special treatment (#10870)
					if (jQuery.expr.match.bool.test(name)) {

						// Set corresponding property to false
						elem[propName] = false;
					}

					elem.removeAttribute(name);
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function (elem, value, name) {
			if (value === false) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr(elem, name);
			} else {
				elem.setAttribute(name, name);
			}
			return name;
		}
	};
	jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
		var getter = attrHandle[name] || jQuery.find.attr;

		attrHandle[name] = function (elem, name, isXML) {
			var ret, handle;
			if (!isXML) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[name];
				attrHandle[name] = ret;
				ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
				attrHandle[name] = handle;
			}
			return ret;
		};
	});

	var rfocusable = /^(?:input|select|textarea|button)$/i,
	    rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend({
		prop: function (name, value) {
			return access(this, jQuery.prop, name, value, arguments.length > 1);
		},

		removeProp: function (name) {
			return this.each(function () {
				delete this[jQuery.propFix[name] || name];
			});
		}
	});

	jQuery.extend({
		prop: function (elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

				// Fix name and attach hooks
				name = jQuery.propFix[name] || name;
				hooks = jQuery.propHooks[name];
			}

			if (value !== undefined) {
				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				return elem[name] = value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			return elem[name];
		},

		propHooks: {
			tabIndex: {
				get: function (elem) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr(elem, "tabindex");

					return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	});

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if (!support.optSelected) {
		jQuery.propHooks.selected = {
			get: function (elem) {
				var parent = elem.parentNode;
				if (parent && parent.parentNode) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function (elem) {
				var parent = elem.parentNode;
				if (parent) {
					parent.selectedIndex;

					if (parent.parentNode) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		jQuery.propFix[this.toLowerCase()] = this;
	});

	var rclass = /[\t\r\n\f]/g;

	function getClass(elem) {
		return elem.getAttribute && elem.getAttribute("class") || "";
	}

	jQuery.fn.extend({
		addClass: function (value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).addClass(value.call(this, j, getClass(this)));
				});
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);
					cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {
							if (cur.indexOf(" " + clazz + " ") < 0) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		removeClass: function (value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).removeClass(value.call(this, j, getClass(this)));
				});
			}

			if (!arguments.length) {
				return this.attr("class", "");
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {

							// Remove *all* instances
							while (cur.indexOf(" " + clazz + " ") > -1) {
								cur = cur.replace(" " + clazz + " ", " ");
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		toggleClass: function (value, stateVal) {
			var type = typeof value;

			if (typeof stateVal === "boolean" && type === "string") {
				return stateVal ? this.addClass(value) : this.removeClass(value);
			}

			if (jQuery.isFunction(value)) {
				return this.each(function (i) {
					jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
				});
			}

			return this.each(function () {
				var className, i, self, classNames;

				if (type === "string") {

					// Toggle individual class names
					i = 0;
					self = jQuery(this);
					classNames = value.match(rnotwhite) || [];

					while (className = classNames[i++]) {

						// Check each className given, space separated list
						if (self.hasClass(className)) {
							self.removeClass(className);
						} else {
							self.addClass(className);
						}
					}

					// Toggle whole class name
				} else if (value === undefined || type === "boolean") {
						className = getClass(this);
						if (className) {

							// Store className if set
							dataPriv.set(this, "__className__", className);
						}

						// If the element has a class name or if we're passed `false`,
						// then remove the whole classname (if there was one, the above saved it).
						// Otherwise bring back whatever was previously saved (if anything),
						// falling back to the empty string if nothing was stored.
						if (this.setAttribute) {
							this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
						}
					}
			});
		},

		hasClass: function (selector) {
			var className,
			    elem,
			    i = 0;

			className = " " + selector + " ";
			while (elem = this[i++]) {
				if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
					return true;
				}
			}

			return false;
		}
	});

	var rreturn = /\r/g,
	    rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend({
		val: function (value) {
			var hooks,
			    ret,
			    isFunction,
			    elem = this[0];

			if (!arguments.length) {
				if (elem) {
					hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

					if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace(rreturn, "") :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction(value);

			return this.each(function (i) {
				var val;

				if (this.nodeType !== 1) {
					return;
				}

				if (isFunction) {
					val = value.call(this, i, jQuery(this).val());
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if (val == null) {
					val = "";
				} else if (typeof val === "number") {
					val += "";
				} else if (jQuery.isArray(val)) {
					val = jQuery.map(val, function (value) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

				// If set returns undefined, fall back to normal setting
				if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function (elem) {

					var val = jQuery.find.attr(elem, "value");
					return val != null ? val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
				}
			},
			select: {
				get: function (elem) {
					var value,
					    option,
					    options = elem.options,
					    index = elem.selectedIndex,
					    one = elem.type === "select-one" || index < 0,
					    values = one ? null : [],
					    max = one ? index + 1 : options.length,
					    i = index < 0 ? max : one ? index : 0;

					// Loop through all the selected options
					for (; i < max; i++) {
						option = options[i];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ((option.selected || i === index) && (

						// Don't return options that are disabled or in a disabled optgroup
						support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if (one) {
								return value;
							}

							// Multi-Selects return an array
							values.push(value);
						}
					}

					return values;
				},

				set: function (elem, value) {
					var optionSet,
					    option,
					    options = elem.options,
					    values = jQuery.makeArray(value),
					    i = options.length;

					while (i--) {
						option = options[i];
						if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if (!optionSet) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each(["radio", "checkbox"], function () {
		jQuery.valHooks[this] = {
			set: function (elem, value) {
				if (jQuery.isArray(value)) {
					return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
				}
			}
		};
		if (!support.checkOn) {
			jQuery.valHooks[this].get = function (elem) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});

	// Return jQuery for attributes-only inclusion

	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend(jQuery.event, {

		trigger: function (event, data, elem, onlyHandlers) {

			var i,
			    cur,
			    tmp,
			    bubbleType,
			    ontype,
			    handle,
			    special,
			    eventPath = [elem || document],
			    type = hasOwn.call(event, "type") ? event.type : event,
			    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if (elem.nodeType === 3 || elem.nodeType === 8) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if (rfocusMorph.test(type + jQuery.event.triggered)) {
				return;
			}

			if (type.indexOf(".") > -1) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if (!event.target) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ? [event] : jQuery.makeArray(data, [event]);

			// Allow special events to draw outside the lines
			special = jQuery.event.special[type] || {};
			if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

				bubbleType = special.delegateType || type;
				if (!rfocusMorph.test(bubbleType + type)) {
					cur = cur.parentNode;
				}
				for (; cur; cur = cur.parentNode) {
					eventPath.push(cur);
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if (tmp === (elem.ownerDocument || document)) {
					eventPath.push(tmp.defaultView || tmp.parentWindow || window);
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

				event.type = i > 1 ? bubbleType : special.bindType || type;

				// jQuery handler
				handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
				if (handle) {
					handle.apply(cur, data);
				}

				// Native handler
				handle = ontype && cur[ontype];
				if (handle && handle.apply && acceptData(cur)) {
					event.result = handle.apply(cur, data);
					if (event.result === false) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if (!onlyHandlers && !event.isDefaultPrevented()) {

				if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ontype];

						if (tmp) {
							elem[ontype] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[type]();
						jQuery.event.triggered = undefined;

						if (tmp) {
							elem[ontype] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		simulate: function (type, elem, event) {
			var e = jQuery.extend(new jQuery.Event(), event, {
				type: type,
				isSimulated: true

				// Previously, `originalEvent: {}` was set here, so stopPropagation call
				// would not be triggered on donor event, since in our own
				// jQuery.event.stopPropagation function we had a check for existence of
				// originalEvent.stopPropagation method, so, consequently it would be a noop.
				//
				// But now, this "simulate" function is used only for events
				// for which stopPropagation() is noop, so there is no need for that anymore.
				//
				// For the 1.x branch though, guard for "click" and "submit"
				// events is still used, but was moved to jQuery.event.stopPropagation function
				// because `originalEvent` should point to the original event for the constancy
				// with other events and for more focused logic
			});

			jQuery.event.trigger(e, null, elem);

			if (e.isDefaultPrevented()) {
				event.preventDefault();
			}
		}

	});

	jQuery.fn.extend({

		trigger: function (type, data) {
			return this.each(function () {
				jQuery.event.trigger(type, data, this);
			});
		},
		triggerHandler: function (type, data) {
			var elem = this[0];
			if (elem) {
				return jQuery.event.trigger(type, data, elem, true);
			}
		}
	});

	jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

		// Handle event binding
		jQuery.fn[name] = function (data, fn) {
			return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
		};
	});

	jQuery.fn.extend({
		hover: function (fnOver, fnOut) {
			return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
		}
	});

	support.focusin = "onfocusin" in window;

	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if (!support.focusin) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function (event) {
				jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
			};

			jQuery.event.special[fix] = {
				setup: function () {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix);

					if (!attaches) {
						doc.addEventListener(orig, handler, true);
					}
					dataPriv.access(doc, fix, (attaches || 0) + 1);
				},
				teardown: function () {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix) - 1;

					if (!attaches) {
						doc.removeEventListener(orig, handler, true);
						dataPriv.remove(doc, fix);
					} else {
						dataPriv.access(doc, fix, attaches);
					}
				}
			};
		});
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = /\?/;

	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function (data) {
		return JSON.parse(data + "");
	};

	// Cross-browser xml parsing
	jQuery.parseXML = function (data) {
		var xml;
		if (!data || typeof data !== "string") {
			return null;
		}

		// Support: IE9
		try {
			xml = new window.DOMParser().parseFromString(data, "text/xml");
		} catch (e) {
			xml = undefined;
		}

		if (!xml || xml.getElementsByTagName("parsererror").length) {
			jQuery.error("Invalid XML: " + data);
		}
		return xml;
	};

	var rhash = /#.*$/,
	    rts = /([?&])_=[^&]*/,
	    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,


	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	    rnoContent = /^(?:GET|HEAD)$/,
	    rprotocol = /^\/\//,


	/* Prefilters
  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  * 2) These are called:
  *    - BEFORE asking for a transport
  *    - AFTER param serialization (s.data is a string if s.processData is true)
  * 3) key is the dataType
  * 4) the catchall symbol "*" can be used
  * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  */
	prefilters = {},


	/* Transports bindings
  * 1) key is the dataType
  * 2) the catchall symbol "*" can be used
  * 3) selection will start with transport dataType and THEN go to "*" if needed
  */
	transports = {},


	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*"),


	// Anchor tag for parsing the document origin
	originAnchor = document.createElement("a");
	originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports(structure) {

		// dataTypeExpression is optional and defaults to "*"
		return function (dataTypeExpression, func) {

			if (typeof dataTypeExpression !== "string") {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
			    i = 0,
			    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

			if (jQuery.isFunction(func)) {

				// For each dataType in the dataTypeExpression
				while (dataType = dataTypes[i++]) {

					// Prepend if requested
					if (dataType[0] === "+") {
						dataType = dataType.slice(1) || "*";
						(structure[dataType] = structure[dataType] || []).unshift(func);

						// Otherwise append
					} else {
							(structure[dataType] = structure[dataType] || []).push(func);
						}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

		var inspected = {},
		    seekingTransport = structure === transports;

		function inspect(dataType) {
			var selected;
			inspected[dataType] = true;
			jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
				var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
				if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {

					options.dataTypes.unshift(dataTypeOrTransport);
					inspect(dataTypeOrTransport);
					return false;
				} else if (seekingTransport) {
					return !(selected = dataTypeOrTransport);
				}
			});
			return selected;
		}

		return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend(target, src) {
		var key,
		    deep,
		    flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for (key in src) {
			if (src[key] !== undefined) {
				(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
			}
		}
		if (deep) {
			jQuery.extend(true, target, deep);
		}

		return target;
	}

	/* Handles responses to an ajax request:
  * - finds the right dataType (mediates between content-type and expected dataType)
  * - returns the corresponding response
  */
	function ajaxHandleResponses(s, jqXHR, responses) {

		var ct,
		    type,
		    finalDataType,
		    firstDataType,
		    contents = s.contents,
		    dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while (dataTypes[0] === "*") {
			dataTypes.shift();
			if (ct === undefined) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if (ct) {
			for (type in contents) {
				if (contents[type] && contents[type].test(ct)) {
					dataTypes.unshift(type);
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if (dataTypes[0] in responses) {
			finalDataType = dataTypes[0];
		} else {

			// Try convertible dataTypes
			for (type in responses) {
				if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
					finalDataType = type;
					break;
				}
				if (!firstDataType) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if (finalDataType) {
			if (finalDataType !== dataTypes[0]) {
				dataTypes.unshift(finalDataType);
			}
			return responses[finalDataType];
		}
	}

	/* Chain conversions given the request and the original response
  * Also sets the responseXXX fields on the jqXHR instance
  */
	function ajaxConvert(s, response, jqXHR, isSuccess) {
		var conv2,
		    current,
		    conv,
		    tmp,
		    prev,
		    converters = {},


		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if (dataTypes[1]) {
			for (conv in s.converters) {
				converters[conv.toLowerCase()] = s.converters[conv];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while (current) {

			if (s.responseFields[current]) {
				jqXHR[s.responseFields[current]] = response;
			}

			// Apply the dataFilter if provided
			if (!prev && isSuccess && s.dataFilter) {
				response = s.dataFilter(response, s.dataType);
			}

			prev = current;
			current = dataTypes.shift();

			if (current) {

				// There's only work to do if current dataType is non-auto
				if (current === "*") {

					current = prev;

					// Convert response if prev dataType is non-auto and differs from current
				} else if (prev !== "*" && prev !== current) {

						// Seek a direct converter
						conv = converters[prev + " " + current] || converters["* " + current];

						// If none found, seek a pair
						if (!conv) {
							for (conv2 in converters) {

								// If conv2 outputs current
								tmp = conv2.split(" ");
								if (tmp[1] === current) {

									// If prev can be converted to accepted input
									conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
									if (conv) {

										// Condense equivalence converters
										if (conv === true) {
											conv = converters[conv2];

											// Otherwise, insert the intermediate dataType
										} else if (converters[conv2] !== true) {
												current = tmp[0];
												dataTypes.unshift(tmp[1]);
											}
										break;
									}
								}
							}
						}

						// Apply converter (if not an equivalence)
						if (conv !== true) {

							// Unless errors are allowed to bubble, catch and return them
							if (conv && s.throws) {
								response = conv(response);
							} else {
								try {
									response = conv(response);
								} catch (e) {
									return {
										state: "parsererror",
										error: conv ? e : "No conversion from " + prev + " to " + current
									};
								}
							}
						}
					}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test(location.protocol),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
   timeout: 0,
   data: null,
   dataType: null,
   username: null,
   password: null,
   cache: null,
   throws: false,
   traditional: false,
   headers: {},
   */

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function (target, settings) {
			return settings ?

			// Building a settings object
			ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

			// Extending ajaxSettings
			ajaxExtend(jQuery.ajaxSettings, target);
		},

		ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
		ajaxTransport: addToPrefiltersOrTransports(transports),

		// Main method
		ajax: function (url, options) {

			// If url is an object, simulate pre-1.5 signature
			if (typeof url === "object") {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,


			// URL without anti-cache param
			cacheURL,


			// Response headers
			responseHeadersString,
			    responseHeaders,


			// timeout handle
			timeoutTimer,


			// Url cleanup var
			urlAnchor,


			// To know if global events are to be dispatched
			fireGlobals,


			// Loop variable
			i,


			// Create the final options object
			s = jQuery.ajaxSetup({}, options),


			// Callbacks context
			callbackContext = s.context || s,


			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,


			// Deferreds
			deferred = jQuery.Deferred(),
			    completeDeferred = jQuery.Callbacks("once memory"),


			// Status-dependent callbacks
			statusCode = s.statusCode || {},


			// Headers (they are sent all at once)
			requestHeaders = {},
			    requestHeadersNames = {},


			// The jqXHR state
			state = 0,


			// Default abort message
			strAbort = "canceled",


			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function (key) {
					var match;
					if (state === 2) {
						if (!responseHeaders) {
							responseHeaders = {};
							while (match = rheaders.exec(responseHeadersString)) {
								responseHeaders[match[1].toLowerCase()] = match[2];
							}
						}
						match = responseHeaders[key.toLowerCase()];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function () {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function (name, value) {
					var lname = name.toLowerCase();
					if (!state) {
						name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
						requestHeaders[name] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function (type) {
					if (!state) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function (map) {
					var code;
					if (map) {
						if (state < 2) {
							for (code in map) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[code] = [statusCode[code], map[code]];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always(map[jqXHR.status]);
						}
					}
					return this;
				},

				// Cancel the request
				abort: function (statusText) {
					var finalText = statusText || strAbort;
					if (transport) {
						transport.abort(finalText);
					}
					done(0, finalText);
					return this;
				}
			};

			// Attach deferreds
			deferred.promise(jqXHR).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if (s.crossDomain == null) {
				urlAnchor = document.createElement("a");

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
				} catch (e) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if (s.data && s.processData && typeof s.data !== "string") {
				s.data = jQuery.param(s.data, s.traditional);
			}

			// Apply prefilters
			inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

			// If request was aborted inside a prefilter, stop there
			if (state === 2) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if (fireGlobals && jQuery.active++ === 0) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test(s.type);

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if (!s.hasContent) {

				// If data is available, append data to url
				if (s.data) {
					cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if (s.cache === false) {
					s.url = rts.test(cacheURL) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace(rts, "$1_=" + nonce++) :

					// Otherwise add one to the end
					cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if (s.ifModified) {
				if (jQuery.lastModified[cacheURL]) {
					jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
				}
				if (jQuery.etag[cacheURL]) {
					jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
				}
			}

			// Set the correct header, if data is being sent
			if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
				jqXHR.setRequestHeader("Content-Type", s.contentType);
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

			// Check for headers option
			for (i in s.headers) {
				jqXHR.setRequestHeader(i, s.headers[i]);
			}

			// Allow custom headers/mimetypes and early abort
			if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for (i in { success: 1, error: 1, complete: 1 }) {
				jqXHR[i](s[i]);
			}

			// Get transport
			transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

			// If no transport, we auto-abort
			if (!transport) {
				done(-1, "No Transport");
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if (fireGlobals) {
					globalEventContext.trigger("ajaxSend", [jqXHR, s]);
				}

				// If request was aborted inside ajaxSend, stop there
				if (state === 2) {
					return jqXHR;
				}

				// Timeout
				if (s.async && s.timeout > 0) {
					timeoutTimer = window.setTimeout(function () {
						jqXHR.abort("timeout");
					}, s.timeout);
				}

				try {
					state = 1;
					transport.send(requestHeaders, done);
				} catch (e) {

					// Propagate exception as error if not done
					if (state < 2) {
						done(-1, e);

						// Simply rethrow otherwise
					} else {
							throw e;
						}
				}
			}

			// Callback for when everything is done
			function done(status, nativeStatusText, responses, headers) {
				var isSuccess,
				    success,
				    error,
				    response,
				    modified,
				    statusText = nativeStatusText;

				// Called once
				if (state === 2) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if (timeoutTimer) {
					window.clearTimeout(timeoutTimer);
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if (responses) {
					response = ajaxHandleResponses(s, jqXHR, responses);
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert(s, response, jqXHR, isSuccess);

				// If successful, handle type chaining
				if (isSuccess) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if (s.ifModified) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if (modified) {
							jQuery.lastModified[cacheURL] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if (modified) {
							jQuery.etag[cacheURL] = modified;
						}
					}

					// if no content
					if (status === 204 || s.type === "HEAD") {
						statusText = "nocontent";

						// if not modified
					} else if (status === 304) {
							statusText = "notmodified";

							// If we have data, let's convert it
						} else {
								statusText = response.state;
								success = response.data;
								error = response.error;
								isSuccess = !error;
							}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if (status || !statusText) {
						statusText = "error";
						if (status < 0) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = (nativeStatusText || statusText) + "";

				// Success/Error
				if (isSuccess) {
					deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
				} else {
					deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
				}

				// Status-dependent callbacks
				jqXHR.statusCode(statusCode);
				statusCode = undefined;

				if (fireGlobals) {
					globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
				}

				// Complete
				completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

				if (fireGlobals) {
					globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

					// Handle the global AJAX counter
					if (! --jQuery.active) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function (url, data, callback) {
			return jQuery.get(url, data, callback, "json");
		},

		getScript: function (url, callback) {
			return jQuery.get(url, undefined, callback, "script");
		}
	});

	jQuery.each(["get", "post"], function (i, method) {
		jQuery[method] = function (url, data, callback, type) {

			// Shift arguments if data argument was omitted
			if (jQuery.isFunction(data)) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax(jQuery.extend({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject(url) && url));
		};
	});

	jQuery._evalUrl = function (url) {
		return jQuery.ajax({
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};

	jQuery.fn.extend({
		wrapAll: function (html) {
			var wrap;

			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapAll(html.call(this, i));
				});
			}

			if (this[0]) {

				// The elements to wrap the target around
				wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

				if (this[0].parentNode) {
					wrap.insertBefore(this[0]);
				}

				wrap.map(function () {
					var elem = this;

					while (elem.firstElementChild) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append(this);
			}

			return this;
		},

		wrapInner: function (html) {
			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapInner(html.call(this, i));
				});
			}

			return this.each(function () {
				var self = jQuery(this),
				    contents = self.contents();

				if (contents.length) {
					contents.wrapAll(html);
				} else {
					self.append(html);
				}
			});
		},

		wrap: function (html) {
			var isFunction = jQuery.isFunction(html);

			return this.each(function (i) {
				jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
			});
		},

		unwrap: function () {
			return this.parent().each(function () {
				if (!jQuery.nodeName(this, "body")) {
					jQuery(this).replaceWith(this.childNodes);
				}
			}).end();
		}
	});

	jQuery.expr.filters.hidden = function (elem) {
		return !jQuery.expr.filters.visible(elem);
	};
	jQuery.expr.filters.visible = function (elem) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};

	var r20 = /%20/g,
	    rbracket = /\[\]$/,
	    rCRLF = /\r?\n/g,
	    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	    rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams(prefix, obj, traditional, add) {
		var name;

		if (jQuery.isArray(obj)) {

			// Serialize array item.
			jQuery.each(obj, function (i, v) {
				if (traditional || rbracket.test(prefix)) {

					// Treat each array item as a scalar.
					add(prefix, v);
				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
				}
			});
		} else if (!traditional && jQuery.type(obj) === "object") {

			// Serialize object item.
			for (name in obj) {
				buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
			}
		} else {

			// Serialize scalar item.
			add(prefix, obj);
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function (a, traditional) {
		var prefix,
		    s = [],
		    add = function (key, value) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
			s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
		};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if (traditional === undefined) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {

			// Serialize the form elements
			jQuery.each(a, function () {
				add(this.name, this.value);
			});
		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for (prefix in a) {
				buildParams(prefix, a[prefix], traditional, add);
			}
		}

		// Return the resulting serialization
		return s.join("&").replace(r20, "+");
	};

	jQuery.fn.extend({
		serialize: function () {
			return jQuery.param(this.serializeArray());
		},
		serializeArray: function () {
			return this.map(function () {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop(this, "elements");
				return elements ? jQuery.makeArray(elements) : this;
			}).filter(function () {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
			}).map(function (i, elem) {
				var val = jQuery(this).val();

				return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
					return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
				}) : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
			}).get();
		}
	});

	jQuery.ajaxSettings.xhr = function () {
		try {
			return new window.XMLHttpRequest();
		} catch (e) {}
	};

	var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	    xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function (options) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if (support.cors || xhrSupported && !options.crossDomain) {
			return {
				send: function (headers, complete) {
					var i,
					    xhr = options.xhr();

					xhr.open(options.type, options.url, options.async, options.username, options.password);

					// Apply custom fields if provided
					if (options.xhrFields) {
						for (i in options.xhrFields) {
							xhr[i] = options.xhrFields[i];
						}
					}

					// Override mime type if needed
					if (options.mimeType && xhr.overrideMimeType) {
						xhr.overrideMimeType(options.mimeType);
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if (!options.crossDomain && !headers["X-Requested-With"]) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for (i in headers) {
						xhr.setRequestHeader(i, headers[i]);
					}

					// Callback
					callback = function (type) {
						return function () {
							if (callback) {
								callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if (type === "abort") {
									xhr.abort();
								} else if (type === "error") {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if (typeof xhr.status !== "number") {
										complete(0, "error");
									} else {
										complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status, xhr.statusText);
									}
								} else {
									complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback("error");

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if (xhr.onabort !== undefined) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function () {

							// Check readyState before timeout as it changes
							if (xhr.readyState === 4) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout(function () {
									if (callback) {
										errorCallback();
									}
								});
							}
						};
					}

					// Create the abort callback
					callback = callback("abort");

					try {

						// Do send the request (this may raise an exception)
						xhr.send(options.hasContent && options.data || null);
					} catch (e) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if (callback) {
							throw e;
						}
					}
				},

				abort: function () {
					if (callback) {
						callback();
					}
				}
			};
		}
	});

	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function (text) {
				jQuery.globalEval(text);
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter("script", function (s) {
		if (s.cache === undefined) {
			s.cache = false;
		}
		if (s.crossDomain) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport("script", function (s) {

		// This transport only deals with cross domain requests
		if (s.crossDomain) {
			var script, callback;
			return {
				send: function (_, complete) {
					script = jQuery("<script>").prop({
						charset: s.scriptCharset,
						src: s.url
					}).on("load error", callback = function (evt) {
						script.remove();
						callback = null;
						if (evt) {
							complete(evt.type === "error" ? 404 : 200, evt.type);
						}
					});

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild(script[0]);
				},
				abort: function () {
					if (callback) {
						callback();
					}
				}
			};
		}
	});

	var oldCallbacks = [],
	    rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function () {
			var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
			this[callback] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

		var callbackName,
		    overwritten,
		    responseContainer,
		    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if (jsonProp || s.dataTypes[0] === "jsonp") {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

			// Insert callback into url or form data
			if (jsonProp) {
				s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
			} else if (s.jsonp !== false) {
				s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function () {
				if (!responseContainer) {
					jQuery.error(callbackName + " was not called");
				}
				return responseContainer[0];
			};

			// Force json dataType
			s.dataTypes[0] = "json";

			// Install callback
			overwritten = window[callbackName];
			window[callbackName] = function () {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function () {

				// If previous value didn't exist - remove it
				if (overwritten === undefined) {
					jQuery(window).removeProp(callbackName);

					// Otherwise restore preexisting value
				} else {
						window[callbackName] = overwritten;
					}

				// Save back as free
				if (s[callbackName]) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push(callbackName);
				}

				// Call if it was a function and we have a response
				if (responseContainer && jQuery.isFunction(overwritten)) {
					overwritten(responseContainer[0]);
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});

	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function (data, context, keepScripts) {
		if (!data || typeof data !== "string") {
			return null;
		}
		if (typeof context === "boolean") {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec(data),
		    scripts = !keepScripts && [];

		// Single tag
		if (parsed) {
			return [context.createElement(parsed[1])];
		}

		parsed = buildFragment([data], context, scripts);

		if (scripts && scripts.length) {
			jQuery(scripts).remove();
		}

		return jQuery.merge([], parsed.childNodes);
	};

	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
  * Load a url into a page
  */
	jQuery.fn.load = function (url, params, callback) {
		if (typeof url !== "string" && _load) {
			return _load.apply(this, arguments);
		}

		var selector,
		    type,
		    response,
		    self = this,
		    off = url.indexOf(" ");

		if (off > -1) {
			selector = jQuery.trim(url.slice(off));
			url = url.slice(0, off);
		}

		// If it's a function
		if (jQuery.isFunction(params)) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

			// Otherwise, build a param string
		} else if (params && typeof params === "object") {
				type = "POST";
			}

		// If we have elements to modify, make the request
		if (self.length > 0) {
			jQuery.ajax({
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			}).done(function (responseText) {

				// Save response for use in complete callback
				response = arguments;

				self.html(selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

				// Otherwise use the full result
				responseText);

				// If the request succeeds, this function gets "data", "status", "jqXHR"
				// but they are ignored because response was set above.
				// If it fails, this function gets "jqXHR", "status", "error"
			}).always(callback && function (jqXHR, status) {
				self.each(function () {
					callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
				});
			});
		}

		return this;
	};

	// Attach a bunch of functions for handling common AJAX events
	jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
		jQuery.fn[type] = function (fn) {
			return this.on(type, fn);
		};
	});

	jQuery.expr.filters.animated = function (elem) {
		return jQuery.grep(jQuery.timers, function (fn) {
			return elem === fn.elem;
		}).length;
	};

	/**
  * Gets a window from an element
  */
	function getWindow(elem) {
		return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function (elem, options, i) {
			var curPosition,
			    curLeft,
			    curCSSTop,
			    curTop,
			    curOffset,
			    curCSSLeft,
			    calculatePosition,
			    position = jQuery.css(elem, "position"),
			    curElem = jQuery(elem),
			    props = {};

			// Set position first, in-case top/left are set even on static elem
			if (position === "static") {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css(elem, "top");
			curCSSLeft = jQuery.css(elem, "left");
			calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if (calculatePosition) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat(curCSSTop) || 0;
				curLeft = parseFloat(curCSSLeft) || 0;
			}

			if (jQuery.isFunction(options)) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call(elem, i, jQuery.extend({}, curOffset));
			}

			if (options.top != null) {
				props.top = options.top - curOffset.top + curTop;
			}
			if (options.left != null) {
				props.left = options.left - curOffset.left + curLeft;
			}

			if ("using" in options) {
				options.using.call(elem, props);
			} else {
				curElem.css(props);
			}
		}
	};

	jQuery.fn.extend({
		offset: function (options) {
			if (arguments.length) {
				return options === undefined ? this : this.each(function (i) {
					jQuery.offset.setOffset(this, options, i);
				});
			}

			var docElem,
			    win,
			    elem = this[0],
			    box = { top: 0, left: 0 },
			    doc = elem && elem.ownerDocument;

			if (!doc) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if (!jQuery.contains(docElem, elem)) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow(doc);
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function () {
			if (!this[0]) {
				return;
			}

			var offsetParent,
			    offset,
			    elem = this[0],
			    parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if (jQuery.css(elem, "position") === "fixed") {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if (!jQuery.nodeName(offsetParent[0], "html")) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
				parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
				left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function () {
			return this.map(function () {
				var offsetParent = this.offsetParent;

				while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
		var top = "pageYOffset" === prop;

		jQuery.fn[method] = function (val) {
			return access(this, function (elem, method, val) {
				var win = getWindow(elem);

				if (val === undefined) {
					return win ? win[prop] : elem[method];
				}

				if (win) {
					win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
				} else {
					elem[method] = val;
				}
			}, method, val, arguments.length);
		};
	});

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each(["top", "left"], function (i, prop) {
		jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
			if (computed) {
				computed = curCSS(elem, prop);

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
			}
		});
	});

	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
		jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[funcName] = function (margin, value) {
				var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
				    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

				return access(this, function (elem, type, value) {
					var doc;

					if (jQuery.isWindow(elem)) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement["client" + name];
					}

					// Get document width or height
					if (elem.nodeType === 9) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
					}

					return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css(elem, type, extra) :

					// Set width or height on the element
					jQuery.style(elem, type, value, extra);
				}, type, chainable ? margin : undefined, chainable, null);
			};
		});
	});

	jQuery.fn.extend({

		bind: function (types, data, fn) {
			return this.on(types, null, data, fn);
		},
		unbind: function (types, fn) {
			return this.off(types, null, fn);
		},

		delegate: function (selector, types, data, fn) {
			return this.on(types, selector, data, fn);
		},
		undelegate: function (selector, types, fn) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
		},
		size: function () {
			return this.length;
		}
	});

	jQuery.fn.andSelf = jQuery.fn.addBack;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if (typeof define === "function" && define.amd) {
		define("jquery", [], function () {
			return jQuery;
		});
	}

	var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,


	// Map over the $ in case of overwrite
	_$ = window.$;

	jQuery.noConflict = function (deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}

		if (deep && window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if (!noGlobal) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
});
"use strict";

/*!
 * VERSION: 1.18.4
 * DATE: 2016-04-26
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {

	"use strict";

	_gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {

		var _slice = function (a) {
			//don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			var b = [],
			    l = a.length,
			    i;
			for (i = 0; i !== l; b.push(a[i++])) {}
			return b;
		},
		    _applyCycle = function (vars, targets, i) {
			var alt = vars.cycle,
			    p,
			    val;
			for (p in alt) {
				val = alt[p];
				vars[p] = typeof val === "function" ? val.call(targets[i], i) : val[i % val.length];
			}
			delete vars.cycle;
		},
		    TweenMax = function (target, duration, vars) {
			TweenLite.call(this, target, duration, vars);
			this._cycle = 0;
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
			this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _isSelector = TweenLiteInternals.isSelector,
		    _isArray = TweenLiteInternals.isArray,
		    p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
		    _blankArray = [];

		TweenMax.version = "1.18.4";
		p.constructor = TweenMax;
		p.kill()._gc = false;
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
		TweenMax.getTweensOf = TweenLite.getTweensOf;
		TweenMax.lagSmoothing = TweenLite.lagSmoothing;
		TweenMax.ticker = TweenLite.ticker;
		TweenMax.render = TweenLite.render;

		p.invalidate = function () {
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TweenLite.prototype.invalidate.call(this);
		};

		p.updateTo = function (vars, resetDuration) {
			var curRatio = this.ratio,
			    immediate = this.vars.immediateRender || vars.immediateRender,
			    p;
			if (resetDuration && this._startTime < this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled && this._firstPT) {
						TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration > 0.998) {
						//if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards.
						var prevTime = this._totalTime;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else {
						this._initted = false;
						this._init();
						if (this._time > 0 || immediate) {
							var inv = 1 / (1 - curRatio),
							    pt = this._firstPT,
							    endValue;
							while (pt) {
								endValue = pt.s + pt.c;
								pt.c *= inv;
								pt.s = endValue - pt.c;
								pt = pt._next;
							}
						}
					}
				}
			}
			return this;
		};

		p.render = function (time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) {
				//zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    prevTime = this._time,
			    prevTotalTime = this._totalTime,
			    prevCycle = this._cycle,
			    duration = this._duration,
			    prevRawPrevTime = this._rawPrevTime,
			    isComplete,
			    callback,
			    pt,
			    cycleDuration,
			    r,
			    type,
			    pow,
			    rawPrevTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = "onComplete";
					force = force || this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) {
					//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) {
						//if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause") if (prevRawPrevTime !== time) {
						//note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
			} else if (time < 0.0000001) {
					//to work around occasional floating point math artifacts, round super small values to 0.
					this._totalTime = this._time = this._cycle = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
					if (prevTotalTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
						callback = "onReverseComplete";
						isComplete = this._reversed;
					}
					if (time < 0) {
						this._active = false;
						if (duration === 0) if (this._initted || !this.vars.lazy || force) {
							//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
							if (prevRawPrevTime >= 0) {
								force = true;
							}
							this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
						}
					}
					if (!this._initted) {
						//if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
						force = true;
					}
				} else {
					this._totalTime = this._time = time;
					if (this._repeat !== 0) {
						cycleDuration = duration + this._repeatDelay;
						this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						this._time = this._totalTime - this._cycle * cycleDuration;
						if (this._yoyo) if ((this._cycle & 1) !== 0) {
							this._time = duration - this._time;
						}
						if (this._time > duration) {
							this._time = duration;
						} else if (this._time < 0) {
							this._time = 0;
						}
					}

					if (this._easeType) {
						r = this._time / duration;
						type = this._easeType;
						pow = this._easePower;
						if (type === 1 || type === 3 && r >= 0.5) {
							r = 1 - r;
						}
						if (type === 3) {
							r *= 2;
						}
						if (pow === 1) {
							r *= r;
						} else if (pow === 2) {
							r *= r * r;
						} else if (pow === 3) {
							r *= r * r * r;
						} else if (pow === 4) {
							r *= r * r * r * r;
						}

						if (type === 1) {
							this.ratio = 1 - r;
						} else if (type === 2) {
							this.ratio = r;
						} else if (this._time / duration < 0.5) {
							this.ratio = r / 2;
						} else {
							this.ratio = 1 - r / 2;
						}
					} else {
						this.ratio = this._ease.getRatio(this._time / duration);
					}
				}

			if (prevTime === this._time && !force && prevCycle === this._cycle) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
					//so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) {
					//immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
					//we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;
					this._totalTime = prevTotalTime;
					this._rawPrevTime = prevRawPrevTime;
					this._cycle = prevCycle;
					TweenLiteInternals.lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
				}
			}
			if (this._lazy !== false) {
				this._lazy = false;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTotalTime === 0) {
				if (this._initted === 2 && time > 0) {
					//this.invalidate();
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}

			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && this._startTime) {
					//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || callback) {
					this._callback("onUpdate");
				}
			}
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
				this._callback("onRepeat");
			}
			if (callback) if (!this._gc || force) {
				//check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
					//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
					//the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------

		TweenMax.to = function (target, duration, vars) {
			return new TweenMax(target, duration, vars);
		};

		TweenMax.from = function (target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = vars.immediateRender != false;
			return new TweenMax(target, duration, vars);
		};

		TweenMax.fromTo = function (target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return new TweenMax(target, duration, toVars);
		};

		TweenMax.staggerTo = TweenMax.allTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
			    a = [],
			    finalComplete = function () {
				if (vars.onComplete) {
					vars.onComplete.apply(vars.onCompleteScope || this, arguments);
				}
				onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
			},
			    cycle = vars.cycle,
			    fromCycle = vars.startAt && vars.startAt.cycle,
			    l,
			    copy,
			    i,
			    p;
			if (!_isArray(targets)) {
				if (typeof targets === "string") {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i <= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l && onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		};

		TweenMax.staggerFrom = TweenMax.allFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = vars.immediateRender != false;
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		TweenMax.staggerFromTo = TweenMax.allFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		TweenMax.delayedCall = function (delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, { delay: delay, onComplete: callback, onCompleteParams: params, callbackScope: scope, onReverseComplete: callback, onReverseCompleteParams: params, immediateRender: false, useFrames: useFrames, overwrite: 0 });
		};

		TweenMax.set = function (target, vars) {
			return new TweenMax(target, 0, vars);
		};

		TweenMax.isTweening = function (target) {
			return TweenLite.getTweensOf(target, true).length > 0;
		};

		var _getChildrenOf = function (timeline, includeTimelines) {
			var a = [],
			    cnt = 0,
			    tween = timeline._first;
			while (tween) {
				if (tween instanceof TweenLite) {
					a[cnt++] = tween;
				} else {
					if (includeTimelines) {
						a[cnt++] = tween;
					}
					a = a.concat(_getChildrenOf(tween, includeTimelines));
					cnt = a.length;
				}
				tween = tween._next;
			}
			return a;
		},
		    getAllTweens = TweenMax.getAllTweens = function (includeTimelines) {
			return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines));
		};

		TweenMax.killAll = function (complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens(timelines != false),
			    l = a.length,
			    allTrue = tweens && delayedCalls && timelines,
			    isDC,
			    tween,
			    i;
			for (i = 0; i < l; i++) {
				tween = a[i];
				if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		};

		TweenMax.killChildTweensOf = function (parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
			    a,
			    curParent,
			    p,
			    i,
			    l;
			if (typeof parent === "string") {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i > -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		};

		var _changePause = function (pause, tweens, delayedCalls, timelines) {
			tweens = tweens !== false;
			delayedCalls = delayedCalls !== false;
			timelines = timelines !== false;
			var a = getAllTweens(timelines),
			    allTrue = tweens && delayedCalls && timelines,
			    i = a.length,
			    isDC,
			    tween;
			while (--i > -1) {
				tween = a[i];
				if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
					tween.paused(pause);
				}
			}
		};

		TweenMax.pauseAll = function (tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		};

		TweenMax.resumeAll = function (tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		};

		TweenMax.globalTimeScale = function (value) {
			var tl = Animation._rootTimeline,
			    t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		};

		//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------

		p.progress = function (value, suppressEvents) {
			return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
		};

		p.totalProgress = function (value, suppressEvents) {
			return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
		};

		p.time = function (value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.duration = function (value) {
			if (!arguments.length) {
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}
			return Animation.prototype.duration.call(this, value);
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1));
		};

		p.repeat = function (value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function (value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function (value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		return TweenMax;
	}, true);

	/*
  * ----------------------------------------------------------------
  * TimelineLite
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function (vars) {
			SimpleTimeline.call(this, vars);
			this._labels = {};
			this.autoRemoveChildren = this.vars.autoRemoveChildren === true;
			this.smoothChildTiming = this.vars.smoothChildTiming === true;
			this._sortChildren = true;
			this._onUpdate = this.vars.onUpdate;
			var v = this.vars,
			    val,
			    p;
			for (p in v) {
				val = v[p];
				if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
					v[p] = this._swapSelfInParams(val);
				}
			}
			if (_isArray(v.tweens)) {
				this.add(v.tweens, 0, v.align, v.stagger);
			}
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _internals = TimelineLite._internals = {},
		    _isSelector = TweenLiteInternals.isSelector,
		    _isArray = TweenLiteInternals.isArray,
		    _lazyTweens = TweenLiteInternals.lazyTweens,
		    _lazyRender = TweenLiteInternals.lazyRender,
		    _globals = _gsScope._gsDefine.globals,
		    _copy = function (vars) {
			var copy = {},
			    p;
			for (p in vars) {
				copy[p] = vars[p];
			}
			return copy;
		},
		    _applyCycle = function (vars, targets, i) {
			var alt = vars.cycle,
			    p,
			    val;
			for (p in alt) {
				val = alt[p];
				vars[p] = typeof val === "function" ? val.call(targets[i], i) : val[i % val.length];
			}
			delete vars.cycle;
		},
		    _pauseCallback = _internals.pauseCallback = function () {},
		    _slice = function (a) {
			//don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			var b = [],
			    l = a.length,
			    i;
			for (i = 0; i !== l; b.push(a[i++])) {}
			return b;
		},
		    p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.18.4";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = p._hasPause = false;

		/* might use later...
  //translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
  function localToGlobal(time, animation) {
  	while (animation) {
  		time = (time / animation._timeScale) + animation._startTime;
  		animation = animation.timeline;
  	}
  	return time;
  }
  	//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
  function globalToLocal(time, animation) {
  	var scale = 1;
  	time -= localToGlobal(0, animation);
  	while (animation) {
  		scale *= animation._timeScale;
  		animation = animation.timeline;
  	}
  	return time * scale;
  }
  */

		p.to = function (target, duration, vars, position) {
			var Engine = vars.repeat && _globals.TweenMax || TweenLite;
			return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function (target, duration, vars, position) {
			return this.add((vars.repeat && _globals.TweenMax || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function (target, duration, fromVars, toVars, position) {
			var Engine = toVars.repeat && _globals.TweenMax || TweenLite;
			return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({ onComplete: onCompleteAll, onCompleteParams: onCompleteAllParams, callbackScope: onCompleteAllScope, smoothChildTiming: this.smoothChildTiming }),
			    cycle = vars.cycle,
			    copy,
			    i;
			if (typeof targets === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) {
				//senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				copy = _copy(vars);
				if (copy.startAt) {
					copy.startAt = _copy(copy.startAt);
					if (copy.startAt.cycle) {
						_applyCycle(copy.startAt, targets, i);
					}
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
				}
				tl.to(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = vars.immediateRender != false;
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function (targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function (callback, params, scope, position) {
			return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function (target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = position === this._time && !this._paused;
			}
			return this.add(new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function (vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
			    root = tl._timeline,
			    tween,
			    next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		};

		p.add = function (value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof position !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if (value instanceof Array || value && value.push && _isArray(value)) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({ tweens: child });
						}
						this.add(child, curTime);
						if (typeof child !== "string" && typeof child !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + child.totalDuration() / child._timeScale;
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof value === "string") {
					return this.addLabel(value, position);
				} else if (typeof value === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw "Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.";
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = tl.rawTime() > value._startTime; //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
							tl._enabled(true, false);
						}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function (value) {
			if (value instanceof Animation) {
				this._remove(value, false);
				var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline; //now that it's removed, default it to the root timeline so that if it gets played again, it doesn't jump back into this timeline.
				value._startTime = (value._paused ? value._pauseTime : tl._time) - (!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale; //ensure that if it gets played again, the timing is correct.
				return this;
			} else if (value instanceof Array || value && value.push && _isArray(value)) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof value === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function (tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
				this._time = this.duration();
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function (value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function (value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function (tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function (label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function (position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
			t.vars.onComplete = t.vars.onReverseComplete = callback;
			t.data = "isPause";
			this._hasPause = true;
			return this.add(t, position);
		};

		p.removeLabel = function (label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function (label) {
			return this._labels[label] != null ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function (timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof offsetOrLabel === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && typeof timeOrLabel === "number" && this._labels[offsetOrLabel] == null ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof timeOrLabel === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
				//if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? this._labels[timeOrLabel] = this.duration() + offsetOrLabel : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
				timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function (position, suppressEvents) {
			return this.totalTime(typeof position === "number" ? position : this._parseTimeOrLabel(position), suppressEvents !== false);
		};

		p.stop = function () {
			return this.paused(true);
		};

		p.gotoAndPlay = function (position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function (position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function (time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    prevTime = this._time,
			    prevStart = this._startTime,
			    prevTimeScale = this._timeScale,
			    prevPaused = this._paused,
			    tween,
			    isComplete,
			    next,
			    callback,
			    internalForce,
			    pauseTween,
			    curTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time <= 0 && time >= -0.0000001 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.
			} else if (time < 0.0000001) {
					//to work around occasional floating point math artifacts, round super small values to 0.
					this._totalTime = this._time = 0;
					if (prevTime !== 0 || this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || time < 0 && this._rawPrevTime >= 0)) {
						callback = "onReverseComplete";
						isComplete = this._reversed;
					}
					if (time < 0) {
						this._active = false;
						if (this._timeline.autoRemoveChildren && this._reversed) {
							//ensures proper GC if a timeline is resumed after it's finished reversing.
							internalForce = isComplete = true;
							callback = "onReverseComplete";
						} else if (this._rawPrevTime >= 0 && this._first) {
							//when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
							internalForce = true;
						}
						this._rawPrevTime = time;
					} else {
						this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
						if (time === 0 && isComplete) {
							//if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
							tween = this._first;
							while (tween && tween._startTime === 0) {
								if (!tween._duration) {
									isComplete = false;
								}
								tween = tween._next;
							}
						}
						time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
						if (!this._initted) {
							internalForce = true;
						}
					}
				} else {

					if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
						if (time >= prevTime) {
							tween = this._first;
							while (tween && tween._startTime <= time && !pauseTween) {
								if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
									pauseTween = tween;
								}
								tween = tween._next;
							}
						} else {
							tween = this._last;
							while (tween && tween._startTime >= time && !pauseTween) {
								if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
									pauseTween = tween;
								}
								tween = tween._prev;
							}
						}
						if (pauseTween) {
							this._time = time = pauseTween._startTime;
							this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
						}
					}

					this._totalTime = this._time = this._rawPrevTime = time;
				}
			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= curTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
				//if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) {
						//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p._hasPausedChild = function () {
			var tween = this._first;
			while (tween) {
				if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild()) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function (nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
			    tween = this._first,
			    cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
						if (tweens !== false) {
							a[cnt++] = tween;
						}
					} else {
						if (timelines !== false) {
							a[cnt++] = tween;
						}
						if (nested !== false) {
							a = a.concat(tween.getChildren(true, tweens, timelines));
							cnt = a.length;
						}
					}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function (target, nested) {
			var disabled = this._gc,
			    a = [],
			    cnt = 0,
			    tweens,
			    i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || nested && this._contains(tweens[i])) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function () {
			return this._recent;
		};

		p._contains = function (tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function (amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
			    labels = this._labels,
			    p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function (vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = !target ? this.getChildren(true, true, false) : this.getTweensOf(target),
			    i = tweens.length,
			    changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function (labels) {
			var tweens = this.getChildren(false, true, true),
			    i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function () {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function (time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
					    tween = this._last,
					    prevStart = 999999999999,
					    prev,
					    end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) {
							//in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) {
							//children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + tween._totalDuration / tween._timeScale;
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return value && this.totalDuration() ? this.timeScale(this._totalDuration / value) : this;
		};

		p.paused = function (value) {
			if (!value) {
				//if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
				    time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function () {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return tl === Animation._rootFramesTimeline;
		};

		p.rawTime = function () {
			return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
		};

		return TimelineLite;
	}, true);

	/*
  * ----------------------------------------------------------------
  * TimelineMax
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (TimelineLite, TweenLite, Ease) {

		var TimelineMax = function (vars) {
			TimelineLite.call(this, vars);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._cycle = 0;
			this._yoyo = this.vars.yoyo === true;
			this._dirty = true;
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _lazyTweens = TweenLiteInternals.lazyTweens,
		    _lazyRender = TweenLiteInternals.lazyRender,
		    _easeNone = new Ease(null, null, 1, 0),
		    p = TimelineMax.prototype = new TimelineLite();

		p.constructor = TimelineMax;
		p.kill()._gc = false;
		TimelineMax.version = "1.18.4";

		p.invalidate = function () {
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TimelineLite.prototype.invalidate.call(this);
		};

		p.addCallback = function (callback, position, params, scope) {
			return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.removeCallback = function (callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
					    i = a.length,
					    time = this._parseTimeOrLabel(position);
					while (--i > -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		};

		p.removePause = function (position) {
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);
		};

		p.tweenTo = function (position, vars) {
			vars = vars || {};
			var copy = { ease: _easeNone, useFrames: this.usesFrames(), immediateRender: false },
			    duration,
			    p,
			    t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = Math.abs(Number(copy.time) - this._time) / this._timeScale || 0.001;
			t = new TweenLite(this, duration, copy);
			copy.onStart = function () {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() && duration === t.duration()) {
					//don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale);
				}
				if (vars.onStart) {
					//in case the user had an onStart in the vars - we don't want to overwrite it.
					t._callback("onStart");
				}
			};
			return t;
		};

		p.tweenFromTo = function (fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = { onComplete: this.seek, onCompleteParams: [fromPosition], callbackScope: this };
			vars.immediateRender = vars.immediateRender !== false;
			var t = this.tweenTo(toPosition, vars);
			return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || 0.001);
		};

		p.render = function (time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    dur = this._duration,
			    prevTime = this._time,
			    prevTotalTime = this._totalTime,
			    prevStart = this._startTime,
			    prevTimeScale = this._timeScale,
			    prevRawPrevTime = this._rawPrevTime,
			    prevPaused = this._paused,
			    prevCycle = this._cycle,
			    tween,
			    isComplete,
			    next,
			    callback,
			    internalForce,
			    cycleDuration,
			    pauseTween,
			    curTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time <= 0 && time >= -0.0000001 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}
			} else if (time < 0.0000001) {
					//to work around occasional floating point math artifacts, round super small values to 0.
					if (!this._locked) {
						this._totalTime = this._cycle = 0;
					}
					this._time = 0;
					if (prevTime !== 0 || dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || time < 0 && prevRawPrevTime >= 0) && !this._locked) {
						//edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
						callback = "onReverseComplete";
						isComplete = this._reversed;
					}
					if (time < 0) {
						this._active = false;
						if (this._timeline.autoRemoveChildren && this._reversed) {
							internalForce = isComplete = true;
							callback = "onReverseComplete";
						} else if (prevRawPrevTime >= 0 && this._first) {
							//when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
							internalForce = true;
						}
						this._rawPrevTime = time;
					} else {
						this._rawPrevTime = dur || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
						if (time === 0 && isComplete) {
							//if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
							tween = this._first;
							while (tween && tween._startTime === 0) {
								if (!tween._duration) {
									isComplete = false;
								}
								tween = tween._next;
							}
						}
						time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
						if (!this._initted) {
							internalForce = true;
						}
					}
				} else {
					if (dur === 0 && prevRawPrevTime < 0) {
						//without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
						internalForce = true;
					}
					this._time = this._rawPrevTime = time;
					if (!this._locked) {
						this._totalTime = time;
						if (this._repeat !== 0) {
							cycleDuration = dur + this._repeatDelay;
							this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
							if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
								this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
							}
							this._time = this._totalTime - this._cycle * cycleDuration;
							if (this._yoyo) if ((this._cycle & 1) !== 0) {
								this._time = dur - this._time;
							}
							if (this._time > dur) {
								this._time = dur;
								time = dur + 0.0001; //to avoid occasional floating point rounding error
							} else if (this._time < 0) {
									this._time = time = 0;
								} else {
									time = this._time;
								}
						}
					}

					if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
						time = this._time;
						if (time >= prevTime) {
							tween = this._first;
							while (tween && tween._startTime <= time && !pauseTween) {
								if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
									pauseTween = tween;
								}
								tween = tween._next;
							}
						} else {
							tween = this._last;
							while (tween && tween._startTime >= time && !pauseTween) {
								if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
									pauseTween = tween;
								}
								tween = tween._prev;
							}
						}
						if (pauseTween) {
							this._time = time = pauseTween._startTime;
							this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
						}
					}
				}

			if (this._cycle !== prevCycle) if (!this._locked) {
				/*
    make sure children at the end/beginning of the timeline are rendered properly. If, for example,
    a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
    would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
    could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
    we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
    ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
    */
				var backwards = this._yoyo && (prevCycle & 1) !== 0,
				    wrap = backwards === (this._yoyo && (this._cycle & 1) !== 0),
				    recTotalTime = this._totalTime,
				    recCycle = this._cycle,
				    recRawPrevTime = this._rawPrevTime,
				    recTime = this._time;

				this._totalTime = prevCycle * dur;
				if (this._cycle < prevCycle) {
					backwards = !backwards;
				} else {
					this._totalTime += dur;
				}
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

				this._rawPrevTime = dur === 0 ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
				this._cycle = prevCycle;
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = backwards ? 0 : dur;
				this.render(prevTime, suppressEvents, dur === 0);
				if (!suppressEvents) if (!this._gc) {
					if (this.vars.onRepeat) {
						this._callback("onRepeat");
					}
				}
				if (prevTime !== this._time) {
					//in case there's a callback like onComplete in a nested tween/timeline that changes the playhead position, like via seek(), we should just abort.
					return;
				}
				if (wrap) {
					prevTime = backwards ? dur + 0.0001 : -0.0001;
					this.render(prevTime, true, false);
				}
				this._locked = false;
				if (this._paused && !prevPaused) {
					//if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;
				}
				this._time = recTime;
				this._totalTime = recTotalTime;
				this._cycle = recCycle;
				this._rawPrevTime = recRawPrevTime;
			}

			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
					//so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
				this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
				//if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) {
						//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p.getActive = function (nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [],
			    all = this.getChildren(nested, tweens, timelines),
			    cnt = 0,
			    l = all.length,
			    i,
			    tween;
			for (i = 0; i < l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		};

		p.getLabelAfter = function (time) {
			if (!time) if (time !== 0) {
				//faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
			    l = labels.length,
			    i;
			for (i = 0; i < l; i++) {
				if (labels[i].time > time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelBefore = function (time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
			    i = labels.length;
			while (--i > -1) {
				if (labels[i].time < time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelsArray = function () {
			var a = [],
			    cnt = 0,
			    p;
			for (p in this._labels) {
				a[cnt++] = { time: this._labels[p], name: p };
			}
			a.sort(function (a, b) {
				return a.time - b.time;
			});
			return a;
		};

		//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

		p.progress = function (value, suppressEvents) {
			return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
		};

		p.totalProgress = function (value, suppressEvents) {
			return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
				}
				return this._totalDuration;
			}
			return this._repeat === -1 || !value ? this : this.timeScale(this.totalDuration() / value);
		};

		p.time = function (value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.repeat = function (value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function (value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function (value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		p.currentLabel = function (value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		};

		return TimelineMax;
	}, true);

	/*
  * ----------------------------------------------------------------
  * BezierPlugin
  * ----------------------------------------------------------------
  */
	(function () {

		var _RAD2DEG = 180 / Math.PI,
		    _r1 = [],
		    _r2 = [],
		    _r3 = [],
		    _corProps = {},
		    _globals = _gsScope._gsDefine.globals,
		    Segment = function (a, b, c, d) {
			this.a = a;
			this.b = b;
			this.c = c;
			this.d = d;
			this.da = d - a;
			this.ca = c - a;
			this.ba = b - a;
		},
		    _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
		    cubicToQuadratic = function (a, b, c, d) {
			var q1 = { a: a },
			    q2 = {},
			    q3 = {},
			    q4 = { c: d },
			    mab = (a + b) / 2,
			    mbc = (b + c) / 2,
			    mcd = (c + d) / 2,
			    mabc = (mab + mbc) / 2,
			    mbcd = (mbc + mcd) / 2,
			    m8 = (mbcd - mabc) / 8;
			q1.b = mab + (a - mab) / 4;
			q2.b = mabc + m8;
			q1.c = q2.a = (q1.b + q2.b) / 2;
			q2.c = q3.a = (mabc + mbcd) / 2;
			q3.b = mbcd - m8;
			q4.b = mcd + (d - mcd) / 4;
			q3.c = q4.a = (q3.b + q4.b) / 2;
			return [q1, q2, q3, q4];
		},
		    _calculateControlPoints = function (a, curviness, quad, basic, correlate) {
			var l = a.length - 1,
			    ii = 0,
			    cp1 = a[0].a,
			    i,
			    p1,
			    p2,
			    p3,
			    seg,
			    m1,
			    m2,
			    mm,
			    cp2,
			    qb,
			    r1,
			    r2,
			    tl;
			for (i = 0; i < l; i++) {
				seg = a[ii];
				p1 = seg.a;
				p2 = seg.d;
				p3 = a[ii + 1].d;

				if (correlate) {
					r1 = _r1[i];
					r2 = _r2[i];
					tl = (r2 + r1) * curviness * 0.25 / (basic ? 0.5 : _r3[i] || 0.5);
					m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : r1 !== 0 ? tl / r1 : 0);
					m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : r2 !== 0 ? tl / r2 : 0);
					mm = p2 - (m1 + ((m2 - m1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));
				} else {
					m1 = p2 - (p2 - p1) * curviness * 0.5;
					m2 = p2 + (p3 - p2) * curviness * 0.5;
					mm = p2 - (m1 + m2) / 2;
				}
				m1 += mm;
				m2 += mm;

				seg.c = cp2 = m1;
				if (i !== 0) {
					seg.b = cp1;
				} else {
					seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
				}

				seg.da = p2 - p1;
				seg.ca = cp2 - p1;
				seg.ba = cp1 - p1;

				if (quad) {
					qb = cubicToQuadratic(p1, cp1, cp2, p2);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
					ii += 4;
				} else {
					ii++;
				}

				cp1 = m2;
			}
			seg = a[ii];
			seg.b = cp1;
			seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
			seg.da = seg.d - seg.a;
			seg.ca = seg.c - seg.a;
			seg.ba = cp1 - seg.a;
			if (quad) {
				qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
				a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
			}
		},
		    _parseAnchors = function (values, p, correlate, prepend) {
			var a = [],
			    l,
			    i,
			    p1,
			    p2,
			    p3,
			    tmp;
			if (prepend) {
				values = [prepend].concat(values);
				i = values.length;
				while (--i > -1) {
					if (typeof (tmp = values[i][p]) === "string") if (tmp.charAt(1) === "=") {
						values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
					}
				}
			}
			l = values.length - 2;
			if (l < 0) {
				a[0] = new Segment(values[0][p], 0, 0, values[l < -1 ? 0 : 1][p]);
				return a;
			}
			for (i = 0; i < l; i++) {
				p1 = values[i][p];
				p2 = values[i + 1][p];
				a[i] = new Segment(p1, 0, 0, p2);
				if (correlate) {
					p3 = values[i + 2][p];
					_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
					_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
				}
			}
			a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]);
			return a;
		},
		    bezierThrough = function (values, curviness, quadratic, basic, correlate, prepend) {
			var obj = {},
			    props = [],
			    first = prepend || values[0],
			    i,
			    p,
			    a,
			    j,
			    r,
			    l,
			    seamless,
			    last;
			correlate = typeof correlate === "string" ? "," + correlate + "," : _correlate;
			if (curviness == null) {
				curviness = 1;
			}
			for (p in values[0]) {
				props.push(p);
			}
			//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
			if (values.length > 1) {
				last = values[values.length - 1];
				seamless = true;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					if (Math.abs(first[p] - last[p]) > 0.05) {
						//build in a tolerance of +/-0.05 to accommodate rounding errors.
						seamless = false;
						break;
					}
				}
				if (seamless) {
					values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
					if (prepend) {
						values.unshift(prepend);
					}
					values.push(values[1]);
					prepend = values[values.length - 3];
				}
			}
			_r1.length = _r2.length = _r3.length = 0;
			i = props.length;
			while (--i > -1) {
				p = props[i];
				_corProps[p] = correlate.indexOf("," + p + ",") !== -1;
				obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
			}
			i = _r1.length;
			while (--i > -1) {
				_r1[i] = Math.sqrt(_r1[i]);
				_r2[i] = Math.sqrt(_r2[i]);
			}
			if (!basic) {
				i = props.length;
				while (--i > -1) {
					if (_corProps[p]) {
						a = obj[props[i]];
						l = a.length - 1;
						for (j = 0; j < l; j++) {
							r = a[j + 1].da / _r2[j] + a[j].da / _r1[j] || 0;
							_r3[j] = (_r3[j] || 0) + r * r;
						}
					}
				}
				i = _r3.length;
				while (--i > -1) {
					_r3[i] = Math.sqrt(_r3[i]);
				}
			}
			i = props.length;
			j = quadratic ? 4 : 1;
			while (--i > -1) {
				p = props[i];
				a = obj[p];
				_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
				if (seamless) {
					a.splice(0, j);
					a.splice(a.length - j, j);
				}
			}
			return obj;
		},
		    _parseBezierData = function (values, type, prepend) {
			type = type || "soft";
			var obj = {},
			    inc = type === "cubic" ? 3 : 2,
			    soft = type === "soft",
			    props = [],
			    a,
			    b,
			    c,
			    d,
			    cur,
			    i,
			    j,
			    l,
			    p,
			    cnt,
			    tmp;
			if (soft && prepend) {
				values = [prepend].concat(values);
			}
			if (values == null || values.length < inc + 1) {
				throw "invalid Bezier data";
			}
			for (p in values[0]) {
				props.push(p);
			}
			i = props.length;
			while (--i > -1) {
				p = props[i];
				obj[p] = cur = [];
				cnt = 0;
				l = values.length;
				for (j = 0; j < l; j++) {
					a = prepend == null ? values[j][p] : typeof (tmp = values[j][p]) === "string" && tmp.charAt(1) === "=" ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
					if (soft) if (j > 1) if (j < l - 1) {
						cur[cnt++] = (a + cur[cnt - 2]) / 2;
					}
					cur[cnt++] = a;
				}
				l = cnt - inc + 1;
				cnt = 0;
				for (j = 0; j < l; j += inc) {
					a = cur[j];
					b = cur[j + 1];
					c = cur[j + 2];
					d = inc === 2 ? 0 : cur[j + 3];
					cur[cnt++] = tmp = inc === 3 ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
				}
				cur.length = cnt;
			}
			return obj;
		},
		    _addCubicLengths = function (a, steps, resolution) {
			var inc = 1 / resolution,
			    j = a.length,
			    d,
			    d1,
			    s,
			    da,
			    ca,
			    ba,
			    p,
			    i,
			    inv,
			    bez,
			    index;
			while (--j > -1) {
				bez = a[j];
				s = bez.a;
				da = bez.d - s;
				ca = bez.c - s;
				ba = bez.b - s;
				d = d1 = 0;
				for (i = 1; i <= resolution; i++) {
					p = inc * i;
					inv = 1 - p;
					d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
					index = j * resolution + i - 1;
					steps[index] = (steps[index] || 0) + d * d;
				}
			}
		},
		    _parseLengthData = function (obj, resolution) {
			resolution = resolution >> 0 || 6;
			var a = [],
			    lengths = [],
			    d = 0,
			    total = 0,
			    threshold = resolution - 1,
			    segments = [],
			    curLS = [],
			    //current length segments array
			p,
			    i,
			    l,
			    index;
			for (p in obj) {
				_addCubicLengths(obj[p], a, resolution);
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				d += Math.sqrt(a[i]);
				index = i % resolution;
				curLS[index] = d;
				if (index === threshold) {
					total += d;
					index = i / resolution >> 0;
					segments[index] = curLS;
					lengths[index] = total;
					d = 0;
					curLS = [];
				}
			}
			return { length: total, lengths: lengths, segments: segments };
		},
		    BezierPlugin = _gsScope._gsDefine.plugin({
			propName: "bezier",
			priority: -1,
			version: "1.3.5",
			API: 2,
			global: true,

			//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function (target, vars, tween) {
				this._target = target;
				if (vars instanceof Array) {
					vars = { values: vars };
				}
				this._func = {};
				this._round = {};
				this._props = [];
				this._timeRes = vars.timeResolution == null ? 6 : parseInt(vars.timeResolution, 10);
				var values = vars.values || [],
				    first = {},
				    second = values[0],
				    autoRotate = vars.autoRotate || tween.vars.orientToBezier,
				    p,
				    isFunc,
				    i,
				    j,
				    prepend;

				this._autoRotate = autoRotate ? autoRotate instanceof Array ? autoRotate : [["x", "y", "rotation", autoRotate === true ? 0 : Number(autoRotate) || 0]] : null;
				for (p in second) {
					this._props.push(p);
				}

				i = this._props.length;
				while (--i > -1) {
					p = this._props[i];

					this._overwriteProps.push(p);
					isFunc = this._func[p] = typeof target[p] === "function";
					first[p] = !isFunc ? parseFloat(target[p]) : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]();
					if (!prepend) if (first[p] !== values[0][p]) {
						prepend = first;
					}
				}
				this._beziers = vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft" ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, vars.type === "thruBasic", vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
				this._segCount = this._beziers[p].length;

				if (this._timeRes) {
					var ld = _parseLengthData(this._beziers, this._timeRes);
					this._length = ld.length;
					this._lengths = ld.lengths;
					this._segments = ld.segments;
					this._l1 = this._li = this._s1 = this._si = 0;
					this._l2 = this._lengths[0];
					this._curSeg = this._segments[0];
					this._s2 = this._curSeg[0];
					this._prec = 1 / this._curSeg.length;
				}

				if (autoRotate = this._autoRotate) {
					this._initialRotations = [];
					if (!(autoRotate[0] instanceof Array)) {
						this._autoRotate = autoRotate = [autoRotate];
					}
					i = autoRotate.length;
					while (--i > -1) {
						for (j = 0; j < 3; j++) {
							p = autoRotate[i][j];
							this._func[p] = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)] : false;
						}
						p = autoRotate[i][2];
						this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
					}
				}
				this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
				return true;
			},

			//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
			set: function (v) {
				var segments = this._segCount,
				    func = this._func,
				    target = this._target,
				    notStart = v !== this._startRatio,
				    curIndex,
				    inv,
				    i,
				    p,
				    b,
				    t,
				    val,
				    l,
				    lengths,
				    curSeg;
				if (!this._timeRes) {
					curIndex = v < 0 ? 0 : v >= 1 ? segments - 1 : segments * v >> 0;
					t = (v - curIndex * (1 / segments)) * segments;
				} else {
					lengths = this._lengths;
					curSeg = this._curSeg;
					v *= this._length;
					i = this._li;
					//find the appropriate segment (if the currently cached one isn't correct)
					if (v > this._l2 && i < segments - 1) {
						l = segments - 1;
						while (i < l && (this._l2 = lengths[++i]) <= v) {}
						this._l1 = lengths[i - 1];
						this._li = i;
						this._curSeg = curSeg = this._segments[i];
						this._s2 = curSeg[this._s1 = this._si = 0];
					} else if (v < this._l1 && i > 0) {
						while (i > 0 && (this._l1 = lengths[--i]) >= v) {}
						if (i === 0 && v < this._l1) {
							this._l1 = 0;
						} else {
							i++;
						}
						this._l2 = lengths[i];
						this._li = i;
						this._curSeg = curSeg = this._segments[i];
						this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
						this._s2 = curSeg[this._si];
					}
					curIndex = i;
					//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
					v -= this._l1;
					i = this._si;
					if (v > this._s2 && i < curSeg.length - 1) {
						l = curSeg.length - 1;
						while (i < l && (this._s2 = curSeg[++i]) <= v) {}
						this._s1 = curSeg[i - 1];
						this._si = i;
					} else if (v < this._s1 && i > 0) {
						while (i > 0 && (this._s1 = curSeg[--i]) >= v) {}
						if (i === 0 && v < this._s1) {
							this._s1 = 0;
						} else {
							i++;
						}
						this._s2 = curSeg[i];
						this._si = i;
					}
					t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec || 0;
				}
				inv = 1 - t;

				i = this._props.length;
				while (--i > -1) {
					p = this._props[i];
					b = this._beziers[p][curIndex];
					val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
					if (this._round[p]) {
						val = Math.round(val);
					}
					if (func[p]) {
						target[p](val);
					} else {
						target[p] = val;
					}
				}

				if (this._autoRotate) {
					var ar = this._autoRotate,
					    b2,
					    x1,
					    y1,
					    x2,
					    y2,
					    add,
					    conv;
					i = ar.length;
					while (--i > -1) {
						p = ar[i][2];
						add = ar[i][3] || 0;
						conv = ar[i][4] === true ? 1 : _RAD2DEG;
						b = this._beziers[ar[i][0]];
						b2 = this._beziers[ar[i][1]];

						if (b && b2) {
							//in case one of the properties got overwritten.
							b = b[curIndex];
							b2 = b2[curIndex];

							x1 = b.a + (b.b - b.a) * t;
							x2 = b.b + (b.c - b.b) * t;
							x1 += (x2 - x1) * t;
							x2 += (b.c + (b.d - b.c) * t - x2) * t;

							y1 = b2.a + (b2.b - b2.a) * t;
							y2 = b2.b + (b2.c - b2.b) * t;
							y1 += (y2 - y1) * t;
							y2 += (b2.c + (b2.d - b2.c) * t - y2) * t;

							val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}
					}
				}
			}
		}),
		    p = BezierPlugin.prototype;

		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function (a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function () {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
			    _parseToProxy = _internals._parseToProxy,
			    _setPluginRatio = _internals._setPluginRatio,
			    CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", { parser: function (t, e, prop, cssp, pt, plugin) {
					if (e instanceof Array) {
						e = { values: e };
					}
					plugin = new BezierPlugin();
					var values = e.values,
					    l = values.length - 1,
					    pluginValues = [],
					    v = {},
					    i,
					    p,
					    data;
					if (l < 0) {
						return pt;
					}
					for (i = 0; i <= l; i++) {
						data = _parseToProxy(t, values[i], cssp, pt, plugin, l !== i);
						pluginValues[i] = data.end;
					}
					for (p in e) {
						v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
					}
					v.values = pluginValues;
					pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
					pt.data = data;
					pt.plugin = plugin;
					pt.setRatio = _setPluginRatio;
					if (v.autoRotate === 0) {
						v.autoRotate = true;
					}
					if (v.autoRotate && !(v.autoRotate instanceof Array)) {
						i = v.autoRotate === true ? 0 : Number(v.autoRotate);
						v.autoRotate = data.end.left != null ? [["left", "top", "rotation", i, false]] : data.end.x != null ? [["x", "y", "rotation", i, false]] : false;
					}
					if (v.autoRotate) {
						if (!cssp._transform) {
							cssp._enableTransforms(false);
						}
						data.autoRotate = cssp._target._gsTransform;
					}
					plugin._onInitTween(data.proxy, v, cssp._tween);
					return pt;
				} });
		};

		p._roundProps = function (lookup, value) {
			var op = this._overwriteProps,
			    i = op.length;
			while (--i > -1) {
				if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
					this._round[op[i]] = value;
				}
			}
		};

		p._kill = function (lookup) {
			var a = this._props,
			    p,
			    i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};
	})();

	/*
  * ----------------------------------------------------------------
  * CSSPlugin
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (TweenPlugin, TweenLite) {

		/** @constructor **/
		var CSSPlugin = function () {
			TweenPlugin.call(this, "css");
			this._overwriteProps.length = 0;
			this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
		},
		    _globals = _gsScope._gsDefine.globals,
		    _hasPriority,
		    //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
		_suffixMap,
		    //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
		_cs,
		    //computed style (we store this in a shared variable to conserve memory and make minification tighter
		_overwriteProps,
		    //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
		_specialProps = {},
		    p = CSSPlugin.prototype = new TweenPlugin("css");

		p.constructor = CSSPlugin;
		CSSPlugin.version = "1.18.4";
		CSSPlugin.API = 2;
		CSSPlugin.defaultTransformPerspective = 0;
		CSSPlugin.defaultSkewType = "compensated";
		CSSPlugin.defaultSmoothOrigin = true;
		p = "px"; //we'll reuse the "p" variable to keep file size down
		CSSPlugin.suffixMap = { top: p, right: p, bottom: p, left: p, width: p, height: p, fontSize: p, padding: p, margin: p, perspective: p, lineHeight: "" };

		var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
		    _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
		    _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
		    //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
		_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
		    //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
		_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
		    _opacityExp = /opacity *= *([^)]*)/i,
		    _opacityValExp = /opacity:([^;]*)/i,
		    _alphaFilterExp = /alpha\(opacity *=.+?\)/i,
		    _rgbhslExp = /^(rgb|hsl)/,
		    _capsExp = /([A-Z])/g,
		    _camelExp = /-([a-z])/gi,
		    _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
		    //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
		_camelFunc = function (s, g) {
			return g.toUpperCase();
		},
		    _horizExp = /(?:Left|Right|Width)/i,
		    _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
		    _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
		    _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi,
		    //finds any commas that are not within parenthesis
		_complexExp = /[\s,\(]/i,
		    //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
		_DEG2RAD = Math.PI / 180,
		    _RAD2DEG = 180 / Math.PI,
		    _forcePT = {},
		    _doc = document,
		    _createElement = function (type) {
			return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
		},
		    _tempDiv = _createElement("div"),
		    _tempImg = _createElement("img"),
		    _internals = CSSPlugin._internals = { _specialProps: _specialProps },
		    //provides a hook to a few internal methods that we need to access from inside other plugins
		_agent = navigator.userAgent,
		    _autoRound,
		    _reqSafariFix,
		    //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

		_isSafari,
		    _isFirefox,
		    //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
		_isSafariLT6,
		    //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
		_ieVers,
		    _supportsOpacity = function () {
			//we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
			var i = _agent.indexOf("Android"),
			    a = _createElement("a");
			_isSafari = _agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i + 8, 1)) > 3);
			_isSafariLT6 = _isSafari && Number(_agent.substr(_agent.indexOf("Version/") + 8, 1)) < 6;
			_isFirefox = _agent.indexOf("Firefox") !== -1;
			if (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(_agent)) {
				_ieVers = parseFloat(RegExp.$1);
			}
			if (!a) {
				return false;
			}
			a.style.cssText = "top:1px;opacity:.55;";
			return (/^0.55/.test(a.style.opacity)
			);
		}(),
		    _getIEOpacity = function (v) {
			return _opacityExp.test(typeof v === "string" ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
		},
		    _log = function (s) {
			//for logging messages, but in a way that won't throw errors in old versions of IE.
			if (window.console) {
				console.log(s);
			}
		},
		    _prefixCSS = "",
		    //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
		_prefix = "",
		    //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

		// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
		_checkPropPrefix = function (p, e) {
			e = e || _tempDiv;
			var s = e.style,
			    a,
			    i;
			if (s[p] !== undefined) {
				return p;
			}
			p = p.charAt(0).toUpperCase() + p.substr(1);
			a = ["O", "Moz", "ms", "Ms", "Webkit"];
			i = 5;
			while (--i > -1 && s[a[i] + p] === undefined) {}
			if (i >= 0) {
				_prefix = i === 3 ? "ms" : a[i];
				_prefixCSS = "-" + _prefix.toLowerCase() + "-";
				return _prefix + p;
			}
			return null;
		},
		    _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function () {},


		/**
   * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
   * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
   *
   * @param {!Object} t Target element whose style property you want to query
   * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
   * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
   * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
   * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
   * @return {?string} The current property value
   */
		_getStyle = CSSPlugin.getStyle = function (t, p, cs, calc, dflt) {
			var rv;
			if (!_supportsOpacity) if (p === "opacity") {
				//several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
				return _getIEOpacity(t);
			}
			if (!calc && t.style[p]) {
				rv = t.style[p];
			} else if (cs = cs || _getComputedStyle(t)) {
				rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
			} else if (t.currentStyle) {
				rv = t.currentStyle[p];
			}
			return dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto") ? dflt : rv;
		},


		/**
   * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
   * @param {!Object} t Target element
   * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
   * @param {!number} v Value
   * @param {string=} sfx Suffix (like "px" or "%" or "em")
   * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
   * @return {number} value in pixels
   */
		_convertToPixels = _internals.convertToPixels = function (t, p, v, sfx, recurse) {
			if (sfx === "px" || !sfx) {
				return v;
			}
			if (sfx === "auto" || !v) {
				return 0;
			}
			var horiz = _horizExp.test(p),
			    node = t,
			    style = _tempDiv.style,
			    neg = v < 0,
			    pix,
			    cache,
			    time;
			if (neg) {
				v = -v;
			}
			if (sfx === "%" && p.indexOf("border") !== -1) {
				pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight);
			} else {
				style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
				if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
					node = t.parentNode || _doc.body;
					cache = node._gsCache;
					time = TweenLite.ticker.frame;
					if (cache && horiz && cache.time === time) {
						//performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
						return cache.width * v / 100;
					}
					style[horiz ? "width" : "height"] = v + sfx;
				} else {
					style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx;
				}
				node.appendChild(_tempDiv);
				pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]);
				node.removeChild(_tempDiv);
				if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
					cache = node._gsCache = node._gsCache || {};
					cache.time = time;
					cache.width = pix / v * 100;
				}
				if (pix === 0 && !recurse) {
					pix = _convertToPixels(t, p, v, sfx, true);
				}
			}
			return neg ? -pix : pix;
		},
		    _calculateOffset = _internals.calculateOffset = function (t, p, cs) {
			//for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
			if (_getStyle(t, "position", cs) !== "absolute") {
				return 0;
			}
			var dim = p === "left" ? "Left" : "Top",
			    v = _getStyle(t, "margin" + dim, cs);
			return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
		},


		// @private returns at object containing ALL of the style properties in camelCase and their associated values.
		_getAllStyles = function (t, cs) {
			var s = {},
			    i,
			    tr,
			    p;
			if (cs = cs || _getComputedStyle(t, null)) {
				if (i = cs.length) {
					while (--i > -1) {
						p = cs[i];
						if (p.indexOf("-transform") === -1 || _transformPropCSS === p) {
							//Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
							s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
						}
					}
				} else {
					//some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
					for (i in cs) {
						if (i.indexOf("Transform") === -1 || _transformProp === i) {
							//Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
							s[i] = cs[i];
						}
					}
				}
			} else if (cs = t.currentStyle || t.style) {
				for (i in cs) {
					if (typeof i === "string" && s[i] === undefined) {
						s[i.replace(_camelExp, _camelFunc)] = cs[i];
					}
				}
			}
			if (!_supportsOpacity) {
				s.opacity = _getIEOpacity(t);
			}
			tr = _getTransform(t, cs, false);
			s.rotation = tr.rotation;
			s.skewX = tr.skewX;
			s.scaleX = tr.scaleX;
			s.scaleY = tr.scaleY;
			s.x = tr.x;
			s.y = tr.y;
			if (_supports3D) {
				s.z = tr.z;
				s.rotationX = tr.rotationX;
				s.rotationY = tr.rotationY;
				s.scaleZ = tr.scaleZ;
			}
			if (s.filters) {
				delete s.filters;
			}
			return s;
		},


		// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
		_cssDif = function (t, s1, s2, vars, forceLookup) {
			var difs = {},
			    style = t.style,
			    val,
			    p,
			    mpt;
			for (p in s2) {
				if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p]) if (p.indexOf("Origin") === -1) if (typeof val === "number" || typeof val === "string") {
					difs[p] = val === "auto" && (p === "left" || p === "top") ? _calculateOffset(t, p) : (val === "" || val === "auto" || val === "none") && typeof s1[p] === "string" && s1[p].replace(_NaNExp, "") !== "" ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
					if (style[p] !== undefined) {
						//for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
						mpt = new MiniPropTween(style, p, style[p], mpt);
					}
				}
			}
			if (vars) {
				for (p in vars) {
					//copy properties (except className)
					if (p !== "className") {
						difs[p] = vars[p];
					}
				}
			}
			return { difs: difs, firstMPT: mpt };
		},
		    _dimensions = { width: ["Left", "Right"], height: ["Top", "Bottom"] },
		    _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"],


		/**
   * @private Gets the width or height of an element
   * @param {!Object} t Target element
   * @param {!string} p Property name ("width" or "height")
   * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
   * @return {number} Dimension (in pixels)
   */
		_getDimension = function (t, p, cs) {
			if ((t.nodeName + "").toLowerCase() === "svg") {
				//Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
				return (cs || _getComputedStyle(t))[p] || 0;
			} else if (t.getBBox && _isSVG(t)) {
				return t.getBBox()[p] || 0;
			}
			var v = parseFloat(p === "width" ? t.offsetWidth : t.offsetHeight),
			    a = _dimensions[p],
			    i = a.length;
			cs = cs || _getComputedStyle(t, null);
			while (--i > -1) {
				v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0;
				v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0;
			}
			return v;
		},


		// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
		_parsePosition = function (v, recObj) {
			if (v === "contain" || v === "auto" || v === "auto auto") {
				return v + " ";
			}
			if (v == null || v === "") {
				//note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
				v = "0 0";
			}
			var a = v.split(" "),
			    x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0],
			    y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1],
			    i;
			if (a.length > 3 && !recObj) {
				//multiple positions
				a = v.split(", ").join(",").split(",");
				v = [];
				for (i = 0; i < a.length; i++) {
					v.push(_parsePosition(a[i]));
				}
				return v.join(",");
			}
			if (y == null) {
				y = x === "center" ? "50%" : "0";
			} else if (y === "center") {
				y = "50%";
			}
			if (x === "center" || isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1) {
				//remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
				x = "50%";
			}
			v = x + " " + y + (a.length > 2 ? " " + a[2] : "");
			if (recObj) {
				recObj.oxp = x.indexOf("%") !== -1;
				recObj.oyp = y.indexOf("%") !== -1;
				recObj.oxr = x.charAt(1) === "=";
				recObj.oyr = y.charAt(1) === "=";
				recObj.ox = parseFloat(x.replace(_NaNExp, ""));
				recObj.oy = parseFloat(y.replace(_NaNExp, ""));
				recObj.v = v;
			}
			return recObj || v;
		},


		/**
   * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
   * @param {(number|string)} e End value which is typically a string, but could be a number
   * @param {(number|string)} b Beginning value which is typically a string but could be a number
   * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
   */
		_parseChange = function (e, b) {
			return typeof e === "string" && e.charAt(1) === "=" ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b) || 0;
		},


		/**
   * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
   * @param {Object} v Value to be parsed
   * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
   * @return {number} Parsed value
   */
		_parseVal = function (v, d) {
			return v == null ? d : typeof v === "string" && v.charAt(1) === "=" ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
		},


		/**
   * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
   * @param {Object} v Value to be parsed
   * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
   * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
   * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
   * @return {number} parsed angle in radians
   */
		_parseAngle = function (v, d, p, directionalEnd) {
			var min = 0.000001,
			    cap,
			    split,
			    dif,
			    result,
			    isRelative;
			if (v == null) {
				result = d;
			} else if (typeof v === "number") {
				result = v;
			} else {
				cap = 360;
				split = v.split("_");
				isRelative = v.charAt(1) === "=";
				dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * (v.indexOf("rad") === -1 ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
				if (split.length) {
					if (directionalEnd) {
						directionalEnd[p] = d + dif;
					}
					if (v.indexOf("short") !== -1) {
						dif = dif % cap;
						if (dif !== dif % (cap / 2)) {
							dif = dif < 0 ? dif + cap : dif - cap;
						}
					}
					if (v.indexOf("_cw") !== -1 && dif < 0) {
						dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
					} else if (v.indexOf("ccw") !== -1 && dif > 0) {
						dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
					}
				}
				result = d + dif;
			}
			if (result < min && result > -min) {
				result = 0;
			}
			return result;
		},
		    _colorLookup = { aqua: [0, 255, 255],
			lime: [0, 255, 0],
			silver: [192, 192, 192],
			black: [0, 0, 0],
			maroon: [128, 0, 0],
			teal: [0, 128, 128],
			blue: [0, 0, 255],
			navy: [0, 0, 128],
			white: [255, 255, 255],
			fuchsia: [255, 0, 255],
			olive: [128, 128, 0],
			yellow: [255, 255, 0],
			orange: [255, 165, 0],
			gray: [128, 128, 128],
			purple: [128, 0, 128],
			green: [0, 128, 0],
			red: [255, 0, 0],
			pink: [255, 192, 203],
			cyan: [0, 255, 255],
			transparent: [255, 255, 255, 0] },
		    _hue = function (h, m1, m2) {
			h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
			return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + 0.5 | 0;
		},


		/**
   * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
   * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
   * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
   * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
   */
		_parseColor = CSSPlugin.parseColor = function (v, toHSL) {
			var a, r, g, b, h, s, l, max, min, d, wasHSL;
			if (!v) {
				a = _colorLookup.black;
			} else if (typeof v === "number") {
				a = [v >> 16, v >> 8 & 255, v & 255];
			} else {
				if (v.charAt(v.length - 1) === ",") {
					//sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
					v = v.substr(0, v.length - 1);
				}
				if (_colorLookup[v]) {
					a = _colorLookup[v];
				} else if (v.charAt(0) === "#") {
					if (v.length === 4) {
						//for shorthand like #9F0
						r = v.charAt(1);
						g = v.charAt(2);
						b = v.charAt(3);
						v = "#" + r + r + g + g + b + b;
					}
					v = parseInt(v.substr(1), 16);
					a = [v >> 16, v >> 8 & 255, v & 255];
				} else if (v.substr(0, 3) === "hsl") {
					a = wasHSL = v.match(_numExp);
					if (!toHSL) {
						h = Number(a[0]) % 360 / 360;
						s = Number(a[1]) / 100;
						l = Number(a[2]) / 100;
						g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
						r = l * 2 - g;
						if (a.length > 3) {
							a[3] = Number(v[3]);
						}
						a[0] = _hue(h + 1 / 3, r, g);
						a[1] = _hue(h, r, g);
						a[2] = _hue(h - 1 / 3, r, g);
					} else if (v.indexOf("=") !== -1) {
						//if relative values are found, just return the raw strings with the relative prefixes in place.
						return v.match(_relNumExp);
					}
				} else {
					a = v.match(_numExp) || _colorLookup.transparent;
				}
				a[0] = Number(a[0]);
				a[1] = Number(a[1]);
				a[2] = Number(a[2]);
				if (a.length > 3) {
					a[3] = Number(a[3]);
				}
			}
			if (toHSL && !wasHSL) {
				r = a[0] / 255;
				g = a[1] / 255;
				b = a[2] / 255;
				max = Math.max(r, g, b);
				min = Math.min(r, g, b);
				l = (max + min) / 2;
				if (max === min) {
					h = s = 0;
				} else {
					d = max - min;
					s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
					h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
					h *= 60;
				}
				a[0] = h + 0.5 | 0;
				a[1] = s * 100 + 0.5 | 0;
				a[2] = l * 100 + 0.5 | 0;
			}
			return a;
		},
		    _formatColors = function (s, toHSL) {
			var colors = s.match(_colorExp) || [],
			    charIndex = 0,
			    parsed = colors.length ? "" : s,
			    i,
			    color,
			    temp;
			for (i = 0; i < colors.length; i++) {
				color = colors[i];
				temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
				charIndex += temp.length + color.length;
				color = _parseColor(color, toHSL);
				if (color.length === 3) {
					color.push(1);
				}
				parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
			}
			return parsed + s.substr(charIndex);
		},
		    _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

		for (p in _colorLookup) {
			_colorExp += "|" + p + "\\b";
		}
		_colorExp = new RegExp(_colorExp + ")", "gi");

		CSSPlugin.colorStringFilter = function (a) {
			var combined = a[0] + a[1],
			    toHSL;
			if (_colorExp.test(combined)) {
				toHSL = combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1;
				a[0] = _formatColors(a[0], toHSL);
				a[1] = _formatColors(a[1], toHSL);
			}
			_colorExp.lastIndex = 0;
		};

		if (!TweenLite.defaultStringFilter) {
			TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter;
		}

		/**
   * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
   * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
   * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
   * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
   * @return {Function} formatter function
   */
		var _getFormatter = function (dflt, clr, collapsible, multi) {
			if (dflt == null) {
				return function (v) {
					return v;
				};
			}
			var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
			    dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
			    pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
			    sfx = dflt.charAt(dflt.length - 1) === ")" ? ")" : "",
			    delim = dflt.indexOf(" ") !== -1 ? " " : ",",
			    numVals = dVals.length,
			    dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "",
			    formatter;
			if (!numVals) {
				return function (v) {
					return v;
				};
			}
			if (clr) {
				formatter = function (v) {
					var color, vals, i, a;
					if (typeof v === "number") {
						v += dSfx;
					} else if (multi && _commasOutsideParenExp.test(v)) {
						a = v.replace(_commasOutsideParenExp, "|").split("|");
						for (i = 0; i < a.length; i++) {
							a[i] = formatter(a[i]);
						}
						return a.join(",");
					}
					color = (v.match(_colorExp) || [dColor])[0];
					vals = v.split(color).join("").match(_valuesExp) || [];
					i = vals.length;
					if (numVals > i--) {
						while (++i < numVals) {
							vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
						}
					}
					return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
				};
				return formatter;
			}
			formatter = function (v) {
				var vals, a, i;
				if (typeof v === "number") {
					v += dSfx;
				} else if (multi && _commasOutsideParenExp.test(v)) {
					a = v.replace(_commasOutsideParenExp, "|").split("|");
					for (i = 0; i < a.length; i++) {
						a[i] = formatter(a[i]);
					}
					return a.join(",");
				}
				vals = v.match(_valuesExp) || [];
				i = vals.length;
				if (numVals > i--) {
					while (++i < numVals) {
						vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
					}
				}
				return pfx + vals.join(delim) + sfx;
			};
			return formatter;
		},


		/**
   * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
   * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
   * @return {Function} a formatter function
   */
		_getEdgeParser = function (props) {
			props = props.split(",");
			return function (t, e, p, cssp, pt, plugin, vars) {
				var a = (e + "").split(" "),
				    i;
				vars = {};
				for (i = 0; i < 4; i++) {
					vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0];
				}
				return cssp.parse(t, vars, pt, plugin);
			};
		},


		// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens  which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
		_setPluginRatio = _internals._setPluginRatio = function (v) {
			this.plugin.setRatio(v);
			var d = this.data,
			    proxy = d.proxy,
			    mpt = d.firstMPT,
			    min = 0.000001,
			    val,
			    pt,
			    i,
			    str,
			    p;
			while (mpt) {
				val = proxy[mpt.v];
				if (mpt.r) {
					val = Math.round(val);
				} else if (val < min && val > -min) {
					val = 0;
				}
				mpt.t[mpt.p] = val;
				mpt = mpt._next;
			}
			if (d.autoRotate) {
				d.autoRotate.rotation = proxy.rotation;
			}
			//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.
			if (v === 1 || v === 0) {
				mpt = d.firstMPT;
				p = v === 1 ? "e" : "b";
				while (mpt) {
					pt = mpt.t;
					if (!pt.type) {
						pt[p] = pt.s + pt.xs0;
					} else if (pt.type === 1) {
						str = pt.xs0 + pt.s + pt.xs1;
						for (i = 1; i < pt.l; i++) {
							str += pt["xn" + i] + pt["xs" + (i + 1)];
						}
						pt[p] = str;
					}
					mpt = mpt._next;
				}
			}
		},


		/**
   * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
   * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
   * @param {!string} p property name
   * @param {(number|string|object)} v value
   * @param {MiniPropTween=} next next MiniPropTween in the linked list
   * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
   */
		MiniPropTween = function (t, p, v, next, r) {
			this.t = t;
			this.p = p;
			this.v = v;
			this.r = r;
			if (next) {
				next._prev = this;
				this._next = next;
			}
		},


		/**
   * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
   * This method returns an object that has the following properties:
   *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
   *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
   *  - firstMPT: the first MiniPropTween in the linked list
   *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
   * @param {!Object} t target object to be tweened
   * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
   * @param {!CSSPlugin} cssp The CSSPlugin instance
   * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
   * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
   * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
   * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
   */
		_parseToProxy = _internals._parseToProxy = function (t, vars, cssp, pt, plugin, shallow) {
			var bpt = pt,
			    start = {},
			    end = {},
			    transform = cssp._transform,
			    oldForce = _forcePT,
			    i,
			    p,
			    xp,
			    mpt,
			    firstPT;
			cssp._transform = null;
			_forcePT = vars;
			pt = firstPT = cssp.parse(t, vars, pt, plugin);
			_forcePT = oldForce;
			//break off from the linked list so the new ones are isolated.
			if (shallow) {
				cssp._transform = transform;
				if (bpt) {
					bpt._prev = null;
					if (bpt._prev) {
						bpt._prev._next = null;
					}
				}
			}
			while (pt && pt !== bpt) {
				if (pt.type <= 1) {
					p = pt.p;
					end[p] = pt.s + pt.c;
					start[p] = pt.s;
					if (!shallow) {
						mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
						pt.c = 0;
					}
					if (pt.type === 1) {
						i = pt.l;
						while (--i > 0) {
							xp = "xn" + i;
							p = pt.p + "_" + xp;
							end[p] = pt.data[xp];
							start[p] = pt[xp];
							if (!shallow) {
								mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
							}
						}
					}
				}
				pt = pt._next;
			}
			return { proxy: start, end: end, firstMPT: mpt, pt: firstPT };
		},


		/**
   * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
   * CSSPropTweens have the following optional properties as well (not defined through the constructor):
   *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
   *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
   *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
   *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
   *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
   * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
   * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
   * @param {number} s Starting numeric value
   * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
   * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
   * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
   * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
   * @param {boolean=} r If true, the value(s) should be rounded
   * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
   * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
   * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
   */
		CSSPropTween = _internals.CSSPropTween = function (t, p, s, c, next, type, n, r, pr, b, e) {
			this.t = t; //target
			this.p = p; //property
			this.s = s; //starting value
			this.c = c; //change value
			this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
			if (!(t instanceof CSSPropTween)) {
				_overwriteProps.push(this.n);
			}
			this.r = r; //round (boolean)
			this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
			if (pr) {
				this.pr = pr;
				_hasPriority = true;
			}
			this.b = b === undefined ? s : b;
			this.e = e === undefined ? s + c : e;
			if (next) {
				this._next = next;
				next._prev = this;
			}
		},
		    _addNonTweeningNumericPT = function (target, prop, start, end, next, overwriteProp) {
			//cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
			var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
			pt.b = start;
			pt.e = pt.xs0 = end;
			return pt;
		},


		/**
   * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
   * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
   * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
   * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
   *
   * @param {!Object} t Target whose property will be tweened
   * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
   * @param {string} b Beginning value
   * @param {string} e Ending value
   * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
   * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
   * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
   * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
   * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
   * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
   * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
   */
		_parseComplex = CSSPlugin.parseComplex = function (t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
			//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
			b = b || dflt || "";
			pt = new CSSPropTween(t, p, 0, 0, pt, setRatio ? 2 : 1, null, false, pr, b, e);
			e += ""; //ensures it's a string
			if (clrs && _colorExp.test(e + b)) {
				//if colors are found, normalize the formatting to rgba() or hsla().
				e = [b, e];
				CSSPlugin.colorStringFilter(e);
				b = e[0];
				e = e[1];
			}
			var ba = b.split(", ").join(",").split(" "),
			    //beginning array
			ea = e.split(", ").join(",").split(" "),
			    //ending array
			l = ba.length,
			    autoRound = _autoRound !== false,
			    i,
			    xi,
			    ni,
			    bv,
			    ev,
			    bnums,
			    enums,
			    bn,
			    hasAlpha,
			    temp,
			    cv,
			    str,
			    useHSL;
			if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
				ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
				ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
				l = ba.length;
			}
			if (l !== ea.length) {
				//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
				ba = (dflt || "").split(" ");
				l = ba.length;
			}
			pt.plugin = plugin;
			pt.setRatio = setRatio;
			_colorExp.lastIndex = 0;
			for (i = 0; i < l; i++) {
				bv = ba[i];
				ev = ea[i];
				bn = parseFloat(bv);
				//if the value begins with a number (most common). It's fine if it has a suffix like px
				if (bn || bn === 0) {
					pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && ev.indexOf("px") !== -1, true);

					//if the value is a color
				} else if (clrs && _colorExp.test(bv)) {
						str = ev.indexOf(")") + 1;
						str = ")" + (str ? ev.substr(str) : ""); //if there's a comma or ) at the end, retain it.
						useHSL = ev.indexOf("hsl") !== -1 && _supportsOpacity;
						bv = _parseColor(bv, useHSL);
						ev = _parseColor(ev, useHSL);
						hasAlpha = bv.length + ev.length > 6;
						if (hasAlpha && !_supportsOpacity && ev[3] === 0) {
							//older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
							pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
							pt.e = pt.e.split(ea[i]).join("transparent");
						} else {
							if (!_supportsOpacity) {
								//old versions of IE don't support rgba().
								hasAlpha = false;
							}
							if (useHSL) {
								pt.appendXtra(hasAlpha ? "hsla(" : "hsl(", bv[0], _parseChange(ev[0], bv[0]), ",", false, true).appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false).appendXtra("", bv[2], _parseChange(ev[2], bv[2]), hasAlpha ? "%," : "%" + str, false);
							} else {
								pt.appendXtra(hasAlpha ? "rgba(" : "rgb(", bv[0], ev[0] - bv[0], ",", true, true).appendXtra("", bv[1], ev[1] - bv[1], ",", true).appendXtra("", bv[2], ev[2] - bv[2], hasAlpha ? "," : str, true);
							}

							if (hasAlpha) {
								bv = bv.length < 4 ? 1 : bv[3];
								pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, false);
							}
						}
						_colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.
					} else {
							bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

							//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
							if (!bnums) {
								pt["xs" + pt.l] += pt.l || pt["xs" + pt.l] ? " " + ev : ev;

								//loop through all the numbers that are found and construct the extra values on the pt.
							} else {
									enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
									if (!enums || enums.length !== bnums.length) {
										//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
										return pt;
									}
									ni = 0;
									for (xi = 0; xi < bnums.length; xi++) {
										cv = bnums[xi];
										temp = bv.indexOf(cv, ni);
										pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && bv.substr(temp + cv.length, 2) === "px", xi === 0);
										ni = temp + cv.length;
									}
									pt["xs" + pt.l] += bv.substr(ni);
								}
						}
			}
			//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
			if (e.indexOf("=") !== -1) if (pt.data) {
				str = pt.xs0 + pt.data.s;
				for (i = 1; i < pt.l; i++) {
					str += pt["xs" + i] + pt.data["xn" + i];
				}
				pt.e = str + pt["xs" + i];
			}
			if (!pt.l) {
				pt.type = -1;
				pt.xs0 = pt.e;
			}
			return pt.xfirst || pt;
		},
		    i = 9;

		p = CSSPropTween.prototype;
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
		while (--i > 0) {
			p["xn" + i] = 0;
			p["xs" + i] = "";
		}
		p.xs0 = "";
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;

		/**
   * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
   * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
   * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
   * @param {string=} pfx Prefix (if any)
   * @param {!number} s Starting value
   * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
   * @param {string=} sfx Suffix (if any)
   * @param {boolean=} r Round (if true).
   * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
   * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
   */
		p.appendXtra = function (pfx, s, c, sfx, r, pad) {
			var pt = this,
			    l = pt.l;
			pt["xs" + l] += pad && (l || pt["xs" + l]) ? " " + pfx : pfx || "";
			if (!c) if (l !== 0 && !pt.plugin) {
				//typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt["xs" + pt.l] = sfx || "";
			if (l > 0) {
				pt.data["xn" + l] = s + c;
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt["xn" + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}
				return pt;
			}
			pt.data = { s: s + c };
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		};

		/**
   * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
   * @param {!string} p Property name (like "boxShadow" or "throwProps")
   * @param {Object=} options An object containing any of the following configuration options:
   *                      - defaultValue: the default value
   *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
   *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
   *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
   *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
   *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
   *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
   *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
   *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
   */
		var SpecialProp = function (p, options) {
			options = options || {};
			this.p = options.prefix ? _checkPropPrefix(p) || p : p;
			_specialProps[p] = _specialProps[this.p] = this;
			this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
			if (options.parser) {
				this.parse = options.parser;
			}
			this.clrs = options.color;
			this.multi = options.multi;
			this.keyword = options.keyword;
			this.dflt = options.defaultValue;
			this.pr = options.priority || 0;
		},


		//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
		_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function (p, options, defaults) {
			if (typeof options !== "object") {
				options = { parser: defaults }; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
			}
			var a = p.split(","),
			    d = options.defaultValue,
			    i,
			    temp;
			defaults = defaults || [d];
			for (i = 0; i < a.length; i++) {
				options.prefix = i === 0 && options.prefix;
				options.defaultValue = defaults[i] || d;
				temp = new SpecialProp(a[i], options);
			}
		},


		//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
		_registerPluginProp = function (p) {
			if (!_specialProps[p]) {
				var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
				_registerComplexSpecialProp(p, { parser: function (t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log("Error: " + pluginName + " js file not loaded.");
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					} });
			}
		};

		p = SpecialProp.prototype;

		/**
   * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
   * @param {!Object} t target element
   * @param {(string|number|object)} b beginning value
   * @param {(string|number|object)} e ending (destination) value
   * @param {CSSPropTween=} pt next CSSPropTween in the linked list
   * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
   * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
   * @return {CSSPropTween=} First CSSPropTween in the linked list
   */
		p.parseComplex = function (t, b, e, pt, plugin, setRatio) {
			var kwd = this.keyword,
			    i,
			    ba,
			    ea,
			    l,
			    bi,
			    ei;
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
				ba = b.replace(_commasOutsideParenExp, "|").split("|");
				ea = e.replace(_commasOutsideParenExp, "|").split("|");
			} else if (kwd) {
				ba = [b];
				ea = [e];
			}
			if (ea) {
				l = ea.length > ba.length ? ea.length : ba.length;
				for (i = 0; i < l; i++) {
					b = ba[i] = ba[i] || this.dflt;
					e = ea[i] = ea[i] || this.dflt;
					if (kwd) {
						bi = b.indexOf(kwd);
						ei = e.indexOf(kwd);
						if (bi !== ei) {
							if (ei === -1) {
								//if the keyword isn't in the end value, remove it from the beginning one.
								ba[i] = ba[i].split(kwd).join("");
							} else if (bi === -1) {
								//if the keyword isn't in the beginning, add it.
								ba[i] += " " + kwd;
							}
						}
					}
				}
				b = ba.join(", ");
				e = ea.join(", ");
			}
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
		};

		/**
   * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
   * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
   * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
   * @param {!Object} t Target object whose property is being tweened
   * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
   * @param {!string} p Property name
   * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
   * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
   * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
   * @param {Object=} vars Original vars object that contains the data for parsing.
   * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
   */
		p.parse = function (t, e, p, cssp, pt, plugin, vars) {
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};

		/**
   * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
   *  1) Target object whose property should be tweened (typically a DOM element)
   *  2) The end/destination value (could be a string, number, object, or whatever you want)
   *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
   *
   * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
   *
   * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
   *      var start = target.style.width;
   *      return function(ratio) {
   *              target.style.width = (start + value * ratio) + "px";
   *              console.log("set width to " + target.style.width);
   *          }
   * }, 0);
   *
   * Then, when I do this tween, it will trigger my special property:
   *
   * TweenLite.to(element, 1, {css:{myCustomProp:100}});
   *
   * In the example, of course, we're just changing the width, but you can do anything you want.
   *
   * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
   * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
   * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
   */
		CSSPlugin.registerSpecialProp = function (name, onInitTween, priority) {
			_registerComplexSpecialProp(name, { parser: function (t, e, p, cssp, pt, plugin, vars) {
					var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
					rv.plugin = plugin;
					rv.setRatio = onInitTween(t, e, cssp._tween, p);
					return rv;
				}, priority: priority });
		};

		//transform-related methods and properties
		CSSPlugin.useSVGTransformAttr = _isSafari || _isFirefox; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).
		var _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
		    _transformProp = _checkPropPrefix("transform"),
		    //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
		_transformPropCSS = _prefixCSS + "transform",
		    _transformOriginProp = _checkPropPrefix("transformOrigin"),
		    _supports3D = _checkPropPrefix("perspective") !== null,
		    Transform = _internals.Transform = function () {
			this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
			this.force3D = CSSPlugin.defaultForce3D === false || !_supports3D ? false : CSSPlugin.defaultForce3D || "auto";
		},
		    _SVGElement = window.SVGElement,
		    _useSVGTransformAttr,

		//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

		_createSVG = function (type, container, attributes) {
			var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
			    reg = /([a-z])([A-Z])/g,
			    p;
			for (p in attributes) {
				element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
			}
			container.appendChild(element);
			return element;
		},
		    _docElement = _doc.documentElement,
		    _forceSVGTransformAttr = function () {
			//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
			var force = _ieVers || /Android/i.test(_agent) && !window.chrome,
			    svg,
			    rect,
			    width;
			if (_doc.createElementNS && !force) {
				//IE8 and earlier doesn't support SVG anyway
				svg = _createSVG("svg", _docElement);
				rect = _createSVG("rect", svg, { width: 100, height: 50, x: 100 });
				width = rect.getBoundingClientRect().width;
				rect.style[_transformOriginProp] = "50% 50%";
				rect.style[_transformProp] = "scaleX(0.5)";
				force = width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
				_docElement.removeChild(svg);
			}
			return force;
		}(),
		    _parseSVGOrigin = function (e, local, decoratee, absolute, smoothOrigin, skipRecord) {
			var tm = e._gsTransform,
			    m = _getMatrix(e, true),
			    v,
			    x,
			    y,
			    xOrigin,
			    yOrigin,
			    a,
			    b,
			    c,
			    d,
			    tx,
			    ty,
			    determinant,
			    xOriginOld,
			    yOriginOld;
			if (tm) {
				xOriginOld = tm.xOrigin; //record the original values before we alter them.
				yOriginOld = tm.yOrigin;
			}
			if (!absolute || (v = absolute.split(" ")).length < 2) {
				b = e.getBBox();
				local = _parsePosition(local).split(" ");
				v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x, (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
			}
			decoratee.xOrigin = xOrigin = parseFloat(v[0]);
			decoratee.yOrigin = yOrigin = parseFloat(v[1]);
			if (absolute && m !== _identity2DMatrix) {
				//if svgOrigin is being set, we must invert the matrix and determine where the absolute point is, factoring in the current transforms. Otherwise, the svgOrigin would be based on the element's non-transformed position on the canvas.
				a = m[0];
				b = m[1];
				c = m[2];
				d = m[3];
				tx = m[4];
				ty = m[5];
				determinant = a * d - b * c;
				x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
				y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
				xOrigin = decoratee.xOrigin = v[0] = x;
				yOrigin = decoratee.yOrigin = v[1] = y;
			}
			if (tm) {
				//avoid jump when transformOrigin is changed - adjust the x/y values accordingly
				if (skipRecord) {
					decoratee.xOffset = tm.xOffset;
					decoratee.yOffset = tm.yOffset;
					tm = decoratee;
				}
				if (smoothOrigin || smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false) {
					x = xOrigin - xOriginOld;
					y = yOrigin - yOriginOld;
					//originally, we simply adjusted the x and y values, but that would cause problems if, for example, you created a rotational tween part-way through an x/y tween. Managing the offset in a separate variable gives us ultimate flexibility.
					//tm.x -= x - (x * m[0] + y * m[2]);
					//tm.y -= y - (x * m[1] + y * m[3]);
					tm.xOffset += x * m[0] + y * m[2] - x;
					tm.yOffset += x * m[1] + y * m[3] - y;
				} else {
					tm.xOffset = tm.yOffset = 0;
				}
			}
			if (!skipRecord) {
				e.setAttribute("data-svg-origin", v.join(" "));
			}
		},
		    _canGetBBox = function (e) {
			try {
				return e.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
			} catch (e) {}
		},
		    _isSVG = function (e) {
			//reports if the element is an SVG on which getBBox() actually works
			return !!(_SVGElement && e.getBBox && e.getCTM && _canGetBBox(e) && (!e.parentNode || e.parentNode.getBBox && e.parentNode.getCTM));
		},
		    _identity2DMatrix = [1, 0, 0, 1, 0, 0],
		    _getMatrix = function (e, force2D) {
			var tm = e._gsTransform || new Transform(),
			    rnd = 100000,
			    isDefault,
			    s,
			    m,
			    n,
			    dec;
			if (_transformProp) {
				s = _getStyle(e, _transformPropCSS, null, true);
			} else if (e.currentStyle) {
				//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
				s = e.currentStyle.filter.match(_ieGetMatrixExp);
				s = s && s.length === 4 ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0].join(",") : "";
			}
			isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)";
			if (tm.svg || e.getBBox && _isSVG(e)) {
				if (isDefault && (e.style[_transformProp] + "").indexOf("matrix") !== -1) {
					//some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
					s = e.style[_transformProp];
					isDefault = 0;
				}
				m = e.getAttribute("transform");
				if (isDefault && m) {
					if (m.indexOf("matrix") !== -1) {
						//just in case there's a "transform" value specified as an attribute instead of CSS style. Accept either a matrix() or simple translate() value though.
						s = m;
						isDefault = 0;
					} else if (m.indexOf("translate") !== -1) {
						s = "matrix(1,0,0,1," + m.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")";
						isDefault = 0;
					}
				}
			}
			if (isDefault) {
				return _identity2DMatrix;
			}
			//split the matrix values out into an array (m for matrix)
			m = (s || "").match(_numExp) || [];
			i = m.length;
			while (--i > -1) {
				n = Number(m[i]);
				m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (dec < 0 ? -0.5 : 0.5) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
			}
			return force2D && m.length > 6 ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
		},


		/**
   * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
   * @param {!Object} t target element
   * @param {Object=} cs computed style object (optional)
   * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
   * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
   * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
   */
		_getTransform = _internals.getTransform = function (t, cs, rec, parse) {
			if (t._gsTransform && rec && !parse) {
				return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
			}
			var tm = rec ? t._gsTransform || new Transform() : new Transform(),
			    invX = tm.scaleX < 0,
			    //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
			min = 0.00002,
			    rnd = 100000,
			    zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
			    defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
			    m,
			    i,
			    scaleX,
			    scaleY,
			    rotation,
			    skewX;

			tm.svg = !!(t.getBBox && _isSVG(t));
			if (tm.svg) {
				_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, _cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
				_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
			}
			m = _getMatrix(t);
			if (m !== _identity2DMatrix) {

				if (m.length === 16) {
					//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
					var a11 = m[0],
					    a21 = m[1],
					    a31 = m[2],
					    a41 = m[3],
					    a12 = m[4],
					    a22 = m[5],
					    a32 = m[6],
					    a42 = m[7],
					    a13 = m[8],
					    a23 = m[9],
					    a33 = m[10],
					    a14 = m[12],
					    a24 = m[13],
					    a34 = m[14],
					    a43 = m[11],
					    angle = Math.atan2(a32, a33),
					    t1,
					    t2,
					    t3,
					    t4,
					    cos,
					    sin;

					//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
					if (tm.zOrigin) {
						a34 = -tm.zOrigin;
						a14 = a13 * a34 - m[12];
						a24 = a23 * a34 - m[13];
						a34 = a33 * a34 + tm.zOrigin - m[14];
					}
					tm.rotationX = angle * _RAD2DEG;
					//rotationX
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						t1 = a12 * cos + a13 * sin;
						t2 = a22 * cos + a23 * sin;
						t3 = a32 * cos + a33 * sin;
						a13 = a12 * -sin + a13 * cos;
						a23 = a22 * -sin + a23 * cos;
						a33 = a32 * -sin + a33 * cos;
						a43 = a42 * -sin + a43 * cos;
						a12 = t1;
						a22 = t2;
						a32 = t3;
					}
					//rotationY
					angle = Math.atan2(-a31, a33);
					tm.rotationY = angle * _RAD2DEG;
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						t1 = a11 * cos - a13 * sin;
						t2 = a21 * cos - a23 * sin;
						t3 = a31 * cos - a33 * sin;
						a23 = a21 * sin + a23 * cos;
						a33 = a31 * sin + a33 * cos;
						a43 = a41 * sin + a43 * cos;
						a11 = t1;
						a21 = t2;
						a31 = t3;
					}
					//rotationZ
					angle = Math.atan2(a21, a11);
					tm.rotation = angle * _RAD2DEG;
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						a11 = a11 * cos + a12 * sin;
						t2 = a21 * cos + a22 * sin;
						a22 = a21 * -sin + a22 * cos;
						a32 = a31 * -sin + a32 * cos;
						a21 = t2;
					}

					if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) {
						//when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
						tm.rotationX = tm.rotation = 0;
						tm.rotationY = 180 - tm.rotationY;
					}

					tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5 | 0) / rnd;
					tm.scaleY = (Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5 | 0) / rnd;
					tm.scaleZ = (Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5 | 0) / rnd;
					tm.skewX = a12 || a22 ? Math.atan2(a12, a22) * _RAD2DEG + tm.rotation : tm.skewX || 0;
					if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
						if (invX) {
							tm.scaleX *= -1;
							tm.skewX += tm.rotation <= 0 ? 180 : -180;
							tm.rotation += tm.rotation <= 0 ? 180 : -180;
						} else {
							tm.scaleY *= -1;
							tm.skewX += tm.skewX <= 0 ? 180 : -180;
						}
					}
					tm.perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
					tm.x = a14;
					tm.y = a24;
					tm.z = a34;
					if (tm.svg) {
						tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
						tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
					}
				} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || !tm.rotationX && !tm.rotationY) && !(tm.x !== undefined && _getStyle(t, "display", cs) === "none")) {
					//sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
					var k = m.length >= 6,
					    a = k ? m[0] : 1,
					    b = m[1] || 0,
					    c = m[2] || 0,
					    d = k ? m[3] : 1;
					tm.x = m[4] || 0;
					tm.y = m[5] || 0;
					scaleX = Math.sqrt(a * a + b * b);
					scaleY = Math.sqrt(d * d + c * c);
					rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
					skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
					if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
						if (invX) {
							scaleX *= -1;
							skewX += rotation <= 0 ? 180 : -180;
							rotation += rotation <= 0 ? 180 : -180;
						} else {
							scaleY *= -1;
							skewX += skewX <= 0 ? 180 : -180;
						}
					}
					tm.scaleX = scaleX;
					tm.scaleY = scaleY;
					tm.rotation = rotation;
					tm.skewX = skewX;
					if (_supports3D) {
						tm.rotationX = tm.rotationY = tm.z = 0;
						tm.perspective = defaultTransformPerspective;
						tm.scaleZ = 1;
					}
					if (tm.svg) {
						tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
						tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
					}
				}
				tm.zOrigin = zOrigin;
				//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
				for (i in tm) {
					if (tm[i] < min) if (tm[i] > -min) {
						tm[i] = 0;
					}
				}
			}
			//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);
			if (rec) {
				t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
				if (tm.svg) {
					//if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
					if (_useSVGTransformAttr && t.style[_transformProp]) {
						TweenLite.delayedCall(0.001, function () {
							//if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
							_removeProp(t.style, _transformProp);
						});
					} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
						TweenLite.delayedCall(0.001, function () {
							t.removeAttribute("transform");
						});
					}
				}
			}
			return tm;
		},


		//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
		_setIETransformRatio = function (v) {
			var t = this.data,
			    //refers to the element's _gsTransform object
			ang = -t.rotation * _DEG2RAD,
			    skew = ang + t.skewX * _DEG2RAD,
			    rnd = 100000,
			    a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd,
			    b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd,
			    c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd,
			    d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd,
			    style = this.t.style,
			    cs = this.t.currentStyle,
			    filters,
			    val;
			if (!cs) {
				return;
			}
			val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
			b = -c;
			c = -val;
			filters = cs.filter;
			style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
			var w = this.t.offsetWidth,
			    h = this.t.offsetHeight,
			    clip = cs.position !== "absolute",
			    m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
			    ox = t.x + w * t.xPercent / 100,
			    oy = t.y + h * t.yPercent / 100,
			    dx,
			    dy;

			//if transformOrigin is being used, adjust the offset x and y
			if (t.ox != null) {
				dx = (t.oxp ? w * t.ox * 0.01 : t.ox) - w / 2;
				dy = (t.oyp ? h * t.oy * 0.01 : t.oy) - h / 2;
				ox += dx - (dx * a + dy * b);
				oy += dy - (dx * c + dy * d);
			}

			if (!clip) {
				m += ", sizingMethod='auto expand')";
			} else {
				dx = w / 2;
				dy = h / 2;
				//translate to ensure that transformations occur around the correct origin (default is center).
				m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
			}
			if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
				style.filter = filters.replace(_ieSetMatrixExp, m);
			} else {
				style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
			}

			//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
			if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
				style.removeAttribute("filter");
			}

			//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
			if (!clip) {
				var mult = _ieVers < 8 ? 1 : -1,
				    //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
				marg,
				    prop,
				    dif;
				dx = t.ieOffsetX || 0;
				dy = t.ieOffsetY || 0;
				t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
				t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
				for (i = 0; i < 4; i++) {
					prop = _margins[i];
					marg = cs[prop];
					//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
					val = marg.indexOf("px") !== -1 ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
					if (val !== t[prop]) {
						dif = i < 2 ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
					} else {
							dif = i < 2 ? dx - t.ieOffsetX : dy - t.ieOffsetY;
						}
					style[prop] = (t[prop] = Math.round(val - dif * (i === 0 || i === 2 ? 1 : mult))) + "px";
				}
			}
		},


		/* translates a super small decimal to a string WITHOUT scientific notation
  _safeDecimal = function(n) {
  	var s = (n < 0 ? -n : n) + "",
  		a = s.split("e-");
  	return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
  },
  */

		_setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function (v) {
			var t = this.data,
			    //refers to the element's _gsTransform object
			style = this.t.style,
			    angle = t.rotation,
			    rotationX = t.rotationX,
			    rotationY = t.rotationY,
			    sx = t.scaleX,
			    sy = t.scaleY,
			    sz = t.scaleZ,
			    x = t.x,
			    y = t.y,
			    z = t.z,
			    isSVG = t.svg,
			    perspective = t.perspective,
			    force3D = t.force3D,
			    a11,
			    a12,
			    a13,
			    a21,
			    a22,
			    a23,
			    a31,
			    a32,
			    a33,
			    a41,
			    a42,
			    a43,
			    zOrigin,
			    min,
			    cos,
			    sin,
			    t1,
			    t2,
			    transform,
			    comma,
			    zero,
			    skew,
			    rnd;
			//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
			if (((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1 || _useSVGTransformAttr && isSVG || !_supports3D) {
				//on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.

				//2D
				if (angle || t.skewX || isSVG) {
					angle *= _DEG2RAD;
					skew = t.skewX * _DEG2RAD;
					rnd = 100000;
					a11 = Math.cos(angle) * sx;
					a21 = Math.sin(angle) * sx;
					a12 = Math.sin(angle - skew) * -sy;
					a22 = Math.cos(angle - skew) * sy;
					if (skew && t.skewType === "simple") {
						//by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
						t1 = Math.tan(skew);
						t1 = Math.sqrt(1 + t1 * t1);
						a12 *= t1;
						a22 *= t1;
						if (t.skewY) {
							a11 *= t1;
							a21 *= t1;
						}
					}
					if (isSVG) {
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
						if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) {
							//The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
							min = this.t.getBBox();
							x += t.xPercent * 0.01 * min.width;
							y += t.yPercent * 0.01 * min.height;
						}
						min = 0.000001;
						if (x < min) if (x > -min) {
							x = 0;
						}
						if (y < min) if (y > -min) {
							y = 0;
						}
					}
					transform = (a11 * rnd | 0) / rnd + "," + (a21 * rnd | 0) / rnd + "," + (a12 * rnd | 0) / rnd + "," + (a22 * rnd | 0) / rnd + "," + x + "," + y + ")";
					if (isSVG && _useSVGTransformAttr) {
						this.t.setAttribute("transform", "matrix(" + transform);
					} else {
						//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
						style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
					}
				} else {
					style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
				}
				return;
			}
			if (_isFirefox) {
				//Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
				min = 0.0001;
				if (sx < min && sx > -min) {
					sx = sz = 0.00002;
				}
				if (sy < min && sy > -min) {
					sy = sz = 0.00002;
				}
				if (perspective && !t.z && !t.rotationX && !t.rotationY) {
					//Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
					perspective = 0;
				}
			}
			if (angle || t.skewX) {
				angle *= _DEG2RAD;
				cos = a11 = Math.cos(angle);
				sin = a21 = Math.sin(angle);
				if (t.skewX) {
					angle -= t.skewX * _DEG2RAD;
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					if (t.skewType === "simple") {
						//by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
						t1 = Math.tan(t.skewX * _DEG2RAD);
						t1 = Math.sqrt(1 + t1 * t1);
						cos *= t1;
						sin *= t1;
						if (t.skewY) {
							a11 *= t1;
							a21 *= t1;
						}
					}
				}
				a12 = -sin;
				a22 = cos;
			} else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) {
				//if we're only translating and/or 2D scaling, this is faster...
				style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + (sx !== 1 || sy !== 1 ? " scale(" + sx + "," + sy + ")" : "");
				return;
			} else {
				a11 = a22 = 1;
				a12 = a21 = 0;
			}
			// KEY  INDEX   AFFECTS
			// a11  0       rotation, rotationY, scaleX
			// a21  1       rotation, rotationY, scaleX
			// a31  2       rotationY, scaleX
			// a41  3       rotationY, scaleX
			// a12  4       rotation, skewX, rotationX, scaleY
			// a22  5       rotation, skewX, rotationX, scaleY
			// a32  6       rotationX, scaleY
			// a42  7       rotationX, scaleY
			// a13  8       rotationY, rotationX, scaleZ
			// a23  9       rotationY, rotationX, scaleZ
			// a33  10      rotationY, rotationX, scaleZ
			// a43  11      rotationY, rotationX, perspective, scaleZ
			// a14  12      x, zOrigin, svgOrigin
			// a24  13      y, zOrigin, svgOrigin
			// a34  14      z, zOrigin
			// a44  15
			// rotation: Math.atan2(a21, a11)
			// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
			// rotationX: Math.atan2(a32, a33)
			a33 = 1;
			a13 = a23 = a31 = a32 = a41 = a42 = 0;
			a43 = perspective ? -1 / perspective : 0;
			zOrigin = t.zOrigin;
			min = 0.000001; //threshold below which browsers use scientific notation which won't work.
			comma = ",";
			zero = "0";
			angle = rotationY * _DEG2RAD;
			if (angle) {
				cos = Math.cos(angle);
				sin = Math.sin(angle);
				a31 = -sin;
				a41 = a43 * -sin;
				a13 = a11 * sin;
				a23 = a21 * sin;
				a33 = cos;
				a43 *= cos;
				a11 *= cos;
				a21 *= cos;
			}
			angle = rotationX * _DEG2RAD;
			if (angle) {
				cos = Math.cos(angle);
				sin = Math.sin(angle);
				t1 = a12 * cos + a13 * sin;
				t2 = a22 * cos + a23 * sin;
				a32 = a33 * sin;
				a42 = a43 * sin;
				a13 = a12 * -sin + a13 * cos;
				a23 = a22 * -sin + a23 * cos;
				a33 = a33 * cos;
				a43 = a43 * cos;
				a12 = t1;
				a22 = t2;
			}
			if (sz !== 1) {
				a13 *= sz;
				a23 *= sz;
				a33 *= sz;
				a43 *= sz;
			}
			if (sy !== 1) {
				a12 *= sy;
				a22 *= sy;
				a32 *= sy;
				a42 *= sy;
			}
			if (sx !== 1) {
				a11 *= sx;
				a21 *= sx;
				a31 *= sx;
				a41 *= sx;
			}

			if (zOrigin || isSVG) {
				if (zOrigin) {
					x += a13 * -zOrigin;
					y += a23 * -zOrigin;
					z += a33 * -zOrigin + zOrigin;
				}
				if (isSVG) {
					//due to bugs in some browsers, we need to manage the transform-origin of SVG manually
					x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
					y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
				}
				if (x < min && x > -min) {
					x = zero;
				}
				if (y < min && y > -min) {
					y = zero;
				}
				if (z < min && z > -min) {
					z = 0; //don't use string because we calculate perspective later and need the number.
				}
			}

			//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
			transform = t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(";
			transform += (a11 < min && a11 > -min ? zero : a11) + comma + (a21 < min && a21 > -min ? zero : a21) + comma + (a31 < min && a31 > -min ? zero : a31);
			transform += comma + (a41 < min && a41 > -min ? zero : a41) + comma + (a12 < min && a12 > -min ? zero : a12) + comma + (a22 < min && a22 > -min ? zero : a22);
			if (rotationX || rotationY || sz !== 1) {
				//performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
				transform += comma + (a32 < min && a32 > -min ? zero : a32) + comma + (a42 < min && a42 > -min ? zero : a42) + comma + (a13 < min && a13 > -min ? zero : a13);
				transform += comma + (a23 < min && a23 > -min ? zero : a23) + comma + (a33 < min && a33 > -min ? zero : a33) + comma + (a43 < min && a43 > -min ? zero : a43) + comma;
			} else {
				transform += ",0,0,0,0,1,0,";
			}
			transform += x + comma + y + comma + z + comma + (perspective ? 1 + -z / perspective : 1) + ")";

			style[_transformProp] = transform;
		};

		p = Transform.prototype;
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;

		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", { parser: function (t, e, p, cssp, pt, plugin, vars) {
				if (cssp._lastParsedTransform === vars) {
					return pt;
				} //only need to parse the transform once, and only if the browser supports it.
				cssp._lastParsedTransform = vars;
				var originalGSTransform = t._gsTransform,
				    style = t.style,
				    min = 0.000001,
				    i = _transformProps.length,
				    v = vars,
				    endRotations = {},
				    transformOriginString = "transformOrigin",
				    m1,
				    m2,
				    copy,
				    orig,
				    has3D,
				    hasChange,
				    dr,
				    x,
				    y,
				    matrix;
				if (vars.display) {
					//if the user is setting display during this tween, it may not be instantiated yet but we must force it here in order to get accurate readings. If display is "none", some browsers refuse to report the transform properties correctly.
					copy = _getStyle(t, "display");
					style.display = "block";
					m1 = _getTransform(t, _cs, true, vars.parseTransform);
					style.display = copy;
				} else {
					m1 = _getTransform(t, _cs, true, vars.parseTransform);
				}
				cssp._transform = m1;
				if (typeof v.transform === "string" && _transformProp) {
					//for values like transform:"rotate(60deg) scale(0.5, 0.8)"
					copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
					copy[_transformProp] = v.transform;
					copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
					copy.position = "absolute";
					_doc.body.appendChild(_tempDiv);
					m2 = _getTransform(_tempDiv, null, false);
					if (m1.svg) {
						//if it's an SVG element, x/y part of the matrix will be affected by whatever we use as the origin and the offsets, so compensate here...
						x = m1.xOrigin;
						y = m1.yOrigin;
						m2.x -= m1.xOffset;
						m2.y -= m1.yOffset;
						if (v.transformOrigin || v.svgOrigin) {
							//if this tween is altering the origin, we must factor that in here. The actual work of recording the transformOrigin values and setting up the PropTween is done later (still inside this function) so we cannot leave the changes intact here - we only want to update the x/y accordingly.
							orig = {};
							_parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
							x = orig.xOrigin;
							y = orig.yOrigin;
							m2.x -= orig.xOffset - m1.xOffset;
							m2.y -= orig.yOffset - m1.yOffset;
						}
						if (x || y) {
							matrix = _getMatrix(_tempDiv);
							m2.x -= x - (x * matrix[0] + y * matrix[2]);
							m2.y -= y - (x * matrix[1] + y * matrix[3]);
						}
					}
					_doc.body.removeChild(_tempDiv);
					if (!m2.perspective) {
						m2.perspective = m1.perspective; //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
					}
					if (v.xPercent != null) {
						m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
					}
					if (v.yPercent != null) {
						m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
					}
				} else if (typeof v === "object") {
					//for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
					m2 = { scaleX: _parseVal(v.scaleX != null ? v.scaleX : v.scale, m1.scaleX),
						scaleY: _parseVal(v.scaleY != null ? v.scaleY : v.scale, m1.scaleY),
						scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
						x: _parseVal(v.x, m1.x),
						y: _parseVal(v.y, m1.y),
						z: _parseVal(v.z, m1.z),
						xPercent: _parseVal(v.xPercent, m1.xPercent),
						yPercent: _parseVal(v.yPercent, m1.yPercent),
						perspective: _parseVal(v.transformPerspective, m1.perspective) };
					dr = v.directionalRotation;
					if (dr != null) {
						if (typeof dr === "object") {
							for (copy in dr) {
								v[copy] = dr[copy];
							}
						} else {
							v.rotation = dr;
						}
					}
					if (typeof v.x === "string" && v.x.indexOf("%") !== -1) {
						m2.x = 0;
						m2.xPercent = _parseVal(v.x, m1.xPercent);
					}
					if (typeof v.y === "string" && v.y.indexOf("%") !== -1) {
						m2.y = 0;
						m2.yPercent = _parseVal(v.y, m1.yPercent);
					}

					m2.rotation = _parseAngle("rotation" in v ? v.rotation : "shortRotation" in v ? v.shortRotation + "_short" : "rotationZ" in v ? v.rotationZ : m1.rotation - m1.skewY, m1.rotation - m1.skewY, "rotation", endRotations); //see notes below about skewY for why we subtract it from rotation here
					if (_supports3D) {
						m2.rotationX = _parseAngle("rotationX" in v ? v.rotationX : "shortRotationX" in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
						m2.rotationY = _parseAngle("rotationY" in v ? v.rotationY : "shortRotationY" in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
					}
					m2.skewX = _parseAngle(v.skewX, m1.skewX - m1.skewY); //see notes below about skewY and why we subtract it from skewX here

					//note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
					if (m2.skewY = _parseAngle(v.skewY, m1.skewY)) {
						m2.skewX += m2.skewY;
						m2.rotation += m2.skewY;
					}
				}
				if (_supports3D && v.force3D != null) {
					m1.force3D = v.force3D;
					hasChange = true;
				}

				m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;

				has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective;
				if (!has3D && v.scale != null) {
					m2.scaleZ = 1; //no need to tween scaleZ.
				}

				while (--i > -1) {
					p = _transformProps[i];
					orig = m2[p] - m1[p];
					if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
						hasChange = true;
						pt = new CSSPropTween(m1, p, m1[p], orig, pt);
						if (p in endRotations) {
							pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
						}
						pt.xs0 = 0; //ensures the value stays numeric in setRatio()
						pt.plugin = plugin;
						cssp._overwriteProps.push(pt.n);
					}
				}

				orig = v.transformOrigin;
				if (m1.svg && (orig || v.svgOrigin)) {
					x = m1.xOffset; //when we change the origin, in order to prevent things from jumping we adjust the x/y so we must record those here so that we can create PropTweens for them and flip them at the same time as the origin
					y = m1.yOffset;
					_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
					pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString); //note: if there wasn't a transformOrigin defined yet, just start with the destination one; it's wasteful otherwise, and it causes problems with fromTo() tweens. For example, TweenLite.to("#wheel", 3, {rotation:180, transformOrigin:"50% 50%", delay:1}); TweenLite.fromTo("#wheel", 3, {scale:0.5, transformOrigin:"50% 50%"}, {scale:1, delay:2}); would cause a jump when the from values revert at the beginning of the 2nd tween.
					pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
					if (x !== m1.xOffset || y !== m1.yOffset) {
						pt = _addNonTweeningNumericPT(m1, "xOffset", originalGSTransform ? x : m1.xOffset, m1.xOffset, pt, transformOriginString);
						pt = _addNonTweeningNumericPT(m1, "yOffset", originalGSTransform ? y : m1.yOffset, m1.yOffset, pt, transformOriginString);
					}
					orig = _useSVGTransformAttr ? null : "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
				}
				if (orig || _supports3D && has3D && m1.zOrigin) {
					//if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
					if (_transformProp) {
						hasChange = true;
						p = _transformOriginProp;
						orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
						pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
						pt.b = style[p];
						pt.plugin = plugin;
						if (_supports3D) {
							copy = m1.zOrigin;
							orig = orig.split(" ");
							m1.zOrigin = (orig.length > 2 && !(copy !== 0 && orig[2] === "0px") ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
							pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
							pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
							pt.b = copy;
							pt.xs0 = pt.e = m1.zOrigin;
						} else {
							pt.xs0 = pt.e = orig;
						}

						//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
					} else {
							_parsePosition(orig + "", m1);
						}
				}
				if (hasChange) {
					cssp._transformType = !(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3) ? 3 : 2; //quicker than calling cssp._enableTransforms();
				}
				return pt;
			}, prefix: true });

		_registerComplexSpecialProp("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: true, color: true, multi: true, keyword: "inset" });

		_registerComplexSpecialProp("borderRadius", { defaultValue: "0px", parser: function (t, e, p, cssp, pt, plugin) {
				e = this.format(e);
				var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
				    style = t.style,
				    ea1,
				    i,
				    es2,
				    bs2,
				    bs,
				    es,
				    bn,
				    en,
				    w,
				    h,
				    esfx,
				    bsfx,
				    rel,
				    hn,
				    vn,
				    em;
				w = parseFloat(t.offsetWidth);
				h = parseFloat(t.offsetHeight);
				ea1 = e.split(" ");
				for (i = 0; i < props.length; i++) {
					//if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
					if (this.p.indexOf("border")) {
						//older browsers used a prefix
						props[i] = _checkPropPrefix(props[i]);
					}
					bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
					if (bs.indexOf(" ") !== -1) {
						bs2 = bs.split(" ");
						bs = bs2[0];
						bs2 = bs2[1];
					}
					es = es2 = ea1[i];
					bn = parseFloat(bs);
					bsfx = bs.substr((bn + "").length);
					rel = es.charAt(1) === "=";
					if (rel) {
						en = parseInt(es.charAt(0) + "1", 10);
						es = es.substr(2);
						en *= parseFloat(es);
						esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
					} else {
						en = parseFloat(es);
						esfx = es.substr((en + "").length);
					}
					if (esfx === "") {
						esfx = _suffixMap[p] || bsfx;
					}
					if (esfx !== bsfx) {
						hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
						vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
						if (esfx === "%") {
							bs = hn / w * 100 + "%";
							bs2 = vn / h * 100 + "%";
						} else if (esfx === "em") {
							em = _convertToPixels(t, "borderLeft", 1, "em");
							bs = hn / em + "em";
							bs2 = vn / em + "em";
						} else {
							bs = hn + "px";
							bs2 = vn + "px";
						}
						if (rel) {
							es = parseFloat(bs) + en + esfx;
							es2 = parseFloat(bs2) + en + esfx;
						}
					}
					pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
				}
				return pt;
			}, prefix: true, formatter: _getFormatter("0px 0px 0px 0px", false, true) });
		_registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", { defaultValue: "0px", parser: function (t, e, p, cssp, pt, plugin) {
				return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
			}, prefix: true, formatter: _getFormatter("0px 0px", false, true) });
		_registerComplexSpecialProp("backgroundPosition", { defaultValue: "0 0", parser: function (t, e, p, cssp, pt, plugin) {
				var bp = "background-position",
				    cs = _cs || _getComputedStyle(t, null),
				    bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
				    //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),
				    ba,
				    ea,
				    i,
				    pct,
				    overlap,
				    src;
				if (bs.indexOf("%") !== -1 !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
					src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
					if (src && src !== "none") {
						ba = bs.split(" ");
						ea = es.split(" ");
						_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
						i = 2;
						while (--i > -1) {
							bs = ba[i];
							pct = bs.indexOf("%") !== -1;
							if (pct !== (ea[i].indexOf("%") !== -1)) {
								overlap = i === 0 ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
								ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%";
							}
						}
						bs = ba.join(" ");
					}
				}
				return this.parseComplex(t.style, bs, es, pt, plugin);
			}, formatter: _parsePosition });
		_registerComplexSpecialProp("backgroundSize", { defaultValue: "0 0", formatter: _parsePosition });
		_registerComplexSpecialProp("perspective", { defaultValue: "0px", prefix: true });
		_registerComplexSpecialProp("perspectiveOrigin", { defaultValue: "50% 50%", prefix: true });
		_registerComplexSpecialProp("transformStyle", { prefix: true });
		_registerComplexSpecialProp("backfaceVisibility", { prefix: true });
		_registerComplexSpecialProp("userSelect", { prefix: true });
		_registerComplexSpecialProp("margin", { parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft") });
		_registerComplexSpecialProp("padding", { parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft") });
		_registerComplexSpecialProp("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function (t, e, p, cssp, pt, plugin) {
				var b, cs, delim;
				if (_ieVers < 9) {
					//IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
					cs = t.currentStyle;
					delim = _ieVers < 8 ? " " : ",";
					b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
					e = this.format(e).split(",").join(delim);
				} else {
					b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
					e = this.format(e);
				}
				return this.parseComplex(t.style, b, e, pt, plugin);
			} });
		_registerComplexSpecialProp("textShadow", { defaultValue: "0px 0px 0px #999", color: true, multi: true });
		_registerComplexSpecialProp("autoRound,strictUnits", { parser: function (t, e, p, cssp, pt) {
				return pt;
			} }); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", { defaultValue: "0px solid #000", parser: function (t, e, p, cssp, pt, plugin) {
				return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, false, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), this.format(e), pt, plugin);
			}, color: true, formatter: function (v) {
				var a = v.split(" ");
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
			} });
		_registerComplexSpecialProp("borderWidth", { parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", { parser: function (t, e, p, cssp, pt, plugin) {
				var s = t.style,
				    prop = "cssFloat" in s ? "cssFloat" : "styleFloat";
				return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
			} });

		//opacity-related
		var _setIEOpacityRatio = function (v) {
			var t = this.t,
			    //refers to the element's style property
			filters = t.filter || _getStyle(this.data, "filter") || "",
			    val = this.s + this.c * v | 0,
			    skip;
			if (val === 100) {
				//for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
				if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
					t.removeAttribute("filter");
					skip = !_getStyle(this.data, "filter"); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
				} else {
						t.filter = filters.replace(_alphaFilterExp, "");
						skip = true;
					}
			}
			if (!skip) {
				if (this.xn1) {
					t.filter = filters = filters || "alpha(opacity=" + val + ")"; //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
				}
				if (filters.indexOf("pacity") === -1) {
					//only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
					if (val !== 0 || !this.xn1) {
						//bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
						t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
					}
				} else {
						t.filter = filters.replace(_opacityExp, "opacity=" + val);
					}
			}
		};
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function (t, e, p, cssp, pt, plugin) {
				var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
				    style = t.style,
				    isAutoAlpha = p === "autoAlpha";
				if (typeof e === "string" && e.charAt(1) === "=") {
					e = (e.charAt(0) === "-" ? -1 : 1) * parseFloat(e.substr(2)) + b;
				}
				if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) {
					//if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
					b = 0;
				}
				if (_supportsOpacity) {
					pt = new CSSPropTween(style, "opacity", b, e - b, pt);
				} else {
					pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
					pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
					style.zoom = 1; //helps correct an IE issue.
					pt.type = 2;
					pt.b = "alpha(opacity=" + pt.s + ")";
					pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
					pt.data = t;
					pt.plugin = plugin;
					pt.setRatio = _setIEOpacityRatio;
				}
				if (isAutoAlpha) {
					//we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
					pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, b !== 0 ? "inherit" : "hidden", e === 0 ? "hidden" : "inherit");
					pt.xs0 = "inherit";
					cssp._overwriteProps.push(pt.n);
					cssp._overwriteProps.push(p);
				}
				return pt;
			} });

		var _removeProp = function (s, p) {
			if (p) {
				if (s.removeProperty) {
					if (p.substr(0, 2) === "ms" || p.substr(0, 6) === "webkit") {
						//Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
						p = "-" + p;
					}
					s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
				} else {
					//note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
					s.removeAttribute(p);
				}
			}
		},
		    _setClassNameRatio = function (v) {
			this.t._gsClassPT = this;
			if (v === 1 || v === 0) {
				this.t.setAttribute("class", v === 0 ? this.b : this.e);
				var mpt = this.data,
				    //first MiniPropTween
				s = this.t.style;
				while (mpt) {
					if (!mpt.v) {
						_removeProp(s, mpt.p);
					} else {
						s[mpt.p] = mpt.v;
					}
					mpt = mpt._next;
				}
				if (v === 1 && this.t._gsClassPT === this) {
					this.t._gsClassPT = null;
				}
			} else if (this.t.getAttribute("class") !== this.e) {
				this.t.setAttribute("class", this.e);
			}
		};
		_registerComplexSpecialProp("className", { parser: function (t, e, p, cssp, pt, plugin, vars) {
				var b = t.getAttribute("class") || "",
				    //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,
				    difData,
				    bs,
				    cnpt,
				    cnptLookup,
				    mpt;
				pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
				pt.setRatio = _setClassNameRatio;
				pt.pr = -11;
				_hasPriority = true;
				pt.b = b;
				bs = _getAllStyles(t, _cs);
				//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
				cnpt = t._gsClassPT;
				if (cnpt) {
					cnptLookup = {};
					mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
					while (mpt) {
						cnptLookup[mpt.p] = 1;
						mpt = mpt._next;
					}
					cnpt.setRatio(1);
				}
				t._gsClassPT = pt;
				pt.e = e.charAt(1) !== "=" ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + (e.charAt(0) === "+" ? " " + e.substr(2) : "");
				t.setAttribute("class", pt.e);
				difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
				t.setAttribute("class", b);
				pt.data = difData.firstMPT;
				t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
				pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
				return pt;
			} });

		var _setClearPropsRatio = function (v) {
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
				//this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,
				    transformParse = _specialProps.transform.parse,
				    a,
				    p,
				    i,
				    clearTransform,
				    transform;
				if (this.e === "all") {
					s.cssText = "";
					clearTransform = true;
				} else {
					a = this.e.split(" ").join("").split(",");
					i = a.length;
					while (--i > -1) {
						p = a[i];
						if (_specialProps[p]) {
							if (_specialProps[p].parse === transformParse) {
								clearTransform = true;
							} else {
								p = p === "transformOrigin" ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}
						}
						_removeProp(s, p);
					}
				}
				if (clearTransform) {
					_removeProp(s, _transformProp);
					transform = this.t._gsTransform;
					if (transform) {
						if (transform.svg) {
							this.t.removeAttribute("data-svg-origin");
							this.t.removeAttribute("transform");
						}
						delete this.t._gsTransform;
					}
				}
			}
		};
		_registerComplexSpecialProp("clearProps", { parser: function (t, e, p, cssp, pt) {
				pt = new CSSPropTween(t, p, 0, 0, pt, 2);
				pt.setRatio = _setClearPropsRatio;
				pt.e = e;
				pt.pr = -10;
				pt.data = cssp._tween;
				_hasPriority = true;
				return pt;
			} });

		p = "bezier,throwProps,physicsProps,physics2D".split(",");
		i = p.length;
		while (i--) {
			_registerPluginProp(p[i]);
		}

		p = CSSPlugin.prototype;
		p._firstPT = p._lastParsedTransform = p._transform = null;

		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
		p._onInitTween = function (target, vars, tween) {
			if (!target.nodeType) {
				//css is only for dom elements
				return false;
			}
			this._target = target;
			this._tween = tween;
			this._vars = vars;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, "");
			_overwriteProps = this._overwriteProps;
			var style = target.style,
			    v,
			    pt,
			    pt2,
			    first,
			    last,
			    next,
			    zIndex,
			    tpt,
			    threeD;
			if (_reqSafariFix) if (style.zIndex === "") {
				v = _getStyle(target, "zIndex", _cs);
				if (v === "auto" || v === "") {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);
				}
			}

			if (typeof vars === "string") {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + ";" + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity && _opacityValExp.test(vars)) {
					v.opacity = parseFloat(RegExp.$1);
				}
				vars = v;
				style.cssText = first;
			}

			if (vars.className) {
				//className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
				this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
			} else {
				this._firstPT = pt = this.parse(target, vars, null);
			}

			if (this._transformType) {
				threeD = this._transformType === 3;
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
						_reqSafariFix = true;
						//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
						if (style.zIndex === "") {
							zIndex = _getStyle(target, "zIndex", _cs);
							if (zIndex === "auto" || zIndex === "") {
								this._addLazySet(style, "zIndex", 0);
							}
						}
						//Setting WebkitBackfaceVisibility corrects 3 bugs:
						// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
						// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
						// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
						//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
						if (_isSafariLT6) {
							this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
						}
					}
				pt2 = pt;
				while (pt2 && pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}

			if (_hasPriority) {
				//reorders the linked list in order of pr (priority)
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if (pt._prev = pt2 ? pt2._prev : last) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if (pt._next = pt2) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				this._firstPT = first;
			}
			return true;
		};

		p.parse = function (target, vars, pt, plugin) {
			var style = target.style,
			    p,
			    sp,
			    bn,
			    en,
			    bs,
			    es,
			    bsfx,
			    esfx,
			    isStr,
			    rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);
				} else {
					bs = _getStyle(target, p, _cs) + "";
					isStr = typeof es === "string";
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || isStr && _rgbhslExp.test(es)) {
						//Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")";
						}
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);
					} else if (isStr && _complexExp.test(es)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);
					} else {
						bn = parseFloat(bs);
						bsfx = bn || bn === 0 ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

						if (bs === "" || bs === "auto") {
							if (p === "width" || p === "height") {
								bn = _getDimension(target, p, _cs);
								bsfx = "px";
							} else if (p === "left" || p === "top") {
								bn = _calculateOffset(target, p, _cs);
								bsfx = "px";
							} else {
								bn = p !== "opacity" ? 0 : 1;
								bsfx = "";
							}
						}

						rel = isStr && es.charAt(1) === "=";
						if (rel) {
							en = parseInt(es.charAt(0) + "1", 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, "");
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, "") : "";
						}

						if (esfx === "") {
							esfx = p in _suffixMap ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}

						es = en || en === 0 ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.

						//if the beginning/ending suffixes don't match, normalize them...
						if (bsfx !== esfx) if (esfx !== "") if (en || en === 0) if (bn) {
							//note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === "%") {
								bn /= _convertToPixels(target, p, 100, "%") / 100;
								if (vars.strictUnits !== true) {
									//some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";
								}
							} else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
								bn /= _convertToPixels(target, p, 1, esfx);

								//otherwise convert to pixels.
							} else if (esfx !== "px") {
									en = _convertToPixels(target, p, en, esfx);
									esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
								}
							if (rel) if (en || en === 0) {
								es = en + bn + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) && (en || en === 0)) {
							//faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, _autoRound !== false && (esfx === "px" || p === "zIndex"), 0, bs, es);
							pt.xs0 = esfx;
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
								_log("invalid " + p + " tween value: " + vars[p]);
							} else {
								pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
								pt.xs0 = es === "none" && (p === "display" || p.indexOf("Style") !== -1) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
								//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
							}
					}
				}
				if (plugin) if (pt && !pt.plugin) {
					pt.plugin = plugin;
				}
			}
			return pt;
		};

		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function (v) {
			var pt = this._firstPT,
			    min = 0.000001,
			    val,
			    str,
			    i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						if (pt.r && pt.type !== -1) {
							val = Math.round(pt.s + pt.c);
							if (!pt.type) {
								pt.t[pt.p] = val + pt.xs0;
							} else if (pt.type === 1) {
								//complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
								i = pt.l;
								str = pt.xs0 + val + pt.xs1;
								for (i = 1; i < pt.l; i++) {
									str += pt["xn" + i] + pt["xs" + (i + 1)];
								}
								pt.t[pt.p] = str;
							}
						} else {
							pt.t[pt.p] = pt.e;
						}
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					} else if (val < min) if (val > -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) {
						//complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn" + i] + pt["xs" + (i + 1)];
							}
							pt.t[pt.p] = str;
						}
					} else if (pt.type === -1) {
						//non-tweening value
						pt.t[pt.p] = pt.xs0;
					} else if (pt.setRatio) {
						//custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

				//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {
					while (pt) {
						if (pt.type !== 2) {
							pt.t[pt.p] = pt.b;
						} else {
							pt.setRatio(v);
						}
						pt = pt._next;
					}
				}
		};

		/**
   * @private
   * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
   * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
   * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
   * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
   * doesn't have any transform-related properties of its own. You can call this method as many times as you
   * want and it won't create duplicate CSSPropTweens.
   *
   * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
   */
		p._enableTransforms = function (threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = !(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3) ? 3 : 2;
		};

		var lazySet = function (v) {
			this.t[this.p] = this.e;
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};
		/** @private Gives us a way to set a value on the first render (and only the first render). **/
		p._addLazySet = function (t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		};

		/** @private **/
		p._linkCSSP = function (pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove && this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		};

		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function (lookup) {
			var copy = lookup,
			    pt,
			    p,
			    xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) {
					//copy the lookup so that we're not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className && (pt = this._classNamePT)) {
				//for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;
				if (xfirst && xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
						this._firstPT = pt._next;
					}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			return TweenPlugin.prototype._kill.call(this, copy);
		};

		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
		var _getChildStyles = function (e, props, targets) {
			var children, i, child, type;
			if (e.slice) {
				i = e.length;
				while (--i > -1) {
					_getChildStyles(e[i], props, targets);
				}
				return;
			}
			children = e.childNodes;
			i = children.length;
			while (--i > -1) {
				child = children[i];
				type = child.type;
				if (child.style) {
					props.push(_getAllStyles(child));
					if (targets) {
						targets.push(child);
					}
				}
				if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
					_getChildStyles(child, props, targets);
				}
			}
		};

		/**
   * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
   * and then compares the style properties of all the target's child elements at the tween's start and end, and
   * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
   * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
   * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
   * is because it creates entirely new tweens that may have completely different targets than the original tween,
   * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
   * and it would create other problems. For example:
   *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
   *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
   *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
   *
   * @param {Object} target object to be tweened
   * @param {number} Duration in seconds (or frames for frames-based tweens)
   * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
   * @return {Array} An array of TweenLite instances
   */
		CSSPlugin.cascadeTo = function (target, duration, vars) {
			var tween = TweenLite.to(target, duration, vars),
			    results = [tween],
			    b = [],
			    e = [],
			    targets = [],
			    _reservedProps = TweenLite._internals.reservedProps,
			    i,
			    difs,
			    p,
			    from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i > -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		};

		TweenPlugin.activate([CSSPlugin]);
		return CSSPlugin;
	}, true);

	/*
  * ----------------------------------------------------------------
  * RoundPropsPlugin
  * ----------------------------------------------------------------
  */
	(function () {

		var RoundPropsPlugin = _gsScope._gsDefine.plugin({
			propName: "roundProps",
			version: "1.5",
			priority: -1,
			API: 2,

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function (target, value, tween) {
				this._tween = tween;
				return true;
			}

		}),
		    _roundLinkedList = function (node) {
			while (node) {
				if (!node.f && !node.blob) {
					node.r = 1;
				}
				node = node._next;
			}
		},
		    p = RoundPropsPlugin.prototype;

		p._onInitAllProps = function () {
			var tween = this._tween,
			    rp = tween.vars.roundProps.join ? tween.vars.roundProps : tween.vars.roundProps.split(","),
			    i = rp.length,
			    lookup = {},
			    rpt = tween._propLookup.roundProps,
			    prop,
			    pt,
			    next;
			while (--i > -1) {
				lookup[rp[i]] = 1;
			}
			i = rp.length;
			while (--i > -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._roundProps(lookup, true);
					} else if (pt.n === prop) {
						if (pt.f === 2 && pt.t) {
							//a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
								next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = next;
							} else if (tween._firstPT === pt) {
								tween._firstPT = next;
							}
							pt._next = pt._prev = null;
							tween._propLookup[prop] = rpt;
						}
					}
					pt = next;
				}
			}
			return false;
		};

		p._add = function (target, p, s, c) {
			this._addTween(target, p, s, s + c, p, true);
			this._overwriteProps.push(p);
		};
	})();

	/*
  * ----------------------------------------------------------------
  * AttrPlugin
  * ----------------------------------------------------------------
  */

	(function () {

		_gsScope._gsDefine.plugin({
			propName: "attr",
			API: 2,
			version: "0.5.0",

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function (target, value, tween) {
				var p;
				if (typeof target.setAttribute !== "function") {
					return false;
				}
				for (p in value) {
					this._addTween(target, "setAttribute", target.getAttribute(p) + "", value[p] + "", p, false, p);
					this._overwriteProps.push(p);
				}
				return true;
			}

		});
	})();

	/*
  * ----------------------------------------------------------------
  * DirectionalRotationPlugin
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.2.1",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function (target, value, tween) {
			if (typeof value !== "object") {
				value = { rotation: value };
			}
			this.finals = {};
			var cap = value.useRadians === true ? Math.PI * 2 : 360,
			    min = 0.000001,
			    p,
			    v,
			    start,
			    end,
			    dif,
			    split;
			for (p in value) {
				if (p !== "useRadians") {
					split = (value[p] + "").split("_");
					v = split[0];
					start = parseFloat(typeof target[p] !== "function" ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]());
					end = this.finals[p] = typeof v === "string" && v.charAt(1) === "=" ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = dif < 0 ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function (ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;

	/*
  * ----------------------------------------------------------------
  * EasePack
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function (Ease) {

		var w = _gsScope.GreenSockGlobals || _gsScope,
		    gs = w.com.greensock,
		    _2PI = Math.PI * 2,
		    _HALF_PI = Math.PI / 2,
		    _class = gs._class,
		    _create = function (n, f) {
			var C = _class("easing." + n, function () {}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			return C;
		},
		    _easeReg = Ease.register || function () {},
		    //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
		_wrap = function (name, EaseOut, EaseIn, EaseInOut, aliases) {
			var C = _class("easing." + name, {
				easeOut: new EaseOut(),
				easeIn: new EaseIn(),
				easeInOut: new EaseInOut()
			}, true);
			_easeReg(C, name);
			return C;
		},
		    EasePoint = function (time, value, next) {
			this.t = time;
			this.v = value;
			if (next) {
				this.next = next;
				next.prev = this;
				this.c = next.v - value;
				this.gap = next.t - time;
			}
		},


		//Back
		_createBack = function (n, f) {
			var C = _class("easing." + n, function (overshoot) {
				this._p1 = overshoot || overshoot === 0 ? overshoot : 1.70158;
				this._p2 = this._p1 * 1.525;
			}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function (overshoot) {
				return new C(overshoot);
			};
			return C;
		},
		    Back = _wrap("Back", _createBack("BackOut", function (p) {
			return (p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1;
		}), _createBack("BackIn", function (p) {
			return p * p * ((this._p1 + 1) * p - this._p1);
		}), _createBack("BackInOut", function (p) {
			return (p *= 2) < 1 ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
		})),


		//SlowMo
		SlowMo = _class("easing.SlowMo", function (linearRatio, power, yoyoMode) {
			power = power || power === 0 ? power : 0.7;
			if (linearRatio == null) {
				linearRatio = 0.7;
			} else if (linearRatio > 1) {
				linearRatio = 1;
			}
			this._p = linearRatio !== 1 ? power : 0;
			this._p1 = (1 - linearRatio) / 2;
			this._p2 = linearRatio;
			this._p3 = this._p1 + this._p2;
			this._calcEnd = yoyoMode === true;
		}, true),
		    p = SlowMo.prototype = new Ease(),
		    SteppedEase,
		    RoughEase,
		    _createElastic;

		p.constructor = SlowMo;
		p.getRatio = function (p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - (p = 1 - p / this._p1) * p : r - (p = 1 - p / this._p1) * p * p * p * r;
			} else if (p > this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + (p - r) * (p = (p - this._p3) / this._p1) * p * p * p;
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);

		p.config = SlowMo.config = function (linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};

		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function (steps) {
			steps = steps || 1;
			this._p1 = 1 / steps;
			this._p2 = steps + 1;
		}, true);
		p = SteppedEase.prototype = new Ease();
		p.constructor = SteppedEase;
		p.getRatio = function (p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return (this._p2 * p >> 0) * this._p1;
		};
		p.config = SteppedEase.config = function (steps) {
			return new SteppedEase(steps);
		};

		//RoughEase
		RoughEase = _class("easing.RoughEase", function (vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
			    a = [],
			    cnt = 0,
			    points = (vars.points || 20) | 0,
			    i = points,
			    randomize = vars.randomize !== false,
			    clamp = vars.clamp === true,
			    template = vars.template instanceof Ease ? vars.template : null,
			    strength = typeof vars.strength === "number" ? vars.strength * 0.4 : 0.4,
			    x,
			    y,
			    bump,
			    invX,
			    obj,
			    pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : 1 / points * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {
					//"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {
					//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += Math.random() * bump - bump * 0.5;
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = { x: x, y: y };
			}
			a.sort(function (a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, pnt.t !== 0 ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function (p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;
		};
		p.config = function (vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();

		//Bounce
		_wrap("Bounce", _create("BounceOut", function (p) {
			if (p < 1 / 2.75) {
				return 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
			} else if (p < 2.5 / 2.75) {
				return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
			}
			return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
		}), _create("BounceIn", function (p) {
			if ((p = 1 - p) < 1 / 2.75) {
				return 1 - 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
			} else if (p < 2.5 / 2.75) {
				return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
			}
			return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
		}), _create("BounceInOut", function (p) {
			var invert = p < 0.5;
			if (invert) {
				p = 1 - p * 2;
			} else {
				p = p * 2 - 1;
			}
			if (p < 1 / 2.75) {
				p = 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
			} else if (p < 2.5 / 2.75) {
				p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
			} else {
				p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}
			return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
		}));

		//CIRC
		_wrap("Circ", _create("CircOut", function (p) {
			return Math.sqrt(1 - (p = p - 1) * p);
		}), _create("CircIn", function (p) {
			return -(Math.sqrt(1 - p * p) - 1);
		}), _create("CircInOut", function (p) {
			return (p *= 2) < 1 ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
		}));

		//Elastic
		_createElastic = function (n, f, def) {
			var C = _class("easing." + n, function (amplitude, period) {
				this._p1 = amplitude >= 1 ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
				this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
				this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
				this._p2 = _2PI / this._p2; //precalculate to optimize
			}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function (amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic", _createElastic("ElasticOut", function (p) {
			return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * this._p2) + 1;
		}, 0.3), _createElastic("ElasticIn", function (p) {
			return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2));
		}, 0.3), _createElastic("ElasticInOut", function (p) {
			return (p *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2) * 0.5 + 1;
		}, 0.45));

		//Expo
		_wrap("Expo", _create("ExpoOut", function (p) {
			return 1 - Math.pow(2, -10 * p);
		}), _create("ExpoIn", function (p) {
			return Math.pow(2, 10 * (p - 1)) - 0.001;
		}), _create("ExpoInOut", function (p) {
			return (p *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
		}));

		//Sine
		_wrap("Sine", _create("SineOut", function (p) {
			return Math.sin(p * _HALF_PI);
		}), _create("SineIn", function (p) {
			return -Math.cos(p * _HALF_PI) + 1;
		}), _create("SineInOut", function (p) {
			return -0.5 * (Math.cos(Math.PI * p) - 1);
		}));

		_class("easing.EaseLookup", {
			find: function (s) {
				return Ease.map[s];
			}
		}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");

		return Back;
	}, true);
});

if (_gsScope._gsDefine) {
	_gsScope._gsQueue.pop()();
} //necessary in case TweenLite was already loaded separately.

/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function (window, moduleName) {

	"use strict";

	var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
	if (_globals.TweenLite) {
		return; //in case the core set of classes is already loaded, don't instantiate twice.
	}
	var _namespace = function (ns) {
		var a = ns.split("."),
		    p = _globals,
		    i;
		for (i = 0; i < a.length; i++) {
			p[a[i]] = p = p[a[i]] || {};
		}
		return p;
	},
	    gs = _namespace("com.greensock"),
	    _tinyNum = 0.0000000001,
	    _slice = function (a) {
		//don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
		var b = [],
		    l = a.length,
		    i;
		for (i = 0; i !== l; b.push(a[i++])) {}
		return b;
	},
	    _emptyFunc = function () {},
	    _isArray = function () {
		//works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
		var toString = Object.prototype.toString,
		    array = toString.call([]);
		return function (obj) {
			return obj != null && (obj instanceof Array || typeof obj === "object" && !!obj.push && toString.call(obj) === array);
		};
	}(),
	    a,
	    i,
	    p,
	    _ticker,
	    _tickerActive,
	    _defLookup = {},


	/**
  * @constructor
  * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
  * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
  * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
  * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
  *
  * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
  * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
  * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
  * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
  * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
  * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
  * sandbox the banner one like:
  *
  * <script>
  *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
  * </script>
  * <script src="js/greensock/v1.7/TweenMax.js"></script>
  * <script>
  *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
  * </script>
  * <script src="js/greensock/v1.6/TweenMax.js"></script>
  * <script>
  *     gs.TweenLite.to(...); //would use v1.7
  *     TweenLite.to(...); //would use v1.6
  * </script>
  *
  * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
  * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
  * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
  * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
  */
	Definition = function (ns, dependencies, func, global) {
		this.sc = _defLookup[ns] ? _defLookup[ns].sc : []; //subclasses
		_defLookup[ns] = this;
		this.gsClass = null;
		this.func = func;
		var _classes = [];
		this.check = function (init) {
			var i = dependencies.length,
			    missing = i,
			    cur,
			    a,
			    n,
			    cl,
			    hasModule;
			while (--i > -1) {
				if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
					_classes[i] = cur.gsClass;
					missing--;
				} else if (init) {
					cur.sc.push(this);
				}
			}
			if (missing === 0 && func) {
				a = ("com.greensock." + ns).split(".");
				n = a.pop();
				cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

				//exports to multiple environments
				if (global) {
					_globals[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
					hasModule = typeof module !== "undefined" && module.exports;
					if (!hasModule && typeof define === "function" && define.amd) {
						//AMD
						define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function () {
							return cl;
						});
					} else if (ns === moduleName && hasModule) {
						//node
						module.exports = cl;
					}
				}
				for (i = 0; i < this.sc.length; i++) {
					this.sc[i].check();
				}
			}
		};
		this.check(true);
	},


	//used to create Definition instances (which basically registers a class that has dependencies).
	_gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
		return new Definition(ns, dependencies, func, global);
	},


	//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
	_class = gs._class = function (ns, func, global) {
		func = func || function () {};
		_gsDefine(ns, [], function () {
			return func;
		}, global);
		return func;
	};

	_gsDefine.globals = _globals;

	/*
  * ----------------------------------------------------------------
  * Ease
  * ----------------------------------------------------------------
  */
	var _baseParams = [0, 0, 1, 1],
	    _blankArray = [],
	    Ease = _class("easing.Ease", function (func, extraParams, type, power) {
		this._func = func;
		this._type = type || 0;
		this._power = power || 0;
		this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
	}, true),
	    _easeMap = Ease.map = {},
	    _easeReg = Ease.register = function (ease, names, types, create) {
		var na = names.split(","),
		    i = na.length,
		    ta = (types || "easeIn,easeOut,easeInOut").split(","),
		    e,
		    name,
		    j,
		    type;
		while (--i > -1) {
			name = na[i];
			e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
			j = ta.length;
			while (--j > -1) {
				type = ta[j];
				_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
			}
		}
	};

	p = Ease.prototype;
	p._calcEnd = false;
	p.getRatio = function (p) {
		if (this._func) {
			this._params[0] = p;
			return this._func.apply(null, this._params);
		}
		var t = this._type,
		    pw = this._power,
		    r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;
		if (pw === 1) {
			r *= r;
		} else if (pw === 2) {
			r *= r * r;
		} else if (pw === 3) {
			r *= r * r * r;
		} else if (pw === 4) {
			r *= r * r * r * r;
		}
		return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;
	};

	//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
	a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
	i = a.length;
	while (--i > -1) {
		p = a[i] + ",Power" + i;
		_easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
		_easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));
		_easeReg(new Ease(null, null, 3, i), p, "easeInOut");
	}
	_easeMap.linear = gs.easing.Linear.easeIn;
	_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks

	/*
  * ----------------------------------------------------------------
  * EventDispatcher
  * ----------------------------------------------------------------
  */
	var EventDispatcher = _class("events.EventDispatcher", function (target) {
		this._listeners = {};
		this._eventTarget = target || this;
	});
	p = EventDispatcher.prototype;

	p.addEventListener = function (type, callback, scope, useParam, priority) {
		priority = priority || 0;
		var list = this._listeners[type],
		    index = 0,
		    listener,
		    i;
		if (list == null) {
			this._listeners[type] = list = [];
		}
		i = list.length;
		while (--i > -1) {
			listener = list[i];
			if (listener.c === callback && listener.s === scope) {
				list.splice(i, 1);
			} else if (index === 0 && listener.pr < priority) {
				index = i + 1;
			}
		}
		list.splice(index, 0, { c: callback, s: scope, up: useParam, pr: priority });
		if (this === _ticker && !_tickerActive) {
			_ticker.wake();
		}
	};

	p.removeEventListener = function (type, callback) {
		var list = this._listeners[type],
		    i;
		if (list) {
			i = list.length;
			while (--i > -1) {
				if (list[i].c === callback) {
					list.splice(i, 1);
					return;
				}
			}
		}
	};

	p.dispatchEvent = function (type) {
		var list = this._listeners[type],
		    i,
		    t,
		    listener;
		if (list) {
			i = list.length;
			t = this._eventTarget;
			while (--i > -1) {
				listener = list[i];
				if (listener) {
					if (listener.up) {
						listener.c.call(listener.s || t, { type: type, target: t });
					} else {
						listener.c.call(listener.s || t);
					}
				}
			}
		}
	};

	/*
  * ----------------------------------------------------------------
  * Ticker
  * ----------------------------------------------------------------
  */
	var _reqAnimFrame = window.requestAnimationFrame,
	    _cancelAnimFrame = window.cancelAnimationFrame,
	    _getTime = Date.now || function () {
		return new Date().getTime();
	},
	    _lastUpdate = _getTime();

	//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
	a = ["ms", "moz", "webkit", "o"];
	i = a.length;
	while (--i > -1 && !_reqAnimFrame) {
		_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
		_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
	}

	_class("Ticker", function (fps, useRAF) {
		var _self = this,
		    _startTime = _getTime(),
		    _useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
		    _lagThreshold = 500,
		    _adjustedLag = 33,
		    _tickWord = "tick",
		    //helps reduce gc burden
		_fps,
		    _req,
		    _id,
		    _gap,
		    _nextTime,
		    _tick = function (manual) {
			var elapsed = _getTime() - _lastUpdate,
			    overlap,
			    dispatch;
			if (elapsed > _lagThreshold) {
				_startTime += elapsed - _adjustedLag;
			}
			_lastUpdate += elapsed;
			_self.time = (_lastUpdate - _startTime) / 1000;
			overlap = _self.time - _nextTime;
			if (!_fps || overlap > 0 || manual === true) {
				_self.frame++;
				_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
				dispatch = true;
			}
			if (manual !== true) {
				//make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
				_id = _req(_tick);
			}
			if (dispatch) {
				_self.dispatchEvent(_tickWord);
			}
		};

		EventDispatcher.call(_self);
		_self.time = _self.frame = 0;
		_self.tick = function () {
			_tick(true);
		};

		_self.lagSmoothing = function (threshold, adjustedLag) {
			_lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited
			_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
		};

		_self.sleep = function () {
			if (_id == null) {
				return;
			}
			if (!_useRAF || !_cancelAnimFrame) {
				clearTimeout(_id);
			} else {
				_cancelAnimFrame(_id);
			}
			_req = _emptyFunc;
			_id = null;
			if (_self === _ticker) {
				_tickerActive = false;
			}
		};

		_self.wake = function (seamless) {
			if (_id !== null) {
				_self.sleep();
			} else if (seamless) {
				_startTime += -_lastUpdate + (_lastUpdate = _getTime());
			} else if (_self.frame > 10) {
				//don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
				_lastUpdate = _getTime() - _lagThreshold + 5;
			}
			_req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
				return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
			} : _reqAnimFrame;
			if (_self === _ticker) {
				_tickerActive = true;
			}
			_tick(2);
		};

		_self.fps = function (value) {
			if (!arguments.length) {
				return _fps;
			}
			_fps = value;
			_gap = 1 / (_fps || 60);
			_nextTime = this.time + _gap;
			_self.wake();
		};

		_self.useRAF = function (value) {
			if (!arguments.length) {
				return _useRAF;
			}
			_self.sleep();
			_useRAF = value;
			_self.fps(_fps);
		};
		_self.fps(fps);

		//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
		setTimeout(function () {
			if (_useRAF === "auto" && _self.frame < 5 && document.visibilityState !== "hidden") {
				_self.useRAF(false);
			}
		}, 1500);
	});

	p = gs.Ticker.prototype = new gs.events.EventDispatcher();
	p.constructor = gs.Ticker;

	/*
  * ----------------------------------------------------------------
  * Animation
  * ----------------------------------------------------------------
  */
	var Animation = _class("core.Animation", function (duration, vars) {
		this.vars = vars = vars || {};
		this._duration = this._totalDuration = duration || 0;
		this._delay = Number(vars.delay) || 0;
		this._timeScale = 1;
		this._active = vars.immediateRender === true;
		this.data = vars.data;
		this._reversed = vars.reversed === true;

		if (!_rootTimeline) {
			return;
		}
		if (!_tickerActive) {
			//some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
			_ticker.wake();
		}

		var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
		tl.add(this, tl._time);

		if (this.vars.paused) {
			this.paused(true);
		}
	});

	_ticker = Animation.ticker = new gs.Ticker();
	p = Animation.prototype;
	p._dirty = p._gc = p._initted = p._paused = false;
	p._totalTime = p._time = 0;
	p._rawPrevTime = -1;
	p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
	p._paused = false;

	//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
	var _checkTimeout = function () {
		if (_tickerActive && _getTime() - _lastUpdate > 2000) {
			_ticker.wake();
		}
		setTimeout(_checkTimeout, 2000);
	};
	_checkTimeout();

	p.play = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from, suppressEvents);
		}
		return this.reversed(false).paused(false);
	};

	p.pause = function (atTime, suppressEvents) {
		if (atTime != null) {
			this.seek(atTime, suppressEvents);
		}
		return this.paused(true);
	};

	p.resume = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from, suppressEvents);
		}
		return this.paused(false);
	};

	p.seek = function (time, suppressEvents) {
		return this.totalTime(Number(time), suppressEvents !== false);
	};

	p.restart = function (includeDelay, suppressEvents) {
		return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);
	};

	p.reverse = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from || this.totalDuration(), suppressEvents);
		}
		return this.reversed(true).paused(false);
	};

	p.render = function (time, suppressEvents, force) {
		//stub - we override this method in subclasses.
	};

	p.invalidate = function () {
		this._time = this._totalTime = 0;
		this._initted = this._gc = false;
		this._rawPrevTime = -1;
		if (this._gc || !this.timeline) {
			this._enabled(true);
		}
		return this;
	};

	p.isActive = function () {
		var tl = this._timeline,
		    //the 2 root timelines won't have a _timeline; they're always active.
		startTime = this._startTime,
		    rawTime;
		return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale;
	};

	p._enabled = function (enabled, ignoreTimeline) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		this._gc = !enabled;
		this._active = this.isActive();
		if (ignoreTimeline !== true) {
			if (enabled && !this.timeline) {
				this._timeline.add(this, this._startTime - this._delay);
			} else if (!enabled && this.timeline) {
				this._timeline._remove(this, true);
			}
		}
		return false;
	};

	p._kill = function (vars, target) {
		return this._enabled(false, false);
	};

	p.kill = function (vars, target) {
		this._kill(vars, target);
		return this;
	};

	p._uncache = function (includeSelf) {
		var tween = includeSelf ? this : this.timeline;
		while (tween) {
			tween._dirty = true;
			tween = tween.timeline;
		}
		return this;
	};

	p._swapSelfInParams = function (params) {
		var i = params.length,
		    copy = params.concat();
		while (--i > -1) {
			if (params[i] === "{self}") {
				copy[i] = this;
			}
		}
		return copy;
	};

	p._callback = function (type) {
		var v = this.vars;
		v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
	};

	//----Animation getters/setters --------------------------------------------------------

	p.eventCallback = function (type, callback, params, scope) {
		if ((type || "").substr(0, 2) === "on") {
			var v = this.vars;
			if (arguments.length === 1) {
				return v[type];
			}
			if (callback == null) {
				delete v[type];
			} else {
				v[type] = callback;
				v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
				v[type + "Scope"] = scope;
			}
			if (type === "onUpdate") {
				this._onUpdate = callback;
			}
		}
		return this;
	};

	p.delay = function (value) {
		if (!arguments.length) {
			return this._delay;
		}
		if (this._timeline.smoothChildTiming) {
			this.startTime(this._startTime + value - this._delay);
		}
		this._delay = value;
		return this;
	};

	p.duration = function (value) {
		if (!arguments.length) {
			this._dirty = false;
			return this._duration;
		}
		this._duration = this._totalDuration = value;
		this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
		if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
			this.totalTime(this._totalTime * (value / this._duration), true);
		}
		return this;
	};

	p.totalDuration = function (value) {
		this._dirty = false;
		return !arguments.length ? this._totalDuration : this.duration(value);
	};

	p.time = function (value, suppressEvents) {
		if (!arguments.length) {
			return this._time;
		}
		if (this._dirty) {
			this.totalDuration();
		}
		return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);
	};

	p.totalTime = function (time, suppressEvents, uncapped) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		if (!arguments.length) {
			return this._totalTime;
		}
		if (this._timeline) {
			if (time < 0 && !uncapped) {
				time += this.totalDuration();
			}
			if (this._timeline.smoothChildTiming) {
				if (this._dirty) {
					this.totalDuration();
				}
				var totalDuration = this._totalDuration,
				    tl = this._timeline;
				if (time > totalDuration && !uncapped) {
					time = totalDuration;
				}
				this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;
				if (!tl._dirty) {
					//for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
					this._uncache(false);
				}
				//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
				if (tl._timeline) {
					while (tl._timeline) {
						if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
							tl.totalTime(tl._totalTime, true);
						}
						tl = tl._timeline;
					}
				}
			}
			if (this._gc) {
				this._enabled(true, false);
			}
			if (this._totalTime !== time || this._duration === 0) {
				if (_lazyTweens.length) {
					_lazyRender();
				}
				this.render(time, suppressEvents, false);
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
					_lazyRender();
				}
			}
		}
		return this;
	};

	p.progress = p.totalProgress = function (value, suppressEvents) {
		var duration = this.duration();
		return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents);
	};

	p.startTime = function (value) {
		if (!arguments.length) {
			return this._startTime;
		}
		if (value !== this._startTime) {
			this._startTime = value;
			if (this.timeline) if (this.timeline._sortChildren) {
				this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
			}
		}
		return this;
	};

	p.endTime = function (includeRepeats) {
		return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale;
	};

	p.timeScale = function (value) {
		if (!arguments.length) {
			return this._timeScale;
		}
		value = value || _tinyNum; //can't allow zero because it'll throw the math off
		if (this._timeline && this._timeline.smoothChildTiming) {
			var pauseTime = this._pauseTime,
			    t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
			this._startTime = t - (t - this._startTime) * this._timeScale / value;
		}
		this._timeScale = value;
		return this._uncache(false);
	};

	p.reversed = function (value) {
		if (!arguments.length) {
			return this._reversed;
		}
		if (value != this._reversed) {
			this._reversed = value;
			this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true);
		}
		return this;
	};

	p.paused = function (value) {
		if (!arguments.length) {
			return this._paused;
		}
		var tl = this._timeline,
		    raw,
		    elapsed;
		if (value != this._paused) if (tl) {
			if (!_tickerActive && !value) {
				_ticker.wake();
			}
			raw = tl.rawTime();
			elapsed = raw - this._pauseTime;
			if (!value && tl.smoothChildTiming) {
				this._startTime += elapsed;
				this._uncache(false);
			}
			this._pauseTime = value ? raw : null;
			this._paused = value;
			this._active = this.isActive();
			if (!value && elapsed !== 0 && this._initted && this.duration()) {
				raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
				this.render(raw, raw === this._totalTime, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
			}
		}
		if (this._gc && !value) {
			this._enabled(true, false);
		}
		return this;
	};

	/*
  * ----------------------------------------------------------------
  * SimpleTimeline
  * ----------------------------------------------------------------
  */
	var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
		Animation.call(this, 0, vars);
		this.autoRemoveChildren = this.smoothChildTiming = true;
	});

	p = SimpleTimeline.prototype = new Animation();
	p.constructor = SimpleTimeline;
	p.kill()._gc = false;
	p._first = p._last = p._recent = null;
	p._sortChildren = false;

	p.add = p.insert = function (child, position, align, stagger) {
		var prevTween, st;
		child._startTime = Number(position || 0) + child._delay;
		if (child._paused) if (this !== child._timeline) {
			//we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
			child._pauseTime = child._startTime + (this.rawTime() - child._startTime) / child._timeScale;
		}
		if (child.timeline) {
			child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
		}
		child.timeline = child._timeline = this;
		if (child._gc) {
			child._enabled(true, true);
		}
		prevTween = this._last;
		if (this._sortChildren) {
			st = child._startTime;
			while (prevTween && prevTween._startTime > st) {
				prevTween = prevTween._prev;
			}
		}
		if (prevTween) {
			child._next = prevTween._next;
			prevTween._next = child;
		} else {
			child._next = this._first;
			this._first = child;
		}
		if (child._next) {
			child._next._prev = child;
		} else {
			this._last = child;
		}
		child._prev = prevTween;
		this._recent = child;
		if (this._timeline) {
			this._uncache(true);
		}
		return this;
	};

	p._remove = function (tween, skipDisable) {
		if (tween.timeline === this) {
			if (!skipDisable) {
				tween._enabled(false, true);
			}

			if (tween._prev) {
				tween._prev._next = tween._next;
			} else if (this._first === tween) {
				this._first = tween._next;
			}
			if (tween._next) {
				tween._next._prev = tween._prev;
			} else if (this._last === tween) {
				this._last = tween._prev;
			}
			tween._next = tween._prev = tween.timeline = null;
			if (tween === this._recent) {
				this._recent = this._last;
			}

			if (this._timeline) {
				this._uncache(true);
			}
		}
		return this;
	};

	p.render = function (time, suppressEvents, force) {
		var tween = this._first,
		    next;
		this._totalTime = this._time = this._rawPrevTime = time;
		while (tween) {
			next = tween._next; //record it here because the value could change after rendering...
			if (tween._active || time >= tween._startTime && !tween._paused) {
				if (!tween._reversed) {
					tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
				} else {
					tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
				}
			}
			tween = next;
		}
	};

	p.rawTime = function () {
		if (!_tickerActive) {
			_ticker.wake();
		}
		return this._totalTime;
	};

	/*
  * ----------------------------------------------------------------
  * TweenLite
  * ----------------------------------------------------------------
  */
	var TweenLite = _class("TweenLite", function (target, duration, vars) {
		Animation.call(this, duration, vars);
		this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

		if (target == null) {
			throw "Cannot tween a null target.";
		}

		this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;

		var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
		    overwrite = this.vars.overwrite,
		    i,
		    targ,
		    targets;

		this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];

		if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
			this._targets = targets = _slice(target); //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			this._propLookup = [];
			this._siblings = [];
			for (i = 0; i < targets.length; i++) {
				targ = targets[i];
				if (!targ) {
					targets.splice(i--, 1);
					continue;
				} else if (typeof targ === "string") {
					targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
					if (typeof targ === "string") {
						targets.splice(i + 1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
					}
					continue;
				} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
					//in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
					targets.splice(i--, 1);
					this._targets = targets = targets.concat(_slice(targ));
					continue;
				}
				this._siblings[i] = _register(targ, this, false);
				if (overwrite === 1) if (this._siblings[i].length > 1) {
					_applyOverwrite(targ, this, null, 1, this._siblings[i]);
				}
			}
		} else {
			this._propLookup = {};
			this._siblings = _register(target, this, false);
			if (overwrite === 1) if (this._siblings.length > 1) {
				_applyOverwrite(target, this, null, 1, this._siblings);
			}
		}
		if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
			this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
			this.render(Math.min(0, -this._delay)); //in case delay is negative
		}
	}, true),
	    _isSelector = function (v) {
		return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
	},
	    _autoCSS = function (vars, target) {
		var css = {},
		    p;
		for (p in vars) {
			if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
				//note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
				css[p] = vars[p];
				delete vars[p];
			}
		}
		vars.css = css;
	};

	p = TweenLite.prototype = new Animation();
	p.constructor = TweenLite;
	p.kill()._gc = false;

	//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

	p.ratio = 0;
	p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
	p._notifyPluginsOfEnabled = p._lazy = false;

	TweenLite.version = "1.18.4";
	TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
	TweenLite.defaultOverwrite = "auto";
	TweenLite.ticker = _ticker;
	TweenLite.autoSleep = 120;
	TweenLite.lagSmoothing = function (threshold, adjustedLag) {
		_ticker.lagSmoothing(threshold, adjustedLag);
	};

	TweenLite.selector = window.$ || window.jQuery || function (e) {
		var selector = window.$ || window.jQuery;
		if (selector) {
			TweenLite.selector = selector;
			return selector(e);
		}
		return typeof document === "undefined" ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById(e.charAt(0) === "#" ? e.substr(1) : e);
	};

	var _lazyTweens = [],
	    _lazyLookup = {},
	    _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,

	//_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
	_setRatio = function (v) {
		var pt = this._firstPT,
		    min = 0.000001,
		    val;
		while (pt) {
			val = !pt.blob ? pt.c * v + pt.s : v ? this.join("") : this.start;
			if (pt.r) {
				val = Math.round(val);
			} else if (val < min) if (val > -min) {
				//prevents issues with converting very small numbers to strings in the browser
				val = 0;
			}
			if (!pt.f) {
				pt.t[pt.p] = val;
			} else if (pt.fp) {
				pt.t[pt.p](pt.fp, val);
			} else {
				pt.t[pt.p](val);
			}
			pt = pt._next;
		}
	},

	//compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
	_blobDif = function (start, end, filter, pt) {
		var a = [start, end],
		    charIndex = 0,
		    s = "",
		    color = 0,
		    startNums,
		    endNums,
		    num,
		    i,
		    l,
		    nonNumbers,
		    currentNum;
		a.start = start;
		if (filter) {
			filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
			start = a[0];
			end = a[1];
		}
		a.length = 0;
		startNums = start.match(_numbersExp) || [];
		endNums = end.match(_numbersExp) || [];
		if (pt) {
			pt._next = null;
			pt.blob = 1;
			a._firstPT = pt; //apply last in the linked list (which means inserting it first)
		}
		l = endNums.length;
		for (i = 0; i < l; i++) {
			currentNum = endNums[i];
			nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
			s += nonNumbers || !i ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
			charIndex += nonNumbers.length;
			if (color) {
				//sense rgba() values and round them.
				color = (color + 1) % 5;
			} else if (nonNumbers.substr(-5) === "rgba(") {
				color = 1;
			}
			if (currentNum === startNums[i] || startNums.length <= i) {
				s += currentNum;
			} else {
				if (s) {
					a.push(s);
					s = "";
				}
				num = parseFloat(startNums[i]);
				a.push(num);
				a._firstPT = { _next: a._firstPT, t: a, p: a.length - 1, s: num, c: (currentNum.charAt(1) === "=" ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0, f: 0, r: color && color < 4 };
				//note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
			}
			charIndex += currentNum.length;
		}
		s += end.substr(charIndex);
		if (s) {
			a.push(s);
		}
		a.setRatio = _setRatio;
		return a;
	},

	//note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
	_addPropTween = function (target, prop, start, end, overwriteProp, round, funcParam, stringFilter) {
		var s = start === "get" ? target[prop] : start,
		    type = typeof target[prop],
		    isRelative = typeof end === "string" && end.charAt(1) === "=",
		    pt = { t: target, p: prop, s: s, f: type === "function", pg: 0, n: overwriteProp || prop, r: round, pr: 0, c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0 },
		    blob,
		    getterName;
		if (type !== "number") {
			if (type === "function" && start === "get") {
				getterName = prop.indexOf("set") || typeof target["get" + prop.substr(3)] !== "function" ? prop : "get" + prop.substr(3);
				pt.s = s = funcParam ? target[getterName](funcParam) : target[getterName]();
			}
			if (typeof s === "string" && (funcParam || isNaN(s))) {
				//a blob (string that has multiple numbers in it)
				pt.fp = funcParam;
				blob = _blobDif(s, end, stringFilter || TweenLite.defaultStringFilter, pt);
				pt = { t: blob, p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: overwriteProp || prop, pr: 0 }; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
			} else if (!isRelative) {
					pt.s = parseFloat(s);
					pt.c = parseFloat(end) - pt.s || 0;
				}
		}
		if (pt.c) {
			//only add it to the linked list if there's a change.
			if (pt._next = this._firstPT) {
				pt._next._prev = pt;
			}
			this._firstPT = pt;
			return pt;
		}
	},
	    _internals = TweenLite._internals = { isArray: _isArray, isSelector: _isSelector, lazyTweens: _lazyTweens, blobDif: _blobDif },
	    //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
	_plugins = TweenLite._plugins = {},
	    _tweenLookup = _internals.tweenLookup = {},
	    _tweenLookupNum = 0,
	    _reservedProps = _internals.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1, onOverwrite: 1, callbackScope: 1, stringFilter: 1 },
	    _overwriteLookup = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, "true": 1, "false": 0 },
	    _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
	    _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
	    _nextGCFrame = 30,
	    _lazyRender = _internals.lazyRender = function () {
		var i = _lazyTweens.length,
		    tween;
		_lazyLookup = {};
		while (--i > -1) {
			tween = _lazyTweens[i];
			if (tween && tween._lazy !== false) {
				tween.render(tween._lazy[0], tween._lazy[1], true);
				tween._lazy = false;
			}
		}
		_lazyTweens.length = 0;
	};

	_rootTimeline._startTime = _ticker.time;
	_rootFramesTimeline._startTime = _ticker.frame;
	_rootTimeline._active = _rootFramesTimeline._active = true;
	setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

	Animation._updateRoot = TweenLite.render = function () {
		var i, a, p;
		if (_lazyTweens.length) {
			//if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
			_lazyRender();
		}
		_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
		_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
		if (_lazyTweens.length) {
			_lazyRender();
		}
		if (_ticker.frame >= _nextGCFrame) {
			//dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
			_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
			for (p in _tweenLookup) {
				a = _tweenLookup[p].tweens;
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc) {
						a.splice(i, 1);
					}
				}
				if (a.length === 0) {
					delete _tweenLookup[p];
				}
			}
			//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
			p = _rootTimeline._first;
			if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
				while (p && p._paused) {
					p = p._next;
				}
				if (!p) {
					_ticker.sleep();
				}
			}
		}
	};

	_ticker.addEventListener("tick", Animation._updateRoot);

	var _register = function (target, tween, scrub) {
		var id = target._gsTweenID,
		    a,
		    i;
		if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
			_tweenLookup[id] = { target: target, tweens: [] };
		}
		if (tween) {
			a = _tweenLookup[id].tweens;
			a[i = a.length] = tween;
			if (scrub) {
				while (--i > -1) {
					if (a[i] === tween) {
						a.splice(i, 1);
					}
				}
			}
		}
		return _tweenLookup[id].tweens;
	},
	    _onOverwrite = function (overwrittenTween, overwritingTween, target, killedProps) {
		var func = overwrittenTween.vars.onOverwrite,
		    r1,
		    r2;
		if (func) {
			r1 = func(overwrittenTween, overwritingTween, target, killedProps);
		}
		func = TweenLite.onOverwrite;
		if (func) {
			r2 = func(overwrittenTween, overwritingTween, target, killedProps);
		}
		return r1 !== false && r2 !== false;
	},
	    _applyOverwrite = function (target, tween, props, mode, siblings) {
		var i, changed, curTween, l;
		if (mode === 1 || mode >= 4) {
			l = siblings.length;
			for (i = 0; i < l; i++) {
				if ((curTween = siblings[i]) !== tween) {
					if (!curTween._gc) {
						if (curTween._kill(null, target, tween)) {
							changed = true;
						}
					}
				} else if (mode === 5) {
					break;
				}
			}
			return changed;
		}
		//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
		var startTime = tween._startTime + _tinyNum,
		    overlaps = [],
		    oCount = 0,
		    zeroDur = tween._duration === 0,
		    globalStart;
		i = siblings.length;
		while (--i > -1) {
			if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
				//ignore
			} else if (curTween._timeline !== tween._timeline) {
					globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
					if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
						overlaps[oCount++] = curTween;
					}
				} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
					overlaps[oCount++] = curTween;
				}
		}

		i = oCount;
		while (--i > -1) {
			curTween = overlaps[i];
			if (mode === 2) if (curTween._kill(props, target, tween)) {
				changed = true;
			}
			if (mode !== 2 || !curTween._firstPT && curTween._initted) {
				if (mode !== 2 && !_onOverwrite(curTween, tween)) {
					continue;
				}
				if (curTween._enabled(false, false)) {
					//if all property tweens have been overwritten, kill the tween.
					changed = true;
				}
			}
		}
		return changed;
	},
	    _checkOverlap = function (tween, reference, zeroDur) {
		var tl = tween._timeline,
		    ts = tl._timeScale,
		    t = tween._startTime;
		while (tl._timeline) {
			t += tl._startTime;
			ts *= tl._timeScale;
			if (tl._paused) {
				return -100;
			}
			tl = tl._timeline;
		}
		t /= ts;
		return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
	};

	//---- TweenLite instance methods -----------------------------------------------------------------------------

	p._init = function () {
		var v = this.vars,
		    op = this._overwrittenProps,
		    dur = this._duration,
		    immediate = !!v.immediateRender,
		    ease = v.ease,
		    i,
		    initPlugins,
		    pt,
		    p,
		    startVars;
		if (v.startAt) {
			if (this._startAt) {
				this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
				this._startAt.kill();
			}
			startVars = {};
			for (p in v.startAt) {
				//copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
				startVars[p] = v.startAt[p];
			}
			startVars.overwrite = false;
			startVars.immediateRender = true;
			startVars.lazy = immediate && v.lazy !== false;
			startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
			this._startAt = TweenLite.to(this.target, 0, startVars);
			if (immediate) {
				if (this._time > 0) {
					this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
				} else if (dur !== 0) {
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}
			}
		} else if (v.runBackwards && dur !== 0) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {
					this._startAt.render(-1, true);
					this._startAt.kill();
					this._startAt = null;
				} else {
					if (this._time !== 0) {
						//in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
						immediate = false;
					}
					pt = {};
					for (p in v) {
						//copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === "autoCSS") {
							pt[p] = v[p];
						}
					}
					pt.overwrite = 0;
					pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
					pt.lazy = immediate && v.lazy !== false;
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);
					if (!immediate) {
						this._startAt._init(); //ensures that the initial values are recorded
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {
							this._startAt = null;
						}
					} else if (this._time === 0) {
						return;
					}
				}
			}
		this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
		if (v.easeParams instanceof Array && ease.config) {
			this._ease = ease.config.apply(ease, v.easeParams);
		}
		this._easeType = this._ease._type;
		this._easePower = this._ease._power;
		this._firstPT = null;

		if (this._targets) {
			i = this._targets.length;
			while (--i > -1) {
				if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null)) {
					initPlugins = true;
				}
			}
		} else {
			initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
		}

		if (initPlugins) {
			TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
		}
		if (op) if (!this._firstPT) if (typeof this.target !== "function") {
			//if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
			this._enabled(false, false);
		}
		if (v.runBackwards) {
			pt = this._firstPT;
			while (pt) {
				pt.s += pt.c;
				pt.c = -pt.c;
				pt = pt._next;
			}
		}
		this._onUpdate = v.onUpdate;
		this._initted = true;
	};

	p._initProps = function (target, propLookup, siblings, overwrittenProps) {
		var p, i, initPlugins, plugin, pt, v;
		if (target == null) {
			return false;
		}

		if (_lazyLookup[target._gsTweenID]) {
			_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
		}

		if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) {
			//it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
			_autoCSS(this.vars, target);
		}
		for (p in this.vars) {
			v = this.vars[p];
			if (_reservedProps[p]) {
				if (v) if (v instanceof Array || v.push && _isArray(v)) if (v.join("").indexOf("{self}") !== -1) {
					this.vars[p] = v = this._swapSelfInParams(v, this);
				}
			} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {

				//t - target 		[object]
				//p - property 		[string]
				//s - start			[number]
				//c - change		[number]
				//f - isFunction	[boolean]
				//n - name			[string]
				//pg - isPlugin 	[boolean]
				//pr - priority		[number]
				this._firstPT = pt = { _next: this._firstPT, t: plugin, p: "setRatio", s: 0, c: 1, f: 1, n: p, pg: 1, pr: plugin._priority };
				i = plugin._overwriteProps.length;
				while (--i > -1) {
					propLookup[plugin._overwriteProps[i]] = this._firstPT;
				}
				if (plugin._priority || plugin._onInitAllProps) {
					initPlugins = true;
				}
				if (plugin._onDisable || plugin._onEnable) {
					this._notifyPluginsOfEnabled = true;
				}
				if (pt._next) {
					pt._next._prev = pt;
				}
			} else {
				propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter);
			}
		}

		if (overwrittenProps) if (this._kill(overwrittenProps, target)) {
			//another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
			return this._initProps(target, propLookup, siblings, overwrittenProps);
		}
		if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
			this._kill(propLookup, target);
			return this._initProps(target, propLookup, siblings, overwrittenProps);
		}
		if (this._firstPT) if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
			//zero duration tweens don't lazy render by default; everything else does.
			_lazyLookup[target._gsTweenID] = true;
		}
		return initPlugins;
	};

	p.render = function (time, suppressEvents, force) {
		var prevTime = this._time,
		    duration = this._duration,
		    prevRawPrevTime = this._rawPrevTime,
		    isComplete,
		    callback,
		    pt,
		    rawPrevTime;
		if (time >= duration - 0.0000001) {
			//to work around occasional floating point math artifacts.
			this._totalTime = this._time = duration;
			this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
			if (!this._reversed) {
				isComplete = true;
				callback = "onComplete";
				force = force || this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
			}
			if (duration === 0) if (this._initted || !this.vars.lazy || force) {
				//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
				if (this._startTime === this._timeline._duration) {
					//if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
					time = 0;
				}
				if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause") if (prevRawPrevTime !== time) {
					//note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
					force = true;
					if (prevRawPrevTime > _tinyNum) {
						callback = "onReverseComplete";
					}
				}
				this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
			}
		} else if (time < 0.0000001) {
				//to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) {
						//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) {
					//if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;

				if (this._easeType) {
					var r = time / duration,
					    type = this._easeType,
					    pow = this._easePower;
					if (type === 1 || type === 3 && r >= 0.5) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - r / 2;
					}
				} else {
					this.ratio = this._ease.getRatio(time / duration);
				}
			}

		if (this._time === prevTime && !force) {
			return;
		} else if (!this._initted) {
			this._init();
			if (!this._initted || this._gc) {
				//immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
				return;
			} else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
				this._time = this._totalTime = prevTime;
				this._rawPrevTime = prevRawPrevTime;
				_lazyTweens.push(this);
				this._lazy = [time, suppressEvents];
				return;
			}
			//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
			if (this._time && !isComplete) {
				this.ratio = this._ease.getRatio(this._time / duration);
			} else if (isComplete && this._ease._calcEnd) {
				this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
			}
		}
		if (this._lazy !== false) {
			//in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
			this._lazy = false;
		}
		if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
			this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
		}
		if (prevTime === 0) {
			if (this._startAt) {
				if (time >= 0) {
					this._startAt.render(time, suppressEvents, force);
				} else if (!callback) {
					callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
				}
			}
			if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
				this._callback("onStart");
			}
		}
		pt = this._firstPT;
		while (pt) {
			if (pt.f) {
				pt.t[pt.p](pt.c * this.ratio + pt.s);
			} else {
				pt.t[pt.p] = pt.c * this.ratio + pt.s;
			}
			pt = pt._next;
		}

		if (this._onUpdate) {
			if (time < 0) if (this._startAt && time !== -0.0001) {
				//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
				this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
			}
			if (!suppressEvents) if (this._time !== prevTime || isComplete || force) {
				this._callback("onUpdate");
			}
		}
		if (callback) if (!this._gc || force) {
			//check _gc because there's a chance that kill() could be called in an onUpdate
			if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) {
				//-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
				this._startAt.render(time, suppressEvents, force);
			}
			if (isComplete) {
				if (this._timeline.autoRemoveChildren) {
					this._enabled(false, false);
				}
				this._active = false;
			}
			if (!suppressEvents && this.vars[callback]) {
				this._callback(callback);
			}
			if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
				//the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
				this._rawPrevTime = 0;
			}
		}
	};

	p._kill = function (vars, target, overwritingTween) {
		if (vars === "all") {
			vars = null;
		}
		if (vars == null) if (target == null || target === this.target) {
			this._lazy = false;
			return this._enabled(false, false);
		}
		target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
		var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,
		    i,
		    overwrittenProps,
		    p,
		    pt,
		    propLookup,
		    changed,
		    killProps,
		    record,
		    killed;
		if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
			i = target.length;
			while (--i > -1) {
				if (this._kill(vars, target[i], overwritingTween)) {
					changed = true;
				}
			}
		} else {
			if (this._targets) {
				i = this._targets.length;
				while (--i > -1) {
					if (target === this._targets[i]) {
						propLookup = this._propLookup[i] || {};
						this._overwrittenProps = this._overwrittenProps || [];
						overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
						break;
					}
				}
			} else if (target !== this.target) {
				return false;
			} else {
				propLookup = this._propLookup;
				overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
			}

			if (propLookup) {
				killProps = vars || propLookup;
				record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof vars !== "object" || !vars._tempKill); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
				if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
					for (p in killProps) {
						if (propLookup[p]) {
							if (!killed) {
								killed = [];
							}
							killed.push(p);
						}
					}
					if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
						//if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
						return false;
					}
				}

				for (p in killProps) {
					if (pt = propLookup[p]) {
						if (simultaneousOverwrite) {
							//if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
							if (pt.f) {
								pt.t[pt.p](pt.s);
							} else {
								pt.t[pt.p] = pt.s;
							}
							changed = true;
						}
						if (pt.pg && pt.t._kill(killProps)) {
							changed = true; //some plugins need to be notified so they can perform cleanup tasks first
						}
						if (!pt.pg || pt.t._overwriteProps.length === 0) {
							if (pt._prev) {
								pt._prev._next = pt._next;
							} else if (pt === this._firstPT) {
								this._firstPT = pt._next;
							}
							if (pt._next) {
								pt._next._prev = pt._prev;
							}
							pt._next = pt._prev = null;
						}
						delete propLookup[p];
					}
					if (record) {
						overwrittenProps[p] = 1;
					}
				}
				if (!this._firstPT && this._initted) {
					//if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
					this._enabled(false, false);
				}
			}
		}
		return changed;
	};

	p.invalidate = function () {
		if (this._notifyPluginsOfEnabled) {
			TweenLite._onPluginEvent("_onDisable", this);
		}
		this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
		this._notifyPluginsOfEnabled = this._active = this._lazy = false;
		this._propLookup = this._targets ? {} : [];
		Animation.prototype.invalidate.call(this);
		if (this.vars.immediateRender) {
			this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
			this.render(Math.min(0, -this._delay)); //in case delay is negative.
		}
		return this;
	};

	p._enabled = function (enabled, ignoreTimeline) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		if (enabled && this._gc) {
			var targets = this._targets,
			    i;
			if (targets) {
				i = targets.length;
				while (--i > -1) {
					this._siblings[i] = _register(targets[i], this, true);
				}
			} else {
				this._siblings = _register(this.target, this, true);
			}
		}
		Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
		if (this._notifyPluginsOfEnabled) if (this._firstPT) {
			return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this);
		}
		return false;
	};

	//----TweenLite static methods -----------------------------------------------------

	TweenLite.to = function (target, duration, vars) {
		return new TweenLite(target, duration, vars);
	};

	TweenLite.from = function (target, duration, vars) {
		vars.runBackwards = true;
		vars.immediateRender = vars.immediateRender != false;
		return new TweenLite(target, duration, vars);
	};

	TweenLite.fromTo = function (target, duration, fromVars, toVars) {
		toVars.startAt = fromVars;
		toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
		return new TweenLite(target, duration, toVars);
	};

	TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
		return new TweenLite(callback, 0, { delay: delay, onComplete: callback, onCompleteParams: params, callbackScope: scope, onReverseComplete: callback, onReverseCompleteParams: params, immediateRender: false, lazy: false, useFrames: useFrames, overwrite: 0 });
	};

	TweenLite.set = function (target, vars) {
		return new TweenLite(target, 0, vars);
	};

	TweenLite.getTweensOf = function (target, onlyActive) {
		if (target == null) {
			return [];
		}
		target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
		var i, a, j, t;
		if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
			i = target.length;
			a = [];
			while (--i > -1) {
				a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
			}
			i = a.length;
			//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
			while (--i > -1) {
				t = a[i];
				j = i;
				while (--j > -1) {
					if (t === a[j]) {
						a.splice(i, 1);
					}
				}
			}
		} else {
			a = _register(target).concat();
			i = a.length;
			while (--i > -1) {
				if (a[i]._gc || onlyActive && !a[i].isActive()) {
					a.splice(i, 1);
				}
			}
		}
		return a;
	};

	TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
		if (typeof onlyActive === "object") {
			vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
			onlyActive = false;
		}
		var a = TweenLite.getTweensOf(target, onlyActive),
		    i = a.length;
		while (--i > -1) {
			a[i]._kill(vars, target);
		}
	};

	/*
  * ----------------------------------------------------------------
  * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
  * ----------------------------------------------------------------
  */
	var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
		this._overwriteProps = (props || "").split(",");
		this._propName = this._overwriteProps[0];
		this._priority = priority || 0;
		this._super = TweenPlugin.prototype;
	}, true);

	p = TweenPlugin.prototype;
	TweenPlugin.version = "1.18.0";
	TweenPlugin.API = 2;
	p._firstPT = null;
	p._addTween = _addPropTween;
	p.setRatio = _setRatio;

	p._kill = function (lookup) {
		var a = this._overwriteProps,
		    pt = this._firstPT,
		    i;
		if (lookup[this._propName] != null) {
			this._overwriteProps = [];
		} else {
			i = a.length;
			while (--i > -1) {
				if (lookup[a[i]] != null) {
					a.splice(i, 1);
				}
			}
		}
		while (pt) {
			if (lookup[pt.n] != null) {
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
					pt._prev = null;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
				}
			}
			pt = pt._next;
		}
		return false;
	};

	p._roundProps = function (lookup, value) {
		var pt = this._firstPT;
		while (pt) {
			if (lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")]) {
				//some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
				pt.r = value;
			}
			pt = pt._next;
		}
	};

	TweenLite._onPluginEvent = function (type, tween) {
		var pt = tween._firstPT,
		    changed,
		    pt2,
		    first,
		    last,
		    next;
		if (type === "_onInitAllProps") {
			//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
			while (pt) {
				next = pt._next;
				pt2 = first;
				while (pt2 && pt2.pr > pt.pr) {
					pt2 = pt2._next;
				}
				if (pt._prev = pt2 ? pt2._prev : last) {
					pt._prev._next = pt;
				} else {
					first = pt;
				}
				if (pt._next = pt2) {
					pt2._prev = pt;
				} else {
					last = pt;
				}
				pt = next;
			}
			pt = tween._firstPT = first;
		}
		while (pt) {
			if (pt.pg) if (typeof pt.t[type] === "function") if (pt.t[type]()) {
				changed = true;
			}
			pt = pt._next;
		}
		return changed;
	};

	TweenPlugin.activate = function (plugins) {
		var i = plugins.length;
		while (--i > -1) {
			if (plugins[i].API === TweenPlugin.API) {
				_plugins[new plugins[i]()._propName] = plugins[i];
			}
		}
		return true;
	};

	//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
	_gsDefine.plugin = function (config) {
		if (!config || !config.propName || !config.init || !config.API) {
			throw "illegal plugin definition.";
		}
		var propName = config.propName,
		    priority = config.priority || 0,
		    overwriteProps = config.overwriteProps,
		    map = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_roundProps", initAll: "_onInitAllProps" },
		    Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
			TweenPlugin.call(this, propName, priority);
			this._overwriteProps = overwriteProps || [];
		}, config.global === true),
		    p = Plugin.prototype = new TweenPlugin(propName),
		    prop;
		p.constructor = Plugin;
		Plugin.API = config.API;
		for (prop in map) {
			if (typeof config[prop] === "function") {
				p[map[prop]] = config[prop];
			}
		}
		Plugin.version = config.version;
		TweenPlugin.activate([Plugin]);
		return Plugin;
	};

	//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
	a = window._gsQueue;
	if (a) {
		for (i = 0; i < a.length; i++) {
			a[i]();
		}
		for (p in _defLookup) {
			if (!_defLookup[p].func) {
				window.console.log("GSAP encountered missing dependency: com.greensock." + p);
			}
		}
	}

	_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated
})(typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window, "TweenMax");
'use strict';

/*!
 * ScrollMagic v2.0.5 (2015-04-29)
 * The javascript library for magical scroll interactions.
 * (c) 2015 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.5
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic main library.
 */
/**
 * @namespace ScrollMagic
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		module.exports = factory();
	} else {
		// Browser global
		root.ScrollMagic = factory();
	}
})(this, function () {
	"use strict";

	var ScrollMagic = function () {
		_util.log(2, '(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use \'new ScrollMagic.Controller()\' to create a new controller instance. Use \'new ScrollMagic.Scene()\' to instance a scene.');
	};

	ScrollMagic.version = "2.0.5";

	// TODO: temporary workaround for chrome's scroll jitter bug
	window.addEventListener("mousewheel", function () {});

	// global const
	var PIN_SPACER_ATTRIBUTE = "data-scrollmagic-pin-spacer";

	/**
  * The main class that is needed once per scroll container.
  *
  * @class
  *
  * @example
  * // basic initialization
  * var controller = new ScrollMagic.Controller();
  *
  * // passing options
  * var controller = new ScrollMagic.Controller({container: "#myContainer", loglevel: 3});
  *
  * @param {object} [options] - An object containing one or more options for the controller.
  * @param {(string|object)} [options.container=window] - A selector, DOM object that references the main container for scrolling.
  * @param {boolean} [options.vertical=true] - Sets the scroll mode to vertical (`true`) or horizontal (`false`) scrolling.
  * @param {object} [options.globalSceneOptions={}] - These options will be passed to every Scene that is added to the controller using the addScene method. For more information on Scene options see {@link ScrollMagic.Scene}.
  * @param {number} [options.loglevel=2] Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
  ** `0` => silent
  ** `1` => errors
  ** `2` => errors, warnings
  ** `3` => errors, warnings, debuginfo
  * @param {boolean} [options.refreshInterval=100] - Some changes don't call events by default, like changing the container size or moving a scene trigger element.  
  This interval polls these parameters to fire the necessary events.  
  If you don't use custom containers, trigger elements or have static layouts, where the positions of the trigger elements don't change, you can set this to 0 disable interval checking and improve performance.
  *
  */
	ScrollMagic.Controller = function (options) {
		/*
  	 * ----------------------------------------------------------------
  	 * settings
  	 * ----------------------------------------------------------------
  	 */
		var NAMESPACE = 'ScrollMagic.Controller',
		    SCROLL_DIRECTION_FORWARD = 'FORWARD',
		    SCROLL_DIRECTION_REVERSE = 'REVERSE',
		    SCROLL_DIRECTION_PAUSED = 'PAUSED',
		    DEFAULT_OPTIONS = CONTROLLER_OPTIONS.defaults;

		/*
  	 * ----------------------------------------------------------------
  	 * private vars
  	 * ----------------------------------------------------------------
  	 */
		var Controller = this,
		    _options = _util.extend({}, DEFAULT_OPTIONS, options),
		    _sceneObjects = [],
		    _updateScenesOnNextCycle = false,

		// can be boolean (true => all scenes) or an array of scenes to be updated
		_scrollPos = 0,
		    _scrollDirection = SCROLL_DIRECTION_PAUSED,
		    _isDocument = true,
		    _viewPortSize = 0,
		    _enabled = true,
		    _updateTimeout,
		    _refreshTimeout;

		/*
  	 * ----------------------------------------------------------------
  	 * private functions
  	 * ----------------------------------------------------------------
  	 */

		/**
   * Internal constructor function of the ScrollMagic Controller
   * @private
   */
		var construct = function () {
			for (var key in _options) {
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			_options.container = _util.get.elements(_options.container)[0];
			// check ScrollContainer
			if (!_options.container) {
				log(1, "ERROR creating object " + NAMESPACE + ": No valid scroll container supplied");
				throw NAMESPACE + " init failed."; // cancel
			}
			_isDocument = _options.container === window || _options.container === document.body || !document.body.contains(_options.container);
			// normalize to window
			if (_isDocument) {
				_options.container = window;
			}
			// update container size immediately
			_viewPortSize = getViewportSize();
			// set event handlers
			_options.container.addEventListener("resize", onChange);
			_options.container.addEventListener("scroll", onChange);

			_options.refreshInterval = parseInt(_options.refreshInterval) || DEFAULT_OPTIONS.refreshInterval;
			scheduleRefresh();

			log(3, "added new " + NAMESPACE + " controller (v" + ScrollMagic.version + ")");
		};

		/**
   * Schedule the next execution of the refresh function
   * @private
   */
		var scheduleRefresh = function () {
			if (_options.refreshInterval > 0) {
				_refreshTimeout = window.setTimeout(refresh, _options.refreshInterval);
			}
		};

		/**
   * Default function to get scroll pos - overwriteable using `Controller.scrollPos(newFunction)`
   * @private
   */
		var getScrollPos = function () {
			return _options.vertical ? _util.get.scrollTop(_options.container) : _util.get.scrollLeft(_options.container);
		};

		/**
   * Returns the current viewport Size (width vor horizontal, height for vertical)
   * @private
   */
		var getViewportSize = function () {
			return _options.vertical ? _util.get.height(_options.container) : _util.get.width(_options.container);
		};

		/**
   * Default function to set scroll pos - overwriteable using `Controller.scrollTo(newFunction)`
   * Make available publicly for pinned mousewheel workaround.
   * @private
   */
		var setScrollPos = this._setScrollPos = function (pos) {
			if (_options.vertical) {
				if (_isDocument) {
					window.scrollTo(_util.get.scrollLeft(), pos);
				} else {
					_options.container.scrollTop = pos;
				}
			} else {
				if (_isDocument) {
					window.scrollTo(pos, _util.get.scrollTop());
				} else {
					_options.container.scrollLeft = pos;
				}
			}
		};

		/**
   * Handle updates in cycles instead of on scroll (performance)
   * @private
   */
		var updateScenes = function () {
			if (_enabled && _updateScenesOnNextCycle) {
				// determine scenes to update
				var scenesToUpdate = _util.type.Array(_updateScenesOnNextCycle) ? _updateScenesOnNextCycle : _sceneObjects.slice(0);
				// reset scenes
				_updateScenesOnNextCycle = false;
				var oldScrollPos = _scrollPos;
				// update scroll pos now instead of onChange, as it might have changed since scheduling (i.e. in-browser smooth scroll)
				_scrollPos = Controller.scrollPos();
				var deltaScroll = _scrollPos - oldScrollPos;
				if (deltaScroll !== 0) {
					// scroll position changed?
					_scrollDirection = deltaScroll > 0 ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_REVERSE;
				}
				// reverse order of scenes if scrolling reverse
				if (_scrollDirection === SCROLL_DIRECTION_REVERSE) {
					scenesToUpdate.reverse();
				}
				// update scenes
				scenesToUpdate.forEach(function (scene, index) {
					log(3, "updating Scene " + (index + 1) + "/" + scenesToUpdate.length + " (" + _sceneObjects.length + " total)");
					scene.update(true);
				});
				if (scenesToUpdate.length === 0 && _options.loglevel >= 3) {
					log(3, "updating 0 Scenes (nothing added to controller)");
				}
			}
		};

		/**
   * Initializes rAF callback
   * @private
   */
		var debounceUpdate = function () {
			_updateTimeout = _util.rAF(updateScenes);
		};

		/**
   * Handles Container changes
   * @private
   */
		var onChange = function (e) {
			log(3, "event fired causing an update:", e.type);
			if (e.type == "resize") {
				// resize
				_viewPortSize = getViewportSize();
				_scrollDirection = SCROLL_DIRECTION_PAUSED;
			}
			// schedule update
			if (_updateScenesOnNextCycle !== true) {
				_updateScenesOnNextCycle = true;
				debounceUpdate();
			}
		};

		var refresh = function () {
			if (!_isDocument) {
				// simulate resize event. Only works for viewport relevant param (performance)
				if (_viewPortSize != getViewportSize()) {
					var resizeEvent;
					try {
						resizeEvent = new Event('resize', {
							bubbles: false,
							cancelable: false
						});
					} catch (e) {
						// stupid IE
						resizeEvent = document.createEvent("Event");
						resizeEvent.initEvent("resize", false, false);
					}
					_options.container.dispatchEvent(resizeEvent);
				}
			}
			_sceneObjects.forEach(function (scene, index) {
				// refresh all scenes
				scene.refresh();
			});
			scheduleRefresh();
		};

		/**
   * Send a debug message to the console.
   * provided publicly with _log for plugins
   * @private
   *
   * @param {number} loglevel - The loglevel required to initiate output for the message.
   * @param {...mixed} output - One or more variables that should be passed to the console.
   */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};
		// for scenes we have getters for each option, but for the controller we don't, so we need to make it available externally for plugins
		this._options = _options;

		/**
   * Sort scenes in ascending order of their start offset.
   * @private
   *
   * @param {array} ScenesArray - an array of ScrollMagic Scenes that should be sorted
   * @return {array} The sorted array of Scenes.
   */
		var sortScenes = function (ScenesArray) {
			if (ScenesArray.length <= 1) {
				return ScenesArray;
			} else {
				var scenes = ScenesArray.slice(0);
				scenes.sort(function (a, b) {
					return a.scrollOffset() > b.scrollOffset() ? 1 : -1;
				});
				return scenes;
			}
		};

		/**
   * ----------------------------------------------------------------
   * public functions
   * ----------------------------------------------------------------
   */

		/**
   * Add one ore more scene(s) to the controller.  
   * This is the equivalent to `Scene.addTo(controller)`.
   * @public
   * @example
   * // with a previously defined scene
   * controller.addScene(scene);
   *
   * // with a newly created scene.
   * controller.addScene(new ScrollMagic.Scene({duration : 0}));
   *
   * // adding multiple scenes
   * controller.addScene([scene, scene2, new ScrollMagic.Scene({duration : 0})]);
   *
   * @param {(ScrollMagic.Scene|array)} newScene - ScrollMagic Scene or Array of Scenes to be added to the controller.
   * @return {Controller} Parent object for chaining.
   */
		this.addScene = function (newScene) {
			if (_util.type.Array(newScene)) {
				newScene.forEach(function (scene, index) {
					Controller.addScene(scene);
				});
			} else if (newScene instanceof ScrollMagic.Scene) {
				if (newScene.controller() !== Controller) {
					newScene.addTo(Controller);
				} else if (_sceneObjects.indexOf(newScene) < 0) {
					// new scene
					_sceneObjects.push(newScene); // add to array
					_sceneObjects = sortScenes(_sceneObjects); // sort
					newScene.on("shift.controller_sort", function () {
						// resort whenever scene moves
						_sceneObjects = sortScenes(_sceneObjects);
					});
					// insert Global defaults.
					for (var key in _options.globalSceneOptions) {
						if (newScene[key]) {
							newScene[key].call(newScene, _options.globalSceneOptions[key]);
						}
					}
					log(3, "adding Scene (now " + _sceneObjects.length + " total)");
				}
			} else {
				log(1, "ERROR: invalid argument supplied for '.addScene()'");
			}
			return Controller;
		};

		/**
   * Remove one ore more scene(s) from the controller.  
   * This is the equivalent to `Scene.remove()`.
   * @public
   * @example
   * // remove a scene from the controller
   * controller.removeScene(scene);
   *
   * // remove multiple scenes from the controller
   * controller.removeScene([scene, scene2, scene3]);
   *
   * @param {(ScrollMagic.Scene|array)} Scene - ScrollMagic Scene or Array of Scenes to be removed from the controller.
   * @returns {Controller} Parent object for chaining.
   */
		this.removeScene = function (Scene) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.removeScene(scene);
				});
			} else {
				var index = _sceneObjects.indexOf(Scene);
				if (index > -1) {
					Scene.off("shift.controller_sort");
					_sceneObjects.splice(index, 1);
					log(3, "removing Scene (now " + _sceneObjects.length + " left)");
					Scene.remove();
				}
			}
			return Controller;
		};

		/**
   * Update one ore more scene(s) according to the scroll position of the container.  
   * This is the equivalent to `Scene.update()`.  
   * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
   * It then updates the current scene state accordingly (or does nothing, if the state is already correct) – Pins will be set to their correct position and tweens will be updated to their correct progress.  
   * _**Note:** This method gets called constantly whenever Controller detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
   * @public
   * @example
   * // update a specific scene on next cycle
   * controller.updateScene(scene);
   *
   * // update a specific scene immediately
   * controller.updateScene(scene, true);
   *
   * // update multiple scenes scene on next cycle
   * controller.updateScene([scene1, scene2, scene3]);
   *
   * @param {ScrollMagic.Scene} Scene - ScrollMagic Scene or Array of Scenes that is/are supposed to be updated.
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle.  
   This is useful when changing multiple properties of the scene - this way it will only be updated once all new properties are set (updateScenes).
   * @return {Controller} Parent object for chaining.
   */
		this.updateScene = function (Scene, immediately) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.updateScene(scene, immediately);
				});
			} else {
				if (immediately) {
					Scene.update(true);
				} else if (_updateScenesOnNextCycle !== true && Scene instanceof ScrollMagic.Scene) {
					// if _updateScenesOnNextCycle is true, all connected scenes are already scheduled for update
					// prep array for next update cycle
					_updateScenesOnNextCycle = _updateScenesOnNextCycle || [];
					if (_updateScenesOnNextCycle.indexOf(Scene) == -1) {
						_updateScenesOnNextCycle.push(Scene);
					}
					_updateScenesOnNextCycle = sortScenes(_updateScenesOnNextCycle); // sort
					debounceUpdate();
				}
			}
			return Controller;
		};

		/**
   * Updates the controller params and calls updateScene on every scene, that is attached to the controller.  
   * See `Controller.updateScene()` for more information about what this means.  
   * In most cases you will not need this function, as it is called constantly, whenever ScrollMagic detects a state change event, like resize or scroll.  
   * The only application for this method is when ScrollMagic fails to detect these events.  
   * One application is with some external scroll libraries (like iScroll) that move an internal container to a negative offset instead of actually scrolling. In this case the update on the controller needs to be called whenever the child container's position changes.
   * For this case there will also be the need to provide a custom function to calculate the correct scroll position. See `Controller.scrollPos()` for details.
   * @public
   * @example
   * // update the controller on next cycle (saves performance due to elimination of redundant updates)
   * controller.update();
   *
   * // update the controller immediately
   * controller.update(true);
   *
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance)
   * @return {Controller} Parent object for chaining.
   */
		this.update = function (immediately) {
			onChange({
				type: "resize"
			}); // will update size and set _updateScenesOnNextCycle to true
			if (immediately) {
				updateScenes();
			}
			return Controller;
		};

		/**
   * Scroll to a numeric scroll offset, a DOM element, the start of a scene or provide an alternate method for scrolling.  
   * For vertical controllers it will change the top scroll offset and for horizontal applications it will change the left offset.
   * @public
   *
   * @since 1.1.0
   * @example
   * // scroll to an offset of 100
   * controller.scrollTo(100);
   *
   * // scroll to a DOM element
   * controller.scrollTo("#anchor");
   *
   * // scroll to the beginning of a scene
   * var scene = new ScrollMagic.Scene({offset: 200});
   * controller.scrollTo(scene);
   *
   * // define a new scroll position modification function (jQuery animate instead of jump)
   * controller.scrollTo(function (newScrollPos) {
   *	$("html, body").animate({scrollTop: newScrollPos});
   * });
   * controller.scrollTo(100); // call as usual, but the new function will be used instead
   *
   * // define a new scroll function with an additional parameter
   * controller.scrollTo(function (newScrollPos, message) {
   *  console.log(message);
   *	$(this).animate({scrollTop: newScrollPos});
   * });
   * // call as usual, but supply an extra parameter to the defined custom function
   * controller.scrollTo(100, "my message");
   *
   * // define a new scroll function with an additional parameter containing multiple variables
   * controller.scrollTo(function (newScrollPos, options) {
   *  someGlobalVar = options.a + options.b;
   *	$(this).animate({scrollTop: newScrollPos});
   * });
   * // call as usual, but supply an extra parameter containing multiple options
   * controller.scrollTo(100, {a: 1, b: 2});
   *
   * // define a new scroll function with a callback supplied as an additional parameter
   * controller.scrollTo(function (newScrollPos, callback) {
   *	$(this).animate({scrollTop: newScrollPos}, 400, "swing", callback);
   * });
   * // call as usual, but supply an extra parameter, which is used as a callback in the previously defined custom scroll function
   * controller.scrollTo(100, function() {
   *	console.log("scroll has finished.");
   * });
   *
   * @param {mixed} scrollTarget - The supplied argument can be one of these types:
   * 1. `number` -> The container will scroll to this new scroll offset.
   * 2. `string` or `object` -> Can be a selector or a DOM object.  
   *  The container will scroll to the position of this element.
   * 3. `ScrollMagic Scene` -> The container will scroll to the start of this scene.
   * 4. `function` -> This function will be used for future scroll position modifications.  
   *  This provides a way for you to change the behaviour of scrolling and adding new behaviour like animation. The function receives the new scroll position as a parameter and a reference to the container element using `this`.  
   *  It may also optionally receive an optional additional parameter (see below)  
   *  _**NOTE:**  
   *  All other options will still work as expected, using the new function to scroll._
   * @param {mixed} [additionalParameter] - If a custom scroll function was defined (see above 4.), you may want to supply additional parameters to it, when calling it. You can do this using this parameter – see examples for details. Please note, that this parameter will have no effect, if you use the default scrolling function.
   * @returns {Controller} Parent object for chaining.
   */
		this.scrollTo = function (scrollTarget, additionalParameter) {
			if (_util.type.Number(scrollTarget)) {
				// excecute
				setScrollPos.call(_options.container, scrollTarget, additionalParameter);
			} else if (scrollTarget instanceof ScrollMagic.Scene) {
				// scroll to scene
				if (scrollTarget.controller() === Controller) {
					// check if the controller is associated with this scene
					Controller.scrollTo(scrollTarget.scrollOffset(), additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", scrollTarget);
				}
			} else if (_util.type.Function(scrollTarget)) {
				// assign new scroll function
				setScrollPos = scrollTarget;
			} else {
				// scroll to element
				var elem = _util.get.elements(scrollTarget)[0];
				if (elem) {
					// if parent is pin spacer, use spacer position instead so correct start position is returned for pinned elements.
					while (elem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						elem = elem.parentNode;
					}

					var param = _options.vertical ? "top" : "left",

					// which param is of interest ?
					containerOffset = _util.get.offset(_options.container),

					// container position is needed because element offset is returned in relation to document, not in relation to container.
					elementOffset = _util.get.offset(elem);

					if (!_isDocument) {
						// container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
						containerOffset[param] -= Controller.scrollPos();
					}

					Controller.scrollTo(elementOffset[param] - containerOffset[param], additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", scrollTarget);
				}
			}
			return Controller;
		};

		/**
   * **Get** the current scrollPosition or **Set** a new method to calculate it.  
   * -> **GET**:
   * When used as a getter this function will return the current scroll position.  
   * To get a cached value use Controller.info("scrollPos"), which will be updated in the update cycle.  
   * For vertical controllers it will return the top scroll offset and for horizontal applications it will return the left offset.
   *
   * -> **SET**:
   * When used as a setter this method prodes a way to permanently overwrite the controller's scroll position calculation.  
   * A typical usecase is when the scroll position is not reflected by the containers scrollTop or scrollLeft values, but for example by the inner offset of a child container.  
   * Moving a child container inside a parent is a commonly used method for several scrolling frameworks, including iScroll.  
   * By providing an alternate calculation function you can make sure ScrollMagic receives the correct scroll position.  
   * Please also bear in mind that your function should return y values for vertical scrolls an x for horizontals.
   *
   * To change the current scroll position please use `Controller.scrollTo()`.
   * @public
   *
   * @example
   * // get the current scroll Position
   * var scrollPos = controller.scrollPos();
   *
   * // set a new scroll position calculation method
   * controller.scrollPos(function () {
   *	return this.info("vertical") ? -mychildcontainer.y : -mychildcontainer.x
   * });
   *
   * @param {function} [scrollPosMethod] - The function to be used for the scroll position calculation of the container.
   * @returns {(number|Controller)} Current scroll position or parent object for chaining.
   */
		this.scrollPos = function (scrollPosMethod) {
			if (!arguments.length) {
				// get
				return getScrollPos.call(Controller);
			} else {
				// set
				if (_util.type.Function(scrollPosMethod)) {
					getScrollPos = scrollPosMethod;
				} else {
					log(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'.");
				}
			}
			return Controller;
		};

		/**
   * **Get** all infos or one in particular about the controller.
   * @public
   * @example
   * // returns the current scroll position (number)
   * var scrollPos = controller.info("scrollPos");
   *
   * // returns all infos as an object
   * var infos = controller.info();
   *
   * @param {string} [about] - If passed only this info will be returned instead of an object containing all.  
   Valid options are:
   ** `"size"` => the current viewport size of the container
   ** `"vertical"` => true if vertical scrolling, otherwise false
   ** `"scrollPos"` => the current scroll position
   ** `"scrollDirection"` => the last known direction of the scroll
   ** `"container"` => the container element
   ** `"isDocument"` => true if container element is the document.
   * @returns {(mixed|object)} The requested info(s).
   */
		this.info = function (about) {
			var values = {
				size: _viewPortSize,
				// contains height or width (in regard to orientation);
				vertical: _options.vertical,
				scrollPos: _scrollPos,
				scrollDirection: _scrollDirection,
				container: _options.container,
				isDocument: _isDocument
			};
			if (!arguments.length) {
				// get all as an object
				return values;
			} else if (values[about] !== undefined) {
				return values[about];
			} else {
				log(1, "ERROR: option \"" + about + "\" is not available");
				return;
			}
		};

		/**
   * **Get** or **Set** the current loglevel option value.
   * @public
   *
   * @example
   * // get the current value
   * var loglevel = controller.loglevel();
   *
   * // set a new value
   * controller.loglevel(3);
   *
   * @param {number} [newLoglevel] - The new loglevel setting of the Controller. `[0-3]`
   * @returns {(number|Controller)} Current loglevel or parent object for chaining.
   */
		this.loglevel = function (newLoglevel) {
			if (!arguments.length) {
				// get
				return _options.loglevel;
			} else if (_options.loglevel != newLoglevel) {
				// set
				_options.loglevel = newLoglevel;
			}
			return Controller;
		};

		/**
   * **Get** or **Set** the current enabled state of the controller.  
   * This can be used to disable all Scenes connected to the controller without destroying or removing them.
   * @public
   *
   * @example
   * // get the current value
   * var enabled = controller.enabled();
   *
   * // disable the controller
   * controller.enabled(false);
   *
   * @param {boolean} [newState] - The new enabled state of the controller `true` or `false`.
   * @returns {(boolean|Controller)} Current enabled state or parent object for chaining.
   */
		this.enabled = function (newState) {
			if (!arguments.length) {
				// get
				return _enabled;
			} else if (_enabled != newState) {
				// set
				_enabled = !!newState;
				Controller.updateScene(_sceneObjects, true);
			}
			return Controller;
		};

		/**
   * Destroy the Controller, all Scenes and everything.
   * @public
   *
   * @example
   * // without resetting the scenes
   * controller = controller.destroy();
   *
   * // with scene reset
   * controller = controller.destroy(true);
   *
   * @param {boolean} [resetScenes=false] - If `true` the pins and tweens (if existent) of all scenes will be reset.
   * @returns {null} Null to unset handler variables.
   */
		this.destroy = function (resetScenes) {
			window.clearTimeout(_refreshTimeout);
			var i = _sceneObjects.length;
			while (i--) {
				_sceneObjects[i].destroy(resetScenes);
			}
			_options.container.removeEventListener("resize", onChange);
			_options.container.removeEventListener("scroll", onChange);
			_util.cAF(_updateTimeout);
			log(3, "destroyed " + NAMESPACE + " (reset: " + (resetScenes ? "true" : "false") + ")");
			return null;
		};

		// INIT
		construct();
		return Controller;
	};

	// store pagewide controller options
	var CONTROLLER_OPTIONS = {
		defaults: {
			container: window,
			vertical: true,
			globalSceneOptions: {},
			loglevel: 2,
			refreshInterval: 100
		}
	};
	/*
  * method used to add an option to ScrollMagic Scenes.
  */
	ScrollMagic.Controller.addOption = function (name, defaultValue) {
		CONTROLLER_OPTIONS.defaults[name] = defaultValue;
	};
	// instance extension function for plugins
	ScrollMagic.Controller.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Controller = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Controller, oldClass); // copy properties
		ScrollMagic.Controller.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Controller.prototype.constructor = ScrollMagic.Controller; // restore constructor
	};

	/**
  * A Scene defines where the controller should react and how.
  *
  * @class
  *
  * @example
  * // create a standard scene and add it to a controller
  * new ScrollMagic.Scene()
  *		.addTo(controller);
  *
  * // create a scene with custom options and assign a handler to it.
  * var scene = new ScrollMagic.Scene({
  * 		duration: 100,
  *		offset: 200,
  *		triggerHook: "onEnter",
  *		reverse: false
  * });
  *
  * @param {object} [options] - Options for the Scene. The options can be updated at any time.  
  Instead of setting the options for each scene individually you can also set them globally in the controller as the controllers `globalSceneOptions` option. The object accepts the same properties as the ones below.  
  When a scene is added to the controller the options defined using the Scene constructor will be overwritten by those set in `globalSceneOptions`.
  * @param {(number|function)} [options.duration=0] - The duration of the scene. 
  If `0` tweens will auto-play when reaching the scene start point, pins will be pinned indefinetly starting at the start position.  
  A function retuning the duration value is also supported. Please see `Scene.duration()` for details.
  * @param {number} [options.offset=0] - Offset Value for the Trigger Position. If no triggerElement is defined this will be the scroll distance from the start of the page, after which the scene will start.
  * @param {(string|object)} [options.triggerElement=null] - Selector or DOM object that defines the start of the scene. If undefined the scene will start right at the start of the page (unless an offset is set).
  * @param {(number|string)} [options.triggerHook="onCenter"] - Can be a number between 0 and 1 defining the position of the trigger Hook in relation to the viewport.  
  Can also be defined using a string:
  ** `"onEnter"` => `1`
  ** `"onCenter"` => `0.5`
  ** `"onLeave"` => `0`
  * @param {boolean} [options.reverse=true] - Should the scene reverse, when scrolling up?
  * @param {number} [options.loglevel=2] - Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
  ** `0` => silent
  ** `1` => errors
  ** `2` => errors, warnings
  ** `3` => errors, warnings, debuginfo
  * 
  */
	ScrollMagic.Scene = function (options) {

		/*
  	 * ----------------------------------------------------------------
  	 * settings
  	 * ----------------------------------------------------------------
  	 */

		var NAMESPACE = 'ScrollMagic.Scene',
		    SCENE_STATE_BEFORE = 'BEFORE',
		    SCENE_STATE_DURING = 'DURING',
		    SCENE_STATE_AFTER = 'AFTER',
		    DEFAULT_OPTIONS = SCENE_OPTIONS.defaults;

		/*
  	 * ----------------------------------------------------------------
  	 * private vars
  	 * ----------------------------------------------------------------
  	 */

		var Scene = this,
		    _options = _util.extend({}, DEFAULT_OPTIONS, options),
		    _state = SCENE_STATE_BEFORE,
		    _progress = 0,
		    _scrollOffset = {
			start: 0,
			end: 0
		},

		// reflects the controllers's scroll position for the start and end of the scene respectively
		_triggerPos = 0,
		    _enabled = true,
		    _durationUpdateMethod,
		    _controller;

		/**
   * Internal constructor function of the ScrollMagic Scene
   * @private
   */
		var construct = function () {
			for (var key in _options) {
				// check supplied options
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			// add getters/setters for all possible options
			for (var optionName in DEFAULT_OPTIONS) {
				addSceneOption(optionName);
			}
			// validate all options
			validateOption();
		};

		/*
   * ----------------------------------------------------------------
   * Event Management
   * ----------------------------------------------------------------
   */

		var _listeners = {};
		/**
   * Scene start event.  
   * Fires whenever the scroll position its the starting point of the scene.  
   * It will also fire when scrolling back up going over the start position of the scene. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#start
   *
   * @example
   * scene.on("start", function (event) {
   * 	console.log("Hit start point of scene.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"` or `"DURING"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene end event.  
   * Fires whenever the scroll position its the ending point of the scene.  
   * It will also fire when scrolling back up from after the scene and going over its end position. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#end
   *
   * @example
   * scene.on("end", function (event) {
   * 	console.log("Hit end point of scene.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"DURING"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene enter event.  
   * Fires whenever the scene enters the "DURING" state.  
   * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene enters its active scroll timeframe, regardless of the scroll-direction.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#enter
   *
   * @example
   * scene.on("enter", function (event) {
   * 	console.log("Scene entered.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene - always `"DURING"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene leave event.  
   * Fires whenever the scene's state goes from "DURING" to either "BEFORE" or "AFTER".  
   * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene leaves its active scroll timeframe, regardless of the scroll-direction.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#leave
   *
   * @example
   * scene.on("leave", function (event) {
   * 	console.log("Scene left.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene update event.  
   * Fires whenever the scene is updated (but not necessarily changes the progress).
   *
   * @event ScrollMagic.Scene#update
   *
   * @example
   * scene.on("update", function (event) {
   * 	console.log("Scene updated.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.startPos - The starting position of the scene (in relation to the conainer)
   * @property {number} event.endPos - The ending position of the scene (in relation to the conainer)
   * @property {number} event.scrollPos - The current scroll position of the container
   */
		/**
   * Scene progress event.  
   * Fires whenever the progress of the scene changes.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#progress
   *
   * @example
   * scene.on("progress", function (event) {
   * 	console.log("Scene progress changed to " + event.progress);
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"`, `"DURING"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene change event.  
   * Fires whenvever a property of the scene is changed.
   *
   * @event ScrollMagic.Scene#change
   *
   * @example
   * scene.on("change", function (event) {
   * 	console.log("Scene Property \"" + event.what + "\" changed to " + event.newval);
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {string} event.what - Indicates what value has been changed
   * @property {mixed} event.newval - The new value of the changed property
   */
		/**
   * Scene shift event.  
   * Fires whenvever the start or end **scroll offset** of the scene change.
   * This happens explicitely, when one of these values change: `offset`, `duration` or `triggerHook`.
   * It will fire implicitly when the `triggerElement` changes, if the new element has a different position (most cases).
   * It will also fire implicitly when the size of the container changes and the triggerHook is anything other than `onLeave`.
   *
   * @event ScrollMagic.Scene#shift
   * @since 1.1.0
   *
   * @example
   * scene.on("shift", function (event) {
   * 	console.log("Scene moved, because the " + event.reason + " has changed.)");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {string} event.reason - Indicates why the scene has shifted
   */
		/**
   * Scene destroy event.  
   * Fires whenvever the scene is destroyed.
   * This can be used to tidy up custom behaviour used in events.
   *
   * @event ScrollMagic.Scene#destroy
   * @since 1.1.0
   *
   * @example
   * scene.on("enter", function (event) {
   *        // add custom action
   *        $("#my-elem").left("200");
   *      })
   *      .on("destroy", function (event) {
   *        // reset my element to start position
   *        if (event.reset) {
   *          $("#my-elem").left("0");
   *        }
   *      });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {boolean} event.reset - Indicates if the destroy method was called with reset `true` or `false`.
   */
		/**
   * Scene add event.  
   * Fires when the scene is added to a controller.
   * This is mostly used by plugins to know that change might be due.
   *
   * @event ScrollMagic.Scene#add
   * @since 2.0.0
   *
   * @example
   * scene.on("add", function (event) {
   * 	console.log('Scene was added to a new controller.');
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {boolean} event.controller - The controller object the scene was added to.
   */
		/**
   * Scene remove event.  
   * Fires when the scene is removed from a controller.
   * This is mostly used by plugins to know that change might be due.
   *
   * @event ScrollMagic.Scene#remove
   * @since 2.0.0
   *
   * @example
   * scene.on("remove", function (event) {
   * 	console.log('Scene was removed from its controller.');
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   */

		/**
   * Add one ore more event listener.  
   * The callback function will be fired at the respective event, and an object containing relevant data will be passed to the callback.
   * @method ScrollMagic.Scene#on
   *
   * @example
   * function callback (event) {
   * 		console.log("Event fired! (" + event.type + ")");
   * }
   * // add listeners
   * scene.on("change update progress start end enter leave", callback);
   *
   * @param {string} names - The name or names of the event the callback should be attached to.
   * @param {function} callback - A function that should be executed, when the event is dispatched. An event object will be passed to the callback.
   * @returns {Scene} Parent object for chaining.
   */
		this.on = function (names, callback) {
			if (_util.type.Function(callback)) {
				names = names.trim().split(' ');
				names.forEach(function (fullname) {
					var nameparts = fullname.split('.'),
					    eventname = nameparts[0],
					    namespace = nameparts[1];
					if (eventname != "*") {
						// disallow wildcards
						if (!_listeners[eventname]) {
							_listeners[eventname] = [];
						}
						_listeners[eventname].push({
							namespace: namespace || '',
							callback: callback
						});
					}
				});
			} else {
				log(1, "ERROR when calling '.on()': Supplied callback for '" + names + "' is not a valid function!");
			}
			return Scene;
		};

		/**
   * Remove one or more event listener.
   * @method ScrollMagic.Scene#off
   *
   * @example
   * function callback (event) {
   * 		console.log("Event fired! (" + event.type + ")");
   * }
   * // add listeners
   * scene.on("change update", callback);
   * // remove listeners
   * scene.off("change update", callback);
   *
   * @param {string} names - The name or names of the event that should be removed.
   * @param {function} [callback] - A specific callback function that should be removed. If none is passed all callbacks to the event listener will be removed.
   * @returns {Scene} Parent object for chaining.
   */
		this.off = function (names, callback) {
			if (!names) {
				log(1, "ERROR: Invalid event name supplied.");
				return Scene;
			}
			names = names.trim().split(' ');
			names.forEach(function (fullname, key) {
				var nameparts = fullname.split('.'),
				    eventname = nameparts[0],
				    namespace = nameparts[1] || '',
				    removeList = eventname === '*' ? Object.keys(_listeners) : [eventname];
				removeList.forEach(function (remove) {
					var list = _listeners[remove] || [],
					    i = list.length;
					while (i--) {
						var listener = list[i];
						if (listener && (namespace === listener.namespace || namespace === '*') && (!callback || callback == listener.callback)) {
							list.splice(i, 1);
						}
					}
					if (!list.length) {
						delete _listeners[remove];
					}
				});
			});
			return Scene;
		};

		/**
   * Trigger an event.
   * @method ScrollMagic.Scene#trigger
   *
   * @example
   * this.trigger("change");
   *
   * @param {string} name - The name of the event that should be triggered.
   * @param {object} [vars] - An object containing info that should be passed to the callback.
   * @returns {Scene} Parent object for chaining.
   */
		this.trigger = function (name, vars) {
			if (name) {
				var nameparts = name.trim().split('.'),
				    eventname = nameparts[0],
				    namespace = nameparts[1],
				    listeners = _listeners[eventname];
				log(3, 'event fired:', eventname, vars ? "->" : '', vars || '');
				if (listeners) {
					listeners.forEach(function (listener, key) {
						if (!namespace || namespace === listener.namespace) {
							listener.callback.call(Scene, new ScrollMagic.Event(eventname, listener.namespace, Scene, vars));
						}
					});
				}
			} else {
				log(1, "ERROR: Invalid event name supplied.");
			}
			return Scene;
		};

		// set event listeners
		Scene.on("change.internal", function (e) {
			if (e.what !== "loglevel" && e.what !== "tweenChanges") {
				// no need for a scene update scene with these options...
				if (e.what === "triggerElement") {
					updateTriggerElementPosition();
				} else if (e.what === "reverse") {
					// the only property left that may have an impact on the current scene state. Everything else is handled by the shift event.
					Scene.update();
				}
			}
		}).on("shift.internal", function (e) {
			updateScrollOffset();
			Scene.update(); // update scene to reflect new position
		});

		/**
   * Send a debug message to the console.
   * @private
   * but provided publicly with _log for plugins
   *
   * @param {number} loglevel - The loglevel required to initiate output for the message.
   * @param {...mixed} output - One or more variables that should be passed to the console.
   */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};

		/**
   * Add the scene to a controller.  
   * This is the equivalent to `Controller.addScene(scene)`.
   * @method ScrollMagic.Scene#addTo
   *
   * @example
   * // add a scene to a ScrollMagic Controller
   * scene.addTo(controller);
   *
   * @param {ScrollMagic.Controller} controller - The controller to which the scene should be added.
   * @returns {Scene} Parent object for chaining.
   */
		this.addTo = function (controller) {
			if (!(controller instanceof ScrollMagic.Controller)) {
				log(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller");
			} else if (_controller != controller) {
				// new controller
				if (_controller) {
					// was associated to a different controller before, so remove it...
					_controller.removeScene(Scene);
				}
				_controller = controller;
				validateOption();
				updateDuration(true);
				updateTriggerElementPosition(true);
				updateScrollOffset();
				_controller.info("container").addEventListener('resize', onContainerResize);
				controller.addScene(Scene);
				Scene.trigger("add", {
					controller: _controller
				});
				log(3, "added " + NAMESPACE + " to controller");
				Scene.update();
			}
			return Scene;
		};

		/**
   * **Get** or **Set** the current enabled state of the scene.  
   * This can be used to disable this scene without removing or destroying it.
   * @method ScrollMagic.Scene#enabled
   *
   * @example
   * // get the current value
   * var enabled = scene.enabled();
   *
   * // disable the scene
   * scene.enabled(false);
   *
   * @param {boolean} [newState] - The new enabled state of the scene `true` or `false`.
   * @returns {(boolean|Scene)} Current enabled state or parent object for chaining.
   */
		this.enabled = function (newState) {
			if (!arguments.length) {
				// get
				return _enabled;
			} else if (_enabled != newState) {
				// set
				_enabled = !!newState;
				Scene.update(true);
			}
			return Scene;
		};

		/**
   * Remove the scene from the controller.  
   * This is the equivalent to `Controller.removeScene(scene)`.
   * The scene will not be updated anymore until you readd it to a controller.
   * To remove the pin or the tween you need to call removeTween() or removePin() respectively.
   * @method ScrollMagic.Scene#remove
   * @example
   * // remove the scene from its controller
   * scene.remove();
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.remove = function () {
			if (_controller) {
				_controller.info("container").removeEventListener('resize', onContainerResize);
				var tmpParent = _controller;
				_controller = undefined;
				tmpParent.removeScene(Scene);
				Scene.trigger("remove");
				log(3, "removed " + NAMESPACE + " from controller");
			}
			return Scene;
		};

		/**
   * Destroy the scene and everything.
   * @method ScrollMagic.Scene#destroy
   * @example
   * // destroy the scene without resetting the pin and tween to their initial positions
   * scene = scene.destroy();
   *
   * // destroy the scene and reset the pin and tween
   * scene = scene.destroy(true);
   *
   * @param {boolean} [reset=false] - If `true` the pin and tween (if existent) will be reset.
   * @returns {null} Null to unset handler variables.
   */
		this.destroy = function (reset) {
			Scene.trigger("destroy", {
				reset: reset
			});
			Scene.remove();
			Scene.off("*.*");
			log(3, "destroyed " + NAMESPACE + " (reset: " + (reset ? "true" : "false") + ")");
			return null;
		};

		/**
   * Updates the Scene to reflect the current state.  
   * This is the equivalent to `Controller.updateScene(scene, immediately)`.  
   * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
   * It then updates the current scene state accordingly (or does nothing, if the state is already correct) – Pins will be set to their correct position and tweens will be updated to their correct progress.
   * This means an update doesn't necessarily result in a progress change. The `progress` event will be fired if the progress has indeed changed between this update and the last.  
   * _**NOTE:** This method gets called constantly whenever ScrollMagic detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
   * @method ScrollMagic.Scene#update
   * @example
   * // update the scene on next tick
   * scene.update();
   *
   * // update the scene immediately
   * scene.update(true);
   *
   * @fires Scene.update
   *
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance).
   * @returns {Scene} Parent object for chaining.
   */
		this.update = function (immediately) {
			if (_controller) {
				if (immediately) {
					if (_controller.enabled() && _enabled) {
						var scrollPos = _controller.info("scrollPos"),
						    newProgress;

						if (_options.duration > 0) {
							newProgress = (scrollPos - _scrollOffset.start) / (_scrollOffset.end - _scrollOffset.start);
						} else {
							newProgress = scrollPos >= _scrollOffset.start ? 1 : 0;
						}

						Scene.trigger("update", {
							startPos: _scrollOffset.start,
							endPos: _scrollOffset.end,
							scrollPos: scrollPos
						});

						Scene.progress(newProgress);
					} else if (_pin && _state === SCENE_STATE_DURING) {
						updatePinState(true); // unpin in position
					}
				} else {
						_controller.updateScene(Scene, false);
					}
			}
			return Scene;
		};

		/**
   * Updates dynamic scene variables like the trigger element position or the duration.
   * This method is automatically called in regular intervals from the controller. See {@link ScrollMagic.Controller} option `refreshInterval`.
   * 
   * You can call it to minimize lag, for example when you intentionally change the position of the triggerElement.
   * If you don't it will simply be updated in the next refresh interval of the container, which is usually sufficient.
   *
   * @method ScrollMagic.Scene#refresh
   * @since 1.1.0
   * @example
   * scene = new ScrollMagic.Scene({triggerElement: "#trigger"});
   * 
   * // change the position of the trigger
   * $("#trigger").css("top", 500);
   * // immediately let the scene know of this change
   * scene.refresh();
   *
   * @fires {@link Scene.shift}, if the trigger element position or the duration changed
   * @fires {@link Scene.change}, if the duration changed
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.refresh = function () {
			updateDuration();
			updateTriggerElementPosition();
			// update trigger element position
			return Scene;
		};

		/**
   * **Get** or **Set** the scene's progress.  
   * Usually it shouldn't be necessary to use this as a setter, as it is set automatically by scene.update().  
   * The order in which the events are fired depends on the duration of the scene:
   *  1. Scenes with `duration == 0`:  
   *  Scenes that have no duration by definition have no ending. Thus the `end` event will never be fired.  
   *  When the trigger position of the scene is passed the events are always fired in this order:  
   *  `enter`, `start`, `progress` when scrolling forward  
   *  and  
   *  `progress`, `start`, `leave` when scrolling in reverse
   *  2. Scenes with `duration > 0`:  
   *  Scenes with a set duration have a defined start and end point.  
   *  When scrolling past the start position of the scene it will fire these events in this order:  
   *  `enter`, `start`, `progress`  
   *  When continuing to scroll and passing the end point it will fire these events:  
   *  `progress`, `end`, `leave`  
   *  When reversing through the end point these events are fired:  
   *  `enter`, `end`, `progress`  
   *  And when continuing to scroll past the start position in reverse it will fire:  
   *  `progress`, `start`, `leave`  
   *  In between start and end the `progress` event will be called constantly, whenever the progress changes.
   * 
   * In short:  
   * `enter` events will always trigger **before** the progress update and `leave` envents will trigger **after** the progress update.  
   * `start` and `end` will always trigger at their respective position.
   * 
   * Please review the event descriptions for details on the events and the event object that is passed to the callback.
   * 
   * @method ScrollMagic.Scene#progress
   * @example
   * // get the current scene progress
   * var progress = scene.progress();
   *
   * // set new scene progress
   * scene.progress(0.3);
   *
   * @fires {@link Scene.enter}, when used as setter
   * @fires {@link Scene.start}, when used as setter
   * @fires {@link Scene.progress}, when used as setter
   * @fires {@link Scene.end}, when used as setter
   * @fires {@link Scene.leave}, when used as setter
   *
   * @param {number} [progress] - The new progress value of the scene `[0-1]`.
   * @returns {number} `get` -  Current scene progress.
   * @returns {Scene} `set` -  Parent object for chaining.
   */
		this.progress = function (progress) {
			if (!arguments.length) {
				// get
				return _progress;
			} else {
				// set
				var doUpdate = false,
				    oldState = _state,
				    scrollDirection = _controller ? _controller.info("scrollDirection") : 'PAUSED',
				    reverseOrForward = _options.reverse || progress >= _progress;
				if (_options.duration === 0) {
					// zero duration scenes
					doUpdate = _progress != progress;
					_progress = progress < 1 && reverseOrForward ? 0 : 1;
					_state = _progress === 0 ? SCENE_STATE_BEFORE : SCENE_STATE_DURING;
				} else {
					// scenes with start and end
					if (progress < 0 && _state !== SCENE_STATE_BEFORE && reverseOrForward) {
						// go back to initial state
						_progress = 0;
						_state = SCENE_STATE_BEFORE;
						doUpdate = true;
					} else if (progress >= 0 && progress < 1 && reverseOrForward) {
						_progress = progress;
						_state = SCENE_STATE_DURING;
						doUpdate = true;
					} else if (progress >= 1 && _state !== SCENE_STATE_AFTER) {
						_progress = 1;
						_state = SCENE_STATE_AFTER;
						doUpdate = true;
					} else if (_state === SCENE_STATE_DURING && !reverseOrForward) {
						updatePinState(); // in case we scrolled backwards mid-scene and reverse is disabled => update the pin position, so it doesn't move back as well.
					}
				}
				if (doUpdate) {
					// fire events
					var eventVars = {
						progress: _progress,
						state: _state,
						scrollDirection: scrollDirection
					},
					    stateChanged = _state != oldState;

					var trigger = function (eventName) {
						// tmp helper to simplify code
						Scene.trigger(eventName, eventVars);
					};

					if (stateChanged) {
						// enter events
						if (oldState !== SCENE_STATE_DURING) {
							trigger("enter");
							trigger(oldState === SCENE_STATE_BEFORE ? "start" : "end");
						}
					}
					trigger("progress");
					if (stateChanged) {
						// leave events
						if (_state !== SCENE_STATE_DURING) {
							trigger(_state === SCENE_STATE_BEFORE ? "start" : "end");
							trigger("leave");
						}
					}
				}

				return Scene;
			}
		};

		/**
   * Update the start and end scrollOffset of the container.
   * The positions reflect what the controller's scroll position will be at the start and end respectively.
   * Is called, when:
   *   - Scene event "change" is called with: offset, triggerHook, duration 
   *   - scroll container event "resize" is called
   *   - the position of the triggerElement changes
   *   - the controller changes -> addTo()
   * @private
   */
		var updateScrollOffset = function () {
			_scrollOffset = {
				start: _triggerPos + _options.offset
			};
			if (_controller && _options.triggerElement) {
				// take away triggerHook portion to get relative to top
				_scrollOffset.start -= _controller.info("size") * _options.triggerHook;
			}
			_scrollOffset.end = _scrollOffset.start + _options.duration;
		};

		/**
   * Updates the duration if set to a dynamic function.
   * This method is called when the scene is added to a controller and in regular intervals from the controller through scene.refresh().
   * 
   * @fires {@link Scene.change}, if the duration changed
   * @fires {@link Scene.shift}, if the duration changed
   *
   * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
   * @private
   */
		var updateDuration = function (suppressEvents) {
			// update duration
			if (_durationUpdateMethod) {
				var varname = "duration";
				if (changeOption(varname, _durationUpdateMethod.call(Scene)) && !suppressEvents) {
					// set
					Scene.trigger("change", {
						what: varname,
						newval: _options[varname]
					});
					Scene.trigger("shift", {
						reason: varname
					});
				}
			}
		};

		/**
   * Updates the position of the triggerElement, if present.
   * This method is called ...
   *  - ... when the triggerElement is changed
   *  - ... when the scene is added to a (new) controller
   *  - ... in regular intervals from the controller through scene.refresh().
   * 
   * @fires {@link Scene.shift}, if the position changed
   *
   * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
   * @private
   */
		var updateTriggerElementPosition = function (suppressEvents) {
			var elementPos = 0,
			    telem = _options.triggerElement;
			if (_controller && telem) {
				var controllerInfo = _controller.info(),
				    containerOffset = _util.get.offset(controllerInfo.container),

				// container position is needed because element offset is returned in relation to document, not in relation to container.
				param = controllerInfo.vertical ? "top" : "left"; // which param is of interest ?
				// if parent is spacer, use spacer position instead so correct start position is returned for pinned elements.
				while (telem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
					telem = telem.parentNode;
				}

				var elementOffset = _util.get.offset(telem);

				if (!controllerInfo.isDocument) {
					// container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
					containerOffset[param] -= _controller.scrollPos();
				}

				elementPos = elementOffset[param] - containerOffset[param];
			}
			var changed = elementPos != _triggerPos;
			_triggerPos = elementPos;
			if (changed && !suppressEvents) {
				Scene.trigger("shift", {
					reason: "triggerElementPosition"
				});
			}
		};

		/**
   * Trigger a shift event, when the container is resized and the triggerHook is > 1.
   * @private
   */
		var onContainerResize = function (e) {
			if (_options.triggerHook > 0) {
				Scene.trigger("shift", {
					reason: "containerResize"
				});
			}
		};

		var _validate = _util.extend(SCENE_OPTIONS.validate, {
			// validation for duration handled internally for reference to private var _durationMethod
			duration: function (val) {
				if (_util.type.String(val) && val.match(/^(\.|\d)*\d+%$/)) {
					// percentage value
					var perc = parseFloat(val) / 100;
					val = function () {
						return _controller ? _controller.info("size") * perc : 0;
					};
				}
				if (_util.type.Function(val)) {
					// function
					_durationUpdateMethod = val;
					try {
						val = parseFloat(_durationUpdateMethod());
					} catch (e) {
						val = -1; // will cause error below
					}
				}
				// val has to be float
				val = parseFloat(val);
				if (!_util.type.Number(val) || val < 0) {
					if (_durationUpdateMethod) {
						_durationUpdateMethod = undefined;
						throw ["Invalid return value of supplied function for option \"duration\":", val];
					} else {
						throw ["Invalid value for option \"duration\":", val];
					}
				}
				return val;
			}
		});

		/**
   * Checks the validity of a specific or all options and reset to default if neccessary.
   * @private
   */
		var validateOption = function (check) {
			check = arguments.length ? [check] : Object.keys(_validate);
			check.forEach(function (optionName, key) {
				var value;
				if (_validate[optionName]) {
					// there is a validation method for this option
					try {
						// validate value
						value = _validate[optionName](_options[optionName]);
					} catch (e) {
						// validation failed -> reset to default
						value = DEFAULT_OPTIONS[optionName];
						var logMSG = _util.type.String(e) ? [e] : e;
						if (_util.type.Array(logMSG)) {
							logMSG[0] = "ERROR: " + logMSG[0];
							logMSG.unshift(1); // loglevel 1 for error msg
							log.apply(this, logMSG);
						} else {
							log(1, "ERROR: Problem executing validation callback for option '" + optionName + "':", e.message);
						}
					} finally {
						_options[optionName] = value;
					}
				}
			});
		};

		/**
   * Helper used by the setter/getters for scene options
   * @private
   */
		var changeOption = function (varname, newval) {
			var changed = false,
			    oldval = _options[varname];
			if (_options[varname] != newval) {
				_options[varname] = newval;
				validateOption(varname); // resets to default if necessary
				changed = oldval != _options[varname];
			}
			return changed;
		};

		// generate getters/setters for all options
		var addSceneOption = function (optionName) {
			if (!Scene[optionName]) {
				Scene[optionName] = function (newVal) {
					if (!arguments.length) {
						// get
						return _options[optionName];
					} else {
						if (optionName === "duration") {
							// new duration is set, so any previously set function must be unset
							_durationUpdateMethod = undefined;
						}
						if (changeOption(optionName, newVal)) {
							// set
							Scene.trigger("change", {
								what: optionName,
								newval: _options[optionName]
							});
							if (SCENE_OPTIONS.shifts.indexOf(optionName) > -1) {
								Scene.trigger("shift", {
									reason: optionName
								});
							}
						}
					}
					return Scene;
				};
			}
		};

		/**
   * **Get** or **Set** the duration option value.
   * As a setter it also accepts a function returning a numeric value.  
   * This is particularly useful for responsive setups.
   *
   * The duration is updated using the supplied function every time `Scene.refresh()` is called, which happens periodically from the controller (see ScrollMagic.Controller option `refreshInterval`).  
   * _**NOTE:** Be aware that it's an easy way to kill performance, if you supply a function that has high CPU demand.  
   * Even for size and position calculations it is recommended to use a variable to cache the value. (see example)  
   * This counts double if you use the same function for multiple scenes._
   *
   * @method ScrollMagic.Scene#duration
   * @example
   * // get the current duration value
   * var duration = scene.duration();
   *
   * // set a new duration
   * scene.duration(300);
   *
   * // use a function to automatically adjust the duration to the window height.
   * var durationValueCache;
   * function getDuration () {
   *   return durationValueCache;
   * }
   * function updateDuration (e) {
   *   durationValueCache = window.innerHeight;
   * }
   * $(window).on("resize", updateDuration); // update the duration when the window size changes
   * $(window).triggerHandler("resize"); // set to initial value
   * scene.duration(getDuration); // supply duration method
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {(number|function)} [newDuration] - The new duration of the scene.
   * @returns {number} `get` -  Current scene duration.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the offset option value.
   * @method ScrollMagic.Scene#offset
   * @example
   * // get the current offset
   * var offset = scene.offset();
   *
   * // set a new offset
   * scene.offset(100);
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {number} [newOffset] - The new offset of the scene.
   * @returns {number} `get` -  Current scene offset.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the triggerElement option value.
   * Does **not** fire `Scene.shift`, because changing the trigger Element doesn't necessarily mean the start position changes. This will be determined in `Scene.refresh()`, which is automatically triggered.
   * @method ScrollMagic.Scene#triggerElement
   * @example
   * // get the current triggerElement
   * var triggerElement = scene.triggerElement();
   *
   * // set a new triggerElement using a selector
   * scene.triggerElement("#trigger");
   * // set a new triggerElement using a DOM object
   * scene.triggerElement(document.getElementById("trigger"));
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {(string|object)} [newTriggerElement] - The new trigger element for the scene.
   * @returns {(string|object)} `get` -  Current triggerElement.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the triggerHook option value.
   * @method ScrollMagic.Scene#triggerHook
   * @example
   * // get the current triggerHook value
   * var triggerHook = scene.triggerHook();
   *
   * // set a new triggerHook using a string
   * scene.triggerHook("onLeave");
   * // set a new triggerHook using a number
   * scene.triggerHook(0.7);
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {(number|string)} [newTriggerHook] - The new triggerHook of the scene. See {@link Scene} parameter description for value options.
   * @returns {number} `get` -  Current triggerHook (ALWAYS numerical).
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the reverse option value.
   * @method ScrollMagic.Scene#reverse
   * @example
   * // get the current reverse option
   * var reverse = scene.reverse();
   *
   * // set new reverse option
   * scene.reverse(false);
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {boolean} [newReverse] - The new reverse setting of the scene.
   * @returns {boolean} `get` -  Current reverse option value.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the loglevel option value.
   * @method ScrollMagic.Scene#loglevel
   * @example
   * // get the current loglevel
   * var loglevel = scene.loglevel();
   *
   * // set new loglevel
   * scene.loglevel(3);
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {number} [newLoglevel] - The new loglevel setting of the scene. `[0-3]`
   * @returns {number} `get` -  Current loglevel.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** the associated controller.
   * @method ScrollMagic.Scene#controller
   * @example
   * // get the controller of a scene
   * var controller = scene.controller();
   *
   * @returns {ScrollMagic.Controller} Parent controller or `undefined`
   */
		this.controller = function () {
			return _controller;
		};

		/**
   * **Get** the current state.
   * @method ScrollMagic.Scene#state
   * @example
   * // get the current state
   * var state = scene.state();
   *
   * @returns {string} `"BEFORE"`, `"DURING"` or `"AFTER"`
   */
		this.state = function () {
			return _state;
		};

		/**
   * **Get** the current scroll offset for the start of the scene.  
   * Mind, that the scrollOffset is related to the size of the container, if `triggerHook` is bigger than `0` (or `"onLeave"`).  
   * This means, that resizing the container or changing the `triggerHook` will influence the scene's start offset.
   * @method ScrollMagic.Scene#scrollOffset
   * @example
   * // get the current scroll offset for the start and end of the scene.
   * var start = scene.scrollOffset();
   * var end = scene.scrollOffset() + scene.duration();
   * console.log("the scene starts at", start, "and ends at", end);
   *
   * @returns {number} The scroll offset (of the container) at which the scene will trigger. Y value for vertical and X value for horizontal scrolls.
   */
		this.scrollOffset = function () {
			return _scrollOffset.start;
		};

		/**
   * **Get** the trigger position of the scene (including the value of the `offset` option).  
   * @method ScrollMagic.Scene#triggerPosition
   * @example
   * // get the scene's trigger position
   * var triggerPosition = scene.triggerPosition();
   *
   * @returns {number} Start position of the scene. Top position value for vertical and left position value for horizontal scrolls.
   */
		this.triggerPosition = function () {
			var pos = _options.offset; // the offset is the basis
			if (_controller) {
				// get the trigger position
				if (_options.triggerElement) {
					// Element as trigger
					pos += _triggerPos;
				} else {
					// return the height of the triggerHook to start at the beginning
					pos += _controller.info("size") * Scene.triggerHook();
				}
			}
			return pos;
		};

		var _pin, _pinOptions;

		Scene.on("shift.internal", function (e) {
			var durationChanged = e.reason === "duration";
			if (_state === SCENE_STATE_AFTER && durationChanged || _state === SCENE_STATE_DURING && _options.duration === 0) {
				// if [duration changed after a scene (inside scene progress updates pin position)] or [duration is 0, we are in pin phase and some other value changed].
				updatePinState();
			}
			if (durationChanged) {
				updatePinDimensions();
			}
		}).on("progress.internal", function (e) {
			updatePinState();
		}).on("add.internal", function (e) {
			updatePinDimensions();
		}).on("destroy.internal", function (e) {
			Scene.removePin(e.reset);
		});
		/**
   * Update the pin state.
   * @private
   */
		var updatePinState = function (forceUnpin) {
			if (_pin && _controller) {
				var containerInfo = _controller.info(),
				    pinTarget = _pinOptions.spacer.firstChild; // may be pin element or another spacer, if cascading pins
				if (!forceUnpin && _state === SCENE_STATE_DURING) {
					// during scene or if duration is 0 and we are past the trigger
					// pinned state
					if (_util.css(pinTarget, "position") != "fixed") {
						// change state before updating pin spacer (position changes due to fixed collapsing might occur.)
						_util.css(pinTarget, {
							"position": "fixed"
						});
						// update pin spacer
						updatePinDimensions();
					}

					var fixedPos = _util.get.offset(_pinOptions.spacer, true),

					// get viewport position of spacer
					scrollDistance = _options.reverse || _options.duration === 0 ? containerInfo.scrollPos - _scrollOffset.start // quicker
					: Math.round(_progress * _options.duration * 10) / 10; // if no reverse and during pin the position needs to be recalculated using the progress
					// add scrollDistance
					fixedPos[containerInfo.vertical ? "top" : "left"] += scrollDistance;

					// set new values
					_util.css(_pinOptions.spacer.firstChild, {
						top: fixedPos.top,
						left: fixedPos.left
					});
				} else {
					// unpinned state
					var newCSS = {
						position: _pinOptions.inFlow ? "relative" : "absolute",
						top: 0,
						left: 0
					},
					    change = _util.css(pinTarget, "position") != newCSS.position;

					if (!_pinOptions.pushFollowers) {
						newCSS[containerInfo.vertical ? "top" : "left"] = _options.duration * _progress;
					} else if (_options.duration > 0) {
						// only concerns scenes with duration
						if (_state === SCENE_STATE_AFTER && parseFloat(_util.css(_pinOptions.spacer, "padding-top")) === 0) {
							change = true; // if in after state but havent updated spacer yet (jumped past pin)
						} else if (_state === SCENE_STATE_BEFORE && parseFloat(_util.css(_pinOptions.spacer, "padding-bottom")) === 0) {
								// before
								change = true; // jumped past fixed state upward direction
							}
					}
					// set new values
					_util.css(pinTarget, newCSS);
					if (change) {
						// update pin spacer if state changed
						updatePinDimensions();
					}
				}
			}
		};

		/**
   * Update the pin spacer and/or element size.
   * The size of the spacer needs to be updated whenever the duration of the scene changes, if it is to push down following elements.
   * @private
   */
		var updatePinDimensions = function () {
			if (_pin && _controller && _pinOptions.inFlow) {
				// no spacerresize, if original position is absolute
				var after = _state === SCENE_STATE_AFTER,
				    before = _state === SCENE_STATE_BEFORE,
				    during = _state === SCENE_STATE_DURING,
				    vertical = _controller.info("vertical"),
				    pinTarget = _pinOptions.spacer.firstChild,

				// usually the pined element but can also be another spacer (cascaded pins)
				marginCollapse = _util.isMarginCollapseType(_util.css(_pinOptions.spacer, "display")),
				    css = {};

				// set new size
				// if relsize: spacer -> pin | else: pin -> spacer
				if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
					if (during) {
						_util.css(_pin, {
							"width": _util.get.width(_pinOptions.spacer)
						});
					} else {
						_util.css(_pin, {
							"width": "100%"
						});
					}
				} else {
					// minwidth is needed for cascaded pins.
					css["min-width"] = _util.get.width(vertical ? _pin : pinTarget, true, true);
					css.width = during ? css["min-width"] : "auto";
				}
				if (_pinOptions.relSize.height) {
					if (during) {
						// the only padding the spacer should ever include is the duration (if pushFollowers = true), so we need to substract that.
						_util.css(_pin, {
							"height": _util.get.height(_pinOptions.spacer) - (_pinOptions.pushFollowers ? _options.duration : 0)
						});
					} else {
						_util.css(_pin, {
							"height": "100%"
						});
					}
				} else {
					// margin is only included if it's a cascaded pin to resolve an IE9 bug
					css["min-height"] = _util.get.height(vertical ? pinTarget : _pin, true, !marginCollapse); // needed for cascading pins
					css.height = during ? css["min-height"] : "auto";
				}

				// add space for duration if pushFollowers is true
				if (_pinOptions.pushFollowers) {
					css["padding" + (vertical ? "Top" : "Left")] = _options.duration * _progress;
					css["padding" + (vertical ? "Bottom" : "Right")] = _options.duration * (1 - _progress);
				}
				_util.css(_pinOptions.spacer, css);
			}
		};

		/**
   * Updates the Pin state (in certain scenarios)
   * If the controller container is not the document and we are mid-pin-phase scrolling or resizing the main document can result to wrong pin positions.
   * So this function is called on resize and scroll of the document.
   * @private
   */
		var updatePinInContainer = function () {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
				updatePinState();
			}
		};

		/**
   * Updates the Pin spacer size state (in certain scenarios)
   * If container is resized during pin and relatively sized the size of the pin might need to be updated...
   * So this function is called on resize of the container.
   * @private
   */
		var updateRelativePinSpacer = function () {
			if (_controller && _pin && // well, duh
			_state === SCENE_STATE_DURING && ( // element in pinned state?
			// is width or height relatively sized, but not in relation to body? then we need to recalc.
			(_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) && _util.get.width(window) != _util.get.width(_pinOptions.spacer.parentNode) || _pinOptions.relSize.height && _util.get.height(window) != _util.get.height(_pinOptions.spacer.parentNode))) {
				updatePinDimensions();
			}
		};

		/**
   * Is called, when the mousewhel is used while over a pinned element inside a div container.
   * If the scene is in fixed state scroll events would be counted towards the body. This forwards the event to the scroll container.
   * @private
   */
		var onMousewheelOverPin = function (e) {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
				// in pin state
				e.preventDefault();
				_controller._setScrollPos(_controller.info("scrollPos") - ((e.wheelDelta || e[_controller.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || -e.detail * 30));
			}
		};

		/**
   * Pin an element for the duration of the tween.  
   * If the scene duration is 0 the element will only be unpinned, if the user scrolls back past the start position.  
   * Make sure only one pin is applied to an element at the same time.
   * An element can be pinned multiple times, but only successively.
   * _**NOTE:** The option `pushFollowers` has no effect, when the scene duration is 0._
   * @method ScrollMagic.Scene#setPin
   * @example
   * // pin element and push all following elements down by the amount of the pin duration.
   * scene.setPin("#pin");
   *
   * // pin element and keeping all following elements in their place. The pinned element will move past them.
   * scene.setPin("#pin", {pushFollowers: false});
   *
   * @param {(string|object)} element - A Selector targeting an element or a DOM object that is supposed to be pinned.
   * @param {object} [settings] - settings for the pin
   * @param {boolean} [settings.pushFollowers=true] - If `true` following elements will be "pushed" down for the duration of the pin, if `false` the pinned element will just scroll past them.  
   Ignored, when duration is `0`.
   * @param {string} [settings.spacerClass="scrollmagic-pin-spacer"] - Classname of the pin spacer element, which is used to replace the element.
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.setPin = function (element, settings) {
			var defaultSettings = {
				pushFollowers: true,
				spacerClass: "scrollmagic-pin-spacer"
			};
			settings = _util.extend({}, defaultSettings, settings);

			// validate Element
			element = _util.get.elements(element)[0];
			if (!element) {
				log(1, "ERROR calling method 'setPin()': Invalid pin element supplied.");
				return Scene; // cancel
			} else if (_util.css(element, "position") === "fixed") {
					log(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'.");
					return Scene; // cancel
				}

			if (_pin) {
				// preexisting pin?
				if (_pin === element) {
					// same pin we already have -> do nothing
					return Scene; // cancel
				} else {
						// kill old pin
						Scene.removePin();
					}
			}
			_pin = element;

			var parentDisplay = _pin.parentNode.style.display,
			    boundsParams = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];

			_pin.parentNode.style.display = 'none'; // hack start to force css to return stylesheet values instead of calculated px values.
			var inFlow = _util.css(_pin, "position") != "absolute",
			    pinCSS = _util.css(_pin, boundsParams.concat(["display"])),
			    sizeCSS = _util.css(_pin, ["width", "height"]);
			_pin.parentNode.style.display = parentDisplay; // hack end.
			if (!inFlow && settings.pushFollowers) {
				log(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled.");
				settings.pushFollowers = false;
			}
			window.setTimeout(function () {
				// wait until all finished, because with responsive duration it will only be set after scene is added to controller
				if (_pin && _options.duration === 0 && settings.pushFollowers) {
					log(2, "WARNING: pushFollowers =", true, "has no effect, when scene duration is 0.");
				}
			}, 0);

			// create spacer and insert
			var spacer = _pin.parentNode.insertBefore(document.createElement('div'), _pin),
			    spacerCSS = _util.extend(pinCSS, {
				position: inFlow ? "relative" : "absolute",
				boxSizing: "content-box",
				mozBoxSizing: "content-box",
				webkitBoxSizing: "content-box"
			});

			if (!inFlow) {
				// copy size if positioned absolutely, to work for bottom/right positioned elements.
				_util.extend(spacerCSS, _util.css(_pin, ["width", "height"]));
			}

			_util.css(spacer, spacerCSS);
			spacer.setAttribute(PIN_SPACER_ATTRIBUTE, "");
			_util.addClass(spacer, settings.spacerClass);

			// set the pin Options
			_pinOptions = {
				spacer: spacer,
				relSize: { // save if size is defined using % values. if so, handle spacer resize differently...
					width: sizeCSS.width.slice(-1) === "%",
					height: sizeCSS.height.slice(-1) === "%",
					autoFullWidth: sizeCSS.width === "auto" && inFlow && _util.isMarginCollapseType(pinCSS.display)
				},
				pushFollowers: settings.pushFollowers,
				inFlow: inFlow
			};

			// stores if the element takes up space in the document flow
			if (!_pin.___origStyle) {
				_pin.___origStyle = {};
				var pinInlineCSS = _pin.style,
				    copyStyles = boundsParams.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]);
				copyStyles.forEach(function (val) {
					_pin.___origStyle[val] = pinInlineCSS[val] || "";
				});
			}

			// if relative size, transfer it to spacer and make pin calculate it...
			if (_pinOptions.relSize.width) {
				_util.css(spacer, {
					width: sizeCSS.width
				});
			}
			if (_pinOptions.relSize.height) {
				_util.css(spacer, {
					height: sizeCSS.height
				});
			}

			// now place the pin element inside the spacer	
			spacer.appendChild(_pin);
			// and set new css
			_util.css(_pin, {
				position: inFlow ? "relative" : "absolute",
				margin: "auto",
				top: "auto",
				left: "auto",
				bottom: "auto",
				right: "auto"
			});

			if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
				_util.css(_pin, {
					boxSizing: "border-box",
					mozBoxSizing: "border-box",
					webkitBoxSizing: "border-box"
				});
			}

			// add listener to document to update pin position in case controller is not the document.
			window.addEventListener('scroll', updatePinInContainer);
			window.addEventListener('resize', updatePinInContainer);
			window.addEventListener('resize', updateRelativePinSpacer);
			// add mousewheel listener to catch scrolls over fixed elements
			_pin.addEventListener("mousewheel", onMousewheelOverPin);
			_pin.addEventListener("DOMMouseScroll", onMousewheelOverPin);

			log(3, "added pin");

			// finally update the pin to init
			updatePinState();

			return Scene;
		};

		/**
   * Remove the pin from the scene.
   * @method ScrollMagic.Scene#removePin
   * @example
   * // remove the pin from the scene without resetting it (the spacer is not removed)
   * scene.removePin();
   *
   * // remove the pin from the scene and reset the pin element to its initial position (spacer is removed)
   * scene.removePin(true);
   *
   * @param {boolean} [reset=false] - If `false` the spacer will not be removed and the element's position will not be reset.
   * @returns {Scene} Parent object for chaining.
   */
		this.removePin = function (reset) {
			if (_pin) {
				if (_state === SCENE_STATE_DURING) {
					updatePinState(true); // force unpin at position
				}
				if (reset || !_controller) {
					// if there's no controller no progress was made anyway...
					var pinTarget = _pinOptions.spacer.firstChild; // usually the pin element, but may be another spacer (cascaded pins)...
					if (pinTarget.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						// copy margins to child spacer
						var style = _pinOptions.spacer.style,
						    values = ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
						margins = {};
						values.forEach(function (val) {
							margins[val] = style[val] || "";
						});
						_util.css(pinTarget, margins);
					}
					_pinOptions.spacer.parentNode.insertBefore(pinTarget, _pinOptions.spacer);
					_pinOptions.spacer.parentNode.removeChild(_pinOptions.spacer);
					if (!_pin.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						// if it's the last pin for this element -> restore inline styles
						// TODO: only correctly set for first pin (when cascading) - how to fix?
						_util.css(_pin, _pin.___origStyle);
						delete _pin.___origStyle;
					}
				}
				window.removeEventListener('scroll', updatePinInContainer);
				window.removeEventListener('resize', updatePinInContainer);
				window.removeEventListener('resize', updateRelativePinSpacer);
				_pin.removeEventListener("mousewheel", onMousewheelOverPin);
				_pin.removeEventListener("DOMMouseScroll", onMousewheelOverPin);
				_pin = undefined;
				log(3, "removed pin (reset: " + (reset ? "true" : "false") + ")");
			}
			return Scene;
		};

		var _cssClasses,
		    _cssClassElems = [];

		Scene.on("destroy.internal", function (e) {
			Scene.removeClassToggle(e.reset);
		});
		/**
   * Define a css class modification while the scene is active.  
   * When the scene triggers the classes will be added to the supplied element and removed, when the scene is over.
   * If the scene duration is 0 the classes will only be removed if the user scrolls back past the start position.
   * @method ScrollMagic.Scene#setClassToggle
   * @example
   * // add the class 'myclass' to the element with the id 'my-elem' for the duration of the scene
   * scene.setClassToggle("#my-elem", "myclass");
   *
   * // add multiple classes to multiple elements defined by the selector '.classChange'
   * scene.setClassToggle(".classChange", "class1 class2 class3");
   *
   * @param {(string|object)} element - A Selector targeting one or more elements or a DOM object that is supposed to be modified.
   * @param {string} classes - One or more Classnames (separated by space) that should be added to the element during the scene.
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.setClassToggle = function (element, classes) {
			var elems = _util.get.elements(element);
			if (elems.length === 0 || !_util.type.String(classes)) {
				log(1, "ERROR calling method 'setClassToggle()': Invalid " + (elems.length === 0 ? "element" : "classes") + " supplied.");
				return Scene;
			}
			if (_cssClassElems.length > 0) {
				// remove old ones
				Scene.removeClassToggle();
			}
			_cssClasses = classes;
			_cssClassElems = elems;
			Scene.on("enter.internal_class leave.internal_class", function (e) {
				var toggle = e.type === "enter" ? _util.addClass : _util.removeClass;
				_cssClassElems.forEach(function (elem, key) {
					toggle(elem, _cssClasses);
				});
			});
			return Scene;
		};

		/**
   * Remove the class binding from the scene.
   * @method ScrollMagic.Scene#removeClassToggle
   * @example
   * // remove class binding from the scene without reset
   * scene.removeClassToggle();
   *
   * // remove class binding and remove the changes it caused
   * scene.removeClassToggle(true);
   *
   * @param {boolean} [reset=false] - If `false` and the classes are currently active, they will remain on the element. If `true` they will be removed.
   * @returns {Scene} Parent object for chaining.
   */
		this.removeClassToggle = function (reset) {
			if (reset) {
				_cssClassElems.forEach(function (elem, key) {
					_util.removeClass(elem, _cssClasses);
				});
			}
			Scene.off("start.internal_class end.internal_class");
			_cssClasses = undefined;
			_cssClassElems = [];
			return Scene;
		};

		// INIT
		construct();
		return Scene;
	};

	// store pagewide scene options
	var SCENE_OPTIONS = {
		defaults: {
			duration: 0,
			offset: 0,
			triggerElement: undefined,
			triggerHook: 0.5,
			reverse: true,
			loglevel: 2
		},
		validate: {
			offset: function (val) {
				val = parseFloat(val);
				if (!_util.type.Number(val)) {
					throw ["Invalid value for option \"offset\":", val];
				}
				return val;
			},
			triggerElement: function (val) {
				val = val || undefined;
				if (val) {
					var elem = _util.get.elements(val)[0];
					if (elem) {
						val = elem;
					} else {
						throw ["Element defined in option \"triggerElement\" was not found:", val];
					}
				}
				return val;
			},
			triggerHook: function (val) {
				var translate = {
					"onCenter": 0.5,
					"onEnter": 1,
					"onLeave": 0
				};
				if (_util.type.Number(val)) {
					val = Math.max(0, Math.min(parseFloat(val), 1)); //  make sure its betweeen 0 and 1
				} else if (val in translate) {
						val = translate[val];
					} else {
						throw ["Invalid value for option \"triggerHook\": ", val];
					}
				return val;
			},
			reverse: function (val) {
				return !!val; // force boolean
			},
			loglevel: function (val) {
				val = parseInt(val);
				if (!_util.type.Number(val) || val < 0 || val > 3) {
					throw ["Invalid value for option \"loglevel\":", val];
				}
				return val;
			}
		},
		// holder for  validation methods. duration validation is handled in 'getters-setters.js'
		shifts: ["duration", "offset", "triggerHook"]
	};
	/*
  * method used to add an option to ScrollMagic Scenes.
  * TODO: DOC (private for dev)
  */
	// list of options that trigger a `shift` event
	ScrollMagic.Scene.addOption = function (name, defaultValue, validationCallback, shifts) {
		if (!(name in SCENE_OPTIONS.defaults)) {
			SCENE_OPTIONS.defaults[name] = defaultValue;
			SCENE_OPTIONS.validate[name] = validationCallback;
			if (shifts) {
				SCENE_OPTIONS.shifts.push(name);
			}
		} else {
			ScrollMagic._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + name + "', because it already exists.");
		}
	};
	// instance extension function for plugins
	// TODO: DOC (private for dev)
	ScrollMagic.Scene.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Scene = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Scene, oldClass); // copy properties
		ScrollMagic.Scene.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Scene.prototype.constructor = ScrollMagic.Scene; // restore constructor
	};

	/**
  * TODO: DOCS (private for dev)
  * @class
  * @private
  */

	ScrollMagic.Event = function (type, namespace, target, vars) {
		vars = vars || {};
		for (var key in vars) {
			this[key] = vars[key];
		}
		this.type = type;
		this.target = this.currentTarget = target;
		this.namespace = namespace || '';
		this.timeStamp = this.timestamp = Date.now();
		return this;
	};

	/*
  * TODO: DOCS (private for dev)
  */

	var _util = ScrollMagic._util = function (window) {
		var U = {},
		    i;

		/**
   * ------------------------------
   * internal helpers
   * ------------------------------
   */

		// parse float and fall back to 0.
		var floatval = function (number) {
			return parseFloat(number) || 0;
		};
		// get current style IE safe (otherwise IE would return calculated values for 'auto')
		var _getComputedStyle = function (elem) {
			return elem.currentStyle ? elem.currentStyle : window.getComputedStyle(elem);
		};

		// get element dimension (width or height)
		var _dimension = function (which, elem, outer, includeMargin) {
			elem = elem === document ? window : elem;
			if (elem === window) {
				includeMargin = false;
			} else if (!_type.DomElement(elem)) {
				return 0;
			}
			which = which.charAt(0).toUpperCase() + which.substr(1).toLowerCase();
			var dimension = (outer ? elem['offset' + which] || elem['outer' + which] : elem['client' + which] || elem['inner' + which]) || 0;
			if (outer && includeMargin) {
				var style = _getComputedStyle(elem);
				dimension += which === 'Height' ? floatval(style.marginTop) + floatval(style.marginBottom) : floatval(style.marginLeft) + floatval(style.marginRight);
			}
			return dimension;
		};
		// converts 'margin-top' into 'marginTop'
		var _camelCase = function (str) {
			return str.replace(/^[^a-z]+([a-z])/g, '$1').replace(/-([a-z])/g, function (g) {
				return g[1].toUpperCase();
			});
		};

		/**
   * ------------------------------
   * external helpers
   * ------------------------------
   */

		// extend obj – same as jQuery.extend({}, objA, objB)
		U.extend = function (obj) {
			obj = obj || {};
			for (i = 1; i < arguments.length; i++) {
				if (!arguments[i]) {
					continue;
				}
				for (var key in arguments[i]) {
					if (arguments[i].hasOwnProperty(key)) {
						obj[key] = arguments[i][key];
					}
				}
			}
			return obj;
		};

		// check if a css display type results in margin-collapse or not
		U.isMarginCollapseType = function (str) {
			return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(str) > -1;
		};

		// implementation of requestAnimationFrame
		// based on https://gist.github.com/paulirish/1579671
		var lastTime = 0,
		    vendors = ['ms', 'moz', 'webkit', 'o'];
		var _requestAnimationFrame = window.requestAnimationFrame;
		var _cancelAnimationFrame = window.cancelAnimationFrame;
		// try vendor prefixes if the above doesn't work
		for (i = 0; !_requestAnimationFrame && i < vendors.length; ++i) {
			_requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
			_cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];
		}

		// fallbacks
		if (!_requestAnimationFrame) {
			_requestAnimationFrame = function (callback) {
				var currTime = new Date().getTime(),
				    timeToCall = Math.max(0, 16 - (currTime - lastTime)),
				    id = window.setTimeout(function () {
					callback(currTime + timeToCall);
				}, timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};
		}
		if (!_cancelAnimationFrame) {
			_cancelAnimationFrame = function (id) {
				window.clearTimeout(id);
			};
		}
		U.rAF = _requestAnimationFrame.bind(window);
		U.cAF = _cancelAnimationFrame.bind(window);

		var loglevels = ["error", "warn", "log"],
		    console = window.console || {};

		console.log = console.log || function () {}; // no console log, well - do nothing then...
		// make sure methods for all levels exist.
		for (i = 0; i < loglevels.length; i++) {
			var method = loglevels[i];
			if (!console[method]) {
				console[method] = console.log; // prefer .log over nothing
			}
		}
		U.log = function (loglevel) {
			if (loglevel > loglevels.length || loglevel <= 0) loglevel = loglevels.length;
			var now = new Date(),
			    time = ("0" + now.getHours()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2) + ":" + ("00" + now.getMilliseconds()).slice(-3),
			    method = loglevels[loglevel - 1],
			    args = Array.prototype.splice.call(arguments, 1),
			    func = Function.prototype.bind.call(console[method], console);
			args.unshift(time);
			func.apply(console, args);
		};

		/**
   * ------------------------------
   * type testing
   * ------------------------------
   */

		var _type = U.type = function (v) {
			return Object.prototype.toString.call(v).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
		};
		_type.String = function (v) {
			return _type(v) === 'string';
		};
		_type.Function = function (v) {
			return _type(v) === 'function';
		};
		_type.Array = function (v) {
			return Array.isArray(v);
		};
		_type.Number = function (v) {
			return !_type.Array(v) && v - parseFloat(v) + 1 >= 0;
		};
		_type.DomElement = function (o) {
			return typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
			o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
		};

		/**
   * ------------------------------
   * DOM Element info
   * ------------------------------
   */
		// always returns a list of matching DOM elements, from a selector, a DOM element or an list of elements or even an array of selectors
		var _get = U.get = {};
		_get.elements = function (selector) {
			var arr = [];
			if (_type.String(selector)) {
				try {
					selector = document.querySelectorAll(selector);
				} catch (e) {
					// invalid selector
					return arr;
				}
			}
			if (_type(selector) === 'nodelist' || _type.Array(selector)) {
				for (var i = 0, ref = arr.length = selector.length; i < ref; i++) {
					// list of elements
					var elem = selector[i];
					arr[i] = _type.DomElement(elem) ? elem : _get.elements(elem); // if not an element, try to resolve recursively
				}
			} else if (_type.DomElement(selector) || selector === document || selector === window) {
					arr = [selector]; // only the element
				}
			return arr;
		};
		// get scroll top value
		_get.scrollTop = function (elem) {
			return elem && typeof elem.scrollTop === 'number' ? elem.scrollTop : window.pageYOffset || 0;
		};
		// get scroll left value
		_get.scrollLeft = function (elem) {
			return elem && typeof elem.scrollLeft === 'number' ? elem.scrollLeft : window.pageXOffset || 0;
		};
		// get element height
		_get.width = function (elem, outer, includeMargin) {
			return _dimension('width', elem, outer, includeMargin);
		};
		// get element width
		_get.height = function (elem, outer, includeMargin) {
			return _dimension('height', elem, outer, includeMargin);
		};

		// get element position (optionally relative to viewport)
		_get.offset = function (elem, relativeToViewport) {
			var offset = {
				top: 0,
				left: 0
			};
			if (elem && elem.getBoundingClientRect) {
				// check if available
				var rect = elem.getBoundingClientRect();
				offset.top = rect.top;
				offset.left = rect.left;
				if (!relativeToViewport) {
					// clientRect is by default relative to viewport...
					offset.top += _get.scrollTop();
					offset.left += _get.scrollLeft();
				}
			}
			return offset;
		};

		/**
   * ------------------------------
   * DOM Element manipulation
   * ------------------------------
   */

		U.addClass = function (elem, classname) {
			if (classname) {
				if (elem.classList) elem.classList.add(classname);else elem.className += ' ' + classname;
			}
		};
		U.removeClass = function (elem, classname) {
			if (classname) {
				if (elem.classList) elem.classList.remove(classname);else elem.className = elem.className.replace(new RegExp('(^|\\b)' + classname.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
			}
		};
		// if options is string -> returns css value
		// if options is array -> returns object with css value pairs
		// if options is object -> set new css values
		U.css = function (elem, options) {
			if (_type.String(options)) {
				return _getComputedStyle(elem)[_camelCase(options)];
			} else if (_type.Array(options)) {
				var obj = {},
				    style = _getComputedStyle(elem);
				options.forEach(function (option, key) {
					obj[option] = style[_camelCase(option)];
				});
				return obj;
			} else {
				for (var option in options) {
					var val = options[option];
					if (val == parseFloat(val)) {
						// assume pixel for seemingly numerical values
						val += 'px';
					}
					elem.style[_camelCase(option)] = val;
				}
			}
		};

		return U;
	}(window || {});

	ScrollMagic.Scene.prototype.addIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	};
	ScrollMagic.Scene.prototype.setTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	};
	ScrollMagic.Scene.prototype.setVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	};

	return ScrollMagic;
});
'use strict';

/*!
 * ScrollMagic v2.0.5 (2015-04-29)
 * The javascript library for magical scroll interactions.
 * (c) 2015 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.5
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic GSAP Animation Plugin.
 *
 * requires: GSAP ~1.14
 * Powered by the Greensock Animation Platform (GSAP): http://www.greensock.com/js
 * Greensock License info at http://www.greensock.com/licensing/
 */
/**
 * This plugin is meant to be used in conjunction with the Greensock Animation Plattform.  
 * It offers an easy API to trigger Tweens or synchronize them to the scrollbar movement.
 *
 * Both the `lite` and the `max` versions of the GSAP library are supported.  
 * The most basic requirement is `TweenLite`.
 * 
 * To have access to this extension, please include `plugins/animation.gsap.js`.
 * @requires {@link http://greensock.com/gsap|GSAP ~1.14.x}
 * @mixin animation.GSAP
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['ScrollMagic', 'TweenMax', 'TimelineMax'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		// Loads whole gsap package onto global scope.
		require('gsap');
		factory(require('scrollmagic'), TweenMax, TimelineMax);
	} else {
		// Browser globals
		factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic, root.TweenMax || root.TweenLite, root.TimelineMax || root.TimelineLite);
	}
})(this, function (ScrollMagic, Tween, Timeline) {
	"use strict";

	var NAMESPACE = "animation.gsap";

	var console = window.console || {},
	    err = Function.prototype.bind.call(console.error || console.log || function () {}, console);
	if (!ScrollMagic) {
		err("(" + NAMESPACE + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs.");
	}
	if (!Tween) {
		err("(" + NAMESPACE + ") -> ERROR: TweenLite or TweenMax could not be found. Please make sure GSAP is loaded before ScrollMagic or use an asynchronous loader like requirejs.");
	}

	/*
 	 * ----------------------------------------------------------------
 	 * Extensions for Scene
 	 * ----------------------------------------------------------------
 	 */
	/**
  * Every instance of ScrollMagic.Scene now accepts an additional option.  
  * See {@link ScrollMagic.Scene} for a complete list of the standard options.
  * @memberof! animation.GSAP#
  * @method new ScrollMagic.Scene(options)
  * @example
  * var scene = new ScrollMagic.Scene({tweenChanges: true});
  *
  * @param {object} [options] - Options for the Scene. The options can be updated at any time.
  * @param {boolean} [options.tweenChanges=false] - Tweens Animation to the progress target instead of setting it.  
  Does not affect animations where duration is `0`.
  */
	/**
  * **Get** or **Set** the tweenChanges option value.  
  * This only affects scenes with a duration. If `tweenChanges` is `true`, the progress update when scrolling will not be immediate, but instead the animation will smoothly animate to the target state.  
  * For a better understanding, try enabling and disabling this option in the [Scene Manipulation Example](../examples/basic/scene_manipulation.html).
  * @memberof! animation.GSAP#
  * @method Scene.tweenChanges
  * 
  * @example
  * // get the current tweenChanges option
  * var tweenChanges = scene.tweenChanges();
  *
  * // set new tweenChanges option
  * scene.tweenChanges(true);
  *
  * @fires {@link Scene.change}, when used as setter
  * @param {boolean} [newTweenChanges] - The new tweenChanges setting of the scene.
  * @returns {boolean} `get` -  Current tweenChanges option value.
  * @returns {Scene} `set` -  Parent object for chaining.
  */
	// add option (TODO: DOC (private for dev))
	ScrollMagic.Scene.addOption("tweenChanges", // name
	false, // default

	function (val) {
		// validation callback
		return !!val;
	});
	// extend scene
	ScrollMagic.Scene.extend(function () {
		var Scene = this,
		    _tween;

		var log = function () {
			if (Scene._log) {
				// not available, when main source minified
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
				Scene._log.apply(this, arguments);
			}
		};

		// set listeners
		Scene.on("progress.plugin_gsap", function () {
			updateTweenProgress();
		});
		Scene.on("destroy.plugin_gsap", function (e) {
			Scene.removeTween(e.reset);
		});

		/**
   * Update the tween progress to current position.
   * @private
   */
		var updateTweenProgress = function () {
			if (_tween) {
				var progress = Scene.progress(),
				    state = Scene.state();
				if (_tween.repeat && _tween.repeat() === -1) {
					// infinite loop, so not in relation to progress
					if (state === 'DURING' && _tween.paused()) {
						_tween.play();
					} else if (state !== 'DURING' && !_tween.paused()) {
						_tween.pause();
					}
				} else if (progress != _tween.progress()) {
					// do we even need to update the progress?
					// no infinite loop - so should we just play or go to a specific point in time?
					if (Scene.duration() === 0) {
						// play the animation
						if (progress > 0) {
							// play from 0 to 1
							_tween.play();
						} else {
							// play from 1 to 0
							_tween.reverse();
						}
					} else {
						// go to a specific point in time
						if (Scene.tweenChanges() && _tween.tweenTo) {
							// go smooth
							_tween.tweenTo(progress * _tween.duration());
						} else {
							// just hard set it
							_tween.progress(progress).pause();
						}
					}
				}
			}
		};

		/**
   * Add a tween to the scene.  
   * If you want to add multiple tweens, add them into a GSAP Timeline object and supply it instead (see example below).  
   * 
   * If the scene has a duration, the tween's duration will be projected to the scroll distance of the scene, meaning its progress will be synced to scrollbar movement.  
   * For a scene with a duration of `0`, the tween will be triggered when scrolling forward past the scene's trigger position and reversed, when scrolling back.  
   * To gain better understanding, check out the [Simple Tweening example](../examples/basic/simple_tweening.html).
   *
   * Instead of supplying a tween this method can also be used as a shorthand for `TweenMax.to()` (see example below).
   * @memberof! animation.GSAP#
   *
   * @example
   * // add a single tween directly
   * scene.setTween(TweenMax.to("obj"), 1, {x: 100});
   *
   * // add a single tween via variable
   * var tween = TweenMax.to("obj"), 1, {x: 100};
   * scene.setTween(tween);
   *
   * // add multiple tweens, wrapped in a timeline.
   * var timeline = new TimelineMax();
   * var tween1 = TweenMax.from("obj1", 1, {x: 100});
   * var tween2 = TweenMax.to("obj2", 1, {y: 100});
   * timeline
   *		.add(tween1)
   *		.add(tween2);
   * scene.addTween(timeline);
   *
   * // short hand to add a TweenMax.to() tween
   * scene.setTween("obj3", 0.5, {y: 100});
   *
   * // short hand to add a TweenMax.to() tween for 1 second
   * // this is useful, when the scene has a duration and the tween duration isn't important anyway
   * scene.setTween("obj3", {y: 100});
   *
   * @param {(object|string)} TweenObject - A TweenMax, TweenLite, TimelineMax or TimelineLite object that should be animated in the scene. Can also be a Dom Element or Selector, when using direct tween definition (see examples).
   * @param {(number|object)} duration - A duration for the tween, or tween parameters. If an object containing parameters are supplied, a default duration of 1 will be used.
   * @param {object} params - The parameters for the tween
   * @returns {Scene} Parent object for chaining.
   */
		Scene.setTween = function (TweenObject, duration, params) {
			var newTween;
			if (arguments.length > 1) {
				if (arguments.length < 3) {
					params = duration;
					duration = 1;
				}
				TweenObject = Tween.to(TweenObject, duration, params);
			}
			try {
				// wrap Tween into a Timeline Object if available to include delay and repeats in the duration and standardize methods.
				if (Timeline) {
					newTween = new Timeline({
						smoothChildTiming: true
					}).add(TweenObject);
				} else {
					newTween = TweenObject;
				}
				newTween.pause();
			} catch (e) {
				log(1, "ERROR calling method 'setTween()': Supplied argument is not a valid TweenObject");
				return Scene;
			}
			if (_tween) {
				// kill old tween?
				Scene.removeTween();
			}
			_tween = newTween;

			// some properties need to be transferred it to the wrapper, otherwise they would get lost.
			if (TweenObject.repeat && TweenObject.repeat() === -1) {
				// TweenMax or TimelineMax Object?
				_tween.repeat(-1);
				_tween.yoyo(TweenObject.yoyo());
			}
			// Some tween validations and debugging helpers
			if (Scene.tweenChanges() && !_tween.tweenTo) {
				log(2, "WARNING: tweenChanges will only work if the TimelineMax object is available for ScrollMagic.");
			}

			// check if there are position tweens defined for the trigger and warn about it :)
			if (_tween && Scene.controller() && Scene.triggerElement() && Scene.loglevel() >= 2) {
				// controller is needed to know scroll direction.
				var triggerTweens = Tween.getTweensOf(Scene.triggerElement()),
				    vertical = Scene.controller().info("vertical");
				triggerTweens.forEach(function (value, index) {
					var tweenvars = value.vars.css || value.vars,
					    condition = vertical ? tweenvars.top !== undefined || tweenvars.bottom !== undefined : tweenvars.left !== undefined || tweenvars.right !== undefined;
					if (condition) {
						log(2, "WARNING: Tweening the position of the trigger element affects the scene timing and should be avoided!");
						return false;
					}
				});
			}

			// warn about tween overwrites, when an element is tweened multiple times
			if (parseFloat(TweenLite.version) >= 1.14) {
				// onOverwrite only present since GSAP v1.14.0
				var list = _tween.getChildren ? _tween.getChildren(true, true, false) : [_tween],

				// get all nested tween objects
				newCallback = function () {
					log(2, "WARNING: tween was overwritten by another. To learn how to avoid this issue see here: https://github.com/janpaepke/ScrollMagic/wiki/WARNING:-tween-was-overwritten-by-another");
				};
				for (var i = 0, thisTween, oldCallback; i < list.length; i++) {
					/*jshint loopfunc: true */
					thisTween = list[i];
					if (oldCallback !== newCallback) {
						// if tweens is added more than once
						oldCallback = thisTween.vars.onOverwrite;
						thisTween.vars.onOverwrite = function () {
							if (oldCallback) {
								oldCallback.apply(this, arguments);
							}
							newCallback.apply(this, arguments);
						};
					}
				}
			}
			log(3, "added tween");

			updateTweenProgress();
			return Scene;
		};

		/**
   * Remove the tween from the scene.  
   * This will terminate the control of the Scene over the tween.
   *
   * Using the reset option you can decide if the tween should remain in the current state or be rewound to set the target elements back to the state they were in before the tween was added to the scene.
   * @memberof! animation.GSAP#
   *
   * @example
   * // remove the tween from the scene without resetting it
   * scene.removeTween();
   *
   * // remove the tween from the scene and reset it to initial position
   * scene.removeTween(true);
   *
   * @param {boolean} [reset=false] - If `true` the tween will be reset to its initial values.
   * @returns {Scene} Parent object for chaining.
   */
		Scene.removeTween = function (reset) {
			if (_tween) {
				if (reset) {
					_tween.progress(0).pause();
				}
				_tween.kill();
				_tween = undefined;
				log(3, "removed tween (reset: " + (reset ? "true" : "false") + ")");
			}
			return Scene;
		};
	});
});
'use strict';

/*! Lazy Load XT v1.0.5 2014-06-05
 * http://ressio.github.io/lazy-load-xt
 * (C) 2014 RESS.io
 * Licensed under MIT */

(function ($, window, document, undefined) {
    // options
    var lazyLoadXT = 'lazyLoadXT',
        dataLazied = 'lazied',
        load_error = 'load error',
        classLazyHidden = 'lazy-hidden',
        docElement = document.documentElement || document.body,

    //  force load all images in Opera Mini and some mobile browsers without scroll event or getBoundingClientRect()
    forceLoad = window.onscroll === undefined || !!window.operamini || !docElement.getBoundingClientRect,
        options = {
        autoInit: true, // auto initialize in $.ready
        selector: 'img[data-src]', // selector for lazyloading elements
        blankImage: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
        throttle: 99, // interval (ms) for changes check
        forceLoad: forceLoad, // force auto load all images

        loadEvent: 'pageshow', // check AJAX-loaded content in jQueryMobile
        updateEvent: 'load orientationchange resize scroll touchmove focus', // page-modified events
        forceEvent: '', // force loading of all elements

        //onstart: null,
        oninit: { removeClass: 'lazy' }, // init handler
        onshow: { addClass: classLazyHidden }, // start loading handler
        onload: { removeClass: classLazyHidden, addClass: 'lazy-loaded' }, // load success handler
        onerror: { removeClass: classLazyHidden }, // error handler
        //oncomplete: null, // complete handler

        //scrollContainer: undefined,
        checkDuplicates: true
    },
        elementOptions = {
        srcAttr: 'data-src',
        edgeX: 0,
        edgeY: 0,
        visibleOnly: true
    },
        $window = $(window),
        $isFunction = $.isFunction,
        $extend = $.extend,
        $data = $.data || function (el, name) {
        return $(el).data(name);
    },

    // $.contains is not included into DOMtastic, so implement it there
    $contains = $.contains || function (parent, el) {
        while (el = el.parentNode) {
            if (el === parent) {
                return true;
            }
        }
        return false;
    },
        elements = [],
        topLazy = 0,

    /*
     waitingMode=0 : no setTimeout
     waitingMode=1 : setTimeout, no deferred events
     waitingMode=2 : setTimeout, deferred events
     */
    waitingMode = 0;

    $[lazyLoadXT] = $extend(options, elementOptions, $[lazyLoadXT]);

    /**
     * Return options.prop if obj.prop is undefined, otherwise return obj.prop
     * @param {*} obj
     * @param {*} prop
     * @returns *
     */
    function getOrDef(obj, prop) {
        return obj[prop] === undefined ? options[prop] : obj[prop];
    }

    /**
     * @returns {number}
     */
    function scrollTop() {
        var scroll = window.pageYOffset;
        return scroll === undefined ? docElement.scrollTop : scroll;
    }

    /**
     * Add new elements to lazy-load list:
     * $(elements).lazyLoadXT() or $(window).lazyLoadXT()
     *
     * @param {object} [overrides] override global options
     */
    $.fn[lazyLoadXT] = function (overrides) {
        overrides = overrides || {};

        var blankImage = getOrDef(overrides, 'blankImage'),
            checkDuplicates = getOrDef(overrides, 'checkDuplicates'),
            scrollContainer = getOrDef(overrides, 'scrollContainer'),
            elementOptionsOverrides = {},
            prop;

        // empty overrides.scrollContainer is supported by both jQuery and Zepto
        $(scrollContainer).on('scroll', queueCheckLazyElements);

        for (prop in elementOptions) {
            elementOptionsOverrides[prop] = getOrDef(overrides, prop);
        }

        return this.each(function (index, el) {
            if (el === window) {
                $(options.selector).lazyLoadXT(overrides);
            } else {
                // prevent duplicates
                if (checkDuplicates && $data(el, dataLazied)) {
                    return;
                }

                var $el = $(el).data(dataLazied, 1);

                if (blankImage && el.tagName === 'IMG' && !el.src) {
                    el.src = blankImage;
                }

                // clone elementOptionsOverrides object
                $el[lazyLoadXT] = $extend({}, elementOptionsOverrides);

                triggerEvent('init', $el);

                elements.push($el);
            }
        });
    };

    /**
     * Process function/object event handler
     * @param {string} event suffix
     * @param {jQuery} $el
     */
    function triggerEvent(event, $el) {
        var handler = options['on' + event];
        if (handler) {
            if ($isFunction(handler)) {
                handler.call($el[0]);
            } else {
                if (handler.addClass) {
                    $el.addClass(handler.addClass);
                }
                if (handler.removeClass) {
                    $el.removeClass(handler.removeClass);
                }
            }
        }

        $el.trigger('lazy' + event, [$el]);

        // queue next check as images may be resized after loading of actual file
        queueCheckLazyElements();
    }

    /**
     * Trigger onload/onerror handler
     * @param {Event} e
     */
    function triggerLoadOrError(e) {
        triggerEvent(e.type, $(this).off(load_error, triggerLoadOrError));
    }

    /**
     * Load visible elements
     * @param {bool} [force] loading of all elements
     */
    function checkLazyElements(force) {
        if (!elements.length) {
            return;
        }

        force = force || options.forceLoad;

        topLazy = Infinity;

        var viewportTop = scrollTop(),
            viewportHeight = window.innerHeight || docElement.clientHeight,
            viewportWidth = window.innerWidth || docElement.clientWidth,
            i,
            length;

        for (i = 0, length = elements.length; i < length; i++) {
            var $el = elements[i],
                el = $el[0],
                objData = $el[lazyLoadXT],
                removeNode = false,
                visible = force,
                topEdge;

            // remove items that are not in DOM
            if (!$contains(docElement, el)) {
                removeNode = true;
            } else if (force || !objData.visibleOnly || el.offsetWidth || el.offsetHeight) {

                if (!visible) {
                    var elPos = el.getBoundingClientRect(),
                        edgeX = objData.edgeX,
                        edgeY = objData.edgeY;

                    topEdge = elPos.top + viewportTop - edgeY - viewportHeight;

                    visible = topEdge <= viewportTop && elPos.bottom > -edgeY && elPos.left <= viewportWidth + edgeX && elPos.right > -edgeX;
                }

                if (visible) {
                    triggerEvent('show', $el);

                    var srcAttr = objData.srcAttr,
                        src = $isFunction(srcAttr) ? srcAttr($el) : el.getAttribute(srcAttr);
                    if (src) {
                        $el.on(load_error, triggerLoadOrError);
                        el.src = src;
                    }

                    removeNode = true;
                } else {
                    if (topEdge < topLazy) {
                        topLazy = topEdge;
                    }
                }
            }

            if (removeNode) {
                elements.splice(i--, 1);
                length--;
            }
        }

        if (!length) {
            triggerEvent('complete', $(docElement));
        }
    }

    /**
     * Run check of lazy elements after timeout
     */
    function timeoutLazyElements() {
        if (waitingMode > 1) {
            waitingMode = 1;
            checkLazyElements();
            setTimeout(timeoutLazyElements, options.throttle);
        } else {
            waitingMode = 0;
        }
    }

    /**
     * Queue check of lazy elements because of event e
     * @param {Event} [e]
     */
    function queueCheckLazyElements(e) {
        if (!elements.length) {
            return;
        }

        // fast check for scroll event without new visible elements
        if (e && e.type === 'scroll' && e.currentTarget === window) {
            if (topLazy >= scrollTop()) {
                return;
            }
        }

        if (!waitingMode) {
            setTimeout(timeoutLazyElements, 0);
        }
        waitingMode = 2;
    }

    /**
     * Initialize list of hidden elements
     */
    function initLazyElements() {
        $window.lazyLoadXT();
    }

    /**
     * Loading of all elements
     */
    function forceLoadAll() {
        checkLazyElements(true);
    }

    /**
     * Initialization
     */
    $(document).ready(function () {
        triggerEvent('start', $window);

        $window.on(options.loadEvent, initLazyElements).on(options.updateEvent, queueCheckLazyElements).on(options.forceEvent, forceLoadAll);

        $(document).on(options.updateEvent, queueCheckLazyElements);

        if (options.autoInit) {
            initLazyElements(); // standard initialization
        }
    });
})(window.jQuery || window.Zepto || window.$, window, document);
'use strict';

/*! Lazy Load XT v1.0.5 2014-06-05
 * http://ressio.github.io/lazy-load-xt
 * (C) 2014 RESS.io
 * Licensed under MIT */

(function ($) {
    var options = $.lazyLoadXT;

    options.forceEvent += ' lazyautoload';
    options.autoLoadTime = options.autoLoadTime || 50;

    $(document).ready(function () {
        setTimeout(function () {
            $(window).trigger('lazyautoload');
        }, options.autoLoadTime);
    });
})(window.jQuery || window.Zepto || window.$);
'use strict';

/*! Lazy Load XT v1.0.5 2014-06-05
 * http://ressio.github.io/lazy-load-xt
 * (C) 2014 RESS.io
 * Licensed under MIT */

(function ($) {
    var options = $.lazyLoadXT,
        bgAttr = options.bgAttr || 'data-bg';

    options.selector += ',[' + bgAttr + ']';

    $(document).on('lazyshow', function (e) {
        var $this = $(e.target);
        $this.css('background-image', "url('" + $this.attr(bgAttr) + "')").removeAttr(bgAttr);
    });
})(window.jQuery || window.Zepto || window.$);
!function ($) {

  "use strict";

  var FOUNDATION_VERSION = '6.2.1';

  // Global Foundation object
  // This is attached to the window, or used as a module for AMD/Browserify
  var Foundation = {
    version: FOUNDATION_VERSION,

    /**
     * Stores initialized plugins.
     */
    _plugins: {},

    /**
     * Stores generated unique ids for plugin instances
     */
    _uuids: [],

    /**
     * Returns a boolean for RTL support
     */
    rtl: function () {
      return $('html').attr('dir') === 'rtl';
    },
    /**
     * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.
     * @param {Object} plugin - The constructor of the plugin.
     */
    plugin: function (plugin, name) {
      // Object key to use when adding to global Foundation object
      // Examples: Foundation.Reveal, Foundation.OffCanvas
      var className = name || functionName(plugin);
      // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin
      // Examples: data-reveal, data-off-canvas
      var attrName = hyphenate(className);

      // Add to the Foundation object and the plugins list (for reflowing)
      this._plugins[attrName] = this[className] = plugin;
    },
    /**
     * @function
     * Populates the _uuids array with pointers to each individual plugin instance.
     * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.
     * Also fires the initialization event for each plugin, consolidating repeditive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @param {String} name - the name of the plugin, passed as a camelCased string.
     * @fires Plugin#init
     */
    registerPlugin: function (plugin, name) {
      var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();
      plugin.uuid = this.GetYoDigits(6, pluginName);

      if (!plugin.$element.attr('data-' + pluginName)) {
        plugin.$element.attr('data-' + pluginName, plugin.uuid);
      }
      if (!plugin.$element.data('zfPlugin')) {
        plugin.$element.data('zfPlugin', plugin);
      }
      /**
       * Fires when the plugin has initialized.
       * @event Plugin#init
       */
      plugin.$element.trigger('init.zf.' + pluginName);

      this._uuids.push(plugin.uuid);

      return;
    },
    /**
     * @function
     * Removes the plugins uuid from the _uuids array.
     * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.
     * Also fires the destroyed event for the plugin, consolidating repeditive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @fires Plugin#destroyed
     */
    unregisterPlugin: function (plugin) {
      var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));

      this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);
      plugin.$element.removeAttr('data-' + pluginName).removeData('zfPlugin')
      /**
       * Fires when the plugin has been destroyed.
       * @event Plugin#destroyed
       */
      .trigger('destroyed.zf.' + pluginName);
      for (var prop in plugin) {
        plugin[prop] = null; //clean up script to prep for garbage collection.
      }
      return;
    },

    /**
     * @function
     * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.
     * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`
     * @default If no argument is passed, reflow all currently active plugins.
     */
    reInit: function (plugins) {
      var isJQ = plugins instanceof $;
      try {
        if (isJQ) {
          plugins.each(function () {
            $(this).data('zfPlugin')._init();
          });
        } else {
          var type = typeof plugins,
              _this = this,
              fns = {
            'object': function (plgs) {
              plgs.forEach(function (p) {
                p = hyphenate(p);
                $('[data-' + p + ']').foundation('_init');
              });
            },
            'string': function () {
              plugins = hyphenate(plugins);
              $('[data-' + plugins + ']').foundation('_init');
            },
            'undefined': function () {
              this['object'](Object.keys(_this._plugins));
            }
          };
          fns[type](plugins);
        }
      } catch (err) {
        console.error(err);
      } finally {
        return plugins;
      }
    },

    /**
     * returns a random base-36 uid with namespacing
     * @function
     * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.
     * @param {String} namespace - name of plugin to be incorporated in uid, optional.
     * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.
     * @returns {String} - unique id
     */
    GetYoDigits: function (length, namespace) {
      length = length || 6;
      return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? '-' + namespace : '');
    },
    /**
     * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.
     * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.
     * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.
     */
    reflow: function (elem, plugins) {

      // If plugins is undefined, just grab everything
      if (typeof plugins === 'undefined') {
        plugins = Object.keys(this._plugins);
      }
      // If plugins is a string, convert it to an array with one item
      else if (typeof plugins === 'string') {
          plugins = [plugins];
        }

      var _this = this;

      // Iterate through each plugin
      $.each(plugins, function (i, name) {
        // Get the current plugin
        var plugin = _this._plugins[name];

        // Localize the search to all elements inside elem, as well as elem itself, unless elem === document
        var $elem = $(elem).find('[data-' + name + ']').addBack('[data-' + name + ']');

        // For each plugin found, initialize it
        $elem.each(function () {
          var $el = $(this),
              opts = {};
          // Don't double-dip on plugins
          if ($el.data('zfPlugin')) {
            console.warn("Tried to initialize " + name + " on an element that already has a Foundation plugin.");
            return;
          }

          if ($el.attr('data-options')) {
            var thing = $el.attr('data-options').split(';').forEach(function (e, i) {
              var opt = e.split(':').map(function (el) {
                return el.trim();
              });
              if (opt[0]) opts[opt[0]] = parseValue(opt[1]);
            });
          }
          try {
            $el.data('zfPlugin', new plugin($(this), opts));
          } catch (er) {
            console.error(er);
          } finally {
            return;
          }
        });
      });
    },
    getFnName: functionName,
    transitionend: function ($elem) {
      var transitions = {
        'transition': 'transitionend',
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'otransitionend'
      };
      var elem = document.createElement('div'),
          end;

      for (var t in transitions) {
        if (typeof elem.style[t] !== 'undefined') {
          end = transitions[t];
        }
      }
      if (end) {
        return end;
      } else {
        end = setTimeout(function () {
          $elem.triggerHandler('transitionend', [$elem]);
        }, 1);
        return 'transitionend';
      }
    }
  };

  Foundation.util = {
    /**
     * Function for applying a debounce effect to a function call.
     * @function
     * @param {Function} func - Function to be called at end of timeout.
     * @param {Number} delay - Time in ms to delay the call of `func`.
     * @returns function
     */
    throttle: function (func, delay) {
      var timer = null;

      return function () {
        var context = this,
            args = arguments;

        if (timer === null) {
          timer = setTimeout(function () {
            func.apply(context, args);
            timer = null;
          }, delay);
        }
      };
    }
  };

  // TODO: consider not making this a jQuery function
  // TODO: need way to reflow vs. re-initialize
  /**
   * The Foundation jQuery method.
   * @param {String|Array} method - An action to perform on the current jQuery object.
   */
  var foundation = function (method) {
    var type = typeof method,
        $meta = $('meta.foundation-mq'),
        $noJS = $('.no-js');

    if (!$meta.length) {
      $('<meta class="foundation-mq">').appendTo(document.head);
    }
    if ($noJS.length) {
      $noJS.removeClass('no-js');
    }

    if (type === 'undefined') {
      //needs to initialize the Foundation object, or an individual plugin.
      Foundation.MediaQuery._init();
      Foundation.reflow(this);
    } else if (type === 'string') {
      //an individual method to invoke on a plugin or group of plugins
      var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary
      var plugClass = this.data('zfPlugin'); //determine the class of plugin

      if (plugClass !== undefined && plugClass[method] !== undefined) {
        //make sure both the class and method exist
        if (this.length === 1) {
          //if there's only one, call it directly.
          plugClass[method].apply(plugClass, args);
        } else {
          this.each(function (i, el) {
            //otherwise loop through the jQuery collection and invoke the method on each
            plugClass[method].apply($(el).data('zfPlugin'), args);
          });
        }
      } else {
        //error for no class or no method
        throw new ReferenceError("We're sorry, '" + method + "' is not an available method for " + (plugClass ? functionName(plugClass) : 'this element') + '.');
      }
    } else {
      //error for invalid argument type
      throw new TypeError('We\'re sorry, ' + type + ' is not a valid parameter. You must use a string representing the method you wish to invoke.');
    }
    return this;
  };

  window.Foundation = Foundation;
  $.fn.foundation = foundation;

  // Polyfill for requestAnimationFrame
  (function () {
    if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {
      return new Date().getTime();
    };

    var vendors = ['webkit', 'moz'];
    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
      var vp = vendors[i];
      window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
    }
    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
      var lastTime = 0;
      window.requestAnimationFrame = function (callback) {
        var now = Date.now();
        var nextTime = Math.max(lastTime + 16, now);
        return setTimeout(function () {
          callback(lastTime = nextTime);
        }, nextTime - now);
      };
      window.cancelAnimationFrame = clearTimeout;
    }
    /**
     * Polyfill for performance.now, required by rAF
     */
    if (!window.performance || !window.performance.now) {
      window.performance = {
        start: Date.now(),
        now: function () {
          return Date.now() - this.start;
        }
      };
    }
  })();
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
      if (typeof this !== 'function') {
        // closest thing possible to the ECMAScript 5
        // internal IsCallable function
        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
      }

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
      };

      if (this.prototype) {
        // native functions don't have a prototype
        fNOP.prototype = this.prototype;
      }
      fBound.prototype = new fNOP();

      return fBound;
    };
  }
  // Polyfill to get the name of a function in IE9
  function functionName(fn) {
    if (Function.prototype.name === undefined) {
      var funcNameRegex = /function\s([^(]{1,})\(/;
      var results = funcNameRegex.exec(fn.toString());
      return results && results.length > 1 ? results[1].trim() : "";
    } else if (fn.prototype === undefined) {
      return fn.constructor.name;
    } else {
      return fn.prototype.constructor.name;
    }
  }
  function parseValue(str) {
    if (/true/.test(str)) return true;else if (/false/.test(str)) return false;else if (!isNaN(str * 1)) return parseFloat(str);
    return str;
  }
  // Convert PascalCase to kebab-case
  // Thank you: http://stackoverflow.com/a/8955580
  function hyphenate(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }
}(jQuery);
'use strict';

!function ($) {

  Foundation.Box = {
    ImNotTouchingYou: ImNotTouchingYou,
    GetDimensions: GetDimensions,
    GetOffsets: GetOffsets
  };

  /**
   * Compares the dimensions of an element to a container and determines collision events with container.
   * @function
   * @param {jQuery} element - jQuery object to test for collisions.
   * @param {jQuery} parent - jQuery object to use as bounding container.
   * @param {Boolean} lrOnly - set to true to check left and right values only.
   * @param {Boolean} tbOnly - set to true to check top and bottom values only.
   * @default if no parent object passed, detects collisions with `window`.
   * @returns {Boolean} - true if collision free, false if a collision in any direction.
   */
  function ImNotTouchingYou(element, parent, lrOnly, tbOnly) {
    var eleDims = GetDimensions(element),
        top,
        bottom,
        left,
        right;

    if (parent) {
      var parDims = GetDimensions(parent);

      bottom = eleDims.offset.top + eleDims.height <= parDims.height + parDims.offset.top;
      top = eleDims.offset.top >= parDims.offset.top;
      left = eleDims.offset.left >= parDims.offset.left;
      right = eleDims.offset.left + eleDims.width <= parDims.width;
    } else {
      bottom = eleDims.offset.top + eleDims.height <= eleDims.windowDims.height + eleDims.windowDims.offset.top;
      top = eleDims.offset.top >= eleDims.windowDims.offset.top;
      left = eleDims.offset.left >= eleDims.windowDims.offset.left;
      right = eleDims.offset.left + eleDims.width <= eleDims.windowDims.width;
    }

    var allDirs = [bottom, top, left, right];

    if (lrOnly) {
      return left === right === true;
    }

    if (tbOnly) {
      return top === bottom === true;
    }

    return allDirs.indexOf(false) === -1;
  };

  /**
   * Uses native methods to return an object of dimension values.
   * @function
   * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.
   * @returns {Object} - nested object of integer pixel values
   * TODO - if element is window, return only those values.
   */
  function GetDimensions(elem, test) {
    elem = elem.length ? elem[0] : elem;

    if (elem === window || elem === document) {
      throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");
    }

    var rect = elem.getBoundingClientRect(),
        parRect = elem.parentNode.getBoundingClientRect(),
        winRect = document.body.getBoundingClientRect(),
        winY = window.pageYOffset,
        winX = window.pageXOffset;

    return {
      width: rect.width,
      height: rect.height,
      offset: {
        top: rect.top + winY,
        left: rect.left + winX
      },
      parentDims: {
        width: parRect.width,
        height: parRect.height,
        offset: {
          top: parRect.top + winY,
          left: parRect.left + winX
        }
      },
      windowDims: {
        width: winRect.width,
        height: winRect.height,
        offset: {
          top: winY,
          left: winX
        }
      }
    };
  }

  /**
   * Returns an object of top and left integer pixel values for dynamically rendered elements,
   * such as: Tooltip, Reveal, and Dropdown
   * @function
   * @param {jQuery} element - jQuery object for the element being positioned.
   * @param {jQuery} anchor - jQuery object for the element's anchor point.
   * @param {String} position - a string relating to the desired position of the element, relative to it's anchor
   * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.
   * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.
   * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.
   * TODO alter/rewrite to work with `em` values as well/instead of pixels
   */
  function GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {
    var $eleDims = GetDimensions(element),
        $anchorDims = anchor ? GetDimensions(anchor) : null;

    switch (position) {
      case 'top':
        return {
          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top
        };
        break;
      case 'right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset,
          top: $anchorDims.offset.top
        };
        break;
      case 'center top':
        return {
          left: $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'center bottom':
        return {
          left: isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
        break;
      case 'center left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'center right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset + 1,
          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'center':
        return {
          left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2,
          top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'reveal':
        return {
          left: ($eleDims.windowDims.width - $eleDims.width) / 2,
          top: $eleDims.windowDims.offset.top + vOffset
        };
      case 'reveal full':
        return {
          left: $eleDims.windowDims.offset.left,
          top: $eleDims.windowDims.offset.top
        };
        break;
      case 'left bottom':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top + $anchorDims.height
        };
        break;
      case 'right bottom':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset - $eleDims.width,
          top: $anchorDims.offset.top + $anchorDims.height
        };
        break;
      default:
        return {
          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
    }
  }
}(jQuery);
/*******************************************
 *                                         *
 * This util was created by Marius Olbertz *
 * Please thank Marius on GitHub /owlbertz *
 * or the web http://www.mariusolbertz.de/ *
 *                                         *
 ******************************************/

'use strict';

!function ($) {

  var keyCodes = {
    9: 'TAB',
    13: 'ENTER',
    27: 'ESCAPE',
    32: 'SPACE',
    37: 'ARROW_LEFT',
    38: 'ARROW_UP',
    39: 'ARROW_RIGHT',
    40: 'ARROW_DOWN'
  };

  var commands = {};

  var Keyboard = {
    keys: getKeyCodes(keyCodes),

    /**
     * Parses the (keyboard) event and returns a String that represents its key
     * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
     * @param {Event} event - the event generated by the event handler
     * @return String key - String that represents the key pressed
     */
    parseKey: function (event) {
      var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();
      if (event.shiftKey) key = 'SHIFT_' + key;
      if (event.ctrlKey) key = 'CTRL_' + key;
      if (event.altKey) key = 'ALT_' + key;
      return key;
    },


    /**
     * Handles the given (keyboard) event
     * @param {Event} event - the event generated by the event handler
     * @param {String} component - Foundation component's name, e.g. Slider or Reveal
     * @param {Objects} functions - collection of functions that are to be executed
     */
    handleKey: function (event, component, functions) {
      var commandList = commands[component],
          keyCode = this.parseKey(event),
          cmds,
          command,
          fn;

      if (!commandList) return console.warn('Component not defined!');

      if (typeof commandList.ltr === 'undefined') {
        // this component does not differentiate between ltr and rtl
        cmds = commandList; // use plain list
      } else {
          // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa
          if (Foundation.rtl()) cmds = $.extend({}, commandList.ltr, commandList.rtl);else cmds = $.extend({}, commandList.rtl, commandList.ltr);
        }
      command = cmds[keyCode];

      fn = functions[command];
      if (fn && typeof fn === 'function') {
        // execute function  if exists
        fn.apply();
        if (functions.handled || typeof functions.handled === 'function') {
          // execute function when event was handled
          functions.handled.apply();
        }
      } else {
        if (functions.unhandled || typeof functions.unhandled === 'function') {
          // execute function when event was not handled
          functions.unhandled.apply();
        }
      }
    },


    /**
     * Finds all focusable elements within the given `$element`
     * @param {jQuery} $element - jQuery object to search within
     * @return {jQuery} $focusable - all focusable elements within `$element`
     */
    findFocusable: function ($element) {
      return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {
        if (!$(this).is(':visible') || $(this).attr('tabindex') < 0) {
          return false;
        } //only have visible elements and those that have a tabindex greater or equal 0
        return true;
      });
    },


    /**
     * Returns the component name name
     * @param {Object} component - Foundation component, e.g. Slider or Reveal
     * @return String componentName
     */

    register: function (componentName, cmds) {
      commands[componentName] = cmds;
    }
  };

  /*
   * Constants for easier comparing.
   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
   */
  function getKeyCodes(kcs) {
    var k = {};
    for (var kc in kcs) {
      k[kcs[kc]] = kcs[kc];
    }return k;
  }

  Foundation.Keyboard = Keyboard;
}(jQuery);
'use strict';

!function ($) {

  // Default set of media queries
  var defaultQueries = {
    'default': 'only screen',
    landscape: 'only screen and (orientation: landscape)',
    portrait: 'only screen and (orientation: portrait)',
    retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'
  };

  var MediaQuery = {
    queries: [],

    current: '',

    /**
     * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.
     * @function
     * @private
     */
    _init: function () {
      var self = this;
      var extractedStyles = $('.foundation-mq').css('font-family');
      var namedQueries;

      namedQueries = parseStyleToObject(extractedStyles);

      for (var key in namedQueries) {
        self.queries.push({
          name: key,
          value: 'only screen and (min-width: ' + namedQueries[key] + ')'
        });
      }

      this.current = this._getCurrentSize();

      this._watcher();
    },


    /**
     * Checks if the screen is at least as wide as a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to check.
     * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.
     */
    atLeast: function (size) {
      var query = this.get(size);

      if (query) {
        return window.matchMedia(query).matches;
      }

      return false;
    },


    /**
     * Gets the media query of a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to get.
     * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.
     */
    get: function (size) {
      for (var i in this.queries) {
        var query = this.queries[i];
        if (size === query.name) return query.value;
      }

      return null;
    },


    /**
     * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).
     * @function
     * @private
     * @returns {String} Name of the current breakpoint.
     */
    _getCurrentSize: function () {
      var matched;

      for (var i = 0; i < this.queries.length; i++) {
        var query = this.queries[i];

        if (window.matchMedia(query.value).matches) {
          matched = query;
        }
      }

      if (typeof matched === 'object') {
        return matched.name;
      } else {
        return matched;
      }
    },


    /**
     * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.
     * @function
     * @private
     */
    _watcher: function () {
      var _this = this;

      $(window).on('resize.zf.mediaquery', function () {
        var newSize = _this._getCurrentSize();

        if (newSize !== _this.current) {
          // Broadcast the media query change on the window
          $(window).trigger('changed.zf.mediaquery', [newSize, _this.current]);

          // Change the current media query
          _this.current = newSize;
        }
      });
    }
  };

  Foundation.MediaQuery = MediaQuery;

  // matchMedia() polyfill - Test a CSS media type/query in JS.
  // Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license
  window.matchMedia || (window.matchMedia = function () {
    'use strict';

    // For browsers that support matchMedium api such as IE 9 and webkit

    var styleMedia = window.styleMedia || window.media;

    // For those that don't support matchMedium
    if (!styleMedia) {
      var style = document.createElement('style'),
          script = document.getElementsByTagName('script')[0],
          info = null;

      style.type = 'text/css';
      style.id = 'matchmediajs-test';

      script.parentNode.insertBefore(style, script);

      // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
      info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;

      styleMedia = {
        matchMedium: function (media) {
          var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

          // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
          if (style.styleSheet) {
            style.styleSheet.cssText = text;
          } else {
            style.textContent = text;
          }

          // Test if media query is true or false
          return info.width === '1px';
        }
      };
    }

    return function (media) {
      return {
        matches: styleMedia.matchMedium(media || 'all'),
        media: media || 'all'
      };
    };
  }());

  // Thank you: https://github.com/sindresorhus/query-string
  function parseStyleToObject(str) {
    var styleObject = {};

    if (typeof str !== 'string') {
      return styleObject;
    }

    str = str.trim().slice(1, -1); // browsers re-quote string style values

    if (!str) {
      return styleObject;
    }

    styleObject = str.split('&').reduce(function (ret, param) {
      var parts = param.replace(/\+/g, ' ').split('=');
      var key = parts[0];
      var val = parts[1];
      key = decodeURIComponent(key);

      // missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
      val = val === undefined ? null : decodeURIComponent(val);

      if (!ret.hasOwnProperty(key)) {
        ret[key] = val;
      } else if (Array.isArray(ret[key])) {
        ret[key].push(val);
      } else {
        ret[key] = [ret[key], val];
      }
      return ret;
    }, {});

    return styleObject;
  }

  Foundation.MediaQuery = MediaQuery;
}(jQuery);
'use strict';

!function ($) {

  /**
   * Motion module.
   * @module foundation.motion
   */

  var initClasses = ['mui-enter', 'mui-leave'];
  var activeClasses = ['mui-enter-active', 'mui-leave-active'];

  var Motion = {
    animateIn: function (element, animation, cb) {
      animate(true, element, animation, cb);
    },

    animateOut: function (element, animation, cb) {
      animate(false, element, animation, cb);
    }
  };

  function Move(duration, elem, fn) {
    var anim,
        prog,
        start = null;
    // console.log('called');

    function move(ts) {
      if (!start) start = window.performance.now();
      // console.log(start, ts);
      prog = ts - start;
      fn.apply(elem);

      if (prog < duration) {
        anim = window.requestAnimationFrame(move, elem);
      } else {
        window.cancelAnimationFrame(anim);
        elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
      }
    }
    anim = window.requestAnimationFrame(move);
  }

  /**
   * Animates an element in or out using a CSS transition class.
   * @function
   * @private
   * @param {Boolean} isIn - Defines if the animation is in or out.
   * @param {Object} element - jQuery or HTML object to animate.
   * @param {String} animation - CSS class to use.
   * @param {Function} cb - Callback to run when animation is finished.
   */
  function animate(isIn, element, animation, cb) {
    element = $(element).eq(0);

    if (!element.length) return;

    var initClass = isIn ? initClasses[0] : initClasses[1];
    var activeClass = isIn ? activeClasses[0] : activeClasses[1];

    // Set up the animation
    reset();

    element.addClass(animation).css('transition', 'none');

    requestAnimationFrame(function () {
      element.addClass(initClass);
      if (isIn) element.show();
    });

    // Start the animation
    requestAnimationFrame(function () {
      element[0].offsetWidth;
      element.css('transition', '').addClass(activeClass);
    });

    // Clean up the animation when it finishes
    element.one(Foundation.transitionend(element), finish);

    // Hides the element (for out animations), resets the element, and runs a callback
    function finish() {
      if (!isIn) element.hide();
      reset();
      if (cb) cb.apply(element);
    }

    // Resets transitions and removes motion-specific classes
    function reset() {
      element[0].style.transitionDuration = 0;
      element.removeClass(initClass + ' ' + activeClass + ' ' + animation);
    }
  }

  Foundation.Move = Move;
  Foundation.Motion = Motion;
}(jQuery);
'use strict';

!function ($) {

  var Nest = {
    Feather: function (menu) {
      var type = arguments.length <= 1 || arguments[1] === undefined ? 'zf' : arguments[1];

      menu.attr('role', 'menubar');

      var items = menu.find('li').attr({ 'role': 'menuitem' }),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      menu.find('a:first').attr('tabindex', 0);

      items.each(function () {
        var $item = $(this),
            $sub = $item.children('ul');

        if ($sub.length) {
          $item.addClass(hasSubClass).attr({
            'aria-haspopup': true,
            'aria-expanded': false,
            'aria-label': $item.children('a:first').text()
          });

          $sub.addClass('submenu ' + subMenuClass).attr({
            'data-submenu': '',
            'aria-hidden': true,
            'role': 'menu'
          });
        }

        if ($item.parent('[data-submenu]').length) {
          $item.addClass('is-submenu-item ' + subItemClass);
        }
      });

      return;
    },
    Burn: function (menu, type) {
      var items = menu.find('li').removeAttr('tabindex'),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      menu.find('*').removeClass(subMenuClass + ' ' + subItemClass + ' ' + hasSubClass + ' is-submenu-item submenu is-active').removeAttr('data-submenu').css('display', '');

      // console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')
      //           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')
      //           .removeAttr('data-submenu'));
      // items.each(function(){
      //   var $item = $(this),
      //       $sub = $item.children('ul');
      //   if($item.parent('[data-submenu]').length){
      //     $item.removeClass('is-submenu-item ' + subItemClass);
      //   }
      //   if($sub.length){
      //     $item.removeClass('has-submenu');
      //     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');
      //   }
      // });
    }
  };

  Foundation.Nest = Nest;
}(jQuery);
'use strict';

!function ($) {

  function Timer(elem, options, cb) {
    var _this = this,
        duration = options.duration,
        //options is an object for easily adding features later.
    nameSpace = Object.keys(elem.data())[0] || 'timer',
        remain = -1,
        start,
        timer;

    this.isPaused = false;

    this.restart = function () {
      remain = -1;
      clearTimeout(timer);
      this.start();
    };

    this.start = function () {
      this.isPaused = false;
      // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      remain = remain <= 0 ? duration : remain;
      elem.data('paused', false);
      start = Date.now();
      timer = setTimeout(function () {
        if (options.infinite) {
          _this.restart(); //rerun the timer.
        }
        cb();
      }, remain);
      elem.trigger('timerstart.zf.' + nameSpace);
    };

    this.pause = function () {
      this.isPaused = true;
      //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      elem.data('paused', true);
      var end = Date.now();
      remain = remain - (end - start);
      elem.trigger('timerpaused.zf.' + nameSpace);
    };
  }

  /**
   * Runs a callback function when images are fully loaded.
   * @param {Object} images - Image(s) to check if loaded.
   * @param {Func} callback - Function to execute when image is fully loaded.
   */
  function onImagesLoaded(images, callback) {
    var self = this,
        unloaded = images.length;

    if (unloaded === 0) {
      callback();
    }

    images.each(function () {
      if (this.complete) {
        singleImageLoaded();
      } else if (typeof this.naturalWidth !== 'undefined' && this.naturalWidth > 0) {
        singleImageLoaded();
      } else {
        $(this).one('load', function () {
          singleImageLoaded();
        });
      }
    });

    function singleImageLoaded() {
      unloaded--;
      if (unloaded === 0) {
        callback();
      }
    }
  }

  Foundation.Timer = Timer;
  Foundation.onImagesLoaded = onImagesLoaded;
}(jQuery);
//**************************************************
//**Work inspired by multiple jquery swipe plugins**
//**Done by Yohai Ararat ***************************
//**************************************************
(function ($) {

	$.spotSwipe = {
		version: '1.0.0',
		enabled: 'ontouchstart' in document.documentElement,
		preventDefault: false,
		moveThreshold: 75,
		timeThreshold: 200
	};

	var startPosX,
	    startPosY,
	    startTime,
	    elapsedTime,
	    isMoving = false;

	function onTouchEnd() {
		//  alert(this);
		this.removeEventListener('touchmove', onTouchMove);
		this.removeEventListener('touchend', onTouchEnd);
		isMoving = false;
	}

	function onTouchMove(e) {
		if ($.spotSwipe.preventDefault) {
			e.preventDefault();
		}
		if (isMoving) {
			var x = e.touches[0].pageX;
			var y = e.touches[0].pageY;
			var dx = startPosX - x;
			var dy = startPosY - y;
			var dir;
			elapsedTime = new Date().getTime() - startTime;
			if (Math.abs(dx) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
				dir = dx > 0 ? 'left' : 'right';
			}
			// else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
			//   dir = dy > 0 ? 'down' : 'up';
			// }
			if (dir) {
				e.preventDefault();
				onTouchEnd.call(this);
				$(this).trigger('swipe', dir).trigger('swipe' + dir);
			}
		}
	}

	function onTouchStart(e) {
		if (e.touches.length == 1) {
			startPosX = e.touches[0].pageX;
			startPosY = e.touches[0].pageY;
			isMoving = true;
			startTime = new Date().getTime();
			this.addEventListener('touchmove', onTouchMove, false);
			this.addEventListener('touchend', onTouchEnd, false);
		}
	}

	function init() {
		this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);
	}

	function teardown() {
		this.removeEventListener('touchstart', onTouchStart);
	}

	$.event.special.swipe = { setup: init };

	$.each(['left', 'up', 'down', 'right'], function () {
		$.event.special['swipe' + this] = { setup: function () {
				$(this).on('swipe', $.noop);
			} };
	});
})(jQuery);
/****************************************************
 * Method for adding psuedo drag events to elements *
 ***************************************************/
!function ($) {
	$.fn.addTouch = function () {
		this.each(function (i, el) {
			$(el).bind('touchstart touchmove touchend touchcancel', function () {
				//we pass the original event object because the jQuery event
				//object is normalized to w3c specs and does not provide the TouchList
				handleTouch(event);
			});
		});

		var handleTouch = function (event) {
			var touches = event.changedTouches,
			    first = touches[0],
			    eventTypes = {
				touchstart: 'mousedown',
				touchmove: 'mousemove',
				touchend: 'mouseup'
			},
			    type = eventTypes[event.type],
			    simulatedEvent;

			if ('MouseEvent' in window && typeof window.MouseEvent === 'function') {
				simulatedEvent = window.MouseEvent(type, {
					'bubbles': true,
					'cancelable': true,
					'screenX': first.screenX,
					'screenY': first.screenY,
					'clientX': first.clientX,
					'clientY': first.clientY
				});
			} else {
				simulatedEvent = document.createEvent('MouseEvent');
				simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0 /*left*/, null);
			}
			first.target.dispatchEvent(simulatedEvent);
		};
	};
}(jQuery);

//**********************************
//**From the jQuery Mobile Library**
//**need to recreate functionality**
//**and try to improve if possible**
//**********************************

/* Removing the jQuery function ****
************************************

(function( $, window, undefined ) {

	var $document = $( document ),
		// supportTouch = $.mobile.support.touch,
		touchStartEvent = 'touchstart'//supportTouch ? "touchstart" : "mousedown",
		touchStopEvent = 'touchend'//supportTouch ? "touchend" : "mouseup",
		touchMoveEvent = 'touchmove'//supportTouch ? "touchmove" : "mousemove";

	// setup new event shortcuts
	$.each( ( "touchstart touchmove touchend " +
		"swipe swipeleft swiperight" ).split( " " ), function( i, name ) {

		$.fn[ name ] = function( fn ) {
			return fn ? this.bind( name, fn ) : this.trigger( name );
		};

		// jQuery < 1.8
		if ( $.attrFn ) {
			$.attrFn[ name ] = true;
		}
	});

	function triggerCustomEvent( obj, eventType, event, bubble ) {
		var originalType = event.type;
		event.type = eventType;
		if ( bubble ) {
			$.event.trigger( event, undefined, obj );
		} else {
			$.event.dispatch.call( obj, event );
		}
		event.type = originalType;
	}

	// also handles taphold

	// Also handles swipeleft, swiperight
	$.event.special.swipe = {

		// More than this horizontal displacement, and we will suppress scrolling.
		scrollSupressionThreshold: 30,

		// More time than this, and it isn't a swipe.
		durationThreshold: 1000,

		// Swipe horizontal displacement must be more than this.
		horizontalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		// Swipe vertical displacement must be less than this.
		verticalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		getLocation: function ( event ) {
			var winPageX = window.pageXOffset,
				winPageY = window.pageYOffset,
				x = event.clientX,
				y = event.clientY;

			if ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||
				event.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {

				// iOS4 clientX/clientY have the value that should have been
				// in pageX/pageY. While pageX/page/ have the value 0
				x = x - winPageX;
				y = y - winPageY;
			} else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {

				// Some Android browsers have totally bogus values for clientX/Y
				// when scrolling/zooming a page. Detectable since clientX/clientY
				// should never be smaller than pageX/pageY minus page scroll
				x = event.pageX - winPageX;
				y = event.pageY - winPageY;
			}

			return {
				x: x,
				y: y
			};
		},

		start: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ],
						origin: $( event.target )
					};
		},

		stop: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ]
					};
		},

		handleSwipe: function( start, stop, thisObject, origTarget ) {
			if ( stop.time - start.time < $.event.special.swipe.durationThreshold &&
				Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&
				Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {
				var direction = start.coords[0] > stop.coords[ 0 ] ? "swipeleft" : "swiperight";

				triggerCustomEvent( thisObject, "swipe", $.Event( "swipe", { target: origTarget, swipestart: start, swipestop: stop }), true );
				triggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );
				return true;
			}
			return false;

		},

		// This serves as a flag to ensure that at most one swipe event event is
		// in work at any given time
		eventInProgress: false,

		setup: function() {
			var events,
				thisObject = this,
				$this = $( thisObject ),
				context = {};

			// Retrieve the events data for this element and add the swipe context
			events = $.data( this, "mobile-events" );
			if ( !events ) {
				events = { length: 0 };
				$.data( this, "mobile-events", events );
			}
			events.length++;
			events.swipe = context;

			context.start = function( event ) {

				// Bail if we're already working on a swipe event
				if ( $.event.special.swipe.eventInProgress ) {
					return;
				}
				$.event.special.swipe.eventInProgress = true;

				var stop,
					start = $.event.special.swipe.start( event ),
					origTarget = event.target,
					emitted = false;

				context.move = function( event ) {
					if ( !start || event.isDefaultPrevented() ) {
						return;
					}

					stop = $.event.special.swipe.stop( event );
					if ( !emitted ) {
						emitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );
						if ( emitted ) {

							// Reset the context to make way for the next swipe event
							$.event.special.swipe.eventInProgress = false;
						}
					}
					// prevent scrolling
					if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {
						event.preventDefault();
					}
				};

				context.stop = function() {
						emitted = true;

						// Reset the context to make way for the next swipe event
						$.event.special.swipe.eventInProgress = false;
						$document.off( touchMoveEvent, context.move );
						context.move = null;
				};

				$document.on( touchMoveEvent, context.move )
					.one( touchStopEvent, context.stop );
			};
			$this.on( touchStartEvent, context.start );
		},

		teardown: function() {
			var events, context;

			events = $.data( this, "mobile-events" );
			if ( events ) {
				context = events.swipe;
				delete events.swipe;
				events.length--;
				if ( events.length === 0 ) {
					$.removeData( this, "mobile-events" );
				}
			}

			if ( context ) {
				if ( context.start ) {
					$( this ).off( touchStartEvent, context.start );
				}
				if ( context.move ) {
					$document.off( touchMoveEvent, context.move );
				}
				if ( context.stop ) {
					$document.off( touchStopEvent, context.stop );
				}
			}
		}
	};
	$.each({
		swipeleft: "swipe.left",
		swiperight: "swipe.right"
	}, function( event, sourceEvent ) {

		$.event.special[ event ] = {
			setup: function() {
				$( this ).bind( sourceEvent, $.noop );
			},
			teardown: function() {
				$( this ).unbind( sourceEvent );
			}
		};
	});
})( jQuery, this );
*/
'use strict';

!function ($) {

  var MutationObserver = function () {
    var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
    for (var i = 0; i < prefixes.length; i++) {
      if (prefixes[i] + 'MutationObserver' in window) {
        return window[prefixes[i] + 'MutationObserver'];
      }
    }
    return false;
  }();

  var triggers = function (el, type) {
    el.data(type).split(' ').forEach(function (id) {
      $('#' + id)[type === 'close' ? 'trigger' : 'triggerHandler'](type + '.zf.trigger', [el]);
    });
  };
  // Elements with [data-open] will reveal a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-open]', function () {
    triggers($(this), 'open');
  });

  // Elements with [data-close] will close a plugin that supports it when clicked.
  // If used without a value on [data-close], the event will bubble, allowing it to close a parent component.
  $(document).on('click.zf.trigger', '[data-close]', function () {
    var id = $(this).data('close');
    if (id) {
      triggers($(this), 'close');
    } else {
      $(this).trigger('close.zf.trigger');
    }
  });

  // Elements with [data-toggle] will toggle a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-toggle]', function () {
    triggers($(this), 'toggle');
  });

  // Elements with [data-closable] will respond to close.zf.trigger events.
  $(document).on('close.zf.trigger', '[data-closable]', function (e) {
    e.stopPropagation();
    var animation = $(this).data('closable');

    if (animation !== '') {
      Foundation.Motion.animateOut($(this), animation, function () {
        $(this).trigger('closed.zf');
      });
    } else {
      $(this).fadeOut().trigger('closed.zf');
    }
  });

  $(document).on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', function () {
    var id = $(this).data('toggle-focus');
    $('#' + id).triggerHandler('toggle.zf.trigger', [$(this)]);
  });

  /**
  * Fires once after all other scripts have loaded
  * @function
  * @private
  */
  $(window).load(function () {
    checkListeners();
  });

  function checkListeners() {
    eventsListener();
    resizeListener();
    scrollListener();
    closemeListener();
  }

  //******** only fires this function once on load, if there's something to watch ********
  function closemeListener(pluginName) {
    var yetiBoxes = $('[data-yeti-box]'),
        plugNames = ['dropdown', 'tooltip', 'reveal'];

    if (pluginName) {
      if (typeof pluginName === 'string') {
        plugNames.push(pluginName);
      } else if (typeof pluginName === 'object' && typeof pluginName[0] === 'string') {
        plugNames.concat(pluginName);
      } else {
        console.error('Plugin names must be strings');
      }
    }
    if (yetiBoxes.length) {
      var listeners = plugNames.map(function (name) {
        return 'closeme.zf.' + name;
      }).join(' ');

      $(window).off(listeners).on(listeners, function (e, pluginId) {
        var plugin = e.namespace.split('.')[0];
        var plugins = $('[data-' + plugin + ']').not('[data-yeti-box="' + pluginId + '"]');

        plugins.each(function () {
          var _this = $(this);

          _this.triggerHandler('close.zf.trigger', [_this]);
        });
      });
    }
  }

  function resizeListener(debounce) {
    var timer = void 0,
        $nodes = $('[data-resize]');
    if ($nodes.length) {
      $(window).off('resize.zf.trigger').on('resize.zf.trigger', function (e) {
        if (timer) {
          clearTimeout(timer);
        }

        timer = setTimeout(function () {

          if (!MutationObserver) {
            //fallback for IE 9
            $nodes.each(function () {
              $(this).triggerHandler('resizeme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a resize event
          $nodes.attr('data-events', "resize");
        }, debounce || 10); //default time to emit resize event
      });
    }
  }

  function scrollListener(debounce) {
    var timer = void 0,
        $nodes = $('[data-scroll]');
    if ($nodes.length) {
      $(window).off('scroll.zf.trigger').on('scroll.zf.trigger', function (e) {
        if (timer) {
          clearTimeout(timer);
        }

        timer = setTimeout(function () {

          if (!MutationObserver) {
            //fallback for IE 9
            $nodes.each(function () {
              $(this).triggerHandler('scrollme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a scroll event
          $nodes.attr('data-events', "scroll");
        }, debounce || 10); //default time to emit scroll event
      });
    }
  }

  function eventsListener() {
    if (!MutationObserver) {
      return false;
    }
    var nodes = document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');

    //element callback
    var listeningElementsMutation = function (mutationRecordsList) {
      var $target = $(mutationRecordsList[0].target);
      //trigger the event handler for the element depending on type
      switch ($target.attr("data-events")) {

        case "resize":
          $target.triggerHandler('resizeme.zf.trigger', [$target]);
          break;

        case "scroll":
          $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);
          break;

        // case "mutate" :
        // console.log('mutate', $target);
        // $target.triggerHandler('mutate.zf.trigger');
        //
        // //make sure we don't get stuck in an infinite loop from sloppy codeing
        // if ($target.index('[data-mutate]') == $("[data-mutate]").length-1) {
        //   domMutationObserver();
        // }
        // break;

        default:
          return false;
        //nothing
      }
    };

    if (nodes.length) {
      //for each element that needs to listen for resizing, scrolling, (or coming soon mutation) add a single observer
      for (var i = 0; i <= nodes.length - 1; i++) {
        var elementObserver = new MutationObserver(listeningElementsMutation);
        elementObserver.observe(nodes[i], { attributes: true, childList: false, characterData: false, subtree: false, attributeFilter: ["data-events"] });
      }
    }
  }

  // ------------------------------------

  // [PH]
  // Foundation.CheckWatchers = checkWatchers;
  Foundation.IHearYou = checkListeners;
  // Foundation.ISeeYou = scrollListener;
  // Foundation.IFeelYou = closemeListener;
}(jQuery);

// function domMutationObserver(debounce) {
//   // !!! This is coming soon and needs more work; not active  !!! //
//   var timer,
//   nodes = document.querySelectorAll('[data-mutate]');
//   //
//   if (nodes.length) {
//     // var MutationObserver = (function () {
//     //   var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
//     //   for (var i=0; i < prefixes.length; i++) {
//     //     if (prefixes[i] + 'MutationObserver' in window) {
//     //       return window[prefixes[i] + 'MutationObserver'];
//     //     }
//     //   }
//     //   return false;
//     // }());
//
//
//     //for the body, we need to listen for all changes effecting the style and class attributes
//     var bodyObserver = new MutationObserver(bodyMutation);
//     bodyObserver.observe(document.body, { attributes: true, childList: true, characterData: false, subtree:true, attributeFilter:["style", "class"]});
//
//
//     //body callback
//     function bodyMutation(mutate) {
//       //trigger all listening elements and signal a mutation event
//       if (timer) { clearTimeout(timer); }
//
//       timer = setTimeout(function() {
//         bodyObserver.disconnect();
//         $('[data-mutate]').attr('data-events',"mutate");
//       }, debounce || 150);
//     }
//   }
// }
'use strict';

// $(document).foundation();

$(document).ready(function () {
	Site.init();
});

var Site = {
	init: function () {
		if ($(window).width() > 640) {
			Site.scrollmagic();
		}
	},
	scrollmagic: function () {
		// init controller
		var controller = new ScrollMagic.Controller();
		var images = $('.parallax');
		var windowHeight = $(window).height();

		$.each(images, function (index, image) {
			// var tween = new TweenMax.fromTo(image, 1, { transform: 'translateY(12em)' }, { transform: 'translateY(-8em)' })
			var tween = new TweenMax.fromTo(image, 1, { transform: 'translateY(-4em)' }, { transform: 'translateY(12em)' });

			var scene = new ScrollMagic.Scene({
				duration: windowHeight * 2,
				triggerElement: image,
				triggerHook: 1
			}). // offset: 50*index
			// offset: 0
			setTween(tween).addTo(controller);
		});
	}
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5qcyIsIlR3ZWVuTWF4LmpzIiwiU2Nyb2xsTWFnaWMuanMiLCJhbmltYXRpb24uZ3NhcC5qcyIsImpxdWVyeS5sYXp5bG9hZHh0LmpzIiwianF1ZXJ5Lmxhenlsb2FkeHQuYXV0b2xvYWQuanMiLCJqcXVlcnkubGF6eWxvYWR4dC5iZy5qcyIsImZvdW5kYXRpb24uY29yZS5qcyIsImZvdW5kYXRpb24udXRpbC5ib3guanMiLCJmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanMiLCJmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qcyIsImZvdW5kYXRpb24udXRpbC5tb3Rpb24uanMiLCJmb3VuZGF0aW9uLnV0aWwubmVzdC5qcyIsImZvdW5kYXRpb24udXRpbC50aW1lckFuZEltYWdlTG9hZGVyLmpzIiwiZm91bmRhdGlvbi51dGlsLnRvdWNoLmpzIiwiZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzIiwiYXBwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQyxXQUFVLE1BQVYsRUFBa0IsT0FBbEIsRUFBNEI7O0FBRTVCLEtBQUssT0FBTyxNQUFQLEtBQWtCLFFBQWxCLElBQThCLE9BQU8sT0FBTyxPQUFkLEtBQTBCLFFBQTdELEVBQXdFOzs7Ozs7OztBQVF2RSxTQUFPLE9BQVAsR0FBaUIsT0FBTyxRQUFQLEdBQ2hCLFFBQVMsTUFBVCxFQUFpQixJQUFqQixDQURnQixHQUVoQixVQUFVLENBQVYsRUFBYztBQUNiLE9BQUssQ0FBQyxFQUFFLFFBQVIsRUFBbUI7QUFDbEIsVUFBTSxJQUFJLEtBQUosQ0FBVywwQ0FBWCxDQUFOO0FBQ0E7QUFDRCxVQUFPLFFBQVMsQ0FBVCxDQUFQO0FBQ0EsR0FQRjtBQVFBLEVBaEJELE1BZ0JPO0FBQ04sVUFBUyxNQUFUO0FBQ0E7OztBQUdELENBdkJBLEVBdUJDLE9BQU8sTUFBUCxLQUFrQixXQUFsQixHQUFnQyxNQUFoQyxHQUF5QyxJQXZCMUMsRUF1QmdELFVBQVUs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T0FBTSxZQUFXO0FBQ2hCLE1BQUssRUFBRSxNQUFGLEVBQVUsS0FBVixLQUFvQixHQUF6QixFQUErQjtBQUM5QixRQUFLLFdBQUw7QUFDQTtBQUNELEVBTFM7QUFNVixjQUFhLFlBQVc7O0FBRXZCLE1BQUksYUFBYSxJQUFJLFlBQVksVUFBaEIsRUFBakI7QUFDQSxNQUFJLFNBQVMsRUFBRSxXQUFGLENBQWI7QUFDQSxNQUFJLGVBQWUsRUFBRSxNQUFGLEVBQVUsTUFBVixFQUFuQjs7QUFFQSxJQUFFLElBQUYsQ0FBTyxNQUFQLEVBQWUsVUFBUyxLQUFULEVBQWdCLEtBQWhCLEVBQXNCOztBQUVwQyxPQUFJLFFBQVEsSUFBSSxTQUFTLE1BQWIsQ0FBb0IsS0FBcEIsRUFBMkIsQ0FBM0IsRUFBOEIsRUFBRSxXQUFXLGtCQUFiLEVBQTlCLEVBQWlFLEVBQUUsV0FBVyxrQkFBYixFQUFqRSxDQUFaOztBQUVBLE9BQUksUUFBUSxJQUFJLFlBQVksS0FBaEIsQ0FBc0I7QUFDaEMsY0FBVSxlQUFhLENBRFM7QUFFaEMsb0JBQWdCLEtBRmdCO0FBR2hDLGlCQUFhO0FBSG1CLElBQXRCOztBQU9WLFdBUFUsQ0FPQSxLQVBBLEVBUVYsS0FSVSxDQVFKLFVBUkksQ0FBWjtBQVNBLEdBYkQ7QUFjQTtBQTFCUyxDQUFYIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2Mi4yLjNcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wNC0wNVQxOToyNlpcbiAqL1xuXG4oZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDE4K1xuLy8gQ2FuJ3QgYmUgaW4gc3RyaWN0IG1vZGUsIHNldmVyYWwgbGlicyBpbmNsdWRpbmcgQVNQLk5FVCB0cmFjZVxuLy8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmXG4vLyB5b3UgdHJ5IHRvIHRyYWNlIHRocm91Z2ggXCJ1c2Ugc3RyaWN0XCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXG4vL1widXNlIHN0cmljdFwiO1xudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjIuMi4zXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFtcXGRhLXpdKS9naSxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvclxuXHRzZWxlY3RvcjogXCJcIixcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0cmV0dXJuIG51bSAhPSBudWxsID9cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOlxuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXHRcdHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQvLyBhZGRpbmcgMSBjb3JyZWN0cyBsb3NzIG9mIHByZWNpc2lvbiBmcm9tIHBhcnNlRmxvYXQgKCMxNTEwMClcblx0XHR2YXIgcmVhbFN0cmluZ09iaiA9IG9iaiAmJiBvYmoudG9TdHJpbmcoKTtcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0FycmF5KCBvYmogKSAmJiAoIHJlYWxTdHJpbmdPYmogLSBwYXJzZUZsb2F0KCByZWFsU3RyaW5nT2JqICkgKyAxICkgPj0gMDtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBrZXk7XG5cblx0XHQvLyBOb3QgcGxhaW4gb2JqZWN0czpcblx0XHQvLyAtIEFueSBvYmplY3Qgb3IgdmFsdWUgd2hvc2UgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIltvYmplY3QgT2JqZWN0XVwiXG5cdFx0Ly8gLSBET00gbm9kZXNcblx0XHQvLyAtIHdpbmRvd1xuXHRcdGlmICggalF1ZXJ5LnR5cGUoIG9iaiApICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3Rcblx0XHRpZiAoIG9iai5jb25zdHJ1Y3RvciAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwoIG9iaiwgXCJjb25zdHJ1Y3RvclwiICkgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmouY29uc3RydWN0b3IucHJvdG90eXBlIHx8IHt9LCBcImlzUHJvdG90eXBlT2ZcIiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuXHRcdC8vIGlmIGxhc3Qgb25lIGlzIG93biwgdGhlbiBhbGwgcHJvcGVydGllcyBhcmUgb3duXG5cdFx0Zm9yICgga2V5IGluIG9iaiApIHt9XG5cblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgfHwgaGFzT3duLmNhbGwoIG9iaiwga2V5ICk7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjAsIGlPUzw2IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdHZhciBzY3JpcHQsXG5cdFx0XHRpbmRpcmVjdCA9IGV2YWw7XG5cblx0XHRjb2RlID0galF1ZXJ5LnRyaW0oIGNvZGUgKTtcblxuXHRcdGlmICggY29kZSApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIGNvZGUgaW5jbHVkZXMgYSB2YWxpZCwgcHJvbG9ndWUgcG9zaXRpb25cblx0XHRcdC8vIHN0cmljdCBtb2RlIHByYWdtYSwgZXhlY3V0ZSBjb2RlIGJ5IGluamVjdGluZyBhXG5cdFx0XHQvLyBzY3JpcHQgdGFnIGludG8gdGhlIGRvY3VtZW50LlxuXHRcdFx0aWYgKCBjb2RlLmluZGV4T2YoIFwidXNlIHN0cmljdFwiICkgPT09IDEgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblx0XHRcdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBhdm9pZCB0aGUgRE9NIG5vZGUgY3JlYXRpb24sIGluc2VydGlvblxuXHRcdFx0XHQvLyBhbmQgcmVtb3ZhbCBieSB1c2luZyBhbiBpbmRpcmVjdCBnbG9iYWwgZXZhbFxuXG5cdFx0XHRcdGluZGlyZWN0KCBjb2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHQvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5cdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcblx0fSxcblxuXHRub2RlTmFtZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG4vLyBKU0hpbnQgd291bGQgZXJyb3Igb24gdGhpcyBjb2RlIGR1ZSB0byB0aGUgU3ltYm9sIG5vdCBiZWluZyBkZWZpbmVkIGluIEVTNS5cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5qc2hpbnRyYyB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGp1c3QgZGlzYWJsZSBKU0hpbnQgZm9yIHRoZXNlXG4vLyB0aHJlZSBsaW5lcy5cbi8qIGpzaGludCBpZ25vcmU6IHN0YXJ0ICovXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG4vKiBqc2hpbnQgaWdub3JlOiBlbmQgKi9cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IGlPUyA4LjIgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMi4xXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE1LTEwLTE3XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXG5cdE1BWF9ORUdBVElWRSA9IDEgPDwgMzEsXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHA6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblx0cmVzY2FwZSA9IC8nfFxcXFwvZyxcblxuXHQvLyBDU1MgZXNjYXBlcyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH07XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbmlkc2VsZWN0LCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHRuaWRzZWxlY3QgPSByaWRlbnRpZmllci50ZXN0KCBuaWQgKSA/IFwiI1wiICsgbmlkIDogXCJbaWQ9J1wiICsgbmlkICsgXCInXVwiO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gbmlkc2VsZWN0ICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBkaXYgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGRpdi5wYXJlbnROb2RlICkge1xuXHRcdFx0ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGRpdiA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHQoIH5iLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApIC1cblx0XHRcdCggfmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICk7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHBhcmVudCxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggKHBhcmVudCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBwYXJlbnQudG9wICE9PSBwYXJlbnQgKSB7XG5cdFx0Ly8gU3VwcG9ydDogSUUgMTFcblx0XHRpZiAoIHBhcmVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0cGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHBhcmVudC5hdHRhY2hFdmVudCApIHtcblx0XHRcdHBhcmVudC5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbmQgYW5kIGZpbHRlclxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIG0gPyBbIG0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIFN1cHBvcnQ6IElFNi83XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdGRlbGV0ZSBFeHByLmZpbmRbXCJJRFwiXTtcblxuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBkaXYsIFwiZGl2XCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBkaXYsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0XCJkaXNhYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGRpciA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBkaXIgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGRpciBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdHN1cHBvcnQuZ2V0QnlJZCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0XHRcdEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZGl2MSApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBkaXYxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0cmV0dXJuIGRpdi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbXFx3LV0rKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyApO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblxuXHR9XG5cblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblxuXHR9XG5cblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xuXHRcdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xuXHRcdH1cblxuXHRcdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMgKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdH0gKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSA/XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdIDpcblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0Ly8gTmVlZGVkIGJlY2F1c2UgJCggc2VsZWN0b3IsIGNvbnRleHQgKSBiZWNvbWVzICQoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldCApO1xuXHRcdHJldC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXCIgXCIgKyBzZWxlY3RvciA6IHNlbGVjdG9yO1xuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSopKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEJsYWNrYmVycnkgNC42XG5cdFx0XHRcdFx0Ly8gZ0VCSUQgcmV0dXJucyBub2RlcyBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICgjNjk2Mylcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSB0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3Iuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvci5zZWxlY3Rvcjtcblx0XHRcdHRoaXMuY29udGV4dCA9IHNlbGVjdG9yLmNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRwb3MgPSBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggcG9zID9cblx0XHRcdFx0XHRwb3MuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90d2hpdGUgPSAoIC9cXFMrL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgalF1ZXJ5LnR5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZVxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgXCJyZWplY3RlZFwiIF0sXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICkgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIGkgXSApICYmIGZuc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gZm9yIGZvcndhcmRpbmcgYWN0aW9ucyB0byBuZXdEZWZlclxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyA9PT0gcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0cHJvbWlzZS5waXBlID0gcHJvbWlzZS50aGVuO1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgMyBdO1xuXG5cdFx0XHQvLyBwcm9taXNlWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0Ly8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxuXHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cblx0XHRcdFx0Ly8gWyByZWplY3RfbGlzdCB8IHJlc29sdmVfbGlzdCBdLmRpc2FibGU7IHByb2dyZXNzX2xpc3QubG9ja1xuXHRcdFx0XHR9LCB0dXBsZXNbIGkgXiAxIF1bIDIgXS5kaXNhYmxlLCB0dXBsZXNbIDIgXVsgMiBdLmxvY2sgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVmZXJyZWRbIHJlc29sdmUgfCByZWplY3QgfCBub3RpZnkgXVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gcHJvbWlzZSA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHN1Ym9yZGluYXRlIC8qICwgLi4uLCBzdWJvcmRpbmF0ZU4gKi8gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0bGVuZ3RoID0gcmVzb2x2ZVZhbHVlcy5sZW5ndGgsXG5cblx0XHRcdC8vIHRoZSBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGxlbmd0aCAhPT0gMSB8fFxuXHRcdFx0XHQoIHN1Ym9yZGluYXRlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBzdWJvcmRpbmF0ZS5wcm9taXNlICkgKSA/IGxlbmd0aCA6IDAsXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWQuXG5cdFx0XHQvLyBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cblx0XHRcdGRlZmVycmVkID0gcmVtYWluaW5nID09PSAxID8gc3Vib3JkaW5hdGUgOiBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpLCBjb250ZXh0cywgdmFsdWVzICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdmFsdWVzID09PSBwcm9ncmVzc1ZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHRwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzO1xuXG5cdFx0Ly8gQWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxuXHRcdGlmICggbGVuZ3RoID4gMSApIHtcblx0XHRcdHByb2dyZXNzVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIHVwZGF0ZUZ1bmMoIGksIHByb2dyZXNzQ29udGV4dHMsIHByb2dyZXNzVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmRvbmUoIHVwZGF0ZUZ1bmMoIGksIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApIClcblx0XHRcdFx0XHRcdC5mYWlsKCBkZWZlcnJlZC5yZWplY3QgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQtLXJlbWFpbmluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcblx0XHRpZiAoICFyZW1haW5pbmcgKSB7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdDtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdC8vIEFkZCB0aGUgY2FsbGJhY2tcblx0alF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKCBmbiApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblxuXHRcdC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xuXHRcdGlmICggalF1ZXJ5LmZuLnRyaWdnZXJIYW5kbGVyICkge1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLnRyaWdnZXJIYW5kbGVyKCBcInJlYWR5XCIgKTtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS5vZmYoIFwicmVhZHlcIiApO1xuXHRcdH1cblx0fVxufSApO1xuXG4vKipcbiAqIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxualF1ZXJ5LnJlYWR5LnByb21pc2UgPSBmdW5jdGlvbiggb2JqICkge1xuXHRpZiAoICFyZWFkeUxpc3QgKSB7XG5cblx0XHRyZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxuXHRcdC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG5cdFx0Ly8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG5cdFx0Ly8gU3VwcG9ydDogSUU5LTEwIG9ubHlcblx0XHQvLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cblx0XHRpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHRcdFx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0XHRcdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdFx0XHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlYWR5TGlzdC5wcm9taXNlKCBvYmogKTtcbn07XG5cbi8vIEtpY2sgb2ZmIHRoZSBET00gcmVhZHkgY2hlY2sgZXZlbiBpZiB0aGUgdXNlciBkb2VzIG5vdFxualF1ZXJ5LnJlYWR5LnByb21pc2UoKTtcblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNoYWluYWJsZSA/XG5cdFx0ZWxlbXMgOlxuXG5cdFx0Ly8gR2V0c1xuXHRcdGJ1bGsgP1xuXHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0LyoganNoaW50IC1XMDE4ICovXG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRyZWdpc3RlcjogZnVuY3Rpb24oIG93bmVyLCBpbml0aWFsICkge1xuXHRcdHZhciB2YWx1ZSA9IGluaXRpYWwgfHwge307XG5cblx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSBwcm9wZXJ0eVxuXHRcdC8vIGNvbmZpZ3VyYWJpbGl0eSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0Ly8gZGVsZXRlZCB3aXRoIHRoZSBkZWxldGUgb3BlcmF0b3Jcblx0XHR9IGVsc2Uge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHR9LFxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRpZiAoICFhY2NlcHREYXRhKCBvd25lciApICkge1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGRhdGEgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgcHJvcCBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsga2V5IF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBzdG9yZWQ7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHN0b3JlZCA9IHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cblx0XHRcdHJldHVybiBzdG9yZWQgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHN0b3JlZCA6IHRoaXMuZ2V0KCBvd25lciwgalF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGNhbWVsLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMucmVnaXN0ZXIoIG93bmVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgXCJuYW1lXCIgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXCJrZXlcIiwgXCJ2YWxcIikgc2lnbmF0dXJlLFxuXHRcdFx0XHQvLyBrZXlzIHdpbGwgYmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZS5cblx0XHRcdFx0Ly8gU2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIHRlbGwgX2hvd18gYSBrZXkgd2FzIGFkZGVkLCByZW1vdmVcblx0XHRcdFx0Ly8gYm90aCBwbGFpbiBrZXkgYW5kIGNhbWVsQ2FzZSBrZXkuICMxMjc4NlxuXHRcdFx0XHQvLyBUaGlzIHdpbGwgb25seSBwZW5hbGl6ZSB0aGUgYXJyYXkgYXJndW1lbnQgcGF0aC5cblx0XHRcdFx0bmFtZSA9IGtleS5jb25jYXQoIGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FtZWwgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBUcnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuXHRcdFx0XHRpZiAoIGtleSBpbiBjYWNoZSApIHtcblx0XHRcdFx0XHRuYW1lID0gWyBrZXksIGNhbWVsIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRuYW1lID0gY2FtZWw7XG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFx0WyBuYW1lIF0gOiAoIG5hbWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aSA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBuYW1lWyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0gMzUtNDUrXG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwN1xuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cblx0XHRcdFx0XHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRcdFx0XHRcdCtkYXRhICsgXCJcIiA9PT0gZGF0YSA/ICtkYXRhIDpcblx0XHRcdFx0XHRyYnJhY2UudGVzdCggZGF0YSApID8galF1ZXJ5LnBhcnNlSlNPTiggZGF0YSApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTErXG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YSwgY2FtZWxLZXk7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBhcy1pc1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKSB8fFxuXG5cdFx0XHRcdFx0Ly8gVHJ5IHRvIGZpbmQgZGFzaGVkIGtleSBpZiBpdCBleGlzdHMgKGdoLTI3NzkpXG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBmb3IgMi4yLnggb25seVxuXHRcdFx0XHRcdGRhdGFVc2VyLmdldCggZWxlbSwga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpICk7XG5cblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGNhbWVsaXplZFxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBjYW1lbEtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBjYW1lbEtleSwgdW5kZWZpbmVkICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0Y2FtZWxLZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gRmlyc3QsIGF0dGVtcHQgdG8gc3RvcmUgYSBjb3B5IG9yIHJlZmVyZW5jZSBvZiBhbnlcblx0XHRcdFx0Ly8gZGF0YSB0aGF0IG1pZ2h0J3ZlIGJlZW4gc3RvcmUgd2l0aCBhIGNhbWVsQ2FzZWQga2V5LlxuXHRcdFx0XHR2YXIgZGF0YSA9IGRhdGFVc2VyLmdldCggdGhpcywgY2FtZWxLZXkgKTtcblxuXHRcdFx0XHQvLyBGb3IgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZSBpbnRlcm9wLCB3ZSBoYXZlIHRvXG5cdFx0XHRcdC8vIHN0b3JlIHByb3BlcnR5IG5hbWVzIHdpdGggZGFzaGVzIGluIGEgY2FtZWxDYXNlIGZvcm0uXG5cdFx0XHRcdC8vIFRoaXMgbWlnaHQgbm90IGFwcGx5IHRvIGFsbCBwcm9wZXJ0aWVzLi4uKlxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGNhbWVsS2V5LCB2YWx1ZSApO1xuXG5cdFx0XHRcdC8vICouLi4gSW4gdGhlIGNhc2Ugb2YgcHJvcGVydGllcyB0aGF0IG1pZ2h0IF9hY3R1YWxseV9cblx0XHRcdFx0Ly8gaGF2ZSBkYXNoZXMsIHdlIG5lZWQgdG8gYWxzbyBzdG9yZSBhIGNvcHkgb2YgdGhhdFxuXHRcdFx0XHQvLyB1bmNoYW5nZWQgcHJvcGVydHkuXG5cdFx0XHRcdGlmICgga2V5LmluZGV4T2YoIFwiLVwiICkgPiAtMSAmJiBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBqUXVlcnkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgaXNIaWRkZW4gPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbiBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0IWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsXG5cdFx0c2NhbGUgPSAxLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHR3ZWVuLmN1cigpOyB9IDpcblx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApOyB9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHRkbyB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqLlxuXHRcdFx0Ly8gVXNlIHN0cmluZyBmb3IgZG91Ymxpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcblx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHQvLyBBZGp1c3QgYW5kIGFwcGx5XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKClcblx0XHQvLyBCcmVhayB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoLlxuXHRcdH0gd2hpbGUgKFxuXHRcdFx0c2NhbGUgIT09ICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgKSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnNcblx0XHQpO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbXFx3Oi1dKykvICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFOVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQgPSB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHR0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdFx0Y29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRbXTtcblxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xuXHRcdGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApIDpcblx0XHRyZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjEsIFBoYW50b21KUzwyXG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAtNC4zLCBTYWZhcmk8PTUuMVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogU2FmYXJpPD01LjEsIEFuZHJvaWQ8NC4yXG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIG1hdGNoZXMsIHNlbCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIFN1cHBvcnQgKGF0IGxlYXN0KTogQ2hyb21lLCBJRTlcblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MClcblx0XHQvL1xuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8PTQyK1xuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGluIEZGIGJ1dCBkb24ndCBibG9jayBJRSByYWRpbyBldmVudHMgKCMzODYxLCBnaC0yMzQzKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiZcblx0XHRcdCggZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiIHx8IGlzTmFOKCBldmVudC5idXR0b24gKSB8fCBldmVudC5idXR0b24gPCAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgKCBjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogdGhpcywgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0Ly8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcblx0cHJvcHM6ICggXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBkZXRhaWwgZXZlbnRQaGFzZSBcIiArXG5cdFx0XCJtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIgKS5zcGxpdCggXCIgXCIgKSxcblxuXHRmaXhIb29rczoge30sXG5cblx0a2V5SG9va3M6IHtcblx0XHRwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoIFwiIFwiICksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdXNlSG9va3M6IHtcblx0XHRwcm9wczogKCBcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgXCIgK1xuXHRcdFx0XCJzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cdFx0XHR2YXIgZXZlbnREb2MsIGRvYywgYm9keSxcblx0XHRcdFx0YnV0dG9uID0gb3JpZ2luYWwuYnV0dG9uO1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlXG5cdFx0XHRpZiAoIGV2ZW50LnBhZ2VYID09IG51bGwgJiYgb3JpZ2luYWwuY2xpZW50WCAhPSBudWxsICkge1xuXHRcdFx0XHRldmVudERvYyA9IGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuXHRcdFx0XHRkb2MgPSBldmVudERvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRcdGJvZHkgPSBldmVudERvYy5ib2R5O1xuXG5cdFx0XHRcdGV2ZW50LnBhZ2VYID0gb3JpZ2luYWwuY2xpZW50WCArXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC1cblx0XHRcdFx0XHQoIGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwICk7XG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLnNjcm9sbFRvcCAgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCAgfHwgMCApIC1cblx0XHRcdFx0XHQoIGRvYyAmJiBkb2MuY2xpZW50VG9wICB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wICB8fCAwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRcdC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG5cdFx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGEgd3JpdGFibGUgY29weSBvZiB0aGUgZXZlbnQgb2JqZWN0IGFuZCBub3JtYWxpemUgc29tZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGksIHByb3AsIGNvcHksXG5cdFx0XHR0eXBlID0gZXZlbnQudHlwZSxcblx0XHRcdG9yaWdpbmFsRXZlbnQgPSBldmVudCxcblx0XHRcdGZpeEhvb2sgPSB0aGlzLmZpeEhvb2tzWyB0eXBlIF07XG5cblx0XHRpZiAoICFmaXhIb29rICkge1xuXHRcdFx0dGhpcy5maXhIb29rc1sgdHlwZSBdID0gZml4SG9vayA9XG5cdFx0XHRcdHJtb3VzZUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMubW91c2VIb29rcyA6XG5cdFx0XHRcdHJrZXlFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLmtleUhvb2tzIDpcblx0XHRcdFx0e307XG5cdFx0fVxuXHRcdGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XG5cblx0XHRldmVudCA9IG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblxuXHRcdGkgPSBjb3B5Lmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHByb3AgPSBjb3B5WyBpIF07XG5cdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ2luYWxFdmVudFsgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IENvcmRvdmEgMi41IChXZWJLaXQpICgjMTMyNTUpXG5cdFx0Ly8gQWxsIGV2ZW50cyBzaG91bGQgaGF2ZSBhIHRhcmdldDsgQ29yZG92YSBkZXZpY2VyZWFkeSBkb2Vzbid0XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDYuMCssIENocm9tZTwyOFxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0aWYgKCBldmVudC50YXJnZXQubm9kZVR5cGUgPT09IDMgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZml4SG9vay5maWx0ZXIgPyBmaXhIb29rLmZpbHRlciggZXZlbnQsIG9yaWdpbmFsRXZlbnQgKSA6IGV2ZW50O1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Oi1dKylbXj5dKilcXC8+L2dpLFxuXG5cdC8vIFN1cHBvcnQ6IElFIDEwLTExLCBFZGdlIDEwMjQwK1xuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIE1hbmlwdWxhdGluZyB0YWJsZXMgcmVxdWlyZXMgYSB0Ym9keVxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdGpRdWVyeS5ub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSA/XG5cblx0XHRlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInRib2R5XCIgKVsgMCBdIHx8XG5cdFx0XHRlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0Ym9keVwiICkgKSA6XG5cdFx0ZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjEsIFBoYW50b21KUzwyXG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHA6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PSAzNS00NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0gMzUtNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBLZWVwIGRvbU1hbmlwIGV4cG9zZWQgdW50aWwgMy4wIChnaC0yMjI1KVxuXHRkb21NYW5pcDogZG9tTWFuaXAsXG5cblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Ncblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xuXG5cbnZhciBpZnJhbWUsXG5cdGVsZW1kaXNwbGF5ID0ge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveFxuXHRcdC8vIFdlIGhhdmUgdG8gcHJlLWRlZmluZSB0aGVzZSB2YWx1ZXMgZm9yIEZGICgjMTAyMjcpXG5cdFx0SFRNTDogXCJibG9ja1wiLFxuXHRcdEJPRFk6IFwiYmxvY2tcIlxuXHR9O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhY3R1YWwgZGlzcGxheSBvZiBhIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdFxuICovXG5cbi8vIENhbGxlZCBvbmx5IGZyb20gd2l0aGluIGRlZmF1bHREaXNwbGF5XG5mdW5jdGlvbiBhY3R1YWxEaXNwbGF5KCBuYW1lLCBkb2MgKSB7XG5cdHZhciBlbGVtID0galF1ZXJ5KCBkb2MuY3JlYXRlRWxlbWVudCggbmFtZSApICkuYXBwZW5kVG8oIGRvYy5ib2R5ICksXG5cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbVsgMCBdLCBcImRpc3BsYXlcIiApO1xuXG5cdC8vIFdlIGRvbid0IGhhdmUgYW55IGRhdGEgc3RvcmVkIG9uIHRoZSBlbGVtZW50LFxuXHQvLyBzbyB1c2UgXCJkZXRhY2hcIiBtZXRob2QgYXMgZmFzdCB3YXkgdG8gZ2V0IHJpZCBvZiB0aGUgZWxlbWVudFxuXHRlbGVtLmRldGFjaCgpO1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG4vKipcbiAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkoIG5vZGVOYW1lICkge1xuXHR2YXIgZG9jID0gZG9jdW1lbnQsXG5cdFx0ZGlzcGxheSA9IGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdO1xuXG5cdGlmICggIWRpc3BsYXkgKSB7XG5cdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIWRpc3BsYXkgKSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgYWxyZWFkeS1jcmVhdGVkIGlmcmFtZSBpZiBwb3NzaWJsZVxuXHRcdFx0aWZyYW1lID0gKCBpZnJhbWUgfHwgalF1ZXJ5KCBcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cIiApIClcblx0XHRcdFx0LmFwcGVuZFRvKCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG5cblx0XHRcdC8vIEFsd2F5cyB3cml0ZSBhIG5ldyBIVE1MIHNrZWxldG9uIHNvIFdlYmtpdCBhbmQgRmlyZWZveCBkb24ndCBjaG9rZSBvbiByZXVzZVxuXHRcdFx0ZG9jID0gaWZyYW1lWyAwIF0uY29udGVudERvY3VtZW50O1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0ZG9jLndyaXRlKCk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblxuXHRcdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblx0XHRcdGlmcmFtZS5kZXRhY2goKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cdH1cblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cbnZhciBybWFyZ2luID0gKCAvXm1hcmdpbi8gKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw9MTErLCBGaXJlZm94PD0zMCsgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBwaXhlbE1hcmdpblJpZ2h0VmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG5cdFx0XCJwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwidG9wOjElO3dpZHRoOjUwJVwiO1xuXHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IGRpdlN0eWxlLm1hcmdpbkxlZnQgPT09IFwiMnB4XCI7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjUwJVwiO1xuXHRcdHBpeGVsTWFyZ2luUmlnaHRWYWwgPSBkaXZTdHlsZS5tYXJnaW5SaWdodCA9PT0gXCI0cHhcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdH1cblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFRoaXMgdGVzdCBpcyBleGVjdXRlZCBvbmx5IG9uY2UgYnV0IHdlIHN0aWxsIGRvIG1lbW9pemluZ1xuXHRcdFx0Ly8gc2luY2Ugd2UgY2FuIHVzZSB0aGUgYm94U2l6aW5nUmVsaWFibGUgcHJlLWNvbXB1dGluZy5cblx0XHRcdC8vIE5vIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHRlc3Qgd2FzIGFscmVhZHkgcGVyZm9ybWVkLCB0aG91Z2guXG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbE1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAtNC4zXG5cdFx0XHQvLyBXZSdyZSBjaGVja2luZyBmb3IgYm94U2l6aW5nUmVsaWFibGVWYWwgaGVyZSBpbnN0ZWFkIG9mIHBpeGVsTWFyZ2luUmlnaHRWYWxcblx0XHRcdC8vIHNpbmNlIHRoYXQgY29tcHJlc3NlcyBiZXR0ZXIgYW5kIHRoZXkncmUgY29tcHV0ZWQgdG9nZXRoZXIgYW55d2F5LlxuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBpeGVsTWFyZ2luUmlnaHRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggb25seSwgQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSAzN1xuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0Ly8gQ2hlY2sgaWYgZGl2IHdpdGggZXhwbGljaXQgd2lkdGggYW5kIG5vIG1hcmdpbi1yaWdodCBpbmNvcnJlY3RseVxuXHRcdFx0Ly8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXG5cdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdC8vIFRoaXMgc3VwcG9ydCBmdW5jdGlvbiBpcyBvbmx5IGV4ZWN1dGVkIG9uY2Ugc28gbm8gbWVtb2l6aW5nIGlzIG5lZWRlZC5cblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdG1hcmdpbkRpdiA9IGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdC8vIFJlc2V0IENTUzogYm94LXNpemluZzsgZGlzcGxheTsgbWFyZ2luOyBib3JkZXI7IHBhZGRpbmdcblx0XHRcdG1hcmdpbkRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2LnN0eWxlLmNzc1RleHQgPVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcblx0XHRcdFx0XCJkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MFwiO1xuXHRcdFx0bWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XG5cdFx0XHRkaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xuXHRcdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdFx0cmV0ID0gIXBhcnNlRmxvYXQoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBtYXJnaW5EaXYgKS5tYXJnaW5SaWdodCApO1xuXG5cdFx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHRcdFx0ZGl2LnJlbW92ZUNoaWxkKCBtYXJnaW5EaXYgKTtcblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cdHJldCA9IGNvbXB1dGVkID8gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF0gOiB1bmRlZmluZWQ7XG5cblx0Ly8gU3VwcG9ydDogT3BlcmEgMTIuMXggb25seVxuXHQvLyBGYWxsIGJhY2sgdG8gc3R5bGUgZXZlbiB3aXRob3V0IGNvbXB1dGVkXG5cdC8vIGNvbXB1dGVkIGlzIHVuZGVmaW5lZCBmb3IgZWxlbXMgb24gZG9jdW1lbnQgZnJhZ21lbnRzXG5cdGlmICggKCByZXQgPT09IFwiXCIgfHwgcmV0ID09PSB1bmRlZmluZWQgKSAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiT1wiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSA9IGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgP1xuXG5cdFx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdFx0NCA6XG5cblx0XHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG5cdFx0bmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cblx0XHR2YWwgPSAwO1xuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuXHR2YXIgdmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG5cdFx0dmFsID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0LFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBJRTExIG9ubHlcblx0Ly8gSW4gSUUgMTEgZnVsbHNjcmVlbiBlbGVtZW50cyBpbnNpZGUgb2YgYW4gaWZyYW1lIGhhdmVcblx0Ly8gMTAweCB0b28gc21hbGwgZGltZW5zaW9ucyAoZ2gtMTc2NCkuXG5cdGlmICggZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudCAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdGlmICggZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHZhbCA9IE1hdGgucm91bmQoIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbIG5hbWUgXSAqIDEwMCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHRcdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcblx0XHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cblx0XHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cdFx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblx0fVxuXG5cdC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cdHJldHVybiAoIHZhbCArXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0bmFtZSxcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXNcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sIGhpZGRlbixcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICk7XG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcblx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3Rcblx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuXHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcblx0XHRcdC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmFjY2Vzcyhcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFwib2xkZGlzcGxheVwiLFxuXHRcdFx0XHRcdGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlkZGVuID0gaXNIaWRkZW4oIGVsZW0gKTtcblxuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiB8fCAhaGlkZGVuICkge1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcIm9sZGRpc3BsYXlcIixcblx0XHRcdFx0XHRoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiBtb3N0IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXG5cdC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoICFzaG93IHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1sgaW5kZXggXSB8fCBcIlwiIDogXCJub25lXCI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdFwiZmxvYXRcIjogXCJjc3NGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblx0XHRcdFx0XHRlbGVtLm9mZnNldFdpZHRoID09PSAwID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luUmlnaHQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gc3dhcCggZWxlbSwgeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIiB9LFxuXHRcdFx0XHRjdXJDU1MsIFsgZWxlbSwgXCJtYXJnaW5SaWdodFwiIF0gKTtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbiggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgQ29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0IDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIHR3ZWVuLCBob29rcywgb2xkZmlyZSwgZGlzcGxheSwgY2hlY2tEaXNwbGF5LFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbiggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gSGFuZGxlIHF1ZXVlOiBmYWxzZSBwcm9taXNlc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBIZWlnaHQvd2lkdGggb3ZlcmZsb3cgcGFzc1xuXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcImhlaWdodFwiIGluIHByb3BzIHx8IFwid2lkdGhcIiBpbiBwcm9wcyApICkge1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRTktMTAgZG8gbm90XG5cdFx0Ly8gY2hhbmdlIHRoZSBvdmVyZmxvdyBhdHRyaWJ1dGUgd2hlbiBvdmVyZmxvd1ggYW5kXG5cdFx0Ly8gb3ZlcmZsb3dZIGFyZSBzZXQgdG8gdGhlIHNhbWUgdmFsdWVcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIFNldCBkaXNwbGF5IHByb3BlcnR5IHRvIGlubGluZS1ibG9jayBmb3IgaGVpZ2h0L3dpZHRoXG5cdFx0Ly8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXG5cdFx0Ly8gVGVzdCBkZWZhdWx0IGRpc3BsYXkgaWYgZGlzcGxheSBpcyBjdXJyZW50bHkgXCJub25lXCJcblx0XHRjaGVja0Rpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/XG5cdFx0XHRkYXRhUHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICkgfHwgZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXk7XG5cblx0XHRpZiAoIGNoZWNrRGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIHNob3cvaGlkZSBwYXNzXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMuZXhlYyggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvd1xuXHRcdFx0XHQvLyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW5cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cblx0XHQvLyBBbnkgbm9uLWZ4IHZhbHVlIHN0b3BzIHVzIGZyb20gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpc3BsYXkgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7fSApO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHN0YXRlIGlmIGl0cyB0b2dnbGUgLSBlbmFibGVzIC5zdG9wKCkudG9nZ2xlKCkgdG8gXCJyZXZlcnNlXCJcblx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0fVxuXHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0alF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5oaWRlKCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcDtcblxuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdHR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cblx0XHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRcdHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRcdHR3ZWVuLnN0YXJ0ID0gcHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHQvLyBJZiB0aGlzIGlzIGEgbm9vcCBsaWtlIC5oaWRlKCkuaGlkZSgpLCByZXN0b3JlIGFuIG92ZXJ3cml0dGVuIGRpc3BsYXkgdmFsdWVcblx0fSBlbHNlIGlmICggKCBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5ICkgPT09IFwiaW5saW5lXCIgKSB7XG5cdFx0c3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdGpRdWVyeS5wcm94eSggcmVzdWx0LnN0b3AsIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3R3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZngub2ZmID8gMCA6IHR5cGVvZiBvcHQuZHVyYXRpb24gPT09IFwibnVtYmVyXCIgP1xuXHRcdG9wdC5kdXJhdGlvbiA6IG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID9cblx0XHRcdGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGlmICggdGltZXIoKSApIHtcblx0XHRqUXVlcnkuZnguc3RhcnQoKTtcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkudGltZXJzLnBvcCgpO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0d2luZG93LmNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTtcblxuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogaU9TPD01LjEsIEFuZHJvaWQ8PTQuMitcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPD0yLjNcblx0Ly8gT3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmUgaW5jb3JyZWN0bHkgbWFya2VkIGFzIGRpc2FibGVkXG5cdHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG5cdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2Vcblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0alF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLCBwcm9wTmFtZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRwcm9wTmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblxuXHRcdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgZ2V0IHNwZWNpYWwgdHJlYXRtZW50ICgjMTA4NzApXG5cdFx0XHRcdGlmICggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdFx0XHQvLyBTZXQgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB0byBmYWxzZVxuXHRcdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlO1xuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBuYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0cmV0dXJuIHRhYmluZGV4ID9cblx0XHRcdFx0XHRwYXJzZUludCggdGFiaW5kZXgsIDEwICkgOlxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiBlbGVtLmhyZWYgP1xuXHRcdFx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRcdFx0LTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxudmFyIHJjbGFzcyA9IC9bXFx0XFxyXFxuXFxmXS9nO1xuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIFwiIFwiICsgY3VyVmFsdWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgZ2V0Q2xhc3MoIGVsZW0gKSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTFcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2csXG5cdHJzcGFjZXMgPSAvW1xceDIwXFx0XFxyXFxuXFxmXSsvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdFx0cmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKSA6XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0XHRyZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMC0xMStcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdGpRdWVyeS50cmltKCBqUXVlcnkudGV4dCggZWxlbSApICkucmVwbGFjZSggcnNwYWNlcywgXCIgXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiIHx8IGluZGV4IDwgMCxcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGgsXG5cdFx0XHRcdFx0aSA9IGluZGV4IDwgMCA/XG5cdFx0XHRcdFx0XHRtYXggOlxuXHRcdFx0XHRcdFx0b25lID8gaW5kZXggOiAwO1xuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQoIHN1cHBvcnQub3B0RGlzYWJsZWQgP1xuXHRcdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PT0gbnVsbCApICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblxuXHRcdFx0XHQvLyBQcmV2aW91c2x5LCBgb3JpZ2luYWxFdmVudDoge31gIHdhcyBzZXQgaGVyZSwgc28gc3RvcFByb3BhZ2F0aW9uIGNhbGxcblx0XHRcdFx0Ly8gd291bGQgbm90IGJlIHRyaWdnZXJlZCBvbiBkb25vciBldmVudCwgc2luY2UgaW4gb3VyIG93blxuXHRcdFx0XHQvLyBqUXVlcnkuZXZlbnQuc3RvcFByb3BhZ2F0aW9uIGZ1bmN0aW9uIHdlIGhhZCBhIGNoZWNrIGZvciBleGlzdGVuY2Ugb2Zcblx0XHRcdFx0Ly8gb3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24gbWV0aG9kLCBzbywgY29uc2VxdWVudGx5IGl0IHdvdWxkIGJlIGEgbm9vcC5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gQnV0IG5vdywgdGhpcyBcInNpbXVsYXRlXCIgZnVuY3Rpb24gaXMgdXNlZCBvbmx5IGZvciBldmVudHNcblx0XHRcdFx0Ly8gZm9yIHdoaWNoIHN0b3BQcm9wYWdhdGlvbigpIGlzIG5vb3AsIHNvIHRoZXJlIGlzIG5vIG5lZWQgZm9yIHRoYXQgYW55bW9yZS5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gRm9yIHRoZSAxLnggYnJhbmNoIHRob3VnaCwgZ3VhcmQgZm9yIFwiY2xpY2tcIiBhbmQgXCJzdWJtaXRcIlxuXHRcdFx0XHQvLyBldmVudHMgaXMgc3RpbGwgdXNlZCwgYnV0IHdhcyBtb3ZlZCB0byBqUXVlcnkuZXZlbnQuc3RvcFByb3BhZ2F0aW9uIGZ1bmN0aW9uXG5cdFx0XHRcdC8vIGJlY2F1c2UgYG9yaWdpbmFsRXZlbnRgIHNob3VsZCBwb2ludCB0byB0aGUgb3JpZ2luYWwgZXZlbnQgZm9yIHRoZSBjb25zdGFuY3lcblx0XHRcdFx0Ly8gd2l0aCBvdGhlciBldmVudHMgYW5kIGZvciBtb3JlIGZvY3VzZWQgbG9naWNcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblxuXHRcdGlmICggZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSwgU2FmYXJpXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG4vLyBXb3JrYXJvdW5kIGZhaWx1cmUgdG8gc3RyaW5nLWNhc3QgbnVsbCBpbnB1dFxualF1ZXJ5LnBhcnNlSlNPTiA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSArIFwiXCIgKTtcbn07XG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IGpRdWVyeS5wYXJzZUpTT04sXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIFRoZSBqcVhIUiBzdGF0ZVxuXHRcdFx0c3RhdGUgPSAwLFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlID09PSAyID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0dmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKS5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xuXHRcdGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xuXHRcdGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDtcblxuXHRcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKS5yZXBsYWNlKCByaGFzaCwgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOC0xMStcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gaWYgdXJsIGlzIG1hbGZvcm1lZCwgZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTgtMTErXG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybDtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSAoIHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGEgKTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVybCBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHMudXJsID0gcnRzLnRlc3QoIGNhY2hlVVJMICkgP1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhICdfJyBwYXJhbWV0ZXIsIHNldCBpdHMgdmFsdWVcblx0XHRcdFx0XHRjYWNoZVVSTC5yZXBsYWNlKCBydHMsIFwiJDFfPVwiICsgbm9uY2UrKyApIDpcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBhZGQgb25lIHRvIHRoZSBlbmRcblx0XHRcdFx0XHRjYWNoZVVSTCArICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyBub25jZSsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Zm9yICggaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9ICkge1xuXHRcdFx0anFYSFJbIGkgXSggc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHN0YXRlID0gMTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgZXhjZXB0aW9uIGFzIGVycm9yIGlmIG5vdCBkb25lXG5cdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cblx0XHRcdFx0Ly8gU2ltcGx5IHJldGhyb3cgb3RoZXJ3aXNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIENhbGxlZCBvbmNlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuXHRcdFx0c3RhdGUgPSAyO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudCgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fSApLmVuZCgpO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHQvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMlxuXHQvLyBPcGVyYSByZXBvcnRzIG9mZnNldFdpZHRocyBhbmQgb2Zmc2V0SGVpZ2h0cyBsZXNzIHRoYW4gemVybyBvbiBzb21lIGVsZW1lbnRzXG5cdC8vIFVzZSBPUiBpbnN0ZWFkIG9mIEFORCBhcyB0aGUgZWxlbWVudCBpcyBub3QgdmlzaWJsZSBpZiBlaXRoZXIgaXMgdHJ1ZVxuXHQvLyBTZWUgdGlja2V0cyAjMTA0MDYgYW5kICMxMzEzMlxuXHRyZXR1cm4gZWxlbS5vZmZzZXRXaWR0aCA+IDAgfHwgZWxlbS5vZmZzZXRIZWlnaHQgPiAwIHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwO1xufTtcblxuXG5cblxudmFyIHIyMCA9IC8lMjAvZyxcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuXHRcdFx0dmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlKCkgOiAoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuXHRpZiAoIHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0dHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzICYmIGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWw7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHR2YXIgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICksXG5cdFx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxudmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcblx0XHRyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRpZiAoICFkb2MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0XHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3g7XG5cdFx0fVxuXG5cdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IGJveC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpPDctOCssIENocm9tZTwzNy00NCtcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTI4MFxuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxuXHRcdFx0XHRcdC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcblx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzc2NFxuXHRcdFx0XHRcdHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXHRzaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGg7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmFuZFNlbGYgPSBqUXVlcnkuZm4uYWRkQmFjaztcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5yZXR1cm4galF1ZXJ5O1xufSkpO1xuIiwiLyohXG4gKiBWRVJTSU9OOiAxLjE4LjRcbiAqIERBVEU6IDIwMTYtMDQtMjZcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKiBcbiAqIEluY2x1ZGVzIGFsbCBvZiB0aGUgZm9sbG93aW5nOiBUd2VlbkxpdGUsIFR3ZWVuTWF4LCBUaW1lbGluZUxpdGUsIFRpbWVsaW5lTWF4LCBFYXNlUGFjaywgQ1NTUGx1Z2luLCBSb3VuZFByb3BzUGx1Z2luLCBCZXppZXJQbHVnaW4sIEF0dHJQbHVnaW4sIERpcmVjdGlvbmFsUm90YXRpb25QbHVnaW5cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxNiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyB3b3JrIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHA6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgc29mdHdhcmUgYWdyZWVtZW50IHRoYXQgd2FzIGlzc3VlZCB3aXRoIHlvdXIgbWVtYmVyc2hpcC5cbiAqIFxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4gKiovXG52YXIgX2dzU2NvcGUgPSAodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mKGdsb2JhbCkgIT09IFwidW5kZWZpbmVkXCIpID8gZ2xvYmFsIDogdGhpcyB8fCB3aW5kb3c7IC8vaGVscHMgZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQvUmVxdWlyZUpTIGFuZCBDb21tb25KUy9Ob2RlXG4oX2dzU2NvcGUuX2dzUXVldWUgfHwgKF9nc1Njb3BlLl9nc1F1ZXVlID0gW10pKS5wdXNoKCBmdW5jdGlvbigpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUd2Vlbk1heFwiLCBbXCJjb3JlLkFuaW1hdGlvblwiLFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLFwiVHdlZW5MaXRlXCJdLCBmdW5jdGlvbihBbmltYXRpb24sIFNpbXBsZVRpbWVsaW5lLCBUd2VlbkxpdGUpIHtcblxuXHRcdHZhciBfc2xpY2UgPSBmdW5jdGlvbihhKSB7IC8vZG9uJ3QgdXNlIFtdLnNsaWNlIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdHZhciBiID0gW10sXG5cdFx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgIT09IGw7IGIucHVzaChhW2krK10pKTtcblx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHR9LFxuXHRcdFx0X2FwcGx5Q3ljbGUgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXRzLCBpKSB7XG5cdFx0XHRcdHZhciBhbHQgPSB2YXJzLmN5Y2xlLFxuXHRcdFx0XHRcdHAsIHZhbDtcblx0XHRcdFx0Zm9yIChwIGluIGFsdCkge1xuXHRcdFx0XHRcdHZhbCA9IGFsdFtwXTtcblx0XHRcdFx0XHR2YXJzW3BdID0gKHR5cGVvZih2YWwpID09PSBcImZ1bmN0aW9uXCIpID8gdmFsLmNhbGwodGFyZ2V0c1tpXSwgaSkgOiB2YWxbaSAlIHZhbC5sZW5ndGhdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSB2YXJzLmN5Y2xlO1xuXHRcdFx0fSxcblx0XHRcdFR3ZWVuTWF4ID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0XHRUd2VlbkxpdGUuY2FsbCh0aGlzLCB0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHRoaXMudmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7IC8vZW5zdXJlcyB0aGF0IGlmIHRoZXJlIGlzIGFueSByZXBlYXQsIHRoZSB0b3RhbER1cmF0aW9uIHdpbGwgZ2V0IHJlY2FsY3VsYXRlZCB0byBhY2N1cmF0ZWx5IHJlcG9ydCBpdC5cblx0XHRcdFx0dGhpcy5yZW5kZXIgPSBUd2Vlbk1heC5wcm90b3R5cGUucmVuZGVyOyAvL3NwZWVkIG9wdGltaXphdGlvbiAoYXZvaWQgcHJvdG90eXBlIGxvb2t1cCBvbiB0aGlzIFwiaG90XCIgbWV0aG9kKVxuXHRcdFx0fSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMsXG5cdFx0XHRfaXNTZWxlY3RvciA9IFR3ZWVuTGl0ZUludGVybmFscy5pc1NlbGVjdG9yLFxuXHRcdFx0X2lzQXJyYXkgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNBcnJheSxcblx0XHRcdHAgPSBUd2Vlbk1heC5wcm90b3R5cGUgPSBUd2VlbkxpdGUudG8oe30sIDAuMSwge30pLFxuXHRcdFx0X2JsYW5rQXJyYXkgPSBbXTtcblxuXHRcdFR3ZWVuTWF4LnZlcnNpb24gPSBcIjEuMTguNFwiO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUd2Vlbk1heDtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblx0XHRUd2Vlbk1heC5raWxsVHdlZW5zT2YgPSBUd2Vlbk1heC5raWxsRGVsYXllZENhbGxzVG8gPSBUd2VlbkxpdGUua2lsbFR3ZWVuc09mO1xuXHRcdFR3ZWVuTWF4LmdldFR3ZWVuc09mID0gVHdlZW5MaXRlLmdldFR3ZWVuc09mO1xuXHRcdFR3ZWVuTWF4LmxhZ1Ntb290aGluZyA9IFR3ZWVuTGl0ZS5sYWdTbW9vdGhpbmc7XG5cdFx0VHdlZW5NYXgudGlja2VyID0gVHdlZW5MaXRlLnRpY2tlcjtcblx0XHRUd2Vlbk1heC5yZW5kZXIgPSBUd2VlbkxpdGUucmVuZGVyO1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlKTtcblx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdGhpcy52YXJzLnJlcGVhdERlbGF5IHx8IDA7XG5cdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0cmV0dXJuIFR3ZWVuTGl0ZS5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC51cGRhdGVUbyA9IGZ1bmN0aW9uKHZhcnMsIHJlc2V0RHVyYXRpb24pIHtcblx0XHRcdHZhciBjdXJSYXRpbyA9IHRoaXMucmF0aW8sXG5cdFx0XHRcdGltbWVkaWF0ZSA9IHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIgfHwgdmFycy5pbW1lZGlhdGVSZW5kZXIsXG5cdFx0XHRcdHA7XG5cdFx0XHRpZiAocmVzZXREdXJhdGlvbiAmJiB0aGlzLl9zdGFydFRpbWUgPCB0aGlzLl90aW1lbGluZS5fdGltZSkge1xuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB0aGlzLl90aW1lbGluZS5fdGltZTtcblx0XHRcdFx0dGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWVsaW5lLmluc2VydCh0aGlzLCB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9kZWxheSk7IC8vZW5zdXJlcyB0aGF0IGFueSBuZWNlc3NhcnkgcmUtc2VxdWVuY2luZyBvZiBBbmltYXRpb25zIGluIHRoZSB0aW1lbGluZSBvY2N1cnMgdG8gbWFrZSBzdXJlIHRoZSByZW5kZXJpbmcgb3JkZXIgaXMgY29ycmVjdC5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0dGhpcy52YXJzW3BdID0gdmFyc1twXTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9pbml0dGVkIHx8IGltbWVkaWF0ZSkge1xuXHRcdFx0XHRpZiAocmVzZXREdXJhdGlvbikge1xuXHRcdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlcigwLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgJiYgdGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRcdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KFwiX29uRGlzYWJsZVwiLCB0aGlzKTsgLy9pbiBjYXNlIGEgcGx1Z2luIGxpa2UgTW90aW9uQmx1ciBtdXN0IHBlcmZvcm0gc29tZSBjbGVhbnVwIHRhc2tzXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lIC8gdGhpcy5fZHVyYXRpb24gPiAwLjk5OCkgeyAvL2lmIHRoZSB0d2VlbiBoYXMgZmluaXNoZWQgKG9yIGNvbWUgZXh0cmVtZWx5IGNsb3NlIHRvIGZpbmlzaGluZyksIHdlIGp1c3QgbmVlZCB0byByZXdpbmQgaXQgdG8gMCBhbmQgdGhlbiByZW5kZXIgaXQgYWdhaW4gYXQgdGhlIGVuZCB3aGljaCBmb3JjZXMgaXQgdG8gcmUtaW5pdGlhbGl6ZSAocGFyc2luZyB0aGUgbmV3IHZhcnMpLiBXZSBhbGxvdyB0d2VlbnMgdGhhdCBhcmUgY2xvc2UgdG8gZmluaXNoaW5nIChidXQgaGF2ZW4ndCBxdWl0ZSBmaW5pc2hlZCkgdG8gd29yayB0aGlzIHdheSB0b28gYmVjYXVzZSBvdGhlcndpc2UsIHRoZSB2YWx1ZXMgYXJlIHNvIHNtYWxsIHdoZW4gZGV0ZXJtaW5pbmcgd2hlcmUgdG8gcHJvamVjdCB0aGUgc3RhcnRpbmcgdmFsdWVzIHRoYXQgYmluYXJ5IG1hdGggaXNzdWVzIGNyZWVwIGluIGFuZCBjYW4gbWFrZSB0aGUgdHdlZW4gYXBwZWFyIHRvIHJlbmRlciBpbmNvcnJlY3RseSB3aGVuIHJ1biBiYWNrd2FyZHMuIFxuXHRcdFx0XHRcdFx0dmFyIHByZXZUaW1lID0gdGhpcy5fdG90YWxUaW1lO1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXIoMCwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUsIGZhbHNlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5faW5pdCgpO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgPiAwIHx8IGltbWVkaWF0ZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaW52ID0gMSAvICgxIC0gY3VyUmF0aW8pLFxuXHRcdFx0XHRcdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVCwgZW5kVmFsdWU7XG5cdFx0XHRcdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gcHQucyArIHB0LmM7XG5cdFx0XHRcdFx0XHRcdFx0cHQuYyAqPSBpbnY7XG5cdFx0XHRcdFx0XHRcdFx0cHQucyA9IGVuZFZhbHVlIC0gcHQuYztcblx0XHRcdFx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFx0XHRcblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSBpZiAodGhpcy5fZHVyYXRpb24gPT09IDAgJiYgdGhpcy52YXJzLnJlcGVhdCkgeyAvL3plcm8gZHVyYXRpb24gdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IGhhdmUgcmVuZGVyKCkgY2FsbGVkIGZyb20gVHdlZW5MaXRlJ3MgY29uc3RydWN0b3IsIGJlZm9yZSBUd2Vlbk1heCdzIGNvbnN0cnVjdG9yIGhhcyBmaW5pc2hlZCBzZXR0aW5nIF9yZXBlYXQsIF9yZXBlYXREZWxheSwgYW5kIF95b3lvIHdoaWNoIGFyZSBjcml0aWNhbCBpbiBkZXRlcm1pbmluZyB0b3RhbER1cmF0aW9uKCkgc28gd2UgbmVlZCB0byBjYWxsIGludmFsaWRhdGUoKSB3aGljaCBpcyBhIGxvdy1rYiB3YXkgdG8gZ2V0IHRob3NlIHNldCBwcm9wZXJseS5cblx0XHRcdFx0dGhpcy5pbnZhbGlkYXRlKCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG90YWxEdXIgPSAoIXRoaXMuX2RpcnR5KSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLnRvdGFsRHVyYXRpb24oKSxcblx0XHRcdFx0cHJldlRpbWUgPSB0aGlzLl90aW1lLFxuXHRcdFx0XHRwcmV2VG90YWxUaW1lID0gdGhpcy5fdG90YWxUaW1lLCBcblx0XHRcdFx0cHJldkN5Y2xlID0gdGhpcy5fY3ljbGUsXG5cdFx0XHRcdGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdHByZXZSYXdQcmV2VGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lLFxuXHRcdFx0XHRpc0NvbXBsZXRlLCBjYWxsYmFjaywgcHQsIGN5Y2xlRHVyYXRpb24sIHIsIHR5cGUsIHBvdywgcmF3UHJldlRpbWU7XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1ciAtIDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRvdGFsRHVyO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IHRoaXMuX3JlcGVhdDtcblx0XHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXJhdGlvbjtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMSkgOiAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25Db21wbGV0ZVwiO1xuXHRcdFx0XHRcdGZvcmNlID0gKGZvcmNlIHx8IHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbik7IC8vb3RoZXJ3aXNlLCBpZiB0aGUgYW5pbWF0aW9uIGlzIHVucGF1c2VkL2FjdGl2YXRlZCBhZnRlciBpdCdzIGFscmVhZHkgZmluaXNoZWQsIGl0IGRvZXNuJ3QgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHRpbWVsaW5lLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0VGltZSA9PT0gdGhpcy5fdGltZWxpbmUuX2R1cmF0aW9uKSB7IC8vaWYgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGlzIGF0IHRoZSBWRVJZIGVuZCBvZiBhIHRpbWVsaW5lIGFuZCB0aGF0IHRpbWVsaW5lIHJlbmRlcnMgYXQgaXRzIGVuZCwgaXQgd2lsbCB0eXBpY2FsbHkgYWRkIGEgdGlueSBiaXQgb2YgY3VzaGlvbiB0byB0aGUgcmVuZGVyIHRpbWUgdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnMgZnJvbSBnZXR0aW5nIGluIHRoZSB3YXkgb2YgdHdlZW5zIHJlbmRlcmluZyB0aGVpciBWRVJZIGVuZC4gSWYgd2UgdGhlbiByZXZlcnNlKCkgdGhhdCB0aW1lbGluZSwgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gd2lsbCB0cmlnZ2VyIGl0cyBvblJldmVyc2VDb21wbGV0ZSBldmVuIHRob3VnaCB0ZWNobmljYWxseSB0aGUgcGxheWhlYWQgZGlkbid0IHBhc3Mgb3ZlciBpdCBhZ2Fpbi4gSXQncyBhIHZlcnkgc3BlY2lmaWMgZWRnZSBjYXNlIHdlIG11c3QgYWNjb21tb2RhdGUuXG5cdFx0XHRcdFx0XHR0aW1lID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA8IDAgfHwgKHRpbWUgPD0gMCAmJiB0aW1lID49IC0wLjAwMDAwMDEpIHx8IChwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHRoaXMuZGF0YSAhPT0gXCJpc1BhdXNlXCIpKSBpZiAocHJldlJhd1ByZXZUaW1lICE9PSB0aW1lKSB7IC8vbm90ZTogd2hlbiB0aGlzLmRhdGEgaXMgXCJpc1BhdXNlXCIsIGl0J3MgYSBjYWxsYmFjayBhZGRlZCBieSBhZGRQYXVzZSgpIG9uIGEgdGltZWxpbmUgdGhhdCB3ZSBzaG91bGQgbm90IGJlIHRyaWdnZXJlZCB3aGVuIExFQVZJTkcgaXRzIGV4YWN0IHN0YXJ0IHRpbWUuIEluIG90aGVyIHdvcmRzLCB0bC5hZGRQYXVzZSgxKS5wbGF5KDEpIHNob3VsZG4ndCBwYXVzZS5cblx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygwKSA6IDA7XG5cdFx0XHRcdGlmIChwcmV2VG90YWxUaW1lICE9PSAwIHx8IChkdXJhdGlvbiA9PT0gMCAmJiBwcmV2UmF3UHJldlRpbWUgPiAwKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7IC8vaWYgd2UgcmVuZGVyIHRoZSB2ZXJ5IGJlZ2lubmluZyAodGltZSA9PSAwKSBvZiBhIGZyb21UbygpLCB3ZSBtdXN0IGZvcmNlIHRoZSByZW5kZXIgKG5vcm1hbCB0d2VlbnMgd291bGRuJ3QgbmVlZCB0byByZW5kZXIgYXQgYSB0aW1lIG9mIDAgd2hlbiB0aGUgcHJldlRpbWUgd2FzIGFsc28gMCkuIFRoaXMgaXMgYWxzbyBtYW5kYXRvcnkgdG8gbWFrZSBzdXJlIG92ZXJ3cml0aW5nIGtpY2tzIGluIGltbWVkaWF0ZWx5LlxuXHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRpbWU7XG5cdFx0XHRcdGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0XHRjeWNsZUR1cmF0aW9uID0gZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9ICh0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSA+PiAwOyAvL29yaWdpbmFsbHkgX3RvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24gYnV0IGZsb2F0aW5nIHBvaW50IGVycm9ycyBjYXVzZWQgcHJvYmxlbXMsIHNvIEkgbm9ybWFsaXplZCBpdC4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXHRcdFx0XHRcdGlmICh0aGlzLl9jeWNsZSAhPT0gMCkgaWYgKHRoaXMuX2N5Y2xlID09PSB0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uICYmIHByZXZUb3RhbFRpbWUgPD0gdGltZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fY3ljbGUtLTsgLy9vdGhlcndpc2Ugd2hlbiByZW5kZXJlZCBleGFjdGx5IGF0IHRoZSBlbmQgdGltZSwgaXQgd2lsbCBhY3QgYXMgdGhvdWdoIGl0IGlzIHJlcGVhdGluZyAoYXQgdGhlIGJlZ2lubmluZylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSAtICh0aGlzLl9jeWNsZSAqIGN5Y2xlRHVyYXRpb24pO1xuXHRcdFx0XHRcdGlmICh0aGlzLl95b3lvKSBpZiAoKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXJhdGlvbiAtIHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXJhdGlvbjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPCAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fZWFzZVR5cGUpIHtcblx0XHRcdFx0XHRyID0gdGhpcy5fdGltZSAvIGR1cmF0aW9uO1xuXHRcdFx0XHRcdHR5cGUgPSB0aGlzLl9lYXNlVHlwZTtcblx0XHRcdFx0XHRwb3cgPSB0aGlzLl9lYXNlUG93ZXI7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEgfHwgKHR5cGUgPT09IDMgJiYgciA+PSAwLjUpKSB7XG5cdFx0XHRcdFx0XHRyID0gMSAtIHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwb3cgPT09IDEpIHtcblx0XHRcdFx0XHRcdHIgKj0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMikge1xuXHRcdFx0XHRcdFx0ciAqPSByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDQpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByICogcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gMikge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lIC8gZHVyYXRpb24gPCAwLjUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByIC8gMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSAociAvIDIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0aWYgKHByZXZUaW1lID09PSB0aGlzLl90aW1lICYmICFmb3JjZSAmJiBwcmV2Q3ljbGUgPT09IHRoaXMuX2N5Y2xlKSB7XG5cdFx0XHRcdGlmIChwcmV2VG90YWxUaW1lICE9PSB0aGlzLl90b3RhbFRpbWUpIGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgeyAvL3NvIHRoYXQgb25VcGRhdGUgZmlyZXMgZXZlbiBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IC0gYXMgbG9uZyBhcyB0aGUgdG90YWxUaW1lIGNoYW5nZWQsIHdlIHNob3VsZCB0cmlnZ2VyIG9uVXBkYXRlLlxuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCB8fCB0aGlzLl9nYykgeyAvL2ltbWVkaWF0ZVJlbmRlciB0d2VlbnMgdHlwaWNhbGx5IHdvbid0IGluaXRpYWxpemUgdW50aWwgdGhlIHBsYXloZWFkIGFkdmFuY2VzIChfdGltZSBpcyBncmVhdGVyIHRoYW4gMCkgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgb3ZlcndyaXRpbmcgb2NjdXJzIHByb3Blcmx5LiBBbHNvLCBpZiBhbGwgb2YgdGhlIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuICh3aGljaCB3b3VsZCBjYXVzZSBfZ2MgdG8gYmUgdHJ1ZSwgYXMgc2V0IGluIF9pbml0KCkpLCB3ZSBzaG91bGRuJ3QgY29udGludWUgb3RoZXJ3aXNlIGFuIG9uU3RhcnQgY2FsbGJhY2sgY291bGQgYmUgY2FsbGVkIGZvciBleGFtcGxlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmICghZm9yY2UgJiYgdGhpcy5fZmlyc3RQVCAmJiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpKSB7IC8vd2Ugc3RpY2sgaXQgaW4gdGhlIHF1ZXVlIGZvciByZW5kZXJpbmcgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSB0aWNrIC0gdGhpcyBpcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBiZWNhdXNlIGJyb3dzZXJzIGludmFsaWRhdGUgc3R5bGVzIGFuZCBmb3JjZSBhIHJlY2FsY3VsYXRpb24gaWYgeW91IHJlYWQsIHdyaXRlLCBhbmQgdGhlbiByZWFkIHN0eWxlIGRhdGEgKHNvIGl0J3MgYmV0dGVyIHRvIHJlYWQvcmVhZC9yZWFkL3dyaXRlL3dyaXRlL3dyaXRlIHRoYW4gcmVhZC93cml0ZS9yZWFkL3dyaXRlL3JlYWQvd3JpdGUpLiBUaGUgZG93biBzaWRlLCBvZiBjb3Vyc2UsIGlzIHRoYXQgdXN1YWxseSB5b3UgV0FOVCB0aGluZ3MgdG8gcmVuZGVyIGltbWVkaWF0ZWx5IGJlY2F1c2UgeW91IG1heSBoYXZlIGNvZGUgcnVubmluZyByaWdodCBhZnRlciB0aGF0IHdoaWNoIGRlcGVuZHMgb24gdGhlIGNoYW5nZS4gTGlrZSBpbWFnaW5lIHJ1bm5pbmcgVHdlZW5MaXRlLnNldCguLi4pIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoYXQsIGNyZWF0aW5nIGEgbm90aGVyIHR3ZWVuIHRoYXQgYW5pbWF0ZXMgdGhlIHNhbWUgcHJvcGVydHkgdG8gYW5vdGhlciB2YWx1ZTsgdGhlIHN0YXJ0aW5nIHZhbHVlcyBvZiB0aGF0IDJuZCB0d2VlbiB3b3VsZG4ndCBiZSBhY2N1cmF0ZSBpZiBsYXp5IGlzIHRydWUuXG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHByZXZUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHByZXZUb3RhbFRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSBwcmV2UmF3UHJldlRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSBwcmV2Q3ljbGU7XG5cdFx0XHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzLmxhenlUd2VlbnMucHVzaCh0aGlzKTtcblx0XHRcdFx0XHR0aGlzLl9sYXp5ID0gW3RpbWUsIHN1cHByZXNzRXZlbnRzXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9fZWFzZSBpcyBpbml0aWFsbHkgc2V0IHRvIGRlZmF1bHRFYXNlLCBzbyBub3cgdGhhdCBpbml0KCkgaGFzIHJ1biwgX2Vhc2UgaXMgc2V0IHByb3Blcmx5IGFuZCB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSByYXRpby4gT3ZlcmFsbCB0aGlzIGlzIGZhc3RlciB0aGFuIHVzaW5nIGNvbmRpdGlvbmFsIGxvZ2ljIGVhcmxpZXIgaW4gdGhlIG1ldGhvZCB0byBhdm9pZCBoYXZpbmcgdG8gc2V0IHJhdGlvIHR3aWNlIGJlY2F1c2Ugd2Ugb25seSBpbml0KCkgb25jZSBidXQgcmVuZGVyVGltZSgpIGdldHMgY2FsbGVkIFZFUlkgZnJlcXVlbnRseS5cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgJiYgIWlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzQ29tcGxldGUgJiYgdGhpcy5fZWFzZS5fY2FsY0VuZCkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKCh0aGlzLl90aW1lID09PSAwKSA/IDAgOiAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2xhenkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RpbWUgIT09IHByZXZUaW1lICYmIHRpbWUgPj0gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBhIHR3ZWVuIChhcyBvcHBvc2VkIHRvIHRoZSB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCB0aGUgdGltZWxpbmUgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdHdlZW4gYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUuXG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlRvdGFsVGltZSA9PT0gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5faW5pdHRlZCA9PT0gMiAmJiB0aW1lID4gMCkge1xuXHRcdFx0XHRcdC8vdGhpcy5pbnZhbGlkYXRlKCk7XG5cdFx0XHRcdFx0dGhpcy5faW5pdCgpOyAvL3dpbGwganVzdCBhcHBseSBvdmVyd3JpdGluZyBzaW5jZSBfaW5pdHRlZCBvZiAoMikgbWVhbnMgaXQgd2FzIGEgZnJvbSgpIHR3ZWVuIHRoYXQgaGFkIGltbWVkaWF0ZVJlbmRlcjp0cnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHRpZiAodGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwiX2R1bW15R1NcIjsgLy9pZiBubyBjYWxsYmFjayBpcyBkZWZpbmVkLCB1c2UgYSBkdW1teSB2YWx1ZSBqdXN0IHNvIHRoYXQgdGhlIGNvbmRpdGlvbiBhdCB0aGUgZW5kIGV2YWx1YXRlcyBhcyB0cnVlIGJlY2F1c2UgX3N0YXJ0QXQgc2hvdWxkIHJlbmRlciBBRlRFUiB0aGUgbm9ybWFsIHJlbmRlciBsb29wIHdoZW4gdGhlIHRpbWUgaXMgbmVnYXRpdmUuIFdlIGNvdWxkIGhhbmRsZSB0aGlzIGluIGEgbW9yZSBpbnR1aXRpdmUgd2F5LCBvZiBjb3Vyc2UsIGJ1dCB0aGUgcmVuZGVyIGxvb3AgaXMgdGhlIE1PU1QgaW1wb3J0YW50IHRoaW5nIHRvIG9wdGltaXplLCBzbyB0aGlzIHRlY2huaXF1ZSBhbGxvd3MgdXMgdG8gYXZvaWQgYWRkaW5nIGV4dHJhIGNvbmRpdGlvbmFsIGxvZ2ljIGluIGEgaGlnaC1mcmVxdWVuY3kgYXJlYS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdG90YWxUaW1lICE9PSAwIHx8IGR1cmF0aW9uID09PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0ocHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDApIGlmICh0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3N0YXJ0VGltZSkgeyAvL2lmIHRoZSB0d2VlbiBpcyBwb3NpdGlvbmVkIGF0IHRoZSBWRVJZIGJlZ2lubmluZyAoX3N0YXJ0VGltZSAwKSBvZiBpdHMgcGFyZW50IHRpbWVsaW5lLCBpdCdzIGlsbGVnYWwgZm9yIHRoZSBwbGF5aGVhZCB0byBnbyBiYWNrIGZ1cnRoZXIsIHNvIHdlIHNob3VsZCBub3QgcmVuZGVyIHRoZSByZWNvcmRlZCBzdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIGlmICh0aGlzLl90b3RhbFRpbWUgIT09IHByZXZUb3RhbFRpbWUgfHwgY2FsbGJhY2spIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IHByZXZDeWNsZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKCF0aGlzLl9nYykgaWYgKHRoaXMudmFycy5vblJlcGVhdCkge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uUmVwZWF0XCIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2djIHx8IGZvcmNlKSB7IC8vY2hlY2sgZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGhpcy5fc3RhcnRUaW1lKSB7IC8vaWYgdGhlIHR3ZWVuIGlzIHBvc2l0aW9uZWQgYXQgdGhlIFZFUlkgYmVnaW5uaW5nIChfc3RhcnRUaW1lIDApIG9mIGl0cyBwYXJlbnQgdGltZWxpbmUsIGl0J3MgaWxsZWdhbCBmb3IgdGhlIHBsYXloZWFkIHRvIGdvIGJhY2sgZnVydGhlciwgc28gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlIHJlY29yZGVkIHN0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKGNhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHJhd1ByZXZUaW1lICE9PSBfdGlueU51bSkgeyAvL3RoZSBvbkNvbXBsZXRlIG9yIG9uUmV2ZXJzZUNvbXBsZXRlIGNvdWxkIHRyaWdnZXIgbW92ZW1lbnQgb2YgdGhlIHBsYXloZWFkIGFuZCBmb3IgemVyby1kdXJhdGlvbiB0d2VlbnMgKHdoaWNoIG11c3QgZGlzY2VybiBkaXJlY3Rpb24pIHRoYXQgbGFuZCBkaXJlY3RseSBiYWNrIG9uIHRoZWlyIHN0YXJ0IHRpbWUsIHdlIGRvbid0IHdhbnQgdG8gZmlyZSBhZ2FpbiBvbiB0aGUgbmV4dCByZW5kZXIuIFRoaW5rIG9mIHNldmVyYWwgYWRkUGF1c2UoKSdzIGluIGEgdGltZWxpbmUgdGhhdCBmb3JjZXMgdGhlIHBsYXloZWFkIHRvIGEgY2VydGFpbiBzcG90LCBidXQgd2hhdCBpZiBpdCdzIGFscmVhZHkgcGF1c2VkIGFuZCBhbm90aGVyIHR3ZWVuIGlzIHR3ZWVuaW5nIHRoZSBcInRpbWVcIiBvZiB0aGUgdGltZWxpbmU/IEVhY2ggdGltZSBpdCBtb3ZlcyBbZm9yd2FyZF0gcGFzdCB0aGF0IHNwb3QsIGl0IHdvdWxkIG1vdmUgYmFjaywgYW5kIHNpbmNlIHN1cHByZXNzRXZlbnRzIGlzIHRydWUsIGl0J2QgcmVzZXQgX3Jhd1ByZXZUaW1lIHRvIF90aW55TnVtIHNvIHRoYXQgd2hlbiBpdCBiZWdpbnMgYWdhaW4sIHRoZSBjYWxsYmFjayB3b3VsZCBmaXJlIChzbyB1bHRpbWF0ZWx5IGl0IGNvdWxkIGJvdW5jZSBiYWNrIGFuZCBmb3J0aCBkdXJpbmcgdGhhdCB0d2VlbikuIEFnYWluLCB0aGlzIGlzIGEgdmVyeSB1bmNvbW1vbiBzY2VuYXJpbywgYnV0IHBvc3NpYmxlIG5vbmV0aGVsZXNzLlxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG4vLy0tLS0gU1RBVElDIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFxuXHRcdFR3ZWVuTWF4LnRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmZyb20gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycykge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIGR1cmF0aW9uLCB0b1ZhcnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc3RhZ2dlclRvID0gVHdlZW5NYXguYWxsVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHRzdGFnZ2VyID0gc3RhZ2dlciB8fCAwO1xuXHRcdFx0dmFyIGRlbGF5ID0gMCxcblx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRmaW5hbENvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKHZhcnMub25Db21wbGV0ZSkge1xuXHRcdFx0XHRcdFx0dmFycy5vbkNvbXBsZXRlLmFwcGx5KHZhcnMub25Db21wbGV0ZVNjb3BlIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9uQ29tcGxldGVBbGwuYXBwbHkob25Db21wbGV0ZUFsbFNjb3BlIHx8IHZhcnMuY2FsbGJhY2tTY29wZSB8fCB0aGlzLCBvbkNvbXBsZXRlQWxsUGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Y3ljbGUgPSB2YXJzLmN5Y2xlLFxuXHRcdFx0XHRmcm9tQ3ljbGUgPSAodmFycy5zdGFydEF0ICYmIHZhcnMuc3RhcnRBdC5jeWNsZSksXG5cdFx0XHRcdGwsIGNvcHksIGksIHA7XG5cdFx0XHRpZiAoIV9pc0FycmF5KHRhcmdldHMpKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YodGFyZ2V0cykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHR0YXJnZXRzID0gVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldHMpIHx8IHRhcmdldHM7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9pc1NlbGVjdG9yKHRhcmdldHMpKSB7XG5cdFx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0cyA9IHRhcmdldHMgfHwgW107XG5cdFx0XHRpZiAoc3RhZ2dlciA8IDApIHtcblx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdFx0dGFyZ2V0cy5yZXZlcnNlKCk7XG5cdFx0XHRcdHN0YWdnZXIgKj0gLTE7XG5cdFx0XHR9XG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGggLSAxO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8PSBsOyBpKyspIHtcblx0XHRcdFx0Y29weSA9IHt9O1xuXHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdGNvcHlbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjeWNsZSkge1xuXHRcdFx0XHRcdF9hcHBseUN5Y2xlKGNvcHksIHRhcmdldHMsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmcm9tQ3ljbGUpIHtcblx0XHRcdFx0XHRmcm9tQ3ljbGUgPSBjb3B5LnN0YXJ0QXQgPSB7fTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gdmFycy5zdGFydEF0KSB7XG5cdFx0XHRcdFx0XHRmcm9tQ3ljbGVbcF0gPSB2YXJzLnN0YXJ0QXRbcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9hcHBseUN5Y2xlKGNvcHkuc3RhcnRBdCwgdGFyZ2V0cywgaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29weS5kZWxheSA9IGRlbGF5ICsgKGNvcHkuZGVsYXkgfHwgMCk7XG5cdFx0XHRcdGlmIChpID09PSBsICYmIG9uQ29tcGxldGVBbGwpIHtcblx0XHRcdFx0XHRjb3B5Lm9uQ29tcGxldGUgPSBmaW5hbENvbXBsZXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFbaV0gPSBuZXcgVHdlZW5NYXgodGFyZ2V0c1tpXSwgZHVyYXRpb24sIGNvcHkpO1xuXHRcdFx0XHRkZWxheSArPSBzdGFnZ2VyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5zdGFnZ2VyRnJvbSA9IFR3ZWVuTWF4LmFsbEZyb20gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gVHdlZW5NYXguc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc3RhZ2dlckZyb21UbyA9IFR3ZWVuTWF4LmFsbEZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBUd2Vlbk1heC5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXHRcdFx0XHRcblx0XHRUd2Vlbk1heC5kZWxheWVkQ2FsbCA9IGZ1bmN0aW9uKGRlbGF5LCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSwgdXNlRnJhbWVzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KGNhbGxiYWNrLCAwLCB7ZGVsYXk6ZGVsYXksIG9uQ29tcGxldGU6Y2FsbGJhY2ssIG9uQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBjYWxsYmFja1Njb3BlOnNjb3BlLCBvblJldmVyc2VDb21wbGV0ZTpjYWxsYmFjaywgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBpbW1lZGlhdGVSZW5kZXI6ZmFsc2UsIHVzZUZyYW1lczp1c2VGcmFtZXMsIG92ZXJ3cml0ZTowfSk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgodGFyZ2V0LCAwLCB2YXJzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmlzVHdlZW5pbmcgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRcdHJldHVybiAoVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldCwgdHJ1ZSkubGVuZ3RoID4gMCk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgX2dldENoaWxkcmVuT2YgPSBmdW5jdGlvbih0aW1lbGluZSwgaW5jbHVkZVRpbWVsaW5lcykge1xuXHRcdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdFx0dHdlZW4gPSB0aW1lbGluZS5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdGlmICh0d2VlbiBpbnN0YW5jZW9mIFR3ZWVuTGl0ZSkge1xuXHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGluY2x1ZGVUaW1lbGluZXMpIHtcblx0XHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGEgPSBhLmNvbmNhdChfZ2V0Q2hpbGRyZW5PZih0d2VlbiwgaW5jbHVkZVRpbWVsaW5lcykpO1xuXHRcdFx0XHRcdFx0Y250ID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9LCBcblx0XHRcdGdldEFsbFR3ZWVucyA9IFR3ZWVuTWF4LmdldEFsbFR3ZWVucyA9IGZ1bmN0aW9uKGluY2x1ZGVUaW1lbGluZXMpIHtcblx0XHRcdFx0cmV0dXJuIF9nZXRDaGlsZHJlbk9mKEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lLCBpbmNsdWRlVGltZWxpbmVzKS5jb25jYXQoIF9nZXRDaGlsZHJlbk9mKEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lLCBpbmNsdWRlVGltZWxpbmVzKSApO1xuXHRcdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5raWxsQWxsID0gZnVuY3Rpb24oY29tcGxldGUsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdGlmICh0d2VlbnMgPT0gbnVsbCkge1xuXHRcdFx0XHR0d2VlbnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRlbGF5ZWRDYWxscyA9PSBudWxsKSB7XG5cdFx0XHRcdGRlbGF5ZWRDYWxscyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IGdldEFsbFR3ZWVucygodGltZWxpbmVzICE9IGZhbHNlKSksXG5cdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0YWxsVHJ1ZSA9ICh0d2VlbnMgJiYgZGVsYXllZENhbGxzICYmIHRpbWVsaW5lcyksXG5cdFx0XHRcdGlzREMsIHR3ZWVuLCBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0d2VlbiA9IGFbaV07XG5cdFx0XHRcdGlmIChhbGxUcnVlIHx8ICh0d2VlbiBpbnN0YW5jZW9mIFNpbXBsZVRpbWVsaW5lKSB8fCAoKGlzREMgPSAodHdlZW4udGFyZ2V0ID09PSB0d2Vlbi52YXJzLm9uQ29tcGxldGUpKSAmJiBkZWxheWVkQ2FsbHMpIHx8ICh0d2VlbnMgJiYgIWlzREMpKSB7XG5cdFx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi50b3RhbFRpbWUodHdlZW4uX3JldmVyc2VkID8gMCA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5raWxsQ2hpbGRUd2VlbnNPZiA9IGZ1bmN0aW9uKHBhcmVudCwgY29tcGxldGUpIHtcblx0XHRcdGlmIChwYXJlbnQgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGwgPSBUd2VlbkxpdGVJbnRlcm5hbHMudHdlZW5Mb29rdXAsXG5cdFx0XHRcdGEsIGN1clBhcmVudCwgcCwgaSwgbDtcblx0XHRcdGlmICh0eXBlb2YocGFyZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRwYXJlbnQgPSBUd2VlbkxpdGUuc2VsZWN0b3IocGFyZW50KSB8fCBwYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX2lzU2VsZWN0b3IocGFyZW50KSkge1xuXHRcdFx0XHRwYXJlbnQgPSBfc2xpY2UocGFyZW50KTtcblx0XHRcdH1cblx0XHRcdGlmIChfaXNBcnJheShwYXJlbnQpKSB7XG5cdFx0XHRcdGkgPSBwYXJlbnQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRUd2Vlbk1heC5raWxsQ2hpbGRUd2VlbnNPZihwYXJlbnRbaV0sIGNvbXBsZXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRhID0gW107XG5cdFx0XHRmb3IgKHAgaW4gdGwpIHtcblx0XHRcdFx0Y3VyUGFyZW50ID0gdGxbcF0udGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0XHRcdHdoaWxlIChjdXJQYXJlbnQpIHtcblx0XHRcdFx0XHRpZiAoY3VyUGFyZW50ID09PSBwYXJlbnQpIHtcblx0XHRcdFx0XHRcdGEgPSBhLmNvbmNhdCh0bFtwXS50d2VlbnMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJQYXJlbnQgPSBjdXJQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bCA9IGEubGVuZ3RoO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoY29tcGxldGUpIHtcblx0XHRcdFx0XHRhW2ldLnRvdGFsVGltZShhW2ldLnRvdGFsRHVyYXRpb24oKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtpXS5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgX2NoYW5nZVBhdXNlID0gZnVuY3Rpb24ocGF1c2UsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdHR3ZWVucyA9ICh0d2VlbnMgIT09IGZhbHNlKTtcblx0XHRcdGRlbGF5ZWRDYWxscyA9IChkZWxheWVkQ2FsbHMgIT09IGZhbHNlKTtcblx0XHRcdHRpbWVsaW5lcyA9ICh0aW1lbGluZXMgIT09IGZhbHNlKTtcblx0XHRcdHZhciBhID0gZ2V0QWxsVHdlZW5zKHRpbWVsaW5lcyksXG5cdFx0XHRcdGFsbFRydWUgPSAodHdlZW5zICYmIGRlbGF5ZWRDYWxscyAmJiB0aW1lbGluZXMpLFxuXHRcdFx0XHRpID0gYS5sZW5ndGgsXG5cdFx0XHRcdGlzREMsIHR3ZWVuO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHR3ZWVuID0gYVtpXTtcblx0XHRcdFx0aWYgKGFsbFRydWUgfHwgKHR3ZWVuIGluc3RhbmNlb2YgU2ltcGxlVGltZWxpbmUpIHx8ICgoaXNEQyA9ICh0d2Vlbi50YXJnZXQgPT09IHR3ZWVuLnZhcnMub25Db21wbGV0ZSkpICYmIGRlbGF5ZWRDYWxscykgfHwgKHR3ZWVucyAmJiAhaXNEQykpIHtcblx0XHRcdFx0XHR0d2Vlbi5wYXVzZWQocGF1c2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5wYXVzZUFsbCA9IGZ1bmN0aW9uKHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdF9jaGFuZ2VQYXVzZSh0cnVlLCB0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnJlc3VtZUFsbCA9IGZ1bmN0aW9uKHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdF9jaGFuZ2VQYXVzZShmYWxzZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTWF4Lmdsb2JhbFRpbWVTY2FsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgdGwgPSBBbmltYXRpb24uX3Jvb3RUaW1lbGluZSxcblx0XHRcdFx0dCA9IFR3ZWVuTGl0ZS50aWNrZXIudGltZTtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGwuX3RpbWVTY2FsZTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgX3RpbnlOdW07IC8vY2FuJ3QgYWxsb3cgemVybyBiZWNhdXNlIGl0J2xsIHRocm93IHRoZSBtYXRoIG9mZlxuXHRcdFx0dGwuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0bC5fc3RhcnRUaW1lKSAqIHRsLl90aW1lU2NhbGUgLyB2YWx1ZSk7XG5cdFx0XHR0bCA9IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lO1xuXHRcdFx0dCA9IFR3ZWVuTGl0ZS50aWNrZXIuZnJhbWU7XG5cdFx0XHR0bC5fc3RhcnRUaW1lID0gdCAtICgodCAtIHRsLl9zdGFydFRpbWUpICogdGwuX3RpbWVTY2FsZSAvIHZhbHVlKTtcblx0XHRcdHRsLl90aW1lU2NhbGUgPSBBbmltYXRpb24uX3Jvb3RUaW1lbGluZS5fdGltZVNjYWxlID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblx0XHRcblx0XG4vLy0tLS0gR0VUVEVSUyAvIFNFVFRFUlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFxuXHRcdHAucHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdGltZSAvIHRoaXMuZHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLmR1cmF0aW9uKCkgKiAoKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApID8gMSAtIHZhbHVlIDogdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RvdGFsVGltZSAvIHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUoIHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAudGltZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlID4gdGhpcy5fZHVyYXRpb24pIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlID0gKHRoaXMuX2R1cmF0aW9uIC0gdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlICs9IHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjsgLy9kb24ndCBzZXQgX2RpcnR5ID0gZmFsc2UgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSByZXBlYXRzIHRoYXQgaGF2ZW4ndCBiZWVuIGZhY3RvcmVkIGludG8gdGhlIF90b3RhbER1cmF0aW9uIHlldC4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIGEgcmVwZWF0ZWQgVHdlZW5NYXggYW5kIHRoZW4gaW1tZWRpYXRlbHkgY2hlY2sgaXRzIGR1cmF0aW9uKCksIGl0IHdvdWxkIGNhY2hlIHRoZSB2YWx1ZSBhbmQgdGhlIHRvdGFsRHVyYXRpb24gd291bGQgbm90IGJlIGNvcnJlY3QsIHRodXMgcmVwZWF0cyB3b3VsZG4ndCB0YWtlIGVmZmVjdC5cblx0XHRcdH1cblx0XHRcdHJldHVybiBBbmltYXRpb24ucHJvdG90eXBlLmR1cmF0aW9uLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdC8vaW5zdGVhZCBvZiBJbmZpbml0eSwgd2UgdXNlIDk5OTk5OTk5OTk5OSBzbyB0aGF0IHdlIGNhbiBhY2NvbW1vZGF0ZSByZXZlcnNlc1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsRHVyYXRpb24gPSAodGhpcy5fcmVwZWF0ID09PSAtMSkgPyA5OTk5OTk5OTk5OTkgOiB0aGlzLl9kdXJhdGlvbiAqICh0aGlzLl9yZXBlYXQgKyAxKSArICh0aGlzLl9yZXBlYXREZWxheSAqIHRoaXMuX3JlcGVhdCk7XG5cdFx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodGhpcy5fcmVwZWF0ID09PSAtMSkgPyB0aGlzIDogdGhpcy5kdXJhdGlvbiggKHZhbHVlIC0gKHRoaXMuX3JlcGVhdCAqIHRoaXMuX3JlcGVhdERlbGF5KSkgLyAodGhpcy5fcmVwZWF0ICsgMSkgKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAucmVwZWF0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAucmVwZWF0RGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAueW95byA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3lveW87XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl95b3lvID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHJldHVybiBUd2Vlbk1heDtcblx0XHRcblx0fSwgdHJ1ZSk7XG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRpbWVsaW5lTGl0ZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTGl0ZVwiLCBbXCJjb3JlLkFuaW1hdGlvblwiLFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLFwiVHdlZW5MaXRlXCJdLCBmdW5jdGlvbihBbmltYXRpb24sIFNpbXBsZVRpbWVsaW5lLCBUd2VlbkxpdGUpIHtcblxuXHRcdHZhciBUaW1lbGluZUxpdGUgPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRcdFNpbXBsZVRpbWVsaW5lLmNhbGwodGhpcywgdmFycyk7XG5cdFx0XHRcdHRoaXMuX2xhYmVscyA9IHt9O1xuXHRcdFx0XHR0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9ICh0aGlzLnZhcnMuYXV0b1JlbW92ZUNoaWxkcmVuID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9ICh0aGlzLnZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLl9zb3J0Q2hpbGRyZW4gPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZSA9IHRoaXMudmFycy5vblVwZGF0ZTtcblx0XHRcdFx0dmFyIHYgPSB0aGlzLnZhcnMsXG5cdFx0XHRcdFx0dmFsLCBwO1xuXHRcdFx0XHRmb3IgKHAgaW4gdikge1xuXHRcdFx0XHRcdHZhbCA9IHZbcF07XG5cdFx0XHRcdFx0aWYgKF9pc0FycmF5KHZhbCkpIGlmICh2YWwuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dltwXSA9IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXModmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9pc0FycmF5KHYudHdlZW5zKSkge1xuXHRcdFx0XHRcdHRoaXMuYWRkKHYudHdlZW5zLCAwLCB2LmFsaWduLCB2LnN0YWdnZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyxcblx0XHRcdF9pbnRlcm5hbHMgPSBUaW1lbGluZUxpdGUuX2ludGVybmFscyA9IHt9LFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNTZWxlY3Rvcixcblx0XHRcdF9pc0FycmF5ID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzQXJyYXksXG5cdFx0XHRfbGF6eVR3ZWVucyA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5VHdlZW5zLFxuXHRcdFx0X2xhenlSZW5kZXIgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVJlbmRlcixcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRfY29weSA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0dmFyIGNvcHkgPSB7fSwgcDtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRjb3B5W3BdID0gdmFyc1twXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29weTtcblx0XHRcdH0sXG5cdFx0XHRfYXBwbHlDeWNsZSA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldHMsIGkpIHtcblx0XHRcdFx0dmFyIGFsdCA9IHZhcnMuY3ljbGUsXG5cdFx0XHRcdFx0cCwgdmFsO1xuXHRcdFx0XHRmb3IgKHAgaW4gYWx0KSB7XG5cdFx0XHRcdFx0dmFsID0gYWx0W3BdO1xuXHRcdFx0XHRcdHZhcnNbcF0gPSAodHlwZW9mKHZhbCkgPT09IFwiZnVuY3Rpb25cIikgPyB2YWwuY2FsbCh0YXJnZXRzW2ldLCBpKSA6IHZhbFtpICUgdmFsLmxlbmd0aF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIHZhcnMuY3ljbGU7XG5cdFx0XHR9LFxuXHRcdFx0X3BhdXNlQ2FsbGJhY2sgPSBfaW50ZXJuYWxzLnBhdXNlQ2FsbGJhY2sgPSBmdW5jdGlvbigpIHt9LFxuXHRcdFx0X3NsaWNlID0gZnVuY3Rpb24oYSkgeyAvL2Rvbid0IHVzZSBbXS5zbGljZSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHR2YXIgYiA9IFtdLFxuXHRcdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpICE9PSBsOyBiLnB1c2goYVtpKytdKSk7XG5cdFx0XHRcdHJldHVybiBiO1xuXHRcdFx0fSxcblx0XHRcdHAgPSBUaW1lbGluZUxpdGUucHJvdG90eXBlID0gbmV3IFNpbXBsZVRpbWVsaW5lKCk7XG5cblx0XHRUaW1lbGluZUxpdGUudmVyc2lvbiA9IFwiMS4xOC40XCI7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFRpbWVsaW5lTGl0ZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBwLl9mb3JjaW5nUGxheWhlYWQgPSBwLl9oYXNQYXVzZSA9IGZhbHNlO1xuXG5cdFx0LyogbWlnaHQgdXNlIGxhdGVyLi4uXG5cdFx0Ly90cmFuc2xhdGVzIGEgbG9jYWwgdGltZSBpbnNpZGUgYW4gYW5pbWF0aW9uIHRvIHRoZSBjb3JyZXNwb25kaW5nIHRpbWUgb24gdGhlIHJvb3QvZ2xvYmFsIHRpbWVsaW5lLCBmYWN0b3JpbmcgaW4gYWxsIG5lc3RpbmcgYW5kIHRpbWVTY2FsZXMuXG5cdFx0ZnVuY3Rpb24gbG9jYWxUb0dsb2JhbCh0aW1lLCBhbmltYXRpb24pIHtcblx0XHRcdHdoaWxlIChhbmltYXRpb24pIHtcblx0XHRcdFx0dGltZSA9ICh0aW1lIC8gYW5pbWF0aW9uLl90aW1lU2NhbGUpICsgYW5pbWF0aW9uLl9zdGFydFRpbWU7XG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aW1lO1xuXHRcdH1cblxuXHRcdC8vdHJhbnNsYXRlcyB0aGUgc3VwcGxpZWQgdGltZSBvbiB0aGUgcm9vdC9nbG9iYWwgdGltZWxpbmUgaW50byB0aGUgY29ycmVzcG9uZGluZyBsb2NhbCB0aW1lIGluc2lkZSBhIHBhcnRpY3VsYXIgYW5pbWF0aW9uLCBmYWN0b3JpbmcgaW4gYWxsIG5lc3RpbmcgYW5kIHRpbWVTY2FsZXNcblx0XHRmdW5jdGlvbiBnbG9iYWxUb0xvY2FsKHRpbWUsIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIHNjYWxlID0gMTtcblx0XHRcdHRpbWUgLT0gbG9jYWxUb0dsb2JhbCgwLCBhbmltYXRpb24pO1xuXHRcdFx0d2hpbGUgKGFuaW1hdGlvbikge1xuXHRcdFx0XHRzY2FsZSAqPSBhbmltYXRpb24uX3RpbWVTY2FsZTtcblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRpbWUgKiBzY2FsZTtcblx0XHR9XG5cdFx0Ki9cblxuXHRcdHAudG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdFx0dmFyIEVuZ2luZSA9ICh2YXJzLnJlcGVhdCAmJiBfZ2xvYmFscy5Ud2Vlbk1heCkgfHwgVHdlZW5MaXRlO1xuXHRcdFx0cmV0dXJuIGR1cmF0aW9uID8gdGhpcy5hZGQoIG5ldyBFbmdpbmUodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyksIHBvc2l0aW9uKSA6IHRoaXMuc2V0KHRhcmdldCwgdmFycywgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLmZyb20gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCAoKHZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGUpLmZyb20odGFyZ2V0LCBkdXJhdGlvbiwgdmFycyksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5mcm9tVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBwb3NpdGlvbikge1xuXHRcdFx0dmFyIEVuZ2luZSA9ICh0b1ZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGU7XG5cdFx0XHRyZXR1cm4gZHVyYXRpb24gPyB0aGlzLmFkZCggRW5naW5lLmZyb21Ubyh0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzKSwgcG9zaXRpb24pIDogdGhpcy5zZXQodGFyZ2V0LCB0b1ZhcnMsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFnZ2VyVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dmFyIHRsID0gbmV3IFRpbWVsaW5lTGl0ZSh7b25Db21wbGV0ZTpvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlUGFyYW1zOm9uQ29tcGxldGVBbGxQYXJhbXMsIGNhbGxiYWNrU2NvcGU6b25Db21wbGV0ZUFsbFNjb3BlLCBzbW9vdGhDaGlsZFRpbWluZzp0aGlzLnNtb290aENoaWxkVGltaW5nfSksXG5cdFx0XHRcdGN5Y2xlID0gdmFycy5jeWNsZSxcblx0XHRcdFx0Y29weSwgaTtcblx0XHRcdGlmICh0eXBlb2YodGFyZ2V0cykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0dGFyZ2V0cyA9IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXRzKSB8fCB0YXJnZXRzO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0cyA9IHRhcmdldHMgfHwgW107XG5cdFx0XHRpZiAoX2lzU2VsZWN0b3IodGFyZ2V0cykpIHsgLy9zZW5zZXMgaWYgdGhlIHRhcmdldHMgb2JqZWN0IGlzIGEgc2VsZWN0b3IuIElmIGl0IGlzLCB3ZSBzaG91bGQgdHJhbnNsYXRlIGl0IGludG8gYW4gYXJyYXkuXG5cdFx0XHRcdHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0cyk7XG5cdFx0XHR9XG5cdFx0XHRzdGFnZ2VyID0gc3RhZ2dlciB8fCAwO1xuXHRcdFx0aWYgKHN0YWdnZXIgPCAwKSB7XG5cdFx0XHRcdHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0cyk7XG5cdFx0XHRcdHRhcmdldHMucmV2ZXJzZSgpO1xuXHRcdFx0XHRzdGFnZ2VyICo9IC0xO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29weSA9IF9jb3B5KHZhcnMpO1xuXHRcdFx0XHRpZiAoY29weS5zdGFydEF0KSB7XG5cdFx0XHRcdFx0Y29weS5zdGFydEF0ID0gX2NvcHkoY29weS5zdGFydEF0KTtcblx0XHRcdFx0XHRpZiAoY29weS5zdGFydEF0LmN5Y2xlKSB7XG5cdFx0XHRcdFx0XHRfYXBwbHlDeWNsZShjb3B5LnN0YXJ0QXQsIHRhcmdldHMsIGkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY3ljbGUpIHtcblx0XHRcdFx0XHRfYXBwbHlDeWNsZShjb3B5LCB0YXJnZXRzLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bC50byh0YXJnZXRzW2ldLCBkdXJhdGlvbiwgY29weSwgaSAqIHN0YWdnZXIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHRsLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlckZyb20gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFnZ2VyRnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXG5cdFx0cC5jYWxsID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoIFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24sIDAsIHRydWUpO1xuXHRcdFx0aWYgKHZhcnMuaW1tZWRpYXRlUmVuZGVyID09IG51bGwpIHtcblx0XHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAocG9zaXRpb24gPT09IHRoaXMuX3RpbWUgJiYgIXRoaXMuX3BhdXNlZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCAwLCB2YXJzKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCA9IGZ1bmN0aW9uKHZhcnMsIGlnbm9yZURlbGF5ZWRDYWxscykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHRpZiAodmFycy5zbW9vdGhDaGlsZFRpbWluZyA9PSBudWxsKSB7XG5cdFx0XHRcdHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gbmV3IFRpbWVsaW5lTGl0ZSh2YXJzKSxcblx0XHRcdFx0cm9vdCA9IHRsLl90aW1lbGluZSxcblx0XHRcdFx0dHdlZW4sIG5leHQ7XG5cdFx0XHRpZiAoaWdub3JlRGVsYXllZENhbGxzID09IG51bGwpIHtcblx0XHRcdFx0aWdub3JlRGVsYXllZENhbGxzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJvb3QuX3JlbW92ZSh0bCwgdHJ1ZSk7XG5cdFx0XHR0bC5fc3RhcnRUaW1lID0gMDtcblx0XHRcdHRsLl9yYXdQcmV2VGltZSA9IHRsLl90aW1lID0gdGwuX3RvdGFsVGltZSA9IHJvb3QuX3RpbWU7XG5cdFx0XHR0d2VlbiA9IHJvb3QuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0aWYgKCFpZ25vcmVEZWxheWVkQ2FsbHMgfHwgISh0d2VlbiBpbnN0YW5jZW9mIFR3ZWVuTGl0ZSAmJiB0d2Vlbi50YXJnZXQgPT09IHR3ZWVuLnZhcnMub25Db21wbGV0ZSkpIHtcblx0XHRcdFx0XHR0bC5hZGQodHdlZW4sIHR3ZWVuLl9zdGFydFRpbWUgLSB0d2Vlbi5fZGVsYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdH1cblx0XHRcdHJvb3QuYWRkKHRsLCAwKTtcblx0XHRcdHJldHVybiB0bDtcblx0XHR9O1xuXG5cdFx0cC5hZGQgPSBmdW5jdGlvbih2YWx1ZSwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHR2YXIgY3VyVGltZSwgbCwgaSwgY2hpbGQsIHRsLCBiZWZvcmVSYXdUaW1lO1xuXHRcdFx0aWYgKHR5cGVvZihwb3NpdGlvbikgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uLCAwLCB0cnVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFuaW1hdGlvbikpIHtcblx0XHRcdFx0aWYgKCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB8fCAodmFsdWUgJiYgdmFsdWUucHVzaCAmJiBfaXNBcnJheSh2YWx1ZSkpKSB7XG5cdFx0XHRcdFx0YWxpZ24gPSBhbGlnbiB8fCBcIm5vcm1hbFwiO1xuXHRcdFx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHRcdFx0Y3VyVGltZSA9IHBvc2l0aW9uO1xuXHRcdFx0XHRcdGwgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKF9pc0FycmF5KGNoaWxkID0gdmFsdWVbaV0pKSB7XG5cdFx0XHRcdFx0XHRcdGNoaWxkID0gbmV3IFRpbWVsaW5lTGl0ZSh7dHdlZW5zOmNoaWxkfSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmFkZChjaGlsZCwgY3VyVGltZSk7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGNoaWxkKSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YoY2hpbGQpICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFsaWduID09PSBcInNlcXVlbmNlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRjdXJUaW1lID0gY2hpbGQuX3N0YXJ0VGltZSArIChjaGlsZC50b3RhbER1cmF0aW9uKCkgLyBjaGlsZC5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChhbGlnbiA9PT0gXCJzdGFydFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGQuX3N0YXJ0VGltZSAtPSBjaGlsZC5kZWxheSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJUaW1lICs9IHN0YWdnZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRMYWJlbCh2YWx1ZSwgcG9zaXRpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHZhbHVlID0gVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyhcIkNhbm5vdCBhZGQgXCIgKyB2YWx1ZSArIFwiIGludG8gdGhlIHRpbWVsaW5lOyBpdCBpcyBub3QgYSB0d2VlbiwgdGltZWxpbmUsIGZ1bmN0aW9uLCBvciBzdHJpbmcuXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCB2YWx1ZSwgcG9zaXRpb24pO1xuXG5cdFx0XHQvL2lmIHRoZSB0aW1lbGluZSBoYXMgYWxyZWFkeSBlbmRlZCBidXQgdGhlIGluc2VydGVkIHR3ZWVuL3RpbWVsaW5lIGV4dGVuZHMgdGhlIGR1cmF0aW9uLCB3ZSBzaG91bGQgZW5hYmxlIHRoaXMgdGltZWxpbmUgYWdhaW4gc28gdGhhdCBpdCByZW5kZXJzIHByb3Blcmx5LiBXZSBzaG91bGQgYWxzbyBhbGlnbiB0aGUgcGxheWhlYWQgd2l0aCB0aGUgcGFyZW50IHRpbWVsaW5lJ3Mgd2hlbiBhcHByb3ByaWF0ZS5cblx0XHRcdGlmICh0aGlzLl9nYyB8fCB0aGlzLl90aW1lID09PSB0aGlzLl9kdXJhdGlvbikgaWYgKCF0aGlzLl9wYXVzZWQpIGlmICh0aGlzLl9kdXJhdGlvbiA8IHRoaXMuZHVyYXRpb24oKSkge1xuXHRcdFx0XHQvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG5cdFx0XHRcdHRsID0gdGhpcztcblx0XHRcdFx0YmVmb3JlUmF3VGltZSA9ICh0bC5yYXdUaW1lKCkgPiB2YWx1ZS5fc3RhcnRUaW1lKTsgLy9pZiB0aGUgdHdlZW4gaXMgcGxhY2VkIG9uIHRoZSB0aW1lbGluZSBzbyB0aGF0IGl0IHN0YXJ0cyBCRUZPUkUgdGhlIGN1cnJlbnQgcmF3VGltZSwgd2Ugc2hvdWxkIGFsaWduIHRoZSBwbGF5aGVhZCAobW92ZSB0aGUgdGltZWxpbmUpLiBUaGlzIGlzIGJlY2F1c2Ugc29tZXRpbWVzIHVzZXJzIHdpbGwgY3JlYXRlIGEgdGltZWxpbmUsIGxldCBpdCBmaW5pc2gsIGFuZCBtdWNoIGxhdGVyIGFwcGVuZCBhIHR3ZWVuIGFuZCBleHBlY3QgaXQgdG8gcnVuIGluc3RlYWQgb2YganVtcGluZyB0byBpdHMgZW5kIHN0YXRlLiBXaGlsZSB0ZWNobmljYWxseSBvbmUgY291bGQgYXJndWUgdGhhdCBpdCBzaG91bGQganVtcCB0byBpdHMgZW5kIHN0YXRlLCB0aGF0J3Mgbm90IHdoYXQgdXNlcnMgaW50dWl0aXZlbHkgZXhwZWN0LlxuXHRcdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0aWYgKGJlZm9yZVJhd1RpbWUgJiYgdGwuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0XHR0bC50b3RhbFRpbWUodGwuX3RvdGFsVGltZSwgdHJ1ZSk7IC8vbW92ZXMgdGhlIHRpbWVsaW5lIChzaGlmdHMgaXRzIHN0YXJ0VGltZSkgaWYgbmVjZXNzYXJ5LCBhbmQgYWxzbyBlbmFibGVzIGl0LlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGwuX2djKSB7XG5cdFx0XHRcdFx0XHR0bC5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBbmltYXRpb24pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlKHZhbHVlLCBmYWxzZSk7XG5cdFx0XHRcdHZhciB0bCA9IHZhbHVlLl90aW1lbGluZSA9IHZhbHVlLnZhcnMudXNlRnJhbWVzID8gQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmUgOiBBbmltYXRpb24uX3Jvb3RUaW1lbGluZTsgLy9ub3cgdGhhdCBpdCdzIHJlbW92ZWQsIGRlZmF1bHQgaXQgdG8gdGhlIHJvb3QgdGltZWxpbmUgc28gdGhhdCBpZiBpdCBnZXRzIHBsYXllZCBhZ2FpbiwgaXQgZG9lc24ndCBqdW1wIGJhY2sgaW50byB0aGlzIHRpbWVsaW5lLlxuXHRcdFx0XHR2YWx1ZS5fc3RhcnRUaW1lID0gKHZhbHVlLl9wYXVzZWQgPyB2YWx1ZS5fcGF1c2VUaW1lIDogdGwuX3RpbWUpIC0gKCghdmFsdWUuX3JldmVyc2VkID8gdmFsdWUuX3RvdGFsVGltZSA6IHZhbHVlLnRvdGFsRHVyYXRpb24oKSAtIHZhbHVlLl90b3RhbFRpbWUpIC8gdmFsdWUuX3RpbWVTY2FsZSk7IC8vZW5zdXJlIHRoYXQgaWYgaXQgZ2V0cyBwbGF5ZWQgYWdhaW4sIHRoZSB0aW1pbmcgaXMgY29ycmVjdC5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgfHwgKHZhbHVlICYmIHZhbHVlLnB1c2ggJiYgX2lzQXJyYXkodmFsdWUpKSkge1xuXHRcdFx0XHR2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmUodmFsdWVbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlbW92ZUxhYmVsKHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmtpbGwobnVsbCwgdmFsdWUpO1xuXHRcdH07XG5cblx0XHRwLl9yZW1vdmUgPSBmdW5jdGlvbih0d2Vlbiwgc2tpcERpc2FibGUpIHtcblx0XHRcdFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5fcmVtb3ZlLmNhbGwodGhpcywgdHdlZW4sIHNraXBEaXNhYmxlKTtcblx0XHRcdHZhciBsYXN0ID0gdGhpcy5fbGFzdDtcblx0XHRcdGlmICghbGFzdCkge1xuXHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lID0gdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gMDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSA+IGxhc3QuX3N0YXJ0VGltZSArIGxhc3QuX3RvdGFsRHVyYXRpb24gLyBsYXN0Ll90aW1lU2NhbGUpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb24oKTtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdG90YWxEdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmFwcGVuZCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXRPckxhYmVsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodmFsdWUsIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwobnVsbCwgb2Zmc2V0T3JMYWJlbCwgdHJ1ZSwgdmFsdWUpKTtcblx0XHR9O1xuXG5cdFx0cC5pbnNlcnQgPSBwLmluc2VydE11bHRpcGxlID0gZnVuY3Rpb24odmFsdWUsIHBvc2l0aW9uLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHZhbHVlLCBwb3NpdGlvbiB8fCAwLCBhbGlnbiwgc3RhZ2dlcik7XG5cdFx0fTtcblxuXHRcdHAuYXBwZW5kTXVsdGlwbGUgPSBmdW5jdGlvbih0d2VlbnMsIG9mZnNldE9yTGFiZWwsIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodHdlZW5zLCB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG51bGwsIG9mZnNldE9yTGFiZWwsIHRydWUsIHR3ZWVucyksIGFsaWduLCBzdGFnZ2VyKTtcblx0XHR9O1xuXG5cdFx0cC5hZGRMYWJlbCA9IGZ1bmN0aW9uKGxhYmVsLCBwb3NpdGlvbikge1xuXHRcdFx0dGhpcy5fbGFiZWxzW2xhYmVsXSA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuYWRkUGF1c2UgPSBmdW5jdGlvbihwb3NpdGlvbiwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdHZhciB0ID0gVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIF9wYXVzZUNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlIHx8IHRoaXMpO1xuXHRcdFx0dC52YXJzLm9uQ29tcGxldGUgPSB0LnZhcnMub25SZXZlcnNlQ29tcGxldGUgPSBjYWxsYmFjaztcblx0XHRcdHQuZGF0YSA9IFwiaXNQYXVzZVwiO1xuXHRcdFx0dGhpcy5faGFzUGF1c2UgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHQsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5yZW1vdmVMYWJlbCA9IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fbGFiZWxzW2xhYmVsXTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmdldExhYmVsVGltZSA9IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX2xhYmVsc1tsYWJlbF0gIT0gbnVsbCkgPyB0aGlzLl9sYWJlbHNbbGFiZWxdIDogLTE7XG5cdFx0fTtcblxuXHRcdHAuX3BhcnNlVGltZU9yTGFiZWwgPSBmdW5jdGlvbih0aW1lT3JMYWJlbCwgb2Zmc2V0T3JMYWJlbCwgYXBwZW5kSWZBYnNlbnQsIGlnbm9yZSkge1xuXHRcdFx0dmFyIGk7XG5cdFx0XHQvL2lmIHdlJ3JlIGFib3V0IHRvIGFkZCBhIHR3ZWVuL3RpbWVsaW5lIChvciBhbiBhcnJheSBvZiB0aGVtKSB0aGF0J3MgYWxyZWFkeSBhIGNoaWxkIG9mIHRoaXMgdGltZWxpbmUsIHdlIHNob3VsZCByZW1vdmUgaXQgZmlyc3Qgc28gdGhhdCBpdCBkb2Vzbid0IGNvbnRhbWluYXRlIHRoZSBkdXJhdGlvbigpLlxuXHRcdFx0aWYgKGlnbm9yZSBpbnN0YW5jZW9mIEFuaW1hdGlvbiAmJiBpZ25vcmUudGltZWxpbmUgPT09IHRoaXMpIHtcblx0XHRcdFx0dGhpcy5yZW1vdmUoaWdub3JlKTtcblx0XHRcdH0gZWxzZSBpZiAoaWdub3JlICYmICgoaWdub3JlIGluc3RhbmNlb2YgQXJyYXkpIHx8IChpZ25vcmUucHVzaCAmJiBfaXNBcnJheShpZ25vcmUpKSkpIHtcblx0XHRcdFx0aSA9IGlnbm9yZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChpZ25vcmVbaV0gaW5zdGFuY2VvZiBBbmltYXRpb24gJiYgaWdub3JlW2ldLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbW92ZShpZ25vcmVbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZihvZmZzZXRPckxhYmVsKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChvZmZzZXRPckxhYmVsLCAoYXBwZW5kSWZBYnNlbnQgJiYgdHlwZW9mKHRpbWVPckxhYmVsKSA9PT0gXCJudW1iZXJcIiAmJiB0aGlzLl9sYWJlbHNbb2Zmc2V0T3JMYWJlbF0gPT0gbnVsbCkgPyB0aW1lT3JMYWJlbCAtIHRoaXMuZHVyYXRpb24oKSA6IDAsIGFwcGVuZElmQWJzZW50KTtcblx0XHRcdH1cblx0XHRcdG9mZnNldE9yTGFiZWwgPSBvZmZzZXRPckxhYmVsIHx8IDA7XG5cdFx0XHRpZiAodHlwZW9mKHRpbWVPckxhYmVsKSA9PT0gXCJzdHJpbmdcIiAmJiAoaXNOYU4odGltZU9yTGFiZWwpIHx8IHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gIT0gbnVsbCkpIHsgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cblx0XHRcdFx0aSA9IHRpbWVPckxhYmVsLmluZGV4T2YoXCI9XCIpO1xuXHRcdFx0XHRpZiAoaSA9PT0gLTEpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYXBwZW5kSWZBYnNlbnQgPyAodGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSA9IHRoaXMuZHVyYXRpb24oKSArIG9mZnNldE9yTGFiZWwpIDogb2Zmc2V0T3JMYWJlbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gKyBvZmZzZXRPckxhYmVsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9mZnNldE9yTGFiZWwgPSBwYXJzZUludCh0aW1lT3JMYWJlbC5jaGFyQXQoaS0xKSArIFwiMVwiLCAxMCkgKiBOdW1iZXIodGltZU9yTGFiZWwuc3Vic3RyKGkrMSkpO1xuXHRcdFx0XHR0aW1lT3JMYWJlbCA9IChpID4gMSkgPyB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHRpbWVPckxhYmVsLnN1YnN0cigwLCBpLTEpLCAwLCBhcHBlbmRJZkFic2VudCkgOiB0aGlzLmR1cmF0aW9uKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRpbWVPckxhYmVsID09IG51bGwpIHtcblx0XHRcdFx0dGltZU9yTGFiZWwgPSB0aGlzLmR1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gTnVtYmVyKHRpbWVPckxhYmVsKSArIG9mZnNldE9yTGFiZWw7XG5cdFx0fTtcblxuXHRcdHAuc2VlayA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKCh0eXBlb2YocG9zaXRpb24pID09PSBcIm51bWJlclwiKSA/IHBvc2l0aW9uIDogdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbiksIChzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpKTtcblx0XHR9O1xuXG5cdFx0cC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAuZ290b0FuZFBsYXkgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBsYXkocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2UocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHZhciB0b3RhbER1ciA9ICghdGhpcy5fZGlydHkpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMudG90YWxEdXJhdGlvbigpLFxuXHRcdFx0XHRwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cHJldlRpbWVTY2FsZSA9IHRoaXMuX3RpbWVTY2FsZSxcblx0XHRcdFx0cHJldlBhdXNlZCA9IHRoaXMuX3BhdXNlZCxcblx0XHRcdFx0dHdlZW4sIGlzQ29tcGxldGUsIG5leHQsIGNhbGxiYWNrLCBpbnRlcm5hbEZvcmNlLCBwYXVzZVR3ZWVuLCBjdXJUaW1lO1xuXHRcdFx0aWYgKHRpbWUgPj0gdG90YWxEdXIgLSAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdG90YWxEdXI7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIGlmICghdGhpcy5faGFzUGF1c2VkQ2hpbGQoKSkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9ICEhdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0XHRpZiAodGhpcy5fZHVyYXRpb24gPT09IDApIGlmICgodGltZSA8PSAwICYmIHRpbWUgPj0gLTAuMDAwMDAwMSkgfHwgdGhpcy5fcmF3UHJldlRpbWUgPCAwIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSBfdGlueU51bSkgaWYgKHRoaXMuX3Jhd1ByZXZUaW1lICE9PSB0aW1lICYmIHRoaXMuX2ZpcnN0KSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLl9yYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9ICh0aGlzLl9kdXJhdGlvbiB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdHRpbWUgPSB0b3RhbER1ciArIDAuMDAwMTsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAtIHNvbWV0aW1lcyBjaGlsZCB0d2VlbnMvdGltZWxpbmVzIHdlcmUgbm90IGJlaW5nIGZ1bGx5IGNvbXBsZXRlZCAodGhlaXIgcHJvZ3Jlc3MgbWlnaHQgYmUgMC45OTk5OTk5OTk5OTk5OTggaW5zdGVhZCBvZiAxIGJlY2F1c2Ugd2hlbiBfdGltZSAtIHR3ZWVuLl9zdGFydFRpbWUgaXMgcGVyZm9ybWVkLCBmbG9hdGluZyBwb2ludCBlcnJvcnMgd291bGQgcmV0dXJuIGEgdmFsdWUgdGhhdCB3YXMgU0xJR0hUTFkgb2ZmKS4gVHJ5ICg5OTk5OTk5OTk5OTkuNyAtIDk5OTk5OTk5OTk5OSkgKiAxID0gMC42OTk5NTExNzE4NzUgaW5zdGVhZCBvZiAwLjcuXG5cblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSAwIHx8ICh0aGlzLl9kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0gJiYgKHRoaXMuX3Jhd1ByZXZUaW1lID4gMCB8fCAodGltZSA8IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPj0gMCkpKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuICYmIHRoaXMuX3JldmVyc2VkKSB7IC8vZW5zdXJlcyBwcm9wZXIgR0MgaWYgYSB0aW1lbGluZSBpcyByZXN1bWVkIGFmdGVyIGl0J3MgZmluaXNoZWQgcmV2ZXJzaW5nLlxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9yYXdQcmV2VGltZSA+PSAwICYmIHRoaXMuX2ZpcnN0KSB7IC8vd2hlbiBnb2luZyBiYWNrIGJleW9uZCB0aGUgc3RhcnQsIGZvcmNlIGEgcmVuZGVyIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgdGhhdCBzaXQgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIHJlbmRlciB0aGVpciBzdGFydCB2YWx1ZXMgcHJvcGVybHkuIE90aGVyd2lzZSwgaWYgdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGxhbmRzIGV4YWN0bHkgYXQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSwgYW5kIHRoZW4gbW92ZXMgYmFja3dhcmRzLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIGJlZ2lubmluZyB3b3VsZCBzdGlsbCBiZSBhdCB0aGVpciBlbmQgc3RhdGUuXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHRpZiAodGltZSA9PT0gMCAmJiBpc0NvbXBsZXRlKSB7IC8vaWYgdGhlcmUncyBhIHplcm8tZHVyYXRpb24gdHdlZW4gYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGEgdGltZWxpbmUgYW5kIHRoZSBwbGF5aGVhZCBsYW5kcyBFWEFDVExZIGF0IHRpbWUgMCwgdGhhdCB0d2VlbiB3aWxsIGNvcnJlY3RseSByZW5kZXIgaXRzIGVuZCB2YWx1ZXMsIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHRpbWVsaW5lIGFsaXZlIGZvciBvbmUgbW9yZSByZW5kZXIgc28gdGhhdCB0aGUgYmVnaW5uaW5nIHZhbHVlcyByZW5kZXIgcHJvcGVybHkgYXMgdGhlIHBhcmVudCdzIHBsYXloZWFkIGtlZXBzIG1vdmluZyBiZXlvbmQgdGhlIGJlZ2luaW5nLiBJbWFnaW5lIG9iai54IHN0YXJ0cyBhdCAwIGFuZCB0aGVuIHdlIGRvIHRsLnNldChvYmosIHt4OjEwMH0pLnRvKG9iaiwgMSwge3g6MjAwfSkgYW5kIHRoZW4gbGF0ZXIgd2UgdGwucmV2ZXJzZSgpLi4udGhlIGdvYWwgaXMgdG8gaGF2ZSBvYmoueCByZXZlcnQgdG8gMC4gSWYgdGhlIHBsYXloZWFkIGhhcHBlbnMgdG8gbGFuZCBvbiBleGFjdGx5IDAsIHdpdGhvdXQgdGhpcyBjaHVuayBvZiBjb2RlLCBpdCdkIGNvbXBsZXRlIHRoZSB0aW1lbGluZSBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHJlbmRlcmluZyBxdWV1ZSAobm90IGdvb2QpLlxuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0aXNDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWUgPSAwOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIChjb3VsZCBjYXVzZSBwcm9ibGVtcyBlc3BlY2lhbGx5IHdpdGggemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSlcblx0XHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZ1BsYXloZWFkICYmICFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IHByZXZUaW1lKSB7XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPD0gdGltZSAmJiAhcGF1c2VUd2Vlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikgaWYgKHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmICF0d2Vlbi5yYXRpbyAmJiAhKHR3ZWVuLl9zdGFydFRpbWUgPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPT09IDApKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lID49IHRpbWUgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIGlmICh0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIiAmJiB0d2Vlbi5fcmF3UHJldlRpbWUgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGltZSA9IHBhdXNlVHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRpbWUgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fdG90YWxEdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICgodGhpcy5fdGltZSA9PT0gcHJldlRpbWUgfHwgIXRoaXMuX2ZpcnN0KSAmJiAhZm9yY2UgJiYgIWludGVybmFsRm9yY2UgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RpbWUgIT09IHByZXZUaW1lICYmIHRpbWUgPiAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7ICAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyB0aGUgdGltZWxpbmUgKGFzIG9wcG9zZWQgdG8gdGhlIHBhcmVudCB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCBpdCBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0aW1lbGluZSBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZSwgZm9yIGV4YW1wbGUuXG5cdFx0XHR9XG5cblx0XHRcdGlmIChwcmV2VGltZSA9PT0gMCkgaWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdGltZSAhPT0gMCkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIik7XG5cdFx0XHR9XG5cblx0XHRcdGN1clRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0aWYgKGN1clRpbWUgPj0gcHJldlRpbWUpIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAoY3VyVGltZSAhPT0gdGhpcy5fdGltZSB8fCAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHR3ZWVuLl9zdGFydFRpbWUgPD0gY3VyVGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4gPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKGN1clRpbWUgIT09IHRoaXMuX3RpbWUgfHwgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IHByZXZUaW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAocGF1c2VUd2VlbiA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuLl9wcmV2OyAvL3RoZSBsaW5rZWQgbGlzdCBpcyBvcmdhbml6ZWQgYnkgX3N0YXJ0VGltZSwgdGh1cyBpdCdzIHBvc3NpYmxlIHRoYXQgYSB0d2VlbiBjb3VsZCBzdGFydCBCRUZPUkUgdGhlIHBhdXNlIGFuZCBlbmQgYWZ0ZXIgaXQsIGluIHdoaWNoIGNhc2UgaXQgd291bGQgYmUgcG9zaXRpb25lZCBiZWZvcmUgdGhlIHBhdXNlIHR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCwgYnV0IHdlIHNob3VsZCByZW5kZXIgaXQgYmVmb3JlIHdlIHBhdXNlKCkgdGhlIHRpbWVsaW5lIGFuZCBjZWFzZSByZW5kZXJpbmcuIFRoaXMgaXMgb25seSBhIGNvbmNlcm4gd2hlbiBnb2luZyBpbiByZXZlcnNlLlxuXHRcdFx0XHRcdFx0XHR3aGlsZSAocGF1c2VUd2VlbiAmJiBwYXVzZVR3ZWVuLmVuZFRpbWUoKSA+IHRoaXMuX3RpbWUpIHtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuLnJlbmRlciggKHBhdXNlVHdlZW4uX3JldmVyc2VkID8gcGF1c2VUd2Vlbi50b3RhbER1cmF0aW9uKCkgLSAoKHRpbWUgLSBwYXVzZVR3ZWVuLl9zdGFydFRpbWUpICogcGF1c2VUd2Vlbi5fdGltZVNjYWxlKSA6ICh0aW1lIC0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lKSAqIHBhdXNlVHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHBhdXNlVHdlZW4uX3ByZXY7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25VcGRhdGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2djKSBpZiAocHJldlN0YXJ0ID09PSB0aGlzLl9zdGFydFRpbWUgfHwgcHJldlRpbWVTY2FsZSAhPT0gdGhpcy5fdGltZVNjYWxlKSBpZiAodGhpcy5fdGltZSA9PT0gMCB8fCB0b3RhbER1ciA+PSB0aGlzLnRvdGFsRHVyYXRpb24oKSkgeyAvL2lmIG9uZSBvZiB0aGUgdHdlZW5zIHRoYXQgd2FzIHJlbmRlcmVkIGFsdGVyZWQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSAobGlrZSBpZiBhbiBvbkNvbXBsZXRlIHJldmVyc2VkIHRoZSB0aW1lbGluZSksIGl0IHByb2JhYmx5IGlzbid0IGNvbXBsZXRlLiBJZiBpdCBpcywgZG9uJ3Qgd29ycnksIGJlY2F1c2Ugd2hhdGV2ZXIgY2FsbCBhbHRlcmVkIHRoZSBzdGFydFRpbWUgd291bGQgY29tcGxldGUgaWYgaXQgd2FzIG5lY2Vzc2FyeSBhdCB0aGUgbmV3IHRpbWUuIFRoZSBvbmx5IGV4Y2VwdGlvbiBpcyB0aGUgdGltZVNjYWxlIHByb3BlcnR5LiBBbHNvIGNoZWNrIF9nYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmIChpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uQ29tcGxldGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXHRcdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzICYmIHRoaXMudmFyc1tjYWxsYmFja10pIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5faGFzUGF1c2VkQ2hpbGQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fcGF1c2VkIHx8ICgodHdlZW4gaW5zdGFuY2VvZiBUaW1lbGluZUxpdGUpICYmIHR3ZWVuLl9oYXNQYXVzZWRDaGlsZCgpKSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRpZ25vcmVCZWZvcmVUaW1lID0gaWdub3JlQmVmb3JlVGltZSB8fCAtOTk5OTk5OTk5OTtcblx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdGNudCA9IDA7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0Ly9kbyBub3RoaW5nXG5cdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4gaW5zdGFuY2VvZiBUd2VlbkxpdGUpIHtcblx0XHRcdFx0XHRpZiAodHdlZW5zICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRpbWVsaW5lcyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChuZXN0ZWQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRhID0gYS5jb25jYXQodHdlZW4uZ2V0Q2hpbGRyZW4odHJ1ZSwgdHdlZW5zLCB0aW1lbGluZXMpKTtcblx0XHRcdFx0XHRcdGNudCA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdHAuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbih0YXJnZXQsIG5lc3RlZCkge1xuXHRcdFx0dmFyIGRpc2FibGVkID0gdGhpcy5fZ2MsXG5cdFx0XHRcdGEgPSBbXSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0dHdlZW5zLCBpO1xuXHRcdFx0aWYgKGRpc2FibGVkKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgdHJ1ZSk7IC8vZ2V0VHdlZW5zT2YoKSBmaWx0ZXJzIG91dCBkaXNhYmxlZCB0d2VlbnMsIGFuZCB3ZSBoYXZlIHRvIG1hcmsgdGhlbSBhcyBfZ2MgPSB0cnVlIHdoZW4gdGhlIHRpbWVsaW5lIGNvbXBsZXRlcyBpbiBvcmRlciB0byBhbGxvdyBjbGVhbiBnYXJiYWdlIGNvbGxlY3Rpb24sIHNvIHRlbXBvcmFyaWx5IHJlLWVuYWJsZSB0aGUgdGltZWxpbmUgaGVyZS5cblx0XHRcdH1cblx0XHRcdHR3ZWVucyA9IFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXQpO1xuXHRcdFx0aSA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHR3ZWVuc1tpXS50aW1lbGluZSA9PT0gdGhpcyB8fCAobmVzdGVkICYmIHRoaXMuX2NvbnRhaW5zKHR3ZWVuc1tpXSkpKSB7XG5cdFx0XHRcdFx0YVtjbnQrK10gPSB0d2VlbnNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkaXNhYmxlZCkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRwLnJlY2VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlY2VudDtcblx0XHR9O1xuXG5cdFx0cC5fY29udGFpbnMgPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdFx0dmFyIHRsID0gdHdlZW4udGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodGwpIHtcblx0XHRcdFx0aWYgKHRsID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGwgPSB0bC50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5zaGlmdENoaWxkcmVuID0gZnVuY3Rpb24oYW1vdW50LCBhZGp1c3RMYWJlbHMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdGlnbm9yZUJlZm9yZVRpbWUgPSBpZ25vcmVCZWZvcmVUaW1lIHx8IDA7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0bGFiZWxzID0gdGhpcy5fbGFiZWxzLFxuXHRcdFx0XHRwO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0XHR0d2Vlbi5fc3RhcnRUaW1lICs9IGFtb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFkanVzdExhYmVscykge1xuXHRcdFx0XHRmb3IgKHAgaW4gbGFiZWxzKSB7XG5cdFx0XHRcdFx0aWYgKGxhYmVsc1twXSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0XHRsYWJlbHNbcF0gKz0gYW1vdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdGlmICghdmFycyAmJiAhdGFyZ2V0KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdHdlZW5zID0gKCF0YXJnZXQpID8gdGhpcy5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkgOiB0aGlzLmdldFR3ZWVuc09mKHRhcmdldCksXG5cdFx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoLFxuXHRcdFx0XHRjaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHR3ZWVuc1tpXS5fa2lsbCh2YXJzLCB0YXJnZXQpKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHRwLmNsZWFyID0gZnVuY3Rpb24obGFiZWxzKSB7XG5cdFx0XHR2YXIgdHdlZW5zID0gdGhpcy5nZXRDaGlsZHJlbihmYWxzZSwgdHJ1ZSwgdHJ1ZSksXG5cdFx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IDA7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0dHdlZW5zW2ldLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGFiZWxzICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9sYWJlbHMgPSB7fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVuLmludmFsaWRhdGUoKTtcblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBBbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTs7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbihlbmFibGVkLCBpZ25vcmVUaW1lbGluZSkge1xuXHRcdFx0aWYgKGVuYWJsZWQgPT09IHRoaXMuX2djKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHR0d2Vlbi5fZW5hYmxlZChlbmFibGVkLCB0cnVlKTtcblx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2ltcGxlVGltZWxpbmUucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcywgZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsVGltZSA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCB1bmNhcHBlZCkge1xuXHRcdFx0dGhpcy5fZm9yY2luZ1BsYXloZWFkID0gdHJ1ZTtcblx0XHRcdHZhciB2YWwgPSBBbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5fZm9yY2luZ1BsYXloZWFkID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH07XG5cblx0XHRwLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTsgLy9qdXN0IHRyaWdnZXJzIHJlY2FsY3VsYXRpb25cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5kdXJhdGlvbigpICE9PSAwICYmIHZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHRoaXMudGltZVNjYWxlKHRoaXMuX2R1cmF0aW9uIC8gdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0dmFyIG1heCA9IDAsXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3QsXG5cdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSA5OTk5OTk5OTk5OTksXG5cdFx0XHRcdFx0XHRwcmV2LCBlbmQ7XG5cdFx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRwcmV2ID0gdHdlZW4uX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgaW4gY2FzZSB0aGUgdHdlZW4gY2hhbmdlcyBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2UuLi5cblx0XHRcdFx0XHRcdGlmICh0d2Vlbi5fZGlydHkpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4udG90YWxEdXJhdGlvbigpOyAvL2NvdWxkIGNoYW5nZSB0aGUgdHdlZW4uX3N0YXJ0VGltZSwgc28gbWFrZSBzdXJlIHRoZSB0d2VlbidzIGNhY2hlIGlzIGNsZWFuIGJlZm9yZSBhbmFseXppbmcgaXQuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA+IHByZXZTdGFydCAmJiB0aGlzLl9zb3J0Q2hpbGRyZW4gJiYgIXR3ZWVuLl9wYXVzZWQpIHsgLy9pbiBjYXNlIG9uZSBvZiB0aGUgdHdlZW5zIHNoaWZ0ZWQgb3V0IG9mIG9yZGVyLCBpdCBuZWVkcyB0byBiZSByZS1pbnNlcnRlZCBpbnRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZVxuXHRcdFx0XHRcdFx0XHR0aGlzLmFkZCh0d2VlbiwgdHdlZW4uX3N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPCAwICYmICF0d2Vlbi5fcGF1c2VkKSB7IC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXG5cdFx0XHRcdFx0XHRcdG1heCAtPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgKz0gdHdlZW4uX3N0YXJ0VGltZSAvIHRoaXMuX3RpbWVTY2FsZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0aGlzLnNoaWZ0Q2hpbGRyZW4oLXR3ZWVuLl9zdGFydFRpbWUsIGZhbHNlLCAtOTk5OTk5OTk5OSk7XG5cdFx0XHRcdFx0XHRcdHByZXZTdGFydCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbmQgPSB0d2Vlbi5fc3RhcnRUaW1lICsgKHR3ZWVuLl90b3RhbER1cmF0aW9uIC8gdHdlZW4uX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0XHRpZiAoZW5kID4gbWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1heCA9IGVuZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHR3ZWVuID0gcHJldjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gbWF4O1xuXHRcdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHZhbHVlICYmIHRoaXMudG90YWxEdXJhdGlvbigpKSA/IHRoaXMudGltZVNjYWxlKHRoaXMuX3RvdGFsRHVyYXRpb24gLyB2YWx1ZSkgOiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIXZhbHVlKSB7IC8vaWYgdGhlcmUncyBhIHBhdXNlIGRpcmVjdGx5IGF0IHRoZSBzcG90IGZyb20gd2hlcmUgd2UncmUgdW5wYXVzaW5nLCBza2lwIGl0LlxuXHRcdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPT09IHRpbWUgJiYgdHdlZW4uZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLl9yYXdQcmV2VGltZSA9IDA7IC8vcmVtZW1iZXIsIF9yYXdQcmV2VGltZSBpcyBob3cgemVyby1kdXJhdGlvbiB0d2VlbnMvY2FsbGJhY2tzIHNlbnNlIGRpcmVjdGlvbmFsaXR5IGFuZCBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gZmlyZS4gSWYgX3Jhd1ByZXZUaW1lIGlzIHRoZSBzYW1lIGFzIF9zdGFydFRpbWUgb24gdGhlIG5leHQgcmVuZGVyLCBpdCB3b24ndCBmaXJlLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQW5pbWF0aW9uLnByb3RvdHlwZS5wYXVzZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXG5cdFx0cC51c2VzRnJhbWVzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGwgPSB0aGlzLl90aW1lbGluZTtcblx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHRsID09PSBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSk7XG5cdFx0fTtcblxuXHRcdHAucmF3VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BhdXNlZCA/IHRoaXMuX3RvdGFsVGltZSA6ICh0aGlzLl90aW1lbGluZS5yYXdUaW1lKCkgLSB0aGlzLl9zdGFydFRpbWUpICogdGhpcy5fdGltZVNjYWxlO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gVGltZWxpbmVMaXRlO1xuXG5cdH0sIHRydWUpO1xuXG5cblxuXG5cblxuXG5cblx0XG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRpbWVsaW5lTWF4XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwiVGltZWxpbmVNYXhcIiwgW1wiVGltZWxpbmVMaXRlXCIsXCJUd2VlbkxpdGVcIixcImVhc2luZy5FYXNlXCJdLCBmdW5jdGlvbihUaW1lbGluZUxpdGUsIFR3ZWVuTGl0ZSwgRWFzZSkge1xuXG5cdFx0dmFyIFRpbWVsaW5lTWF4ID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0XHRUaW1lbGluZUxpdGUuY2FsbCh0aGlzLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHRoaXMudmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyxcblx0XHRcdF9sYXp5VHdlZW5zID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlUd2VlbnMsXG5cdFx0XHRfbGF6eVJlbmRlciA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5UmVuZGVyLFxuXHRcdFx0X2Vhc2VOb25lID0gbmV3IEVhc2UobnVsbCwgbnVsbCwgMSwgMCksXG5cdFx0XHRwID0gVGltZWxpbmVNYXgucHJvdG90eXBlID0gbmV3IFRpbWVsaW5lTGl0ZSgpO1xuXG5cdFx0cC5jb25zdHJ1Y3RvciA9IFRpbWVsaW5lTWF4O1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXHRcdFRpbWVsaW5lTWF4LnZlcnNpb24gPSBcIjEuMTguNFwiO1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlKTtcblx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdGhpcy52YXJzLnJlcGVhdERlbGF5IHx8IDA7XG5cdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0cmV0dXJuIFRpbWVsaW5lTGl0ZS5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdH07XG5cblx0XHRwLmFkZENhbGxiYWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBvc2l0aW9uLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoIFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5yZW1vdmVDYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwb3NpdGlvbikge1xuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fa2lsbChudWxsLCBjYWxsYmFjayk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGEgPSB0aGlzLmdldFR3ZWVuc09mKGNhbGxiYWNrLCBmYWxzZSksXG5cdFx0XHRcdFx0XHRpID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0XHR0aW1lID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbik7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoYVtpXS5fc3RhcnRUaW1lID09PSB0aW1lKSB7XG5cdFx0XHRcdFx0XHRcdGFbaV0uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLnJlbW92ZUNhbGxiYWNrKFRpbWVsaW5lTGl0ZS5faW50ZXJuYWxzLnBhdXNlQ2FsbGJhY2ssIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC50d2VlblRvID0gZnVuY3Rpb24ocG9zaXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0dmFyIGNvcHkgPSB7ZWFzZTpfZWFzZU5vbmUsIHVzZUZyYW1lczp0aGlzLnVzZXNGcmFtZXMoKSwgaW1tZWRpYXRlUmVuZGVyOmZhbHNlfSxcblx0XHRcdFx0ZHVyYXRpb24sIHAsIHQ7XG5cdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRjb3B5W3BdID0gdmFyc1twXTtcblx0XHRcdH1cblx0XHRcdGNvcHkudGltZSA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24pO1xuXHRcdFx0ZHVyYXRpb24gPSAoTWF0aC5hYnMoTnVtYmVyKGNvcHkudGltZSkgLSB0aGlzLl90aW1lKSAvIHRoaXMuX3RpbWVTY2FsZSkgfHwgMC4wMDE7XG5cdFx0XHR0ID0gbmV3IFR3ZWVuTGl0ZSh0aGlzLCBkdXJhdGlvbiwgY29weSk7XG5cdFx0XHRjb3B5Lm9uU3RhcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dC50YXJnZXQucGF1c2VkKHRydWUpO1xuXHRcdFx0XHRpZiAodC52YXJzLnRpbWUgIT09IHQudGFyZ2V0LnRpbWUoKSAmJiBkdXJhdGlvbiA9PT0gdC5kdXJhdGlvbigpKSB7IC8vZG9uJ3QgbWFrZSB0aGUgZHVyYXRpb24gemVybyAtIGlmIGl0J3Mgc3VwcG9zZWQgdG8gYmUgemVybywgZG9uJ3Qgd29ycnkgYmVjYXVzZSBpdCdzIGFscmVhZHkgaW5pdHRpbmcgdGhlIHR3ZWVuIGFuZCB3aWxsIGNvbXBsZXRlIGltbWVkaWF0ZWx5LCBlZmZlY3RpdmVseSBtYWtpbmcgdGhlIGR1cmF0aW9uIHplcm8gYW55d2F5LiBJZiB3ZSBtYWtlIGR1cmF0aW9uIHplcm8sIHRoZSB0d2VlbiB3b24ndCBydW4gYXQgYWxsLlxuXHRcdFx0XHRcdHQuZHVyYXRpb24oIE1hdGguYWJzKCB0LnZhcnMudGltZSAtIHQudGFyZ2V0LnRpbWUoKSkgLyB0LnRhcmdldC5fdGltZVNjYWxlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhcnMub25TdGFydCkgeyAvL2luIGNhc2UgdGhlIHVzZXIgaGFkIGFuIG9uU3RhcnQgaW4gdGhlIHZhcnMgLSB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBpdC5cblx0XHRcdFx0XHR0Ll9jYWxsYmFjayhcIm9uU3RhcnRcIik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9O1xuXG5cdFx0cC50d2VlbkZyb21UbyA9IGZ1bmN0aW9uKGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbiwgdmFycykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHRmcm9tUG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKGZyb21Qb3NpdGlvbik7XG5cdFx0XHR2YXJzLnN0YXJ0QXQgPSB7b25Db21wbGV0ZTp0aGlzLnNlZWssIG9uQ29tcGxldGVQYXJhbXM6W2Zyb21Qb3NpdGlvbl0sIGNhbGxiYWNrU2NvcGU6dGhpc307XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UpO1xuXHRcdFx0dmFyIHQgPSB0aGlzLnR3ZWVuVG8odG9Qb3NpdGlvbiwgdmFycyk7XG5cdFx0XHRyZXR1cm4gdC5kdXJhdGlvbigoTWF0aC5hYnMoIHQudmFycy50aW1lIC0gZnJvbVBvc2l0aW9uKSAvIHRoaXMuX3RpbWVTY2FsZSkgfHwgMC4wMDEpO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdGR1ciA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHByZXZUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsXG5cdFx0XHRcdHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cHJldlRpbWVTY2FsZSA9IHRoaXMuX3RpbWVTY2FsZSxcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdHByZXZQYXVzZWQgPSB0aGlzLl9wYXVzZWQsXG5cdFx0XHRcdHByZXZDeWNsZSA9IHRoaXMuX2N5Y2xlLFxuXHRcdFx0XHR0d2VlbiwgaXNDb21wbGV0ZSwgbmV4dCwgY2FsbGJhY2ssIGludGVybmFsRm9yY2UsIGN5Y2xlRHVyYXRpb24sIHBhdXNlVHdlZW4sIGN1clRpbWU7XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1ciAtIDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMuXG5cdFx0XHRcdGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdG90YWxEdXI7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSB0aGlzLl9yZXBlYXQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9yZXZlcnNlZCkgaWYgKCF0aGlzLl9oYXNQYXVzZWRDaGlsZCgpKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gISF0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW47IC8vb3RoZXJ3aXNlLCBpZiB0aGUgYW5pbWF0aW9uIGlzIHVucGF1c2VkL2FjdGl2YXRlZCBhZnRlciBpdCdzIGFscmVhZHkgZmluaXNoZWQsIGl0IGRvZXNuJ3QgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHRpbWVsaW5lLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9kdXJhdGlvbiA9PT0gMCkgaWYgKCh0aW1lIDw9IDAgJiYgdGltZSA+PSAtMC4wMDAwMDAxKSB8fCBwcmV2UmF3UHJldlRpbWUgPCAwIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0pIGlmIChwcmV2UmF3UHJldlRpbWUgIT09IHRpbWUgJiYgdGhpcy5fZmlyc3QpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9ICh0aGlzLl9kdXJhdGlvbiB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRpbWUgPSAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXI7XG5cdFx0XHRcdFx0dGltZSA9IGR1ciArIDAuMDAwMTsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAtIHNvbWV0aW1lcyBjaGlsZCB0d2VlbnMvdGltZWxpbmVzIHdlcmUgbm90IGJlaW5nIGZ1bGx5IGNvbXBsZXRlZCAodGhlaXIgcHJvZ3Jlc3MgbWlnaHQgYmUgMC45OTk5OTk5OTk5OTk5OTggaW5zdGVhZCBvZiAxIGJlY2F1c2Ugd2hlbiBfdGltZSAtIHR3ZWVuLl9zdGFydFRpbWUgaXMgcGVyZm9ybWVkLCBmbG9hdGluZyBwb2ludCBlcnJvcnMgd291bGQgcmV0dXJuIGEgdmFsdWUgdGhhdCB3YXMgU0xJR0hUTFkgb2ZmKS4gVHJ5ICg5OTk5OTk5OTk5OTkuNyAtIDk5OTk5OTk5OTk5OSkgKiAxID0gMC42OTk5NTExNzE4NzUgaW5zdGVhZCBvZiAwLjcuIFdlIGNhbm5vdCBkbyBsZXNzIHRoZW4gMC4wMDAxIGJlY2F1c2UgdGhlIHNhbWUgaXNzdWUgY2FuIG9jY3VyIHdoZW4gdGhlIGR1cmF0aW9uIGlzIGV4dHJlbWVseSBsYXJnZSBsaWtlIDk5OTk5OTk5OTk5OSBpbiB3aGljaCBjYXNlIGFkZGluZyAwLjAwMDAwMDAxLCBmb3IgZXhhbXBsZSwgY2F1c2VzIGl0IHRvIGFjdCBsaWtlIG5vdGhpbmcgd2FzIGFkZGVkLlxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHRpZiAoIXRoaXMuX2xvY2tlZCkge1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX2N5Y2xlID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSAwIHx8IChkdXIgPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lICE9PSBfdGlueU51bSAmJiAocHJldlJhd1ByZXZUaW1lID4gMCB8fCAodGltZSA8IDAgJiYgcHJldlJhd1ByZXZUaW1lID49IDApKSAmJiAhdGhpcy5fbG9ja2VkKSkgeyAvL2VkZ2UgY2FzZSBmb3IgY2hlY2tpbmcgdGltZSA8IDAgJiYgcHJldlJhd1ByZXZUaW1lID49IDA6IGEgemVyby1kdXJhdGlvbiBmcm9tVG8oKSB0d2VlbiBpbnNpZGUgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lICh5ZWFoLCB2ZXJ5IHJhcmUpXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgdGhpcy5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSBpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHJldlJhd1ByZXZUaW1lID49IDAgJiYgdGhpcy5fZmlyc3QpIHsgLy93aGVuIGdvaW5nIGJhY2sgYmV5b25kIHRoZSBzdGFydCwgZm9yY2UgYSByZW5kZXIgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyB0aGF0IHNpdCBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgcmVuZGVyIHRoZWlyIHN0YXJ0IHZhbHVlcyBwcm9wZXJseS4gT3RoZXJ3aXNlLCBpZiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgbGFuZHMgZXhhY3RseSBhdCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lLCBhbmQgdGhlbiBtb3ZlcyBiYWNrd2FyZHMsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgYmVnaW5uaW5nIHdvdWxkIHN0aWxsIGJlIGF0IHRoZWlyIGVuZCBzdGF0ZS5cblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAoZHVyIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHRpZiAodGltZSA9PT0gMCAmJiBpc0NvbXBsZXRlKSB7IC8vaWYgdGhlcmUncyBhIHplcm8tZHVyYXRpb24gdHdlZW4gYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGEgdGltZWxpbmUgYW5kIHRoZSBwbGF5aGVhZCBsYW5kcyBFWEFDVExZIGF0IHRpbWUgMCwgdGhhdCB0d2VlbiB3aWxsIGNvcnJlY3RseSByZW5kZXIgaXRzIGVuZCB2YWx1ZXMsIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHRpbWVsaW5lIGFsaXZlIGZvciBvbmUgbW9yZSByZW5kZXIgc28gdGhhdCB0aGUgYmVnaW5uaW5nIHZhbHVlcyByZW5kZXIgcHJvcGVybHkgYXMgdGhlIHBhcmVudCdzIHBsYXloZWFkIGtlZXBzIG1vdmluZyBiZXlvbmQgdGhlIGJlZ2luaW5nLiBJbWFnaW5lIG9iai54IHN0YXJ0cyBhdCAwIGFuZCB0aGVuIHdlIGRvIHRsLnNldChvYmosIHt4OjEwMH0pLnRvKG9iaiwgMSwge3g6MjAwfSkgYW5kIHRoZW4gbGF0ZXIgd2UgdGwucmV2ZXJzZSgpLi4udGhlIGdvYWwgaXMgdG8gaGF2ZSBvYmoueCByZXZlcnQgdG8gMC4gSWYgdGhlIHBsYXloZWFkIGhhcHBlbnMgdG8gbGFuZCBvbiBleGFjdGx5IDAsIHdpdGhvdXQgdGhpcyBjaHVuayBvZiBjb2RlLCBpdCdkIGNvbXBsZXRlIHRoZSB0aW1lbGluZSBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHJlbmRlcmluZyBxdWV1ZSAobm90IGdvb2QpLlxuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0aXNDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWUgPSAwOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIChjb3VsZCBjYXVzZSBwcm9ibGVtcyBlc3BlY2lhbGx5IHdpdGggemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSlcblx0XHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoZHVyID09PSAwICYmIHByZXZSYXdQcmV2VGltZSA8IDApIHsgLy93aXRob3V0IHRoaXMsIHplcm8tZHVyYXRpb24gcmVwZWF0aW5nIHRpbWVsaW5lcyAobGlrZSB3aXRoIGEgc2ltcGxlIGNhbGxiYWNrIG5lc3RlZCBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgYW5kIGEgcmVwZWF0RGVsYXkpIHdvdWxkbid0IHJlbmRlciB0aGUgZmlyc3QgdGltZSB0aHJvdWdoLlxuXHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGltZTtcblx0XHRcdFx0XHRpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9ICh0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSA+PiAwOyAvL29yaWdpbmFsbHkgX3RvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24gYnV0IGZsb2F0aW5nIHBvaW50IGVycm9ycyBjYXVzZWQgcHJvYmxlbXMsIHNvIEkgbm9ybWFsaXplZCBpdC4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IGl0IGdldHMgcmVwb3J0ZWQgYXMgMC43OTk5OTk5OSEpXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IDApIGlmICh0aGlzLl9jeWNsZSA9PT0gdGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbiAmJiBwcmV2VG90YWxUaW1lIDw9IHRpbWUpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY3ljbGUtLTsgLy9vdGhlcndpc2Ugd2hlbiByZW5kZXJlZCBleGFjdGx5IGF0IHRoZSBlbmQgdGltZSwgaXQgd2lsbCBhY3QgYXMgdGhvdWdoIGl0IGlzIHJlcGVhdGluZyAoYXQgdGhlIGJlZ2lubmluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgLSAodGhpcy5fY3ljbGUgKiBjeWNsZUR1cmF0aW9uKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLl95b3lvKSBpZiAoKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1ciAtIHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IGR1cikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyO1xuXHRcdFx0XHRcdFx0XHR0aW1lID0gZHVyICsgMC4wMDAxOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3Jcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRpbWUgPSAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX2hhc1BhdXNlICYmICF0aGlzLl9mb3JjaW5nUGxheWhlYWQgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gcHJldlRpbWUpIHtcblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA8PSB0aW1lICYmICFwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSBpZiAodHdlZW4uZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgIXR3ZWVuLnJhdGlvICYmICEodHdlZW4uX3N0YXJ0VGltZSA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA9PT0gMCkpIHtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gdHdlZW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPj0gdGltZSAmJiAhcGF1c2VUd2Vlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikgaWYgKHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIHR3ZWVuLl9yYXdQcmV2VGltZSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gdHdlZW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lID0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGltZSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl90b3RhbER1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IHByZXZDeWNsZSkgaWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0Lypcblx0XHRcdFx0bWFrZSBzdXJlIGNoaWxkcmVuIGF0IHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSBhcmUgcmVuZGVyZWQgcHJvcGVybHkuIElmLCBmb3IgZXhhbXBsZSxcblx0XHRcdFx0YSAzLXNlY29uZCBsb25nIHRpbWVsaW5lIHJlbmRlcmVkIGF0IDIuOSBzZWNvbmRzIHByZXZpb3VzbHksIGFuZCBub3cgcmVuZGVycyBhdCAzLjIgc2Vjb25kcyAod2hpY2hcblx0XHRcdFx0d291bGQgZ2V0IHRyYW5zYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcblx0XHRcdFx0Y291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG5cdFx0XHRcdHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3Rcblx0XHRcdFx0ZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmVNYXggd29yay5cblx0XHRcdFx0Ki9cblx0XHRcdFx0dmFyIGJhY2t3YXJkcyA9ICh0aGlzLl95b3lvICYmIChwcmV2Q3ljbGUgJiAxKSAhPT0gMCksXG5cdFx0XHRcdFx0d3JhcCA9IChiYWNrd2FyZHMgPT09ICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSksXG5cdFx0XHRcdFx0cmVjVG90YWxUaW1lID0gdGhpcy5fdG90YWxUaW1lLFxuXHRcdFx0XHRcdHJlY0N5Y2xlID0gdGhpcy5fY3ljbGUsXG5cdFx0XHRcdFx0cmVjUmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0XHRyZWNUaW1lID0gdGhpcy5fdGltZTtcblxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSBwcmV2Q3ljbGUgKiBkdXI7XG5cdFx0XHRcdGlmICh0aGlzLl9jeWNsZSA8IHByZXZDeWNsZSkge1xuXHRcdFx0XHRcdGJhY2t3YXJkcyA9ICFiYWNrd2FyZHM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lICs9IGR1cjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gcHJldlRpbWU7IC8vdGVtcG9yYXJpbHkgcmV2ZXJ0IF90aW1lIHNvIHRoYXQgcmVuZGVyKCkgcmVuZGVycyB0aGUgY2hpbGRyZW4gaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFdpdGhvdXQgdGhpcywgdHdlZW5zIHdvbid0IHJld2luZCBjb3JyZWN0bHkuIFdlIGNvdWxkIGFyaGljdGVjdCB0aGluZ3MgaW4gYSBcImNsZWFuZXJcIiB3YXkgYnkgc3BsaXR0aW5nIG91dCB0aGUgcmVuZGVyaW5nIHF1ZXVlIGludG8gYSBzZXBhcmF0ZSBtZXRob2QgYnV0IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBrZXB0IGl0IGFsbCBpbnNpZGUgdGhpcyBtZXRob2QuXG5cblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAoZHVyID09PSAwKSA/IHByZXZSYXdQcmV2VGltZSAtIDAuMDAwMSA6IHByZXZSYXdQcmV2VGltZTtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSBwcmV2Q3ljbGU7XG5cdFx0XHRcdHRoaXMuX2xvY2tlZCA9IHRydWU7IC8vcHJldmVudHMgY2hhbmdlcyB0byB0b3RhbFRpbWUgYW5kIHNraXBzIHJlcGVhdC95b3lvIGJlaGF2aW9yIHdoZW4gd2UgcmVjdXJzaXZlbHkgY2FsbCByZW5kZXIoKVxuXHRcdFx0XHRwcmV2VGltZSA9IChiYWNrd2FyZHMpID8gMCA6IGR1cjtcblx0XHRcdFx0dGhpcy5yZW5kZXIocHJldlRpbWUsIHN1cHByZXNzRXZlbnRzLCAoZHVyID09PSAwKSk7XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIGlmICghdGhpcy5fZ2MpIHtcblx0XHRcdFx0XHRpZiAodGhpcy52YXJzLm9uUmVwZWF0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uUmVwZWF0XCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUpIHsgLy9pbiBjYXNlIHRoZXJlJ3MgYSBjYWxsYmFjayBsaWtlIG9uQ29tcGxldGUgaW4gYSBuZXN0ZWQgdHdlZW4vdGltZWxpbmUgdGhhdCBjaGFuZ2VzIHRoZSBwbGF5aGVhZCBwb3NpdGlvbiwgbGlrZSB2aWEgc2VlaygpLCB3ZSBzaG91bGQganVzdCBhYm9ydC5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHdyYXApIHtcblx0XHRcdFx0XHRwcmV2VGltZSA9IChiYWNrd2FyZHMpID8gZHVyICsgMC4wMDAxIDogLTAuMDAwMTtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2xvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRpZiAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSB7IC8vaWYgdGhlIHJlbmRlcigpIHRyaWdnZXJlZCBjYWxsYmFjayB0aGF0IHBhdXNlZCB0aGlzIHRpbWVsaW5lLCB3ZSBzaG91bGQgYWJvcnQgKHZlcnkgcmFyZSwgYnV0IHBvc3NpYmxlKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gcmVjVGltZTtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gcmVjVG90YWxUaW1lO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IHJlY0N5Y2xlO1xuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJlY1Jhd1ByZXZUaW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoKHRoaXMuX3RpbWUgPT09IHByZXZUaW1lIHx8ICF0aGlzLl9maXJzdCkgJiYgIWZvcmNlICYmICFpbnRlcm5hbEZvcmNlICYmICFwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdGlmIChwcmV2VG90YWxUaW1lICE9PSB0aGlzLl90b3RhbFRpbWUpIGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgeyAvL3NvIHRoYXQgb25VcGRhdGUgZmlyZXMgZXZlbiBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IC0gYXMgbG9uZyBhcyB0aGUgdG90YWxUaW1lIGNoYW5nZWQsIHdlIHNob3VsZCB0cmlnZ2VyIG9uVXBkYXRlLlxuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RvdGFsVGltZSAhPT0gcHJldlRvdGFsVGltZSAmJiB0aW1lID4gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgdGhlIHRpbWVsaW5lIChhcyBvcHBvc2VkIHRvIHRoZSBwYXJlbnQgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgaXQgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdGltZWxpbmUgYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUsIGZvciBleGFtcGxlLlxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJldlRvdGFsVGltZSA9PT0gMCkgaWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdG90YWxUaW1lICE9PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25TdGFydFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Y3VyVGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRpZiAoY3VyVGltZSA+PSBwcmV2VGltZSkge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmIChjdXJUaW1lICE9PSB0aGlzLl90aW1lIHx8ICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSB0aGlzLl90aW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAocGF1c2VUd2VlbiA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAoY3VyVGltZSAhPT0gdGhpcy5fdGltZSB8fCAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHR3ZWVuLl9zdGFydFRpbWUgPD0gcHJldlRpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gdHdlZW4uX3ByZXY7IC8vdGhlIGxpbmtlZCBsaXN0IGlzIG9yZ2FuaXplZCBieSBfc3RhcnRUaW1lLCB0aHVzIGl0J3MgcG9zc2libGUgdGhhdCBhIHR3ZWVuIGNvdWxkIHN0YXJ0IEJFRk9SRSB0aGUgcGF1c2UgYW5kIGVuZCBhZnRlciBpdCwgaW4gd2hpY2ggY2FzZSBpdCB3b3VsZCBiZSBwb3NpdGlvbmVkIGJlZm9yZSB0aGUgcGF1c2UgdHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0LCBidXQgd2Ugc2hvdWxkIHJlbmRlciBpdCBiZWZvcmUgd2UgcGF1c2UoKSB0aGUgdGltZWxpbmUgYW5kIGNlYXNlIHJlbmRlcmluZy4gVGhpcyBpcyBvbmx5IGEgY29uY2VybiB3aGVuIGdvaW5nIGluIHJldmVyc2UuXG5cdFx0XHRcdFx0XHRcdHdoaWxlIChwYXVzZVR3ZWVuICYmIHBhdXNlVHdlZW4uZW5kVGltZSgpID4gdGhpcy5fdGltZSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4ucmVuZGVyKCAocGF1c2VUd2Vlbi5fcmV2ZXJzZWQgPyBwYXVzZVR3ZWVuLnRvdGFsRHVyYXRpb24oKSAtICgodGltZSAtIHBhdXNlVHdlZW4uX3N0YXJ0VGltZSkgKiBwYXVzZVR3ZWVuLl90aW1lU2NhbGUpIDogKHRpbWUgLSBwYXVzZVR3ZWVuLl9zdGFydFRpbWUpICogcGF1c2VUd2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gcGF1c2VUd2Vlbi5fcHJldjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2xvY2tlZCkgaWYgKCF0aGlzLl9nYykgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnRUaW1lIHx8IHByZXZUaW1lU2NhbGUgIT09IHRoaXMuX3RpbWVTY2FsZSkgaWYgKHRoaXMuX3RpbWUgPT09IDAgfHwgdG90YWxEdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkpIHsgLy9pZiBvbmUgb2YgdGhlIHR3ZWVucyB0aGF0IHdhcyByZW5kZXJlZCBhbHRlcmVkIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgKGxpa2UgaWYgYW4gb25Db21wbGV0ZSByZXZlcnNlZCB0aGUgdGltZWxpbmUpLCBpdCBwcm9iYWJseSBpc24ndCBjb21wbGV0ZS4gSWYgaXQgaXMsIGRvbid0IHdvcnJ5LCBiZWNhdXNlIHdoYXRldmVyIGNhbGwgYWx0ZXJlZCB0aGUgc3RhcnRUaW1lIHdvdWxkIGNvbXBsZXRlIGlmIGl0IHdhcyBuZWNlc3NhcnkgYXQgdGhlIG5ldyB0aW1lLiBUaGUgb25seSBleGNlcHRpb24gaXMgdGhlIHRpbWVTY2FsZSBwcm9wZXJ0eS4gQWxzbyBjaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvbkNvbXBsZXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuZ2V0QWN0aXZlID0gZnVuY3Rpb24obmVzdGVkLCB0d2VlbnMsIHRpbWVsaW5lcykge1xuXHRcdFx0aWYgKG5lc3RlZCA9PSBudWxsKSB7XG5cdFx0XHRcdG5lc3RlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHdlZW5zID09IG51bGwpIHtcblx0XHRcdFx0dHdlZW5zID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aW1lbGluZXMgPT0gbnVsbCkge1xuXHRcdFx0XHR0aW1lbGluZXMgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdGFsbCA9IHRoaXMuZ2V0Q2hpbGRyZW4obmVzdGVkLCB0d2VlbnMsIHRpbWVsaW5lcyksXG5cdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdGwgPSBhbGwubGVuZ3RoLFxuXHRcdFx0XHRpLCB0d2Vlbjtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dHdlZW4gPSBhbGxbaV07XG5cdFx0XHRcdGlmICh0d2Vlbi5pc0FjdGl2ZSgpKSB7XG5cdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXG5cdFx0cC5nZXRMYWJlbEFmdGVyID0gZnVuY3Rpb24odGltZSkge1xuXHRcdFx0aWYgKCF0aW1lKSBpZiAodGltZSAhPT0gMCkgeyAvL2Zhc3RlciB0aGFuIGlzTmFuKClcblx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHNBcnJheSgpLFxuXHRcdFx0XHRsID0gbGFiZWxzLmxlbmd0aCxcblx0XHRcdFx0aTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKGxhYmVsc1tpXS50aW1lID4gdGltZSkge1xuXHRcdFx0XHRcdHJldHVybiBsYWJlbHNbaV0ubmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblxuXHRcdHAuZ2V0TGFiZWxCZWZvcmUgPSBmdW5jdGlvbih0aW1lKSB7XG5cdFx0XHRpZiAodGltZSA9PSBudWxsKSB7XG5cdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzQXJyYXkoKSxcblx0XHRcdFx0aSA9IGxhYmVscy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKGxhYmVsc1tpXS50aW1lIDwgdGltZSkge1xuXHRcdFx0XHRcdHJldHVybiBsYWJlbHNbaV0ubmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblxuXHRcdHAuZ2V0TGFiZWxzQXJyYXkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdHA7XG5cdFx0XHRmb3IgKHAgaW4gdGhpcy5fbGFiZWxzKSB7XG5cdFx0XHRcdGFbY250KytdID0ge3RpbWU6dGhpcy5fbGFiZWxzW3BdLCBuYW1lOnB9O1xuXHRcdFx0fVxuXHRcdFx0YS5zb3J0KGZ1bmN0aW9uKGEsYikge1xuXHRcdFx0XHRyZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cbi8vLS0tLSBHRVRURVJTIC8gU0VUVEVSUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLnByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RpbWUgLyB0aGlzLmR1cmF0aW9uKCkgOiB0aGlzLnRvdGFsVGltZSggdGhpcy5kdXJhdGlvbigpICogKCh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSA/IDEgLSB2YWx1ZSA6IHZhbHVlKSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSksIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RvdGFsVGltZSAvIHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUoIHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHRUaW1lbGluZUxpdGUucHJvdG90eXBlLnRvdGFsRHVyYXRpb24uY2FsbCh0aGlzKTsgLy9qdXN0IGZvcmNlcyByZWZyZXNoXG5cdFx0XHRcdFx0Ly9JbnN0ZWFkIG9mIEluZmluaXR5LCB3ZSB1c2UgOTk5OTk5OTk5OTk5IHNvIHRoYXQgd2UgY2FuIGFjY29tbW9kYXRlIHJldmVyc2VzLlxuXHRcdFx0XHRcdHRoaXMuX3RvdGFsRHVyYXRpb24gPSAodGhpcy5fcmVwZWF0ID09PSAtMSkgPyA5OTk5OTk5OTk5OTkgOiB0aGlzLl9kdXJhdGlvbiAqICh0aGlzLl9yZXBlYXQgKyAxKSArICh0aGlzLl9yZXBlYXREZWxheSAqIHRoaXMuX3JlcGVhdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHRoaXMuX3JlcGVhdCA9PT0gLTEgfHwgIXZhbHVlKSA/IHRoaXMgOiB0aGlzLnRpbWVTY2FsZSggdGhpcy50b3RhbER1cmF0aW9uKCkgLyB2YWx1ZSApO1xuXHRcdH07XG5cblx0XHRwLnRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSA+IHRoaXMuX2R1cmF0aW9uKSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSA9ICh0aGlzLl9kdXJhdGlvbiAtIHZhbHVlKSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3JlcGVhdCAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSArPSB0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnJlcGVhdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcGVhdDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAucmVwZWF0RGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC55b3lvID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5feW95bztcblx0XHRcdH1cblx0XHRcdHRoaXMuX3lveW8gPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxCZWZvcmUodGhpcy5fdGltZSArIDAuMDAwMDAwMDEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHJldHVybiBUaW1lbGluZU1heDtcblxuXHR9LCB0cnVlKTtcblx0XG5cblxuXG5cblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQmV6aWVyUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0KGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcblx0XHRcdF9yMSA9IFtdLFxuXHRcdFx0X3IyID0gW10sXG5cdFx0XHRfcjMgPSBbXSxcblx0XHRcdF9jb3JQcm9wcyA9IHt9LFxuXHRcdFx0X2dsb2JhbHMgPSBfZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxcblx0XHRcdFNlZ21lbnQgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG5cdFx0XHRcdHRoaXMuYSA9IGE7XG5cdFx0XHRcdHRoaXMuYiA9IGI7XG5cdFx0XHRcdHRoaXMuYyA9IGM7XG5cdFx0XHRcdHRoaXMuZCA9IGQ7XG5cdFx0XHRcdHRoaXMuZGEgPSBkIC0gYTtcblx0XHRcdFx0dGhpcy5jYSA9IGMgLSBhO1xuXHRcdFx0XHR0aGlzLmJhID0gYiAtIGE7XG5cdFx0XHR9LFxuXHRcdFx0X2NvcnJlbGF0ZSA9IFwiLHgseSx6LGxlZnQsdG9wLHJpZ2h0LGJvdHRvbSxtYXJnaW5Ub3AsbWFyZ2luTGVmdCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20scGFkZGluZ0xlZnQscGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxiYWNrZ3JvdW5kUG9zaXRpb24sYmFja2dyb3VuZFBvc2l0aW9uX3ksXCIsXG5cdFx0XHRjdWJpY1RvUXVhZHJhdGljID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuXHRcdFx0XHR2YXIgcTEgPSB7YTphfSxcblx0XHRcdFx0XHRxMiA9IHt9LFxuXHRcdFx0XHRcdHEzID0ge30sXG5cdFx0XHRcdFx0cTQgPSB7YzpkfSxcblx0XHRcdFx0XHRtYWIgPSAoYSArIGIpIC8gMixcblx0XHRcdFx0XHRtYmMgPSAoYiArIGMpIC8gMixcblx0XHRcdFx0XHRtY2QgPSAoYyArIGQpIC8gMixcblx0XHRcdFx0XHRtYWJjID0gKG1hYiArIG1iYykgLyAyLFxuXHRcdFx0XHRcdG1iY2QgPSAobWJjICsgbWNkKSAvIDIsXG5cdFx0XHRcdFx0bTggPSAobWJjZCAtIG1hYmMpIC8gODtcblx0XHRcdFx0cTEuYiA9IG1hYiArIChhIC0gbWFiKSAvIDQ7XG5cdFx0XHRcdHEyLmIgPSBtYWJjICsgbTg7XG5cdFx0XHRcdHExLmMgPSBxMi5hID0gKHExLmIgKyBxMi5iKSAvIDI7XG5cdFx0XHRcdHEyLmMgPSBxMy5hID0gKG1hYmMgKyBtYmNkKSAvIDI7XG5cdFx0XHRcdHEzLmIgPSBtYmNkIC0gbTg7XG5cdFx0XHRcdHE0LmIgPSBtY2QgKyAoZCAtIG1jZCkgLyA0O1xuXHRcdFx0XHRxMy5jID0gcTQuYSA9IChxMy5iICsgcTQuYikgLyAyO1xuXHRcdFx0XHRyZXR1cm4gW3ExLCBxMiwgcTMsIHE0XTtcblx0XHRcdH0sXG5cdFx0XHRfY2FsY3VsYXRlQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKGEsIGN1cnZpbmVzcywgcXVhZCwgYmFzaWMsIGNvcnJlbGF0ZSkge1xuXHRcdFx0XHR2YXIgbCA9IGEubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRpaSA9IDAsXG5cdFx0XHRcdFx0Y3AxID0gYVswXS5hLFxuXHRcdFx0XHRcdGksIHAxLCBwMiwgcDMsIHNlZywgbTEsIG0yLCBtbSwgY3AyLCBxYiwgcjEsIHIyLCB0bDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHNlZyA9IGFbaWldO1xuXHRcdFx0XHRcdHAxID0gc2VnLmE7XG5cdFx0XHRcdFx0cDIgPSBzZWcuZDtcblx0XHRcdFx0XHRwMyA9IGFbaWkrMV0uZDtcblxuXHRcdFx0XHRcdGlmIChjb3JyZWxhdGUpIHtcblx0XHRcdFx0XHRcdHIxID0gX3IxW2ldO1xuXHRcdFx0XHRcdFx0cjIgPSBfcjJbaV07XG5cdFx0XHRcdFx0XHR0bCA9ICgocjIgKyByMSkgKiBjdXJ2aW5lc3MgKiAwLjI1KSAvIChiYXNpYyA/IDAuNSA6IF9yM1tpXSB8fCAwLjUpO1xuXHRcdFx0XHRcdFx0bTEgPSBwMiAtIChwMiAtIHAxKSAqIChiYXNpYyA/IGN1cnZpbmVzcyAqIDAuNSA6IChyMSAhPT0gMCA/IHRsIC8gcjEgOiAwKSk7XG5cdFx0XHRcdFx0XHRtMiA9IHAyICsgKHAzIC0gcDIpICogKGJhc2ljID8gY3VydmluZXNzICogMC41IDogKHIyICE9PSAwID8gdGwgLyByMiA6IDApKTtcblx0XHRcdFx0XHRcdG1tID0gcDIgLSAobTEgKyAoKChtMiAtIG0xKSAqICgocjEgKiAzIC8gKHIxICsgcjIpKSArIDAuNSkgLyA0KSB8fCAwKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG0xID0gcDIgLSAocDIgLSBwMSkgKiBjdXJ2aW5lc3MgKiAwLjU7XG5cdFx0XHRcdFx0XHRtMiA9IHAyICsgKHAzIC0gcDIpICogY3VydmluZXNzICogMC41O1xuXHRcdFx0XHRcdFx0bW0gPSBwMiAtIChtMSArIG0yKSAvIDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG0xICs9IG1tO1xuXHRcdFx0XHRcdG0yICs9IG1tO1xuXG5cdFx0XHRcdFx0c2VnLmMgPSBjcDIgPSBtMTtcblx0XHRcdFx0XHRpZiAoaSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0c2VnLmIgPSBjcDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlZy5iID0gY3AxID0gc2VnLmEgKyAoc2VnLmMgLSBzZWcuYSkgKiAwLjY7IC8vaW5zdGVhZCBvZiBwbGFjaW5nIGIgb24gYSBleGFjdGx5LCB3ZSBtb3ZlIGl0IGlubGluZSB3aXRoIGMgc28gdGhhdCBpZiB0aGUgdXNlciBzcGVjaWZpZXMgYW4gZWFzZSBsaWtlIEJhY2suZWFzZUluIG9yIEVsYXN0aWMuZWFzZUluIHdoaWNoIGdvZXMgQkVZT05EIHRoZSBiZWdpbm5pbmcsIGl0IHdpbGwgZG8gc28gc21vb3RobHkuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2VnLmRhID0gcDIgLSBwMTtcblx0XHRcdFx0XHRzZWcuY2EgPSBjcDIgLSBwMTtcblx0XHRcdFx0XHRzZWcuYmEgPSBjcDEgLSBwMTtcblxuXHRcdFx0XHRcdGlmIChxdWFkKSB7XG5cdFx0XHRcdFx0XHRxYiA9IGN1YmljVG9RdWFkcmF0aWMocDEsIGNwMSwgY3AyLCBwMik7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShpaSwgMSwgcWJbMF0sIHFiWzFdLCBxYlsyXSwgcWJbM10pO1xuXHRcdFx0XHRcdFx0aWkgKz0gNDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWkrKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjcDEgPSBtMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWcgPSBhW2lpXTtcblx0XHRcdFx0c2VnLmIgPSBjcDE7XG5cdFx0XHRcdHNlZy5jID0gY3AxICsgKHNlZy5kIC0gY3AxKSAqIDAuNDsgLy9pbnN0ZWFkIG9mIHBsYWNpbmcgYyBvbiBkIGV4YWN0bHksIHdlIG1vdmUgaXQgaW5saW5lIHdpdGggYiBzbyB0aGF0IGlmIHRoZSB1c2VyIHNwZWNpZmllcyBhbiBlYXNlIGxpa2UgQmFjay5lYXNlT3V0IG9yIEVsYXN0aWMuZWFzZU91dCB3aGljaCBnb2VzIEJFWU9ORCB0aGUgZW5kLCBpdCB3aWxsIGRvIHNvIHNtb290aGx5LlxuXHRcdFx0XHRzZWcuZGEgPSBzZWcuZCAtIHNlZy5hO1xuXHRcdFx0XHRzZWcuY2EgPSBzZWcuYyAtIHNlZy5hO1xuXHRcdFx0XHRzZWcuYmEgPSBjcDEgLSBzZWcuYTtcblx0XHRcdFx0aWYgKHF1YWQpIHtcblx0XHRcdFx0XHRxYiA9IGN1YmljVG9RdWFkcmF0aWMoc2VnLmEsIGNwMSwgc2VnLmMsIHNlZy5kKTtcblx0XHRcdFx0XHRhLnNwbGljZShpaSwgMSwgcWJbMF0sIHFiWzFdLCBxYlsyXSwgcWJbM10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlQW5jaG9ycyA9IGZ1bmN0aW9uKHZhbHVlcywgcCwgY29ycmVsYXRlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0bCwgaSwgcDEsIHAyLCBwMywgdG1wO1xuXHRcdFx0XHRpZiAocHJlcGVuZCkge1xuXHRcdFx0XHRcdHZhbHVlcyA9IFtwcmVwZW5kXS5jb25jYXQodmFsdWVzKTtcblx0XHRcdFx0XHRpID0gdmFsdWVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoICh0bXAgPSB2YWx1ZXNbaV1bcF0pICkgPT09IFwic3RyaW5nXCIpIGlmICh0bXAuY2hhckF0KDEpID09PSBcIj1cIikge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbaV1bcF0gPSBwcmVwZW5kW3BdICsgTnVtYmVyKHRtcC5jaGFyQXQoMCkgKyB0bXAuc3Vic3RyKDIpKTsgLy9hY2NvbW1vZGF0ZSByZWxhdGl2ZSB2YWx1ZXMuIERvIGl0IGlubGluZSBpbnN0ZWFkIG9mIGJyZWFraW5nIGl0IG91dCBpbnRvIGEgZnVuY3Rpb24gZm9yIHNwZWVkIHJlYXNvbnNcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bCA9IHZhbHVlcy5sZW5ndGggLSAyO1xuXHRcdFx0XHRpZiAobCA8IDApIHtcblx0XHRcdFx0XHRhWzBdID0gbmV3IFNlZ21lbnQodmFsdWVzWzBdW3BdLCAwLCAwLCB2YWx1ZXNbKGwgPCAtMSkgPyAwIDogMV1bcF0pO1xuXHRcdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRwMSA9IHZhbHVlc1tpXVtwXTtcblx0XHRcdFx0XHRwMiA9IHZhbHVlc1tpKzFdW3BdO1xuXHRcdFx0XHRcdGFbaV0gPSBuZXcgU2VnbWVudChwMSwgMCwgMCwgcDIpO1xuXHRcdFx0XHRcdGlmIChjb3JyZWxhdGUpIHtcblx0XHRcdFx0XHRcdHAzID0gdmFsdWVzW2krMl1bcF07XG5cdFx0XHRcdFx0XHRfcjFbaV0gPSAoX3IxW2ldIHx8IDApICsgKHAyIC0gcDEpICogKHAyIC0gcDEpO1xuXHRcdFx0XHRcdFx0X3IyW2ldID0gKF9yMltpXSB8fCAwKSArIChwMyAtIHAyKSAqIChwMyAtIHAyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtpXSA9IG5ldyBTZWdtZW50KHZhbHVlc1tpXVtwXSwgMCwgMCwgdmFsdWVzW2krMV1bcF0pO1xuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sXG5cdFx0XHRiZXppZXJUaHJvdWdoID0gZnVuY3Rpb24odmFsdWVzLCBjdXJ2aW5lc3MsIHF1YWRyYXRpYywgYmFzaWMsIGNvcnJlbGF0ZSwgcHJlcGVuZCkge1xuXHRcdFx0XHR2YXIgb2JqID0ge30sXG5cdFx0XHRcdFx0cHJvcHMgPSBbXSxcblx0XHRcdFx0XHRmaXJzdCA9IHByZXBlbmQgfHwgdmFsdWVzWzBdLFxuXHRcdFx0XHRcdGksIHAsIGEsIGosIHIsIGwsIHNlYW1sZXNzLCBsYXN0O1xuXHRcdFx0XHRjb3JyZWxhdGUgPSAodHlwZW9mKGNvcnJlbGF0ZSkgPT09IFwic3RyaW5nXCIpID8gXCIsXCIrY29ycmVsYXRlK1wiLFwiIDogX2NvcnJlbGF0ZTtcblx0XHRcdFx0aWYgKGN1cnZpbmVzcyA9PSBudWxsKSB7XG5cdFx0XHRcdFx0Y3VydmluZXNzID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHAgaW4gdmFsdWVzWzBdKSB7XG5cdFx0XHRcdFx0cHJvcHMucHVzaChwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL2NoZWNrIHRvIHNlZSBpZiB0aGUgbGFzdCBhbmQgZmlyc3QgdmFsdWVzIGFyZSBpZGVudGljYWwgKHdlbGwsIHdpdGhpbiAwLjA1KS4gSWYgc28sIG1ha2Ugc2VhbWxlc3MgYnkgYXBwZW5kaW5nIHRoZSBzZWNvbmQgZWxlbWVudCB0byB0aGUgdmVyeSBlbmQgb2YgdGhlIHZhbHVlcyBhcnJheSBhbmQgdGhlIDJuZC10by1sYXN0IGVsZW1lbnQgdG8gdGhlIHZlcnkgYmVnaW5uaW5nICh3ZSdsbCByZW1vdmUgdGhvc2Ugc2VnbWVudHMgbGF0ZXIpXG5cdFx0XHRcdGlmICh2YWx1ZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGxhc3QgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdHNlYW1sZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKE1hdGguYWJzKGZpcnN0W3BdIC0gbGFzdFtwXSkgPiAwLjA1KSB7IC8vYnVpbGQgaW4gYSB0b2xlcmFuY2Ugb2YgKy8tMC4wNSB0byBhY2NvbW1vZGF0ZSByb3VuZGluZyBlcnJvcnMuXG5cdFx0XHRcdFx0XHRcdHNlYW1sZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRcdHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoKTsgLy9kdXBsaWNhdGUgdGhlIGFycmF5IHRvIGF2b2lkIGNvbnRhbWluYXRpbmcgdGhlIG9yaWdpbmFsIHdoaWNoIHRoZSB1c2VyIG1heSBiZSByZXVzaW5nIGZvciBvdGhlciB0d2VlbnNcblx0XHRcdFx0XHRcdGlmIChwcmVwZW5kKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlcy51bnNoaWZ0KHByZXBlbmQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2godmFsdWVzWzFdKTtcblx0XHRcdFx0XHRcdHByZXBlbmQgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDNdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfcjEubGVuZ3RoID0gX3IyLmxlbmd0aCA9IF9yMy5sZW5ndGggPSAwO1xuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0X2NvclByb3BzW3BdID0gKGNvcnJlbGF0ZS5pbmRleE9mKFwiLFwiK3ArXCIsXCIpICE9PSAtMSk7XG5cdFx0XHRcdFx0b2JqW3BdID0gX3BhcnNlQW5jaG9ycyh2YWx1ZXMsIHAsIF9jb3JQcm9wc1twXSwgcHJlcGVuZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IF9yMS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdF9yMVtpXSA9IE1hdGguc3FydChfcjFbaV0pO1xuXHRcdFx0XHRcdF9yMltpXSA9IE1hdGguc3FydChfcjJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYmFzaWMpIHtcblx0XHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKF9jb3JQcm9wc1twXSkge1xuXHRcdFx0XHRcdFx0XHRhID0gb2JqW3Byb3BzW2ldXTtcblx0XHRcdFx0XHRcdFx0bCA9IGEubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuXHRcdFx0XHRcdFx0XHRcdHIgPSAoYVtqKzFdLmRhIC8gX3IyW2pdICsgYVtqXS5kYSAvIF9yMVtqXSkgfHwgMDtcblx0XHRcdFx0XHRcdFx0XHRfcjNbal0gPSAoX3IzW2pdIHx8IDApICsgciAqIHI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aSA9IF9yMy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRfcjNbaV0gPSBNYXRoLnNxcnQoX3IzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0aiA9IHF1YWRyYXRpYyA/IDQgOiAxO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0YSA9IG9ialtwXTtcblx0XHRcdFx0XHRfY2FsY3VsYXRlQ29udHJvbFBvaW50cyhhLCBjdXJ2aW5lc3MsIHF1YWRyYXRpYywgYmFzaWMsIF9jb3JQcm9wc1twXSk7IC8vdGhpcyBtZXRob2QgcmVxdWlyZXMgdGhhdCBfcGFyc2VBbmNob3JzKCkgYW5kIF9zZXRTZWdtZW50UmF0aW9zKCkgcmFuIGZpcnN0IHNvIHRoYXQgX3IxLCBfcjIsIGFuZCBfcjMgdmFsdWVzIGFyZSBwb3B1bGF0ZWQgZm9yIGFsbCBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0aWYgKHNlYW1sZXNzKSB7XG5cdFx0XHRcdFx0XHRhLnNwbGljZSgwLCBqKTtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGEubGVuZ3RoIC0gaiwgaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlQmV6aWVyRGF0YSA9IGZ1bmN0aW9uKHZhbHVlcywgdHlwZSwgcHJlcGVuZCkge1xuXHRcdFx0XHR0eXBlID0gdHlwZSB8fCBcInNvZnRcIjtcblx0XHRcdFx0dmFyIG9iaiA9IHt9LFxuXHRcdFx0XHRcdGluYyA9ICh0eXBlID09PSBcImN1YmljXCIpID8gMyA6IDIsXG5cdFx0XHRcdFx0c29mdCA9ICh0eXBlID09PSBcInNvZnRcIiksXG5cdFx0XHRcdFx0cHJvcHMgPSBbXSxcblx0XHRcdFx0XHRhLCBiLCBjLCBkLCBjdXIsIGksIGosIGwsIHAsIGNudCwgdG1wO1xuXHRcdFx0XHRpZiAoc29mdCAmJiBwcmVwZW5kKSB7XG5cdFx0XHRcdFx0dmFsdWVzID0gW3ByZXBlbmRdLmNvbmNhdCh2YWx1ZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YWx1ZXMgPT0gbnVsbCB8fCB2YWx1ZXMubGVuZ3RoIDwgaW5jICsgMSkgeyB0aHJvdyBcImludmFsaWQgQmV6aWVyIGRhdGFcIjsgfVxuXHRcdFx0XHRmb3IgKHAgaW4gdmFsdWVzWzBdKSB7XG5cdFx0XHRcdFx0cHJvcHMucHVzaChwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0b2JqW3BdID0gY3VyID0gW107XG5cdFx0XHRcdFx0Y250ID0gMDtcblx0XHRcdFx0XHRsID0gdmFsdWVzLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRhID0gKHByZXBlbmQgPT0gbnVsbCkgPyB2YWx1ZXNbal1bcF0gOiAodHlwZW9mKCAodG1wID0gdmFsdWVzW2pdW3BdKSApID09PSBcInN0cmluZ1wiICYmIHRtcC5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHByZXBlbmRbcF0gKyBOdW1iZXIodG1wLmNoYXJBdCgwKSArIHRtcC5zdWJzdHIoMikpIDogTnVtYmVyKHRtcCk7XG5cdFx0XHRcdFx0XHRpZiAoc29mdCkgaWYgKGogPiAxKSBpZiAoaiA8IGwgLSAxKSB7XG5cdFx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSAoYSArIGN1cltjbnQtMl0pIC8gMjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSBhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsID0gY250IC0gaW5jICsgMTtcblx0XHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqICs9IGluYykge1xuXHRcdFx0XHRcdFx0YSA9IGN1cltqXTtcblx0XHRcdFx0XHRcdGIgPSBjdXJbaisxXTtcblx0XHRcdFx0XHRcdGMgPSBjdXJbaisyXTtcblx0XHRcdFx0XHRcdGQgPSAoaW5jID09PSAyKSA/IDAgOiBjdXJbaiszXTtcblx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSB0bXAgPSAoaW5jID09PSAzKSA/IG5ldyBTZWdtZW50KGEsIGIsIGMsIGQpIDogbmV3IFNlZ21lbnQoYSwgKDIgKiBiICsgYSkgLyAzLCAoMiAqIGIgKyBjKSAvIDMsIGMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXIubGVuZ3RoID0gY250O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9LFxuXHRcdFx0X2FkZEN1YmljTGVuZ3RocyA9IGZ1bmN0aW9uKGEsIHN0ZXBzLCByZXNvbHV0aW9uKSB7XG5cdFx0XHRcdHZhciBpbmMgPSAxIC8gcmVzb2x1dGlvbixcblx0XHRcdFx0XHRqID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0ZCwgZDEsIHMsIGRhLCBjYSwgYmEsIHAsIGksIGludiwgYmV6LCBpbmRleDtcblx0XHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdFx0YmV6ID0gYVtqXTtcblx0XHRcdFx0XHRzID0gYmV6LmE7XG5cdFx0XHRcdFx0ZGEgPSBiZXouZCAtIHM7XG5cdFx0XHRcdFx0Y2EgPSBiZXouYyAtIHM7XG5cdFx0XHRcdFx0YmEgPSBiZXouYiAtIHM7XG5cdFx0XHRcdFx0ZCA9IGQxID0gMDtcblx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDw9IHJlc29sdXRpb247IGkrKykge1xuXHRcdFx0XHRcdFx0cCA9IGluYyAqIGk7XG5cdFx0XHRcdFx0XHRpbnYgPSAxIC0gcDtcblx0XHRcdFx0XHRcdGQgPSBkMSAtIChkMSA9IChwICogcCAqIGRhICsgMyAqIGludiAqIChwICogY2EgKyBpbnYgKiBiYSkpICogcCk7XG5cdFx0XHRcdFx0XHRpbmRleCA9IGogKiByZXNvbHV0aW9uICsgaSAtIDE7XG5cdFx0XHRcdFx0XHRzdGVwc1tpbmRleF0gPSAoc3RlcHNbaW5kZXhdIHx8IDApICsgZCAqIGQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlTGVuZ3RoRGF0YSA9IGZ1bmN0aW9uKG9iaiwgcmVzb2x1dGlvbikge1xuXHRcdFx0XHRyZXNvbHV0aW9uID0gcmVzb2x1dGlvbiA+PiAwIHx8IDY7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0bGVuZ3RocyA9IFtdLFxuXHRcdFx0XHRcdGQgPSAwLFxuXHRcdFx0XHRcdHRvdGFsID0gMCxcblx0XHRcdFx0XHR0aHJlc2hvbGQgPSByZXNvbHV0aW9uIC0gMSxcblx0XHRcdFx0XHRzZWdtZW50cyA9IFtdLFxuXHRcdFx0XHRcdGN1ckxTID0gW10sIC8vY3VycmVudCBsZW5ndGggc2VnbWVudHMgYXJyYXlcblx0XHRcdFx0XHRwLCBpLCBsLCBpbmRleDtcblx0XHRcdFx0Zm9yIChwIGluIG9iaikge1xuXHRcdFx0XHRcdF9hZGRDdWJpY0xlbmd0aHMob2JqW3BdLCBhLCByZXNvbHV0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsID0gYS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRkICs9IE1hdGguc3FydChhW2ldKTtcblx0XHRcdFx0XHRpbmRleCA9IGkgJSByZXNvbHV0aW9uO1xuXHRcdFx0XHRcdGN1ckxTW2luZGV4XSA9IGQ7XG5cdFx0XHRcdFx0aWYgKGluZGV4ID09PSB0aHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdHRvdGFsICs9IGQ7XG5cdFx0XHRcdFx0XHRpbmRleCA9IChpIC8gcmVzb2x1dGlvbikgPj4gMDtcblx0XHRcdFx0XHRcdHNlZ21lbnRzW2luZGV4XSA9IGN1ckxTO1xuXHRcdFx0XHRcdFx0bGVuZ3Roc1tpbmRleF0gPSB0b3RhbDtcblx0XHRcdFx0XHRcdGQgPSAwO1xuXHRcdFx0XHRcdFx0Y3VyTFMgPSBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtsZW5ndGg6dG90YWwsIGxlbmd0aHM6bGVuZ3Rocywgc2VnbWVudHM6c2VnbWVudHN9O1xuXHRcdFx0fSxcblxuXG5cblx0XHRcdEJlemllclBsdWdpbiA9IF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdFx0XHRcdHByb3BOYW1lOiBcImJlemllclwiLFxuXHRcdFx0XHRcdHByaW9yaXR5OiAtMSxcblx0XHRcdFx0XHR2ZXJzaW9uOiBcIjEuMy41XCIsXG5cdFx0XHRcdFx0QVBJOiAyLFxuXHRcdFx0XHRcdGdsb2JhbDp0cnVlLFxuXG5cdFx0XHRcdFx0Ly9nZXRzIGNhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdFx0XHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgdHdlZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XHRcdFx0XHRcdGlmICh2YXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0dmFycyA9IHt2YWx1ZXM6dmFyc307XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9mdW5jID0ge307XG5cdFx0XHRcdFx0XHR0aGlzLl9yb3VuZCA9IHt9O1xuXHRcdFx0XHRcdFx0dGhpcy5fcHJvcHMgPSBbXTtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWVSZXMgPSAodmFycy50aW1lUmVzb2x1dGlvbiA9PSBudWxsKSA/IDYgOiBwYXJzZUludCh2YXJzLnRpbWVSZXNvbHV0aW9uLCAxMCk7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFycy52YWx1ZXMgfHwgW10sXG5cdFx0XHRcdFx0XHRcdGZpcnN0ID0ge30sXG5cdFx0XHRcdFx0XHRcdHNlY29uZCA9IHZhbHVlc1swXSxcblx0XHRcdFx0XHRcdFx0YXV0b1JvdGF0ZSA9IHZhcnMuYXV0b1JvdGF0ZSB8fCB0d2Vlbi52YXJzLm9yaWVudFRvQmV6aWVyLFxuXHRcdFx0XHRcdFx0XHRwLCBpc0Z1bmMsIGksIGosIHByZXBlbmQ7XG5cblx0XHRcdFx0XHRcdHRoaXMuX2F1dG9Sb3RhdGUgPSBhdXRvUm90YXRlID8gKGF1dG9Sb3RhdGUgaW5zdGFuY2VvZiBBcnJheSkgPyBhdXRvUm90YXRlIDogW1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsKChhdXRvUm90YXRlID09PSB0cnVlKSA/IDAgOiBOdW1iZXIoYXV0b1JvdGF0ZSkgfHwgMCldXSA6IG51bGw7XG5cdFx0XHRcdFx0XHRmb3IgKHAgaW4gc2Vjb25kKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3Byb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGkgPSB0aGlzLl9wcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuX3Byb3BzW2ldO1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0XHRcdGlzRnVuYyA9IHRoaXMuX2Z1bmNbcF0gPSAodHlwZW9mKHRhcmdldFtwXSkgPT09IFwiZnVuY3Rpb25cIik7XG5cdFx0XHRcdFx0XHRcdGZpcnN0W3BdID0gKCFpc0Z1bmMpID8gcGFyc2VGbG9hdCh0YXJnZXRbcF0pIDogdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIXByZXBlbmQpIGlmIChmaXJzdFtwXSAhPT0gdmFsdWVzWzBdW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJlcGVuZCA9IGZpcnN0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9iZXppZXJzID0gKHZhcnMudHlwZSAhPT0gXCJjdWJpY1wiICYmIHZhcnMudHlwZSAhPT0gXCJxdWFkcmF0aWNcIiAmJiB2YXJzLnR5cGUgIT09IFwic29mdFwiKSA/IGJlemllclRocm91Z2godmFsdWVzLCBpc05hTih2YXJzLmN1cnZpbmVzcykgPyAxIDogdmFycy5jdXJ2aW5lc3MsIGZhbHNlLCAodmFycy50eXBlID09PSBcInRocnVCYXNpY1wiKSwgdmFycy5jb3JyZWxhdGUsIHByZXBlbmQpIDogX3BhcnNlQmV6aWVyRGF0YSh2YWx1ZXMsIHZhcnMudHlwZSwgZmlyc3QpO1xuXHRcdFx0XHRcdFx0dGhpcy5fc2VnQ291bnQgPSB0aGlzLl9iZXppZXJzW3BdLmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVSZXMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGxkID0gX3BhcnNlTGVuZ3RoRGF0YSh0aGlzLl9iZXppZXJzLCB0aGlzLl90aW1lUmVzKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbGVuZ3RoID0gbGQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sZW5ndGhzID0gbGQubGVuZ3Rocztcblx0XHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudHMgPSBsZC5zZWdtZW50cztcblx0XHRcdFx0XHRcdFx0dGhpcy5fbDEgPSB0aGlzLl9saSA9IHRoaXMuX3MxID0gdGhpcy5fc2kgPSAwO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sMiA9IHRoaXMuX2xlbmd0aHNbMF07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N1clNlZyA9IHRoaXMuX3NlZ21lbnRzWzBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IHRoaXMuX2N1clNlZ1swXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fcHJlYyA9IDEgLyB0aGlzLl9jdXJTZWcubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoKGF1dG9Sb3RhdGUgPSB0aGlzLl9hdXRvUm90YXRlKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9pbml0aWFsUm90YXRpb25zID0gW107XG5cdFx0XHRcdFx0XHRcdGlmICghKGF1dG9Sb3RhdGVbMF0gaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9hdXRvUm90YXRlID0gYXV0b1JvdGF0ZSA9IFthdXRvUm90YXRlXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpID0gYXV0b1JvdGF0ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCAzOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHAgPSBhdXRvUm90YXRlW2ldW2pdO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZnVuY1twXSA9ICh0eXBlb2YodGFyZ2V0W3BdKSA9PT0gXCJmdW5jdGlvblwiKSA/IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0gOiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cCA9IGF1dG9Sb3RhdGVbaV1bMl07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5faW5pdGlhbFJvdGF0aW9uc1tpXSA9ICh0aGlzLl9mdW5jW3BdID8gdGhpcy5fZnVuY1twXS5jYWxsKHRoaXMuX3RhcmdldCkgOiB0aGlzLl90YXJnZXRbcF0pIHx8IDA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0UmF0aW8gPSB0d2Vlbi52YXJzLnJ1bkJhY2t3YXJkcyA/IDEgOiAwOyAvL3dlIGRldGVybWluZSB0aGUgc3RhcnRpbmcgcmF0aW8gd2hlbiB0aGUgdHdlZW4gaW5pdHMgd2hpY2ggaXMgYWx3YXlzIDAgdW5sZXNzIHRoZSB0d2VlbiBoYXMgcnVuQmFja3dhcmRzOnRydWUgKGluZGljYXRpbmcgaXQncyBhIGZyb20oKSB0d2VlbikgaW4gd2hpY2ggY2FzZSBpdCdzIDEuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly9jYWxsZWQgZWFjaCB0aW1lIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQsIGFuZCB0aGUgcmF0aW8gZ2V0cyBwYXNzZWQgYXMgdGhlIG9ubHkgcGFyYW1ldGVyICh0eXBpY2FsbHkgaXQncyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgYnV0IGl0IGNhbiBleGNlZWQgdGhvc2Ugd2hlbiB1c2luZyBhbiBlYXNlIGxpa2UgRWxhc3RpYy5lYXNlT3V0IG9yIEJhY2suZWFzZU91dCwgZXRjLilcblx0XHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ0NvdW50LFxuXHRcdFx0XHRcdFx0XHRmdW5jID0gdGhpcy5fZnVuYyxcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRub3RTdGFydCA9ICh2ICE9PSB0aGlzLl9zdGFydFJhdGlvKSxcblx0XHRcdFx0XHRcdFx0Y3VySW5kZXgsIGludiwgaSwgcCwgYiwgdCwgdmFsLCBsLCBsZW5ndGhzLCBjdXJTZWc7XG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuX3RpbWVSZXMpIHtcblx0XHRcdFx0XHRcdFx0Y3VySW5kZXggPSAodiA8IDApID8gMCA6ICh2ID49IDEpID8gc2VnbWVudHMgLSAxIDogKHNlZ21lbnRzICogdikgPj4gMDtcblx0XHRcdFx0XHRcdFx0dCA9ICh2IC0gKGN1ckluZGV4ICogKDEgLyBzZWdtZW50cykpKSAqIHNlZ21lbnRzO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGVuZ3RocyA9IHRoaXMuX2xlbmd0aHM7XG5cdFx0XHRcdFx0XHRcdGN1clNlZyA9IHRoaXMuX2N1clNlZztcblx0XHRcdFx0XHRcdFx0diAqPSB0aGlzLl9sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGkgPSB0aGlzLl9saTtcblx0XHRcdFx0XHRcdFx0Ly9maW5kIHRoZSBhcHByb3ByaWF0ZSBzZWdtZW50IChpZiB0aGUgY3VycmVudGx5IGNhY2hlZCBvbmUgaXNuJ3QgY29ycmVjdClcblx0XHRcdFx0XHRcdFx0aWYgKHYgPiB0aGlzLl9sMiAmJiBpIDwgc2VnbWVudHMgLSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0bCA9IHNlZ21lbnRzIC0gMTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA8IGwgJiYgKHRoaXMuX2wyID0gbGVuZ3Roc1srK2ldKSA8PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbDEgPSBsZW5ndGhzW2ktMV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbGkgPSBpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2N1clNlZyA9IGN1clNlZyA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gY3VyU2VnWyh0aGlzLl9zMSA9IHRoaXMuX3NpID0gMCldO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYgPCB0aGlzLl9sMSAmJiBpID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpID4gMCAmJiAodGhpcy5fbDEgPSBsZW5ndGhzWy0taV0pID49IHYpIHsgfVxuXHRcdFx0XHRcdFx0XHRcdGlmIChpID09PSAwICYmIHYgPCB0aGlzLl9sMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fbDEgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2wyID0gbGVuZ3Roc1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9saSA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY3VyU2VnID0gY3VyU2VnID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczEgPSBjdXJTZWdbKHRoaXMuX3NpID0gY3VyU2VnLmxlbmd0aCAtIDEpIC0gMV0gfHwgMDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IGN1clNlZ1t0aGlzLl9zaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y3VySW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHQvL25vdyBmaW5kIHRoZSBhcHByb3ByaWF0ZSBzdWItc2VnbWVudCAod2Ugc3BsaXQgaXQgaW50byB0aGUgbnVtYmVyIG9mIHBpZWNlcyB0aGF0IHdhcyBkZWZpbmVkIGJ5IFwicHJlY2lzaW9uXCIgYW5kIG1lYXN1cmVkIGVhY2ggb25lKVxuXHRcdFx0XHRcdFx0XHR2IC09IHRoaXMuX2wxO1xuXHRcdFx0XHRcdFx0XHRpID0gdGhpcy5fc2k7XG5cdFx0XHRcdFx0XHRcdGlmICh2ID4gdGhpcy5fczIgJiYgaSA8IGN1clNlZy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0bCA9IGN1clNlZy5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpIDwgbCAmJiAodGhpcy5fczIgPSBjdXJTZWdbKytpXSkgPD0gdikge1x0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MxID0gY3VyU2VnW2ktMV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2kgPSBpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYgPCB0aGlzLl9zMSAmJiBpID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpID4gMCAmJiAodGhpcy5fczEgPSBjdXJTZWdbLS1pXSkgPj0gdikge1x0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChpID09PSAwICYmIHYgPCB0aGlzLl9zMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fczEgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gY3VyU2VnW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NpID0gaTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0ID0gKChpICsgKHYgLSB0aGlzLl9zMSkgLyAodGhpcy5fczIgLSB0aGlzLl9zMSkpICogdGhpcy5fcHJlYykgfHwgMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGludiA9IDEgLSB0O1xuXG5cdFx0XHRcdFx0XHRpID0gdGhpcy5fcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSB0aGlzLl9wcm9wc1tpXTtcblx0XHRcdFx0XHRcdFx0YiA9IHRoaXMuX2JlemllcnNbcF1bY3VySW5kZXhdO1xuXHRcdFx0XHRcdFx0XHR2YWwgPSAodCAqIHQgKiBiLmRhICsgMyAqIGludiAqICh0ICogYi5jYSArIGludiAqIGIuYmEpKSAqIHQgKyBiLmE7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLl9yb3VuZFtwXSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9IE1hdGgucm91bmQodmFsKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoZnVuY1twXSkge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSh2YWwpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSA9IHZhbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fYXV0b1JvdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXIgPSB0aGlzLl9hdXRvUm90YXRlLFxuXHRcdFx0XHRcdFx0XHRcdGIyLCB4MSwgeTEsIHgyLCB5MiwgYWRkLCBjb252O1xuXHRcdFx0XHRcdFx0XHRpID0gYXIubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRwID0gYXJbaV1bMl07XG5cdFx0XHRcdFx0XHRcdFx0YWRkID0gYXJbaV1bM10gfHwgMDtcblx0XHRcdFx0XHRcdFx0XHRjb252ID0gKGFyW2ldWzRdID09PSB0cnVlKSA/IDEgOiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdFx0XHRiID0gdGhpcy5fYmV6aWVyc1thcltpXVswXV07XG5cdFx0XHRcdFx0XHRcdFx0YjIgPSB0aGlzLl9iZXppZXJzW2FyW2ldWzFdXTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChiICYmIGIyKSB7IC8vaW4gY2FzZSBvbmUgb2YgdGhlIHByb3BlcnRpZXMgZ290IG92ZXJ3cml0dGVuLlxuXHRcdFx0XHRcdFx0XHRcdFx0YiA9IGJbY3VySW5kZXhdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YjIgPSBiMltjdXJJbmRleF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdHgxID0gYi5hICsgKGIuYiAtIGIuYSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eDIgPSBiLmIgKyAoYi5jIC0gYi5iKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR4MSArPSAoeDIgLSB4MSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eDIgKz0gKChiLmMgKyAoYi5kIC0gYi5jKSAqIHQpIC0geDIpICogdDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0eTEgPSBiMi5hICsgKGIyLmIgLSBiMi5hKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR5MiA9IGIyLmIgKyAoYjIuYyAtIGIyLmIpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHkxICs9ICh5MiAtIHkxKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR5MiArPSAoKGIyLmMgKyAoYjIuZCAtIGIyLmMpICogdCkgLSB5MikgKiB0O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWwgPSBub3RTdGFydCA/IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkgKiBjb252ICsgYWRkIDogdGhpcy5faW5pdGlhbFJvdGF0aW9uc1tpXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGZ1bmNbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdKHZhbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0gPSB2YWw7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0XHRwID0gQmV6aWVyUGx1Z2luLnByb3RvdHlwZTtcblxuXG5cdFx0QmV6aWVyUGx1Z2luLmJlemllclRocm91Z2ggPSBiZXppZXJUaHJvdWdoO1xuXHRcdEJlemllclBsdWdpbi5jdWJpY1RvUXVhZHJhdGljID0gY3ViaWNUb1F1YWRyYXRpYztcblx0XHRCZXppZXJQbHVnaW4uX2F1dG9DU1MgPSB0cnVlOyAvL2luZGljYXRlcyB0aGF0IHRoaXMgcGx1Z2luIGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBcImNzc1wiIG9iamVjdCB1c2luZyB0aGUgYXV0b0NTUyBmZWF0dXJlIG9mIFR3ZWVuTGl0ZVxuXHRcdEJlemllclBsdWdpbi5xdWFkcmF0aWNUb0N1YmljID0gZnVuY3Rpb24oYSwgYiwgYykge1xuXHRcdFx0cmV0dXJuIG5ldyBTZWdtZW50KGEsICgyICogYiArIGEpIC8gMywgKDIgKiBiICsgYykgLyAzLCBjKTtcblx0XHR9O1xuXG5cdFx0QmV6aWVyUGx1Z2luLl9jc3NSZWdpc3RlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIENTU1BsdWdpbiA9IF9nbG9iYWxzLkNTU1BsdWdpbjtcblx0XHRcdGlmICghQ1NTUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBfaW50ZXJuYWxzID0gQ1NTUGx1Z2luLl9pbnRlcm5hbHMsXG5cdFx0XHRcdF9wYXJzZVRvUHJveHkgPSBfaW50ZXJuYWxzLl9wYXJzZVRvUHJveHksXG5cdFx0XHRcdF9zZXRQbHVnaW5SYXRpbyA9IF9pbnRlcm5hbHMuX3NldFBsdWdpblJhdGlvLFxuXHRcdFx0XHRDU1NQcm9wVHdlZW4gPSBfaW50ZXJuYWxzLkNTU1Byb3BUd2Vlbjtcblx0XHRcdF9pbnRlcm5hbHMuX3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmV6aWVyXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcHJvcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0XHRpZiAoZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0ZSA9IHt2YWx1ZXM6ZX07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGx1Z2luID0gbmV3IEJlemllclBsdWdpbigpO1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gZS52YWx1ZXMsXG5cdFx0XHRcdFx0bCA9IHZhbHVlcy5sZW5ndGggLSAxLFxuXHRcdFx0XHRcdHBsdWdpblZhbHVlcyA9IFtdLFxuXHRcdFx0XHRcdHYgPSB7fSxcblx0XHRcdFx0XHRpLCBwLCBkYXRhO1xuXHRcdFx0XHRpZiAobCA8IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8PSBsOyBpKyspIHtcblx0XHRcdFx0XHRkYXRhID0gX3BhcnNlVG9Qcm94eSh0LCB2YWx1ZXNbaV0sIGNzc3AsIHB0LCBwbHVnaW4sIChsICE9PSBpKSk7XG5cdFx0XHRcdFx0cGx1Z2luVmFsdWVzW2ldID0gZGF0YS5lbmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwIGluIGUpIHtcblx0XHRcdFx0XHR2W3BdID0gZVtwXTsgLy9kdXBsaWNhdGUgdGhlIHZhcnMgb2JqZWN0IGJlY2F1c2Ugd2UgbmVlZCB0byBhbHRlciBzb21lIHRoaW5ncyB3aGljaCB3b3VsZCBjYXVzZSBwcm9ibGVtcyBpZiB0aGUgdXNlciBwbGFucyB0byByZXVzZSB0aGUgc2FtZSB2YXJzIG9iamVjdCBmb3IgYW5vdGhlciB0d2Vlbi5cblx0XHRcdFx0fVxuXHRcdFx0XHR2LnZhbHVlcyA9IHBsdWdpblZhbHVlcztcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIFwiYmV6aWVyXCIsIDAsIDAsIGRhdGEucHQsIDIpO1xuXHRcdFx0XHRwdC5kYXRhID0gZGF0YTtcblx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRwdC5zZXRSYXRpbyA9IF9zZXRQbHVnaW5SYXRpbztcblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSA9PT0gMCkge1xuXHRcdFx0XHRcdHYuYXV0b1JvdGF0ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSAmJiAhKHYuYXV0b1JvdGF0ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0XHRcdGkgPSAodi5hdXRvUm90YXRlID09PSB0cnVlKSA/IDAgOiBOdW1iZXIodi5hdXRvUm90YXRlKTtcblx0XHRcdFx0XHR2LmF1dG9Sb3RhdGUgPSAoZGF0YS5lbmQubGVmdCAhPSBudWxsKSA/IFtbXCJsZWZ0XCIsXCJ0b3BcIixcInJvdGF0aW9uXCIsaSxmYWxzZV1dIDogKGRhdGEuZW5kLnggIT0gbnVsbCkgPyBbW1wieFwiLFwieVwiLFwicm90YXRpb25cIixpLGZhbHNlXV0gOiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi5hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0aWYgKCFjc3NwLl90cmFuc2Zvcm0pIHtcblx0XHRcdFx0XHRcdGNzc3AuX2VuYWJsZVRyYW5zZm9ybXMoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhLmF1dG9Sb3RhdGUgPSBjc3NwLl90YXJnZXQuX2dzVHJhbnNmb3JtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsdWdpbi5fb25Jbml0VHdlZW4oZGF0YS5wcm94eSwgdiwgY3NzcC5fdHdlZW4pO1xuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9fSk7XG5cdFx0fTtcblxuXHRcdHAuX3JvdW5kUHJvcHMgPSBmdW5jdGlvbihsb29rdXAsIHZhbHVlKSB7XG5cdFx0XHR2YXIgb3AgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0aSA9IG9wLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAobG9va3VwW29wW2ldXSB8fCBsb29rdXAuYmV6aWVyIHx8IGxvb2t1cC5iZXppZXJUaHJvdWdoKSB7XG5cdFx0XHRcdFx0dGhpcy5fcm91bmRbb3BbaV1dID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGEgPSB0aGlzLl9wcm9wcyxcblx0XHRcdFx0cCwgaTtcblx0XHRcdGZvciAocCBpbiB0aGlzLl9iZXppZXJzKSB7XG5cdFx0XHRcdGlmIChwIGluIGxvb2t1cCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9iZXppZXJzW3BdO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9mdW5jW3BdO1xuXHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChhW2ldID09PSBwKSB7XG5cdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyLl9raWxsLmNhbGwodGhpcywgbG9va3VwKTtcblx0XHR9O1xuXG5cdH0oKSk7XG5cblxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDU1NQbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJwbHVnaW5zLkNTU1BsdWdpblwiLCBbXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsXCJUd2VlbkxpdGVcIl0sIGZ1bmN0aW9uKFR3ZWVuUGx1Z2luLCBUd2VlbkxpdGUpIHtcblxuXHRcdC8qKiBAY29uc3RydWN0b3IgKiovXG5cdFx0dmFyIENTU1BsdWdpbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRUd2VlblBsdWdpbi5jYWxsKHRoaXMsIFwiY3NzXCIpO1xuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5sZW5ndGggPSAwO1xuXHRcdFx0XHR0aGlzLnNldFJhdGlvID0gQ1NTUGx1Z2luLnByb3RvdHlwZS5zZXRSYXRpbzsgLy9zcGVlZCBvcHRpbWl6YXRpb24gKGF2b2lkIHByb3RvdHlwZSBsb29rdXAgb24gdGhpcyBcImhvdFwiIG1ldGhvZClcblx0XHRcdH0sXG5cdFx0XHRfZ2xvYmFscyA9IF9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLFxuXHRcdFx0X2hhc1ByaW9yaXR5LCAvL3R1cm5zIHRydWUgd2hlbmV2ZXIgYSBDU1NQcm9wVHdlZW4gaW5zdGFuY2UgaXMgY3JlYXRlZCB0aGF0IGhhcyBhIHByaW9yaXR5IG90aGVyIHRoYW4gMC4gVGhpcyBoZWxwcyB1cyBkaXNjZXJuIHdoZXRoZXIgb3Igbm90IHdlIHNob3VsZCBzcGVuZCB0aGUgdGltZSBvcmdhbml6aW5nIHRoZSBsaW5rZWQgbGlzdCBvciBub3QgYWZ0ZXIgYSBDU1NQbHVnaW4ncyBfb25Jbml0VHdlZW4oKSBtZXRob2QgaXMgY2FsbGVkLlxuXHRcdFx0X3N1ZmZpeE1hcCwgLy93ZSBzZXQgdGhpcyBpbiBfb25Jbml0VHdlZW4oKSBlYWNoIHRpbWUgYXMgYSB3YXkgdG8gaGF2ZSBhIHBlcnNpc3RlbnQgdmFyaWFibGUgd2UgY2FuIHVzZSBpbiBvdGhlciBtZXRob2RzIGxpa2UgX3BhcnNlKCkgd2l0aG91dCBoYXZpbmcgdG8gcGFzcyBpdCBhcm91bmQgYXMgYSBwYXJhbWV0ZXIgYW5kIHdlIGtlZXAgX3BhcnNlKCkgZGVjb3VwbGVkIGZyb20gYSBwYXJ0aWN1bGFyIENTU1BsdWdpbiBpbnN0YW5jZVxuXHRcdFx0X2NzLCAvL2NvbXB1dGVkIHN0eWxlICh3ZSBzdG9yZSB0aGlzIGluIGEgc2hhcmVkIHZhcmlhYmxlIHRvIGNvbnNlcnZlIG1lbW9yeSBhbmQgbWFrZSBtaW5pZmljYXRpb24gdGlnaHRlclxuXHRcdFx0X292ZXJ3cml0ZVByb3BzLCAvL2FsaWFzIHRvIHRoZSBjdXJyZW50bHkgaW5zdGFudGlhdGluZyBDU1NQbHVnaW4ncyBfb3ZlcndyaXRlUHJvcHMgYXJyYXkuIFdlIHVzZSB0aGlzIGNsb3N1cmUgaW4gb3JkZXIgdG8gYXZvaWQgaGF2aW5nIHRvIHBhc3MgYSByZWZlcmVuY2UgYXJvdW5kIGZyb20gbWV0aG9kIHRvIG1ldGhvZCBhbmQgYWlkIGluIG1pbmlmaWNhdGlvbi5cblx0XHRcdF9zcGVjaWFsUHJvcHMgPSB7fSxcblx0XHRcdHAgPSBDU1NQbHVnaW4ucHJvdG90eXBlID0gbmV3IFR3ZWVuUGx1Z2luKFwiY3NzXCIpO1xuXG5cdFx0cC5jb25zdHJ1Y3RvciA9IENTU1BsdWdpbjtcblx0XHRDU1NQbHVnaW4udmVyc2lvbiA9IFwiMS4xOC40XCI7XG5cdFx0Q1NTUGx1Z2luLkFQSSA9IDI7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IDA7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRTa2V3VHlwZSA9IFwiY29tcGVuc2F0ZWRcIjtcblx0XHRDU1NQbHVnaW4uZGVmYXVsdFNtb290aE9yaWdpbiA9IHRydWU7XG5cdFx0cCA9IFwicHhcIjsgLy93ZSdsbCByZXVzZSB0aGUgXCJwXCIgdmFyaWFibGUgdG8ga2VlcCBmaWxlIHNpemUgZG93blxuXHRcdENTU1BsdWdpbi5zdWZmaXhNYXAgPSB7dG9wOnAsIHJpZ2h0OnAsIGJvdHRvbTpwLCBsZWZ0OnAsIHdpZHRoOnAsIGhlaWdodDpwLCBmb250U2l6ZTpwLCBwYWRkaW5nOnAsIG1hcmdpbjpwLCBwZXJzcGVjdGl2ZTpwLCBsaW5lSGVpZ2h0OlwiXCJ9O1xuXG5cblx0XHR2YXIgX251bUV4cCA9IC8oPzpcXC18XFwufFxcYikoXFxkfFxcLnxlXFwtKSsvZyxcblx0XHRcdF9yZWxOdW1FeHAgPSAvKD86XFxkfFxcLVxcZHxcXC5cXGR8XFwtXFwuXFxkfFxcKz1cXGR8XFwtPVxcZHxcXCs9LlxcZHxcXC09XFwuXFxkKSsvZyxcblx0XHRcdF92YWx1ZXNFeHAgPSAvKD86XFwrPXxcXC09fFxcLXxcXGIpW1xcZFxcLVxcLl0rW2EtekEtWjAtOV0qKD86JXxcXGIpL2dpLCAvL2ZpbmRzIGFsbCB0aGUgdmFsdWVzIHRoYXQgYmVnaW4gd2l0aCBudW1iZXJzIG9yICs9IG9yIC09IGFuZCB0aGVuIGEgbnVtYmVyLiBJbmNsdWRlcyBzdWZmaXhlcy4gV2UgdXNlIHRoaXMgdG8gc3BsaXQgY29tcGxleCB2YWx1ZXMgYXBhcnQgbGlrZSBcIjFweCA1cHggMjBweCByZ2IoMjU1LDEwMiw1MSlcIlxuXHRcdFx0X05hTkV4cCA9IC8oPyFbKy1dP1xcZCpcXC4/XFxkK3xbKy1dfGVbKy1dXFxkKylbXjAtOV0vZywgLy9hbHNvIGFsbG93cyBzY2llbnRpZmljIG5vdGF0aW9uIGFuZCBkb2Vzbid0IGtpbGwgdGhlIGxlYWRpbmcgLS8rIGluIC09IGFuZCArPVxuXHRcdFx0X3N1ZmZpeEV4cCA9IC8oPzpcXGR8XFwtfFxcK3w9fCN8XFwuKSovZyxcblx0XHRcdF9vcGFjaXR5RXhwID0gL29wYWNpdHkgKj0gKihbXildKikvaSxcblx0XHRcdF9vcGFjaXR5VmFsRXhwID0gL29wYWNpdHk6KFteO10qKS9pLFxuXHRcdFx0X2FscGhhRmlsdGVyRXhwID0gL2FscGhhXFwob3BhY2l0eSAqPS4rP1xcKS9pLFxuXHRcdFx0X3JnYmhzbEV4cCA9IC9eKHJnYnxoc2wpLyxcblx0XHRcdF9jYXBzRXhwID0gLyhbQS1aXSkvZyxcblx0XHRcdF9jYW1lbEV4cCA9IC8tKFthLXpdKS9naSxcblx0XHRcdF91cmxFeHAgPSAvKF4oPzp1cmxcXChcXFwifHVybFxcKCkpfCg/OihcXFwiXFwpKSR8XFwpJCkvZ2ksIC8vZm9yIHB1bGxpbmcgb3V0IHVybHMgZnJvbSB1cmwoLi4uKSBvciB1cmwoXCIuLi5cIikgc3RyaW5ncyAoc29tZSBicm93c2VycyB3cmFwIHVybHMgaW4gcXVvdGVzLCBzb21lIGRvbid0IHdoZW4gcmVwb3J0aW5nIHRoaW5ncyBsaWtlIGJhY2tncm91bmRJbWFnZSlcblx0XHRcdF9jYW1lbEZ1bmMgPSBmdW5jdGlvbihzLCBnKSB7IHJldHVybiBnLnRvVXBwZXJDYXNlKCk7IH0sXG5cdFx0XHRfaG9yaXpFeHAgPSAvKD86TGVmdHxSaWdodHxXaWR0aCkvaSxcblx0XHRcdF9pZUdldE1hdHJpeEV4cCA9IC8oTTExfE0xMnxNMjF8TTIyKT1bXFxkXFwtXFwuZV0rL2dpLFxuXHRcdFx0X2llU2V0TWF0cml4RXhwID0gL3Byb2dpZFxcOkRYSW1hZ2VUcmFuc2Zvcm1cXC5NaWNyb3NvZnRcXC5NYXRyaXhcXCguKz9cXCkvaSxcblx0XHRcdF9jb21tYXNPdXRzaWRlUGFyZW5FeHAgPSAvLCg/PVteXFwpXSooPzpcXCh8JCkpL2dpLCAvL2ZpbmRzIGFueSBjb21tYXMgdGhhdCBhcmUgbm90IHdpdGhpbiBwYXJlbnRoZXNpc1xuXHRcdFx0X2NvbXBsZXhFeHAgPSAvW1xccyxcXChdL2ksIC8vZm9yIHRlc3RpbmcgYSBzdHJpbmcgdG8gZmluZCBpZiBpdCBoYXMgYSBzcGFjZSwgY29tbWEsIG9yIG9wZW4gcGFyZW50aGVzaXMgKGNsdWVzIHRoYXQgaXQncyBhIGNvbXBsZXggdmFsdWUpXG5cdFx0XHRfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG5cdFx0XHRfZm9yY2VQVCA9IHt9LFxuXHRcdFx0X2RvYyA9IGRvY3VtZW50LFxuXHRcdFx0X2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdHJldHVybiBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTtcblx0XHRcdH0sXG5cdFx0XHRfdGVtcERpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuXHRcdFx0X3RlbXBJbWcgPSBfY3JlYXRlRWxlbWVudChcImltZ1wiKSxcblx0XHRcdF9pbnRlcm5hbHMgPSBDU1NQbHVnaW4uX2ludGVybmFscyA9IHtfc3BlY2lhbFByb3BzOl9zcGVjaWFsUHJvcHN9LCAvL3Byb3ZpZGVzIGEgaG9vayB0byBhIGZldyBpbnRlcm5hbCBtZXRob2RzIHRoYXQgd2UgbmVlZCB0byBhY2Nlc3MgZnJvbSBpbnNpZGUgb3RoZXIgcGx1Z2luc1xuXHRcdFx0X2FnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcblx0XHRcdF9hdXRvUm91bmQsXG5cdFx0XHRfcmVxU2FmYXJpRml4LCAvL3dlIHdvbid0IGFwcGx5IHRoZSBTYWZhcmkgdHJhbnNmb3JtIGZpeCB1bnRpbCB3ZSBhY3R1YWxseSBjb21lIGFjcm9zcyBhIHR3ZWVuIHRoYXQgYWZmZWN0cyBhIHRyYW5zZm9ybSBwcm9wZXJ0eSAodG8gbWFpbnRhaW4gYmVzdCBwZXJmb3JtYW5jZSkuXG5cblx0XHRcdF9pc1NhZmFyaSxcblx0XHRcdF9pc0ZpcmVmb3gsIC8vRmlyZWZveCBoYXMgYSBidWcgdGhhdCBjYXVzZXMgM0QgdHJhbnNmb3JtZWQgZWxlbWVudHMgdG8gcmFuZG9tbHkgZGlzYXBwZWFyIHVubGVzcyBhIHJlcGFpbnQgaXMgZm9yY2VkIGFmdGVyIGVhY2ggdXBkYXRlIG9uIGVhY2ggZWxlbWVudC5cblx0XHRcdF9pc1NhZmFyaUxUNiwgLy9TYWZhcmkgKGFuZCBBbmRyb2lkIDQgd2hpY2ggdXNlcyBhIGZsYXZvciBvZiBTYWZhcmkpIGhhcyBhIGJ1ZyB0aGF0IHByZXZlbnRzIGNoYW5nZXMgdG8gXCJ0b3BcIiBhbmQgXCJsZWZ0XCIgcHJvcGVydGllcyBmcm9tIHJlbmRlcmluZyBwcm9wZXJseSBpZiBjaGFuZ2VkIG9uIHRoZSBzYW1lIGZyYW1lIGFzIGEgdHJhbnNmb3JtIFVOTEVTUyB3ZSBzZXQgdGhlIGVsZW1lbnQncyBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgdG8gaGlkZGVuICh3ZWlyZCwgSSBrbm93KS4gRG9pbmcgdGhpcyBmb3IgQW5kcm9pZCAzIGFuZCBlYXJsaWVyIHNlZW1zIHRvIGFjdHVhbGx5IGNhdXNlIG90aGVyIHByb2JsZW1zLCB0aG91Z2ggKGZ1biEpXG5cdFx0XHRfaWVWZXJzLFxuXHRcdFx0X3N1cHBvcnRzT3BhY2l0eSA9IChmdW5jdGlvbigpIHsgLy93ZSBzZXQgX2lzU2FmYXJpLCBfaWVWZXJzLCBfaXNGaXJlZm94LCBhbmQgX3N1cHBvcnRzT3BhY2l0eSBhbGwgaW4gb25lIGZ1bmN0aW9uIGhlcmUgdG8gcmVkdWNlIGZpbGUgc2l6ZSBzbGlnaHRseSwgZXNwZWNpYWxseSBpbiB0aGUgbWluaWZpZWQgdmVyc2lvbi5cblx0XHRcdFx0dmFyIGkgPSBfYWdlbnQuaW5kZXhPZihcIkFuZHJvaWRcIiksXG5cdFx0XHRcdFx0YSA9IF9jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHRcdFx0X2lzU2FmYXJpID0gKF9hZ2VudC5pbmRleE9mKFwiU2FmYXJpXCIpICE9PSAtMSAmJiBfYWdlbnQuaW5kZXhPZihcIkNocm9tZVwiKSA9PT0gLTEgJiYgKGkgPT09IC0xIHx8IE51bWJlcihfYWdlbnQuc3Vic3RyKGkrOCwgMSkpID4gMykpO1xuXHRcdFx0XHRfaXNTYWZhcmlMVDYgPSAoX2lzU2FmYXJpICYmIChOdW1iZXIoX2FnZW50LnN1YnN0cihfYWdlbnQuaW5kZXhPZihcIlZlcnNpb24vXCIpKzgsIDEpKSA8IDYpKTtcblx0XHRcdFx0X2lzRmlyZWZveCA9IChfYWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgIT09IC0xKTtcblx0XHRcdFx0aWYgKCgvTVNJRSAoWzAtOV17MSx9W1xcLjAtOV17MCx9KS8pLmV4ZWMoX2FnZW50KSB8fCAoL1RyaWRlbnRcXC8uKnJ2OihbMC05XXsxLH1bXFwuMC05XXswLH0pLykuZXhlYyhfYWdlbnQpKSB7XG5cdFx0XHRcdFx0X2llVmVycyA9IHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhLnN0eWxlLmNzc1RleHQgPSBcInRvcDoxcHg7b3BhY2l0eTouNTU7XCI7XG5cdFx0XHRcdHJldHVybiAvXjAuNTUvLnRlc3QoYS5zdHlsZS5vcGFjaXR5KTtcblx0XHRcdH0oKSksXG5cdFx0XHRfZ2V0SUVPcGFjaXR5ID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHRyZXR1cm4gKF9vcGFjaXR5RXhwLnRlc3QoICgodHlwZW9mKHYpID09PSBcInN0cmluZ1wiKSA/IHYgOiAodi5jdXJyZW50U3R5bGUgPyB2LmN1cnJlbnRTdHlsZS5maWx0ZXIgOiB2LnN0eWxlLmZpbHRlcikgfHwgXCJcIikgKSA/ICggcGFyc2VGbG9hdCggUmVnRXhwLiQxICkgLyAxMDAgKSA6IDEpO1xuXHRcdFx0fSxcblx0XHRcdF9sb2cgPSBmdW5jdGlvbihzKSB7Ly9mb3IgbG9nZ2luZyBtZXNzYWdlcywgYnV0IGluIGEgd2F5IHRoYXQgd29uJ3QgdGhyb3cgZXJyb3JzIGluIG9sZCB2ZXJzaW9ucyBvZiBJRS5cblx0XHRcdFx0aWYgKHdpbmRvdy5jb25zb2xlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2cocyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9wcmVmaXhDU1MgPSBcIlwiLCAvL3RoZSBub24tY2FtZWxDYXNlIHZlbmRvciBwcmVmaXggbGlrZSBcIi1vLVwiLCBcIi1tb3otXCIsIFwiLW1zLVwiLCBvciBcIi13ZWJraXQtXCJcblx0XHRcdF9wcmVmaXggPSBcIlwiLCAvL2NhbWVsQ2FzZSB2ZW5kb3IgcHJlZml4IGxpa2UgXCJPXCIsIFwibXNcIiwgXCJXZWJraXRcIiwgb3IgXCJNb3pcIi5cblxuXHRcdFx0Ly8gQHByaXZhdGUgZmVlZCBpbiBhIGNhbWVsQ2FzZSBwcm9wZXJ0eSBuYW1lIGxpa2UgXCJ0cmFuc2Zvcm1cIiBhbmQgaXQgd2lsbCBjaGVjayB0byBzZWUgaWYgaXQgaXMgdmFsaWQgYXMtaXMgb3IgaWYgaXQgbmVlZHMgYSB2ZW5kb3IgcHJlZml4LiBJdCByZXR1cm5zIHRoZSBjb3JyZWN0ZWQgY2FtZWxDYXNlIHByb3BlcnR5IG5hbWUgKGkuZS4gXCJXZWJraXRUcmFuc2Zvcm1cIiBvciBcIk1velRyYW5zZm9ybVwiIG9yIFwidHJhbnNmb3JtXCIgb3IgbnVsbCBpZiBubyBzdWNoIHByb3BlcnR5IGlzIGZvdW5kLCBsaWtlIGlmIHRoZSBicm93c2VyIGlzIElFOCBvciBiZWZvcmUsIFwidHJhbnNmb3JtXCIgd29uJ3QgYmUgZm91bmQgYXQgYWxsKVxuXHRcdFx0X2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uKHAsIGUpIHtcblx0XHRcdFx0ZSA9IGUgfHwgX3RlbXBEaXY7XG5cdFx0XHRcdHZhciBzID0gZS5zdHlsZSxcblx0XHRcdFx0XHRhLCBpO1xuXHRcdFx0XHRpZiAoc1twXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cCA9IHAuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwLnN1YnN0cigxKTtcblx0XHRcdFx0YSA9IFtcIk9cIixcIk1velwiLFwibXNcIixcIk1zXCIsXCJXZWJraXRcIl07XG5cdFx0XHRcdGkgPSA1O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEgJiYgc1thW2ldK3BdID09PSB1bmRlZmluZWQpIHsgfVxuXHRcdFx0XHRpZiAoaSA+PSAwKSB7XG5cdFx0XHRcdFx0X3ByZWZpeCA9IChpID09PSAzKSA/IFwibXNcIiA6IGFbaV07XG5cdFx0XHRcdFx0X3ByZWZpeENTUyA9IFwiLVwiICsgX3ByZWZpeC50b0xvd2VyQ2FzZSgpICsgXCItXCI7XG5cdFx0XHRcdFx0cmV0dXJuIF9wcmVmaXggKyBwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0X2dldENvbXB1dGVkU3R5bGUgPSBfZG9jLmRlZmF1bHRWaWV3ID8gX2RvYy5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlIDogZnVuY3Rpb24oKSB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBSZXR1cm5zIHRoZSBjc3Mgc3R5bGUgZm9yIGEgcGFydGljdWxhciBwcm9wZXJ0eSBvZiBhbiBlbGVtZW50LiBGb3IgZXhhbXBsZSwgdG8gZ2V0IHdoYXRldmVyIHRoZSBjdXJyZW50IFwibGVmdFwiIGNzcyB2YWx1ZSBmb3IgYW4gZWxlbWVudCB3aXRoIGFuIElEIG9mIFwibXlFbGVtZW50XCIsIHlvdSBjb3VsZCBkbzpcblx0XHRcdCAqIHZhciBjdXJyZW50TGVmdCA9IENTU1BsdWdpbi5nZXRTdHlsZSggZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteUVsZW1lbnRcIiksIFwibGVmdFwiKTtcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IGVsZW1lbnQgd2hvc2Ugc3R5bGUgcHJvcGVydHkgeW91IHdhbnQgdG8gcXVlcnlcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lIChsaWtlIFwibGVmdFwiIG9yIFwidG9wXCIgb3IgXCJtYXJnaW5Ub3BcIiwgZXRjLilcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gY3MgQ29tcHV0ZWQgc3R5bGUgb2JqZWN0LiBUaGlzIGp1c3QgcHJvdmlkZXMgYSB3YXkgdG8gc3BlZWQgcHJvY2Vzc2luZyBpZiB5b3UncmUgZ29pbmcgdG8gZ2V0IHNldmVyYWwgcHJvcGVydGllcyBvbiB0aGUgc2FtZSBlbGVtZW50IGluIHF1aWNrIHN1Y2Nlc3Npb24gLSB5b3UgY2FuIHJldXNlIHRoZSByZXN1bHQgb2YgdGhlIGdldENvbXB1dGVkU3R5bGUoKSBjYWxsLlxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gY2FsYyBJZiB0cnVlLCB0aGUgdmFsdWUgd2lsbCBub3QgYmUgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBlbGVtZW50J3MgXCJzdHlsZVwiIHByb3BlcnR5IChpZiBpdCBleGlzdHMgdGhlcmUpLCBidXQgaW5zdGVhZCB0aGUgZ2V0Q29tcHV0ZWRTdHlsZSgpIHJlc3VsdCB3aWxsIGJlIHVzZWQuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IHRoZSBicm93c2VyIGl0c2VsZiBpcyBpbnRlcnByZXRpbmcgdGhlIHZhbHVlLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBkZmx0IERlZmF1bHQgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmV0dXJuZWQgaW4gdGhlIHBsYWNlIG9mIG51bGwsIFwibm9uZVwiLCBcImF1dG9cIiBvciBcImF1dG8gYXV0b1wiLlxuXHRcdFx0ICogQHJldHVybiB7P3N0cmluZ30gVGhlIGN1cnJlbnQgcHJvcGVydHkgdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0X2dldFN0eWxlID0gQ1NTUGx1Z2luLmdldFN0eWxlID0gZnVuY3Rpb24odCwgcCwgY3MsIGNhbGMsIGRmbHQpIHtcblx0XHRcdFx0dmFyIHJ2O1xuXHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkpIGlmIChwID09PSBcIm9wYWNpdHlcIikgeyAvL3NldmVyYWwgdmVyc2lvbnMgb2YgSUUgZG9uJ3QgdXNlIHRoZSBzdGFuZGFyZCBcIm9wYWNpdHlcIiBwcm9wZXJ0eSAtIHRoZXkgdXNlIHRoaW5ncyBsaWtlIGZpbHRlcjphbHBoYShvcGFjaXR5PTUwKSwgc28gd2UgcGFyc2UgdGhhdCBoZXJlLlxuXHRcdFx0XHRcdHJldHVybiBfZ2V0SUVPcGFjaXR5KHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghY2FsYyAmJiB0LnN0eWxlW3BdKSB7XG5cdFx0XHRcdFx0cnYgPSB0LnN0eWxlW3BdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKChjcyA9IGNzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQpKSkge1xuXHRcdFx0XHRcdHJ2ID0gY3NbcF0gfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwKSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHAucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodC5jdXJyZW50U3R5bGUpIHtcblx0XHRcdFx0XHRydiA9IHQuY3VycmVudFN0eWxlW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoZGZsdCAhPSBudWxsICYmICghcnYgfHwgcnYgPT09IFwibm9uZVwiIHx8IHJ2ID09PSBcImF1dG9cIiB8fCBydiA9PT0gXCJhdXRvIGF1dG9cIikpID8gZGZsdCA6IHJ2O1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBQYXNzIHRoZSB0YXJnZXQgZWxlbWVudCwgdGhlIHByb3BlcnR5IG5hbWUsIHRoZSBudW1lcmljIHZhbHVlLCBhbmQgdGhlIHN1ZmZpeCAobGlrZSBcIiVcIiwgXCJlbVwiLCBcInB4XCIsIGV0Yy4pIGFuZCBpdCB3aWxsIHNwaXQgYmFjayB0aGUgZXF1aXZhbGVudCBwaXhlbCBudW1iZXIuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lIChsaWtlIFwibGVmdFwiLCBcInRvcFwiLCBcIm1hcmdpbkxlZnRcIiwgZXRjLilcblx0XHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gdiBWYWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBzZnggU3VmZml4IChsaWtlIFwicHhcIiBvciBcIiVcIiBvciBcImVtXCIpXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWN1cnNlIElmIHRydWUsIHRoZSBjYWxsIGlzIGEgcmVjdXJzaXZlIG9uZS4gSW4gc29tZSBicm93c2VycyAobGlrZSBJRTcvOCksIG9jY2FzaW9uYWxseSB0aGUgdmFsdWUgaXNuJ3QgYWNjdXJhdGVseSByZXBvcnRlZCBpbml0aWFsbHksIGJ1dCBpZiB3ZSBydW4gdGhlIGZ1bmN0aW9uIGFnYWluIGl0IHdpbGwgdGFrZSBlZmZlY3QuXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IHZhbHVlIGluIHBpeGVsc1xuXHRcdFx0ICovXG5cdFx0XHRfY29udmVydFRvUGl4ZWxzID0gX2ludGVybmFscy5jb252ZXJ0VG9QaXhlbHMgPSBmdW5jdGlvbih0LCBwLCB2LCBzZngsIHJlY3Vyc2UpIHtcblx0XHRcdFx0aWYgKHNmeCA9PT0gXCJweFwiIHx8ICFzZngpIHsgcmV0dXJuIHY7IH1cblx0XHRcdFx0aWYgKHNmeCA9PT0gXCJhdXRvXCIgfHwgIXYpIHsgcmV0dXJuIDA7IH1cblx0XHRcdFx0dmFyIGhvcml6ID0gX2hvcml6RXhwLnRlc3QocCksXG5cdFx0XHRcdFx0bm9kZSA9IHQsXG5cdFx0XHRcdFx0c3R5bGUgPSBfdGVtcERpdi5zdHlsZSxcblx0XHRcdFx0XHRuZWcgPSAodiA8IDApLFxuXHRcdFx0XHRcdHBpeCwgY2FjaGUsIHRpbWU7XG5cdFx0XHRcdGlmIChuZWcpIHtcblx0XHRcdFx0XHR2ID0gLXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNmeCA9PT0gXCIlXCIgJiYgcC5pbmRleE9mKFwiYm9yZGVyXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdHBpeCA9ICh2IC8gMTAwKSAqIChob3JpeiA/IHQuY2xpZW50V2lkdGggOiB0LmNsaWVudEhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjAgc29saWQgcmVkO3Bvc2l0aW9uOlwiICsgX2dldFN0eWxlKHQsIFwicG9zaXRpb25cIikgKyBcIjtsaW5lLWhlaWdodDowO1wiO1xuXHRcdFx0XHRcdGlmIChzZnggPT09IFwiJVwiIHx8ICFub2RlLmFwcGVuZENoaWxkIHx8IHNmeC5jaGFyQXQoMCkgPT09IFwidlwiIHx8IHNmeCA9PT0gXCJyZW1cIikge1xuXHRcdFx0XHRcdFx0bm9kZSA9IHQucGFyZW50Tm9kZSB8fCBfZG9jLmJvZHk7XG5cdFx0XHRcdFx0XHRjYWNoZSA9IG5vZGUuX2dzQ2FjaGU7XG5cdFx0XHRcdFx0XHR0aW1lID0gVHdlZW5MaXRlLnRpY2tlci5mcmFtZTtcblx0XHRcdFx0XHRcdGlmIChjYWNoZSAmJiBob3JpeiAmJiBjYWNoZS50aW1lID09PSB0aW1lKSB7IC8vcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiB3ZSByZWNvcmQgdGhlIHdpZHRoIG9mIGVsZW1lbnRzIGFsb25nIHdpdGggdGhlIHRpY2tlciBmcmFtZSBzbyB0aGF0IHdlIGNhbiBxdWlja2x5IGdldCBpdCBhZ2FpbiBvbiB0aGUgc2FtZSB0aWNrIChzZWVtcyByZWxhdGl2ZWx5IHNhZmUgdG8gYXNzdW1lIGl0IHdvdWxkbid0IGNoYW5nZSBvbiB0aGUgc2FtZSB0aWNrKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2FjaGUud2lkdGggKiB2IC8gMTAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3R5bGVbKGhvcml6ID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIildID0gdiArIHNmeDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3R5bGVbKGhvcml6ID8gXCJib3JkZXJMZWZ0V2lkdGhcIiA6IFwiYm9yZGVyVG9wV2lkdGhcIildID0gdiArIHNmeDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChfdGVtcERpdik7XG5cdFx0XHRcdFx0cGl4ID0gcGFyc2VGbG9hdChfdGVtcERpdlsoaG9yaXogPyBcIm9mZnNldFdpZHRoXCIgOiBcIm9mZnNldEhlaWdodFwiKV0pO1xuXHRcdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRcdGlmIChob3JpeiAmJiBzZnggPT09IFwiJVwiICYmIENTU1BsdWdpbi5jYWNoZVdpZHRocyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGNhY2hlID0gbm9kZS5fZ3NDYWNoZSA9IG5vZGUuX2dzQ2FjaGUgfHwge307XG5cdFx0XHRcdFx0XHRjYWNoZS50aW1lID0gdGltZTtcblx0XHRcdFx0XHRcdGNhY2hlLndpZHRoID0gcGl4IC8gdiAqIDEwMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBpeCA9PT0gMCAmJiAhcmVjdXJzZSkge1xuXHRcdFx0XHRcdFx0cGl4ID0gX2NvbnZlcnRUb1BpeGVscyh0LCBwLCB2LCBzZngsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbmVnID8gLXBpeCA6IHBpeDtcblx0XHRcdH0sXG5cdFx0XHRfY2FsY3VsYXRlT2Zmc2V0ID0gX2ludGVybmFscy5jYWxjdWxhdGVPZmZzZXQgPSBmdW5jdGlvbih0LCBwLCBjcykgeyAvL2ZvciBmaWd1cmluZyBvdXQgXCJ0b3BcIiBvciBcImxlZnRcIiBpbiBweCB3aGVuIGl0J3MgXCJhdXRvXCIuIFdlIG5lZWQgdG8gZmFjdG9yIGluIG1hcmdpbiB3aXRoIHRoZSBvZmZzZXRMZWZ0L29mZnNldFRvcFxuXHRcdFx0XHRpZiAoX2dldFN0eWxlKHQsIFwicG9zaXRpb25cIiwgY3MpICE9PSBcImFic29sdXRlXCIpIHsgcmV0dXJuIDA7IH1cblx0XHRcdFx0dmFyIGRpbSA9ICgocCA9PT0gXCJsZWZ0XCIpID8gXCJMZWZ0XCIgOiBcIlRvcFwiKSxcblx0XHRcdFx0XHR2ID0gX2dldFN0eWxlKHQsIFwibWFyZ2luXCIgKyBkaW0sIGNzKTtcblx0XHRcdFx0cmV0dXJuIHRbXCJvZmZzZXRcIiArIGRpbV0gLSAoX2NvbnZlcnRUb1BpeGVscyh0LCBwLCBwYXJzZUZsb2F0KHYpLCB2LnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIikpIHx8IDApO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgcmV0dXJucyBhdCBvYmplY3QgY29udGFpbmluZyBBTEwgb2YgdGhlIHN0eWxlIHByb3BlcnRpZXMgaW4gY2FtZWxDYXNlIGFuZCB0aGVpciBhc3NvY2lhdGVkIHZhbHVlcy5cblx0XHRcdF9nZXRBbGxTdHlsZXMgPSBmdW5jdGlvbih0LCBjcykge1xuXHRcdFx0XHR2YXIgcyA9IHt9LFxuXHRcdFx0XHRcdGksIHRyLCBwO1xuXHRcdFx0XHRpZiAoKGNzID0gY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCwgbnVsbCkpKSB7XG5cdFx0XHRcdFx0aWYgKChpID0gY3MubGVuZ3RoKSkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSBjc1tpXTtcblx0XHRcdFx0XHRcdFx0aWYgKHAuaW5kZXhPZihcIi10cmFuc2Zvcm1cIikgPT09IC0xIHx8IF90cmFuc2Zvcm1Qcm9wQ1NTID09PSBwKSB7IC8vU29tZSB3ZWJraXQgYnJvd3NlcnMgZHVwbGljYXRlIHRyYW5zZm9ybSB2YWx1ZXMsIG9uZSBub24tcHJlZml4ZWQgYW5kIG9uZSBwcmVmaXhlZCAoXCJ0cmFuc2Zvcm1cIiBhbmQgXCJXZWJraXRUcmFuc2Zvcm1cIiksIHNvIHdlIG11c3Qgd2VlZCBvdXQgdGhlIGV4dHJhIG9uZSBoZXJlLlxuXHRcdFx0XHRcdFx0XHRcdHNbcC5yZXBsYWNlKF9jYW1lbEV4cCwgX2NhbWVsRnVuYyldID0gY3MuZ2V0UHJvcGVydHlWYWx1ZShwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7IC8vc29tZSBicm93c2VycyBiZWhhdmUgZGlmZmVyZW50bHkgLSBjcy5sZW5ndGggaXMgYWx3YXlzIDAsIHNvIHdlIG11c3QgZG8gYSBmb3IuLi5pbiBsb29wLlxuXHRcdFx0XHRcdFx0Zm9yIChpIGluIGNzKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpLmluZGV4T2YoXCJUcmFuc2Zvcm1cIikgPT09IC0xIHx8IF90cmFuc2Zvcm1Qcm9wID09PSBpKSB7IC8vU29tZSB3ZWJraXQgYnJvd3NlcnMgZHVwbGljYXRlIHRyYW5zZm9ybSB2YWx1ZXMsIG9uZSBub24tcHJlZml4ZWQgYW5kIG9uZSBwcmVmaXhlZCAoXCJ0cmFuc2Zvcm1cIiBhbmQgXCJXZWJraXRUcmFuc2Zvcm1cIiksIHNvIHdlIG11c3Qgd2VlZCBvdXQgdGhlIGV4dHJhIG9uZSBoZXJlLlxuXHRcdFx0XHRcdFx0XHRcdHNbaV0gPSBjc1tpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICgoY3MgPSB0LmN1cnJlbnRTdHlsZSB8fCB0LnN0eWxlKSkge1xuXHRcdFx0XHRcdGZvciAoaSBpbiBjcykge1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZihpKSA9PT0gXCJzdHJpbmdcIiAmJiBzW2ldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0c1tpLnJlcGxhY2UoX2NhbWVsRXhwLCBfY2FtZWxGdW5jKV0gPSBjc1tpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFfc3VwcG9ydHNPcGFjaXR5KSB7XG5cdFx0XHRcdFx0cy5vcGFjaXR5ID0gX2dldElFT3BhY2l0eSh0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ciA9IF9nZXRUcmFuc2Zvcm0odCwgY3MsIGZhbHNlKTtcblx0XHRcdFx0cy5yb3RhdGlvbiA9IHRyLnJvdGF0aW9uO1xuXHRcdFx0XHRzLnNrZXdYID0gdHIuc2tld1g7XG5cdFx0XHRcdHMuc2NhbGVYID0gdHIuc2NhbGVYO1xuXHRcdFx0XHRzLnNjYWxlWSA9IHRyLnNjYWxlWTtcblx0XHRcdFx0cy54ID0gdHIueDtcblx0XHRcdFx0cy55ID0gdHIueTtcblx0XHRcdFx0aWYgKF9zdXBwb3J0czNEKSB7XG5cdFx0XHRcdFx0cy56ID0gdHIuejtcblx0XHRcdFx0XHRzLnJvdGF0aW9uWCA9IHRyLnJvdGF0aW9uWDtcblx0XHRcdFx0XHRzLnJvdGF0aW9uWSA9IHRyLnJvdGF0aW9uWTtcblx0XHRcdFx0XHRzLnNjYWxlWiA9IHRyLnNjYWxlWjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocy5maWx0ZXJzKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHMuZmlsdGVycztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBwcml2YXRlIGFuYWx5emVzIHR3byBzdHlsZSBvYmplY3RzIChhcyByZXR1cm5lZCBieSBfZ2V0QWxsU3R5bGVzKCkpIGFuZCBvbmx5IGxvb2tzIGZvciBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZW0gdGhhdCBjb250YWluIHR3ZWVuYWJsZSB2YWx1ZXMgKGxpa2UgYSBudW1iZXIgb3IgY29sb3IpLiBJdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgXCJkaWZzXCIgcHJvcGVydHkgd2hpY2ggcmVmZXJzIHRvIGFuIG9iamVjdCBjb250YWluaW5nIG9ubHkgdGhvc2UgaXNvbGF0ZWQgcHJvcGVydGllcyBhbmQgdmFsdWVzIGZvciB0d2VlbmluZywgYW5kIGEgXCJmaXJzdE1QVFwiIHByb3BlcnR5IHdoaWNoIHJlZmVycyB0byB0aGUgZmlyc3QgTWluaVByb3BUd2VlbiBpbnN0YW5jZSBpbiBhIGxpbmtlZCBsaXN0IHRoYXQgcmVjb3JkZWQgYWxsIHRoZSBzdGFydGluZyB2YWx1ZXMgb2YgdGhlIGRpZmZlcmVudCBwcm9wZXJ0aWVzIHNvIHRoYXQgd2UgY2FuIHJldmVydCB0byB0aGVtIGF0IHRoZSBlbmQgb3IgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiAtIHdlIGRvbid0IHdhbnQgdGhlIGNhc2NhZGluZyB0byBnZXQgbWVzc2VkIHVwLiBUaGUgZm9yY2VMb29rdXAgcGFyYW1ldGVyIGlzIGFuIG9wdGlvbmFsIGdlbmVyaWMgb2JqZWN0IHdpdGggcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBmb3JjZWQgaW50byB0aGUgcmVzdWx0cyAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjbGFzc05hbWUgdHdlZW5zIHRoYXQgYXJlIG92ZXJ3cml0aW5nIG90aGVycyBiZWNhdXNlIGltYWdpbmUgYSBzY2VuYXJpbyB3aGVyZSBhIHJvbGxvdmVyL3JvbGxvdXQgYWRkcy9yZW1vdmVzIGEgY2xhc3MgYW5kIHRoZSB1c2VyIHN3aXBlcyB0aGUgbW91c2Ugb3ZlciB0aGUgdGFyZ2V0IFNVUEVSIGZhc3QsIHRodXMgbm90aGluZyBhY3R1YWxseSBjaGFuZ2VkIHlldCBhbmQgdGhlIHN1YnNlcXVlbnQgY29tcGFyaXNvbiBvZiB0aGUgcHJvcGVydGllcyB3b3VsZCBpbmRpY2F0ZSB0aGV5IG1hdGNoIChlc3BlY2lhbGx5IHdoZW4gcHggcm91bmRpbmcgaXMgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uKSwgdGh1cyBubyB0d2VlbmluZyBpcyBuZWNlc3NhcnkgZXZlbiB0aG91Z2ggaXQgU0hPVUxEIHR3ZWVuIGFuZCByZW1vdmUgdGhvc2UgcHJvcGVydGllcyBhZnRlciB0aGUgdHdlZW4gKG90aGVyd2lzZSB0aGUgaW5saW5lIHN0eWxlcyB3aWxsIGNvbnRhbWluYXRlIHRoaW5ncykuIFNlZSB0aGUgY2xhc3NOYW1lIFNwZWNpYWxQcm9wIGNvZGUgZm9yIGRldGFpbHMuXG5cdFx0XHRfY3NzRGlmID0gZnVuY3Rpb24odCwgczEsIHMyLCB2YXJzLCBmb3JjZUxvb2t1cCkge1xuXHRcdFx0XHR2YXIgZGlmcyA9IHt9LFxuXHRcdFx0XHRcdHN0eWxlID0gdC5zdHlsZSxcblx0XHRcdFx0XHR2YWwsIHAsIG1wdDtcblx0XHRcdFx0Zm9yIChwIGluIHMyKSB7XG5cdFx0XHRcdFx0aWYgKHAgIT09IFwiY3NzVGV4dFwiKSBpZiAocCAhPT0gXCJsZW5ndGhcIikgaWYgKGlzTmFOKHApKSBpZiAoczFbcF0gIT09ICh2YWwgPSBzMltwXSkgfHwgKGZvcmNlTG9va3VwICYmIGZvcmNlTG9va3VwW3BdKSkgaWYgKHAuaW5kZXhPZihcIk9yaWdpblwiKSA9PT0gLTEpIGlmICh0eXBlb2YodmFsKSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YodmFsKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0ZGlmc1twXSA9ICh2YWwgPT09IFwiYXV0b1wiICYmIChwID09PSBcImxlZnRcIiB8fCBwID09PSBcInRvcFwiKSkgPyBfY2FsY3VsYXRlT2Zmc2V0KHQsIHApIDogKCh2YWwgPT09IFwiXCIgfHwgdmFsID09PSBcImF1dG9cIiB8fCB2YWwgPT09IFwibm9uZVwiKSAmJiB0eXBlb2YoczFbcF0pID09PSBcInN0cmluZ1wiICYmIHMxW3BdLnJlcGxhY2UoX05hTkV4cCwgXCJcIikgIT09IFwiXCIpID8gMCA6IHZhbDsgLy9pZiB0aGUgZW5kaW5nIHZhbHVlIGlzIGRlZmF1bHRpbmcgKFwiXCIgb3IgXCJhdXRvXCIpLCB3ZSBjaGVjayB0aGUgc3RhcnRpbmcgdmFsdWUgYW5kIGlmIGl0IGNhbiBiZSBwYXJzZWQgaW50byBhIG51bWJlciAoYSBzdHJpbmcgd2hpY2ggY291bGQgaGF2ZSBhIHN1ZmZpeCB0b28sIGxpa2UgNzAwcHgpLCB0aGVuIHdlIHN3YXAgaW4gMCBmb3IgXCJcIiBvciBcImF1dG9cIiBzbyB0aGF0IHRoaW5ncyBhY3R1YWxseSB0d2Vlbi5cblx0XHRcdFx0XHRcdGlmIChzdHlsZVtwXSAhPT0gdW5kZWZpbmVkKSB7IC8vZm9yIGNsYXNzTmFtZSB0d2VlbnMsIHdlIG11c3QgcmVtZW1iZXIgd2hpY2ggcHJvcGVydGllcyBhbHJlYWR5IGV4aXN0ZWQgaW5saW5lIC0gdGhlIG9uZXMgdGhhdCBkaWRuJ3Qgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiB0aGUgdHdlZW4gaXNuJ3QgaW4gcHJvZ3Jlc3MgYmVjYXVzZSB0aGV5IHdlcmUgb25seSBpbnRyb2R1Y2VkIHRvIGZhY2lsaXRhdGUgdGhlIHRyYW5zaXRpb24gYmV0d2VlbiBjbGFzc2VzLlxuXHRcdFx0XHRcdFx0XHRtcHQgPSBuZXcgTWluaVByb3BUd2VlbihzdHlsZSwgcCwgc3R5bGVbcF0sIG1wdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YXJzKSB7XG5cdFx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHsgLy9jb3B5IHByb3BlcnRpZXMgKGV4Y2VwdCBjbGFzc05hbWUpXG5cdFx0XHRcdFx0XHRpZiAocCAhPT0gXCJjbGFzc05hbWVcIikge1xuXHRcdFx0XHRcdFx0XHRkaWZzW3BdID0gdmFyc1twXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtkaWZzOmRpZnMsIGZpcnN0TVBUOm1wdH07XG5cdFx0XHR9LFxuXHRcdFx0X2RpbWVuc2lvbnMgPSB7d2lkdGg6W1wiTGVmdFwiLFwiUmlnaHRcIl0sIGhlaWdodDpbXCJUb3BcIixcIkJvdHRvbVwiXX0sXG5cdFx0XHRfbWFyZ2lucyA9IFtcIm1hcmdpbkxlZnRcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Ub3BcIixcIm1hcmdpbkJvdHRvbVwiXSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBHZXRzIHRoZSB3aWR0aCBvciBoZWlnaHQgb2YgYW4gZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZSAoXCJ3aWR0aFwiIG9yIFwiaGVpZ2h0XCIpXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGNzIENvbXB1dGVkIHN0eWxlIG9iamVjdCAoaWYgb25lIGV4aXN0cykuIEp1c3QgYSBzcGVlZCBvcHRpbWl6YXRpb24uXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IERpbWVuc2lvbiAoaW4gcGl4ZWxzKVxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24odCwgcCwgY3MpIHtcblx0XHRcdFx0aWYgKCh0Lm5vZGVOYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIikgeyAvL0Nocm9tZSBubyBsb25nZXIgc3VwcG9ydHMgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IG9uIFNWRyBlbGVtZW50cy5cblx0XHRcdFx0XHRyZXR1cm4gKGNzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQpKVtwXSB8fCAwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQuZ2V0QkJveCAmJiBfaXNTVkcodCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdC5nZXRCQm94KClbcF0gfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdiA9IHBhcnNlRmxvYXQoKHAgPT09IFwid2lkdGhcIikgPyB0Lm9mZnNldFdpZHRoIDogdC5vZmZzZXRIZWlnaHQpLFxuXHRcdFx0XHRcdGEgPSBfZGltZW5zaW9uc1twXSxcblx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdGNzID0gY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCwgbnVsbCk7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHYgLT0gcGFyc2VGbG9hdCggX2dldFN0eWxlKHQsIFwicGFkZGluZ1wiICsgYVtpXSwgY3MsIHRydWUpICkgfHwgMDtcblx0XHRcdFx0XHR2IC09IHBhcnNlRmxvYXQoIF9nZXRTdHlsZSh0LCBcImJvcmRlclwiICsgYVtpXSArIFwiV2lkdGhcIiwgY3MsIHRydWUpICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBwcml2YXRlIFBhcnNlcyBwb3NpdGlvbi1yZWxhdGVkIGNvbXBsZXggc3RyaW5ncyBsaWtlIFwidG9wIGxlZnRcIiBvciBcIjUwcHggMTBweFwiIG9yIFwiNzAlIDIwJVwiLCBldGMuIHdoaWNoIGFyZSB1c2VkIGZvciB0aGluZ3MgbGlrZSB0cmFuc2Zvcm1PcmlnaW4gb3IgYmFja2dyb3VuZFBvc2l0aW9uLiBPcHRpb25hbGx5IGRlY29yYXRlcyBhIHN1cHBsaWVkIG9iamVjdCAocmVjT2JqKSB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczogXCJveFwiIChvZmZzZXRYKSwgXCJveVwiIChvZmZzZXRZKSwgXCJveHBcIiAoaWYgdHJ1ZSwgXCJveFwiIGlzIGEgcGVyY2VudGFnZSBub3QgYSBwaXhlbCB2YWx1ZSksIGFuZCBcIm94eVwiIChpZiB0cnVlLCBcIm95XCIgaXMgYSBwZXJjZW50YWdlIG5vdCBhIHBpeGVsIHZhbHVlKVxuXHRcdFx0X3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbih2LCByZWNPYmopIHtcblx0XHRcdFx0aWYgKHYgPT09IFwiY29udGFpblwiIHx8IHYgPT09IFwiYXV0b1wiIHx8IHYgPT09IFwiYXV0byBhdXRvXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdiArIFwiIFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2ID09IG51bGwgfHwgdiA9PT0gXCJcIikgeyAvL25vdGU6IEZpcmVmb3ggdXNlcyBcImF1dG8gYXV0b1wiIGFzIGRlZmF1bHQgd2hlcmVhcyBDaHJvbWUgdXNlcyBcImF1dG9cIi5cblx0XHRcdFx0XHR2ID0gXCIwIDBcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgYSA9IHYuc3BsaXQoXCIgXCIpLFxuXHRcdFx0XHRcdHggPSAodi5pbmRleE9mKFwibGVmdFwiKSAhPT0gLTEpID8gXCIwJVwiIDogKHYuaW5kZXhPZihcInJpZ2h0XCIpICE9PSAtMSkgPyBcIjEwMCVcIiA6IGFbMF0sXG5cdFx0XHRcdFx0eSA9ICh2LmluZGV4T2YoXCJ0b3BcIikgIT09IC0xKSA/IFwiMCVcIiA6ICh2LmluZGV4T2YoXCJib3R0b21cIikgIT09IC0xKSA/IFwiMTAwJVwiIDogYVsxXSxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRpZiAoYS5sZW5ndGggPiAzICYmICFyZWNPYmopIHsgLy9tdWx0aXBsZSBwb3NpdGlvbnNcblx0XHRcdFx0XHRhID0gdi5zcGxpdChcIiwgXCIpLmpvaW4oXCIsXCIpLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0XHR2ID0gW107XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHYucHVzaChfcGFyc2VQb3NpdGlvbihhW2ldKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2LmpvaW4oXCIsXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh5ID09IG51bGwpIHtcblx0XHRcdFx0XHR5ID0gKHggPT09IFwiY2VudGVyXCIpID8gXCI1MCVcIiA6IFwiMFwiO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHkgPT09IFwiY2VudGVyXCIpIHtcblx0XHRcdFx0XHR5ID0gXCI1MCVcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeCA9PT0gXCJjZW50ZXJcIiB8fCAoaXNOYU4ocGFyc2VGbG9hdCh4KSkgJiYgKHggKyBcIlwiKS5pbmRleE9mKFwiPVwiKSA9PT0gLTEpKSB7IC8vcmVtZW1iZXIsIHRoZSB1c2VyIGNvdWxkIGZsaXAtZmxvcCB0aGUgdmFsdWVzIGFuZCBzYXkgXCJib3R0b20gY2VudGVyXCIgb3IgXCJjZW50ZXIgYm90dG9tXCIsIGV0Yy4gXCJjZW50ZXJcIiBpcyBhbWJpZ3VvdXMgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkIHRvIGRlc2NyaWJlIGhvcml6b250YWwgb3IgdmVydGljYWwsIGhlbmNlIHRoZSBpc05hTigpLiBJZiB0aGVyZSdzIGFuIFwiPVwiIHNpZ24gaW4gdGhlIHZhbHVlLCBpdCdzIHJlbGF0aXZlLlxuXHRcdFx0XHRcdHggPSBcIjUwJVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHYgPSB4ICsgXCIgXCIgKyB5ICsgKChhLmxlbmd0aCA+IDIpID8gXCIgXCIgKyBhWzJdIDogXCJcIik7XG5cdFx0XHRcdGlmIChyZWNPYmopIHtcblx0XHRcdFx0XHRyZWNPYmoub3hwID0gKHguaW5kZXhPZihcIiVcIikgIT09IC0xKTtcblx0XHRcdFx0XHRyZWNPYmoub3lwID0gKHkuaW5kZXhPZihcIiVcIikgIT09IC0xKTtcblx0XHRcdFx0XHRyZWNPYmoub3hyID0gKHguY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0cmVjT2JqLm95ciA9ICh5LmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdHJlY09iai5veCA9IHBhcnNlRmxvYXQoeC5yZXBsYWNlKF9OYU5FeHAsIFwiXCIpKTtcblx0XHRcdFx0XHRyZWNPYmoub3kgPSBwYXJzZUZsb2F0KHkucmVwbGFjZShfTmFORXhwLCBcIlwiKSk7XG5cdFx0XHRcdFx0cmVjT2JqLnYgPSB2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZWNPYmogfHwgdjtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgVGFrZXMgYW4gZW5kaW5nIHZhbHVlICh0eXBpY2FsbHkgYSBzdHJpbmcsIGJ1dCBjYW4gYmUgYSBudW1iZXIpIGFuZCBhIHN0YXJ0aW5nIHZhbHVlIGFuZCByZXR1cm5zIHRoZSBjaGFuZ2UgYmV0d2VlbiB0aGUgdHdvLCBsb29raW5nIGZvciByZWxhdGl2ZSB2YWx1ZSBpbmRpY2F0b3JzIGxpa2UgKz0gYW5kIC09IGFuZCBpdCBhbHNvIGlnbm9yZXMgc3VmZml4ZXMgKGJ1dCBtYWtlIHN1cmUgdGhlIGVuZGluZyB2YWx1ZSBzdGFydHMgd2l0aCBhIG51bWJlciBvciArPS8tPSBhbmQgdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWUgaXMgYSBOVU1CRVIhKVxuXHRcdFx0ICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyl9IGUgRW5kIHZhbHVlIHdoaWNoIGlzIHR5cGljYWxseSBhIHN0cmluZywgYnV0IGNvdWxkIGJlIGEgbnVtYmVyXG5cdFx0XHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gYiBCZWdpbm5pbmcgdmFsdWUgd2hpY2ggaXMgdHlwaWNhbGx5IGEgc3RyaW5nIGJ1dCBjb3VsZCBiZSBhIG51bWJlclxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBBbW91bnQgb2YgY2hhbmdlIGJldHdlZW4gdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyAocmVsYXRpdmUgdmFsdWVzIHRoYXQgaGF2ZSBhIFwiKz1cIiBvciBcIi09XCIgYXJlIHJlY29nbml6ZWQpXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUNoYW5nZSA9IGZ1bmN0aW9uKGUsIGIpIHtcblx0XHRcdFx0cmV0dXJuICh0eXBlb2YoZSkgPT09IFwic3RyaW5nXCIgJiYgZS5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHBhcnNlSW50KGUuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIHBhcnNlRmxvYXQoZS5zdWJzdHIoMikpIDogKHBhcnNlRmxvYXQoZSkgLSBwYXJzZUZsb2F0KGIpKSB8fCAwO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBUYWtlcyBhIHZhbHVlIGFuZCBhIGRlZmF1bHQgbnVtYmVyLCBjaGVja3MgaWYgdGhlIHZhbHVlIGlzIHJlbGF0aXZlLCBudWxsLCBvciBudW1lcmljIGFuZCBzcGl0cyBiYWNrIGEgbm9ybWFsaXplZCBudW1iZXIgYWNjb3JkaW5nbHkuIFByaW1hcmlseSB1c2VkIGluIHRoZSBfcGFyc2VUcmFuc2Zvcm0oKSBmdW5jdGlvbi5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2IFZhbHVlIHRvIGJlIHBhcnNlZFxuXHRcdFx0ICogQHBhcmFtIHshbnVtYmVyfSBkIERlZmF1bHQgdmFsdWUgKHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgcmVsYXRpdmUgY2FsY3VsYXRpb25zIGlmIFwiKz1cIiBvciBcIi09XCIgaXMgZm91bmQgaW4gdGhlIGZpcnN0IHBhcmFtZXRlcilcblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gUGFyc2VkIHZhbHVlXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZVZhbCA9IGZ1bmN0aW9uKHYsIGQpIHtcblx0XHRcdFx0cmV0dXJuICh2ID09IG51bGwpID8gZCA6ICh0eXBlb2YodikgPT09IFwic3RyaW5nXCIgJiYgdi5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHBhcnNlSW50KHYuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIHBhcnNlRmxvYXQodi5zdWJzdHIoMikpICsgZCA6IHBhcnNlRmxvYXQodikgfHwgMDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgVHJhbnNsYXRlcyBzdHJpbmdzIGxpa2UgXCI0MGRlZ1wiIG9yIFwiNDBcIiBvciA0MHJhZFwiIG9yIFwiKz00MGRlZ1wiIG9yIFwiMjcwX3Nob3J0XCIgb3IgXCItOTBfY3dcIiBvciBcIis9NDVfY2N3XCIgdG8gYSBudW1lcmljIHJhZGlhbiBhbmdsZS4gT2YgY291cnNlIGEgc3RhcnRpbmcvZGVmYXVsdCB2YWx1ZSBtdXN0IGJlIGZlZCBpbiB0b28gc28gdGhhdCByZWxhdGl2ZSB2YWx1ZXMgY2FuIGJlIGNhbGN1bGF0ZWQgcHJvcGVybHkuXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gdiBWYWx1ZSB0byBiZSBwYXJzZWRcblx0XHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gZCBEZWZhdWx0IHZhbHVlICh3aGljaCBpcyBhbHNvIHVzZWQgZm9yIHJlbGF0aXZlIGNhbGN1bGF0aW9ucyBpZiBcIis9XCIgb3IgXCItPVwiIGlzIGZvdW5kIGluIHRoZSBmaXJzdCBwYXJhbWV0ZXIpXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHAgcHJvcGVydHkgbmFtZSBmb3IgZGlyZWN0aW9uYWxFbmQgKG9wdGlvbmFsIC0gb25seSB1c2VkIHdoZW4gdGhlIHBhcnNlZCB2YWx1ZSBpcyBkaXJlY3Rpb25hbCAoXCJfc2hvcnRcIiwgXCJfY3dcIiwgb3IgXCJfY2N3XCIgc3VmZml4KS4gV2UgbmVlZCBhIHdheSB0byBzdG9yZSB0aGUgdW5jb21wZW5zYXRlZCB2YWx1ZSBzbyB0aGF0IGF0IHRoZSBlbmQgb2YgdGhlIHR3ZWVuLCB3ZSBzZXQgaXQgdG8gZXhhY3RseSB3aGF0IHdhcyByZXF1ZXN0ZWQgd2l0aCBubyBkaXJlY3Rpb25hbCBjb21wZW5zYXRpb24pLiBQcm9wZXJ0eSBuYW1lIHdvdWxkIGJlIFwicm90YXRpb25cIiwgXCJyb3RhdGlvblhcIiwgb3IgXCJyb3RhdGlvbllcIlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBkaXJlY3Rpb25hbEVuZCBBbiBvYmplY3QgdGhhdCB3aWxsIHN0b3JlIHRoZSByYXcgZW5kIHZhbHVlcyBmb3IgZGlyZWN0aW9uYWwgYW5nbGVzIChcIl9zaG9ydFwiLCBcIl9jd1wiLCBvciBcIl9jY3dcIiBzdWZmaXgpLiBXZSBuZWVkIGEgd2F5IHRvIHN0b3JlIHRoZSB1bmNvbXBlbnNhdGVkIHZhbHVlIHNvIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4sIHdlIHNldCBpdCB0byBleGFjdGx5IHdoYXQgd2FzIHJlcXVlc3RlZCB3aXRoIG5vIGRpcmVjdGlvbmFsIGNvbXBlbnNhdGlvbi5cblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gcGFyc2VkIGFuZ2xlIGluIHJhZGlhbnNcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlQW5nbGUgPSBmdW5jdGlvbih2LCBkLCBwLCBkaXJlY3Rpb25hbEVuZCkge1xuXHRcdFx0XHR2YXIgbWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdFx0Y2FwLCBzcGxpdCwgZGlmLCByZXN1bHQsIGlzUmVsYXRpdmU7XG5cdFx0XHRcdGlmICh2ID09IG51bGwpIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBkO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdHJlc3VsdCA9IHY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2FwID0gMzYwO1xuXHRcdFx0XHRcdHNwbGl0ID0gdi5zcGxpdChcIl9cIik7XG5cdFx0XHRcdFx0aXNSZWxhdGl2ZSA9ICh2LmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdGRpZiA9IChpc1JlbGF0aXZlID8gcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChzcGxpdFswXS5zdWJzdHIoMikpIDogcGFyc2VGbG9hdChzcGxpdFswXSkpICogKCh2LmluZGV4T2YoXCJyYWRcIikgPT09IC0xKSA/IDEgOiBfUkFEMkRFRykgLSAoaXNSZWxhdGl2ZSA/IDAgOiBkKTtcblx0XHRcdFx0XHRpZiAoc3BsaXQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGlyZWN0aW9uYWxFbmQpIHtcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uYWxFbmRbcF0gPSBkICsgZGlmO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcInNob3J0XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSBkaWYgJSBjYXA7XG5cdFx0XHRcdFx0XHRcdGlmIChkaWYgIT09IGRpZiAlIChjYXAgLyAyKSkge1xuXHRcdFx0XHRcdFx0XHRcdGRpZiA9IChkaWYgPCAwKSA/IGRpZiArIGNhcCA6IGRpZiAtIGNhcDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcIl9jd1wiKSAhPT0gLTEgJiYgZGlmIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiArIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2LmluZGV4T2YoXCJjY3dcIikgIT09IC0xICYmIGRpZiA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgLSBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ID0gZCArIGRpZjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzdWx0IDwgbWluICYmIHJlc3VsdCA+IC1taW4pIHtcblx0XHRcdFx0XHRyZXN1bHQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRfY29sb3JMb29rdXAgPSB7YXF1YTpbMCwyNTUsMjU1XSxcblx0XHRcdFx0bGltZTpbMCwyNTUsMF0sXG5cdFx0XHRcdHNpbHZlcjpbMTkyLDE5MiwxOTJdLFxuXHRcdFx0XHRibGFjazpbMCwwLDBdLFxuXHRcdFx0XHRtYXJvb246WzEyOCwwLDBdLFxuXHRcdFx0XHR0ZWFsOlswLDEyOCwxMjhdLFxuXHRcdFx0XHRibHVlOlswLDAsMjU1XSxcblx0XHRcdFx0bmF2eTpbMCwwLDEyOF0sXG5cdFx0XHRcdHdoaXRlOlsyNTUsMjU1LDI1NV0sXG5cdFx0XHRcdGZ1Y2hzaWE6WzI1NSwwLDI1NV0sXG5cdFx0XHRcdG9saXZlOlsxMjgsMTI4LDBdLFxuXHRcdFx0XHR5ZWxsb3c6WzI1NSwyNTUsMF0sXG5cdFx0XHRcdG9yYW5nZTpbMjU1LDE2NSwwXSxcblx0XHRcdFx0Z3JheTpbMTI4LDEyOCwxMjhdLFxuXHRcdFx0XHRwdXJwbGU6WzEyOCwwLDEyOF0sXG5cdFx0XHRcdGdyZWVuOlswLDEyOCwwXSxcblx0XHRcdFx0cmVkOlsyNTUsMCwwXSxcblx0XHRcdFx0cGluazpbMjU1LDE5MiwyMDNdLFxuXHRcdFx0XHRjeWFuOlswLDI1NSwyNTVdLFxuXHRcdFx0XHR0cmFuc3BhcmVudDpbMjU1LDI1NSwyNTUsMF19LFxuXG5cdFx0XHRfaHVlID0gZnVuY3Rpb24oaCwgbTEsIG0yKSB7XG5cdFx0XHRcdGggPSAoaCA8IDApID8gaCArIDEgOiAoaCA+IDEpID8gaCAtIDEgOiBoO1xuXHRcdFx0XHRyZXR1cm4gKCgoKGggKiA2IDwgMSkgPyBtMSArIChtMiAtIG0xKSAqIGggKiA2IDogKGggPCAwLjUpID8gbTIgOiAoaCAqIDMgPCAyKSA/IG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2IDogbTEpICogMjU1KSArIDAuNSkgfCAwO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBQYXJzZXMgYSBjb2xvciAobGlrZSAjOUYwLCAjRkY5OTAwLCByZ2IoMjU1LDUxLDE1Mykgb3IgaHNsKDEwOCwgNTAlLCAxMCUpKSBpbnRvIGFuIGFycmF5IHdpdGggMyBlbGVtZW50cyBmb3IgcmVkLCBncmVlbiwgYW5kIGJsdWUgb3IgaWYgdG9IU0wgcGFyYW1ldGVyIGlzIHRydWUsIGl0IHdpbGwgcG9wdWxhdGUgdGhlIGFycmF5IHdpdGggaHVlLCBzYXR1cmF0aW9uLCBhbmQgbGlnaHRuZXNzIHZhbHVlcy4gSWYgYSByZWxhdGl2ZSB2YWx1ZSBpcyBmb3VuZCBpbiBhbiBoc2woKSBvciBoc2xhKCkgc3RyaW5nLCBpdCB3aWxsIHByZXNlcnZlIHRob3NlIHJlbGF0aXZlIHByZWZpeGVzIGFuZCBhbGwgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgd2lsbCBiZSBzdHJpbmdzIGluc3RlYWQgb2YgbnVtYmVycyAoaW4gYWxsIG90aGVyIGNhc2VzIGl0IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggbnVtYmVycykuXG5cdFx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKX0gdiBUaGUgdmFsdWUgdGhlIHNob3VsZCBiZSBwYXJzZWQgd2hpY2ggY291bGQgYmUgYSBzdHJpbmcgbGlrZSAjOUYwIG9yIHJnYigyNTUsMTAyLDUxKSBvciByZ2JhKDI1NSwwLDAsMC41KSBvciBpdCBjb3VsZCBiZSBhIG51bWJlciBsaWtlIDB4RkYwMENDIG9yIGV2ZW4gYSBuYW1lZCBjb2xvciBsaWtlIHJlZCwgYmx1ZSwgcHVycGxlLCBldGMuXG5cdFx0XHQgKiBAcGFyYW0geyhib29sZWFuKX0gdG9IU0wgSWYgdHJ1ZSwgYW4gaHNsKCkgb3IgaHNsYSgpIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiByZ2IoKSBvciByZ2JhKClcblx0XHRcdCAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBBbiBhcnJheSBjb250YWluaW5nIHJlZCwgZ3JlZW4sIGFuZCBibHVlIChhbmQgb3B0aW9uYWxseSBhbHBoYSkgaW4gdGhhdCBvcmRlciwgb3IgaWYgdGhlIHRvSFNMIHBhcmFtZXRlciB3YXMgdHJ1ZSwgdGhlIGFycmF5IHdpbGwgY29udGFpbiBodWUsIHNhdHVyYXRpb24gYW5kIGxpZ2h0bmVzcyAoYW5kIG9wdGlvbmFsbHkgYWxwaGEpIGluIHRoYXQgb3JkZXIuIEFsd2F5cyBudW1iZXJzIHVubGVzcyB0aGVyZSdzIGEgcmVsYXRpdmUgcHJlZml4IGZvdW5kIGluIGFuIGhzbCgpIG9yIGhzbGEoKSBzdHJpbmcgYW5kIHRvSFNMIGlzIHRydWUuXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUNvbG9yID0gQ1NTUGx1Z2luLnBhcnNlQ29sb3IgPSBmdW5jdGlvbih2LCB0b0hTTCkge1xuXHRcdFx0XHR2YXIgYSwgciwgZywgYiwgaCwgcywgbCwgbWF4LCBtaW4sIGQsIHdhc0hTTDtcblx0XHRcdFx0aWYgKCF2KSB7XG5cdFx0XHRcdFx0YSA9IF9jb2xvckxvb2t1cC5ibGFjaztcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodikgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRhID0gW3YgPj4gMTYsICh2ID4+IDgpICYgMjU1LCB2ICYgMjU1XTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodi5jaGFyQXQodi5sZW5ndGggLSAxKSA9PT0gXCIsXCIpIHsgLy9zb21ldGltZXMgYSB0cmFpbGluZyBjb21tYSBpcyBpbmNsdWRlZCBhbmQgd2Ugc2hvdWxkIGNob3AgaXQgb2ZmICh0eXBpY2FsbHkgZnJvbSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyBsaWtlIGEgdGV4dFNoYWRvdzpcIjJweCAycHggMnB4IGJsdWUsIDVweCA1cHggNXB4IHJnYigyNTUsMCwwKVwiIC0gaW4gdGhpcyBleGFtcGxlIFwiYmx1ZSxcIiBoYXMgYSB0cmFpbGluZyBjb21tYS4gV2UgY291bGQgc3RyaXAgaXQgb3V0IGluc2lkZSBwYXJzZUNvbXBsZXgoKSBidXQgd2UnZCBuZWVkIHRvIGRvIGl0IHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgcGx1cyBpdCB3b3VsZG4ndCBwcm92aWRlIHByb3RlY3Rpb24gZnJvbSBvdGhlciBwb3RlbnRpYWwgc2NlbmFyaW9zIGxpa2UgaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgc2ltaWxhciB2YWx1ZS5cblx0XHRcdFx0XHRcdHYgPSB2LnN1YnN0cigwLCB2Lmxlbmd0aCAtIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoX2NvbG9yTG9va3VwW3ZdKSB7XG5cdFx0XHRcdFx0XHRhID0gX2NvbG9yTG9va3VwW3ZdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodi5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG5cdFx0XHRcdFx0XHRpZiAodi5sZW5ndGggPT09IDQpIHsgLy9mb3Igc2hvcnRoYW5kIGxpa2UgIzlGMFxuXHRcdFx0XHRcdFx0XHRyID0gdi5jaGFyQXQoMSk7XG5cdFx0XHRcdFx0XHRcdGcgPSB2LmNoYXJBdCgyKTtcblx0XHRcdFx0XHRcdFx0YiA9IHYuY2hhckF0KDMpO1xuXHRcdFx0XHRcdFx0XHR2ID0gXCIjXCIgKyByICsgciArIGcgKyBnICsgYiArIGI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2ID0gcGFyc2VJbnQodi5zdWJzdHIoMSksIDE2KTtcblx0XHRcdFx0XHRcdGEgPSBbdiA+PiAxNiwgKHYgPj4gOCkgJiAyNTUsIHYgJiAyNTVdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodi5zdWJzdHIoMCwgMykgPT09IFwiaHNsXCIpIHtcblx0XHRcdFx0XHRcdGEgPSB3YXNIU0wgPSB2Lm1hdGNoKF9udW1FeHApO1xuXHRcdFx0XHRcdFx0aWYgKCF0b0hTTCkge1xuXHRcdFx0XHRcdFx0XHRoID0gKE51bWJlcihhWzBdKSAlIDM2MCkgLyAzNjA7XG5cdFx0XHRcdFx0XHRcdHMgPSBOdW1iZXIoYVsxXSkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdGwgPSBOdW1iZXIoYVsyXSkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdGcgPSAobCA8PSAwLjUpID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuXHRcdFx0XHRcdFx0XHRyID0gbCAqIDIgLSBnO1xuXHRcdFx0XHRcdFx0XHRpZiAoYS5sZW5ndGggPiAzKSB7XG5cdFx0XHRcdFx0XHRcdFx0YVszXSA9IE51bWJlcih2WzNdKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRhWzBdID0gX2h1ZShoICsgMSAvIDMsIHIsIGcpO1xuXHRcdFx0XHRcdFx0XHRhWzFdID0gX2h1ZShoLCByLCBnKTtcblx0XHRcdFx0XHRcdFx0YVsyXSA9IF9odWUoaCAtIDEgLyAzLCByLCBnKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodi5pbmRleE9mKFwiPVwiKSAhPT0gLTEpIHsgLy9pZiByZWxhdGl2ZSB2YWx1ZXMgYXJlIGZvdW5kLCBqdXN0IHJldHVybiB0aGUgcmF3IHN0cmluZ3Mgd2l0aCB0aGUgcmVsYXRpdmUgcHJlZml4ZXMgaW4gcGxhY2UuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB2Lm1hdGNoKF9yZWxOdW1FeHApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhID0gdi5tYXRjaChfbnVtRXhwKSB8fCBfY29sb3JMb29rdXAudHJhbnNwYXJlbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGFbMF0gPSBOdW1iZXIoYVswXSk7XG5cdFx0XHRcdFx0YVsxXSA9IE51bWJlcihhWzFdKTtcblx0XHRcdFx0XHRhWzJdID0gTnVtYmVyKGFbMl0pO1xuXHRcdFx0XHRcdGlmIChhLmxlbmd0aCA+IDMpIHtcblx0XHRcdFx0XHRcdGFbM10gPSBOdW1iZXIoYVszXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0b0hTTCAmJiAhd2FzSFNMKSB7XG5cdFx0XHRcdFx0ciA9IGFbMF0gLyAyNTU7XG5cdFx0XHRcdFx0ZyA9IGFbMV0gLyAyNTU7XG5cdFx0XHRcdFx0YiA9IGFbMl0gLyAyNTU7XG5cdFx0XHRcdFx0bWF4ID0gTWF0aC5tYXgociwgZywgYik7XG5cdFx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYik7XG5cdFx0XHRcdFx0bCA9IChtYXggKyBtaW4pIC8gMjtcblx0XHRcdFx0XHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRcdFx0XHRcdGggPSBzID0gMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZCA9IG1heCAtIG1pbjtcblx0XHRcdFx0XHRcdHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcblx0XHRcdFx0XHRcdGggPSAobWF4ID09PSByKSA/IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApIDogKG1heCA9PT0gZykgPyAoYiAtIHIpIC8gZCArIDIgOiAociAtIGcpIC8gZCArIDQ7XG5cdFx0XHRcdFx0XHRoICo9IDYwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhWzBdID0gKGggKyAwLjUpIHwgMDtcblx0XHRcdFx0XHRhWzFdID0gKHMgKiAxMDAgKyAwLjUpIHwgMDtcblx0XHRcdFx0XHRhWzJdID0gKGwgKiAxMDAgKyAwLjUpIHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sXG5cdFx0XHRfZm9ybWF0Q29sb3JzID0gZnVuY3Rpb24ocywgdG9IU0wpIHtcblx0XHRcdFx0dmFyIGNvbG9ycyA9IHMubWF0Y2goX2NvbG9yRXhwKSB8fCBbXSxcblx0XHRcdFx0XHRjaGFySW5kZXggPSAwLFxuXHRcdFx0XHRcdHBhcnNlZCA9IGNvbG9ycy5sZW5ndGggPyBcIlwiIDogcyxcblx0XHRcdFx0XHRpLCBjb2xvciwgdGVtcDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JzW2ldO1xuXHRcdFx0XHRcdHRlbXAgPSBzLnN1YnN0cihjaGFySW5kZXgsIHMuaW5kZXhPZihjb2xvciwgY2hhckluZGV4KS1jaGFySW5kZXgpO1xuXHRcdFx0XHRcdGNoYXJJbmRleCArPSB0ZW1wLmxlbmd0aCArIGNvbG9yLmxlbmd0aDtcblx0XHRcdFx0XHRjb2xvciA9IF9wYXJzZUNvbG9yKGNvbG9yLCB0b0hTTCk7XG5cdFx0XHRcdFx0aWYgKGNvbG9yLmxlbmd0aCA9PT0gMykge1xuXHRcdFx0XHRcdFx0Y29sb3IucHVzaCgxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyc2VkICs9IHRlbXAgKyAodG9IU0wgPyBcImhzbGEoXCIgKyBjb2xvclswXSArIFwiLFwiICsgY29sb3JbMV0gKyBcIiUsXCIgKyBjb2xvclsyXSArIFwiJSxcIiArIGNvbG9yWzNdIDogXCJyZ2JhKFwiICsgY29sb3Iuam9pbihcIixcIikpICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBhcnNlZCArIHMuc3Vic3RyKGNoYXJJbmRleCk7XG5cdFx0XHR9LFxuXHRcdFx0X2NvbG9yRXhwID0gXCIoPzpcXFxcYig/Oig/OnJnYnxyZ2JhfGhzbHxoc2xhKVxcXFwoLis/XFxcXCkpfFxcXFxCIyg/OlswLTlhLWZdezN9KXsxLDJ9XFxcXGJcIjsgLy93ZSdsbCBkeW5hbWljYWxseSBidWlsZCB0aGlzIFJlZ3VsYXIgRXhwcmVzc2lvbiB0byBjb25zZXJ2ZSBmaWxlIHNpemUuIEFmdGVyIGJ1aWxkaW5nIGl0LCBpdCB3aWxsIGJlIGFibGUgdG8gZmluZCByZ2IoKSwgcmdiYSgpLCAjIChoZXhhZGVjaW1hbCksIGFuZCBuYW1lZCBjb2xvciB2YWx1ZXMgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLlxuXG5cdFx0Zm9yIChwIGluIF9jb2xvckxvb2t1cCkge1xuXHRcdFx0X2NvbG9yRXhwICs9IFwifFwiICsgcCArIFwiXFxcXGJcIjtcblx0XHR9XG5cdFx0X2NvbG9yRXhwID0gbmV3IFJlZ0V4cChfY29sb3JFeHArXCIpXCIsIFwiZ2lcIik7XG5cblx0XHRDU1NQbHVnaW4uY29sb3JTdHJpbmdGaWx0ZXIgPSBmdW5jdGlvbihhKSB7XG5cdFx0XHR2YXIgY29tYmluZWQgPSBhWzBdICsgYVsxXSxcblx0XHRcdFx0dG9IU0w7XG5cdFx0XHRpZiAoX2NvbG9yRXhwLnRlc3QoY29tYmluZWQpKSB7XG5cdFx0XHRcdHRvSFNMID0gKGNvbWJpbmVkLmluZGV4T2YoXCJoc2woXCIpICE9PSAtMSB8fCBjb21iaW5lZC5pbmRleE9mKFwiaHNsYShcIikgIT09IC0xKTtcblx0XHRcdFx0YVswXSA9IF9mb3JtYXRDb2xvcnMoYVswXSwgdG9IU0wpO1xuXHRcdFx0XHRhWzFdID0gX2Zvcm1hdENvbG9ycyhhWzFdLCB0b0hTTCk7XG5cdFx0XHR9XG5cdFx0XHRfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblx0XHR9O1xuXG5cdFx0aWYgKCFUd2VlbkxpdGUuZGVmYXVsdFN0cmluZ0ZpbHRlcikge1xuXHRcdFx0VHdlZW5MaXRlLmRlZmF1bHRTdHJpbmdGaWx0ZXIgPSBDU1NQbHVnaW4uY29sb3JTdHJpbmdGaWx0ZXI7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGUgUmV0dXJucyBhIGZvcm1hdHRlciBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgdGFraW5nIGEgc3RyaW5nIChvciBudW1iZXIgaW4gc29tZSBjYXNlcykgYW5kIHJldHVybmluZyBhIGNvbnNpc3RlbnRseSBmb3JtYXR0ZWQgb25lIGluIHRlcm1zIG9mIGRlbGltaXRlcnMsIHF1YW50aXR5IG9mIHZhbHVlcywgZXRjLiBGb3IgZXhhbXBsZSwgd2UgbWF5IGdldCBib3hTaGFkb3cgdmFsdWVzIGRlZmluZWQgYXMgXCIwcHggcmVkXCIgb3IgXCIwcHggMHB4IDEwcHggcmdiKDI1NSwwLDApXCIgb3IgXCIwcHggMHB4IDIwcHggMjBweCAjRjAwXCIgYW5kIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgd2hhdCB3ZSBnZXQgYmFjayBpcyBkZXNjcmliZWQgd2l0aCA0IG51bWJlcnMgYW5kIGEgY29sb3IuIFRoaXMgYWxsb3dzIHVzIHRvIGZlZWQgaXQgaW50byB0aGUgX3BhcnNlQ29tcGxleCgpIG1ldGhvZCBhbmQgc3BsaXQgdGhlIHZhbHVlcyB1cCBhcHByb3ByaWF0ZWx5LiBUaGUgbmVhdCB0aGluZyBhYm91dCB0aGlzIF9nZXRGb3JtYXR0ZXIoKSBmdW5jdGlvbiBpcyB0aGF0IHRoZSBkZmx0IGRlZmluZXMgYSBwYXR0ZXJuIGFzIHdlbGwgYXMgYSBkZWZhdWx0LCBzbyBmb3IgZXhhbXBsZSwgX2dldEZvcm1hdHRlcihcIjBweCAwcHggMHB4IDBweCAjNzc3XCIsIHRydWUpIG5vdCBvbmx5IHNldHMgdGhlIGRlZmF1bHQgYXMgMHB4IGZvciBhbGwgZGlzdGFuY2VzIGFuZCAjNzc3IGZvciB0aGUgY29sb3IsIGJ1dCBhbHNvIHNldHMgdGhlIHBhdHRlcm4gc3VjaCB0aGF0IDQgbnVtYmVycyBhbmQgYSBjb2xvciB3aWxsIGFsd2F5cyBnZXQgcmV0dXJuZWQuXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBkZmx0IFRoZSBkZWZhdWx0IHZhbHVlIGFuZCBwYXR0ZXJuIHRvIGZvbGxvdy4gU28gXCIwcHggMHB4IDBweCAwcHggIzc3N1wiIHdpbGwgZW5zdXJlIHRoYXQgNCBudW1iZXJzIGFuZCBhIGNvbG9yIHdpbGwgYWx3YXlzIGdldCByZXR1cm5lZC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBjbHIgSWYgdHJ1ZSwgdGhlIHZhbHVlcyBzaG91bGQgYmUgc2VhcmNoZWQgZm9yIGNvbG9yLXJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGJveFNoYWRvdyB2YWx1ZXMgdHlwaWNhbGx5IGNvbnRhaW4gYSBjb2xvciB3aGVyZWFzIGJvcmRlclJhZGl1cyBkb24ndC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBjb2xsYXBzaWJsZSBJZiB0cnVlLCB0aGUgdmFsdWUgaXMgYSB0b3AvbGVmdC9yaWdodC9ib3R0b20gc3R5bGUgb25lIHRoYXQgYWN0cyBsaWtlIG1hcmdpbiBvciBwYWRkaW5nLCB3aGVyZSBpZiBvbmx5IG9uZSB2YWx1ZSBpcyByZWNlaXZlZCwgaXQncyB1c2VkIGZvciBhbGwgNDsgaWYgMiBhcmUgcmVjZWl2ZWQsIHRoZSBmaXJzdCBpcyBkdXBsaWNhdGVkIGZvciAzcmQgKGJvdHRvbSkgYW5kIHRoZSAybmQgaXMgZHVwbGljYXRlZCBmb3IgdGhlIDR0aCBzcG90IChsZWZ0KSwgZXRjLlxuXHRcdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBmb3JtYXR0ZXIgZnVuY3Rpb25cblx0XHQgKi9cblx0XHR2YXIgX2dldEZvcm1hdHRlciA9IGZ1bmN0aW9uKGRmbHQsIGNsciwgY29sbGFwc2libGUsIG11bHRpKSB7XG5cdFx0XHRcdGlmIChkZmx0ID09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odikge3JldHVybiB2O307XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGRDb2xvciA9IGNsciA/IChkZmx0Lm1hdGNoKF9jb2xvckV4cCkgfHwgW1wiXCJdKVswXSA6IFwiXCIsXG5cdFx0XHRcdFx0ZFZhbHMgPSBkZmx0LnNwbGl0KGRDb2xvcikuam9pbihcIlwiKS5tYXRjaChfdmFsdWVzRXhwKSB8fCBbXSxcblx0XHRcdFx0XHRwZnggPSBkZmx0LnN1YnN0cigwLCBkZmx0LmluZGV4T2YoZFZhbHNbMF0pKSxcblx0XHRcdFx0XHRzZnggPSAoZGZsdC5jaGFyQXQoZGZsdC5sZW5ndGggLSAxKSA9PT0gXCIpXCIpID8gXCIpXCIgOiBcIlwiLFxuXHRcdFx0XHRcdGRlbGltID0gKGRmbHQuaW5kZXhPZihcIiBcIikgIT09IC0xKSA/IFwiIFwiIDogXCIsXCIsXG5cdFx0XHRcdFx0bnVtVmFscyA9IGRWYWxzLmxlbmd0aCxcblx0XHRcdFx0XHRkU2Z4ID0gKG51bVZhbHMgPiAwKSA/IGRWYWxzWzBdLnJlcGxhY2UoX251bUV4cCwgXCJcIikgOiBcIlwiLFxuXHRcdFx0XHRcdGZvcm1hdHRlcjtcblx0XHRcdFx0aWYgKCFudW1WYWxzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHYpIHtyZXR1cm4gdjt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjbHIpIHtcblx0XHRcdFx0XHRmb3JtYXR0ZXIgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdFx0XHR2YXIgY29sb3IsIHZhbHMsIGksIGE7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0XHRcdHYgKz0gZFNmeDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobXVsdGkgJiYgX2NvbW1hc091dHNpZGVQYXJlbkV4cC50ZXN0KHYpKSB7XG5cdFx0XHRcdFx0XHRcdGEgPSB2LnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRhW2ldID0gZm9ybWF0dGVyKGFbaV0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiBhLmpvaW4oXCIsXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29sb3IgPSAodi5tYXRjaChfY29sb3JFeHApIHx8IFtkQ29sb3JdKVswXTtcblx0XHRcdFx0XHRcdHZhbHMgPSB2LnNwbGl0KGNvbG9yKS5qb2luKFwiXCIpLm1hdGNoKF92YWx1ZXNFeHApIHx8IFtdO1xuXHRcdFx0XHRcdFx0aSA9IHZhbHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0aWYgKG51bVZhbHMgPiBpLS0pIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCsraSA8IG51bVZhbHMpIHtcblx0XHRcdFx0XHRcdFx0XHR2YWxzW2ldID0gY29sbGFwc2libGUgPyB2YWxzWygoKGkgLSAxKSAvIDIpIHwgMCldIDogZFZhbHNbaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBwZnggKyB2YWxzLmpvaW4oZGVsaW0pICsgZGVsaW0gKyBjb2xvciArIHNmeCArICh2LmluZGV4T2YoXCJpbnNldFwiKSAhPT0gLTEgPyBcIiBpbnNldFwiIDogXCJcIik7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZXR1cm4gZm9ybWF0dGVyO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9ybWF0dGVyID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdHZhciB2YWxzLCBhLCBpO1xuXHRcdFx0XHRcdGlmICh0eXBlb2YodikgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRcdHYgKz0gZFNmeDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG11bHRpICYmIF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdCh2KSkge1xuXHRcdFx0XHRcdFx0YSA9IHYucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0YVtpXSA9IGZvcm1hdHRlcihhW2ldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBhLmpvaW4oXCIsXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YWxzID0gdi5tYXRjaChfdmFsdWVzRXhwKSB8fCBbXTtcblx0XHRcdFx0XHRpID0gdmFscy5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKG51bVZhbHMgPiBpLS0pIHtcblx0XHRcdFx0XHRcdHdoaWxlICgrK2kgPCBudW1WYWxzKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHNbaV0gPSBjb2xsYXBzaWJsZSA/IHZhbHNbKCgoaSAtIDEpIC8gMikgfCAwKV0gOiBkVmFsc1tpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHBmeCArIHZhbHMuam9pbihkZWxpbSkgKyBzZng7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBmb3JtYXR0ZXI7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIHJldHVybnMgYSBmb3JtYXR0ZXIgZnVuY3Rpb24gdGhhdCdzIHVzZWQgZm9yIGVkZ2UtcmVsYXRlZCB2YWx1ZXMgbGlrZSBtYXJnaW5Ub3AsIG1hcmdpbkxlZnQsIHBhZGRpbmdCb3R0b20sIHBhZGRpbmdSaWdodCwgZXRjLiBKdXN0IHBhc3MgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyByZWxhdGVkIHRvIHRoZSBlZGdlcy5cblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcHMgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyBpbiBvcmRlciBmcm9tIHRvcCB0byBsZWZ0LCBsaWtlIFwibWFyZ2luVG9wLG1hcmdpblJpZ2h0LG1hcmdpbkJvdHRvbSxtYXJnaW5MZWZ0XCJcblx0XHRcdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGZvcm1hdHRlciBmdW5jdGlvblxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0RWRnZVBhcnNlciA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0XHRcdHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0XHRcdHZhciBhID0gKGUgKyBcIlwiKS5zcGxpdChcIiBcIiksXG5cdFx0XHRcdFx0XHRpO1xuXHRcdFx0XHRcdHZhcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXJzW3Byb3BzW2ldXSA9IGFbaV0gPSBhW2ldIHx8IGFbKCgoaSAtIDEpIC8gMikgPj4gMCldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gY3NzcC5wYXJzZSh0LCB2YXJzLCBwdCwgcGx1Z2luKTtcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBwcml2YXRlIHVzZWQgd2hlbiBvdGhlciBwbHVnaW5zIG11c3QgdHdlZW4gdmFsdWVzIGZpcnN0LCBsaWtlIEJlemllclBsdWdpbiBvciBUaHJvd1Byb3BzUGx1Z2luLCBldGMuIFRoYXQgcGx1Z2luJ3Mgc2V0UmF0aW8oKSBnZXRzIGNhbGxlZCBmaXJzdCBzbyB0aGF0IHRoZSB2YWx1ZXMgYXJlIHVwZGF0ZWQsIGFuZCB0aGVuIHdlIGxvb3AgdGhyb3VnaCB0aGUgTWluaVByb3BUd2VlbnMgIHdoaWNoIGhhbmRsZSBjb3B5aW5nIHRoZSB2YWx1ZXMgaW50byB0aGVpciBhcHByb3ByaWF0ZSBzbG90cyBzbyB0aGF0IHRoZXkgY2FuIHRoZW4gYmUgYXBwbGllZCBjb3JyZWN0bHkgaW4gdGhlIG1haW4gQ1NTUGx1Z2luIHNldFJhdGlvKCkgbWV0aG9kLiBSZW1lbWJlciwgd2UgdHlwaWNhbGx5IGNyZWF0ZSBhIHByb3h5IG9iamVjdCB0aGF0IGhhcyBhIGJ1bmNoIG9mIHVuaXF1ZWx5LW5hbWVkIHByb3BlcnRpZXMgdGhhdCB3ZSBmZWVkIHRvIHRoZSBzdWItcGx1Z2luIGFuZCBpdCBkb2VzIGl0cyBtYWdpYyBub3JtYWxseSwgYW5kIHRoZW4gd2UgbXVzdCBpbnRlcnByZXQgdGhvc2UgdmFsdWVzIGFuZCBhcHBseSB0aGVtIHRvIHRoZSBjc3MgYmVjYXVzZSBvZnRlbiBudW1iZXJzIG11c3QgZ2V0IGNvbWJpbmVkL2NvbmNhdGVuYXRlZCwgc3VmZml4ZXMgYWRkZWQsIGV0Yy4gdG8gd29yayB3aXRoIGNzcywgbGlrZSBib3hTaGFkb3cgY291bGQgaGF2ZSA0IHZhbHVlcyBwbHVzIGEgY29sb3IuXG5cdFx0XHRfc2V0UGx1Z2luUmF0aW8gPSBfaW50ZXJuYWxzLl9zZXRQbHVnaW5SYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0UmF0aW8odik7XG5cdFx0XHRcdHZhciBkID0gdGhpcy5kYXRhLFxuXHRcdFx0XHRcdHByb3h5ID0gZC5wcm94eSxcblx0XHRcdFx0XHRtcHQgPSBkLmZpcnN0TVBULFxuXHRcdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRcdHZhbCwgcHQsIGksIHN0ciwgcDtcblx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdHZhbCA9IHByb3h5W21wdC52XTtcblx0XHRcdFx0XHRpZiAobXB0LnIpIHtcblx0XHRcdFx0XHRcdHZhbCA9IE1hdGgucm91bmQodmFsKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbCA8IG1pbiAmJiB2YWwgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtcHQudFttcHQucF0gPSB2YWw7XG5cdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkLmF1dG9Sb3RhdGUpIHtcblx0XHRcdFx0XHRkLmF1dG9Sb3RhdGUucm90YXRpb24gPSBwcm94eS5yb3RhdGlvbjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL2F0IHRoZSBlbmQsIHdlIG11c3Qgc2V0IHRoZSBDU1NQcm9wVHdlZW4ncyBcImVcIiAoZW5kKSB2YWx1ZSBkeW5hbWljYWxseSBoZXJlIGJlY2F1c2UgdGhhdCdzIHdoYXQgaXMgdXNlZCBpbiB0aGUgZmluYWwgc2V0UmF0aW8oKSBtZXRob2QuIFNhbWUgZm9yIFwiYlwiIGF0IHRoZSBiZWdpbm5pbmcuXG5cdFx0XHRcdGlmICh2ID09PSAxIHx8IHYgPT09IDApIHtcblx0XHRcdFx0XHRtcHQgPSBkLmZpcnN0TVBUO1xuXHRcdFx0XHRcdHAgPSAodiA9PT0gMSkgPyBcImVcIiA6IFwiYlwiO1xuXHRcdFx0XHRcdHdoaWxlIChtcHQpIHtcblx0XHRcdFx0XHRcdHB0ID0gbXB0LnQ7XG5cdFx0XHRcdFx0XHRpZiAoIXB0LnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0cHRbcF0gPSBwdC5zICsgcHQueHMwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwdC50eXBlID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdHN0ciA9IHB0LnhzMCArIHB0LnMgKyBwdC54czE7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBwdC5sOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gcHRbXCJ4blwiK2ldICsgcHRbXCJ4c1wiKyhpKzEpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwdFtwXSA9IHN0cjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgQGNvbnN0cnVjdG9yIFVzZWQgYnkgYSBmZXcgU3BlY2lhbFByb3BzIHRvIGhvbGQgaW1wb3J0YW50IHZhbHVlcyBmb3IgcHJveGllcy4gRm9yIGV4YW1wbGUsIF9wYXJzZVRvUHJveHkoKSBjcmVhdGVzIGEgTWluaVByb3BUd2VlbiBpbnN0YW5jZSBmb3IgZWFjaCBwcm9wZXJ0eSB0aGF0IG11c3QgZ2V0IHR3ZWVuZWQgb24gdGhlIHByb3h5LCBhbmQgd2UgcmVjb3JkIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBuYW1lIGFzIHdlbGwgYXMgdGhlIHVuaXF1ZSBvbmUgd2UgY3JlYXRlIGZvciB0aGUgcHJveHksIHBsdXMgd2hldGhlciBvciBub3QgdGhlIHZhbHVlIG5lZWRzIHRvIGJlIHJvdW5kZWQgcGx1cyB0aGUgb3JpZ2luYWwgdmFsdWUuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgdGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSB3ZSdyZSB0d2VlbmluZyAob2Z0ZW4gYSBDU1NQcm9wVHdlZW4pXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgcHJvcGVydHkgbmFtZVxuXHRcdFx0ICogQHBhcmFtIHsobnVtYmVyfHN0cmluZ3xvYmplY3QpfSB2IHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge01pbmlQcm9wVHdlZW49fSBuZXh0IG5leHQgTWluaVByb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHIgaWYgdHJ1ZSwgdGhlIHR3ZWVuZWQgdmFsdWUgc2hvdWxkIGJlIHJvdW5kZWQgdG8gdGhlIG5lYXJlc3QgaW50ZWdlclxuXHRcdFx0ICovXG5cdFx0XHRNaW5pUHJvcFR3ZWVuID0gZnVuY3Rpb24odCwgcCwgdiwgbmV4dCwgcikge1xuXHRcdFx0XHR0aGlzLnQgPSB0O1xuXHRcdFx0XHR0aGlzLnAgPSBwO1xuXHRcdFx0XHR0aGlzLnYgPSB2O1xuXHRcdFx0XHR0aGlzLnIgPSByO1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdG5leHQuX3ByZXYgPSB0aGlzO1xuXHRcdFx0XHRcdHRoaXMuX25leHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIE1vc3Qgb3RoZXIgcGx1Z2lucyAobGlrZSBCZXppZXJQbHVnaW4gYW5kIFRocm93UHJvcHNQbHVnaW4gYW5kIG90aGVycykgY2FuIG9ubHkgdHdlZW4gbnVtZXJpYyB2YWx1ZXMsIGJ1dCBDU1NQbHVnaW4gbXVzdCBhY2NvbW1vZGF0ZSBzcGVjaWFsIHZhbHVlcyB0aGF0IGhhdmUgYSBidW5jaCBvZiBleHRyYSBkYXRhIChsaWtlIGEgc3VmZml4IG9yIHN0cmluZ3MgYmV0d2VlbiBudW1lcmljIHZhbHVlcywgZXRjLikuIEZvciBleGFtcGxlLCBib3hTaGFkb3cgaGFzIHZhbHVlcyBsaWtlIFwiMTBweCAxMHB4IDIwcHggMzBweCByZ2IoMjU1LDAsMClcIiB3aGljaCB3b3VsZCB1dHRlcmx5IGNvbmZ1c2Ugb3RoZXIgcGx1Z2lucy4gVGhpcyBtZXRob2QgYWxsb3dzIHVzIHRvIHNwbGl0IHRoYXQgZGF0YSBhcGFydCBhbmQgZ3JhYiBvbmx5IHRoZSBudW1lcmljIGRhdGEgYW5kIGF0dGFjaCBpdCB0byB1bmlxdWVseS1uYW1lZCBwcm9wZXJ0aWVzIG9mIGEgZ2VuZXJpYyBwcm94eSBvYmplY3QgKHt9KSBzbyB0aGF0IHdlIGNhbiBmZWVkIHRoYXQgdG8gdmlydHVhbGx5IGFueSBwbHVnaW4gdG8gaGF2ZSB0aGUgbnVtYmVycyB0d2VlbmVkLiBIb3dldmVyLCB3ZSBtdXN0IGFsc28ga2VlcCB0cmFjayBvZiB3aGljaCBwcm9wZXJ0aWVzIGZyb20gdGhlIHByb3h5IGdvIHdpdGggd2hpY2ggQ1NTUHJvcFR3ZWVuIHZhbHVlcyBhbmQgaW5zdGFuY2VzLiBTbyB3ZSBjcmVhdGUgYSBsaW5rZWQgbGlzdCBvZiBNaW5pUHJvcFR3ZWVucy4gRWFjaCBvbmUgcmVjb3JkcyBhIHRhcmdldCAodGhlIG9yaWdpbmFsIENTU1Byb3BUd2VlbiksIHByb3BlcnR5IChsaWtlIFwic1wiIG9yIFwieG4xXCIgb3IgXCJ4bjJcIikgdGhhdCB3ZSdyZSB0d2VlbmluZyBhbmQgdGhlIHVuaXF1ZSBwcm9wZXJ0eSBuYW1lIHRoYXQgd2FzIHVzZWQgZm9yIHRoZSBwcm94eSAobGlrZSBcImJveFNoYWRvd194bjFcIiBhbmQgXCJib3hTaGFkb3dfeG4yXCIpIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGV5IG5lZWQgdG8gYmUgcm91bmRlZC4gVGhhdCB3YXksIGluIHRoZSBfc2V0UGx1Z2luUmF0aW8oKSBtZXRob2Qgd2UgY2FuIHNpbXBseSBjb3B5IHRoZSB2YWx1ZXMgb3ZlciBmcm9tIHRoZSBwcm94eSB0byB0aGUgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlKHMpLiBUaGVuLCB3aGVuIHRoZSBtYWluIENTU1BsdWdpbiBzZXRSYXRpbygpIG1ldGhvZCBydW5zIGFuZCBhcHBsaWVzIHRoZSBDU1NQcm9wVHdlZW4gdmFsdWVzIGFjY29yZGluZ2x5LCB0aGV5J3JlIHVwZGF0ZWQgbmljZWx5LiBTbyB0aGUgZXh0ZXJuYWwgcGx1Z2luIHR3ZWVucyB0aGUgbnVtYmVycywgX3NldFBsdWdpblJhdGlvKCkgY29waWVzIHRoZW0gb3ZlciwgYW5kIHNldFJhdGlvKCkgYWN0cyBub3JtYWxseSwgYXBwbHlpbmcgY3NzLXNwZWNpZmljIHZhbHVlcyB0byB0aGUgZWxlbWVudC5cblx0XHRcdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHRcdCAqICAtIHByb3h5OiBhIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN0YXJ0aW5nIHZhbHVlcyBmb3IgYWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSB0d2VlbmVkIGJ5IHRoZSBleHRlcm5hbCBwbHVnaW4uICBUaGlzIGlzIHdoYXQgd2UgZmVlZCB0byB0aGUgZXh0ZXJuYWwgX29uSW5pdFR3ZWVuKCkgYXMgdGhlIHRhcmdldFxuXHRcdFx0ICogIC0gZW5kOiBhIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuZGluZyB2YWx1ZXMgZm9yIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgdHdlZW5lZCBieSB0aGUgZXh0ZXJuYWwgcGx1Z2luLiBUaGlzIGlzIHdoYXQgd2UgZmVlZCB0byB0aGUgZXh0ZXJuYWwgcGx1Z2luJ3MgX29uSW5pdFR3ZWVuKCkgYXMgdGhlIGRlc3RpbmF0aW9uIHZhbHVlc1xuXHRcdFx0ICogIC0gZmlyc3RNUFQ6IHRoZSBmaXJzdCBNaW5pUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdFx0ICogIC0gcHQ6IHRoZSBmaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0IHRoYXQgd2FzIGNyZWF0ZWQgd2hlbiBwYXJzaW5nLiBJZiBzaGFsbG93IGlzIHRydWUsIHRoaXMgbGlua2VkIGxpc3Qgd2lsbCBOT1QgYXR0YWNoIHRvIHRoZSBvbmUgcGFzc2VkIGludG8gdGhlIF9wYXJzZVRvUHJveHkoKSBhcyB0aGUgXCJwdFwiICg0dGgpIHBhcmFtZXRlci5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgb2JqZWN0IHRvIGJlIHR3ZWVuZWRcblx0XHRcdCAqIEBwYXJhbSB7IShPYmplY3R8c3RyaW5nKX0gdmFycyB0aGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0d2VlbmluZyB2YWx1ZXMgKHR5cGljYWxseSB0aGUgZW5kL2Rlc3RpbmF0aW9uIHZhbHVlcykgdGhhdCBzaG91bGQgYmUgcGFyc2VkXG5cdFx0XHQgKiBAcGFyYW0geyFDU1NQbHVnaW59IGNzc3AgVGhlIENTU1BsdWdpbiBpbnN0YW5jZVxuXHRcdFx0ICogQHBhcmFtIHtDU1NQcm9wVHdlZW49fSBwdCB0aGUgbmV4dCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIHRoZSBleHRlcm5hbCBUd2VlblBsdWdpbiBpbnN0YW5jZSB0aGF0IHdpbGwgYmUgaGFuZGxpbmcgdHdlZW5pbmcgdGhlIG51bWVyaWMgdmFsdWVzXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaGFsbG93IGlmIHRydWUsIHRoZSByZXN1bHRpbmcgbGlua2VkIGxpc3QgZnJvbSB0aGUgcGFyc2Ugd2lsbCBOT1QgYmUgYXR0YWNoZWQgdG8gdGhlIENTU1Byb3BUd2VlbiB0aGF0IHdhcyBwYXNzZWQgaW4gYXMgdGhlIFwicHRcIiAoNHRoKSBwYXJhbWV0ZXIuXG5cdFx0XHQgKiBAcmV0dXJuIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczogcHJveHksIGVuZCwgZmlyc3RNUFQsIGFuZCBwdCAoc2VlIGFib3ZlIGZvciBkZXNjcmlwdGlvbnMpXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZVRvUHJveHkgPSBfaW50ZXJuYWxzLl9wYXJzZVRvUHJveHkgPSBmdW5jdGlvbih0LCB2YXJzLCBjc3NwLCBwdCwgcGx1Z2luLCBzaGFsbG93KSB7XG5cdFx0XHRcdHZhciBicHQgPSBwdCxcblx0XHRcdFx0XHRzdGFydCA9IHt9LFxuXHRcdFx0XHRcdGVuZCA9IHt9LFxuXHRcdFx0XHRcdHRyYW5zZm9ybSA9IGNzc3AuX3RyYW5zZm9ybSxcblx0XHRcdFx0XHRvbGRGb3JjZSA9IF9mb3JjZVBULFxuXHRcdFx0XHRcdGksIHAsIHhwLCBtcHQsIGZpcnN0UFQ7XG5cdFx0XHRcdGNzc3AuX3RyYW5zZm9ybSA9IG51bGw7XG5cdFx0XHRcdF9mb3JjZVBUID0gdmFycztcblx0XHRcdFx0cHQgPSBmaXJzdFBUID0gY3NzcC5wYXJzZSh0LCB2YXJzLCBwdCwgcGx1Z2luKTtcblx0XHRcdFx0X2ZvcmNlUFQgPSBvbGRGb3JjZTtcblx0XHRcdFx0Ly9icmVhayBvZmYgZnJvbSB0aGUgbGlua2VkIGxpc3Qgc28gdGhlIG5ldyBvbmVzIGFyZSBpc29sYXRlZC5cblx0XHRcdFx0aWYgKHNoYWxsb3cpIHtcblx0XHRcdFx0XHRjc3NwLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cdFx0XHRcdFx0aWYgKGJwdCkge1xuXHRcdFx0XHRcdFx0YnB0Ll9wcmV2ID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmIChicHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdFx0YnB0Ll9wcmV2Ll9uZXh0ID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKHB0ICYmIHB0ICE9PSBicHQpIHtcblx0XHRcdFx0XHRpZiAocHQudHlwZSA8PSAxKSB7XG5cdFx0XHRcdFx0XHRwID0gcHQucDtcblx0XHRcdFx0XHRcdGVuZFtwXSA9IHB0LnMgKyBwdC5jO1xuXHRcdFx0XHRcdFx0c3RhcnRbcF0gPSBwdC5zO1xuXHRcdFx0XHRcdFx0aWYgKCFzaGFsbG93KSB7XG5cdFx0XHRcdFx0XHRcdG1wdCA9IG5ldyBNaW5pUHJvcFR3ZWVuKHB0LCBcInNcIiwgcCwgbXB0LCBwdC5yKTtcblx0XHRcdFx0XHRcdFx0cHQuYyA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocHQudHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRpID0gcHQubDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHR4cCA9IFwieG5cIiArIGk7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IHB0LnAgKyBcIl9cIiArIHhwO1xuXHRcdFx0XHRcdFx0XHRcdGVuZFtwXSA9IHB0LmRhdGFbeHBdO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0W3BdID0gcHRbeHBdO1xuXHRcdFx0XHRcdFx0XHRcdGlmICghc2hhbGxvdykge1xuXHRcdFx0XHRcdFx0XHRcdFx0bXB0ID0gbmV3IE1pbmlQcm9wVHdlZW4ocHQsIHhwLCBwLCBtcHQsIHB0LnJ4cFt4cF0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7cHJveHk6c3RhcnQsIGVuZDplbmQsIGZpcnN0TVBUOm1wdCwgcHQ6Zmlyc3RQVH07XG5cdFx0XHR9LFxuXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAY29uc3RydWN0b3IgRWFjaCBwcm9wZXJ0eSB0aGF0IGlzIHR3ZWVuZWQgaGFzIGF0IGxlYXN0IG9uZSBDU1NQcm9wVHdlZW4gYXNzb2NpYXRlZCB3aXRoIGl0LiBUaGVzZSBpbnN0YW5jZXMgc3RvcmUgaW1wb3J0YW50IGluZm9ybWF0aW9uIGxpa2UgdGhlIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0aW5nIHZhbHVlLCBhbW91bnQgb2YgY2hhbmdlLCBldGMuIFRoZXkgY2FuIGFsc28gb3B0aW9uYWxseSBoYXZlIGEgbnVtYmVyIG9mIFwiZXh0cmFcIiBzdHJpbmdzIGFuZCBudW1lcmljIHZhbHVlcyBuYW1lZCB4czEsIHhuMSwgeHMyLCB4bjIsIHhzMywgeG4zLCBldGMuIHdoZXJlIFwic1wiIGluZGljYXRlcyBzdHJpbmcgYW5kIFwiblwiIGluZGljYXRlcyBudW1iZXIuIFRoZXNlIGNhbiBiZSBwaWVjZWQgdG9nZXRoZXIgaW4gYSBjb21wbGV4LXZhbHVlIHR3ZWVuICh0eXBlOjEpIHRoYXQgaGFzIGFsdGVybmF0aW5nIHR5cGVzIG9mIGRhdGEgbGlrZSBhIHN0cmluZywgbnVtYmVyLCBzdHJpbmcsIG51bWJlciwgZXRjLiBGb3IgZXhhbXBsZSwgYm94U2hhZG93IGNvdWxkIGJlIFwiNXB4IDVweCA4cHggcmdiKDEwMiwgMTAyLCA1MSlcIi4gSW4gdGhhdCB2YWx1ZSwgdGhlcmUgYXJlIDYgbnVtYmVycyB0aGF0IG1heSBuZWVkIHRvIHR3ZWVuIGFuZCB0aGVuIHBpZWNlZCBiYWNrIHRvZ2V0aGVyIGludG8gYSBzdHJpbmcgYWdhaW4gd2l0aCBzcGFjZXMsIHN1ZmZpeGVzLCBldGMuIHhzMCBpcyBzcGVjaWFsIGluIHRoYXQgaXQgc3RvcmVzIHRoZSBzdWZmaXggZm9yIHN0YW5kYXJkICh0eXBlOjApIHR3ZWVucywgLU9SLSB0aGUgZmlyc3Qgc3RyaW5nIChwcmVmaXgpIGluIGEgY29tcGxleC12YWx1ZSAodHlwZToxKSBDU1NQcm9wVHdlZW4gLU9SLSBpdCBjYW4gYmUgdGhlIG5vbi10d2VlbmluZyB2YWx1ZSBpbiBhIHR5cGU6LTEgQ1NTUHJvcFR3ZWVuLiBXZSBkbyB0aGlzIHRvIGNvbnNlcnZlIG1lbW9yeS5cblx0XHRcdCAqIENTU1Byb3BUd2VlbnMgaGF2ZSB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgYXMgd2VsbCAobm90IGRlZmluZWQgdGhyb3VnaCB0aGUgY29uc3RydWN0b3IpOlxuXHRcdFx0ICogIC0gbDogTGVuZ3RoIGluIHRlcm1zIG9mIHRoZSBudW1iZXIgb2YgZXh0cmEgcHJvcGVydGllcyB0aGF0IHRoZSBDU1NQcm9wVHdlZW4gaGFzIChkZWZhdWx0OiAwKS4gRm9yIGV4YW1wbGUsIGZvciBhIGJveFNoYWRvdyB3ZSBtYXkgbmVlZCB0byB0d2VlbiA1IG51bWJlcnMgaW4gd2hpY2ggY2FzZSBsIHdvdWxkIGJlIDU7IEtlZXAgaW4gbWluZCB0aGF0IHRoZSBzdGFydC9lbmQgdmFsdWVzIGZvciB0aGUgZmlyc3QgbnVtYmVyIHRoYXQncyB0d2VlbmVkIGFyZSBhbHdheXMgc3RvcmVkIGluIHRoZSBzIGFuZCBjIHByb3BlcnRpZXMgdG8gY29uc2VydmUgbWVtb3J5LiBBbGwgYWRkaXRpb25hbCB2YWx1ZXMgdGhlcmVhZnRlciBhcmUgc3RvcmVkIGluIHhuMSwgeG4yLCBldGMuXG5cdFx0XHQgKiAgLSB4Zmlyc3Q6IFRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgc3ViLUNTU1Byb3BUd2VlbnMgdGhhdCBhcmUgdHdlZW5pbmcgcHJvcGVydGllcyBvZiB0aGlzIGluc3RhbmNlLiBGb3IgZXhhbXBsZSwgd2UgbWF5IHNwbGl0IHVwIGEgYm94U2hhZG93IHR3ZWVuIHNvIHRoYXQgdGhlcmUncyBhIG1haW4gQ1NTUHJvcFR3ZWVuIG9mIHR5cGU6MSB0aGF0IGhhcyB2YXJpb3VzIHhzKiBhbmQgeG4qIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGgtc2hhZG93LCB2LXNoYWRvdywgYmx1ciwgY29sb3IsIGV0Yy4gVGhlbiB3ZSBzcGF3biBhIENTU1Byb3BUd2VlbiBmb3IgZWFjaCBvZiB0aG9zZSB0aGF0IGhhcyBhIGhpZ2hlciBwcmlvcml0eSBhbmQgcnVucyBCRUZPUkUgdGhlIG1haW4gQ1NTUHJvcFR3ZWVuIHNvIHRoYXQgdGhlIHZhbHVlcyBhcmUgYWxsIHNldCBieSB0aGUgdGltZSBpdCBuZWVkcyB0byByZS1hc3NlbWJsZSB0aGVtLiBUaGUgeGZpcnN0IGdpdmVzIHVzIGFuIGVhc3kgd2F5IHRvIGlkZW50aWZ5IHRoZSBmaXJzdCBvbmUgaW4gdGhhdCBjaGFpbiB3aGljaCB0eXBpY2FsbHkgZW5kcyBhdCB0aGUgbWFpbiBvbmUgKGJlY2F1c2UgdGhleSdyZSBhbGwgcHJlcGVuZGUgdG8gdGhlIGxpbmtlZCBsaXN0KVxuXHRcdFx0ICogIC0gcGx1Z2luOiBUaGUgVHdlZW5QbHVnaW4gaW5zdGFuY2UgdGhhdCB3aWxsIGhhbmRsZSB0aGUgdHdlZW5pbmcgb2YgYW55IGNvbXBsZXggdmFsdWVzLiBGb3IgZXhhbXBsZSwgc29tZXRpbWVzIHdlIGRvbid0IHdhbnQgdG8gdXNlIG5vcm1hbCBzdWJ0d2VlbnMgKGxpa2UgeGZpcnN0IHJlZmVycyB0bykgdG8gdHdlZW4gdGhlIHZhbHVlcyAtIHdlIG1pZ2h0IHdhbnQgVGhyb3dQcm9wc1BsdWdpbiBvciBCZXppZXJQbHVnaW4gc29tZSBvdGhlciBwbHVnaW4gdG8gZG8gdGhlIGFjdHVhbCB0d2VlbmluZywgc28gd2UgY3JlYXRlIGEgcGx1Z2luIGluc3RhbmNlIGFuZCBzdG9yZSBhIHJlZmVyZW5jZSBoZXJlLiBXZSBuZWVkIHRoaXMgcmVmZXJlbmNlIHNvIHRoYXQgaWYgd2UgZ2V0IGEgcmVxdWVzdCB0byByb3VuZCB2YWx1ZXMgb3IgZGlzYWJsZSBhIHR3ZWVuLCB3ZSBjYW4gcGFzcyBhbG9uZyB0aGF0IHJlcXVlc3QuXG5cdFx0XHQgKiAgLSBkYXRhOiBBcmJpdHJhcnkgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIHN0b3JlZCB3aXRoIHRoZSBDU1NQcm9wVHdlZW4uIFR5cGljYWxseSBpZiB3ZSdyZSBnb2luZyB0byBoYXZlIGEgcGx1Z2luIGhhbmRsZSB0aGUgdHdlZW5pbmcgb2YgYSBjb21wbGV4LXZhbHVlIHR3ZWVuLCB3ZSBjcmVhdGUgYSBnZW5lcmljIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUgRU5EIHZhbHVlcyB0aGF0IHdlJ3JlIHR3ZWVuaW5nIHRvIGFuZCB0aGUgQ1NTUHJvcFR3ZWVuJ3MgeHMxLCB4czIsIGV0Yy4gaGF2ZSB0aGUgc3RhcnRpbmcgdmFsdWVzLiBXZSBzdG9yZSB0aGF0IG9iamVjdCBhcyBkYXRhLiBUaGF0IHdheSwgd2UgY2FuIHNpbXBseSBwYXNzIHRoYXQgb2JqZWN0IHRvIHRoZSBwbHVnaW4gYW5kIHVzZSB0aGUgQ1NTUHJvcFR3ZWVuIGFzIHRoZSB0YXJnZXQuXG5cdFx0XHQgKiAgLSBzZXRSYXRpbzogT25seSB1c2VkIGZvciB0eXBlOjIgdHdlZW5zIHRoYXQgcmVxdWlyZSBjdXN0b20gZnVuY3Rpb25hbGl0eS4gSW4gdGhpcyBjYXNlLCB3ZSBjYWxsIHRoZSBDU1NQcm9wVHdlZW4ncyBzZXRSYXRpbygpIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmF0aW8gZWFjaCB0aW1lIHRoZSB0d2VlbiB1cGRhdGVzLiBUaGlzIGlzbid0IHF1aXRlIGFzIGVmZmljaWVudCBhcyBkb2luZyB0aGluZ3MgZGlyZWN0bHkgaW4gdGhlIENTU1BsdWdpbidzIHNldFJhdGlvKCkgbWV0aG9kLCBidXQgaXQncyB2ZXJ5IGNvbnZlbmllbnQgYW5kIGZsZXhpYmxlLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgd2lsbCBiZSB0d2VlbmVkLiBPZnRlbiBhIERPTSBlbGVtZW50LCBidXQgbm90IGFsd2F5cy4gSXQgY291bGQgYmUgYW55dGhpbmcuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcCBQcm9wZXJ0eSB0byB0d2VlbiAobmFtZSkuIEZvciBleGFtcGxlLCB0byB0d2VlbiBlbGVtZW50LndpZHRoLCBwIHdvdWxkIGJlIFwid2lkdGhcIi5cblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBzIFN0YXJ0aW5nIG51bWVyaWMgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBjIENoYW5nZSBpbiBudW1lcmljIHZhbHVlIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgZW50aXJlIHR3ZWVuLiBGb3IgZXhhbXBsZSwgaWYgZWxlbWVudC53aWR0aCBzdGFydHMgYXQgNSBhbmQgc2hvdWxkIGVuZCBhdCAxMDAsIGMgd291bGQgYmUgOTUuXG5cdFx0XHQgKiBAcGFyYW0ge0NTU1Byb3BUd2Vlbj19IG5leHQgVGhlIG5leHQgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdC4gSWYgb25lIGlzIGRlZmluZWQsIHdlIHdpbGwgZGVmaW5lIGl0cyBfcHJldiBhcyB0aGUgbmV3IGluc3RhbmNlLCBhbmQgdGhlIG5ldyBpbnN0YW5jZSdzIF9uZXh0IHdpbGwgYmUgcG9pbnRlZCBhdCBpdC5cblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gdHlwZSBUaGUgdHlwZSBvZiBDU1NQcm9wVHdlZW4gd2hlcmUgLTEgPSBhIG5vbi10d2VlbmluZyB2YWx1ZSwgMCA9IGEgc3RhbmRhcmQgc2ltcGxlIHR3ZWVuLCAxID0gYSBjb21wbGV4IHZhbHVlIChsaWtlIG9uZSB0aGF0IGhhcyBtdWx0aXBsZSBudW1iZXJzIGluIGEgY29tbWEtIG9yIHNwYWNlLWRlbGltaXRlZCBzdHJpbmcgbGlrZSBib3JkZXI6XCIxcHggc29saWQgcmVkXCIpLCBhbmQgMiA9IG9uZSB0aGF0IHVzZXMgYSBjdXN0b20gc2V0UmF0aW8gZnVuY3Rpb24gdGhhdCBkb2VzIGFsbCBvZiB0aGUgd29yayBvZiBhcHBseWluZyB0aGUgdmFsdWVzIG9uIGVhY2ggdXBkYXRlLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBuIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIG92ZXJ3cml0aW5nIHB1cnBvc2VzIHdoaWNoIGlzIHR5cGljYWxseSB0aGUgc2FtZSBhcyBwIGJ1dCBub3QgYWx3YXlzLiBGb3IgZXhhbXBsZSwgd2UgbWF5IG5lZWQgdG8gY3JlYXRlIGEgc3VidHdlZW4gZm9yIHRoZSAybmQgcGFydCBvZiBhIFwiY2xpcDpyZWN0KC4uLilcIiB0d2VlbiBpbiB3aGljaCBjYXNlIFwicFwiIG1pZ2h0IGJlIHhzMSBidXQgXCJuXCIgaXMgc3RpbGwgXCJjbGlwXCJcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHIgSWYgdHJ1ZSwgdGhlIHZhbHVlKHMpIHNob3VsZCBiZSByb3VuZGVkXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcj19IHByIFByaW9yaXR5IGluIHRoZSBsaW5rZWQgbGlzdCBvcmRlci4gSGlnaGVyIHByaW9yaXR5IENTU1Byb3BUd2VlbnMgd2lsbCBiZSB1cGRhdGVkIGJlZm9yZSBsb3dlciBwcmlvcml0eSBvbmVzLiBUaGUgZGVmYXVsdCBwcmlvcml0eSBpcyAwLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBiIEJlZ2lubmluZyB2YWx1ZS4gV2Ugc3RvcmUgdGhpcyB0byBlbnN1cmUgdGhhdCBpdCBpcyBFWEFDVExZIHdoYXQgaXQgd2FzIHdoZW4gdGhlIHR3ZWVuIGJlZ2FuIHdpdGhvdXQgYW55IHJpc2sgb2YgaW50ZXJwcmV0YXRpb24gaXNzdWVzLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBlIEVuZGluZyB2YWx1ZS4gV2Ugc3RvcmUgdGhpcyB0byBlbnN1cmUgdGhhdCBpdCBpcyBFWEFDVExZIHdoYXQgdGhlIHVzZXIgZGVmaW5lZCBhdCB0aGUgZW5kIG9mIHRoZSB0d2VlbiB3aXRob3V0IGFueSByaXNrIG9mIGludGVycHJldGF0aW9uIGlzc3Vlcy5cblx0XHRcdCAqL1xuXHRcdFx0Q1NTUHJvcFR3ZWVuID0gX2ludGVybmFscy5DU1NQcm9wVHdlZW4gPSBmdW5jdGlvbih0LCBwLCBzLCBjLCBuZXh0LCB0eXBlLCBuLCByLCBwciwgYiwgZSkge1xuXHRcdFx0XHR0aGlzLnQgPSB0OyAvL3RhcmdldFxuXHRcdFx0XHR0aGlzLnAgPSBwOyAvL3Byb3BlcnR5XG5cdFx0XHRcdHRoaXMucyA9IHM7IC8vc3RhcnRpbmcgdmFsdWVcblx0XHRcdFx0dGhpcy5jID0gYzsgLy9jaGFuZ2UgdmFsdWVcblx0XHRcdFx0dGhpcy5uID0gbiB8fCBwOyAvL25hbWUgdGhhdCB0aGlzIENTU1Byb3BUd2VlbiBzaG91bGQgYmUgYXNzb2NpYXRlZCB0byAodXN1YWxseSB0aGUgc2FtZSBhcyBwLCBidXQgbm90IGFsd2F5cyAtIG4gaXMgd2hhdCBvdmVyd3JpdGluZyBsb29rcyBhdClcblx0XHRcdFx0aWYgKCEodCBpbnN0YW5jZW9mIENTU1Byb3BUd2VlbikpIHtcblx0XHRcdFx0XHRfb3ZlcndyaXRlUHJvcHMucHVzaCh0aGlzLm4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuciA9IHI7IC8vcm91bmQgKGJvb2xlYW4pXG5cdFx0XHRcdHRoaXMudHlwZSA9IHR5cGUgfHwgMDsgLy8wID0gbm9ybWFsIHR3ZWVuLCAtMSA9IG5vbi10d2VlbmluZyAoaW4gd2hpY2ggY2FzZSB4czAgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSB0YXJnZXQncyBwcm9wZXJ0eSwgbGlrZSB0cC50W3RwLnBdID0gdHAueHMwKSwgMSA9IGNvbXBsZXgtdmFsdWUgU3BlY2lhbFByb3AsIDIgPSBjdXN0b20gc2V0UmF0aW8oKSB0aGF0IGRvZXMgYWxsIHRoZSB3b3JrXG5cdFx0XHRcdGlmIChwcikge1xuXHRcdFx0XHRcdHRoaXMucHIgPSBwcjtcblx0XHRcdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYiA9IChiID09PSB1bmRlZmluZWQpID8gcyA6IGI7XG5cdFx0XHRcdHRoaXMuZSA9IChlID09PSB1bmRlZmluZWQpID8gcyArIGMgOiBlO1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdHRoaXMuX25leHQgPSBuZXh0O1xuXHRcdFx0XHRcdG5leHQuX3ByZXYgPSB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfYWRkTm9uVHdlZW5pbmdOdW1lcmljUFQgPSBmdW5jdGlvbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQsIG5leHQsIG92ZXJ3cml0ZVByb3ApIHsgLy9jbGVhbnMgdXAgc29tZSBjb2RlIHJlZHVuZGFuY2llcyBhbmQgaGVscHMgbWluaWZpY2F0aW9uLiBKdXN0IGEgZmFzdCB3YXkgdG8gYWRkIGEgTlVNRVJJQyBub24tdHdlZW5pbmcgQ1NTUHJvcFR3ZWVuXG5cdFx0XHRcdHZhciBwdCA9IG5ldyBDU1NQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kIC0gc3RhcnQsIG5leHQsIC0xLCBvdmVyd3JpdGVQcm9wKTtcblx0XHRcdFx0cHQuYiA9IHN0YXJ0O1xuXHRcdFx0XHRwdC5lID0gcHQueHMwID0gZW5kO1xuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRha2VzIGEgdGFyZ2V0LCB0aGUgYmVnaW5uaW5nIHZhbHVlIGFuZCBlbmRpbmcgdmFsdWUgKGFzIHN0cmluZ3MpIGFuZCBwYXJzZXMgdGhlbSBpbnRvIGEgQ1NTUHJvcFR3ZWVuIChwb3NzaWJseSB3aXRoIGNoaWxkIENTU1Byb3BUd2VlbnMpIHRoYXQgYWNjb21tb2RhdGVzIG11bHRpcGxlIG51bWJlcnMsIGNvbG9ycywgY29tbWEtZGVsaW1pdGVkIHZhbHVlcywgZXRjLiBGb3IgZXhhbXBsZTpcblx0XHRcdCAqIHNwLnBhcnNlQ29tcGxleChlbGVtZW50LCBcImJveFNoYWRvd1wiLCBcIjVweCAxMHB4IDIwcHggcmdiKDI1NSwxMDIsNTEpXCIsIFwiMHB4IDBweCAwcHggcmVkXCIsIHRydWUsIFwiMHB4IDBweCAwcHggcmdiKDAsMCwwLDApXCIsIHB0KTtcblx0XHRcdCAqIEl0IHdpbGwgd2FsayB0aHJvdWdoIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgc2FtZSBmb3JtYXQgd2l0aCB0aGUgc2FtZSBudW1iZXIgYW5kIHR5cGUgb2YgdmFsdWVzKSBhbmQgZmlndXJlIG91dCB3aGljaCBwYXJ0cyBhcmUgbnVtYmVycywgd2hhdCBzdHJpbmdzIHNlcGFyYXRlIHRoZSBudW1lcmljL3R3ZWVuYWJsZSB2YWx1ZXMsIGFuZCB0aGVuIGNyZWF0ZSB0aGUgQ1NTUHJvcFR3ZWVucyBhY2NvcmRpbmdseS4gSWYgYSBwbHVnaW4gaXMgZGVmaW5lZCwgbm8gY2hpbGQgQ1NTUHJvcFR3ZWVucyB3aWxsIGJlIGNyZWF0ZWQuIEluc3RlYWQsIHRoZSBlbmRpbmcgdmFsdWVzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBcImRhdGFcIiBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQgQ1NTUHJvcFR3ZWVuIGxpa2U6IHtzOi01LCB4bjE6LTEwLCB4bjI6LTIwLCB4bjM6MjU1LCB4bjQ6MCwgeG41OjB9IHNvIHRoYXQgaXQgY2FuIGJlIGZlZCB0byBhbnkgb3RoZXIgcGx1Z2luIGFuZCBpdCdsbCBiZSBwbGFpbiBudW1lcmljIHR3ZWVucyBidXQgdGhlIHJlY29tcG9zaXRpb24gb2YgdGhlIGNvbXBsZXggdmFsdWUgd2lsbCBiZSBoYW5kbGVkIGluc2lkZSBDU1NQbHVnaW4ncyBzZXRSYXRpbygpLlxuXHRcdFx0ICogSWYgYSBzZXRSYXRpbyBpcyBkZWZpbmVkLCB0aGUgdHlwZSBvZiB0aGUgQ1NTUHJvcFR3ZWVuIHdpbGwgYmUgc2V0IHRvIDIgYW5kIHJlY29tcG9zaXRpb24gb2YgdGhlIHZhbHVlcyB3aWxsIGJlIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGF0IG1ldGhvZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IHdob3NlIHByb3BlcnR5IHdpbGwgYmUgdHdlZW5lZFxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IHRoYXQgd2lsbCBiZSB0d2VlbmVkIChpdHMgbmFtZSwgbGlrZSBcImxlZnRcIiBvciBcImJhY2tncm91bmRDb2xvclwiIG9yIFwiYm94U2hhZG93XCIpXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYiBCZWdpbm5pbmcgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBlIEVuZGluZyB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFufSBjbHJzIElmIHRydWUsIHRoZSB2YWx1ZSBjb3VsZCBjb250YWluIGEgY29sb3IgdmFsdWUgbGlrZSBcInJnYigyNTUsMCwwKVwiIG9yIFwiI0YwMFwiIG9yIFwicmVkXCIuIFRoZSBkZWZhdWx0IGlzIGZhbHNlLCBzbyBubyBjb2xvcnMgd2lsbCBiZSByZWNvZ25pemVkIChhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcblx0XHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXJ8T2JqZWN0KX0gZGZsdCBUaGUgZGVmYXVsdCBiZWdpbm5pbmcgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBpZiBubyB2YWxpZCBiZWdpbm5pbmcgdmFsdWUgaXMgZGVmaW5lZCBvciBpZiB0aGUgbnVtYmVyIG9mIHZhbHVlcyBpbnNpZGUgdGhlIGNvbXBsZXggYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIGRvbid0IG1hdGNoXG5cdFx0XHQgKiBAcGFyYW0gez9DU1NQcm9wVHdlZW59IHB0IENTU1Byb3BUd2VlbiBpbnN0YW5jZSB0aGF0IGlzIHRoZSBjdXJyZW50IGhlYWQgb2YgdGhlIGxpbmtlZCBsaXN0ICh3ZSdsbCBwcmVwZW5kIHRvIHRoaXMpLlxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXI9fSBwciBQcmlvcml0eSBpbiB0aGUgbGlua2VkIGxpc3Qgb3JkZXIuIEhpZ2hlciBwcmlvcml0eSBwcm9wZXJ0aWVzIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy4gVGhlIGRlZmF1bHQgcHJpb3JpdHkgaXMgMC5cblx0XHRcdCAqIEBwYXJhbSB7VHdlZW5QbHVnaW49fSBwbHVnaW4gSWYgYSBwbHVnaW4gc2hvdWxkIGhhbmRsZSB0aGUgdHdlZW5pbmcgb2YgZXh0cmEgcHJvcGVydGllcywgcGFzcyB0aGUgcGx1Z2luIGluc3RhbmNlIGhlcmUuIElmIG9uZSBpcyBkZWZpbmVkLCB0aGVuIE5PIHN1YnR3ZWVucyB3aWxsIGJlIGNyZWF0ZWQgZm9yIGFueSBleHRyYSBwcm9wZXJ0aWVzICh0aGUgcHJvcGVydGllcyB3aWxsIGJlIGNyZWF0ZWQgLSBqdXN0IG5vdCBhZGRpdGlvbmFsIENTU1Byb3BUd2VlbiBpbnN0YW5jZXMgdG8gdHdlZW4gdGhlbSkgYmVjYXVzZSB0aGUgcGx1Z2luIGlzIGV4cGVjdGVkIHRvIGRvIHNvLiBIb3dldmVyLCB0aGUgZW5kIHZhbHVlcyBXSUxMIGJlIHBvcHVsYXRlZCBpbiB0aGUgXCJkYXRhXCIgcHJvcGVydHksIGxpa2Uge3M6MTAwLCB4bjE6NTAsIHhuMjozMDB9XG5cdFx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik9fSBzZXRSYXRpbyBJZiB2YWx1ZXMgc2hvdWxkIGJlIHNldCBpbiBhIGN1c3RvbSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGJlaW5nIHBpZWNlZCB0b2dldGhlciBpbiBhIHR5cGU6MSAoY29tcGxleC12YWx1ZSkgQ1NTUHJvcFR3ZWVuLCBkZWZpbmUgdGhhdCBjdXN0b20gZnVuY3Rpb24gaGVyZS5cblx0XHRcdCAqIEByZXR1cm4ge0NTU1Byb3BUd2Vlbn0gVGhlIGZpcnN0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Qgd2hpY2ggaW5jbHVkZXMgdGhlIG5ldyBvbmUocykgYWRkZWQgYnkgdGhlIHBhcnNlQ29tcGxleCgpIGNhbGwuXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUNvbXBsZXggPSBDU1NQbHVnaW4ucGFyc2VDb21wbGV4ID0gZnVuY3Rpb24odCwgcCwgYiwgZSwgY2xycywgZGZsdCwgcHQsIHByLCBwbHVnaW4sIHNldFJhdGlvKSB7XG5cdFx0XHRcdC8vREVCVUc6IF9sb2coXCJwYXJzZUNvbXBsZXg6IFwiK3ArXCIsIGI6IFwiK2IrXCIsIGU6IFwiK2UpO1xuXHRcdFx0XHRiID0gYiB8fCBkZmx0IHx8IFwiXCI7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgKHNldFJhdGlvID8gMiA6IDEpLCBudWxsLCBmYWxzZSwgcHIsIGIsIGUpO1xuXHRcdFx0XHRlICs9IFwiXCI7IC8vZW5zdXJlcyBpdCdzIGEgc3RyaW5nXG5cdFx0XHRcdGlmIChjbHJzICYmIF9jb2xvckV4cC50ZXN0KGUgKyBiKSkgeyAvL2lmIGNvbG9ycyBhcmUgZm91bmQsIG5vcm1hbGl6ZSB0aGUgZm9ybWF0dGluZyB0byByZ2JhKCkgb3IgaHNsYSgpLlxuXHRcdFx0XHRcdGUgPSBbYiwgZV07XG5cdFx0XHRcdFx0Q1NTUGx1Z2luLmNvbG9yU3RyaW5nRmlsdGVyKGUpO1xuXHRcdFx0XHRcdGIgPSBlWzBdO1xuXHRcdFx0XHRcdGUgPSBlWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBiYSA9IGIuc3BsaXQoXCIsIFwiKS5qb2luKFwiLFwiKS5zcGxpdChcIiBcIiksIC8vYmVnaW5uaW5nIGFycmF5XG5cdFx0XHRcdFx0ZWEgPSBlLnNwbGl0KFwiLCBcIikuam9pbihcIixcIikuc3BsaXQoXCIgXCIpLCAvL2VuZGluZyBhcnJheVxuXHRcdFx0XHRcdGwgPSBiYS5sZW5ndGgsXG5cdFx0XHRcdFx0YXV0b1JvdW5kID0gKF9hdXRvUm91bmQgIT09IGZhbHNlKSxcblx0XHRcdFx0XHRpLCB4aSwgbmksIGJ2LCBldiwgYm51bXMsIGVudW1zLCBibiwgaGFzQWxwaGEsIHRlbXAsIGN2LCBzdHIsIHVzZUhTTDtcblx0XHRcdFx0aWYgKGUuaW5kZXhPZihcIixcIikgIT09IC0xIHx8IGIuaW5kZXhPZihcIixcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0YmEgPSBiYS5qb2luKFwiIFwiKS5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwiLCBcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGVhID0gZWEuam9pbihcIiBcIikucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcIiwgXCIpLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRsID0gYmEubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsICE9PSBlYS5sZW5ndGgpIHtcblx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwibWlzbWF0Y2hlZCBmb3JtYXR0aW5nIGRldGVjdGVkIG9uIFwiICsgcCArIFwiIChcIiArIGIgKyBcIiB2cyBcIiArIGUgKyBcIilcIik7XG5cdFx0XHRcdFx0YmEgPSAoZGZsdCB8fCBcIlwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0bCA9IGJhLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gc2V0UmF0aW87XG5cdFx0XHRcdF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0YnYgPSBiYVtpXTtcblx0XHRcdFx0XHRldiA9IGVhW2ldO1xuXHRcdFx0XHRcdGJuID0gcGFyc2VGbG9hdChidik7XG5cdFx0XHRcdFx0Ly9pZiB0aGUgdmFsdWUgYmVnaW5zIHdpdGggYSBudW1iZXIgKG1vc3QgY29tbW9uKS4gSXQncyBmaW5lIGlmIGl0IGhhcyBhIHN1ZmZpeCBsaWtlIHB4XG5cdFx0XHRcdFx0aWYgKGJuIHx8IGJuID09PSAwKSB7XG5cdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKFwiXCIsIGJuLCBfcGFyc2VDaGFuZ2UoZXYsIGJuKSwgZXYucmVwbGFjZShfcmVsTnVtRXhwLCBcIlwiKSwgKGF1dG9Sb3VuZCAmJiBldi5pbmRleE9mKFwicHhcIikgIT09IC0xKSwgdHJ1ZSk7XG5cblx0XHRcdFx0XHQvL2lmIHRoZSB2YWx1ZSBpcyBhIGNvbG9yXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjbHJzICYmIF9jb2xvckV4cC50ZXN0KGJ2KSkge1xuXHRcdFx0XHRcdFx0c3RyID0gZXYuaW5kZXhPZihcIilcIikgKyAxO1xuXHRcdFx0XHRcdFx0c3RyID0gXCIpXCIgKyAoc3RyID8gZXYuc3Vic3RyKHN0cikgOiBcIlwiKTsgLy9pZiB0aGVyZSdzIGEgY29tbWEgb3IgKSBhdCB0aGUgZW5kLCByZXRhaW4gaXQuXG5cdFx0XHRcdFx0XHR1c2VIU0wgPSAoZXYuaW5kZXhPZihcImhzbFwiKSAhPT0gLTEgJiYgX3N1cHBvcnRzT3BhY2l0eSk7XG5cdFx0XHRcdFx0XHRidiA9IF9wYXJzZUNvbG9yKGJ2LCB1c2VIU0wpO1xuXHRcdFx0XHRcdFx0ZXYgPSBfcGFyc2VDb2xvcihldiwgdXNlSFNMKTtcblx0XHRcdFx0XHRcdGhhc0FscGhhID0gKGJ2Lmxlbmd0aCArIGV2Lmxlbmd0aCA+IDYpO1xuXHRcdFx0XHRcdFx0aWYgKGhhc0FscGhhICYmICFfc3VwcG9ydHNPcGFjaXR5ICYmIGV2WzNdID09PSAwKSB7IC8vb2xkZXIgdmVyc2lvbnMgb2YgSUUgZG9uJ3Qgc3VwcG9ydCByZ2JhKCksIHNvIGlmIHRoZSBkZXN0aW5hdGlvbiBhbHBoYSBpcyAwLCBqdXN0IHVzZSBcInRyYW5zcGFyZW50XCIgZm9yIHRoZSBlbmQgY29sb3Jcblx0XHRcdFx0XHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gKz0gcHQubCA/IFwiIHRyYW5zcGFyZW50XCIgOiBcInRyYW5zcGFyZW50XCI7XG5cdFx0XHRcdFx0XHRcdHB0LmUgPSBwdC5lLnNwbGl0KGVhW2ldKS5qb2luKFwidHJhbnNwYXJlbnRcIik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkpIHsgLy9vbGQgdmVyc2lvbnMgb2YgSUUgZG9uJ3Qgc3VwcG9ydCByZ2JhKCkuXG5cdFx0XHRcdFx0XHRcdFx0aGFzQWxwaGEgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAodXNlSFNMKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYSgoaGFzQWxwaGEgPyBcImhzbGEoXCIgOiBcImhzbChcIiksIGJ2WzBdLCBfcGFyc2VDaGFuZ2UoZXZbMF0sIGJ2WzBdKSwgXCIsXCIsIGZhbHNlLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMV0sIF9wYXJzZUNoYW5nZShldlsxXSwgYnZbMV0pLCBcIiUsXCIsIGZhbHNlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMl0sIF9wYXJzZUNoYW5nZShldlsyXSwgYnZbMl0pLCAoaGFzQWxwaGEgPyBcIiUsXCIgOiBcIiVcIiArIHN0ciksIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKChoYXNBbHBoYSA/IFwicmdiYShcIiA6IFwicmdiKFwiKSwgYnZbMF0sIGV2WzBdIC0gYnZbMF0sIFwiLFwiLCB0cnVlLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMV0sIGV2WzFdIC0gYnZbMV0sIFwiLFwiLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMl0sIGV2WzJdIC0gYnZbMl0sIChoYXNBbHBoYSA/IFwiLFwiIDogc3RyKSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoaGFzQWxwaGEpIHtcblx0XHRcdFx0XHRcdFx0XHRidiA9IChidi5sZW5ndGggPCA0KSA/IDEgOiBidlszXTtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKFwiXCIsIGJ2LCAoKGV2Lmxlbmd0aCA8IDQpID8gMSA6IGV2WzNdKSAtIGJ2LCBzdHIsIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7IC8vb3RoZXJ3aXNlIHRoZSB0ZXN0KCkgb24gdGhlIFJlZ0V4cCBjb3VsZCBtb3ZlIHRoZSBsYXN0SW5kZXggYW5kIHRhaW50IGZ1dHVyZSByZXN1bHRzLlxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJudW1zID0gYnYubWF0Y2goX251bUV4cCk7IC8vZ2V0cyBlYWNoIGdyb3VwIG9mIG51bWJlcnMgaW4gdGhlIGJlZ2lubmluZyB2YWx1ZSBzdHJpbmcgYW5kIGRyb3BzIHRoZW0gaW50byBhbiBhcnJheVxuXG5cdFx0XHRcdFx0XHQvL2lmIG5vIG51bWJlciBpcyBmb3VuZCwgdHJlYXQgaXQgYXMgYSBub24tdHdlZW5pbmcgdmFsdWUgYW5kIGp1c3QgYXBwZW5kIHRoZSBzdHJpbmcgdG8gdGhlIGN1cnJlbnQgeHMuXG5cdFx0XHRcdFx0XHRpZiAoIWJudW1zKSB7XG5cdFx0XHRcdFx0XHRcdHB0W1wieHNcIiArIHB0LmxdICs9IChwdC5sIHx8IHB0W1wieHNcIiArIHB0LmxdKSA/IFwiIFwiICsgZXYgOiBldjtcblxuXHRcdFx0XHRcdFx0Ly9sb29wIHRocm91Z2ggYWxsIHRoZSBudW1iZXJzIHRoYXQgYXJlIGZvdW5kIGFuZCBjb25zdHJ1Y3QgdGhlIGV4dHJhIHZhbHVlcyBvbiB0aGUgcHQuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbnVtcyA9IGV2Lm1hdGNoKF9yZWxOdW1FeHApOyAvL2dldCBlYWNoIGdyb3VwIG9mIG51bWJlcnMgaW4gdGhlIGVuZCB2YWx1ZSBzdHJpbmcgYW5kIGRyb3AgdGhlbSBpbnRvIGFuIGFycmF5LiBXZSBhbGxvdyByZWxhdGl2ZSB2YWx1ZXMgdG9vLCBsaWtlICs9NTAgb3IgLT0uNVxuXHRcdFx0XHRcdFx0XHRpZiAoIWVudW1zIHx8IGVudW1zLmxlbmd0aCAhPT0gYm51bXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcIm1pc21hdGNoZWQgZm9ybWF0dGluZyBkZXRlY3RlZCBvbiBcIiArIHAgKyBcIiAoXCIgKyBiICsgXCIgdnMgXCIgKyBlICsgXCIpXCIpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRuaSA9IDA7XG5cdFx0XHRcdFx0XHRcdGZvciAoeGkgPSAwOyB4aSA8IGJudW1zLmxlbmd0aDsgeGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGN2ID0gYm51bXNbeGldO1xuXHRcdFx0XHRcdFx0XHRcdHRlbXAgPSBidi5pbmRleE9mKGN2LCBuaSk7XG5cdFx0XHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYShidi5zdWJzdHIobmksIHRlbXAgLSBuaSksIE51bWJlcihjdiksIF9wYXJzZUNoYW5nZShlbnVtc1t4aV0sIGN2KSwgXCJcIiwgKGF1dG9Sb3VuZCAmJiBidi5zdWJzdHIodGVtcCArIGN2Lmxlbmd0aCwgMikgPT09IFwicHhcIiksICh4aSA9PT0gMCkpO1xuXHRcdFx0XHRcdFx0XHRcdG5pID0gdGVtcCArIGN2Lmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwdFtcInhzXCIgKyBwdC5sXSArPSBidi5zdWJzdHIobmkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL2lmIHRoZXJlIGFyZSByZWxhdGl2ZSB2YWx1ZXMgKFwiKz1cIiBvciBcIi09XCIgcHJlZml4KSwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGVuZGluZyB2YWx1ZSB0byBlbGltaW5hdGUgdGhlIHByZWZpeGVzIGFuZCBjb21iaW5lIHRoZSB2YWx1ZXMgcHJvcGVybHkuXG5cdFx0XHRcdGlmIChlLmluZGV4T2YoXCI9XCIpICE9PSAtMSkgaWYgKHB0LmRhdGEpIHtcblx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyBwdC5kYXRhLnM7XG5cdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieHNcIiArIGldICsgcHQuZGF0YVtcInhuXCIgKyBpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQuZSA9IHN0ciArIHB0W1wieHNcIiArIGldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghcHQubCkge1xuXHRcdFx0XHRcdHB0LnR5cGUgPSAtMTtcblx0XHRcdFx0XHRwdC54czAgPSBwdC5lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwdC54Zmlyc3QgfHwgcHQ7XG5cdFx0XHR9LFxuXHRcdFx0aSA9IDk7XG5cblxuXHRcdHAgPSBDU1NQcm9wVHdlZW4ucHJvdG90eXBlO1xuXHRcdHAubCA9IHAucHIgPSAwOyAvL2xlbmd0aCAobnVtYmVyIG9mIGV4dHJhIHByb3BlcnRpZXMgbGlrZSB4bjEsIHhuMiwgeG4zLCBldGMuXG5cdFx0d2hpbGUgKC0taSA+IDApIHtcblx0XHRcdHBbXCJ4blwiICsgaV0gPSAwO1xuXHRcdFx0cFtcInhzXCIgKyBpXSA9IFwiXCI7XG5cdFx0fVxuXHRcdHAueHMwID0gXCJcIjtcblx0XHRwLl9uZXh0ID0gcC5fcHJldiA9IHAueGZpcnN0ID0gcC5kYXRhID0gcC5wbHVnaW4gPSBwLnNldFJhdGlvID0gcC5yeHAgPSBudWxsO1xuXG5cblx0XHQvKipcblx0XHQgKiBBcHBlbmRzIGFuZCBleHRyYSB0d2VlbmluZyB2YWx1ZSB0byBhIENTU1Byb3BUd2VlbiBhbmQgYXV0b21hdGljYWxseSBtYW5hZ2VzIGFueSBwcmVmaXggYW5kIHN1ZmZpeCBzdHJpbmdzLiBUaGUgZmlyc3QgZXh0cmEgdmFsdWUgaXMgc3RvcmVkIGluIHRoZSBzIGFuZCBjIG9mIHRoZSBtYWluIENTU1Byb3BUd2VlbiBpbnN0YW5jZSwgYnV0IHRoZXJlYWZ0ZXIgYW55IGV4dHJhcyBhcmUgc3RvcmVkIGluIHRoZSB4bjEsIHhuMiwgeG4zLCBldGMuIFRoZSBwcmVmaXhlcyBhbmQgc3VmZml4ZXMgYXJlIHN0b3JlZCBpbiB0aGUgeHMwLCB4czEsIHhzMiwgZXRjLiBwcm9wZXJ0aWVzLiBGb3IgZXhhbXBsZSwgaWYgSSB3YWxrIHRocm91Z2ggYSBjbGlwIHZhbHVlIGxpa2UgXCJyZWN0KDEwcHgsIDVweCwgMHB4LCAyMHB4KVwiLCB0aGUgdmFsdWVzIHdvdWxkIGJlIHN0b3JlZCBsaWtlIHRoaXM6XG5cdFx0ICogeHMwOlwicmVjdChcIiwgczoxMCwgeHMxOlwicHgsIFwiLCB4bjE6NSwgeHMyOlwicHgsIFwiLCB4bjI6MCwgeHMzOlwicHgsIFwiLCB4bjM6MjAsIHhuNDpcInB4KVwiXG5cdFx0ICogQW5kIHRoZXknZCBhbGwgZ2V0IGpvaW5lZCB0b2dldGhlciB3aGVuIHRoZSBDU1NQbHVnaW4gcmVuZGVycyAoaW4gdGhlIHNldFJhdGlvKCkgbWV0aG9kKS5cblx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHBmeCBQcmVmaXggKGlmIGFueSlcblx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IHMgU3RhcnRpbmcgdmFsdWVcblx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IGMgQ2hhbmdlIGluIG51bWVyaWMgdmFsdWUgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBlbnRpcmUgdHdlZW4uIEZvciBleGFtcGxlLCBpZiB0aGUgc3RhcnQgaXMgNSBhbmQgdGhlIGVuZCBpcyAxMDAsIHRoZSBjaGFuZ2Ugd291bGQgYmUgOTUuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBzZnggU3VmZml4IChpZiBhbnkpXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gciBSb3VuZCAoaWYgdHJ1ZSkuXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcGFkIElmIHRydWUsIHRoaXMgZXh0cmEgdmFsdWUgc2hvdWxkIGJlIHNlcGFyYXRlZCBieSB0aGUgcHJldmlvdXMgb25lIGJ5IGEgc3BhY2UuIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGV4dHJhIGFuZCBwYWQgaXMgdHJ1ZSwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGRyb3AgdGhlIHNwYWNlLlxuXHRcdCAqIEByZXR1cm4ge0NTU1Byb3BUd2Vlbn0gcmV0dXJucyBpdHNlbGYgc28gdGhhdCBtdWx0aXBsZSBtZXRob2RzIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLlxuXHRcdCAqL1xuXHRcdHAuYXBwZW5kWHRyYSA9IGZ1bmN0aW9uKHBmeCwgcywgYywgc2Z4LCByLCBwYWQpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMsXG5cdFx0XHRcdGwgPSBwdC5sO1xuXHRcdFx0cHRbXCJ4c1wiICsgbF0gKz0gKHBhZCAmJiAobCB8fCBwdFtcInhzXCIgKyBsXSkpID8gXCIgXCIgKyBwZnggOiBwZnggfHwgXCJcIjtcblx0XHRcdGlmICghYykgaWYgKGwgIT09IDAgJiYgIXB0LnBsdWdpbikgeyAvL3R5cGljYWxseSB3ZSdsbCBjb21iaW5lIG5vbi1jaGFuZ2luZyB2YWx1ZXMgcmlnaHQgaW50byB0aGUgeHMgdG8gb3B0aW1pemUgcGVyZm9ybWFuY2UsIGJ1dCB3ZSBkb24ndCBjb21iaW5lIHRoZW0gd2hlbiB0aGVyZSdzIGEgcGx1Z2luIHRoYXQgd2lsbCBiZSB0d2VlbmluZyB0aGUgdmFsdWVzIGJlY2F1c2UgaXQgbWF5IGRlcGVuZCBvbiB0aGUgdmFsdWVzIGJlaW5nIHNwbGl0IGFwYXJ0LCBsaWtlIGZvciBhIGJlemllciwgaWYgYSB2YWx1ZSBkb2Vzbid0IGNoYW5nZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGl0ZXJhdGlvbiBidXQgdGhlbiBpdCBkb2VzIG9uIHRoZSAzcmQsIHdlJ2xsIHJ1biBpbnRvIHRyb3VibGUgYmVjYXVzZSB0aGVyZSdzIG5vIHhuIHNsb3QgZm9yIHRoYXQgdmFsdWUhXG5cdFx0XHRcdHB0W1wieHNcIiArIGxdICs9IHMgKyAoc2Z4IHx8IFwiXCIpO1xuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9XG5cdFx0XHRwdC5sKys7XG5cdFx0XHRwdC50eXBlID0gcHQuc2V0UmF0aW8gPyAyIDogMTtcblx0XHRcdHB0W1wieHNcIiArIHB0LmxdID0gc2Z4IHx8IFwiXCI7XG5cdFx0XHRpZiAobCA+IDApIHtcblx0XHRcdFx0cHQuZGF0YVtcInhuXCIgKyBsXSA9IHMgKyBjO1xuXHRcdFx0XHRwdC5yeHBbXCJ4blwiICsgbF0gPSByOyAvL3JvdW5kIGV4dHJhIHByb3BlcnR5ICh3ZSBuZWVkIHRvIHRhcCBpbnRvIHRoaXMgaW4gdGhlIF9wYXJzZVRvUHJveHkoKSBtZXRob2QpXG5cdFx0XHRcdHB0W1wieG5cIiArIGxdID0gcztcblx0XHRcdFx0aWYgKCFwdC5wbHVnaW4pIHtcblx0XHRcdFx0XHRwdC54Zmlyc3QgPSBuZXcgQ1NTUHJvcFR3ZWVuKHB0LCBcInhuXCIgKyBsLCBzLCBjLCBwdC54Zmlyc3QgfHwgcHQsIDAsIHB0Lm4sIHIsIHB0LnByKTtcblx0XHRcdFx0XHRwdC54Zmlyc3QueHMwID0gMDsgLy9qdXN0IHRvIGVuc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSBzdGF5cyBudW1lcmljIHdoaWNoIGhlbHBzIG1vZGVybiBicm93c2VycyBzcGVlZCB1cCBwcm9jZXNzaW5nLiBSZW1lbWJlciwgaW4gdGhlIHNldFJhdGlvKCkgbWV0aG9kLCB3ZSBkbyBwdC50W3B0LnBdID0gdmFsICsgcHQueHMwIHNvIGlmIHB0LnhzMCBpcyBcIlwiICh0aGUgZGVmYXVsdCksIGl0J2xsIGNhc3QgdGhlIGVuZCB2YWx1ZSBhcyBhIHN0cmluZy4gV2hlbiBhIHByb3BlcnR5IGlzIGEgbnVtYmVyIHNvbWV0aW1lcyBhbmQgYSBzdHJpbmcgc29tZXRpbWVzLCBpdCBwcmV2ZW50cyB0aGUgY29tcGlsZXIgZnJvbSBsb2NraW5nIGluIHRoZSBkYXRhIHR5cGUsIHNsb3dpbmcgdGhpbmdzIGRvd24gc2xpZ2h0bHkuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fVxuXHRcdFx0cHQuZGF0YSA9IHtzOnMgKyBjfTtcblx0XHRcdHB0LnJ4cCA9IHt9O1xuXHRcdFx0cHQucyA9IHM7XG5cdFx0XHRwdC5jID0gYztcblx0XHRcdHB0LnIgPSByO1xuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBAY29uc3RydWN0b3IgQSBTcGVjaWFsUHJvcCBpcyBiYXNpY2FsbHkgYSBjc3MgcHJvcGVydHkgdGhhdCBuZWVkcyB0byBiZSB0cmVhdGVkIGluIGEgbm9uLXN0YW5kYXJkIHdheSwgbGlrZSBpZiBpdCBtYXkgY29udGFpbiBhIGNvbXBsZXggdmFsdWUgbGlrZSBib3hTaGFkb3c6XCI1cHggMTBweCAxNXB4IHJnYigyNTUsIDEwMiwgNTEpXCIgb3IgaWYgaXQgaXMgYXNzb2NpYXRlZCB3aXRoIGFub3RoZXIgcGx1Z2luIGxpa2UgVGhyb3dQcm9wc1BsdWdpbiBvciBCZXppZXJQbHVnaW4uIEV2ZXJ5IFNwZWNpYWxQcm9wIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgcHJvcGVydHkgbmFtZSBsaWtlIFwiYm94U2hhZG93XCIgb3IgXCJ0aHJvd1Byb3BzXCIgb3IgXCJiZXppZXJcIiBhbmQgaXQgd2lsbCBpbnRlcmNlcHQgdGhvc2UgdmFsdWVzIGluIHRoZSB2YXJzIG9iamVjdCB0aGF0J3MgcGFzc2VkIHRvIHRoZSBDU1NQbHVnaW4gYW5kIGhhbmRsZSB0aGVtIGFjY29yZGluZ2x5LlxuXHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lIChsaWtlIFwiYm94U2hhZG93XCIgb3IgXCJ0aHJvd1Byb3BzXCIpXG5cdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIGFueSBvZiB0aGUgZm9sbG93aW5nIGNvbmZpZ3VyYXRpb24gb3B0aW9uczpcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGRlZmF1bHRWYWx1ZTogdGhlIGRlZmF1bHQgdmFsdWVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIHBhcnNlcjogQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBuYW1lIGlzIGZvdW5kIGluIHRoZSB2YXJzLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBDU1NQcm9wVHdlZW4gaW5zdGFuY2UgYW5kIGl0IHNob3VsZCBlbnN1cmUgdGhhdCBpdCBpcyBwcm9wZXJseSBpbnNlcnRlZCBpbnRvIHRoZSBsaW5rZWQgbGlzdC4gSXQgd2lsbCByZWNlaXZlIDQgcGFyYW10ZXJzOiAxKSBUaGUgdGFyZ2V0LCAyKSBUaGUgdmFsdWUgZGVmaW5lZCBpbiB0aGUgdmFycywgMykgVGhlIENTU1BsdWdpbiBpbnN0YW5jZSAod2hvc2UgX2ZpcnN0UFQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSBsaW5rZWQgbGlzdCksIGFuZCA0KSBBIGNvbXB1dGVkIHN0eWxlIG9iamVjdCBpZiBvbmUgd2FzIGNhbGN1bGF0ZWQgKHRoaXMgaXMgYSBzcGVlZCBvcHRpbWl6YXRpb24gdGhhdCBhbGxvd3MgcmV0cmlldmFsIG9mIHN0YXJ0aW5nIHZhbHVlcyBxdWlja2VyKVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gZm9ybWF0dGVyOiBhIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhbnkgdmFsdWUgcmVjZWl2ZWQgZm9yIHRoaXMgc3BlY2lhbCBwcm9wZXJ0eSAoZm9yIGV4YW1wbGUsIGJveFNoYWRvdyBjb3VsZCB0YWtlIFwiNXB4IDVweCByZWRcIiBhbmQgZm9ybWF0IGl0IHRvIFwiNXB4IDVweCAwcHggMHB4IHJlZFwiIHNvIHRoYXQgYm90aCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIGhhdmUgYSBjb21tb24gb3JkZXIgYW5kIHF1YW50aXR5IG9mIHZhbHVlcy4pXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBwcmVmaXg6IGlmIHRydWUsIHdlJ2xsIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHByb3BlcnR5IHJlcXVpcmVzIGEgdmVuZG9yIHByZWZpeCAobGlrZSBXZWJraXQgb3IgTW96IG9yIG1zIG9yIE8pXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBjb2xvcjogc2V0IHRoaXMgdG8gdHJ1ZSBpZiB0aGUgdmFsdWUgZm9yIHRoaXMgU3BlY2lhbFByb3AgbWF5IGNvbnRhaW4gY29sb3ItcmVsYXRlZCB2YWx1ZXMgbGlrZSByZ2IoKSwgcmdiYSgpLCBldGMuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBwcmlvcml0eTogcHJpb3JpdHkgaW4gdGhlIGxpbmtlZCBsaXN0IG9yZGVyLiBIaWdoZXIgcHJpb3JpdHkgU3BlY2lhbFByb3BzIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy4gVGhlIGRlZmF1bHQgcHJpb3JpdHkgaXMgMC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIG11bHRpOiBpZiB0cnVlLCB0aGUgZm9ybWF0dGVyIHNob3VsZCBhY2NvbW1vZGF0ZSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcywgbGlrZSBib3hTaGFkb3cgY291bGQgaGF2ZSBtdWx0aXBsZSBib3hTaGFkb3dzIGxpc3RlZCBvdXQuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBjb2xsYXBzaWJsZTogaWYgdHJ1ZSwgdGhlIGZvcm1hdHRlciBzaG91bGQgdHJlYXQgdGhlIHZhbHVlIGxpa2UgaXQncyBhIHRvcC9yaWdodC9ib3R0b20vbGVmdCB2YWx1ZSB0aGF0IGNvdWxkIGJlIGNvbGxhcHNlZCwgbGlrZSBcIjVweFwiIHdvdWxkIGFwcGx5IHRvIGFsbCwgXCI1cHgsIDEwcHhcIiB3b3VsZCB1c2UgNXB4IGZvciB0b3AvYm90dG9tIGFuZCAxMHB4IGZvciByaWdodC9sZWZ0LCBldGMuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBrZXl3b3JkOiBhIHNwZWNpYWwga2V5d29yZCB0aGF0IGNhbiBbb3B0aW9uYWxseV0gYmUgZm91bmQgaW5zaWRlIHRoZSB2YWx1ZSAobGlrZSBcImluc2V0XCIgZm9yIGJveFNoYWRvdykuIFRoaXMgYWxsb3dzIHVzIHRvIHZhbGlkYXRlIGJlZ2lubmluZy9lbmRpbmcgdmFsdWVzIHRvIG1ha2Ugc3VyZSB0aGV5IG1hdGNoIChpZiB0aGUga2V5d29yZCBpcyBmb3VuZCBpbiBvbmUsIGl0J2xsIGJlIGFkZGVkIHRvIHRoZSBvdGhlciBmb3IgY29uc2lzdGVuY3kgYnkgZGVmYXVsdCkuXG5cdFx0ICovXG5cdFx0dmFyIFNwZWNpYWxQcm9wID0gZnVuY3Rpb24ocCwgb3B0aW9ucykge1xuXHRcdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdFx0dGhpcy5wID0gb3B0aW9ucy5wcmVmaXggPyBfY2hlY2tQcm9wUHJlZml4KHApIHx8IHAgOiBwO1xuXHRcdFx0XHRfc3BlY2lhbFByb3BzW3BdID0gX3NwZWNpYWxQcm9wc1t0aGlzLnBdID0gdGhpcztcblx0XHRcdFx0dGhpcy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBfZ2V0Rm9ybWF0dGVyKG9wdGlvbnMuZGVmYXVsdFZhbHVlLCBvcHRpb25zLmNvbG9yLCBvcHRpb25zLmNvbGxhcHNpYmxlLCBvcHRpb25zLm11bHRpKTtcblx0XHRcdFx0aWYgKG9wdGlvbnMucGFyc2VyKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXJzZSA9IG9wdGlvbnMucGFyc2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuY2xycyA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRcdHRoaXMubXVsdGkgPSBvcHRpb25zLm11bHRpO1xuXHRcdFx0XHR0aGlzLmtleXdvcmQgPSBvcHRpb25zLmtleXdvcmQ7XG5cdFx0XHRcdHRoaXMuZGZsdCA9IG9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuXHRcdFx0XHR0aGlzLnByID0gb3B0aW9ucy5wcmlvcml0eSB8fCAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9zaG9ydGN1dCBmb3IgY3JlYXRpbmcgYSBuZXcgU3BlY2lhbFByb3AgdGhhdCBjYW4gYWNjZXB0IG11bHRpcGxlIHByb3BlcnRpZXMgYXMgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCAoaGVscHMgbWluaWZpY2F0aW9uKS4gZGZsdCBjYW4gYmUgYW4gYXJyYXkgZm9yIG11bHRpcGxlIHZhbHVlcyAod2UgZG9uJ3QgZG8gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBiZWNhdXNlIHRoZSBkZWZhdWx0IHZhbHVlIG1heSBjb250YWluIGNvbW1hcywgbGlrZSByZWN0KDBweCwwcHgsMHB4LDBweCkpLiBXZSBhdHRhY2ggdGhpcyBtZXRob2QgdG8gdGhlIFNwZWNpYWxQcm9wIGNsYXNzL29iamVjdCBpbnN0ZWFkIG9mIHVzaW5nIGEgcHJpdmF0ZSBfY3JlYXRlU3BlY2lhbFByb3AoKSBtZXRob2Qgc28gdGhhdCB3ZSBjYW4gdGFwIGludG8gaXQgZXh0ZXJuYWxseSBpZiBuZWNlc3NhcnksIGxpa2UgZnJvbSBhbm90aGVyIHBsdWdpbi5cblx0XHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcCA9IF9pbnRlcm5hbHMuX3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wID0gZnVuY3Rpb24ocCwgb3B0aW9ucywgZGVmYXVsdHMpIHtcblx0XHRcdFx0aWYgKHR5cGVvZihvcHRpb25zKSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHRcdG9wdGlvbnMgPSB7cGFyc2VyOmRlZmF1bHRzfTsgLy90byBtYWtlIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgQmV6aWVyUGx1Z2luIGFuZCBUaHJvd1Byb3BzUGx1Z2luXG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGEgPSBwLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRkID0gb3B0aW9ucy5kZWZhdWx0VmFsdWUsXG5cdFx0XHRcdFx0aSwgdGVtcDtcblx0XHRcdFx0ZGVmYXVsdHMgPSBkZWZhdWx0cyB8fCBbZF07XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5wcmVmaXggPSAoaSA9PT0gMCAmJiBvcHRpb25zLnByZWZpeCk7XG5cdFx0XHRcdFx0b3B0aW9ucy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0c1tpXSB8fCBkO1xuXHRcdFx0XHRcdHRlbXAgPSBuZXcgU3BlY2lhbFByb3AoYVtpXSwgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vY3JlYXRlcyBhIHBsYWNlaG9sZGVyIHNwZWNpYWwgcHJvcCBmb3IgYSBwbHVnaW4gc28gdGhhdCB0aGUgcHJvcGVydHkgZ2V0cyBjYXVnaHQgdGhlIGZpcnN0IHRpbWUgYSB0d2VlbiBvZiBpdCBpcyBhdHRlbXB0ZWQsIGFuZCBhdCB0aGF0IHRpbWUgaXQgbWFrZXMgdGhlIHBsdWdpbiByZWdpc3RlciBpdHNlbGYsIHRodXMgdGFraW5nIG92ZXIgZm9yIGFsbCBmdXR1cmUgdHdlZW5zIG9mIHRoYXQgcHJvcGVydHkuIFRoaXMgYWxsb3dzIHVzIHRvIG5vdCBtYW5kYXRlIHRoYXQgdGhpbmdzIGxvYWQgaW4gYSBwYXJ0aWN1bGFyIG9yZGVyIGFuZCBpdCBhbHNvIGFsbG93cyB1cyB0byBsb2coKSBhbiBlcnJvciB0aGF0IGluZm9ybXMgdGhlIHVzZXIgd2hlbiB0aGV5IGF0dGVtcHQgdG8gdHdlZW4gYW4gZXh0ZXJuYWwgcGx1Z2luLXJlbGF0ZWQgcHJvcGVydHkgd2l0aG91dCBsb2FkaW5nIGl0cyAuanMgZmlsZS5cblx0XHRcdF9yZWdpc3RlclBsdWdpblByb3AgPSBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmICghX3NwZWNpYWxQcm9wc1twXSkge1xuXHRcdFx0XHRcdHZhciBwbHVnaW5OYW1lID0gcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHAuc3Vic3RyKDEpICsgXCJQbHVnaW5cIjtcblx0XHRcdFx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AocCwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRcdFx0XHR2YXIgcGx1Z2luQ2xhc3MgPSBfZ2xvYmFscy5jb20uZ3JlZW5zb2NrLnBsdWdpbnNbcGx1Z2luTmFtZV07XG5cdFx0XHRcdFx0XHRpZiAoIXBsdWdpbkNsYXNzKSB7XG5cdFx0XHRcdFx0XHRcdF9sb2coXCJFcnJvcjogXCIgKyBwbHVnaW5OYW1lICsgXCIganMgZmlsZSBub3QgbG9hZGVkLlwiKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGx1Z2luQ2xhc3MuX2Nzc1JlZ2lzdGVyKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gX3NwZWNpYWxQcm9wc1twXS5wYXJzZSh0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKTtcblx0XHRcdFx0XHR9fSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblxuXHRcdHAgPSBTcGVjaWFsUHJvcC5wcm90b3R5cGU7XG5cblx0XHQvKipcblx0XHQgKiBBbGlhcyBmb3IgX3BhcnNlQ29tcGxleCgpIHRoYXQgYXV0b21hdGljYWxseSBwbHVncyBpbiBjZXJ0YWluIHZhbHVlcyBmb3IgdGhpcyBTcGVjaWFsUHJvcCwgbGlrZSBpdHMgcHJvcGVydHkgbmFtZSwgd2hldGhlciBvciBub3QgY29sb3JzIHNob3VsZCBiZSBzZW5zZWQsIHRoZSBkZWZhdWx0IHZhbHVlLCBhbmQgcHJpb3JpdHkuIEl0IGFsc28gbG9va3MgZm9yIGFueSBrZXl3b3JkIHRoYXQgdGhlIFNwZWNpYWxQcm9wIGRlZmluZXMgKGxpa2UgXCJpbnNldFwiIGZvciBib3hTaGFkb3cpIGFuZCBlbnN1cmVzIHRoYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiB2YWx1ZXMgZm9yIFNwZWNpYWxQcm9wcyB3aGVyZSBtdWx0aSBpcyB0cnVlIChsaWtlIGJveFNoYWRvdyBhbmQgdGV4dFNoYWRvdyBjYW4gaGF2ZSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0KVxuXHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgZWxlbWVudFxuXHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXJ8b2JqZWN0KX0gYiBiZWdpbm5pbmcgdmFsdWVcblx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfG9iamVjdCl9IGUgZW5kaW5nIChkZXN0aW5hdGlvbikgdmFsdWVcblx0XHQgKiBAcGFyYW0ge0NTU1Byb3BUd2Vlbj19IHB0IG5leHQgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdCAqIEBwYXJhbSB7VHdlZW5QbHVnaW49fSBwbHVnaW4gSWYgYW5vdGhlciBwbHVnaW4gd2lsbCBiZSB0d2VlbmluZyB0aGUgY29tcGxleCB2YWx1ZSwgdGhhdCBUd2VlblBsdWdpbiBpbnN0YW5jZSBnb2VzIGhlcmUuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj19IHNldFJhdGlvIElmIGEgY3VzdG9tIHNldFJhdGlvKCkgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGhhbmRsZSB0aGlzIGNvbXBsZXggdmFsdWUsIHRoYXQgZ29lcyBoZXJlLlxuXHRcdCAqIEByZXR1cm4ge0NTU1Byb3BUd2Vlbj19IEZpcnN0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHQgKi9cblx0XHRwLnBhcnNlQ29tcGxleCA9IGZ1bmN0aW9uKHQsIGIsIGUsIHB0LCBwbHVnaW4sIHNldFJhdGlvKSB7XG5cdFx0XHR2YXIga3dkID0gdGhpcy5rZXl3b3JkLFxuXHRcdFx0XHRpLCBiYSwgZWEsIGwsIGJpLCBlaTtcblx0XHRcdC8vaWYgdGhpcyBTcGVjaWFsUHJvcCdzIHZhbHVlIGNhbiBjb250YWluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzIChsaWtlIGJveFNoYWRvdyBvciB0ZXh0U2hhZG93KSwgd2UgbXVzdCBwYXJzZSB0aGVtIGluIGEgc3BlY2lhbCB3YXksIGFuZCBsb29rIGZvciBhIGtleXdvcmQgKGxpa2UgXCJpbnNldFwiIGZvciBib3hTaGFkb3cpIGFuZCBlbnN1cmUgdGhhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgQk9USCBoYXZlIGl0IGlmIHRoZSBlbmQgZGVmaW5lcyBpdCBhcyBzdWNoLiBXZSBhbHNvIG11c3QgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIGFuIGVxdWFsIG51bWJlciBvZiB2YWx1ZXMgc3BlY2lmaWVkICh3ZSBjYW4ndCB0d2VlbiAxIGJveFNoYWRvdyB0byAzIGZvciBleGFtcGxlKVxuXHRcdFx0aWYgKHRoaXMubXVsdGkpIGlmIChfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QoZSkgfHwgX2NvbW1hc091dHNpZGVQYXJlbkV4cC50ZXN0KGIpKSB7XG5cdFx0XHRcdGJhID0gYi5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwifFwiKS5zcGxpdChcInxcIik7XG5cdFx0XHRcdGVhID0gZS5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwifFwiKS5zcGxpdChcInxcIik7XG5cdFx0XHR9IGVsc2UgaWYgKGt3ZCkge1xuXHRcdFx0XHRiYSA9IFtiXTtcblx0XHRcdFx0ZWEgPSBbZV07XG5cdFx0XHR9XG5cdFx0XHRpZiAoZWEpIHtcblx0XHRcdFx0bCA9IChlYS5sZW5ndGggPiBiYS5sZW5ndGgpID8gZWEubGVuZ3RoIDogYmEubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0YiA9IGJhW2ldID0gYmFbaV0gfHwgdGhpcy5kZmx0O1xuXHRcdFx0XHRcdGUgPSBlYVtpXSA9IGVhW2ldIHx8IHRoaXMuZGZsdDtcblx0XHRcdFx0XHRpZiAoa3dkKSB7XG5cdFx0XHRcdFx0XHRiaSA9IGIuaW5kZXhPZihrd2QpO1xuXHRcdFx0XHRcdFx0ZWkgPSBlLmluZGV4T2Yoa3dkKTtcblx0XHRcdFx0XHRcdGlmIChiaSAhPT0gZWkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGVpID09PSAtMSkgeyAvL2lmIHRoZSBrZXl3b3JkIGlzbid0IGluIHRoZSBlbmQgdmFsdWUsIHJlbW92ZSBpdCBmcm9tIHRoZSBiZWdpbm5pbmcgb25lLlxuXHRcdFx0XHRcdFx0XHRcdGJhW2ldID0gYmFbaV0uc3BsaXQoa3dkKS5qb2luKFwiXCIpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGJpID09PSAtMSkgeyAvL2lmIHRoZSBrZXl3b3JkIGlzbid0IGluIHRoZSBiZWdpbm5pbmcsIGFkZCBpdC5cblx0XHRcdFx0XHRcdFx0XHRiYVtpXSArPSBcIiBcIiArIGt3ZDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRiID0gYmEuam9pbihcIiwgXCIpO1xuXHRcdFx0XHRlID0gZWEuam9pbihcIiwgXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIF9wYXJzZUNvbXBsZXgodCwgdGhpcy5wLCBiLCBlLCB0aGlzLmNscnMsIHRoaXMuZGZsdCwgcHQsIHRoaXMucHIsIHBsdWdpbiwgc2V0UmF0aW8pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBBY2NlcHRzIGEgdGFyZ2V0IGFuZCBlbmQgdmFsdWUgYW5kIHNwaXRzIGJhY2sgYSBDU1NQcm9wVHdlZW4gdGhhdCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBDU1NQbHVnaW4ncyBsaW5rZWQgbGlzdCBhbmQgY29uZm9ybXMgd2l0aCBhbGwgdGhlIGNvbnZlbnRpb25zIHdlIHVzZSBpbnRlcm5hbGx5LCBsaWtlIHR5cGU6LTEsIDAsIDEsIG9yIDIsIHNldHRpbmcgdXAgYW55IGV4dHJhIHByb3BlcnR5IHR3ZWVucywgcHJpb3JpdHksIGV0Yy4gRm9yIGV4YW1wbGUsIGlmIHdlIGhhdmUgYSBib3hTaGFkb3cgU3BlY2lhbFByb3AgYW5kIGNhbGw6XG5cdFx0ICogdGhpcy5fZmlyc3RQVCA9IHNwLnBhcnNlKGVsZW1lbnQsIFwiNXB4IDEwcHggMjBweCByZ2IoMjU1MCwxMDIsNTEpXCIsIFwiYm94U2hhZG93XCIsIHRoaXMpO1xuXHRcdCAqIEl0IHNob3VsZCBmaWd1cmUgb3V0IHRoZSBzdGFydGluZyB2YWx1ZSBvZiB0aGUgZWxlbWVudCdzIGJveFNoYWRvdywgY29tcGFyZSBpdCB0byB0aGUgcHJvdmlkZWQgZW5kIHZhbHVlIGFuZCBjcmVhdGUgYWxsIHRoZSBuZWNlc3NhcnkgQ1NTUHJvcFR3ZWVucyBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZXMgdG8gdHdlZW4gdGhlIGJveFNoYWRvdy4gVGhlIENTU1Byb3BUd2VlbiB0aGF0IGdldHMgc3BpdCBiYWNrIHNob3VsZCBhbHJlYWR5IGJlIGluc2VydGVkIGludG8gdGhlIGxpbmtlZCBsaXN0ICh0aGUgNHRoIHBhcmFtZXRlciBpcyB0aGUgY3VycmVudCBoZWFkLCBzbyBwcmVwZW5kIHRvIHRoYXQpLlxuXHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnR5IGlzIGJlaW5nIHR3ZWVuZWRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZSBFbmQgdmFsdWUgYXMgcHJvdmlkZWQgaW4gdGhlIHZhcnMgb2JqZWN0ICh0eXBpY2FsbHkgYSBzdHJpbmcsIGJ1dCBub3QgYWx3YXlzIC0gbGlrZSBhIHRocm93UHJvcHMgd291bGQgYmUgYW4gb2JqZWN0KS5cblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZVxuXHRcdCAqIEBwYXJhbSB7IUNTU1BsdWdpbn0gY3NzcCBUaGUgQ1NTUGx1Z2luIGluc3RhbmNlIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHR3ZWVuLlxuXHRcdCAqIEBwYXJhbSB7P0NTU1Byb3BUd2Vlbn0gcHQgVGhlIENTU1Byb3BUd2VlbiB0aGF0IGlzIHRoZSBjdXJyZW50IGhlYWQgb2YgdGhlIGxpbmtlZCBsaXN0ICh3ZSdsbCBwcmVwZW5kIHRvIGl0KVxuXHRcdCAqIEBwYXJhbSB7VHdlZW5QbHVnaW49fSBwbHVnaW4gSWYgYSBwbHVnaW4gd2lsbCBiZSB1c2VkIHRvIHR3ZWVuIHRoZSBwYXJzZWQgdmFsdWUsIHRoaXMgaXMgdGhlIHBsdWdpbiBpbnN0YW5jZS5cblx0XHQgKiBAcGFyYW0ge09iamVjdD19IHZhcnMgT3JpZ2luYWwgdmFycyBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgZGF0YSBmb3IgcGFyc2luZy5cblx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW59IFRoZSBmaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0IHdoaWNoIGluY2x1ZGVzIHRoZSBuZXcgb25lKHMpIGFkZGVkIGJ5IHRoZSBwYXJzZSgpIGNhbGwuXG5cdFx0ICovXG5cdFx0cC5wYXJzZSA9IGZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLCB0aGlzLmZvcm1hdChfZ2V0U3R5bGUodCwgdGhpcy5wLCBfY3MsIGZhbHNlLCB0aGlzLmRmbHQpKSwgdGhpcy5mb3JtYXQoZSksIHB0LCBwbHVnaW4pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZWdpc3RlcnMgYSBzcGVjaWFsIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIGludGVyY2VwdGVkIGZyb20gYW55IFwiY3NzXCIgb2JqZWN0cyBkZWZpbmVkIGluIHR3ZWVucy4gVGhpcyBhbGxvd3MgeW91IHRvIGhhbmRsZSB0aGVtIGhvd2V2ZXIgeW91IHdhbnQgd2l0aG91dCBDU1NQbHVnaW4gZG9pbmcgaXQgZm9yIHlvdS4gVGhlIDJuZCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIDMgcGFyYW1ldGVyczpcblx0XHQgKiAgMSkgVGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBzaG91bGQgYmUgdHdlZW5lZCAodHlwaWNhbGx5IGEgRE9NIGVsZW1lbnQpXG5cdFx0ICogIDIpIFRoZSBlbmQvZGVzdGluYXRpb24gdmFsdWUgKGNvdWxkIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9iamVjdCwgb3Igd2hhdGV2ZXIgeW91IHdhbnQpXG5cdFx0ICogIDMpIFRoZSB0d2VlbiBpbnN0YW5jZSAoeW91IHByb2JhYmx5IGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhpcywgYnV0IGl0IGNhbiBiZSB1c2VmdWwgZm9yIGxvb2tpbmcgdXAgaW5mb3JtYXRpb24gbGlrZSB0aGUgZHVyYXRpb24pXG5cdFx0ICpcblx0XHQgKiBUaGVuLCB5b3VyIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBlYWNoIHRpbWUgdGhlIHR3ZWVuIGdldHMgcmVuZGVyZWQsIHBhc3NpbmcgYSBudW1lcmljIFwicmF0aW9cIiBwYXJhbWV0ZXIgdG8geW91ciBmdW5jdGlvbiB0aGF0IGluZGljYXRlcyB0aGUgY2hhbmdlIGZhY3RvciAodXN1YWxseSBiZXR3ZWVuIDAgYW5kIDEpLiBGb3IgZXhhbXBsZTpcblx0XHQgKlxuXHRcdCAqIENTU1BsdWdpbi5yZWdpc3RlclNwZWNpYWxQcm9wKFwibXlDdXN0b21Qcm9wXCIsIGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG5cdFx0ICogICAgICB2YXIgc3RhcnQgPSB0YXJnZXQuc3R5bGUud2lkdGg7XG5cdFx0ICogICAgICByZXR1cm4gZnVuY3Rpb24ocmF0aW8pIHtcblx0XHQgKiAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLndpZHRoID0gKHN0YXJ0ICsgdmFsdWUgKiByYXRpbykgKyBcInB4XCI7XG5cdFx0ICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2V0IHdpZHRoIHRvIFwiICsgdGFyZ2V0LnN0eWxlLndpZHRoKTtcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogfSwgMCk7XG5cdFx0ICpcblx0XHQgKiBUaGVuLCB3aGVuIEkgZG8gdGhpcyB0d2VlbiwgaXQgd2lsbCB0cmlnZ2VyIG15IHNwZWNpYWwgcHJvcGVydHk6XG5cdFx0ICpcblx0XHQgKiBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7bXlDdXN0b21Qcm9wOjEwMH19KTtcblx0XHQgKlxuXHRcdCAqIEluIHRoZSBleGFtcGxlLCBvZiBjb3Vyc2UsIHdlJ3JlIGp1c3QgY2hhbmdpbmcgdGhlIHdpZHRoLCBidXQgeW91IGNhbiBkbyBhbnl0aGluZyB5b3Ugd2FudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIChvciBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcykgdGhhdCBzaG91bGQgYmUgaW50ZXJjZXB0ZWQgYW5kIGhhbmRsZWQgYnkgeW91ciBmdW5jdGlvbi4gRm9yIGV4YW1wbGUsIGlmIEkgZGVmaW5lIFwibXlDdXN0b21Qcm9wXCIsIHRoZW4gaXQgd291bGQgaGFuZGxlIHRoYXQgcG9ydGlvbiBvZiB0aGUgZm9sbG93aW5nIHR3ZWVuOiBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7bXlDdXN0b21Qcm9wOjEwMH19KVxuXHRcdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKE9iamVjdCwgT2JqZWN0LCBPYmplY3QsIHN0cmluZyk6ZnVuY3Rpb24obnVtYmVyKX0gb25Jbml0VHdlZW4gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHR3ZWVuIG9mIHRoaXMgc3BlY2lhbCBwcm9wZXJ0eSBpcyBwZXJmb3JtZWQuIFRoZSBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgNCBwYXJhbWV0ZXJzOiAxKSBUYXJnZXQgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHR3ZWVuZWQsIDIpIFZhbHVlIHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgdHdlZW4sIDMpIFRoZSB0d2VlbiBpbnN0YW5jZSBpdHNlbGYgKHJhcmVseSB1c2VkKSwgYW5kIDQpIFRoZSBwcm9wZXJ0eSBuYW1lIHRoYXQncyBiZWluZyB0d2VlbmVkLiBZb3VyIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgb24gZXZlcnkgdXBkYXRlIG9mIHRoZSB0d2Vlbi4gVGhhdCBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgYSBzaW5nbGUgcGFyYW1ldGVyIHRoYXQgaXMgYSBcImNoYW5nZSBmYWN0b3JcIiB2YWx1ZSAodHlwaWNhbGx5IGJldHdlZW4gMCBhbmQgMSkgaW5kaWNhdGluZyB0aGUgYW1vdW50IG9mIGNoYW5nZSBhcyBhIHJhdGlvLiBZb3UgY2FuIHVzZSB0aGlzIHRvIGRldGVybWluZSBob3cgdG8gc2V0IHRoZSB2YWx1ZXMgYXBwcm9wcmlhdGVseSBpbiB5b3VyIGZ1bmN0aW9uLlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gcHJpb3JpdHkgUHJpb3JpdHkgdGhhdCBoZWxwcyB0aGUgZW5naW5lIGRldGVybWluZSB0aGUgb3JkZXIgaW4gd2hpY2ggdG8gc2V0IHRoZSBwcm9wZXJ0aWVzIChkZWZhdWx0OiAwKS4gSGlnaGVyIHByaW9yaXR5IHByb3BlcnRpZXMgd2lsbCBiZSB1cGRhdGVkIGJlZm9yZSBsb3dlciBwcmlvcml0eSBvbmVzLlxuXHRcdCAqL1xuXHRcdENTU1BsdWdpbi5yZWdpc3RlclNwZWNpYWxQcm9wID0gZnVuY3Rpb24obmFtZSwgb25Jbml0VHdlZW4sIHByaW9yaXR5KSB7XG5cdFx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AobmFtZSwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRcdHZhciBydiA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgcHQsIDIsIHAsIGZhbHNlLCBwcmlvcml0eSk7XG5cdFx0XHRcdHJ2LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0cnYuc2V0UmF0aW8gPSBvbkluaXRUd2Vlbih0LCBlLCBjc3NwLl90d2VlbiwgcCk7XG5cdFx0XHRcdHJldHVybiBydjtcblx0XHRcdH0sIHByaW9yaXR5OnByaW9yaXR5fSk7XG5cdFx0fTtcblxuXG5cblxuXG5cblx0XHQvL3RyYW5zZm9ybS1yZWxhdGVkIG1ldGhvZHMgYW5kIHByb3BlcnRpZXNcblx0XHRDU1NQbHVnaW4udXNlU1ZHVHJhbnNmb3JtQXR0ciA9IF9pc1NhZmFyaSB8fCBfaXNGaXJlZm94OyAvL1NhZmFyaSBhbmQgRmlyZWZveCBib3RoIGhhdmUgc29tZSByZW5kZXJpbmcgYnVncyB3aGVuIGFwcGx5aW5nIENTUyB0cmFuc2Zvcm1zIHRvIFNWRyBlbGVtZW50cywgc28gZGVmYXVsdCB0byB1c2luZyB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUgaW5zdGVhZCAodXNlcnMgY2FuIG92ZXJyaWRlIHRoaXMpLlxuXHRcdHZhciBfdHJhbnNmb3JtUHJvcHMgPSAoXCJzY2FsZVgsc2NhbGVZLHNjYWxlWix4LHkseixza2V3WCxza2V3WSxyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHBlcnNwZWN0aXZlLHhQZXJjZW50LHlQZXJjZW50XCIpLnNwbGl0KFwiLFwiKSxcblx0XHRcdF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChcInRyYW5zZm9ybVwiKSwgLy90aGUgSmF2YXNjcmlwdCAoY2FtZWxDYXNlKSB0cmFuc2Zvcm0gcHJvcGVydHksIGxpa2UgbXNUcmFuc2Zvcm0sIFdlYmtpdFRyYW5zZm9ybSwgTW96VHJhbnNmb3JtLCBvciBPVHJhbnNmb3JtLlxuXHRcdFx0X3RyYW5zZm9ybVByb3BDU1MgPSBfcHJlZml4Q1NTICsgXCJ0cmFuc2Zvcm1cIixcblx0XHRcdF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChcInRyYW5zZm9ybU9yaWdpblwiKSxcblx0XHRcdF9zdXBwb3J0czNEID0gKF9jaGVja1Byb3BQcmVmaXgoXCJwZXJzcGVjdGl2ZVwiKSAhPT0gbnVsbCksXG5cdFx0XHRUcmFuc2Zvcm0gPSBfaW50ZXJuYWxzLlRyYW5zZm9ybSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBlcnNwZWN0aXZlID0gcGFyc2VGbG9hdChDU1NQbHVnaW4uZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlKSB8fCAwO1xuXHRcdFx0XHR0aGlzLmZvcmNlM0QgPSAoQ1NTUGx1Z2luLmRlZmF1bHRGb3JjZTNEID09PSBmYWxzZSB8fCAhX3N1cHBvcnRzM0QpID8gZmFsc2UgOiBDU1NQbHVnaW4uZGVmYXVsdEZvcmNlM0QgfHwgXCJhdXRvXCI7XG5cdFx0XHR9LFxuXHRcdFx0X1NWR0VsZW1lbnQgPSB3aW5kb3cuU1ZHRWxlbWVudCxcblx0XHRcdF91c2VTVkdUcmFuc2Zvcm1BdHRyLFxuXHRcdFx0Ly9Tb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3ggYW5kIElFKSBkb24ndCBob25vciB0cmFuc2Zvcm0tb3JpZ2luIHByb3Blcmx5IGluIFNWRyBlbGVtZW50cywgc28gd2UgbmVlZCB0byBtYW51YWxseSBhZGp1c3QgdGhlIG1hdHJpeCBhY2NvcmRpbmdseS4gV2UgZmVhdHVyZSBkZXRlY3QgaGVyZSByYXRoZXIgdGhhbiBhbHdheXMgZG9pbmcgdGhlIGNvbnZlcnNpb24gZm9yIGNlcnRhaW4gYnJvd3NlcnMgYmVjYXVzZSB0aGV5IG1heSBmaXggdGhlIHByb2JsZW0gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuXG5cdFx0XHRfY3JlYXRlU1ZHID0gZnVuY3Rpb24odHlwZSwgY29udGFpbmVyLCBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gX2RvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB0eXBlKSxcblx0XHRcdFx0XHRyZWcgPSAvKFthLXpdKShbQS1aXSkvZyxcblx0XHRcdFx0XHRwO1xuXHRcdFx0XHRmb3IgKHAgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgcC5yZXBsYWNlKHJlZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpLCBhdHRyaWJ1dGVzW3BdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdFx0fSxcblx0XHRcdF9kb2NFbGVtZW50ID0gX2RvYy5kb2N1bWVudEVsZW1lbnQsXG5cdFx0XHRfZm9yY2VTVkdUcmFuc2Zvcm1BdHRyID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvL0lFIGFuZCBBbmRyb2lkIHN0b2NrIGRvbid0IHN1cHBvcnQgQ1NTIHRyYW5zZm9ybXMgb24gU1ZHIGVsZW1lbnRzLCBzbyB3ZSBtdXN0IHdyaXRlIHRoZW0gdG8gdGhlIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLiBXZSBwb3B1bGF0ZSB0aGlzIHZhcmlhYmxlIGluIHRoZSBfcGFyc2VUcmFuc2Zvcm0oKSBtZXRob2QsIGFuZCBvbmx5IGlmL3doZW4gd2UgY29tZSBhY3Jvc3MgYW4gU1ZHIGVsZW1lbnRcblx0XHRcdFx0dmFyIGZvcmNlID0gX2llVmVycyB8fCAoL0FuZHJvaWQvaS50ZXN0KF9hZ2VudCkgJiYgIXdpbmRvdy5jaHJvbWUpLFxuXHRcdFx0XHRcdHN2ZywgcmVjdCwgd2lkdGg7XG5cdFx0XHRcdGlmIChfZG9jLmNyZWF0ZUVsZW1lbnROUyAmJiAhZm9yY2UpIHsgLy9JRTggYW5kIGVhcmxpZXIgZG9lc24ndCBzdXBwb3J0IFNWRyBhbnl3YXlcblx0XHRcdFx0XHRzdmcgPSBfY3JlYXRlU1ZHKFwic3ZnXCIsIF9kb2NFbGVtZW50KTtcblx0XHRcdFx0XHRyZWN0ID0gX2NyZWF0ZVNWRyhcInJlY3RcIiwgc3ZnLCB7d2lkdGg6MTAwLCBoZWlnaHQ6NTAsIHg6MTAwfSk7XG5cdFx0XHRcdFx0d2lkdGggPSByZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXHRcdFx0XHRcdHJlY3Quc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gXCI1MCUgNTAlXCI7XG5cdFx0XHRcdFx0cmVjdC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBcInNjYWxlWCgwLjUpXCI7XG5cdFx0XHRcdFx0Zm9yY2UgPSAod2lkdGggPT09IHJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggJiYgIShfaXNGaXJlZm94ICYmIF9zdXBwb3J0czNEKSk7IC8vbm90ZTogRmlyZWZveCBmYWlscyB0aGUgdGVzdCBldmVuIHRob3VnaCBpdCBkb2VzIHN1cHBvcnQgQ1NTIHRyYW5zZm9ybXMgaW4gM0QuIFNpbmNlIHdlIGNhbid0IHB1c2ggM0Qgc3R1ZmYgaW50byB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSwgd2UgZm9yY2UgRmlyZWZveCB0byBwYXNzIHRoZSB0ZXN0IGhlcmUgKGFzIGxvbmcgYXMgaXQgZG9lcyB0cnVseSBzdXBwb3J0IDNEKS5cblx0XHRcdFx0XHRfZG9jRWxlbWVudC5yZW1vdmVDaGlsZChzdmcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmb3JjZTtcblx0XHRcdH0pKCksXG5cdFx0XHRfcGFyc2VTVkdPcmlnaW4gPSBmdW5jdGlvbihlLCBsb2NhbCwgZGVjb3JhdGVlLCBhYnNvbHV0ZSwgc21vb3RoT3JpZ2luLCBza2lwUmVjb3JkKSB7XG5cdFx0XHRcdHZhciB0bSA9IGUuX2dzVHJhbnNmb3JtLFxuXHRcdFx0XHRcdG0gPSBfZ2V0TWF0cml4KGUsIHRydWUpLFxuXHRcdFx0XHRcdHYsIHgsIHksIHhPcmlnaW4sIHlPcmlnaW4sIGEsIGIsIGMsIGQsIHR4LCB0eSwgZGV0ZXJtaW5hbnQsIHhPcmlnaW5PbGQsIHlPcmlnaW5PbGQ7XG5cdFx0XHRcdGlmICh0bSkge1xuXHRcdFx0XHRcdHhPcmlnaW5PbGQgPSB0bS54T3JpZ2luOyAvL3JlY29yZCB0aGUgb3JpZ2luYWwgdmFsdWVzIGJlZm9yZSB3ZSBhbHRlciB0aGVtLlxuXHRcdFx0XHRcdHlPcmlnaW5PbGQgPSB0bS55T3JpZ2luO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYWJzb2x1dGUgfHwgKHYgPSBhYnNvbHV0ZS5zcGxpdChcIiBcIikpLmxlbmd0aCA8IDIpIHtcblx0XHRcdFx0XHRiID0gZS5nZXRCQm94KCk7XG5cdFx0XHRcdFx0bG9jYWwgPSBfcGFyc2VQb3NpdGlvbihsb2NhbCkuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdHYgPSBbKGxvY2FsWzBdLmluZGV4T2YoXCIlXCIpICE9PSAtMSA/IHBhcnNlRmxvYXQobG9jYWxbMF0pIC8gMTAwICogYi53aWR0aCA6IHBhcnNlRmxvYXQobG9jYWxbMF0pKSArIGIueCxcblx0XHRcdFx0XHRcdCAobG9jYWxbMV0uaW5kZXhPZihcIiVcIikgIT09IC0xID8gcGFyc2VGbG9hdChsb2NhbFsxXSkgLyAxMDAgKiBiLmhlaWdodCA6IHBhcnNlRmxvYXQobG9jYWxbMV0pKSArIGIueV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVjb3JhdGVlLnhPcmlnaW4gPSB4T3JpZ2luID0gcGFyc2VGbG9hdCh2WzBdKTtcblx0XHRcdFx0ZGVjb3JhdGVlLnlPcmlnaW4gPSB5T3JpZ2luID0gcGFyc2VGbG9hdCh2WzFdKTtcblx0XHRcdFx0aWYgKGFic29sdXRlICYmIG0gIT09IF9pZGVudGl0eTJETWF0cml4KSB7IC8vaWYgc3ZnT3JpZ2luIGlzIGJlaW5nIHNldCwgd2UgbXVzdCBpbnZlcnQgdGhlIG1hdHJpeCBhbmQgZGV0ZXJtaW5lIHdoZXJlIHRoZSBhYnNvbHV0ZSBwb2ludCBpcywgZmFjdG9yaW5nIGluIHRoZSBjdXJyZW50IHRyYW5zZm9ybXMuIE90aGVyd2lzZSwgdGhlIHN2Z09yaWdpbiB3b3VsZCBiZSBiYXNlZCBvbiB0aGUgZWxlbWVudCdzIG5vbi10cmFuc2Zvcm1lZCBwb3NpdGlvbiBvbiB0aGUgY2FudmFzLlxuXHRcdFx0XHRcdGEgPSBtWzBdO1xuXHRcdFx0XHRcdGIgPSBtWzFdO1xuXHRcdFx0XHRcdGMgPSBtWzJdO1xuXHRcdFx0XHRcdGQgPSBtWzNdO1xuXHRcdFx0XHRcdHR4ID0gbVs0XTtcblx0XHRcdFx0XHR0eSA9IG1bNV07XG5cdFx0XHRcdFx0ZGV0ZXJtaW5hbnQgPSAoYSAqIGQgLSBiICogYyk7XG5cdFx0XHRcdFx0eCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoKGMgKiB0eSAtIGQgKiB0eCkgLyBkZXRlcm1pbmFudCk7XG5cdFx0XHRcdFx0eSA9IHhPcmlnaW4gKiAoLWIgLyBkZXRlcm1pbmFudCkgKyB5T3JpZ2luICogKGEgLyBkZXRlcm1pbmFudCkgLSAoKGEgKiB0eSAtIGIgKiB0eCkgLyBkZXRlcm1pbmFudCk7XG5cdFx0XHRcdFx0eE9yaWdpbiA9IGRlY29yYXRlZS54T3JpZ2luID0gdlswXSA9IHg7XG5cdFx0XHRcdFx0eU9yaWdpbiA9IGRlY29yYXRlZS55T3JpZ2luID0gdlsxXSA9IHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRtKSB7IC8vYXZvaWQganVtcCB3aGVuIHRyYW5zZm9ybU9yaWdpbiBpcyBjaGFuZ2VkIC0gYWRqdXN0IHRoZSB4L3kgdmFsdWVzIGFjY29yZGluZ2x5XG5cdFx0XHRcdFx0aWYgKHNraXBSZWNvcmQpIHtcblx0XHRcdFx0XHRcdGRlY29yYXRlZS54T2Zmc2V0ID0gdG0ueE9mZnNldDtcblx0XHRcdFx0XHRcdGRlY29yYXRlZS55T2Zmc2V0ID0gdG0ueU9mZnNldDtcblx0XHRcdFx0XHRcdHRtID0gZGVjb3JhdGVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc21vb3RoT3JpZ2luIHx8IChzbW9vdGhPcmlnaW4gIT09IGZhbHNlICYmIENTU1BsdWdpbi5kZWZhdWx0U21vb3RoT3JpZ2luICE9PSBmYWxzZSkpIHtcblx0XHRcdFx0XHRcdHggPSB4T3JpZ2luIC0geE9yaWdpbk9sZDtcblx0XHRcdFx0XHRcdHkgPSB5T3JpZ2luIC0geU9yaWdpbk9sZDtcblx0XHRcdFx0XHRcdC8vb3JpZ2luYWxseSwgd2Ugc2ltcGx5IGFkanVzdGVkIHRoZSB4IGFuZCB5IHZhbHVlcywgYnV0IHRoYXQgd291bGQgY2F1c2UgcHJvYmxlbXMgaWYsIGZvciBleGFtcGxlLCB5b3UgY3JlYXRlZCBhIHJvdGF0aW9uYWwgdHdlZW4gcGFydC13YXkgdGhyb3VnaCBhbiB4L3kgdHdlZW4uIE1hbmFnaW5nIHRoZSBvZmZzZXQgaW4gYSBzZXBhcmF0ZSB2YXJpYWJsZSBnaXZlcyB1cyB1bHRpbWF0ZSBmbGV4aWJpbGl0eS5cblx0XHRcdFx0XHRcdC8vdG0ueCAtPSB4IC0gKHggKiBtWzBdICsgeSAqIG1bMl0pO1xuXHRcdFx0XHRcdFx0Ly90bS55IC09IHkgLSAoeCAqIG1bMV0gKyB5ICogbVszXSk7XG5cdFx0XHRcdFx0XHR0bS54T2Zmc2V0ICs9ICh4ICogbVswXSArIHkgKiBtWzJdKSAtIHg7XG5cdFx0XHRcdFx0XHR0bS55T2Zmc2V0ICs9ICh4ICogbVsxXSArIHkgKiBtWzNdKSAtIHk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRtLnhPZmZzZXQgPSB0bS55T2Zmc2V0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFza2lwUmVjb3JkKSB7XG5cdFx0XHRcdFx0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIiwgdi5qb2luKFwiIFwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfY2FuR2V0QkJveCA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gZS5nZXRCQm94KCk7IC8vRmlyZWZveCB0aHJvd3MgZXJyb3JzIGlmIHlvdSB0cnkgY2FsbGluZyBnZXRCQm94KCkgb24gYW4gU1ZHIGVsZW1lbnQgdGhhdCdzIG5vdCByZW5kZXJlZCAobGlrZSBpbiBhIDxzeW1ib2w+IG9yIDxkZWZzPikuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTYxMjExOFxuXHRcdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdFx0fSxcblx0XHRcdF9pc1NWRyA9IGZ1bmN0aW9uKGUpIHsgLy9yZXBvcnRzIGlmIHRoZSBlbGVtZW50IGlzIGFuIFNWRyBvbiB3aGljaCBnZXRCQm94KCkgYWN0dWFsbHkgd29ya3Ncblx0XHRcdFx0cmV0dXJuICEhKF9TVkdFbGVtZW50ICYmIGUuZ2V0QkJveCAmJiBlLmdldENUTSAmJiBfY2FuR2V0QkJveChlKSAmJiAoIWUucGFyZW50Tm9kZSB8fCAoZS5wYXJlbnROb2RlLmdldEJCb3ggJiYgZS5wYXJlbnROb2RlLmdldENUTSkpKTtcblx0XHRcdH0sXG5cdFx0XHRfaWRlbnRpdHkyRE1hdHJpeCA9IFsxLDAsMCwxLDAsMF0sXG5cdFx0XHRfZ2V0TWF0cml4ID0gZnVuY3Rpb24oZSwgZm9yY2UyRCkge1xuXHRcdFx0XHR2YXIgdG0gPSBlLl9nc1RyYW5zZm9ybSB8fCBuZXcgVHJhbnNmb3JtKCksXG5cdFx0XHRcdFx0cm5kID0gMTAwMDAwLFxuXHRcdFx0XHRcdGlzRGVmYXVsdCwgcywgbSwgbiwgZGVjO1xuXHRcdFx0XHRpZiAoX3RyYW5zZm9ybVByb3ApIHtcblx0XHRcdFx0XHRzID0gX2dldFN0eWxlKGUsIF90cmFuc2Zvcm1Qcm9wQ1NTLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChlLmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0XHRcdC8vZm9yIG9sZGVyIHZlcnNpb25zIG9mIElFLCB3ZSBuZWVkIHRvIGludGVycHJldCB0aGUgZmlsdGVyIHBvcnRpb24gdGhhdCBpcyBpbiB0aGUgZm9ybWF0OiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT02LjEyMzIzMzk5NTczNjc2NmUtMTcsIE0xMj0tMSwgTTIxPTEsIE0yMj02LjEyMzIzMzk5NTczNjc2NmUtMTcsIHNpemluZ01ldGhvZD0nYXV0byBleHBhbmQnKSBOb3RpY2UgdGhhdCB3ZSBuZWVkIHRvIHN3YXAgYiBhbmQgYyBjb21wYXJlZCB0byBhIG5vcm1hbCBtYXRyaXguXG5cdFx0XHRcdFx0cyA9IGUuY3VycmVudFN0eWxlLmZpbHRlci5tYXRjaChfaWVHZXRNYXRyaXhFeHApO1xuXHRcdFx0XHRcdHMgPSAocyAmJiBzLmxlbmd0aCA9PT0gNCkgPyBbc1swXS5zdWJzdHIoNCksIE51bWJlcihzWzJdLnN1YnN0cig0KSksIE51bWJlcihzWzFdLnN1YnN0cig0KSksIHNbM10uc3Vic3RyKDQpLCAodG0ueCB8fCAwKSwgKHRtLnkgfHwgMCldLmpvaW4oXCIsXCIpIDogXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpc0RlZmF1bHQgPSAoIXMgfHwgcyA9PT0gXCJub25lXCIgfHwgcyA9PT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIik7XG5cdFx0XHRcdGlmICh0bS5zdmcgfHwgKGUuZ2V0QkJveCAmJiBfaXNTVkcoZSkpKSB7XG5cdFx0XHRcdFx0aWYgKGlzRGVmYXVsdCAmJiAoZS5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5pbmRleE9mKFwibWF0cml4XCIpICE9PSAtMSkgeyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgQ2hyb21lIDQwKSBkb24ndCBjb3JyZWN0bHkgcmVwb3J0IHRyYW5zZm9ybXMgdGhhdCBhcmUgYXBwbGllZCBpbmxpbmUgb24gYW4gU1ZHIGVsZW1lbnQgKHRoZXkgZG9uJ3QgZ2V0IGluY2x1ZGVkIGluIHRoZSBjb21wdXRlZCBzdHlsZSksIHNvIHdlIGRvdWJsZS1jaGVjayBoZXJlIGFuZCBhY2NlcHQgbWF0cml4IHZhbHVlc1xuXHRcdFx0XHRcdFx0cyA9IGUuc3R5bGVbX3RyYW5zZm9ybVByb3BdO1xuXHRcdFx0XHRcdFx0aXNEZWZhdWx0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bSA9IGUuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuXHRcdFx0XHRcdGlmIChpc0RlZmF1bHQgJiYgbSkge1xuXHRcdFx0XHRcdFx0aWYgKG0uaW5kZXhPZihcIm1hdHJpeFwiKSAhPT0gLTEpIHsgLy9qdXN0IGluIGNhc2UgdGhlcmUncyBhIFwidHJhbnNmb3JtXCIgdmFsdWUgc3BlY2lmaWVkIGFzIGFuIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIENTUyBzdHlsZS4gQWNjZXB0IGVpdGhlciBhIG1hdHJpeCgpIG9yIHNpbXBsZSB0cmFuc2xhdGUoKSB2YWx1ZSB0aG91Z2guXG5cdFx0XHRcdFx0XHRcdHMgPSBtO1xuXHRcdFx0XHRcdFx0XHRpc0RlZmF1bHQgPSAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChtLmluZGV4T2YoXCJ0cmFuc2xhdGVcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHMgPSBcIm1hdHJpeCgxLDAsMCwxLFwiICsgbS5tYXRjaCgvKD86XFwtfFxcYilbXFxkXFwtXFwuZV0rXFxiL2dpKS5qb2luKFwiLFwiKSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0XHRpc0RlZmF1bHQgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNEZWZhdWx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9pZGVudGl0eTJETWF0cml4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vc3BsaXQgdGhlIG1hdHJpeCB2YWx1ZXMgb3V0IGludG8gYW4gYXJyYXkgKG0gZm9yIG1hdHJpeClcblx0XHRcdFx0bSA9IChzIHx8IFwiXCIpLm1hdGNoKF9udW1FeHApIHx8IFtdO1xuXHRcdFx0XHRpID0gbS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdG4gPSBOdW1iZXIobVtpXSk7XG5cdFx0XHRcdFx0bVtpXSA9IChkZWMgPSBuIC0gKG4gfD0gMCkpID8gKChkZWMgKiBybmQgKyAoZGVjIDwgMCA/IC0wLjUgOiAwLjUpKSB8IDApIC8gcm5kICsgbiA6IG47IC8vY29udmVydCBzdHJpbmdzIHRvIE51bWJlcnMgYW5kIHJvdW5kIHRvIDUgZGVjaW1hbCBwbGFjZXMgdG8gYXZvaWQgaXNzdWVzIHdpdGggdGlueSBudW1iZXJzLiBSb3VnaGx5IDIweCBmYXN0ZXIgdGhhbiBOdW1iZXIudG9GaXhlZCgpLiBXZSBhbHNvIG11c3QgbWFrZSBzdXJlIHRvIHJvdW5kIGJlZm9yZSBkaXZpZGluZyBzbyB0aGF0IHZhbHVlcyBsaWtlIDAuOTk5OTk5OTk5OSBiZWNvbWUgMSB0byBhdm9pZCBnbGl0Y2hlcyBpbiBicm93c2VyIHJlbmRlcmluZyBhbmQgaW50ZXJwcmV0YXRpb24gb2YgZmxpcHBlZC9yb3RhdGVkIDNEIG1hdHJpY2VzLiBBbmQgZG9uJ3QganVzdCBtdWx0aXBseSB0aGUgbnVtYmVyIGJ5IHJuZCwgZmxvb3IgaXQsIGFuZCB0aGVuIGRpdmlkZSBieSBybmQgYmVjYXVzZSB0aGUgYml0d2lzZSBvcGVyYXRpb25zIG1heCBvdXQgYXQgYSAzMi1iaXQgc2lnbmVkIGludGVnZXIsIHRodXMgaXQgY291bGQgZ2V0IGNsaXBwZWQgYXQgYSByZWxhdGl2ZWx5IGxvdyB2YWx1ZSAobGlrZSAyMiwwMDAuMDAwMDAgZm9yIGV4YW1wbGUpLlxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoZm9yY2UyRCAmJiBtLmxlbmd0aCA+IDYpID8gW21bMF0sIG1bMV0sIG1bNF0sIG1bNV0sIG1bMTJdLCBtWzEzXV0gOiBtO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQYXJzZXMgdGhlIHRyYW5zZm9ybSB2YWx1ZXMgZm9yIGFuIGVsZW1lbnQsIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCB4LCB5LCB6LCBzY2FsZVgsIHNjYWxlWSwgc2NhbGVaLCByb3RhdGlvbiwgcm90YXRpb25YLCByb3RhdGlvblksIHNrZXdYLCBhbmQgc2tld1kgcHJvcGVydGllcy4gTm90ZTogYnkgZGVmYXVsdCAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpLCBhbGwgc2tld2luZyBpcyBjb21iaW5lZCBpbnRvIHNrZXdYIGFuZCByb3RhdGlvbiBidXQgc2tld1kgc3RpbGwgaGFzIGEgcGxhY2UgaW4gdGhlIHRyYW5zZm9ybSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gcmVjb3JkIGhvdyBtdWNoIG9mIHRoZSBza2V3IGlzIGF0dHJpYnV0ZWQgdG8gc2tld1ggdnMgc2tld1kuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGxvb2tzIHRoZSBzYW1lIGFzIGEgcm90YXRpb24gb2YgMTAgYW5kIHNrZXdYIG9mIC0xMC5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBjb21wdXRlZCBzdHlsZSBvYmplY3QgKG9wdGlvbmFsKVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcmVjIGlmIHRydWUsIHRoZSB0cmFuc2Zvcm0gdmFsdWVzIHdpbGwgYmUgcmVjb3JkZWQgdG8gdGhlIHRhcmdldCBlbGVtZW50J3MgX2dzVHJhbnNmb3JtIG9iamVjdCwgbGlrZSB0YXJnZXQuX2dzVHJhbnNmb3JtID0ge3g6MCwgeTowLCB6OjAsIHNjYWxlWDoxLi4ufVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcGFyc2UgaWYgdHJ1ZSwgd2UnbGwgaWdub3JlIGFueSBfZ3NUcmFuc2Zvcm0gdmFsdWVzIHRoYXQgYWxyZWFkeSBleGlzdCBvbiB0aGUgZWxlbWVudCwgYW5kIGZvcmNlIGEgcmVwYXJzaW5nIG9mIHRoZSBjc3MgKGNhbGN1bGF0ZWQgc3R5bGUpXG5cdFx0XHQgKiBAcmV0dXJuIHtvYmplY3R9IG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMvdmFsdWVzIGxpa2Uge3g6MCwgeTowLCB6OjAsIHNjYWxlWDoxLi4ufVxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0VHJhbnNmb3JtID0gX2ludGVybmFscy5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbih0LCBjcywgcmVjLCBwYXJzZSkge1xuXHRcdFx0XHRpZiAodC5fZ3NUcmFuc2Zvcm0gJiYgcmVjICYmICFwYXJzZSkge1xuXHRcdFx0XHRcdHJldHVybiB0Ll9nc1RyYW5zZm9ybTsgLy9pZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhcyBhIF9nc1RyYW5zZm9ybSwgdXNlIHRoYXQuIE5vdGU6IHNvbWUgYnJvd3NlcnMgZG9uJ3QgYWNjdXJhdGVseSByZXR1cm4gdGhlIGNhbGN1bGF0ZWQgc3R5bGUgZm9yIHRoZSB0cmFuc2Zvcm0gKHBhcnRpY3VsYXJseSBmb3IgU1ZHKSwgc28gaXQncyBhbG1vc3QgYWx3YXlzIHNhZmVzdCB0byBqdXN0IHVzZSB0aGUgdmFsdWVzIHdlJ3ZlIGFscmVhZHkgYXBwbGllZCByYXRoZXIgdGhhbiByZS1wYXJzaW5nIHRoaW5ncy5cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdG0gPSByZWMgPyB0Ll9nc1RyYW5zZm9ybSB8fCBuZXcgVHJhbnNmb3JtKCkgOiBuZXcgVHJhbnNmb3JtKCksXG5cdFx0XHRcdFx0aW52WCA9ICh0bS5zY2FsZVggPCAwKSwgLy9pbiBvcmRlciB0byBpbnRlcnByZXQgdGhpbmdzIHByb3Blcmx5LCB3ZSBuZWVkIHRvIGtub3cgaWYgdGhlIHVzZXIgYXBwbGllZCBhIG5lZ2F0aXZlIHNjYWxlWCBwcmV2aW91c2x5IHNvIHRoYXQgd2UgY2FuIGFkanVzdCB0aGUgcm90YXRpb24gYW5kIHNrZXdYIGFjY29yZGluZ2x5LiBPdGhlcndpc2UsIGlmIHdlIGFsd2F5cyBpbnRlcnByZXQgYSBmbGlwcGVkIG1hdHJpeCBhcyBhZmZlY3Rpbmcgc2NhbGVZIGFuZCB0aGUgdXNlciBvbmx5IHdhbnRzIHRvIHR3ZWVuIHRoZSBzY2FsZVggb24gbXVsdGlwbGUgc2VxdWVudGlhbCB0d2VlbnMsIGl0IHdvdWxkIGtlZXAgdGhlIG5lZ2F0aXZlIHNjYWxlWSB3aXRob3V0IHRoYXQgYmVpbmcgdGhlIHVzZXIncyBpbnRlbnQuXG5cdFx0XHRcdFx0bWluID0gMC4wMDAwMixcblx0XHRcdFx0XHRybmQgPSAxMDAwMDAsXG5cdFx0XHRcdFx0ek9yaWdpbiA9IF9zdXBwb3J0czNEID8gcGFyc2VGbG9hdChfZ2V0U3R5bGUodCwgX3RyYW5zZm9ybU9yaWdpblByb3AsIGNzLCBmYWxzZSwgXCIwIDAgMFwiKS5zcGxpdChcIiBcIilbMl0pIHx8IHRtLnpPcmlnaW4gIHx8IDAgOiAwLFxuXHRcdFx0XHRcdGRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IHBhcnNlRmxvYXQoQ1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSkgfHwgMCxcblx0XHRcdFx0XHRtLCBpLCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYO1xuXG5cdFx0XHRcdHRtLnN2ZyA9ICEhKHQuZ2V0QkJveCAmJiBfaXNTVkcodCkpO1xuXHRcdFx0XHRpZiAodG0uc3ZnKSB7XG5cdFx0XHRcdFx0X3BhcnNlU1ZHT3JpZ2luKHQsIF9nZXRTdHlsZSh0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCwgX2NzLCBmYWxzZSwgXCI1MCUgNTAlXCIpICsgXCJcIiwgdG0sIHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpKTtcblx0XHRcdFx0XHRfdXNlU1ZHVHJhbnNmb3JtQXR0ciA9IENTU1BsdWdpbi51c2VTVkdUcmFuc2Zvcm1BdHRyIHx8IF9mb3JjZVNWR1RyYW5zZm9ybUF0dHI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bSA9IF9nZXRNYXRyaXgodCk7XG5cdFx0XHRcdGlmIChtICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkge1xuXG5cdFx0XHRcdFx0aWYgKG0ubGVuZ3RoID09PSAxNikge1xuXHRcdFx0XHRcdFx0Ly93ZSdsbCBvbmx5IGxvb2sgYXQgdGhlc2UgcG9zaXRpb24tcmVsYXRlZCA2IHZhcmlhYmxlcyBmaXJzdCBiZWNhdXNlIGlmIHgveS96IGFsbCBtYXRjaCwgaXQncyByZWxhdGl2ZWx5IHNhZmUgdG8gYXNzdW1lIHdlIGRvbid0IG5lZWQgdG8gcmUtcGFyc2UgZXZlcnl0aGluZyB3aGljaCByaXNrcyBsb3NpbmcgaW1wb3J0YW50IHJvdGF0aW9uYWwgaW5mb3JtYXRpb24gKGxpa2Ugcm90YXRpb25YOjE4MCBwbHVzIHJvdGF0aW9uWToxODAgd291bGQgbG9vayB0aGUgc2FtZSBhcyByb3RhdGlvbjoxODAgLSB0aGVyZSdzIG5vIHdheSB0byBrbm93IGZvciBzdXJlIHdoaWNoIGRpcmVjdGlvbiB3YXMgdGFrZW4gYmFzZWQgc29sZWx5IG9uIHRoZSBtYXRyaXgzZCgpIHZhbHVlcylcblx0XHRcdFx0XHRcdHZhciBhMTEgPSBtWzBdLCBhMjEgPSBtWzFdLCBhMzEgPSBtWzJdLCBhNDEgPSBtWzNdLFxuXHRcdFx0XHRcdFx0XHRhMTIgPSBtWzRdLCBhMjIgPSBtWzVdLCBhMzIgPSBtWzZdLCBhNDIgPSBtWzddLFxuXHRcdFx0XHRcdFx0XHRhMTMgPSBtWzhdLCBhMjMgPSBtWzldLCBhMzMgPSBtWzEwXSxcblx0XHRcdFx0XHRcdFx0YTE0ID0gbVsxMl0sIGEyNCA9IG1bMTNdLCBhMzQgPSBtWzE0XSxcblx0XHRcdFx0XHRcdFx0YTQzID0gbVsxMV0sXG5cdFx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMihhMzIsIGEzMyksXG5cdFx0XHRcdFx0XHRcdHQxLCB0MiwgdDMsIHQ0LCBjb3MsIHNpbjtcblxuXHRcdFx0XHRcdFx0Ly93ZSBtYW51YWxseSBjb21wZW5zYXRlIGZvciBub24temVybyB6IGNvbXBvbmVudCBvZiB0cmFuc2Zvcm1PcmlnaW4gdG8gd29yayBhcm91bmQgYnVncyBpbiBTYWZhcmlcblx0XHRcdFx0XHRcdGlmICh0bS56T3JpZ2luKSB7XG5cdFx0XHRcdFx0XHRcdGEzNCA9IC10bS56T3JpZ2luO1xuXHRcdFx0XHRcdFx0XHRhMTQgPSBhMTMqYTM0LW1bMTJdO1xuXHRcdFx0XHRcdFx0XHRhMjQgPSBhMjMqYTM0LW1bMTNdO1xuXHRcdFx0XHRcdFx0XHRhMzQgPSBhMzMqYTM0K3RtLnpPcmlnaW4tbVsxNF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvblggPSBhbmdsZSAqIF9SQUQyREVHO1xuXHRcdFx0XHRcdFx0Ly9yb3RhdGlvblhcblx0XHRcdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IGExMipjb3MrYTEzKnNpbjtcblx0XHRcdFx0XHRcdFx0dDIgPSBhMjIqY29zK2EyMypzaW47XG5cdFx0XHRcdFx0XHRcdHQzID0gYTMyKmNvcythMzMqc2luO1xuXHRcdFx0XHRcdFx0XHRhMTMgPSBhMTIqLXNpbithMTMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMjMgPSBhMjIqLXNpbithMjMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMzMgPSBhMzIqLXNpbithMzMqY29zO1xuXHRcdFx0XHRcdFx0XHRhNDMgPSBhNDIqLXNpbithNDMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMTIgPSB0MTtcblx0XHRcdFx0XHRcdFx0YTIyID0gdDI7XG5cdFx0XHRcdFx0XHRcdGEzMiA9IHQzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9yb3RhdGlvbllcblx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMigtYTMxLCBhMzMpO1xuXHRcdFx0XHRcdFx0dG0ucm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IGExMSpjb3MtYTEzKnNpbjtcblx0XHRcdFx0XHRcdFx0dDIgPSBhMjEqY29zLWEyMypzaW47XG5cdFx0XHRcdFx0XHRcdHQzID0gYTMxKmNvcy1hMzMqc2luO1xuXHRcdFx0XHRcdFx0XHRhMjMgPSBhMjEqc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0XHRcdGEzMyA9IGEzMSpzaW4rYTMzKmNvcztcblx0XHRcdFx0XHRcdFx0YTQzID0gYTQxKnNpbithNDMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMTEgPSB0MTtcblx0XHRcdFx0XHRcdFx0YTIxID0gdDI7XG5cdFx0XHRcdFx0XHRcdGEzMSA9IHQzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9yb3RhdGlvblpcblx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMihhMjEsIGExMSk7XG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0YTExID0gYTExKmNvcythMTIqc2luO1xuXHRcdFx0XHRcdFx0XHR0MiA9IGEyMSpjb3MrYTIyKnNpbjtcblx0XHRcdFx0XHRcdFx0YTIyID0gYTIxKi1zaW4rYTIyKmNvcztcblx0XHRcdFx0XHRcdFx0YTMyID0gYTMxKi1zaW4rYTMyKmNvcztcblx0XHRcdFx0XHRcdFx0YTIxID0gdDI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0bS5yb3RhdGlvblggJiYgTWF0aC5hYnModG0ucm90YXRpb25YKSArIE1hdGguYWJzKHRtLnJvdGF0aW9uKSA+IDM1OS45KSB7IC8vd2hlbiByb3RhdGlvblkgaXMgc2V0LCBpdCB3aWxsIG9mdGVuIGJlIHBhcnNlZCBhcyAxODAgZGVncmVlcyBkaWZmZXJlbnQgdGhhbiBpdCBzaG91bGQgYmUsIGFuZCByb3RhdGlvblggYW5kIHJvdGF0aW9uIGJvdGggYmVpbmcgMTgwIChpdCBsb29rcyB0aGUgc2FtZSksIHNvIHdlIGFkanVzdCBmb3IgdGhhdCBoZXJlLlxuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblggPSB0bS5yb3RhdGlvbiA9IDA7XG5cdFx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWSA9IDE4MCAtIHRtLnJvdGF0aW9uWTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dG0uc2NhbGVYID0gKChNYXRoLnNxcnQoYTExICogYTExICsgYTIxICogYTIxKSAqIHJuZCArIDAuNSkgfCAwKSAvIHJuZDtcblx0XHRcdFx0XHRcdHRtLnNjYWxlWSA9ICgoTWF0aC5zcXJ0KGEyMiAqIGEyMiArIGEyMyAqIGEyMykgKiBybmQgKyAwLjUpIHwgMCkgLyBybmQ7XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVogPSAoKE1hdGguc3FydChhMzIgKiBhMzIgKyBhMzMgKiBhMzMpICogcm5kICsgMC41KSB8IDApIC8gcm5kO1xuXHRcdFx0XHRcdFx0dG0uc2tld1ggPSAoYTEyIHx8IGEyMikgPyBNYXRoLmF0YW4yKGExMiwgYTIyKSAqIF9SQUQyREVHICsgdG0ucm90YXRpb24gOiB0bS5za2V3WCB8fCAwO1xuXHRcdFx0XHRcdFx0aWYgKE1hdGguYWJzKHRtLnNrZXdYKSA+IDkwICYmIE1hdGguYWJzKHRtLnNrZXdYKSA8IDI3MCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW52WCkge1xuXHRcdFx0XHRcdFx0XHRcdHRtLnNjYWxlWCAqPSAtMTtcblx0XHRcdFx0XHRcdFx0XHR0bS5za2V3WCArPSAodG0ucm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uICs9ICh0bS5yb3RhdGlvbiA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dG0uc2NhbGVZICo9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdHRtLnNrZXdYICs9ICh0bS5za2V3WCA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRtLnBlcnNwZWN0aXZlID0gYTQzID8gMSAvICgoYTQzIDwgMCkgPyAtYTQzIDogYTQzKSA6IDA7XG5cdFx0XHRcdFx0XHR0bS54ID0gYTE0O1xuXHRcdFx0XHRcdFx0dG0ueSA9IGEyNDtcblx0XHRcdFx0XHRcdHRtLnogPSBhMzQ7XG5cdFx0XHRcdFx0XHRpZiAodG0uc3ZnKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnggLT0gdG0ueE9yaWdpbiAtICh0bS54T3JpZ2luICogYTExIC0gdG0ueU9yaWdpbiAqIGExMik7XG5cdFx0XHRcdFx0XHRcdHRtLnkgLT0gdG0ueU9yaWdpbiAtICh0bS55T3JpZ2luICogYTIxIC0gdG0ueE9yaWdpbiAqIGEyMik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCghX3N1cHBvcnRzM0QgfHwgcGFyc2UgfHwgIW0ubGVuZ3RoIHx8IHRtLnggIT09IG1bNF0gfHwgdG0ueSAhPT0gbVs1XSB8fCAoIXRtLnJvdGF0aW9uWCAmJiAhdG0ucm90YXRpb25ZKSkgJiYgISh0bS54ICE9PSB1bmRlZmluZWQgJiYgX2dldFN0eWxlKHQsIFwiZGlzcGxheVwiLCBjcykgPT09IFwibm9uZVwiKSkgeyAvL3NvbWV0aW1lcyBhIDYtZWxlbWVudCBtYXRyaXggaXMgcmV0dXJuZWQgZXZlbiB3aGVuIHdlIHBlcmZvcm1lZCAzRCB0cmFuc2Zvcm1zLCBsaWtlIGlmIHJvdGF0aW9uWCBhbmQgcm90YXRpb25ZIGFyZSAxODAuIEluIGNhc2VzIGxpa2UgdGhpcywgd2Ugc3RpbGwgbmVlZCB0byBob25vciB0aGUgM0QgdHJhbnNmb3Jtcy4gSWYgd2UganVzdCByZWx5IG9uIHRoZSAyRCBpbmZvLCBpdCBjb3VsZCBhZmZlY3QgaG93IHRoZSBkYXRhIGlzIGludGVycHJldGVkLCBsaWtlIHNjYWxlWSBtaWdodCBnZXQgc2V0IHRvIC0xIG9yIHJvdGF0aW9uIGNvdWxkIGdldCBvZmZzZXQgYnkgMTgwIGRlZ3JlZXMuIEZvciBleGFtcGxlLCBkbyBhIFR3ZWVuTGl0ZS50byhlbGVtZW50LCAxLCB7Y3NzOntyb3RhdGlvblg6MTgwLCByb3RhdGlvblk6MTgwfX0pIGFuZCB0aGVuIGxhdGVyLCBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7cm90YXRpb25YOjB9fSkgYW5kIHdpdGhvdXQgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbiBwbGFjZSwgaXQnZCBqdW1wIHRvIGEgc3RhdGUgb2YgYmVpbmcgdW5yb3RhdGVkIHdoZW4gdGhlIDJuZCB0d2VlbiBzdGFydHMuIFRoZW4gYWdhaW4sIHdlIG5lZWQgdG8gaG9ub3IgdGhlIGZhY3QgdGhhdCB0aGUgdXNlciBDT1VMRCBhbHRlciB0aGUgdHJhbnNmb3JtcyBvdXRzaWRlIG9mIENTU1BsdWdpbiwgbGlrZSBieSBtYW51YWxseSBhcHBseWluZyBuZXcgY3NzLCBzbyB3ZSB0cnkgdG8gc2Vuc2UgdGhhdCBieSBsb29raW5nIGF0IHggYW5kIHkgYmVjYXVzZSBpZiB0aG9zZSBjaGFuZ2VkLCB3ZSBrbm93IHRoZSBjaGFuZ2VzIHdlcmUgbWFkZSBvdXRzaWRlIENTU1BsdWdpbiBhbmQgd2UgZm9yY2UgYSByZWludGVycHJldGF0aW9uIG9mIHRoZSBtYXRyaXggdmFsdWVzLiBBbHNvLCBpbiBXZWJraXQgYnJvd3NlcnMsIGlmIHRoZSBlbGVtZW50J3MgXCJkaXNwbGF5XCIgaXMgXCJub25lXCIsIGl0cyBjYWxjdWxhdGVkIHN0eWxlIHZhbHVlIHdpbGwgYWx3YXlzIHJldHVybiBlbXB0eSwgc28gaWYgd2UndmUgYWxyZWFkeSByZWNvcmRlZCB0aGUgdmFsdWVzIGluIHRoZSBfZ3NUcmFuc2Zvcm0gb2JqZWN0LCB3ZSdsbCBqdXN0IHJlbHkgb24gdGhvc2UuXG5cdFx0XHRcdFx0XHR2YXIgayA9IChtLmxlbmd0aCA+PSA2KSxcblx0XHRcdFx0XHRcdFx0YSA9IGsgPyBtWzBdIDogMSxcblx0XHRcdFx0XHRcdFx0YiA9IG1bMV0gfHwgMCxcblx0XHRcdFx0XHRcdFx0YyA9IG1bMl0gfHwgMCxcblx0XHRcdFx0XHRcdFx0ZCA9IGsgPyBtWzNdIDogMTtcblx0XHRcdFx0XHRcdHRtLnggPSBtWzRdIHx8IDA7XG5cdFx0XHRcdFx0XHR0bS55ID0gbVs1XSB8fCAwO1xuXHRcdFx0XHRcdFx0c2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXHRcdFx0XHRcdFx0c2NhbGVZID0gTWF0aC5zcXJ0KGQgKiBkICsgYyAqIGMpO1xuXHRcdFx0XHRcdFx0cm90YXRpb24gPSAoYSB8fCBiKSA/IE1hdGguYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IHRtLnJvdGF0aW9uIHx8IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXG5cdFx0XHRcdFx0XHRza2V3WCA9IChjIHx8IGQpID8gTWF0aC5hdGFuMihjLCBkKSAqIF9SQUQyREVHICsgcm90YXRpb24gOiB0bS5za2V3WCB8fCAwO1xuXHRcdFx0XHRcdFx0aWYgKE1hdGguYWJzKHNrZXdYKSA+IDkwICYmIE1hdGguYWJzKHNrZXdYKSA8IDI3MCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW52WCkge1xuXHRcdFx0XHRcdFx0XHRcdHNjYWxlWCAqPSAtMTtcblx0XHRcdFx0XHRcdFx0XHRza2V3WCArPSAocm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHRcdHJvdGF0aW9uICs9IChyb3RhdGlvbiA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0c2NhbGVZICo9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdHNrZXdYICs9IChza2V3WCA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRtLnNjYWxlWCA9IHNjYWxlWDtcblx0XHRcdFx0XHRcdHRtLnNjYWxlWSA9IHNjYWxlWTtcblx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uID0gcm90YXRpb247XG5cdFx0XHRcdFx0XHR0bS5za2V3WCA9IHNrZXdYO1xuXHRcdFx0XHRcdFx0aWYgKF9zdXBwb3J0czNEKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWCA9IHRtLnJvdGF0aW9uWSA9IHRtLnogPSAwO1xuXHRcdFx0XHRcdFx0XHR0bS5wZXJzcGVjdGl2ZSA9IGRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZTtcblx0XHRcdFx0XHRcdFx0dG0uc2NhbGVaID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0bS5zdmcpIHtcblx0XHRcdFx0XHRcdFx0dG0ueCAtPSB0bS54T3JpZ2luIC0gKHRtLnhPcmlnaW4gKiBhICsgdG0ueU9yaWdpbiAqIGMpO1xuXHRcdFx0XHRcdFx0XHR0bS55IC09IHRtLnlPcmlnaW4gLSAodG0ueE9yaWdpbiAqIGIgKyB0bS55T3JpZ2luICogZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRtLnpPcmlnaW4gPSB6T3JpZ2luO1xuXHRcdFx0XHRcdC8vc29tZSBicm93c2VycyBoYXZlIGEgaGFyZCB0aW1lIHdpdGggdmVyeSBzbWFsbCB2YWx1ZXMgbGlrZSAyLjQ0OTI5MzU5ODI5NDcwNjRlLTE2IChub3RpY2UgdGhlIFwiZS1cIiB0b3dhcmRzIHRoZSBlbmQpIGFuZCB3b3VsZCByZW5kZXIgdGhlIG9iamVjdCBzbGlnaHRseSBvZmYuIFNvIHdlIHJvdW5kIHRvIDAgaW4gdGhlc2UgY2FzZXMuIFRoZSBjb25kaXRpb25hbCBsb2dpYyBoZXJlIGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgTWF0aC5hYnMoKS4gQWxzbywgYnJvd3NlcnMgdGVuZCB0byByZW5kZXIgYSBTTElHSFRMWSByb3RhdGVkIG9iamVjdCBpbiBhIGZ1enp5IHdheSwgc28gd2UgbmVlZCB0byBzbmFwIHRvIGV4YWN0bHkgMCB3aGVuIGFwcHJvcHJpYXRlLlxuXHRcdFx0XHRcdGZvciAoaSBpbiB0bSkge1xuXHRcdFx0XHRcdFx0aWYgKHRtW2ldIDwgbWluKSBpZiAodG1baV0gPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRcdHRtW2ldID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcInBhcnNlZCByb3RhdGlvbiBvZiBcIiArIHQuZ2V0QXR0cmlidXRlKFwiaWRcIikrXCI6IFwiKyh0bS5yb3RhdGlvblgpK1wiLCBcIisodG0ucm90YXRpb25ZKStcIiwgXCIrKHRtLnJvdGF0aW9uKStcIiwgc2NhbGU6IFwiK3RtLnNjYWxlWCtcIiwgXCIrdG0uc2NhbGVZK1wiLCBcIit0bS5zY2FsZVorXCIsIHBvc2l0aW9uOiBcIit0bS54K1wiLCBcIit0bS55K1wiLCBcIit0bS56K1wiLCBwZXJzcGVjdGl2ZTogXCIrdG0ucGVyc3BlY3RpdmUrIFwiLCBvcmlnaW46IFwiKyB0bS54T3JpZ2luKyBcIixcIisgdG0ueU9yaWdpbik7XG5cdFx0XHRcdGlmIChyZWMpIHtcblx0XHRcdFx0XHR0Ll9nc1RyYW5zZm9ybSA9IHRtOyAvL3JlY29yZCB0byB0aGUgb2JqZWN0J3MgX2dzVHJhbnNmb3JtIHdoaWNoIHdlIHVzZSBzbyB0aGF0IHR3ZWVucyBjYW4gY29udHJvbCBpbmRpdmlkdWFsIHByb3BlcnRpZXMgaW5kZXBlbmRlbnRseSAod2UgbmVlZCBhbGwgdGhlIHByb3BlcnRpZXMgdG8gYWNjdXJhdGVseSByZWNvbXBvc2UgdGhlIG1hdHJpeCBpbiB0aGUgc2V0UmF0aW8oKSBtZXRob2QpXG5cdFx0XHRcdFx0aWYgKHRtLnN2ZykgeyAvL2lmIHdlJ3JlIHN1cHBvc2VkIHRvIGFwcGx5IHRyYW5zZm9ybXMgdG8gdGhlIFNWRyBlbGVtZW50J3MgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIG1ha2Ugc3VyZSB0aGVyZSBhcmVuJ3QgYW55IENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQgb3IgdGhleSdsbCBvdmVycmlkZSB0aGUgYXR0cmlidXRlIG9uZXMuIEFsc28gY2xlYXIgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgaWYgd2UncmUgdXNpbmcgQ1NTLCBqdXN0IHRvIGJlIGNsZWFuLlxuXHRcdFx0XHRcdFx0aWYgKF91c2VTVkdUcmFuc2Zvcm1BdHRyICYmIHQuc3R5bGVbX3RyYW5zZm9ybVByb3BdKSB7XG5cdFx0XHRcdFx0XHRcdFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLjAwMSwgZnVuY3Rpb24oKXsgLy9pZiB3ZSBhcHBseSB0aGlzIHJpZ2h0IGF3YXkgKGJlZm9yZSBhbnl0aGluZyBoYXMgcmVuZGVyZWQpLCB3ZSByaXNrIHRoZXJlIGJlaW5nIG5vIHRyYW5zZm9ybXMgZm9yIGEgYnJpZWYgbW9tZW50IGFuZCBpdCBhbHNvIGludGVyZmVyZXMgd2l0aCBhZGp1c3RpbmcgdGhlIHRyYW5zZm9ybU9yaWdpbiBpbiBhIHR3ZWVuIHdpdGggaW1tZWRpYXRlUmVuZGVyOnRydWUgKGl0J2QgdHJ5IHJlYWRpbmcgdGhlIG1hdHJpeCBhbmQgaXQgd291bGRuJ3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgZGF0YSBpbiBwbGFjZSBiZWNhdXNlIHdlIGp1c3QgcmVtb3ZlZCBpdCkuXG5cdFx0XHRcdFx0XHRcdFx0X3JlbW92ZVByb3AodC5zdHlsZSwgX3RyYW5zZm9ybVByb3ApO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIV91c2VTVkdUcmFuc2Zvcm1BdHRyICYmIHQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpKSB7XG5cdFx0XHRcdFx0XHRcdFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLjAwMSwgZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0XHR0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0bTtcblx0XHRcdH0sXG5cblx0XHRcdC8vZm9yIHNldHRpbmcgMkQgdHJhbnNmb3JtcyBpbiBJRTYsIElFNywgYW5kIElFOCAobXVzdCB1c2UgYSBcImZpbHRlclwiIHRvIGVtdWxhdGUgdGhlIGJlaGF2aW9yIG9mIG1vZGVybiBkYXkgYnJvd3NlciB0cmFuc2Zvcm1zKVxuXHRcdFx0X3NldElFVHJhbnNmb3JtUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy5kYXRhLCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIF9nc1RyYW5zZm9ybSBvYmplY3Rcblx0XHRcdFx0XHRhbmcgPSAtdC5yb3RhdGlvbiAqIF9ERUcyUkFELFxuXHRcdFx0XHRcdHNrZXcgPSBhbmcgKyB0LnNrZXdYICogX0RFRzJSQUQsXG5cdFx0XHRcdFx0cm5kID0gMTAwMDAwLFxuXHRcdFx0XHRcdGEgPSAoKE1hdGguY29zKGFuZykgKiB0LnNjYWxlWCAqIHJuZCkgfCAwKSAvIHJuZCxcblx0XHRcdFx0XHRiID0gKChNYXRoLnNpbihhbmcpICogdC5zY2FsZVggKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0YyA9ICgoTWF0aC5zaW4oc2tldykgKiAtdC5zY2FsZVkgKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0ZCA9ICgoTWF0aC5jb3Moc2tldykgKiB0LnNjYWxlWSAqIHJuZCkgfCAwKSAvIHJuZCxcblx0XHRcdFx0XHRzdHlsZSA9IHRoaXMudC5zdHlsZSxcblx0XHRcdFx0XHRjcyA9IHRoaXMudC5jdXJyZW50U3R5bGUsXG5cdFx0XHRcdFx0ZmlsdGVycywgdmFsO1xuXHRcdFx0XHRpZiAoIWNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbCA9IGI7IC8vanVzdCBmb3Igc3dhcHBpbmcgdGhlIHZhcmlhYmxlcyBhbiBpbnZlcnRpbmcgdGhlbSAocmV1c2VkIFwidmFsXCIgdG8gYXZvaWQgY3JlYXRpbmcgYW5vdGhlciB2YXJpYWJsZSBpbiBtZW1vcnkpLiBJRSdzIGZpbHRlciBtYXRyaXggdXNlcyBhIG5vbi1zdGFuZGFyZCBtYXRyaXggY29uZmlndXJhdGlvbiAoYW5nbGUgZ29lcyB0aGUgb3Bwb3NpdGUgd2F5LCBhbmQgYiBhbmQgYyBhcmUgcmV2ZXJzZWQgYW5kIGludmVydGVkKVxuXHRcdFx0XHRiID0gLWM7XG5cdFx0XHRcdGMgPSAtdmFsO1xuXHRcdFx0XHRmaWx0ZXJzID0gY3MuZmlsdGVyO1xuXHRcdFx0XHRzdHlsZS5maWx0ZXIgPSBcIlwiOyAvL3JlbW92ZSBmaWx0ZXJzIHNvIHRoYXQgd2UgY2FuIGFjY3VyYXRlbHkgbWVhc3VyZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHRcblx0XHRcdFx0dmFyIHcgPSB0aGlzLnQub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdFx0aCA9IHRoaXMudC5vZmZzZXRIZWlnaHQsXG5cdFx0XHRcdFx0Y2xpcCA9IChjcy5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiKSxcblx0XHRcdFx0XHRtID0gXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT1cIiArIGEgKyBcIiwgTTEyPVwiICsgYiArIFwiLCBNMjE9XCIgKyBjICsgXCIsIE0yMj1cIiArIGQsXG5cdFx0XHRcdFx0b3ggPSB0LnggKyAodyAqIHQueFBlcmNlbnQgLyAxMDApLFxuXHRcdFx0XHRcdG95ID0gdC55ICsgKGggKiB0LnlQZXJjZW50IC8gMTAwKSxcblx0XHRcdFx0XHRkeCwgZHk7XG5cblx0XHRcdFx0Ly9pZiB0cmFuc2Zvcm1PcmlnaW4gaXMgYmVpbmcgdXNlZCwgYWRqdXN0IHRoZSBvZmZzZXQgeCBhbmQgeVxuXHRcdFx0XHRpZiAodC5veCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0ZHggPSAoKHQub3hwKSA/IHcgKiB0Lm94ICogMC4wMSA6IHQub3gpIC0gdyAvIDI7XG5cdFx0XHRcdFx0ZHkgPSAoKHQub3lwKSA/IGggKiB0Lm95ICogMC4wMSA6IHQub3kpIC0gaCAvIDI7XG5cdFx0XHRcdFx0b3ggKz0gZHggLSAoZHggKiBhICsgZHkgKiBiKTtcblx0XHRcdFx0XHRveSArPSBkeSAtIChkeCAqIGMgKyBkeSAqIGQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFjbGlwKSB7XG5cdFx0XHRcdFx0bSArPSBcIiwgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZHggPSAodyAvIDIpO1xuXHRcdFx0XHRcdGR5ID0gKGggLyAyKTtcblx0XHRcdFx0XHQvL3RyYW5zbGF0ZSB0byBlbnN1cmUgdGhhdCB0cmFuc2Zvcm1hdGlvbnMgb2NjdXIgYXJvdW5kIHRoZSBjb3JyZWN0IG9yaWdpbiAoZGVmYXVsdCBpcyBjZW50ZXIpLlxuXHRcdFx0XHRcdG0gKz0gXCIsIER4PVwiICsgKGR4IC0gKGR4ICogYSArIGR5ICogYikgKyBveCkgKyBcIiwgRHk9XCIgKyAoZHkgLSAoZHggKiBjICsgZHkgKiBkKSArIG95KSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmaWx0ZXJzLmluZGV4T2YoXCJEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdHN0eWxlLmZpbHRlciA9IGZpbHRlcnMucmVwbGFjZShfaWVTZXRNYXRyaXhFeHAsIG0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlLmZpbHRlciA9IG0gKyBcIiBcIiArIGZpbHRlcnM7IC8vd2UgbXVzdCBhbHdheXMgcHV0IHRoZSB0cmFuc2Zvcm0vbWF0cml4IEZJUlNUIChiZWZvcmUgYWxwaGEob3BhY2l0eT14eCkpIHRvIGF2b2lkIGFuIElFIGJ1ZyB0aGF0IHNsaWNlcyBwYXJ0IG9mIHRoZSBvYmplY3Qgd2hlbiByb3RhdGlvbiBpcyBhcHBsaWVkIHdpdGggYWxwaGEuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL2F0IHRoZSBlbmQgb3IgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiwgaWYgdGhlIG1hdHJpeCBpcyBub3JtYWwgKDEsIDAsIDAsIDEpIGFuZCBvcGFjaXR5IGlzIDEwMCAob3IgZG9lc24ndCBleGlzdCksIHJlbW92ZSB0aGUgZmlsdGVyIHRvIGltcHJvdmUgYnJvd3NlciBwZXJmb3JtYW5jZS5cblx0XHRcdFx0aWYgKHYgPT09IDAgfHwgdiA9PT0gMSkgaWYgKGEgPT09IDEpIGlmIChiID09PSAwKSBpZiAoYyA9PT0gMCkgaWYgKGQgPT09IDEpIGlmICghY2xpcCB8fCBtLmluZGV4T2YoXCJEeD0wLCBEeT0wXCIpICE9PSAtMSkgaWYgKCFfb3BhY2l0eUV4cC50ZXN0KGZpbHRlcnMpIHx8IHBhcnNlRmxvYXQoUmVnRXhwLiQxKSA9PT0gMTAwKSBpZiAoZmlsdGVycy5pbmRleE9mKFwiZ3JhZGllbnQoXCIgJiYgZmlsdGVycy5pbmRleE9mKFwiQWxwaGFcIikpID09PSAtMSkge1xuXHRcdFx0XHRcdHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vd2UgbXVzdCBzZXQgdGhlIG1hcmdpbnMgQUZURVIgYXBwbHlpbmcgdGhlIGZpbHRlciBpbiBvcmRlciB0byBhdm9pZCBzb21lIGJ1Z3MgaW4gSUU4IHRoYXQgY291bGQgKGluIHJhcmUgc2NlbmFyaW9zKSBjYXVzZSB0aGVtIHRvIGJlIGlnbm9yZWQgaW50ZXJtaXR0ZW50bHkgKHZpYnJhdGlvbikuXG5cdFx0XHRcdGlmICghY2xpcCkge1xuXHRcdFx0XHRcdHZhciBtdWx0ID0gKF9pZVZlcnMgPCA4KSA/IDEgOiAtMSwgLy9pbiBJbnRlcm5ldCBFeHBsb3JlciA3IGFuZCBiZWZvcmUsIHRoZSBib3ggbW9kZWwgaXMgYnJva2VuLCBjYXVzaW5nIHRoZSBicm93c2VyIHRvIHRyZWF0IHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFjdHVhbCByb3RhdGVkIGZpbHRlcmVkIGltYWdlIGFzIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGJveCBpdHNlbGYsIGJ1dCBNaWNyb3NvZnQgY29ycmVjdGVkIHRoYXQgaW4gSUU4LiBXZSBtdXN0IHVzZSBhIG5lZ2F0aXZlIG9mZnNldCBpbiBJRTggb24gdGhlIHJpZ2h0L2JvdHRvbVxuXHRcdFx0XHRcdFx0bWFyZywgcHJvcCwgZGlmO1xuXHRcdFx0XHRcdGR4ID0gdC5pZU9mZnNldFggfHwgMDtcblx0XHRcdFx0XHRkeSA9IHQuaWVPZmZzZXRZIHx8IDA7XG5cdFx0XHRcdFx0dC5pZU9mZnNldFggPSBNYXRoLnJvdW5kKCh3IC0gKChhIDwgMCA/IC1hIDogYSkgKiB3ICsgKGIgPCAwID8gLWIgOiBiKSAqIGgpKSAvIDIgKyBveCk7XG5cdFx0XHRcdFx0dC5pZU9mZnNldFkgPSBNYXRoLnJvdW5kKChoIC0gKChkIDwgMCA/IC1kIDogZCkgKiBoICsgKGMgPCAwID8gLWMgOiBjKSAqIHcpKSAvIDIgKyBveSk7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRcdFx0cHJvcCA9IF9tYXJnaW5zW2ldO1xuXHRcdFx0XHRcdFx0bWFyZyA9IGNzW3Byb3BdO1xuXHRcdFx0XHRcdFx0Ly93ZSBuZWVkIHRvIGdldCB0aGUgY3VycmVudCBtYXJnaW4gaW4gY2FzZSBpdCBpcyBiZWluZyB0d2VlbmVkIHNlcGFyYXRlbHkgKHdlIHdhbnQgdG8gcmVzcGVjdCB0aGF0IHR3ZWVuJ3MgY2hhbmdlcylcblx0XHRcdFx0XHRcdHZhbCA9IChtYXJnLmluZGV4T2YoXCJweFwiKSAhPT0gLTEpID8gcGFyc2VGbG9hdChtYXJnKSA6IF9jb252ZXJ0VG9QaXhlbHModGhpcy50LCBwcm9wLCBwYXJzZUZsb2F0KG1hcmcpLCBtYXJnLnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIikpIHx8IDA7XG5cdFx0XHRcdFx0XHRpZiAodmFsICE9PSB0W3Byb3BdKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IChpIDwgMikgPyAtdC5pZU9mZnNldFggOiAtdC5pZU9mZnNldFk7IC8vaWYgYW5vdGhlciB0d2VlbiBpcyBjb250cm9sbGluZyBhIG1hcmdpbiwgd2UgY2Fubm90IG9ubHkgYXBwbHkgdGhlIGRpZmZlcmVuY2UgaW4gdGhlIGllT2Zmc2V0cywgc28gd2UgZXNzZW50aWFsbHkgemVyby1vdXQgdGhlIGR4IGFuZCBkeSBoZXJlIGluIHRoYXQgY2FzZS4gV2UgcmVjb3JkIHRoZSBtYXJnaW4ocykgbGF0ZXIgc28gdGhhdCB3ZSBjYW4ga2VlcCBjb21wYXJpbmcgdGhlbSwgbWFraW5nIHRoaXMgY29kZSB2ZXJ5IGZsZXhpYmxlLlxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKGkgPCAyKSA/IGR4IC0gdC5pZU9mZnNldFggOiBkeSAtIHQuaWVPZmZzZXRZO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3R5bGVbcHJvcF0gPSAodFtwcm9wXSA9IE1hdGgucm91bmQoIHZhbCAtIGRpZiAqICgoaSA9PT0gMCB8fCBpID09PSAyKSA/IDEgOiBtdWx0KSApKSArIFwicHhcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qIHRyYW5zbGF0ZXMgYSBzdXBlciBzbWFsbCBkZWNpbWFsIHRvIGEgc3RyaW5nIFdJVEhPVVQgc2NpZW50aWZpYyBub3RhdGlvblxuXHRcdFx0X3NhZmVEZWNpbWFsID0gZnVuY3Rpb24obikge1xuXHRcdFx0XHR2YXIgcyA9IChuIDwgMCA/IC1uIDogbikgKyBcIlwiLFxuXHRcdFx0XHRcdGEgPSBzLnNwbGl0KFwiZS1cIik7XG5cdFx0XHRcdHJldHVybiAobiA8IDAgPyBcIi0wLlwiIDogXCIwLlwiKSArIG5ldyBBcnJheShwYXJzZUludChhWzFdLCAxMCkgfHwgMCkuam9pbihcIjBcIikgKyBhWzBdLnNwbGl0KFwiLlwiKS5qb2luKFwiXCIpO1xuXHRcdFx0fSxcblx0XHRcdCovXG5cblx0XHRcdF9zZXRUcmFuc2Zvcm1SYXRpbyA9IF9pbnRlcm5hbHMuc2V0M0RUcmFuc2Zvcm1SYXRpbyA9IF9pbnRlcm5hbHMuc2V0VHJhbnNmb3JtUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy5kYXRhLCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIF9nc1RyYW5zZm9ybSBvYmplY3Rcblx0XHRcdFx0XHRzdHlsZSA9IHRoaXMudC5zdHlsZSxcblx0XHRcdFx0XHRhbmdsZSA9IHQucm90YXRpb24sXG5cdFx0XHRcdFx0cm90YXRpb25YID0gdC5yb3RhdGlvblgsXG5cdFx0XHRcdFx0cm90YXRpb25ZID0gdC5yb3RhdGlvblksXG5cdFx0XHRcdFx0c3ggPSB0LnNjYWxlWCxcblx0XHRcdFx0XHRzeSA9IHQuc2NhbGVZLFxuXHRcdFx0XHRcdHN6ID0gdC5zY2FsZVosXG5cdFx0XHRcdFx0eCA9IHQueCxcblx0XHRcdFx0XHR5ID0gdC55LFxuXHRcdFx0XHRcdHogPSB0LnosXG5cdFx0XHRcdFx0aXNTVkcgPSB0LnN2Zyxcblx0XHRcdFx0XHRwZXJzcGVjdGl2ZSA9IHQucGVyc3BlY3RpdmUsXG5cdFx0XHRcdFx0Zm9yY2UzRCA9IHQuZm9yY2UzRCxcblx0XHRcdFx0XHRhMTEsIGExMiwgYTEzLCBhMjEsIGEyMiwgYTIzLCBhMzEsIGEzMiwgYTMzLCBhNDEsIGE0MiwgYTQzLFxuXHRcdFx0XHRcdHpPcmlnaW4sIG1pbiwgY29zLCBzaW4sIHQxLCB0MiwgdHJhbnNmb3JtLCBjb21tYSwgemVybywgc2tldywgcm5kO1xuXHRcdFx0XHQvL2NoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgcmVuZGVyIGFzIDJEIChhbmQgU1ZHcyBtdXN0IHVzZSAyRCB3aGVuIF91c2VTVkdUcmFuc2Zvcm1BdHRyIGlzIHRydWUpXG5cdFx0XHRcdGlmICgoKCgodiA9PT0gMSB8fCB2ID09PSAwKSAmJiBmb3JjZTNEID09PSBcImF1dG9cIiAmJiAodGhpcy50d2Vlbi5fdG90YWxUaW1lID09PSB0aGlzLnR3ZWVuLl90b3RhbER1cmF0aW9uIHx8ICF0aGlzLnR3ZWVuLl90b3RhbFRpbWUpKSB8fCAhZm9yY2UzRCkgJiYgIXogJiYgIXBlcnNwZWN0aXZlICYmICFyb3RhdGlvblkgJiYgIXJvdGF0aW9uWCAmJiBzeiA9PT0gMSkgfHwgKF91c2VTVkdUcmFuc2Zvcm1BdHRyICYmIGlzU1ZHKSB8fCAhX3N1cHBvcnRzM0QpIHsgLy9vbiB0aGUgZmluYWwgcmVuZGVyICh3aGljaCBjb3VsZCBiZSAwIGZvciBhIGZyb20gdHdlZW4pLCBpZiB0aGVyZSBhcmUgbm8gM0QgYXNwZWN0cywgcmVuZGVyIGluIDJEIHRvIGZyZWUgdXAgbWVtb3J5IGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZXMuIENoZWNrIHRoZSB0d2VlbidzIHRvdGFsVGltZS90b3RhbER1cmF0aW9uIHRvbyBpbiBvcmRlciB0byBtYWtlIHN1cmUgaXQgZG9lc24ndCBoYXBwZW4gYmV0d2VlbiByZXBlYXRzIGlmIGl0J3MgYSByZXBlYXRpbmcgdHdlZW4uXG5cblx0XHRcdFx0XHQvLzJEXG5cdFx0XHRcdFx0aWYgKGFuZ2xlIHx8IHQuc2tld1ggfHwgaXNTVkcpIHtcblx0XHRcdFx0XHRcdGFuZ2xlICo9IF9ERUcyUkFEO1xuXHRcdFx0XHRcdFx0c2tldyA9IHQuc2tld1ggKiBfREVHMlJBRDtcblx0XHRcdFx0XHRcdHJuZCA9IDEwMDAwMDtcblx0XHRcdFx0XHRcdGExMSA9IE1hdGguY29zKGFuZ2xlKSAqIHN4O1xuXHRcdFx0XHRcdFx0YTIxID0gTWF0aC5zaW4oYW5nbGUpICogc3g7XG5cdFx0XHRcdFx0XHRhMTIgPSBNYXRoLnNpbihhbmdsZSAtIHNrZXcpICogLXN5O1xuXHRcdFx0XHRcdFx0YTIyID0gTWF0aC5jb3MoYW5nbGUgLSBza2V3KSAqIHN5O1xuXHRcdFx0XHRcdFx0aWYgKHNrZXcgJiYgdC5za2V3VHlwZSA9PT0gXCJzaW1wbGVcIikgeyAvL2J5IGRlZmF1bHQsIHdlIGNvbXBlbnNhdGUgc2tld2luZyBvbiB0aGUgb3RoZXIgYXhpcyB0byBtYWtlIGl0IGxvb2sgbW9yZSBuYXR1cmFsLCBidXQgeW91IGNhbiBzZXQgdGhlIHNrZXdUeXBlIHRvIFwic2ltcGxlXCIgdG8gdXNlIHRoZSB1bmNvbXBlbnNhdGVkIHNrZXdpbmcgdGhhdCBDU1MgZG9lc1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGgudGFuKHNrZXcpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGguc3FydCgxICsgdDEgKiB0MSk7XG5cdFx0XHRcdFx0XHRcdGExMiAqPSB0MTtcblx0XHRcdFx0XHRcdFx0YTIyICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRpZiAodC5za2V3WSkge1xuXHRcdFx0XHRcdFx0XHRcdGExMSAqPSB0MTtcblx0XHRcdFx0XHRcdFx0XHRhMjEgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChpc1NWRykge1xuXHRcdFx0XHRcdFx0XHR4ICs9IHQueE9yaWdpbiAtICh0LnhPcmlnaW4gKiBhMTEgKyB0LnlPcmlnaW4gKiBhMTIpICsgdC54T2Zmc2V0O1xuXHRcdFx0XHRcdFx0XHR5ICs9IHQueU9yaWdpbiAtICh0LnhPcmlnaW4gKiBhMjEgKyB0LnlPcmlnaW4gKiBhMjIpICsgdC55T2Zmc2V0O1xuXHRcdFx0XHRcdFx0XHRpZiAoX3VzZVNWR1RyYW5zZm9ybUF0dHIgJiYgKHQueFBlcmNlbnQgfHwgdC55UGVyY2VudCkpIHsgLy9UaGUgU1ZHIHNwZWMgZG9lc24ndCBzdXBwb3J0IHBlcmNlbnRhZ2UtYmFzZWQgdHJhbnNsYXRpb24gaW4gdGhlIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCBzbyB3ZSBtZXJnZSBpdCBpbnRvIHRoZSBtYXRyaXggdG8gc2ltdWxhdGUgaXQuXG5cdFx0XHRcdFx0XHRcdFx0bWluID0gdGhpcy50LmdldEJCb3goKTtcblx0XHRcdFx0XHRcdFx0XHR4ICs9IHQueFBlcmNlbnQgKiAwLjAxICogbWluLndpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdHkgKz0gdC55UGVyY2VudCAqIDAuMDEgKiBtaW4uaGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdG1pbiA9IDAuMDAwMDAxO1xuXHRcdFx0XHRcdFx0XHRpZiAoeCA8IG1pbikgaWYgKHggPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHkgPCBtaW4pIGlmICh5ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm0gPSAoKChhMTEgKiBybmQpIHwgMCkgLyBybmQpICsgXCIsXCIgKyAoKChhMjEgKiBybmQpIHwgMCkgLyBybmQpICsgXCIsXCIgKyAoKChhMTIgKiBybmQpIHwgMCkgLyBybmQpICsgXCIsXCIgKyAoKChhMjIgKiBybmQpIHwgMCkgLyBybmQpICsgXCIsXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XG5cdFx0XHRcdFx0XHRpZiAoaXNTVkcgJiYgX3VzZVNWR1RyYW5zZm9ybUF0dHIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy50LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcIm1hdHJpeChcIiArIHRyYW5zZm9ybSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvL3NvbWUgYnJvd3NlcnMgaGF2ZSBhIGhhcmQgdGltZSB3aXRoIHZlcnkgc21hbGwgdmFsdWVzIGxpa2UgMi40NDkyOTM1OTgyOTQ3MDY0ZS0xNiAobm90aWNlIHRoZSBcImUtXCIgdG93YXJkcyB0aGUgZW5kKSBhbmQgd291bGQgcmVuZGVyIHRoZSBvYmplY3Qgc2xpZ2h0bHkgb2ZmLiBTbyB3ZSByb3VuZCB0byA1IGRlY2ltYWwgcGxhY2VzLlxuXHRcdFx0XHRcdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoKHQueFBlcmNlbnQgfHwgdC55UGVyY2VudCkgPyBcInRyYW5zbGF0ZShcIiArIHQueFBlcmNlbnQgKyBcIiUsXCIgKyB0LnlQZXJjZW50ICsgXCIlKSBtYXRyaXgoXCIgOiBcIm1hdHJpeChcIikgKyB0cmFuc2Zvcm07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIG1hdHJpeChcIiA6IFwibWF0cml4KFwiKSArIHN4ICsgXCIsMCwwLFwiICsgc3kgKyBcIixcIiArIHggKyBcIixcIiArIHkgKyBcIilcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9pc0ZpcmVmb3gpIHsgLy9GaXJlZm94IGhhcyBhIGJ1ZyAoYXQgbGVhc3QgaW4gdjI1KSB0aGF0IGNhdXNlcyBpdCB0byByZW5kZXIgdGhlIHRyYW5zcGFyZW50IHBhcnQgb2YgMzItYml0IFBORyBpbWFnZXMgYXMgYmxhY2sgd2hlbiBkaXNwbGF5ZWQgaW5zaWRlIGFuIGlmcmFtZSBhbmQgdGhlIDNEIHNjYWxlIGlzIHZlcnkgc21hbGwgYW5kIGRvZXNuJ3QgY2hhbmdlIHN1ZmZpY2llbnRseSBlbm91Z2ggYmV0d2VlbiByZW5kZXJzIChsaWtlIGlmIHlvdSB1c2UgYSBQb3dlcjQuZWFzZUluT3V0IHRvIHNjYWxlIGZyb20gMCB0byAxIHdoZXJlIHRoZSBiZWdpbm5pbmcgdmFsdWVzIG9ubHkgY2hhbmdlIGEgdGlueSBhbW91bnQgdG8gYmVnaW4gdGhlIHR3ZWVuIGJlZm9yZSBhY2NlbGVyYXRpbmcpLiBJbiB0aGlzIGNhc2UsIHdlIGZvcmNlIHRoZSBzY2FsZSB0byBiZSAwLjAwMDAyIGluc3RlYWQgd2hpY2ggaXMgdmlzdWFsbHkgdGhlIHNhbWUgYnV0IHdvcmtzIGFyb3VuZCB0aGUgRmlyZWZveCBpc3N1ZS5cblx0XHRcdFx0XHRtaW4gPSAwLjAwMDE7XG5cdFx0XHRcdFx0aWYgKHN4IDwgbWluICYmIHN4ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0c3ggPSBzeiA9IDAuMDAwMDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzeSA8IG1pbiAmJiBzeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHN5ID0gc3ogPSAwLjAwMDAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGVyc3BlY3RpdmUgJiYgIXQueiAmJiAhdC5yb3RhdGlvblggJiYgIXQucm90YXRpb25ZKSB7IC8vRmlyZWZveCBoYXMgYSBidWcgdGhhdCBjYXVzZXMgZWxlbWVudHMgdG8gaGF2ZSBhbiBvZGQgc3VwZXItdGhpbiwgYnJva2VuL2RvdHRlZCBibGFjayBib3JkZXIgb24gZWxlbWVudHMgdGhhdCBoYXZlIGEgcGVyc3BlY3RpdmUgc2V0IGJ1dCBhcmVuJ3QgdXRpbGl6aW5nIDNEIHNwYWNlIChubyByb3RhdGlvblgsIHJvdGF0aW9uWSwgb3IgeikuXG5cdFx0XHRcdFx0XHRwZXJzcGVjdGl2ZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhbmdsZSB8fCB0LnNrZXdYKSB7XG5cdFx0XHRcdFx0YW5nbGUgKj0gX0RFRzJSQUQ7XG5cdFx0XHRcdFx0Y29zID0gYTExID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdHNpbiA9IGEyMSA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRpZiAodC5za2V3WCkge1xuXHRcdFx0XHRcdFx0YW5nbGUgLT0gdC5za2V3WCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdFx0aWYgKHQuc2tld1R5cGUgPT09IFwic2ltcGxlXCIpIHsgLy9ieSBkZWZhdWx0LCB3ZSBjb21wZW5zYXRlIHNrZXdpbmcgb24gdGhlIG90aGVyIGF4aXMgdG8gbWFrZSBpdCBsb29rIG1vcmUgbmF0dXJhbCwgYnV0IHlvdSBjYW4gc2V0IHRoZSBza2V3VHlwZSB0byBcInNpbXBsZVwiIHRvIHVzZSB0aGUgdW5jb21wZW5zYXRlZCBza2V3aW5nIHRoYXQgQ1NTIGRvZXNcblx0XHRcdFx0XHRcdFx0dDEgPSBNYXRoLnRhbih0LnNrZXdYICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGguc3FydCgxICsgdDEgKiB0MSk7XG5cdFx0XHRcdFx0XHRcdGNvcyAqPSB0MTtcblx0XHRcdFx0XHRcdFx0c2luICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRpZiAodC5za2V3WSkge1xuXHRcdFx0XHRcdFx0XHRcdGExMSAqPSB0MTtcblx0XHRcdFx0XHRcdFx0XHRhMjEgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YTEyID0gLXNpbjtcblx0XHRcdFx0XHRhMjIgPSBjb3M7XG5cblx0XHRcdFx0fSBlbHNlIGlmICghcm90YXRpb25ZICYmICFyb3RhdGlvblggJiYgc3ogPT09IDEgJiYgIXBlcnNwZWN0aXZlICYmICFpc1NWRykgeyAvL2lmIHdlJ3JlIG9ubHkgdHJhbnNsYXRpbmcgYW5kL29yIDJEIHNjYWxpbmcsIHRoaXMgaXMgZmFzdGVyLi4uXG5cdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgdHJhbnNsYXRlM2QoXCIgOiBcInRyYW5zbGF0ZTNkKFwiKSArIHggKyBcInB4LFwiICsgeSArIFwicHgsXCIgKyB6ICtcInB4KVwiICsgKChzeCAhPT0gMSB8fCBzeSAhPT0gMSkgPyBcIiBzY2FsZShcIiArIHN4ICsgXCIsXCIgKyBzeSArIFwiKVwiIDogXCJcIik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGExMSA9IGEyMiA9IDE7XG5cdFx0XHRcdFx0YTEyID0gYTIxID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBLRVkgIElOREVYICAgQUZGRUNUU1xuXHRcdFx0XHQvLyBhMTEgIDAgICAgICAgcm90YXRpb24sIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGEyMSAgMSAgICAgICByb3RhdGlvbiwgcm90YXRpb25ZLCBzY2FsZVhcblx0XHRcdFx0Ly8gYTMxICAyICAgICAgIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGE0MSAgMyAgICAgICByb3RhdGlvblksIHNjYWxlWFxuXHRcdFx0XHQvLyBhMTIgIDQgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMjIgIDUgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMzIgIDYgICAgICAgcm90YXRpb25YLCBzY2FsZVlcblx0XHRcdFx0Ly8gYTQyICA3ICAgICAgIHJvdGF0aW9uWCwgc2NhbGVZXG5cdFx0XHRcdC8vIGExMyAgOCAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEyMyAgOSAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEzMyAgMTAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGE0MyAgMTEgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgcGVyc3BlY3RpdmUsIHNjYWxlWlxuXHRcdFx0XHQvLyBhMTQgIDEyICAgICAgeCwgek9yaWdpbiwgc3ZnT3JpZ2luXG5cdFx0XHRcdC8vIGEyNCAgMTMgICAgICB5LCB6T3JpZ2luLCBzdmdPcmlnaW5cblx0XHRcdFx0Ly8gYTM0ICAxNCAgICAgIHosIHpPcmlnaW5cblx0XHRcdFx0Ly8gYTQ0ICAxNVxuXHRcdFx0XHQvLyByb3RhdGlvbjogTWF0aC5hdGFuMihhMjEsIGExMSlcblx0XHRcdFx0Ly8gcm90YXRpb25ZOiBNYXRoLmF0YW4yKGExMywgYTMzKSAob3IgTWF0aC5hdGFuMihhMTMsIGExMSkpXG5cdFx0XHRcdC8vIHJvdGF0aW9uWDogTWF0aC5hdGFuMihhMzIsIGEzMylcblx0XHRcdFx0YTMzID0gMTtcblx0XHRcdFx0YTEzID0gYTIzID0gYTMxID0gYTMyID0gYTQxID0gYTQyID0gMDtcblx0XHRcdFx0YTQzID0gKHBlcnNwZWN0aXZlKSA/IC0xIC8gcGVyc3BlY3RpdmUgOiAwO1xuXHRcdFx0XHR6T3JpZ2luID0gdC56T3JpZ2luO1xuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMTsgLy90aHJlc2hvbGQgYmVsb3cgd2hpY2ggYnJvd3NlcnMgdXNlIHNjaWVudGlmaWMgbm90YXRpb24gd2hpY2ggd29uJ3Qgd29yay5cblx0XHRcdFx0Y29tbWEgPSBcIixcIjtcblx0XHRcdFx0emVybyA9IFwiMFwiO1xuXHRcdFx0XHRhbmdsZSA9IHJvdGF0aW9uWSAqIF9ERUcyUkFEO1xuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdGEzMSA9IC1zaW47XG5cdFx0XHRcdFx0YTQxID0gYTQzKi1zaW47XG5cdFx0XHRcdFx0YTEzID0gYTExKnNpbjtcblx0XHRcdFx0XHRhMjMgPSBhMjEqc2luO1xuXHRcdFx0XHRcdGEzMyA9IGNvcztcblx0XHRcdFx0XHRhNDMgKj0gY29zO1xuXHRcdFx0XHRcdGExMSAqPSBjb3M7XG5cdFx0XHRcdFx0YTIxICo9IGNvcztcblx0XHRcdFx0fVxuXHRcdFx0XHRhbmdsZSA9IHJvdGF0aW9uWCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdHQxID0gYTEyKmNvcythMTMqc2luO1xuXHRcdFx0XHRcdHQyID0gYTIyKmNvcythMjMqc2luO1xuXHRcdFx0XHRcdGEzMiA9IGEzMypzaW47XG5cdFx0XHRcdFx0YTQyID0gYTQzKnNpbjtcblx0XHRcdFx0XHRhMTMgPSBhMTIqLXNpbithMTMqY29zO1xuXHRcdFx0XHRcdGEyMyA9IGEyMiotc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0YTMzID0gYTMzKmNvcztcblx0XHRcdFx0XHRhNDMgPSBhNDMqY29zO1xuXHRcdFx0XHRcdGExMiA9IHQxO1xuXHRcdFx0XHRcdGEyMiA9IHQyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeiAhPT0gMSkge1xuXHRcdFx0XHRcdGExMyo9c3o7XG5cdFx0XHRcdFx0YTIzKj1zejtcblx0XHRcdFx0XHRhMzMqPXN6O1xuXHRcdFx0XHRcdGE0Myo9c3o7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN5ICE9PSAxKSB7XG5cdFx0XHRcdFx0YTEyKj1zeTtcblx0XHRcdFx0XHRhMjIqPXN5O1xuXHRcdFx0XHRcdGEzMio9c3k7XG5cdFx0XHRcdFx0YTQyKj1zeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3ggIT09IDEpIHtcblx0XHRcdFx0XHRhMTEqPXN4O1xuXHRcdFx0XHRcdGEyMSo9c3g7XG5cdFx0XHRcdFx0YTMxKj1zeDtcblx0XHRcdFx0XHRhNDEqPXN4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHpPcmlnaW4gfHwgaXNTVkcpIHtcblx0XHRcdFx0XHRpZiAoek9yaWdpbikge1xuXHRcdFx0XHRcdFx0eCArPSBhMTMqLXpPcmlnaW47XG5cdFx0XHRcdFx0XHR5ICs9IGEyMyotek9yaWdpbjtcblx0XHRcdFx0XHRcdHogKz0gYTMzKi16T3JpZ2luK3pPcmlnaW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpc1NWRykgeyAvL2R1ZSB0byBidWdzIGluIHNvbWUgYnJvd3NlcnMsIHdlIG5lZWQgdG8gbWFuYWdlIHRoZSB0cmFuc2Zvcm0tb3JpZ2luIG9mIFNWRyBtYW51YWxseVxuXHRcdFx0XHRcdFx0eCArPSB0LnhPcmlnaW4gLSAodC54T3JpZ2luICogYTExICsgdC55T3JpZ2luICogYTEyKSArIHQueE9mZnNldDtcblx0XHRcdFx0XHRcdHkgKz0gdC55T3JpZ2luIC0gKHQueE9yaWdpbiAqIGEyMSArIHQueU9yaWdpbiAqIGEyMikgKyB0LnlPZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh4IDwgbWluICYmIHggPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR4ID0gemVybztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHkgPCBtaW4gJiYgeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHkgPSB6ZXJvO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeiA8IG1pbiAmJiB6ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0eiA9IDA7IC8vZG9uJ3QgdXNlIHN0cmluZyBiZWNhdXNlIHdlIGNhbGN1bGF0ZSBwZXJzcGVjdGl2ZSBsYXRlciBhbmQgbmVlZCB0aGUgbnVtYmVyLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vb3B0aW1pemVkIHdheSBvZiBjb25jYXRlbmF0aW5nIGFsbCB0aGUgdmFsdWVzIGludG8gYSBzdHJpbmcuIElmIHdlIGRvIGl0IGFsbCBpbiBvbmUgc2hvdCwgaXQncyBzbG93ZXIgYmVjYXVzZSBvZiB0aGUgd2F5IGJyb3dzZXJzIGhhdmUgdG8gY3JlYXRlIHRlbXAgc3RyaW5ncyBhbmQgdGhlIHdheSBpdCBhZmZlY3RzIG1lbW9yeS4gSWYgd2UgZG8gaXQgcGllY2UtYnktcGllY2Ugd2l0aCArPSwgaXQncyBhIGJpdCBzbG93ZXIgdG9vLiBXZSBmb3VuZCB0aGF0IGRvaW5nIGl0IGluIHRoZXNlIHNpemVkIGNodW5rcyB3b3JrcyBiZXN0IG92ZXJhbGw6XG5cdFx0XHRcdHRyYW5zZm9ybSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIG1hdHJpeDNkKFwiIDogXCJtYXRyaXgzZChcIik7XG5cdFx0XHRcdHRyYW5zZm9ybSArPSAoKGExMSA8IG1pbiAmJiBhMTEgPiAtbWluKSA/IHplcm8gOiBhMTEpICsgY29tbWEgKyAoKGEyMSA8IG1pbiAmJiBhMjEgPiAtbWluKSA/IHplcm8gOiBhMjEpICsgY29tbWEgKyAoKGEzMSA8IG1pbiAmJiBhMzEgPiAtbWluKSA/IHplcm8gOiBhMzEpO1xuXHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGE0MSA8IG1pbiAmJiBhNDEgPiAtbWluKSA/IHplcm8gOiBhNDEpICsgY29tbWEgKyAoKGExMiA8IG1pbiAmJiBhMTIgPiAtbWluKSA/IHplcm8gOiBhMTIpICsgY29tbWEgKyAoKGEyMiA8IG1pbiAmJiBhMjIgPiAtbWluKSA/IHplcm8gOiBhMjIpO1xuXHRcdFx0XHRpZiAocm90YXRpb25YIHx8IHJvdGF0aW9uWSB8fCBzeiAhPT0gMSkgeyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAob2Z0ZW4gdGhlcmUncyBubyByb3RhdGlvblggb3Igcm90YXRpb25ZLCBzbyB3ZSBjYW4gc2tpcCB0aGVzZSBjYWxjdWxhdGlvbnMpXG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IGNvbW1hICsgKChhMzIgPCBtaW4gJiYgYTMyID4gLW1pbikgPyB6ZXJvIDogYTMyKSArIGNvbW1hICsgKChhNDIgPCBtaW4gJiYgYTQyID4gLW1pbikgPyB6ZXJvIDogYTQyKSArIGNvbW1hICsgKChhMTMgPCBtaW4gJiYgYTEzID4gLW1pbikgPyB6ZXJvIDogYTEzKTtcblx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGEyMyA8IG1pbiAmJiBhMjMgPiAtbWluKSA/IHplcm8gOiBhMjMpICsgY29tbWEgKyAoKGEzMyA8IG1pbiAmJiBhMzMgPiAtbWluKSA/IHplcm8gOiBhMzMpICsgY29tbWEgKyAoKGE0MyA8IG1pbiAmJiBhNDMgPiAtbWluKSA/IHplcm8gOiBhNDMpICsgY29tbWE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IFwiLDAsMCwwLDAsMSwwLFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zZm9ybSArPSB4ICsgY29tbWEgKyB5ICsgY29tbWEgKyB6ICsgY29tbWEgKyAocGVyc3BlY3RpdmUgPyAoMSArICgteiAvIHBlcnNwZWN0aXZlKSkgOiAxKSArIFwiKVwiO1xuXG5cdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblx0XHRcdH07XG5cblx0XHRwID0gVHJhbnNmb3JtLnByb3RvdHlwZTtcblx0XHRwLnggPSBwLnkgPSBwLnogPSBwLnNrZXdYID0gcC5za2V3WSA9IHAucm90YXRpb24gPSBwLnJvdGF0aW9uWCA9IHAucm90YXRpb25ZID0gcC56T3JpZ2luID0gcC54UGVyY2VudCA9IHAueVBlcmNlbnQgPSBwLnhPZmZzZXQgPSBwLnlPZmZzZXQgPSAwO1xuXHRcdHAuc2NhbGVYID0gcC5zY2FsZVkgPSBwLnNjYWxlWiA9IDE7XG5cblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ0cmFuc2Zvcm0sc2NhbGUsc2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHoscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxyb3RhdGlvblosc2tld1gsc2tld1ksc2hvcnRSb3RhdGlvbixzaG9ydFJvdGF0aW9uWCxzaG9ydFJvdGF0aW9uWSxzaG9ydFJvdGF0aW9uWix0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlLGRpcmVjdGlvbmFsUm90YXRpb24scGFyc2VUcmFuc2Zvcm0sZm9yY2UzRCxza2V3VHlwZSx4UGVyY2VudCx5UGVyY2VudCxzbW9vdGhPcmlnaW5cIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRpZiAoY3NzcC5fbGFzdFBhcnNlZFRyYW5zZm9ybSA9PT0gdmFycykgeyByZXR1cm4gcHQ7IH0gLy9vbmx5IG5lZWQgdG8gcGFyc2UgdGhlIHRyYW5zZm9ybSBvbmNlLCBhbmQgb25seSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBpdC5cblx0XHRcdGNzc3AuX2xhc3RQYXJzZWRUcmFuc2Zvcm0gPSB2YXJzO1xuXHRcdFx0dmFyIG9yaWdpbmFsR1NUcmFuc2Zvcm0gPSB0Ll9nc1RyYW5zZm9ybSxcblx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0aSA9IF90cmFuc2Zvcm1Qcm9wcy5sZW5ndGgsXG5cdFx0XHRcdHYgPSB2YXJzLFxuXHRcdFx0XHRlbmRSb3RhdGlvbnMgPSB7fSxcblx0XHRcdFx0dHJhbnNmb3JtT3JpZ2luU3RyaW5nID0gXCJ0cmFuc2Zvcm1PcmlnaW5cIixcblx0XHRcdFx0bTEsIG0yLCBjb3B5LCBvcmlnLCBoYXMzRCwgaGFzQ2hhbmdlLCBkciwgeCwgeSwgbWF0cml4O1xuXHRcdFx0aWYgKHZhcnMuZGlzcGxheSkgeyAvL2lmIHRoZSB1c2VyIGlzIHNldHRpbmcgZGlzcGxheSBkdXJpbmcgdGhpcyB0d2VlbiwgaXQgbWF5IG5vdCBiZSBpbnN0YW50aWF0ZWQgeWV0IGJ1dCB3ZSBtdXN0IGZvcmNlIGl0IGhlcmUgaW4gb3JkZXIgdG8gZ2V0IGFjY3VyYXRlIHJlYWRpbmdzLiBJZiBkaXNwbGF5IGlzIFwibm9uZVwiLCBzb21lIGJyb3dzZXJzIHJlZnVzZSB0byByZXBvcnQgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGNvcnJlY3RseS5cblx0XHRcdFx0Y29weSA9IF9nZXRTdHlsZSh0LCBcImRpc3BsYXlcIik7XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdFx0XHRcdG0xID0gX2dldFRyYW5zZm9ybSh0LCBfY3MsIHRydWUsIHZhcnMucGFyc2VUcmFuc2Zvcm0pO1xuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gY29weTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG0xID0gX2dldFRyYW5zZm9ybSh0LCBfY3MsIHRydWUsIHZhcnMucGFyc2VUcmFuc2Zvcm0pO1xuXHRcdFx0fVxuXHRcdFx0Y3NzcC5fdHJhbnNmb3JtID0gbTE7XG5cdFx0XHRpZiAodHlwZW9mKHYudHJhbnNmb3JtKSA9PT0gXCJzdHJpbmdcIiAmJiBfdHJhbnNmb3JtUHJvcCkgeyAvL2ZvciB2YWx1ZXMgbGlrZSB0cmFuc2Zvcm06XCJyb3RhdGUoNjBkZWcpIHNjYWxlKDAuNSwgMC44KVwiXG5cdFx0XHRcdGNvcHkgPSBfdGVtcERpdi5zdHlsZTsgLy9kb24ndCB1c2UgdGhlIG9yaWdpbmFsIHRhcmdldCBiZWNhdXNlIGl0IG1pZ2h0IGJlIFNWRyBpbiB3aGljaCBjYXNlIHNvbWUgYnJvd3NlcnMgZG9uJ3QgcmVwb3J0IGNvbXB1dGVkIHN0eWxlIGNvcnJlY3RseS5cblx0XHRcdFx0Y29weVtfdHJhbnNmb3JtUHJvcF0gPSB2LnRyYW5zZm9ybTtcblx0XHRcdFx0Y29weS5kaXNwbGF5ID0gXCJibG9ja1wiOyAvL2lmIGRpc3BsYXkgaXMgXCJub25lXCIsIHRoZSBicm93c2VyIG9mdGVuIHJlZnVzZXMgdG8gcmVwb3J0IHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBjb3JyZWN0bHkuXG5cdFx0XHRcdGNvcHkucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0XHRcdF9kb2MuYm9keS5hcHBlbmRDaGlsZChfdGVtcERpdik7XG5cdFx0XHRcdG0yID0gX2dldFRyYW5zZm9ybShfdGVtcERpdiwgbnVsbCwgZmFsc2UpO1xuXHRcdFx0XHRpZiAobTEuc3ZnKSB7IC8vaWYgaXQncyBhbiBTVkcgZWxlbWVudCwgeC95IHBhcnQgb2YgdGhlIG1hdHJpeCB3aWxsIGJlIGFmZmVjdGVkIGJ5IHdoYXRldmVyIHdlIHVzZSBhcyB0aGUgb3JpZ2luIGFuZCB0aGUgb2Zmc2V0cywgc28gY29tcGVuc2F0ZSBoZXJlLi4uXG5cdFx0XHRcdFx0eCA9IG0xLnhPcmlnaW47XG5cdFx0XHRcdFx0eSA9IG0xLnlPcmlnaW47XG5cdFx0XHRcdFx0bTIueCAtPSBtMS54T2Zmc2V0O1xuXHRcdFx0XHRcdG0yLnkgLT0gbTEueU9mZnNldDtcblx0XHRcdFx0XHRpZiAodi50cmFuc2Zvcm1PcmlnaW4gfHwgdi5zdmdPcmlnaW4pIHsgLy9pZiB0aGlzIHR3ZWVuIGlzIGFsdGVyaW5nIHRoZSBvcmlnaW4sIHdlIG11c3QgZmFjdG9yIHRoYXQgaW4gaGVyZS4gVGhlIGFjdHVhbCB3b3JrIG9mIHJlY29yZGluZyB0aGUgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcyBhbmQgc2V0dGluZyB1cCB0aGUgUHJvcFR3ZWVuIGlzIGRvbmUgbGF0ZXIgKHN0aWxsIGluc2lkZSB0aGlzIGZ1bmN0aW9uKSBzbyB3ZSBjYW5ub3QgbGVhdmUgdGhlIGNoYW5nZXMgaW50YWN0IGhlcmUgLSB3ZSBvbmx5IHdhbnQgdG8gdXBkYXRlIHRoZSB4L3kgYWNjb3JkaW5nbHkuXG5cdFx0XHRcdFx0XHRvcmlnID0ge307XG5cdFx0XHRcdFx0XHRfcGFyc2VTVkdPcmlnaW4odCwgX3BhcnNlUG9zaXRpb24odi50cmFuc2Zvcm1PcmlnaW4pLCBvcmlnLCB2LnN2Z09yaWdpbiwgdi5zbW9vdGhPcmlnaW4sIHRydWUpO1xuXHRcdFx0XHRcdFx0eCA9IG9yaWcueE9yaWdpbjtcblx0XHRcdFx0XHRcdHkgPSBvcmlnLnlPcmlnaW47XG5cdFx0XHRcdFx0XHRtMi54IC09IG9yaWcueE9mZnNldCAtIG0xLnhPZmZzZXQ7XG5cdFx0XHRcdFx0XHRtMi55IC09IG9yaWcueU9mZnNldCAtIG0xLnlPZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh4IHx8IHkpIHtcblx0XHRcdFx0XHRcdG1hdHJpeCA9IF9nZXRNYXRyaXgoX3RlbXBEaXYpO1xuXHRcdFx0XHRcdFx0bTIueCAtPSB4IC0gKHggKiBtYXRyaXhbMF0gKyB5ICogbWF0cml4WzJdKTtcblx0XHRcdFx0XHRcdG0yLnkgLT0geSAtICh4ICogbWF0cml4WzFdICsgeSAqIG1hdHJpeFszXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdF9kb2MuYm9keS5yZW1vdmVDaGlsZChfdGVtcERpdik7XG5cdFx0XHRcdGlmICghbTIucGVyc3BlY3RpdmUpIHtcblx0XHRcdFx0XHRtMi5wZXJzcGVjdGl2ZSA9IG0xLnBlcnNwZWN0aXZlOyAvL3R3ZWVuaW5nIHRvIG5vIHBlcnNwZWN0aXZlIGdpdmVzIHZlcnkgdW5pbnR1aXRpdmUgcmVzdWx0cyAtIGp1c3Qga2VlcCB0aGUgc2FtZSBwZXJzcGVjdGl2ZSBpbiB0aGF0IGNhc2UuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYueFBlcmNlbnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdG0yLnhQZXJjZW50ID0gX3BhcnNlVmFsKHYueFBlcmNlbnQsIG0xLnhQZXJjZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi55UGVyY2VudCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0bTIueVBlcmNlbnQgPSBfcGFyc2VWYWwodi55UGVyY2VudCwgbTEueVBlcmNlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2KSA9PT0gXCJvYmplY3RcIikgeyAvL2ZvciB2YWx1ZXMgbGlrZSBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHgsIHksIHNrZXdYLCBhbmQgc2tld1kgb3IgdHJhbnNmb3JtOnsuLi59IChvYmplY3QpXG5cdFx0XHRcdG0yID0ge3NjYWxlWDpfcGFyc2VWYWwoKHYuc2NhbGVYICE9IG51bGwpID8gdi5zY2FsZVggOiB2LnNjYWxlLCBtMS5zY2FsZVgpLFxuXHRcdFx0XHRcdHNjYWxlWTpfcGFyc2VWYWwoKHYuc2NhbGVZICE9IG51bGwpID8gdi5zY2FsZVkgOiB2LnNjYWxlLCBtMS5zY2FsZVkpLFxuXHRcdFx0XHRcdHNjYWxlWjpfcGFyc2VWYWwodi5zY2FsZVosIG0xLnNjYWxlWiksXG5cdFx0XHRcdFx0eDpfcGFyc2VWYWwodi54LCBtMS54KSxcblx0XHRcdFx0XHR5Ol9wYXJzZVZhbCh2LnksIG0xLnkpLFxuXHRcdFx0XHRcdHo6X3BhcnNlVmFsKHYueiwgbTEueiksXG5cdFx0XHRcdFx0eFBlcmNlbnQ6X3BhcnNlVmFsKHYueFBlcmNlbnQsIG0xLnhQZXJjZW50KSxcblx0XHRcdFx0XHR5UGVyY2VudDpfcGFyc2VWYWwodi55UGVyY2VudCwgbTEueVBlcmNlbnQpLFxuXHRcdFx0XHRcdHBlcnNwZWN0aXZlOl9wYXJzZVZhbCh2LnRyYW5zZm9ybVBlcnNwZWN0aXZlLCBtMS5wZXJzcGVjdGl2ZSl9O1xuXHRcdFx0XHRkciA9IHYuZGlyZWN0aW9uYWxSb3RhdGlvbjtcblx0XHRcdFx0aWYgKGRyICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mKGRyKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHRcdFx0Zm9yIChjb3B5IGluIGRyKSB7XG5cdFx0XHRcdFx0XHRcdHZbY29weV0gPSBkcltjb3B5XTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0di5yb3RhdGlvbiA9IGRyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mKHYueCkgPT09IFwic3RyaW5nXCIgJiYgdi54LmluZGV4T2YoXCIlXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdG0yLnggPSAwO1xuXHRcdFx0XHRcdG0yLnhQZXJjZW50ID0gX3BhcnNlVmFsKHYueCwgbTEueFBlcmNlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2Yodi55KSA9PT0gXCJzdHJpbmdcIiAmJiB2LnkuaW5kZXhPZihcIiVcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0bTIueSA9IDA7XG5cdFx0XHRcdFx0bTIueVBlcmNlbnQgPSBfcGFyc2VWYWwodi55LCBtMS55UGVyY2VudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtMi5yb3RhdGlvbiA9IF9wYXJzZUFuZ2xlKChcInJvdGF0aW9uXCIgaW4gdikgPyB2LnJvdGF0aW9uIDogKFwic2hvcnRSb3RhdGlvblwiIGluIHYpID8gdi5zaG9ydFJvdGF0aW9uICsgXCJfc2hvcnRcIiA6IChcInJvdGF0aW9uWlwiIGluIHYpID8gdi5yb3RhdGlvblogOiBtMS5yb3RhdGlvbiAtIG0xLnNrZXdZLCBtMS5yb3RhdGlvbiAtIG0xLnNrZXdZLCBcInJvdGF0aW9uXCIsIGVuZFJvdGF0aW9ucyk7IC8vc2VlIG5vdGVzIGJlbG93IGFib3V0IHNrZXdZIGZvciB3aHkgd2Ugc3VidHJhY3QgaXQgZnJvbSByb3RhdGlvbiBoZXJlXG5cdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdG0yLnJvdGF0aW9uWCA9IF9wYXJzZUFuZ2xlKChcInJvdGF0aW9uWFwiIGluIHYpID8gdi5yb3RhdGlvblggOiAoXCJzaG9ydFJvdGF0aW9uWFwiIGluIHYpID8gdi5zaG9ydFJvdGF0aW9uWCArIFwiX3Nob3J0XCIgOiBtMS5yb3RhdGlvblggfHwgMCwgbTEucm90YXRpb25YLCBcInJvdGF0aW9uWFwiLCBlbmRSb3RhdGlvbnMpO1xuXHRcdFx0XHRcdG0yLnJvdGF0aW9uWSA9IF9wYXJzZUFuZ2xlKChcInJvdGF0aW9uWVwiIGluIHYpID8gdi5yb3RhdGlvblkgOiAoXCJzaG9ydFJvdGF0aW9uWVwiIGluIHYpID8gdi5zaG9ydFJvdGF0aW9uWSArIFwiX3Nob3J0XCIgOiBtMS5yb3RhdGlvblkgfHwgMCwgbTEucm90YXRpb25ZLCBcInJvdGF0aW9uWVwiLCBlbmRSb3RhdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG0yLnNrZXdYID0gX3BhcnNlQW5nbGUodi5za2V3WCwgbTEuc2tld1ggLSBtMS5za2V3WSk7IC8vc2VlIG5vdGVzIGJlbG93IGFib3V0IHNrZXdZIGFuZCB3aHkgd2Ugc3VidHJhY3QgaXQgZnJvbSBza2V3WCBoZXJlXG5cblx0XHRcdFx0Ly9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgY29tYmluZSBhbGwgc2tld2luZyBpbnRvIHRoZSBza2V3WCBhbmQgcm90YXRpb24gdmFsdWVzLCBpZ25vcmluZyBza2V3WSBidXQgd2UgbXVzdCBzdGlsbCByZWNvcmQgaXQgc28gdGhhdCB3ZSBjYW4gZGlzY2VybiBob3cgbXVjaCBvZiB0aGUgb3ZlcmFsbCBza2V3IGlzIGF0dHJpYnV0ZWQgdG8gc2tld1ggdnMuIHNrZXdZLiBPdGhlcndpc2UsIGlmIHRoZSBza2V3WSB3b3VsZCBhbHdheXMgYWN0IHJlbGF0aXZlICh0d2VlbiBza2V3WSB0byAxMGRlZywgZm9yIGV4YW1wbGUsIG11bHRpcGxlIHRpbWVzIGFuZCBpZiB3ZSBhbHdheXMgY29tYmluZSB0aGluZ3MgaW50byBza2V3WCwgd2UgY2FuJ3QgcmVtZW1iZXIgdGhhdCBza2V3WSB3YXMgMTAgZnJvbSBsYXN0IHRpbWUpLiBSZW1lbWJlciwgYSBza2V3WSBvZiAxMCBkZWdyZWVzIGxvb2tzIHRoZSBzYW1lIGFzIGEgcm90YXRpb24gb2YgMTAgZGVncmVlcyBwbHVzIGEgc2tld1ggb2YgLTEwIGRlZ3JlZXMuXG5cdFx0XHRcdGlmICgobTIuc2tld1kgPSBfcGFyc2VBbmdsZSh2LnNrZXdZLCBtMS5za2V3WSkpKSB7XG5cdFx0XHRcdFx0bTIuc2tld1ggKz0gbTIuc2tld1k7XG5cdFx0XHRcdFx0bTIucm90YXRpb24gKz0gbTIuc2tld1k7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChfc3VwcG9ydHMzRCAmJiB2LmZvcmNlM0QgIT0gbnVsbCkge1xuXHRcdFx0XHRtMS5mb3JjZTNEID0gdi5mb3JjZTNEO1xuXHRcdFx0XHRoYXNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRtMS5za2V3VHlwZSA9IHYuc2tld1R5cGUgfHwgbTEuc2tld1R5cGUgfHwgQ1NTUGx1Z2luLmRlZmF1bHRTa2V3VHlwZTtcblxuXHRcdFx0aGFzM0QgPSAobTEuZm9yY2UzRCB8fCBtMS56IHx8IG0xLnJvdGF0aW9uWCB8fCBtMS5yb3RhdGlvblkgfHwgbTIueiB8fCBtMi5yb3RhdGlvblggfHwgbTIucm90YXRpb25ZIHx8IG0yLnBlcnNwZWN0aXZlKTtcblx0XHRcdGlmICghaGFzM0QgJiYgdi5zY2FsZSAhPSBudWxsKSB7XG5cdFx0XHRcdG0yLnNjYWxlWiA9IDE7IC8vbm8gbmVlZCB0byB0d2VlbiBzY2FsZVouXG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRwID0gX3RyYW5zZm9ybVByb3BzW2ldO1xuXHRcdFx0XHRvcmlnID0gbTJbcF0gLSBtMVtwXTtcblx0XHRcdFx0aWYgKG9yaWcgPiBtaW4gfHwgb3JpZyA8IC1taW4gfHwgdltwXSAhPSBudWxsIHx8IF9mb3JjZVBUW3BdICE9IG51bGwpIHtcblx0XHRcdFx0XHRoYXNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihtMSwgcCwgbTFbcF0sIG9yaWcsIHB0KTtcblx0XHRcdFx0XHRpZiAocCBpbiBlbmRSb3RhdGlvbnMpIHtcblx0XHRcdFx0XHRcdHB0LmUgPSBlbmRSb3RhdGlvbnNbcF07IC8vZGlyZWN0aW9uYWwgcm90YXRpb25zIHR5cGljYWxseSBoYXZlIGNvbXBlbnNhdGVkIHZhbHVlcyBkdXJpbmcgdGhlIHR3ZWVuLCBidXQgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhleSBlbmQgYXQgZXhhY3RseSB3aGF0IHRoZSB1c2VyIHJlcXVlc3RlZFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdC54czAgPSAwOyAvL2Vuc3VyZXMgdGhlIHZhbHVlIHN0YXlzIG51bWVyaWMgaW4gc2V0UmF0aW8oKVxuXHRcdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHB0Lm4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG9yaWcgPSB2LnRyYW5zZm9ybU9yaWdpbjtcblx0XHRcdGlmIChtMS5zdmcgJiYgKG9yaWcgfHwgdi5zdmdPcmlnaW4pKSB7XG5cdFx0XHRcdHggPSBtMS54T2Zmc2V0OyAvL3doZW4gd2UgY2hhbmdlIHRoZSBvcmlnaW4sIGluIG9yZGVyIHRvIHByZXZlbnQgdGhpbmdzIGZyb20ganVtcGluZyB3ZSBhZGp1c3QgdGhlIHgveSBzbyB3ZSBtdXN0IHJlY29yZCB0aG9zZSBoZXJlIHNvIHRoYXQgd2UgY2FuIGNyZWF0ZSBQcm9wVHdlZW5zIGZvciB0aGVtIGFuZCBmbGlwIHRoZW0gYXQgdGhlIHNhbWUgdGltZSBhcyB0aGUgb3JpZ2luXG5cdFx0XHRcdHkgPSBtMS55T2Zmc2V0O1xuXHRcdFx0XHRfcGFyc2VTVkdPcmlnaW4odCwgX3BhcnNlUG9zaXRpb24ob3JpZyksIG0yLCB2LnN2Z09yaWdpbiwgdi5zbW9vdGhPcmlnaW4pO1xuXHRcdFx0XHRwdCA9IF9hZGROb25Ud2VlbmluZ051bWVyaWNQVChtMSwgXCJ4T3JpZ2luXCIsIChvcmlnaW5hbEdTVHJhbnNmb3JtID8gbTEgOiBtMikueE9yaWdpbiwgbTIueE9yaWdpbiwgcHQsIHRyYW5zZm9ybU9yaWdpblN0cmluZyk7IC8vbm90ZTogaWYgdGhlcmUgd2Fzbid0IGEgdHJhbnNmb3JtT3JpZ2luIGRlZmluZWQgeWV0LCBqdXN0IHN0YXJ0IHdpdGggdGhlIGRlc3RpbmF0aW9uIG9uZTsgaXQncyB3YXN0ZWZ1bCBvdGhlcndpc2UsIGFuZCBpdCBjYXVzZXMgcHJvYmxlbXMgd2l0aCBmcm9tVG8oKSB0d2VlbnMuIEZvciBleGFtcGxlLCBUd2VlbkxpdGUudG8oXCIjd2hlZWxcIiwgMywge3JvdGF0aW9uOjE4MCwgdHJhbnNmb3JtT3JpZ2luOlwiNTAlIDUwJVwiLCBkZWxheToxfSk7IFR3ZWVuTGl0ZS5mcm9tVG8oXCIjd2hlZWxcIiwgMywge3NjYWxlOjAuNSwgdHJhbnNmb3JtT3JpZ2luOlwiNTAlIDUwJVwifSwge3NjYWxlOjEsIGRlbGF5OjJ9KTsgd291bGQgY2F1c2UgYSBqdW1wIHdoZW4gdGhlIGZyb20gdmFsdWVzIHJldmVydCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSAybmQgdHdlZW4uXG5cdFx0XHRcdHB0ID0gX2FkZE5vblR3ZWVuaW5nTnVtZXJpY1BUKG0xLCBcInlPcmlnaW5cIiwgKG9yaWdpbmFsR1NUcmFuc2Zvcm0gPyBtMSA6IG0yKS55T3JpZ2luLCBtMi55T3JpZ2luLCBwdCwgdHJhbnNmb3JtT3JpZ2luU3RyaW5nKTtcblx0XHRcdFx0aWYgKHggIT09IG0xLnhPZmZzZXQgfHwgeSAhPT0gbTEueU9mZnNldCkge1xuXHRcdFx0XHRcdHB0ID0gX2FkZE5vblR3ZWVuaW5nTnVtZXJpY1BUKG0xLCBcInhPZmZzZXRcIiwgKG9yaWdpbmFsR1NUcmFuc2Zvcm0gPyB4IDogbTEueE9mZnNldCksIG0xLnhPZmZzZXQsIHB0LCB0cmFuc2Zvcm1PcmlnaW5TdHJpbmcpO1xuXHRcdFx0XHRcdHB0ID0gX2FkZE5vblR3ZWVuaW5nTnVtZXJpY1BUKG0xLCBcInlPZmZzZXRcIiwgKG9yaWdpbmFsR1NUcmFuc2Zvcm0gPyB5IDogbTEueU9mZnNldCksIG0xLnlPZmZzZXQsIHB0LCB0cmFuc2Zvcm1PcmlnaW5TdHJpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9yaWcgPSBfdXNlU1ZHVHJhbnNmb3JtQXR0ciA/IG51bGwgOiBcIjBweCAwcHhcIjsgLy9jZXJ0YWluIGJyb3dzZXJzIChsaWtlIGZpcmVmb3gpIGNvbXBsZXRlbHkgYm90Y2ggdHJhbnNmb3JtLW9yaWdpbiwgc28gd2UgbXVzdCByZW1vdmUgaXQgdG8gcHJldmVudCBpdCBmcm9tIGNvbnRhbWluYXRpbmcgdHJhbnNmb3Jtcy4gV2UgbWFuYWdlIGl0IG91cnNlbHZlcyB3aXRoIHhPcmlnaW4gYW5kIHlPcmlnaW5cblx0XHRcdH1cblx0XHRcdGlmIChvcmlnIHx8IChfc3VwcG9ydHMzRCAmJiBoYXMzRCAmJiBtMS56T3JpZ2luKSkgeyAvL2lmIGFueXRoaW5nIDNEIGlzIGhhcHBlbmluZyBhbmQgdGhlcmUncyBhIHRyYW5zZm9ybU9yaWdpbiB3aXRoIGEgeiBjb21wb25lbnQgdGhhdCdzIG5vbi16ZXJvLCB3ZSBtdXN0IGVuc3VyZSB0aGF0IHRoZSB0cmFuc2Zvcm1PcmlnaW4ncyB6LWNvbXBvbmVudCBpcyBzZXQgdG8gMCBzbyB0aGF0IHdlIGNhbiBtYW51YWxseSBkbyB0aG9zZSBjYWxjdWxhdGlvbnMgdG8gZ2V0IGFyb3VuZCBTYWZhcmkgYnVncy4gRXZlbiBpZiB0aGUgdXNlciBkaWRuJ3Qgc3BlY2lmaWNhbGx5IGRlZmluZSBhIFwidHJhbnNmb3JtT3JpZ2luXCIgaW4gdGhpcyBwYXJ0aWN1bGFyIHR3ZWVuIChtYXliZSB0aGV5IGRpZCBpdCB2aWEgY3NzIGRpcmVjdGx5KS5cblx0XHRcdFx0aWYgKF90cmFuc2Zvcm1Qcm9wKSB7XG5cdFx0XHRcdFx0aGFzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0XHRwID0gX3RyYW5zZm9ybU9yaWdpblByb3A7XG5cdFx0XHRcdFx0b3JpZyA9IChvcmlnIHx8IF9nZXRTdHlsZSh0LCBwLCBfY3MsIGZhbHNlLCBcIjUwJSA1MCVcIikpICsgXCJcIjsgLy9jYXN0IGFzIHN0cmluZyB0byBhdm9pZCBlcnJvcnNcblx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIHAsIDAsIDAsIHB0LCAtMSwgdHJhbnNmb3JtT3JpZ2luU3RyaW5nKTtcblx0XHRcdFx0XHRwdC5iID0gc3R5bGVbcF07XG5cdFx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdFx0Y29weSA9IG0xLnpPcmlnaW47XG5cdFx0XHRcdFx0XHRvcmlnID0gb3JpZy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0XHRtMS56T3JpZ2luID0gKChvcmlnLmxlbmd0aCA+IDIgJiYgIShjb3B5ICE9PSAwICYmIG9yaWdbMl0gPT09IFwiMHB4XCIpKSA/IHBhcnNlRmxvYXQob3JpZ1syXSkgOiBjb3B5KSB8fCAwOyAvL1NhZmFyaSBkb2Vzbid0IGhhbmRsZSB0aGUgeiBwYXJ0IG9mIHRyYW5zZm9ybU9yaWdpbiBjb3JyZWN0bHksIHNvIHdlJ2xsIG1hbnVhbGx5IGhhbmRsZSBpdCBpbiB0aGUgX3NldDNEVHJhbnNmb3JtUmF0aW8oKSBtZXRob2QuXG5cdFx0XHRcdFx0XHRwdC54czAgPSBwdC5lID0gb3JpZ1swXSArIFwiIFwiICsgKG9yaWdbMV0gfHwgXCI1MCVcIikgKyBcIiAwcHhcIjsgLy93ZSBtdXN0IGRlZmluZSBhIHogdmFsdWUgb2YgMHB4IHNwZWNpZmljYWxseSBvdGhlcndpc2UgaU9TIDUgU2FmYXJpIHdpbGwgc3RpY2sgd2l0aCB0aGUgb2xkIG9uZSAoaWYgb25lIHdhcyBkZWZpbmVkKSFcblx0XHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihtMSwgXCJ6T3JpZ2luXCIsIDAsIDAsIHB0LCAtMSwgcHQubik7IC8vd2UgbXVzdCBjcmVhdGUgYSBDU1NQcm9wVHdlZW4gZm9yIHRoZSBfZ3NUcmFuc2Zvcm0uek9yaWdpbiBzbyB0aGF0IGl0IGdldHMgcmVzZXQgcHJvcGVybHkgYXQgdGhlIGJlZ2lubmluZyBpZiB0aGUgdHdlZW4gcnVucyBiYWNrd2FyZCAoYXMgb3Bwb3NlZCB0byBqdXN0IHNldHRpbmcgbTEuek9yaWdpbiBoZXJlKVxuXHRcdFx0XHRcdFx0cHQuYiA9IGNvcHk7XG5cdFx0XHRcdFx0XHRwdC54czAgPSBwdC5lID0gbTEuek9yaWdpbjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQueHMwID0gcHQuZSA9IG9yaWc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9mb3Igb2xkZXIgdmVyc2lvbnMgb2YgSUUgKDYtOCksIHdlIG5lZWQgdG8gbWFudWFsbHkgY2FsY3VsYXRlIHRoaW5ncyBpbnNpZGUgdGhlIHNldFJhdGlvKCkgZnVuY3Rpb24uIFdlIHJlY29yZCBvcmlnaW4geCBhbmQgeSAob3ggYW5kIG95KSBhbmQgd2hldGhlciBvciBub3QgdGhlIHZhbHVlcyBhcmUgcGVyY2VudGFnZXMgKG94cCBhbmQgb3lwKS5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfcGFyc2VQb3NpdGlvbihvcmlnICsgXCJcIiwgbTEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzQ2hhbmdlKSB7XG5cdFx0XHRcdGNzc3AuX3RyYW5zZm9ybVR5cGUgPSAoIShtMS5zdmcgJiYgX3VzZVNWR1RyYW5zZm9ybUF0dHIpICYmIChoYXMzRCB8fCB0aGlzLl90cmFuc2Zvcm1UeXBlID09PSAzKSkgPyAzIDogMjsgLy9xdWlja2VyIHRoYW4gY2FsbGluZyBjc3NwLl9lbmFibGVUcmFuc2Zvcm1zKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fSwgcHJlZml4OnRydWV9KTtcblxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJveFNoYWRvd1wiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4IDBweCAwcHggMHB4ICM5OTlcIiwgcHJlZml4OnRydWUsIGNvbG9yOnRydWUsIG11bHRpOnRydWUsIGtleXdvcmQ6XCJpbnNldFwifSk7XG5cblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3JkZXJSYWRpdXNcIiwge2RlZmF1bHRWYWx1ZTpcIjBweFwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0ZSA9IHRoaXMuZm9ybWF0KGUpO1xuXHRcdFx0dmFyIHByb3BzID0gW1wiYm9yZGVyVG9wTGVmdFJhZGl1c1wiLFwiYm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzXCJdLFxuXHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdGVhMSwgaSwgZXMyLCBiczIsIGJzLCBlcywgYm4sIGVuLCB3LCBoLCBlc2Z4LCBic2Z4LCByZWwsIGhuLCB2biwgZW07XG5cdFx0XHR3ID0gcGFyc2VGbG9hdCh0Lm9mZnNldFdpZHRoKTtcblx0XHRcdGggPSBwYXJzZUZsb2F0KHQub2Zmc2V0SGVpZ2h0KTtcblx0XHRcdGVhMSA9IGUuc3BsaXQoXCIgXCIpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IC8vaWYgd2UncmUgZGVhbGluZyB3aXRoIHBlcmNlbnRhZ2VzLCB3ZSBtdXN0IGNvbnZlcnQgdGhpbmdzIHNlcGFyYXRlbHkgZm9yIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBheGlzIVxuXHRcdFx0XHRpZiAodGhpcy5wLmluZGV4T2YoXCJib3JkZXJcIikpIHsgLy9vbGRlciBicm93c2VycyB1c2VkIGEgcHJlZml4XG5cdFx0XHRcdFx0cHJvcHNbaV0gPSBfY2hlY2tQcm9wUHJlZml4KHByb3BzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicyA9IGJzMiA9IF9nZXRTdHlsZSh0LCBwcm9wc1tpXSwgX2NzLCBmYWxzZSwgXCIwcHhcIik7XG5cdFx0XHRcdGlmIChicy5pbmRleE9mKFwiIFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRiczIgPSBicy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0YnMgPSBiczJbMF07XG5cdFx0XHRcdFx0YnMyID0gYnMyWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVzID0gZXMyID0gZWExW2ldO1xuXHRcdFx0XHRibiA9IHBhcnNlRmxvYXQoYnMpO1xuXHRcdFx0XHRic2Z4ID0gYnMuc3Vic3RyKChibiArIFwiXCIpLmxlbmd0aCk7XG5cdFx0XHRcdHJlbCA9IChlcy5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdGVuID0gcGFyc2VJbnQoZXMuY2hhckF0KDApK1wiMVwiLCAxMCk7XG5cdFx0XHRcdFx0ZXMgPSBlcy5zdWJzdHIoMik7XG5cdFx0XHRcdFx0ZW4gKj0gcGFyc2VGbG9hdChlcyk7XG5cdFx0XHRcdFx0ZXNmeCA9IGVzLnN1YnN0cigoZW4gKyBcIlwiKS5sZW5ndGggLSAoZW4gPCAwID8gMSA6IDApKSB8fCBcIlwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVuID0gcGFyc2VGbG9hdChlcyk7XG5cdFx0XHRcdFx0ZXNmeCA9IGVzLnN1YnN0cigoZW4gKyBcIlwiKS5sZW5ndGgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlc2Z4ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0ZXNmeCA9IF9zdWZmaXhNYXBbcF0gfHwgYnNmeDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZXNmeCAhPT0gYnNmeCkge1xuXHRcdFx0XHRcdGhuID0gX2NvbnZlcnRUb1BpeGVscyh0LCBcImJvcmRlckxlZnRcIiwgYm4sIGJzZngpOyAvL2hvcml6b250YWwgbnVtYmVyICh3ZSB1c2UgYSBib2d1cyBcImJvcmRlckxlZnRcIiBwcm9wZXJ0eSBqdXN0IGJlY2F1c2UgdGhlIF9jb252ZXJ0VG9QaXhlbHMoKSBtZXRob2Qgc2VhcmNoZXMgZm9yIHRoZSBrZXl3b3JkcyBcIkxlZnRcIiwgXCJSaWdodFwiLCBcIlRvcFwiLCBhbmQgXCJCb3R0b21cIiB0byBkZXRlcm1pbmUgb2YgaXQncyBhIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydHksIGFuZCB3ZSBuZWVkIFwiYm9yZGVyXCIgaW4gdGhlIG5hbWUgc28gdGhhdCBpdCBrbm93cyBpdCBzaG91bGQgbWVhc3VyZSByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCBpdHNlbGYsIG5vdCBpdHMgcGFyZW50LlxuXHRcdFx0XHRcdHZuID0gX2NvbnZlcnRUb1BpeGVscyh0LCBcImJvcmRlclRvcFwiLCBibiwgYnNmeCk7IC8vdmVydGljYWwgbnVtYmVyXG5cdFx0XHRcdFx0aWYgKGVzZnggPT09IFwiJVwiKSB7XG5cdFx0XHRcdFx0XHRicyA9IChobiAvIHcgKiAxMDApICsgXCIlXCI7XG5cdFx0XHRcdFx0XHRiczIgPSAodm4gLyBoICogMTAwKSArIFwiJVwiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZXNmeCA9PT0gXCJlbVwiKSB7XG5cdFx0XHRcdFx0XHRlbSA9IF9jb252ZXJ0VG9QaXhlbHModCwgXCJib3JkZXJMZWZ0XCIsIDEsIFwiZW1cIik7XG5cdFx0XHRcdFx0XHRicyA9IChobiAvIGVtKSArIFwiZW1cIjtcblx0XHRcdFx0XHRcdGJzMiA9ICh2biAvIGVtKSArIFwiZW1cIjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YnMgPSBobiArIFwicHhcIjtcblx0XHRcdFx0XHRcdGJzMiA9IHZuICsgXCJweFwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocmVsKSB7XG5cdFx0XHRcdFx0XHRlcyA9IChwYXJzZUZsb2F0KGJzKSArIGVuKSArIGVzZng7XG5cdFx0XHRcdFx0XHRlczIgPSAocGFyc2VGbG9hdChiczIpICsgZW4pICsgZXNmeDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBfcGFyc2VDb21wbGV4KHN0eWxlLCBwcm9wc1tpXSwgYnMgKyBcIiBcIiArIGJzMiwgZXMgKyBcIiBcIiArIGVzMiwgZmFsc2UsIFwiMHB4XCIsIHB0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9LCBwcmVmaXg6dHJ1ZSwgZm9ybWF0dGVyOl9nZXRGb3JtYXR0ZXIoXCIwcHggMHB4IDBweCAwcHhcIiwgZmFsc2UsIHRydWUpfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyxib3JkZXJCb3R0b21SaWdodFJhZGl1cyxib3JkZXJUb3BMZWZ0UmFkaXVzLGJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsIHtkZWZhdWx0VmFsdWU6XCIwcHhcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHJldHVybiBfcGFyc2VDb21wbGV4KHQuc3R5bGUsIHAsIHRoaXMuZm9ybWF0KF9nZXRTdHlsZSh0LCBwLCBfY3MsIGZhbHNlLCBcIjBweCAwcHhcIikpLCB0aGlzLmZvcm1hdChlKSwgZmFsc2UsIFwiMHB4XCIsIHB0KTtcblx0XHR9LCBwcmVmaXg6dHJ1ZSwgZm9ybWF0dGVyOl9nZXRGb3JtYXR0ZXIoXCIwcHggMHB4XCIsIGZhbHNlLCB0cnVlKX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJhY2tncm91bmRQb3NpdGlvblwiLCB7ZGVmYXVsdFZhbHVlOlwiMCAwXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgYnAgPSBcImJhY2tncm91bmQtcG9zaXRpb25cIixcblx0XHRcdFx0Y3MgPSAoX2NzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpKSxcblx0XHRcdFx0YnMgPSB0aGlzLmZvcm1hdCggKChjcykgPyBfaWVWZXJzID8gY3MuZ2V0UHJvcGVydHlWYWx1ZShicCArIFwiLXhcIikgKyBcIiBcIiArIGNzLmdldFByb3BlcnR5VmFsdWUoYnAgKyBcIi15XCIpIDogY3MuZ2V0UHJvcGVydHlWYWx1ZShicCkgOiB0LmN1cnJlbnRTdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25YICsgXCIgXCIgKyB0LmN1cnJlbnRTdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25ZKSB8fCBcIjAgMFwiKSwgLy9JbnRlcm5ldCBFeHBsb3JlciBkb2Vzbid0IHJlcG9ydCBiYWNrZ3JvdW5kLXBvc2l0aW9uIGNvcnJlY3RseSAtIHdlIG11c3QgcXVlcnkgYmFja2dyb3VuZC1wb3NpdGlvbi14IGFuZCBiYWNrZ3JvdW5kLXBvc2l0aW9uLXkgYW5kIGNvbWJpbmUgdGhlbSAoZXZlbiBpbiBJRTEwKS4gQmVmb3JlIElFOSwgd2UgbXVzdCBkbyB0aGUgc2FtZSB3aXRoIHRoZSBjdXJyZW50U3R5bGUgb2JqZWN0IGFuZCB1c2UgY2FtZWxDYXNlXG5cdFx0XHRcdGVzID0gdGhpcy5mb3JtYXQoZSksXG5cdFx0XHRcdGJhLCBlYSwgaSwgcGN0LCBvdmVybGFwLCBzcmM7XG5cdFx0XHRpZiAoKGJzLmluZGV4T2YoXCIlXCIpICE9PSAtMSkgIT09IChlcy5pbmRleE9mKFwiJVwiKSAhPT0gLTEpICYmIGVzLnNwbGl0KFwiLFwiKS5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdHNyYyA9IF9nZXRTdHlsZSh0LCBcImJhY2tncm91bmRJbWFnZVwiKS5yZXBsYWNlKF91cmxFeHAsIFwiXCIpO1xuXHRcdFx0XHRpZiAoc3JjICYmIHNyYyAhPT0gXCJub25lXCIpIHtcblx0XHRcdFx0XHRiYSA9IGJzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRlYSA9IGVzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRfdGVtcEltZy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgc3JjKTsgLy9zZXQgdGhlIHRlbXAgSU1HJ3Mgc3JjIHRvIHRoZSBiYWNrZ3JvdW5kLWltYWdlIHNvIHRoYXQgd2UgY2FuIG1lYXN1cmUgaXRzIHdpZHRoL2hlaWdodFxuXHRcdFx0XHRcdGkgPSAyO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0YnMgPSBiYVtpXTtcblx0XHRcdFx0XHRcdHBjdCA9IChicy5pbmRleE9mKFwiJVwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdFx0aWYgKHBjdCAhPT0gKGVhW2ldLmluZGV4T2YoXCIlXCIpICE9PSAtMSkpIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmxhcCA9IChpID09PSAwKSA/IHQub2Zmc2V0V2lkdGggLSBfdGVtcEltZy53aWR0aCA6IHQub2Zmc2V0SGVpZ2h0IC0gX3RlbXBJbWcuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHRiYVtpXSA9IHBjdCA/IChwYXJzZUZsb2F0KGJzKSAvIDEwMCAqIG92ZXJsYXApICsgXCJweFwiIDogKHBhcnNlRmxvYXQoYnMpIC8gb3ZlcmxhcCAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnMgPSBiYS5qb2luKFwiIFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIGJzLCBlcywgcHQsIHBsdWdpbik7XG5cdFx0fSwgZm9ybWF0dGVyOl9wYXJzZVBvc2l0aW9ufSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmFja2dyb3VuZFNpemVcIiwge2RlZmF1bHRWYWx1ZTpcIjAgMFwiLCBmb3JtYXR0ZXI6X3BhcnNlUG9zaXRpb259KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJwZXJzcGVjdGl2ZVwiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4XCIsIHByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwicGVyc3BlY3RpdmVPcmlnaW5cIiwge2RlZmF1bHRWYWx1ZTpcIjUwJSA1MCVcIiwgcHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ0cmFuc2Zvcm1TdHlsZVwiLCB7cHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiYWNrZmFjZVZpc2liaWxpdHlcIiwge3ByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwidXNlclNlbGVjdFwiLCB7cHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJtYXJnaW5cIiwge3BhcnNlcjpfZ2V0RWRnZVBhcnNlcihcIm1hcmdpblRvcCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20sbWFyZ2luTGVmdFwiKX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInBhZGRpbmdcIiwge3BhcnNlcjpfZ2V0RWRnZVBhcnNlcihcInBhZGRpbmdUb3AscGFkZGluZ1JpZ2h0LHBhZGRpbmdCb3R0b20scGFkZGluZ0xlZnRcIil9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJjbGlwXCIsIHtkZWZhdWx0VmFsdWU6XCJyZWN0KDBweCwwcHgsMHB4LDBweClcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pe1xuXHRcdFx0dmFyIGIsIGNzLCBkZWxpbTtcblx0XHRcdGlmIChfaWVWZXJzIDwgOSkgeyAvL0lFOCBhbmQgZWFybGllciBkb24ndCByZXBvcnQgYSBcImNsaXBcIiB2YWx1ZSBpbiB0aGUgY3VycmVudFN0eWxlIC0gaW5zdGVhZCwgdGhlIHZhbHVlcyBhcmUgc3BsaXQgYXBhcnQgaW50byBjbGlwVG9wLCBjbGlwUmlnaHQsIGNsaXBCb3R0b20sIGFuZCBjbGlwTGVmdC4gQWxzbywgaW4gSUU3IGFuZCBlYXJsaWVyLCB0aGUgdmFsdWVzIGluc2lkZSByZWN0KCkgYXJlIHNwYWNlLWRlbGltaXRlZCwgbm90IGNvbW1hLWRlbGltaXRlZC5cblx0XHRcdFx0Y3MgPSB0LmN1cnJlbnRTdHlsZTtcblx0XHRcdFx0ZGVsaW0gPSBfaWVWZXJzIDwgOCA/IFwiIFwiIDogXCIsXCI7XG5cdFx0XHRcdGIgPSBcInJlY3QoXCIgKyBjcy5jbGlwVG9wICsgZGVsaW0gKyBjcy5jbGlwUmlnaHQgKyBkZWxpbSArIGNzLmNsaXBCb3R0b20gKyBkZWxpbSArIGNzLmNsaXBMZWZ0ICsgXCIpXCI7XG5cdFx0XHRcdGUgPSB0aGlzLmZvcm1hdChlKS5zcGxpdChcIixcIikuam9pbihkZWxpbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRiID0gdGhpcy5mb3JtYXQoX2dldFN0eWxlKHQsIHRoaXMucCwgX2NzLCBmYWxzZSwgdGhpcy5kZmx0KSk7XG5cdFx0XHRcdGUgPSB0aGlzLmZvcm1hdChlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLCBiLCBlLCBwdCwgcGx1Z2luKTtcblx0XHR9fSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwidGV4dFNoYWRvd1wiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4IDBweCAwcHggIzk5OVwiLCBjb2xvcjp0cnVlLCBtdWx0aTp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYXV0b1JvdW5kLHN0cmljdFVuaXRzXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQpIHtyZXR1cm4gcHQ7fX0pOyAvL2p1c3Qgc28gdGhhdCB3ZSBjYW4gaWdub3JlIHRoZXNlIHByb3BlcnRpZXMgKG5vdCB0d2VlbiB0aGVtKVxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJvcmRlclwiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4IHNvbGlkICMwMDBcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIHRoaXMuZm9ybWF0KF9nZXRTdHlsZSh0LCBcImJvcmRlclRvcFdpZHRoXCIsIF9jcywgZmFsc2UsIFwiMHB4XCIpICsgXCIgXCIgKyBfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BTdHlsZVwiLCBfY3MsIGZhbHNlLCBcInNvbGlkXCIpICsgXCIgXCIgKyBfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BDb2xvclwiLCBfY3MsIGZhbHNlLCBcIiMwMDBcIikpLCB0aGlzLmZvcm1hdChlKSwgcHQsIHBsdWdpbik7XG5cdFx0XHR9LCBjb2xvcjp0cnVlLCBmb3JtYXR0ZXI6ZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgYSA9IHYuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRyZXR1cm4gYVswXSArIFwiIFwiICsgKGFbMV0gfHwgXCJzb2xpZFwiKSArIFwiIFwiICsgKHYubWF0Y2goX2NvbG9yRXhwKSB8fCBbXCIjMDAwXCJdKVswXTtcblx0XHRcdH19KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3JkZXJXaWR0aFwiLCB7cGFyc2VyOl9nZXRFZGdlUGFyc2VyKFwiYm9yZGVyVG9wV2lkdGgsYm9yZGVyUmlnaHRXaWR0aCxib3JkZXJCb3R0b21XaWR0aCxib3JkZXJMZWZ0V2lkdGhcIil9KTsgLy9GaXJlZm94IGRvZXNuJ3QgcGljayB1cCBvbiBib3JkZXJXaWR0aCBzZXQgaW4gc3R5bGUgc2hlZXRzIChvbmx5IGlubGluZSkuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiZmxvYXQsY3NzRmxvYXQsc3R5bGVGbG9hdFwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHZhciBzID0gdC5zdHlsZSxcblx0XHRcdFx0cHJvcCA9IChcImNzc0Zsb2F0XCIgaW4gcykgPyBcImNzc0Zsb2F0XCIgOiBcInN0eWxlRmxvYXRcIjtcblx0XHRcdHJldHVybiBuZXcgQ1NTUHJvcFR3ZWVuKHMsIHByb3AsIDAsIDAsIHB0LCAtMSwgcCwgZmFsc2UsIDAsIHNbcHJvcF0sIGUpO1xuXHRcdH19KTtcblxuXHRcdC8vb3BhY2l0eS1yZWxhdGVkXG5cdFx0dmFyIF9zZXRJRU9wYWNpdHlSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLnQsIC8vcmVmZXJzIHRvIHRoZSBlbGVtZW50J3Mgc3R5bGUgcHJvcGVydHlcblx0XHRcdFx0XHRmaWx0ZXJzID0gdC5maWx0ZXIgfHwgX2dldFN0eWxlKHRoaXMuZGF0YSwgXCJmaWx0ZXJcIikgfHwgXCJcIixcblx0XHRcdFx0XHR2YWwgPSAodGhpcy5zICsgdGhpcy5jICogdikgfCAwLFxuXHRcdFx0XHRcdHNraXA7XG5cdFx0XHRcdGlmICh2YWwgPT09IDEwMCkgeyAvL2ZvciBvbGRlciB2ZXJzaW9ucyBvZiBJRSB0aGF0IG5lZWQgdG8gdXNlIGEgZmlsdGVyIHRvIGFwcGx5IG9wYWNpdHksIHdlIHNob3VsZCByZW1vdmUgdGhlIGZpbHRlciBpZiBvcGFjaXR5IGhpdHMgMSBpbiBvcmRlciB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLCBidXQgbWFrZSBzdXJlIHRoZXJlIGlzbid0IGEgdHJhbnNmb3JtIChtYXRyaXgpIG9yIGdyYWRpZW50IGluIHRoZSBmaWx0ZXJzLlxuXHRcdFx0XHRcdGlmIChmaWx0ZXJzLmluZGV4T2YoXCJhdHJpeChcIikgPT09IC0xICYmIGZpbHRlcnMuaW5kZXhPZihcInJhZGllbnQoXCIpID09PSAtMSAmJiBmaWx0ZXJzLmluZGV4T2YoXCJvYWRlcihcIikgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHR0LnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKTtcblx0XHRcdFx0XHRcdHNraXAgPSAoIV9nZXRTdHlsZSh0aGlzLmRhdGEsIFwiZmlsdGVyXCIpKTsgLy9pZiBhIGNsYXNzIGlzIGFwcGxpZWQgdGhhdCBoYXMgYW4gYWxwaGEgZmlsdGVyLCBpdCB3aWxsIHRha2UgZWZmZWN0ICh3ZSBkb24ndCB3YW50IHRoYXQpLCBzbyByZS1hcHBseSBvdXIgYWxwaGEgZmlsdGVyIGluIHRoYXQgY2FzZS4gV2UgbXVzdCBmaXJzdCByZW1vdmUgaXQgYW5kIHRoZW4gY2hlY2suXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHQuZmlsdGVyID0gZmlsdGVycy5yZXBsYWNlKF9hbHBoYUZpbHRlckV4cCwgXCJcIik7XG5cdFx0XHRcdFx0XHRza2lwID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFza2lwKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMueG4xKSB7XG5cdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMgPSBmaWx0ZXJzIHx8IChcImFscGhhKG9wYWNpdHk9XCIgKyB2YWwgKyBcIilcIik7IC8vd29ya3MgYXJvdW5kIGJ1ZyBpbiBJRTcvOCB0aGF0IHByZXZlbnRzIGNoYW5nZXMgdG8gXCJ2aXNpYmlsaXR5XCIgZnJvbSBiZWluZyBhcHBsaWVkIHByb3Blcmx5IGlmIHRoZSBmaWx0ZXIgaXMgY2hhbmdlZCB0byBhIGRpZmZlcmVudCBhbHBoYSBvbiB0aGUgc2FtZSBmcmFtZS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGZpbHRlcnMuaW5kZXhPZihcInBhY2l0eVwiKSA9PT0gLTEpIHsgLy9vbmx5IHVzZWQgaWYgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHN0YW5kYXJkIG9wYWNpdHkgc3R5bGUgcHJvcGVydHkgKElFIDcgYW5kIDgpLiBXZSBvbWl0IHRoZSBcIk9cIiB0byBhdm9pZCBjYXNlLXNlbnNpdGl2aXR5IGlzc3Vlc1xuXHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gMCB8fCAhdGhpcy54bjEpIHsgLy9idWdzIGluIElFNy84IHdvbid0IHJlbmRlciB0aGUgZmlsdGVyIHByb3Blcmx5IGlmIG9wYWNpdHkgaXMgQURERUQgb24gdGhlIHNhbWUgZnJhbWUvcmVuZGVyIGFzIFwidmlzaWJpbGl0eVwiIGNoYW5nZXMgKHRoaXMueG4xIGlzIDEgaWYgdGhpcyB0d2VlbiBpcyBhbiBcImF1dG9BbHBoYVwiIHR3ZWVuKVxuXHRcdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMgKyBcIiBhbHBoYShvcGFjaXR5PVwiICsgdmFsICsgXCIpXCI7IC8vd2Ugcm91bmQgdGhlIHZhbHVlIGJlY2F1c2Ugb3RoZXJ3aXNlLCBidWdzIGluIElFNy84IGNhbiBwcmV2ZW50IFwidmlzaWJpbGl0eVwiIGNoYW5nZXMgZnJvbSBiZWluZyBhcHBsaWVkIHByb3Blcmx5LlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMucmVwbGFjZShfb3BhY2l0eUV4cCwgXCJvcGFjaXR5PVwiICsgdmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwib3BhY2l0eSxhbHBoYSxhdXRvQWxwaGFcIiwge2RlZmF1bHRWYWx1ZTpcIjFcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHZhciBiID0gcGFyc2VGbG9hdChfZ2V0U3R5bGUodCwgXCJvcGFjaXR5XCIsIF9jcywgZmFsc2UsIFwiMVwiKSksXG5cdFx0XHRcdHN0eWxlID0gdC5zdHlsZSxcblx0XHRcdFx0aXNBdXRvQWxwaGEgPSAocCA9PT0gXCJhdXRvQWxwaGFcIik7XG5cdFx0XHRpZiAodHlwZW9mKGUpID09PSBcInN0cmluZ1wiICYmIGUuY2hhckF0KDEpID09PSBcIj1cIikge1xuXHRcdFx0XHRlID0gKChlLmNoYXJBdCgwKSA9PT0gXCItXCIpID8gLTEgOiAxKSAqIHBhcnNlRmxvYXQoZS5zdWJzdHIoMikpICsgYjtcblx0XHRcdH1cblx0XHRcdGlmIChpc0F1dG9BbHBoYSAmJiBiID09PSAxICYmIF9nZXRTdHlsZSh0LCBcInZpc2liaWxpdHlcIiwgX2NzKSA9PT0gXCJoaWRkZW5cIiAmJiBlICE9PSAwKSB7IC8vaWYgdmlzaWJpbGl0eSBpcyBpbml0aWFsbHkgc2V0IHRvIFwiaGlkZGVuXCIsIHdlIHNob3VsZCBpbnRlcnByZXQgdGhhdCBhcyBpbnRlbnQgdG8gbWFrZSBvcGFjaXR5IDAgKGEgY29udmVuaWVuY2UpXG5cdFx0XHRcdGIgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9zdXBwb3J0c09wYWNpdHkpIHtcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBcIm9wYWNpdHlcIiwgYiwgZSAtIGIsIHB0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJvcGFjaXR5XCIsIGIgKiAxMDAsIChlIC0gYikgKiAxMDAsIHB0KTtcblx0XHRcdFx0cHQueG4xID0gaXNBdXRvQWxwaGEgPyAxIDogMDsgLy93ZSBuZWVkIHRvIHJlY29yZCB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIGFuIGF1dG9BbHBoYSBzbyB0aGF0IGluIHRoZSBzZXRSYXRpbygpLCB3ZSBrbm93IHRvIGR1cGxpY2F0ZSB0aGUgc2V0dGluZyBvZiB0aGUgYWxwaGEgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgYSBidWcgaW4gSUU3IGFuZCBJRTggdGhhdCBwcmV2ZW50cyBjaGFuZ2VzIHRvIFwidmlzaWJpbGl0eVwiIGZyb20gdGFraW5nIGVmZmVjdCBpZiB0aGUgZmlsdGVyIGlzIGNoYW5nZWQgdG8gYSBkaWZmZXJlbnQgYWxwaGEob3BhY2l0eSkgYXQgdGhlIHNhbWUgdGltZS4gU2V0dGluZyBpdCB0byB0aGUgU0FNRSB2YWx1ZSBmaXJzdCwgdGhlbiB0aGUgbmV3IHZhbHVlIHdvcmtzIGFyb3VuZCB0aGUgSUU3LzggYnVnLlxuXHRcdFx0XHRzdHlsZS56b29tID0gMTsgLy9oZWxwcyBjb3JyZWN0IGFuIElFIGlzc3VlLlxuXHRcdFx0XHRwdC50eXBlID0gMjtcblx0XHRcdFx0cHQuYiA9IFwiYWxwaGEob3BhY2l0eT1cIiArIHB0LnMgKyBcIilcIjtcblx0XHRcdFx0cHQuZSA9IFwiYWxwaGEob3BhY2l0eT1cIiArIChwdC5zICsgcHQuYykgKyBcIilcIjtcblx0XHRcdFx0cHQuZGF0YSA9IHQ7XG5cdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0SUVPcGFjaXR5UmF0aW87XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNBdXRvQWxwaGEpIHsgLy93ZSBoYXZlIHRvIGNyZWF0ZSB0aGUgXCJ2aXNpYmlsaXR5XCIgUHJvcFR3ZWVuIGFmdGVyIHRoZSBvcGFjaXR5IG9uZSBpbiB0aGUgbGlua2VkIGxpc3Qgc28gdGhhdCB0aGV5IHJ1biBpbiB0aGUgb3JkZXIgdGhhdCB3b3JrcyBwcm9wZXJseSBpbiBJRTggYW5kIGVhcmxpZXJcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBcInZpc2liaWxpdHlcIiwgMCwgMCwgcHQsIC0xLCBudWxsLCBmYWxzZSwgMCwgKChiICE9PSAwKSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiksICgoZSA9PT0gMCkgPyBcImhpZGRlblwiIDogXCJpbmhlcml0XCIpKTtcblx0XHRcdFx0cHQueHMwID0gXCJpbmhlcml0XCI7XG5cdFx0XHRcdGNzc3AuX292ZXJ3cml0ZVByb3BzLnB1c2gocHQubik7XG5cdFx0XHRcdGNzc3AuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fX0pO1xuXG5cblx0XHR2YXIgX3JlbW92ZVByb3AgPSBmdW5jdGlvbihzLCBwKSB7XG5cdFx0XHRcdGlmIChwKSB7XG5cdFx0XHRcdFx0aWYgKHMucmVtb3ZlUHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdGlmIChwLnN1YnN0cigwLDIpID09PSBcIm1zXCIgfHwgcC5zdWJzdHIoMCw2KSA9PT0gXCJ3ZWJraXRcIikgeyAvL01pY3Jvc29mdCBhbmQgc29tZSBXZWJraXQgYnJvd3NlcnMgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3RhbmRhcmQgb2YgY2FwaXRhbGl6aW5nIHRoZSBmaXJzdCBwcmVmaXggY2hhcmFjdGVyLCBzbyB3ZSBhZGp1c3Qgc28gdGhhdCB3aGVuIHdlIHByZWZpeCB0aGUgY2FwcyB3aXRoIGEgZGFzaCwgaXQncyBjb3JyZWN0IChvdGhlcndpc2UgaXQnZCBiZSBcIm1zLXRyYW5zZm9ybVwiIGluc3RlYWQgb2YgXCItbXMtdHJhbnNmb3JtXCIgZm9yIElFOSwgZm9yIGV4YW1wbGUpXG5cdFx0XHRcdFx0XHRcdHAgPSBcIi1cIiArIHA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzLnJlbW92ZVByb3BlcnR5KHAucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHsgLy9ub3RlOiBvbGQgdmVyc2lvbnMgb2YgSUUgdXNlIFwicmVtb3ZlQXR0cmlidXRlKClcIiBpbnN0ZWFkIG9mIFwicmVtb3ZlUHJvcGVydHkoKVwiXG5cdFx0XHRcdFx0XHRzLnJlbW92ZUF0dHJpYnV0ZShwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfc2V0Q2xhc3NOYW1lUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHRoaXMudC5fZ3NDbGFzc1BUID0gdGhpcztcblx0XHRcdFx0aWYgKHYgPT09IDEgfHwgdiA9PT0gMCkge1xuXHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCAodiA9PT0gMCkgPyB0aGlzLmIgOiB0aGlzLmUpO1xuXHRcdFx0XHRcdHZhciBtcHQgPSB0aGlzLmRhdGEsIC8vZmlyc3QgTWluaVByb3BUd2VlblxuXHRcdFx0XHRcdFx0cyA9IHRoaXMudC5zdHlsZTtcblx0XHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0XHRpZiAoIW1wdC52KSB7XG5cdFx0XHRcdFx0XHRcdF9yZW1vdmVQcm9wKHMsIG1wdC5wKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNbbXB0LnBdID0gbXB0LnY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtcHQgPSBtcHQuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh2ID09PSAxICYmIHRoaXMudC5fZ3NDbGFzc1BUID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnQuX2dzQ2xhc3NQVCA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMudC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSAhPT0gdGhpcy5lKSB7XG5cdFx0XHRcdFx0dGhpcy50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiY2xhc3NOYW1lXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0dmFyIGIgPSB0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIsIC8vZG9uJ3QgdXNlIHQuY2xhc3NOYW1lIGJlY2F1c2UgaXQgZG9lc24ndCB3b3JrIGNvbnNpc3RlbnRseSBvbiBTVkcgZWxlbWVudHM7IGdldEF0dHJpYnV0ZShcImNsYXNzXCIpIGFuZCBzZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB2YWx1ZVwiKSBpcyBtb3JlIHJlbGlhYmxlLlxuXHRcdFx0XHRjc3NUZXh0ID0gdC5zdHlsZS5jc3NUZXh0LFxuXHRcdFx0XHRkaWZEYXRhLCBicywgY25wdCwgY25wdExvb2t1cCwgbXB0O1xuXHRcdFx0cHQgPSBjc3NwLl9jbGFzc05hbWVQVCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgcHQsIDIpO1xuXHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0Q2xhc3NOYW1lUmF0aW87XG5cdFx0XHRwdC5wciA9IC0xMTtcblx0XHRcdF9oYXNQcmlvcml0eSA9IHRydWU7XG5cdFx0XHRwdC5iID0gYjtcblx0XHRcdGJzID0gX2dldEFsbFN0eWxlcyh0LCBfY3MpO1xuXHRcdFx0Ly9pZiB0aGVyZSdzIGEgY2xhc3NOYW1lIHR3ZWVuIGFscmVhZHkgb3BlcmF0aW5nIG9uIHRoZSB0YXJnZXQsIGZvcmNlIGl0IHRvIGl0cyBlbmQgc28gdGhhdCB0aGUgbmVjZXNzYXJ5IGlubGluZSBzdHlsZXMgYXJlIHJlbW92ZWQgYW5kIHRoZSBjbGFzcyBuYW1lIGlzIGFwcGxpZWQgYmVmb3JlIHdlIGRldGVybWluZSB0aGUgZW5kIHN0YXRlICh3ZSBkb24ndCB3YW50IGlubGluZSBzdHlsZXMgaW50ZXJmZXJpbmcgdGhhdCB3ZXJlIHRoZXJlIGp1c3QgZm9yIGNsYXNzLXNwZWNpZmljIHZhbHVlcylcblx0XHRcdGNucHQgPSB0Ll9nc0NsYXNzUFQ7XG5cdFx0XHRpZiAoY25wdCkge1xuXHRcdFx0XHRjbnB0TG9va3VwID0ge307XG5cdFx0XHRcdG1wdCA9IGNucHQuZGF0YTsgLy9maXJzdCBNaW5pUHJvcFR3ZWVuIHdoaWNoIHN0b3JlcyB0aGUgaW5saW5lIHN0eWxlcyAtIHdlIG5lZWQgdG8gZm9yY2UgdGhlc2Ugc28gdGhhdCB0aGUgaW5saW5lIHN0eWxlcyBkb24ndCBjb250YW1pbmF0ZSB0aGluZ3MuIE90aGVyd2lzZSwgdGhlcmUncyBhIHNtYWxsIGNoYW5jZSB0aGF0IGEgdHdlZW4gY291bGQgc3RhcnQgYW5kIHRoZSBpbmxpbmUgdmFsdWVzIG1hdGNoIHRoZSBkZXN0aW5hdGlvbiB2YWx1ZXMgYW5kIHRoZXkgbmV2ZXIgZ2V0IGNsZWFuZWQuXG5cdFx0XHRcdHdoaWxlIChtcHQpIHtcblx0XHRcdFx0XHRjbnB0TG9va3VwW21wdC5wXSA9IDE7XG5cdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNucHQuc2V0UmF0aW8oMSk7XG5cdFx0XHR9XG5cdFx0XHR0Ll9nc0NsYXNzUFQgPSBwdDtcblx0XHRcdHB0LmUgPSAoZS5jaGFyQXQoMSkgIT09IFwiPVwiKSA/IGUgOiBiLnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlLnN1YnN0cigyKSArIFwiKD8hW1xcXFx3LV0pXCIpLCBcIlwiKSArICgoZS5jaGFyQXQoMCkgPT09IFwiK1wiKSA/IFwiIFwiICsgZS5zdWJzdHIoMikgOiBcIlwiKTtcblx0XHRcdHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgcHQuZSk7XG5cdFx0XHRkaWZEYXRhID0gX2Nzc0RpZih0LCBicywgX2dldEFsbFN0eWxlcyh0KSwgdmFycywgY25wdExvb2t1cCk7XG5cdFx0XHR0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGIpO1xuXHRcdFx0cHQuZGF0YSA9IGRpZkRhdGEuZmlyc3RNUFQ7XG5cdFx0XHR0LnN0eWxlLmNzc1RleHQgPSBjc3NUZXh0OyAvL3dlIHJlY29yZGVkIGNzc1RleHQgYmVmb3JlIHdlIHN3YXBwZWQgY2xhc3NlcyBhbmQgcmFuIF9nZXRBbGxTdHlsZXMoKSBiZWNhdXNlIGluIGNhc2VzIHdoZW4gYSBjbGFzc05hbWUgdHdlZW4gaXMgb3ZlcndyaXR0ZW4sIHdlIHJlbW92ZSBhbGwgdGhlIHJlbGF0ZWQgdHdlZW5pbmcgcHJvcGVydGllcyBmcm9tIHRoYXQgY2xhc3MgY2hhbmdlIChvdGhlcndpc2UgY2xhc3Mtc3BlY2lmaWMgc3R1ZmYgY2FuJ3Qgb3ZlcnJpZGUgcHJvcGVydGllcyB3ZSd2ZSBkaXJlY3RseSBzZXQgb24gdGhlIHRhcmdldCdzIHN0eWxlIG9iamVjdCBkdWUgdG8gc3BlY2lmaWNpdHkpLlxuXHRcdFx0cHQgPSBwdC54Zmlyc3QgPSBjc3NwLnBhcnNlKHQsIGRpZkRhdGEuZGlmcywgcHQsIHBsdWdpbik7IC8vd2UgcmVjb3JkIHRoZSBDU1NQcm9wVHdlZW4gYXMgdGhlIHhmaXJzdCBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgb3ZlcndyaXRpbmcgcHJvcGVydGx5IChpZiBcImNsYXNzTmFtZVwiIGdldHMgb3ZlcndyaXR0ZW4sIHdlIG11c3Qga2lsbCBhbGwgdGhlIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjbGFzc05hbWUgcGFydCBvZiB0aGUgdHdlZW4sIHNvIHdlIGNhbiBsb29wIHRocm91Z2ggZnJvbSB4Zmlyc3QgdG8gdGhlIHB0IGl0c2VsZilcblx0XHRcdHJldHVybiBwdDtcblx0XHR9fSk7XG5cblxuXHRcdHZhciBfc2V0Q2xlYXJQcm9wc1JhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0aWYgKHYgPT09IDEgfHwgdiA9PT0gMCkgaWYgKHRoaXMuZGF0YS5fdG90YWxUaW1lID09PSB0aGlzLmRhdGEuX3RvdGFsRHVyYXRpb24gJiYgdGhpcy5kYXRhLmRhdGEgIT09IFwiaXNGcm9tU3RhcnRcIikgeyAvL3RoaXMuZGF0YSByZWZlcnMgdG8gdGhlIHR3ZWVuLiBPbmx5IGNsZWFyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIChyZW1lbWJlciwgZnJvbSgpIHR3ZWVucyBtYWtlIHRoZSByYXRpbyBnbyBmcm9tIDEgdG8gMCwgc28gd2UgY2FuJ3QganVzdCBjaGVjayB0aGF0IGFuZCBpZiB0aGUgdHdlZW4gaXMgdGhlIHplcm8tZHVyYXRpb24gb25lIHRoYXQncyBjcmVhdGVkIGludGVybmFsbHkgdG8gcmVuZGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgaW4gYSBmcm9tKCkgdHdlZW4sIGlnbm9yZSB0aGF0IGJlY2F1c2Ugb3RoZXJ3aXNlLCBmb3IgZXhhbXBsZSwgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4pLlxuXHRcdFx0XHR2YXIgcyA9IHRoaXMudC5zdHlsZSxcblx0XHRcdFx0XHR0cmFuc2Zvcm1QYXJzZSA9IF9zcGVjaWFsUHJvcHMudHJhbnNmb3JtLnBhcnNlLFxuXHRcdFx0XHRcdGEsIHAsIGksIGNsZWFyVHJhbnNmb3JtLCB0cmFuc2Zvcm07XG5cdFx0XHRcdGlmICh0aGlzLmUgPT09IFwiYWxsXCIpIHtcblx0XHRcdFx0XHRzLmNzc1RleHQgPSBcIlwiO1xuXHRcdFx0XHRcdGNsZWFyVHJhbnNmb3JtID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhID0gdGhpcy5lLnNwbGl0KFwiIFwiKS5qb2luKFwiXCIpLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRwID0gYVtpXTtcblx0XHRcdFx0XHRcdGlmIChfc3BlY2lhbFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChfc3BlY2lhbFByb3BzW3BdLnBhcnNlID09PSB0cmFuc2Zvcm1QYXJzZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNsZWFyVHJhbnNmb3JtID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRwID0gKHAgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIpID8gX3RyYW5zZm9ybU9yaWdpblByb3AgOiBfc3BlY2lhbFByb3BzW3BdLnA7IC8vZW5zdXJlcyB0aGF0IHNwZWNpYWwgcHJvcGVydGllcyB1c2UgdGhlIHByb3BlciBicm93c2VyLXNwZWNpZmljIHByb3BlcnR5IG5hbWUsIGxpa2UgXCJzY2FsZVhcIiBtaWdodCBiZSBcIi13ZWJraXQtdHJhbnNmb3JtXCIgb3IgXCJib3hTaGFkb3dcIiBtaWdodCBiZSBcIi1tb3otYm94LXNoYWRvd1wiXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdF9yZW1vdmVQcm9wKHMsIHApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2xlYXJUcmFuc2Zvcm0pIHtcblx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBfdHJhbnNmb3JtUHJvcCk7XG5cdFx0XHRcdFx0dHJhbnNmb3JtID0gdGhpcy50Ll9nc1RyYW5zZm9ybTtcblx0XHRcdFx0XHRpZiAodHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0XHRpZiAodHJhbnNmb3JtLnN2Zykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnQucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMudC5fZ3NUcmFuc2Zvcm07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsZWFyUHJvcHNcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCkge1xuXHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyKTtcblx0XHRcdHB0LnNldFJhdGlvID0gX3NldENsZWFyUHJvcHNSYXRpbztcblx0XHRcdHB0LmUgPSBlO1xuXHRcdFx0cHQucHIgPSAtMTA7XG5cdFx0XHRwdC5kYXRhID0gY3NzcC5fdHdlZW47XG5cdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH19KTtcblxuXHRcdHAgPSBcImJlemllcix0aHJvd1Byb3BzLHBoeXNpY3NQcm9wcyxwaHlzaWNzMkRcIi5zcGxpdChcIixcIik7XG5cdFx0aSA9IHAubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdF9yZWdpc3RlclBsdWdpblByb3AocFtpXSk7XG5cdFx0fVxuXG5cblxuXG5cblxuXG5cblx0XHRwID0gQ1NTUGx1Z2luLnByb3RvdHlwZTtcblx0XHRwLl9maXJzdFBUID0gcC5fbGFzdFBhcnNlZFRyYW5zZm9ybSA9IHAuX3RyYW5zZm9ybSA9IG51bGw7XG5cblx0XHQvL2dldHMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGtpY2tzIGV2ZXJ5dGhpbmcgb2ZmLCByZWNvcmRpbmcgc3RhcnQvZW5kIHZhbHVlcywgZXRjLlxuXHRcdHAuX29uSW5pdFR3ZWVuID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuXHRcdFx0aWYgKCF0YXJnZXQubm9kZVR5cGUpIHsgLy9jc3MgaXMgb25seSBmb3IgZG9tIGVsZW1lbnRzXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XHRcdHRoaXMuX3R3ZWVuID0gdHdlZW47XG5cdFx0XHR0aGlzLl92YXJzID0gdmFycztcblx0XHRcdF9hdXRvUm91bmQgPSB2YXJzLmF1dG9Sb3VuZDtcblx0XHRcdF9oYXNQcmlvcml0eSA9IGZhbHNlO1xuXHRcdFx0X3N1ZmZpeE1hcCA9IHZhcnMuc3VmZml4TWFwIHx8IENTU1BsdWdpbi5zdWZmaXhNYXA7XG5cdFx0XHRfY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQsIFwiXCIpO1xuXHRcdFx0X292ZXJ3cml0ZVByb3BzID0gdGhpcy5fb3ZlcndyaXRlUHJvcHM7XG5cdFx0XHR2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG5cdFx0XHRcdHYsIHB0LCBwdDIsIGZpcnN0LCBsYXN0LCBuZXh0LCB6SW5kZXgsIHRwdCwgdGhyZWVEO1xuXHRcdFx0aWYgKF9yZXFTYWZhcmlGaXgpIGlmIChzdHlsZS56SW5kZXggPT09IFwiXCIpIHtcblx0XHRcdFx0diA9IF9nZXRTdHlsZSh0YXJnZXQsIFwiekluZGV4XCIsIF9jcyk7XG5cdFx0XHRcdGlmICh2ID09PSBcImF1dG9cIiB8fCB2ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0Ly9jb3JyZWN0cyBhIGJ1ZyBpbiBbbm9uLUFuZHJvaWRdIFNhZmFyaSB0aGF0IHByZXZlbnRzIGl0IGZyb20gcmVwYWludGluZyBlbGVtZW50cyBpbiB0aGVpciBuZXcgcG9zaXRpb25zIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHpJbmRleCBzZXQuIFdlIGFsc28gY2FuJ3QganVzdCBhcHBseSB0aGlzIGluc2lkZSBfcGFyc2VUcmFuc2Zvcm0oKSBiZWNhdXNlIGFueXRoaW5nIHRoYXQncyBtb3ZlZCBpbiBhbnkgd2F5IChsaWtlIHVzaW5nIFwibGVmdFwiIG9yIFwidG9wXCIgaW5zdGVhZCBvZiB0cmFuc2Zvcm1zIGxpa2UgXCJ4XCIgYW5kIFwieVwiKSBjYW4gYmUgYWZmZWN0ZWQsIHNvIGl0IGlzIGJlc3QgdG8gZW5zdXJlIHRoYXQgYW55dGhpbmcgdGhhdCdzIHR3ZWVuaW5nIGhhcyBhIHotaW5kZXguIFNldHRpbmcgXCJXZWJraXRQZXJzcGVjdGl2ZVwiIHRvIGEgbm9uLXplcm8gdmFsdWUgd29ya2VkIHRvbyBleGNlcHQgdGhhdCBvbiBpT1MgU2FmYXJpIHRoaW5ncyB3b3VsZCBmbGlja2VyIHJhbmRvbWx5LiBQbHVzIHpJbmRleCBpcyBsZXNzIG1lbW9yeS1pbnRlbnNpdmUuXG5cdFx0XHRcdFx0dGhpcy5fYWRkTGF6eVNldChzdHlsZSwgXCJ6SW5kZXhcIiwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZih2YXJzKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRmaXJzdCA9IHN0eWxlLmNzc1RleHQ7XG5cdFx0XHRcdHYgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCwgX2NzKTtcblx0XHRcdFx0c3R5bGUuY3NzVGV4dCA9IGZpcnN0ICsgXCI7XCIgKyB2YXJzO1xuXHRcdFx0XHR2ID0gX2Nzc0RpZih0YXJnZXQsIHYsIF9nZXRBbGxTdHlsZXModGFyZ2V0KSkuZGlmcztcblx0XHRcdFx0aWYgKCFfc3VwcG9ydHNPcGFjaXR5ICYmIF9vcGFjaXR5VmFsRXhwLnRlc3QodmFycykpIHtcblx0XHRcdFx0XHR2Lm9wYWNpdHkgPSBwYXJzZUZsb2F0KCBSZWdFeHAuJDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXJzID0gdjtcblx0XHRcdFx0c3R5bGUuY3NzVGV4dCA9IGZpcnN0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFycy5jbGFzc05hbWUpIHsgLy9jbGFzc05hbWUgdHdlZW5zIHdpbGwgY29tYmluZSBhbnkgZGlmZmVyZW5jZXMgdGhleSBmaW5kIGluIHRoZSBjc3Mgd2l0aCB0aGUgdmFycyB0aGF0IGFyZSBwYXNzZWQgaW4sIHNvIHtjbGFzc05hbWU6XCJteUNsYXNzXCIsIHNjYWxlOjAuNSwgbGVmdDoyMH0gd291bGQgd29yay5cblx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0ID0gX3NwZWNpYWxQcm9wcy5jbGFzc05hbWUucGFyc2UodGFyZ2V0LCB2YXJzLmNsYXNzTmFtZSwgXCJjbGFzc05hbWVcIiwgdGhpcywgbnVsbCwgbnVsbCwgdmFycyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSB0aGlzLnBhcnNlKHRhcmdldCwgdmFycywgbnVsbCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl90cmFuc2Zvcm1UeXBlKSB7XG5cdFx0XHRcdHRocmVlRCA9ICh0aGlzLl90cmFuc2Zvcm1UeXBlID09PSAzKTtcblx0XHRcdFx0aWYgKCFfdHJhbnNmb3JtUHJvcCkge1xuXHRcdFx0XHRcdHN0eWxlLnpvb20gPSAxOyAvL2hlbHBzIGNvcnJlY3QgYW4gSUUgaXNzdWUuXG5cdFx0XHRcdH0gZWxzZSBpZiAoX2lzU2FmYXJpKSB7XG5cdFx0XHRcdFx0X3JlcVNhZmFyaUZpeCA9IHRydWU7XG5cdFx0XHRcdFx0Ly9pZiB6SW5kZXggaXNuJ3Qgc2V0LCBpT1MgU2FmYXJpIGRvZXNuJ3QgcmVwYWludCB0aGluZ3MgY29ycmVjdGx5IHNvbWV0aW1lcyAoc2VlbWluZ2x5IGF0IHJhbmRvbSkuXG5cdFx0XHRcdFx0aWYgKHN0eWxlLnpJbmRleCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0ekluZGV4ID0gX2dldFN0eWxlKHRhcmdldCwgXCJ6SW5kZXhcIiwgX2NzKTtcblx0XHRcdFx0XHRcdGlmICh6SW5kZXggPT09IFwiYXV0b1wiIHx8IHpJbmRleCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9hZGRMYXp5U2V0KHN0eWxlLCBcInpJbmRleFwiLCAwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9TZXR0aW5nIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSBjb3JyZWN0cyAzIGJ1Z3M6XG5cdFx0XHRcdFx0Ly8gMSkgW25vbi1BbmRyb2lkXSBTYWZhcmkgc2tpcHMgcmVuZGVyaW5nIGNoYW5nZXMgdG8gXCJ0b3BcIiBhbmQgXCJsZWZ0XCIgdGhhdCBhcmUgbWFkZSBvbiB0aGUgc2FtZSBmcmFtZS9yZW5kZXIgYXMgYSB0cmFuc2Zvcm0gdXBkYXRlLlxuXHRcdFx0XHRcdC8vIDIpIGlPUyBTYWZhcmkgc29tZXRpbWVzIG5lZ2xlY3RzIHRvIHJlcGFpbnQgZWxlbWVudHMgaW4gdGhlaXIgbmV3IHBvc2l0aW9ucy4gU2V0dGluZyBcIldlYmtpdFBlcnNwZWN0aXZlXCIgdG8gYSBub24temVybyB2YWx1ZSB3b3JrZWQgdG9vIGV4Y2VwdCB0aGF0IG9uIGlPUyBTYWZhcmkgdGhpbmdzIHdvdWxkIGZsaWNrZXIgcmFuZG9tbHkuXG5cdFx0XHRcdFx0Ly8gMykgU2FmYXJpIHNvbWV0aW1lcyBkaXNwbGF5ZWQgb2RkIGFydGlmYWN0cyB3aGVuIHR3ZWVuaW5nIHRoZSB0cmFuc2Zvcm0gKG9yIFdlYmtpdFRyYW5zZm9ybSkgcHJvcGVydHksIGxpa2UgZ2hvc3RzIG9mIHRoZSBlZGdlcyBvZiB0aGUgZWxlbWVudCByZW1haW5lZC4gRGVmaW5pdGVseSBhIGJyb3dzZXIgYnVnLlxuXHRcdFx0XHRcdC8vTm90ZTogd2UgYWxsb3cgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgdGhlIGF1dG8tc2V0dGluZyBieSBkZWZpbmluZyBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgaW4gdGhlIHZhcnMgb2YgdGhlIHR3ZWVuLlxuXHRcdFx0XHRcdGlmIChfaXNTYWZhcmlMVDYpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZExhenlTZXQoc3R5bGUsIFwiV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5XCIsIHRoaXMuX3ZhcnMuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IHx8ICh0aHJlZUQgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQyID0gcHQ7XG5cdFx0XHRcdHdoaWxlIChwdDIgJiYgcHQyLl9uZXh0KSB7XG5cdFx0XHRcdFx0cHQyID0gcHQyLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4odGFyZ2V0LCBcInRyYW5zZm9ybVwiLCAwLCAwLCBudWxsLCAyKTtcblx0XHRcdFx0dGhpcy5fbGlua0NTU1AodHB0LCBudWxsLCBwdDIpO1xuXHRcdFx0XHR0cHQuc2V0UmF0aW8gPSBfdHJhbnNmb3JtUHJvcCA/IF9zZXRUcmFuc2Zvcm1SYXRpbyA6IF9zZXRJRVRyYW5zZm9ybVJhdGlvO1xuXHRcdFx0XHR0cHQuZGF0YSA9IHRoaXMuX3RyYW5zZm9ybSB8fCBfZ2V0VHJhbnNmb3JtKHRhcmdldCwgX2NzLCB0cnVlKTtcblx0XHRcdFx0dHB0LnR3ZWVuID0gdHdlZW47XG5cdFx0XHRcdHRwdC5wciA9IC0xOyAvL2Vuc3VyZXMgdGhhdCB0aGUgdHJhbnNmb3JtcyBnZXQgYXBwbGllZCBhZnRlciB0aGUgY29tcG9uZW50cyBhcmUgdXBkYXRlZC5cblx0XHRcdFx0X292ZXJ3cml0ZVByb3BzLnBvcCgpOyAvL3dlIGRvbid0IHdhbnQgdG8gZm9yY2UgdGhlIG92ZXJ3cml0ZSBvZiBhbGwgXCJ0cmFuc2Zvcm1cIiB0d2VlbnMgb2YgdGhlIHRhcmdldCAtIHdlIG9ubHkgY2FyZSBhYm91dCBpbmRpdmlkdWFsIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGVYLCByb3RhdGlvbiwgZXRjLiBUaGUgQ1NTUHJvcFR3ZWVuIGNvbnN0cnVjdG9yIGF1dG9tYXRpY2FsbHkgYWRkcyB0aGUgcHJvcGVydHkgdG8gX292ZXJ3cml0ZVByb3BzIHdoaWNoIGlzIHdoeSB3ZSBuZWVkIHRvIHBvcCgpIGhlcmUuXG5cdFx0XHR9XG5cblx0XHRcdGlmIChfaGFzUHJpb3JpdHkpIHtcblx0XHRcdFx0Ly9yZW9yZGVycyB0aGUgbGlua2VkIGxpc3QgaW4gb3JkZXIgb2YgcHIgKHByaW9yaXR5KVxuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRuZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0cHQyID0gZmlyc3Q7XG5cdFx0XHRcdFx0d2hpbGUgKHB0MiAmJiBwdDIucHIgPiBwdC5wcikge1xuXHRcdFx0XHRcdFx0cHQyID0gcHQyLl9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9wcmV2ID0gcHQyID8gcHQyLl9wcmV2IDogbGFzdCkpIHtcblx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcnN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX25leHQgPSBwdDIpKSB7XG5cdFx0XHRcdFx0XHRwdDIuX3ByZXYgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGFzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IGZpcnN0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXG5cdFx0cC5wYXJzZSA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgcHQsIHBsdWdpbikge1xuXHRcdFx0dmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuXHRcdFx0XHRwLCBzcCwgYm4sIGVuLCBicywgZXMsIGJzZngsIGVzZngsIGlzU3RyLCByZWw7XG5cdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRlcyA9IHZhcnNbcF07IC8vZW5kaW5nIHZhbHVlIHN0cmluZ1xuXHRcdFx0XHRzcCA9IF9zcGVjaWFsUHJvcHNbcF07IC8vU3BlY2lhbFByb3AgbG9va3VwLlxuXHRcdFx0XHRpZiAoc3ApIHtcblx0XHRcdFx0XHRwdCA9IHNwLnBhcnNlKHRhcmdldCwgZXMsIHAsIHRoaXMsIHB0LCBwbHVnaW4sIHZhcnMpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnMgPSBfZ2V0U3R5bGUodGFyZ2V0LCBwLCBfY3MpICsgXCJcIjtcblx0XHRcdFx0XHRpc1N0ciA9ICh0eXBlb2YoZXMpID09PSBcInN0cmluZ1wiKTtcblx0XHRcdFx0XHRpZiAocCA9PT0gXCJjb2xvclwiIHx8IHAgPT09IFwiZmlsbFwiIHx8IHAgPT09IFwic3Ryb2tlXCIgfHwgcC5pbmRleE9mKFwiQ29sb3JcIikgIT09IC0xIHx8IChpc1N0ciAmJiBfcmdiaHNsRXhwLnRlc3QoZXMpKSkgeyAvL09wZXJhIHVzZXMgYmFja2dyb3VuZDogdG8gZGVmaW5lIGNvbG9yIHNvbWV0aW1lcyBpbiBhZGRpdGlvbiB0byBiYWNrZ3JvdW5kQ29sb3I6XG5cdFx0XHRcdFx0XHRpZiAoIWlzU3RyKSB7XG5cdFx0XHRcdFx0XHRcdGVzID0gX3BhcnNlQ29sb3IoZXMpO1xuXHRcdFx0XHRcdFx0XHRlcyA9ICgoZXMubGVuZ3RoID4gMykgPyBcInJnYmEoXCIgOiBcInJnYihcIikgKyBlcy5qb2luKFwiLFwiKSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cHQgPSBfcGFyc2VDb21wbGV4KHN0eWxlLCBwLCBicywgZXMsIHRydWUsIFwidHJhbnNwYXJlbnRcIiwgcHQsIDAsIHBsdWdpbik7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGlzU3RyICYmIF9jb21wbGV4RXhwLnRlc3QoZXMpKSB7XG5cdFx0XHRcdFx0XHRwdCA9IF9wYXJzZUNvbXBsZXgoc3R5bGUsIHAsIGJzLCBlcywgdHJ1ZSwgbnVsbCwgcHQsIDAsIHBsdWdpbik7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ym4gPSBwYXJzZUZsb2F0KGJzKTtcblx0XHRcdFx0XHRcdGJzZnggPSAoYm4gfHwgYm4gPT09IDApID8gYnMuc3Vic3RyKChibiArIFwiXCIpLmxlbmd0aCkgOiBcIlwiOyAvL3JlbWVtYmVyLCBicyBjb3VsZCBiZSBub24tbnVtZXJpYyBsaWtlIFwibm9ybWFsXCIgZm9yIGZvbnRXZWlnaHQsIHNvIHdlIHNob3VsZCBkZWZhdWx0IHRvIGEgYmxhbmsgc3VmZml4IGluIHRoYXQgY2FzZS5cblxuXHRcdFx0XHRcdFx0aWYgKGJzID09PSBcIlwiIHx8IGJzID09PSBcImF1dG9cIikge1xuXHRcdFx0XHRcdFx0XHRpZiAocCA9PT0gXCJ3aWR0aFwiIHx8IHAgPT09IFwiaGVpZ2h0XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiA9IF9nZXREaW1lbnNpb24odGFyZ2V0LCBwLCBfY3MpO1xuXHRcdFx0XHRcdFx0XHRcdGJzZnggPSBcInB4XCI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocCA9PT0gXCJsZWZ0XCIgfHwgcCA9PT0gXCJ0b3BcIikge1xuXHRcdFx0XHRcdFx0XHRcdGJuID0gX2NhbGN1bGF0ZU9mZnNldCh0YXJnZXQsIHAsIF9jcyk7XG5cdFx0XHRcdFx0XHRcdFx0YnNmeCA9IFwicHhcIjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRibiA9IChwICE9PSBcIm9wYWNpdHlcIikgPyAwIDogMTtcblx0XHRcdFx0XHRcdFx0XHRic2Z4ID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZWwgPSAoaXNTdHIgJiYgZXMuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0XHRpZiAocmVsKSB7XG5cdFx0XHRcdFx0XHRcdGVuID0gcGFyc2VJbnQoZXMuY2hhckF0KDApICsgXCIxXCIsIDEwKTtcblx0XHRcdFx0XHRcdFx0ZXMgPSBlcy5zdWJzdHIoMik7XG5cdFx0XHRcdFx0XHRcdGVuICo9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdFx0XHRlc2Z4ID0gZXMucmVwbGFjZShfc3VmZml4RXhwLCBcIlwiKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGVuID0gcGFyc2VGbG9hdChlcyk7XG5cdFx0XHRcdFx0XHRcdGVzZnggPSBpc1N0ciA/IGVzLnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIikgOiBcIlwiO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoZXNmeCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0XHRlc2Z4ID0gKHAgaW4gX3N1ZmZpeE1hcCkgPyBfc3VmZml4TWFwW3BdIDogYnNmeDsgLy9wb3B1bGF0ZSB0aGUgZW5kIHN1ZmZpeCwgcHJpb3JpdGl6aW5nIHRoZSBtYXAsIHRoZW4gaWYgbm9uZSBpcyBmb3VuZCwgdXNlIHRoZSBiZWdpbm5pbmcgc3VmZml4LlxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRlcyA9IChlbiB8fCBlbiA9PT0gMCkgPyAocmVsID8gZW4gKyBibiA6IGVuKSArIGVzZnggOiB2YXJzW3BdOyAvL2Vuc3VyZXMgdGhhdCBhbnkgKz0gb3IgLT0gcHJlZml4ZXMgYXJlIHRha2VuIGNhcmUgb2YuIFJlY29yZCB0aGUgZW5kIHZhbHVlIGJlZm9yZSBub3JtYWxpemluZyB0aGUgc3VmZml4IGJlY2F1c2Ugd2UgYWx3YXlzIHdhbnQgdG8gZW5kIHRoZSB0d2VlbiBvbiBleGFjdGx5IHdoYXQgdGhleSBpbnRlbmRlZCBldmVuIGlmIGl0IGRvZXNuJ3QgbWF0Y2ggdGhlIGJlZ2lubmluZyB2YWx1ZSdzIHN1ZmZpeC5cblxuXHRcdFx0XHRcdFx0Ly9pZiB0aGUgYmVnaW5uaW5nL2VuZGluZyBzdWZmaXhlcyBkb24ndCBtYXRjaCwgbm9ybWFsaXplIHRoZW0uLi5cblx0XHRcdFx0XHRcdGlmIChic2Z4ICE9PSBlc2Z4KSBpZiAoZXNmeCAhPT0gXCJcIikgaWYgKGVuIHx8IGVuID09PSAwKSBpZiAoYm4pIHsgLy9ub3RlOiBpZiB0aGUgYmVnaW5uaW5nIHZhbHVlIChibikgaXMgMCwgd2UgZG9uJ3QgbmVlZCB0byBjb252ZXJ0IHVuaXRzIVxuXHRcdFx0XHRcdFx0XHRibiA9IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCBibiwgYnNmeCk7XG5cdFx0XHRcdFx0XHRcdGlmIChlc2Z4ID09PSBcIiVcIikge1xuXHRcdFx0XHRcdFx0XHRcdGJuIC89IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCAxMDAsIFwiJVwiKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0XHRpZiAodmFycy5zdHJpY3RVbml0cyAhPT0gdHJ1ZSkgeyAvL3NvbWUgYnJvd3NlcnMgcmVwb3J0IG9ubHkgXCJweFwiIHZhbHVlcyBpbnN0ZWFkIG9mIGFsbG93aW5nIFwiJVwiIHdpdGggZ2V0Q29tcHV0ZWRTdHlsZSgpLCBzbyB3ZSBhc3N1bWUgdGhhdCBpZiB3ZSdyZSB0d2VlbmluZyB0byBhICUsIHdlIHNob3VsZCBzdGFydCB0aGVyZSB0b28gdW5sZXNzIHN0cmljdFVuaXRzOnRydWUgaXMgZGVmaW5lZC4gVGhpcyBhcHByb2FjaCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciByZXNwb25zaXZlIGRlc2lnbnMgdGhhdCB1c2UgZnJvbSgpIHR3ZWVucy5cblx0XHRcdFx0XHRcdFx0XHRcdGJzID0gYm4gKyBcIiVcIjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlc2Z4ID09PSBcImVtXCIgfHwgZXNmeCA9PT0gXCJyZW1cIiB8fCBlc2Z4ID09PSBcInZ3XCIgfHwgZXNmeCA9PT0gXCJ2aFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gLz0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIDEsIGVzZngpO1xuXG5cdFx0XHRcdFx0XHRcdC8vb3RoZXJ3aXNlIGNvbnZlcnQgdG8gcGl4ZWxzLlxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGVzZnggIT09IFwicHhcIikge1xuXHRcdFx0XHRcdFx0XHRcdGVuID0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIGVuLCBlc2Z4KTtcblx0XHRcdFx0XHRcdFx0XHRlc2Z4ID0gXCJweFwiOyAvL3dlIGRvbid0IHVzZSBic2Z4IGFmdGVyIHRoaXMsIHNvIHdlIGRvbid0IG5lZWQgdG8gc2V0IGl0IHRvIHB4IHRvby5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAocmVsKSBpZiAoZW4gfHwgZW4gPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRlcyA9IChlbiArIGJuKSArIGVzZng7IC8vdGhlIGNoYW5nZXMgd2UgbWFkZSBhZmZlY3QgcmVsYXRpdmUgY2FsY3VsYXRpb25zLCBzbyBhZGp1c3QgdGhlIGVuZCB2YWx1ZSBoZXJlLlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRcdFx0ZW4gKz0gYm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICgoYm4gfHwgYm4gPT09IDApICYmIChlbiB8fCBlbiA9PT0gMCkpIHsgLy9mYXN0ZXIgdGhhbiBpc05hTigpLiBBbHNvLCBwcmV2aW91c2x5IHdlIHJlcXVpcmVkIGVuICE9PSBibiBidXQgdGhhdCBkb2Vzbid0IHJlYWxseSBnYWluIG11Y2ggcGVyZm9ybWFuY2UgYW5kIGl0IHByZXZlbnRzIF9wYXJzZVRvUHJveHkoKSBmcm9tIHdvcmtpbmcgcHJvcGVybHkgaWYgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIG1hdGNoIGJ1dCBuZWVkIHRvIGdldCB0d2VlbmVkIGJ5IGFuIGV4dGVybmFsIHBsdWdpbiBhbnl3YXkuIEZvciBleGFtcGxlLCBhIGJlemllciB0d2VlbiB3aGVyZSB0aGUgdGFyZ2V0IHN0YXJ0cyBhdCBsZWZ0OjAgYW5kIGhhcyB0aGVzZSBwb2ludHM6IFt7bGVmdDo1MH0se2xlZnQ6MH1dIHdvdWxkbid0IHdvcmsgcHJvcGVybHkgYmVjYXVzZSB3aGVuIHBhcnNpbmcgdGhlIGxhc3QgcG9pbnQsIGl0J2QgbWF0Y2ggdGhlIGZpcnN0IChjdXJyZW50KSBvbmUgYW5kIGEgbm9uLXR3ZWVuaW5nIENTU1Byb3BUd2VlbiB3b3VsZCBiZSByZWNvcmRlZCB3aGVuIHdlIGFjdHVhbGx5IG5lZWQgYSBub3JtYWwgdHdlZW4gKHR5cGU6MCkgc28gdGhhdCB0aGluZ3MgZ2V0IHVwZGF0ZWQgZHVyaW5nIHRoZSB0d2VlbiBwcm9wZXJseS5cblx0XHRcdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBwLCBibiwgZW4gLSBibiwgcHQsIDAsIHAsIChfYXV0b1JvdW5kICE9PSBmYWxzZSAmJiAoZXNmeCA9PT0gXCJweFwiIHx8IHAgPT09IFwiekluZGV4XCIpKSwgMCwgYnMsIGVzKTtcblx0XHRcdFx0XHRcdFx0cHQueHMwID0gZXNmeDtcblx0XHRcdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcInR3ZWVuIFwiK3ArXCIgZnJvbSBcIitwdC5iK1wiIChcIitibitlc2Z4K1wiKSB0byBcIitwdC5lK1wiIHdpdGggc3VmZml4OiBcIitwdC54czApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzdHlsZVtwXSA9PT0gdW5kZWZpbmVkIHx8ICFlcyAmJiAoZXMgKyBcIlwiID09PSBcIk5hTlwiIHx8IGVzID09IG51bGwpKSB7XG5cdFx0XHRcdFx0XHRcdF9sb2coXCJpbnZhbGlkIFwiICsgcCArIFwiIHR3ZWVuIHZhbHVlOiBcIiArIHZhcnNbcF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBwLCBlbiB8fCBibiB8fCAwLCAwLCBwdCwgLTEsIHAsIGZhbHNlLCAwLCBicywgZXMpO1xuXHRcdFx0XHRcdFx0XHRwdC54czAgPSAoZXMgPT09IFwibm9uZVwiICYmIChwID09PSBcImRpc3BsYXlcIiB8fCBwLmluZGV4T2YoXCJTdHlsZVwiKSAhPT0gLTEpKSA/IGJzIDogZXM7IC8vaW50ZXJtZWRpYXRlIHZhbHVlIHNob3VsZCB0eXBpY2FsbHkgYmUgc2V0IGltbWVkaWF0ZWx5IChlbmQgdmFsdWUpIGV4Y2VwdCBmb3IgXCJkaXNwbGF5XCIgb3IgdGhpbmdzIGxpa2UgYm9yZGVyVG9wU3R5bGUsIGJvcmRlckJvdHRvbVN0eWxlLCBldGMuIHdoaWNoIHNob3VsZCB1c2UgdGhlIGJlZ2lubmluZyB2YWx1ZSBkdXJpbmcgdGhlIHR3ZWVuLlxuXHRcdFx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwibm9uLXR3ZWVuaW5nIHZhbHVlIFwiK3ArXCI6IFwiK3B0LnhzMCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwbHVnaW4pIGlmIChwdCAmJiAhcHQucGx1Z2luKSB7XG5cdFx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fTtcblxuXG5cdFx0Ly9nZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSB0d2VlbiB1cGRhdGVzLCBwYXNzaW5nIHRoZSBuZXcgcmF0aW8gKHR5cGljYWxseSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgYnV0IG5vdCBhbHdheXMgKGZvciBleGFtcGxlLCBpZiBhbiBFbGFzdGljLmVhc2VPdXQgaXMgdXNlZCwgdGhlIHZhbHVlIGNhbiBqdW1wIGFib3ZlIDEgbWlkLXR3ZWVuKS4gSXQgd2lsbCBhbHdheXMgc3RhcnQgYW5kIDAgYW5kIGVuZCBhdCAxLlxuXHRcdHAuc2V0UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0dmFsLCBzdHIsIGk7XG5cdFx0XHQvL2F0IHRoZSBlbmQgb2YgdGhlIHR3ZWVuLCB3ZSBzZXQgdGhlIHZhbHVlcyB0byBleGFjdGx5IHdoYXQgd2UgcmVjZWl2ZWQgaW4gb3JkZXIgdG8gbWFrZSBzdXJlIG5vbi10d2VlbmluZyB2YWx1ZXMgKGxpa2UgXCJwb3NpdGlvblwiIG9yIFwiZmxvYXRcIiBvciB3aGF0ZXZlcikgYXJlIHNldCBhbmQgc28gdGhhdCBpZiB0aGUgYmVnaW5uaW5nL2VuZGluZyBzdWZmaXhlcyAodW5pdHMpIGRpZG4ndCBtYXRjaCBhbmQgd2Ugbm9ybWFsaXplZCB0byBweCwgdGhlIHZhbHVlIHRoYXQgdGhlIHVzZXIgcGFzc2VkIGluIGlzIHVzZWQgaGVyZS4gV2UgY2hlY2sgdG8gc2VlIGlmIHRoZSB0d2VlbiBpcyBhdCBpdHMgYmVnaW5uaW5nIGluIGNhc2UgaXQncyBhIGZyb20oKSB0d2VlbiBpbiB3aGljaCBjYXNlIHRoZSByYXRpbyB3aWxsIGFjdHVhbGx5IGdvIGZyb20gMSB0byAwIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgdHdlZW4gKGJhY2t3YXJkcykuXG5cdFx0XHRpZiAodiA9PT0gMSAmJiAodGhpcy5fdHdlZW4uX3RpbWUgPT09IHRoaXMuX3R3ZWVuLl9kdXJhdGlvbiB8fCB0aGlzLl90d2Vlbi5fdGltZSA9PT0gMCkpIHtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LnR5cGUgIT09IDIpIHtcblx0XHRcdFx0XHRcdGlmIChwdC5yICYmIHB0LnR5cGUgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHZhbCA9IE1hdGgucm91bmQocHQucyArIHB0LmMpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIXB0LnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gdmFsICsgcHQueHMwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IDEpIHsgLy9jb21wbGV4IHZhbHVlIChvbmUgdGhhdCB0eXBpY2FsbHkgaGFzIG11bHRpcGxlIG51bWJlcnMgaW5zaWRlIGEgc3RyaW5nLCBsaWtlIFwicmVjdCg1cHgsMTBweCwyMHB4LDI1cHgpXCJcblx0XHRcdFx0XHRcdFx0XHRpID0gcHQubDtcblx0XHRcdFx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyB2YWwgKyBwdC54czE7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieG5cIitpXSArIHB0W1wieHNcIisoaSsxKV07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBzdHI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC5lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC5zZXRSYXRpbyh2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHYgfHwgISh0aGlzLl90d2Vlbi5fdGltZSA9PT0gdGhpcy5fdHdlZW4uX2R1cmF0aW9uIHx8IHRoaXMuX3R3ZWVuLl90aW1lID09PSAwKSB8fCB0aGlzLl90d2Vlbi5fcmF3UHJldlRpbWUgPT09IC0wLjAwMDAwMSkge1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHR2YWwgPSBwdC5jICogdiArIHB0LnM7XG5cdFx0XHRcdFx0aWYgKHB0LnIpIHtcblx0XHRcdFx0XHRcdHZhbCA9IE1hdGgucm91bmQodmFsKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbCA8IG1pbikgaWYgKHZhbCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHZhbCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghcHQudHlwZSkge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHZhbCArIHB0LnhzMDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IDEpIHsgLy9jb21wbGV4IHZhbHVlIChvbmUgdGhhdCB0eXBpY2FsbHkgaGFzIG11bHRpcGxlIG51bWJlcnMgaW5zaWRlIGEgc3RyaW5nLCBsaWtlIFwicmVjdCg1cHgsMTBweCwyMHB4LDI1cHgpXCJcblx0XHRcdFx0XHRcdGkgPSBwdC5sO1xuXHRcdFx0XHRcdFx0aWYgKGkgPT09IDIpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMjtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gMykge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyICsgcHQueG4yICsgcHQueHMzO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpID09PSA0KSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czIgKyBwdC54bjIgKyBwdC54czMgKyBwdC54bjMgKyBwdC54czQ7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IDUpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMiArIHB0LnhuMiArIHB0LnhzMyArIHB0LnhuMyArIHB0LnhzNCArIHB0LnhuNCArIHB0LnhzNTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0ciA9IHB0LnhzMCArIHZhbCArIHB0LnhzMTtcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhuXCIraV0gKyBwdFtcInhzXCIrKGkrMSldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBzdHI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IC0xKSB7IC8vbm9uLXR3ZWVuaW5nIHZhbHVlXG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC5zZXRSYXRpbykgeyAvL2N1c3RvbSBzZXRSYXRpbygpIGZvciB0aGluZ3MgbGlrZSBTcGVjaWFsUHJvcHMsIGV4dGVybmFsIHBsdWdpbnMsIGV0Yy5cblx0XHRcdFx0XHRcdHB0LnNldFJhdGlvKHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vaWYgdGhlIHR3ZWVuIGlzIHJldmVyc2VkIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZywgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgd2hpY2ggbWF5IGhhdmUgZGlmZmVyZW50IHVuaXRzIChsaWtlICUgaW5zdGVhZCBvZiBweCBvciBlbSBvciB3aGF0ZXZlcikuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRpZiAocHQudHlwZSAhPT0gMikge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnNldFJhdGlvKHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogRm9yY2VzIHJlbmRlcmluZyBvZiB0aGUgdGFyZ2V0J3MgdHJhbnNmb3JtcyAocm90YXRpb24sIHNjYWxlLCBldGMuKSB3aGVuZXZlciB0aGUgQ1NTUGx1Z2luJ3Mgc2V0UmF0aW8oKSBpcyBjYWxsZWQuXG5cdFx0ICogQmFzaWNhbGx5LCB0aGlzIHRlbGxzIHRoZSBDU1NQbHVnaW4gdG8gY3JlYXRlIGEgQ1NTUHJvcFR3ZWVuICh0eXBlIDIpIGFmdGVyIGluc3RhbnRpYXRpb24gdGhhdCBydW5zIGxhc3QgaW4gdGhlIGxpbmtlZFxuXHRcdCAqIGxpc3QgYW5kIGNhbGxzIHRoZSBhcHByb3ByaWF0ZSAoM0Qgb3IgMkQpIHJlbmRlcmluZyBmdW5jdGlvbi4gV2Ugc2VwYXJhdGUgdGhpcyBpbnRvIGl0cyBvd24gbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNhbGxcblx0XHQgKiBpdCBmcm9tIG90aGVyIHBsdWdpbnMgbGlrZSBCZXppZXJQbHVnaW4gaWYsIGZvciBleGFtcGxlLCBpdCBuZWVkcyB0byBhcHBseSBhbiBhdXRvUm90YXRpb24gYW5kIHRoaXMgQ1NTUGx1Z2luXG5cdFx0ICogZG9lc24ndCBoYXZlIGFueSB0cmFuc2Zvcm0tcmVsYXRlZCBwcm9wZXJ0aWVzIG9mIGl0cyBvd24uIFlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZCBhcyBtYW55IHRpbWVzIGFzIHlvdVxuXHRcdCAqIHdhbnQgYW5kIGl0IHdvbid0IGNyZWF0ZSBkdXBsaWNhdGUgQ1NTUHJvcFR3ZWVucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdGhyZWVEIGlmIHRydWUsIGl0IHNob3VsZCBhcHBseSAzRCB0d2VlbnMgKG90aGVyd2lzZSwganVzdCAyRCBvbmVzIGFyZSBmaW5lIGFuZCB0eXBpY2FsbHkgZmFzdGVyKVxuXHRcdCAqL1xuXHRcdHAuX2VuYWJsZVRyYW5zZm9ybXMgPSBmdW5jdGlvbih0aHJlZUQpIHtcblx0XHRcdHRoaXMuX3RyYW5zZm9ybSA9IHRoaXMuX3RyYW5zZm9ybSB8fCBfZ2V0VHJhbnNmb3JtKHRoaXMuX3RhcmdldCwgX2NzLCB0cnVlKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGVsZW1lbnQgaGFzIGEgX2dzVHJhbnNmb3JtIHByb3BlcnR5IHdpdGggdGhlIGFwcHJvcHJpYXRlIHZhbHVlcy5cblx0XHRcdHRoaXMuX3RyYW5zZm9ybVR5cGUgPSAoISh0aGlzLl90cmFuc2Zvcm0uc3ZnICYmIF91c2VTVkdUcmFuc2Zvcm1BdHRyKSAmJiAodGhyZWVEIHx8IHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09IDMpKSA/IDMgOiAyO1xuXHRcdH07XG5cblx0XHR2YXIgbGF6eVNldCA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdHRoaXMudFt0aGlzLnBdID0gdGhpcy5lO1xuXHRcdFx0dGhpcy5kYXRhLl9saW5rQ1NTUCh0aGlzLCB0aGlzLl9uZXh0LCBudWxsLCB0cnVlKTsgLy93ZSBwdXJwb3NlZnVsbHkga2VlcCB0aGlzLl9uZXh0IGV2ZW4gdGhvdWdoIGl0J2QgbWFrZSBzZW5zZSB0byBudWxsIGl0LCBidXQgdGhpcyBpcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgYXMgdGhpcyBoYXBwZW5zIGR1cmluZyB0aGUgd2hpbGUgKHB0KSB7fSBsb29wIGluIHNldFJhdGlvKCkgYXQgdGhlIGJvdHRvbSBvZiB3aGljaCBpdCBzZXRzIHB0ID0gcHQuX25leHQsIHNvIGlmIHdlIG51bGwgaXQsIHRoZSBsaW5rZWQgbGlzdCB3aWxsIGJlIGJyb2tlbiBpbiB0aGF0IGxvb3AuXG5cdFx0fTtcblx0XHQvKiogQHByaXZhdGUgR2l2ZXMgdXMgYSB3YXkgdG8gc2V0IGEgdmFsdWUgb24gdGhlIGZpcnN0IHJlbmRlciAoYW5kIG9ubHkgdGhlIGZpcnN0IHJlbmRlcikuICoqL1xuXHRcdHAuX2FkZExhenlTZXQgPSBmdW5jdGlvbih0LCBwLCB2KSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBUID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCB0aGlzLl9maXJzdFBULCAyKTtcblx0XHRcdHB0LmUgPSB2O1xuXHRcdFx0cHQuc2V0UmF0aW8gPSBsYXp5U2V0O1xuXHRcdFx0cHQuZGF0YSA9IHRoaXM7XG5cdFx0fTtcblxuXHRcdC8qKiBAcHJpdmF0ZSAqKi9cblx0XHRwLl9saW5rQ1NTUCA9IGZ1bmN0aW9uKHB0LCBuZXh0LCBwcmV2LCByZW1vdmUpIHtcblx0XHRcdGlmIChwdCkge1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdG5leHQuX3ByZXYgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0cmVtb3ZlID0gdHJ1ZTsgLy9qdXN0IHRvIHByZXZlbnQgcmVzZXR0aW5nIHRoaXMuX2ZpcnN0UFQgNSBsaW5lcyBkb3duIGluIGNhc2UgcHQuX25leHQgaXMgbnVsbC4gKG9wdGltaXplZCBmb3Igc3BlZWQpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByZXYpIHtcblx0XHRcdFx0XHRwcmV2Ll9uZXh0ID0gcHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXJlbW92ZSAmJiB0aGlzLl9maXJzdFBUID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0Ll9uZXh0ID0gbmV4dDtcblx0XHRcdFx0cHQuX3ByZXYgPSBwcmV2O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH07XG5cblx0XHQvL3dlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgaWYgYWxwaGEgb3IgYXV0b0FscGhhIGlzIGtpbGxlZCwgb3BhY2l0eSBpcyB0b28uIEFuZCBhdXRvQWxwaGEgYWZmZWN0cyB0aGUgXCJ2aXNpYmlsaXR5XCIgcHJvcGVydHkuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGNvcHkgPSBsb29rdXAsXG5cdFx0XHRcdHB0LCBwLCB4Zmlyc3Q7XG5cdFx0XHRpZiAobG9va3VwLmF1dG9BbHBoYSB8fCBsb29rdXAuYWxwaGEpIHtcblx0XHRcdFx0Y29weSA9IHt9O1xuXHRcdFx0XHRmb3IgKHAgaW4gbG9va3VwKSB7IC8vY29weSB0aGUgbG9va3VwIHNvIHRoYXQgd2UncmUgbm90IGNoYW5naW5nIHRoZSBvcmlnaW5hbCB3aGljaCBtYXkgYmUgcGFzc2VkIGVsc2V3aGVyZS5cblx0XHRcdFx0XHRjb3B5W3BdID0gbG9va3VwW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvcHkub3BhY2l0eSA9IDE7XG5cdFx0XHRcdGlmIChjb3B5LmF1dG9BbHBoYSkge1xuXHRcdFx0XHRcdGNvcHkudmlzaWJpbGl0eSA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChsb29rdXAuY2xhc3NOYW1lICYmIChwdCA9IHRoaXMuX2NsYXNzTmFtZVBUKSkgeyAvL2ZvciBjbGFzc05hbWUgdHdlZW5zLCB3ZSBuZWVkIHRvIGtpbGwgYW55IGFzc29jaWF0ZWQgQ1NTUHJvcFR3ZWVucyB0b287IGEgbGlua2VkIGxpc3Qgc3RhcnRzIGF0IHRoZSBjbGFzc05hbWUncyBcInhmaXJzdFwiLlxuXHRcdFx0XHR4Zmlyc3QgPSBwdC54Zmlyc3Q7XG5cdFx0XHRcdGlmICh4Zmlyc3QgJiYgeGZpcnN0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0dGhpcy5fbGlua0NTU1AoeGZpcnN0Ll9wcmV2LCBwdC5fbmV4dCwgeGZpcnN0Ll9wcmV2Ll9wcmV2KTsgLy9icmVhayBvZmYgdGhlIHByZXZcblx0XHRcdFx0fSBlbHNlIGlmICh4Zmlyc3QgPT09IHRoaXMuX2ZpcnN0UFQpIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0dGhpcy5fbGlua0NTU1AocHQuX25leHQsIHB0Ll9uZXh0Ll9uZXh0LCB4Zmlyc3QuX3ByZXYpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NsYXNzTmFtZVBUID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBUd2VlblBsdWdpbi5wcm90b3R5cGUuX2tpbGwuY2FsbCh0aGlzLCBjb3B5KTtcblx0XHR9O1xuXG5cblxuXHRcdC8vdXNlZCBieSBjYXNjYWRlVG8oKSBmb3IgZ2F0aGVyaW5nIGFsbCB0aGUgc3R5bGUgcHJvcGVydGllcyBvZiBlYWNoIGNoaWxkIGVsZW1lbnQgaW50byBhbiBhcnJheSBmb3IgY29tcGFyaXNvbi5cblx0XHR2YXIgX2dldENoaWxkU3R5bGVzID0gZnVuY3Rpb24oZSwgcHJvcHMsIHRhcmdldHMpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuLCBpLCBjaGlsZCwgdHlwZTtcblx0XHRcdFx0aWYgKGUuc2xpY2UpIHtcblx0XHRcdFx0XHRpID0gZS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRfZ2V0Q2hpbGRTdHlsZXMoZVtpXSwgcHJvcHMsIHRhcmdldHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGRyZW4gPSBlLmNoaWxkTm9kZXM7XG5cdFx0XHRcdGkgPSBjaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdFx0dHlwZSA9IGNoaWxkLnR5cGU7XG5cdFx0XHRcdFx0aWYgKGNoaWxkLnN0eWxlKSB7XG5cdFx0XHRcdFx0XHRwcm9wcy5wdXNoKF9nZXRBbGxTdHlsZXMoY2hpbGQpKTtcblx0XHRcdFx0XHRcdGlmICh0YXJnZXRzKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldHMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgodHlwZSA9PT0gMSB8fCB0eXBlID09PSA5IHx8IHR5cGUgPT09IDExKSAmJiBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0X2dldENoaWxkU3R5bGVzKGNoaWxkLCBwcm9wcywgdGFyZ2V0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVHlwaWNhbGx5IG9ubHkgdXNlZnVsIGZvciBjbGFzc05hbWUgdHdlZW5zIHRoYXQgbWF5IGFmZmVjdCBjaGlsZCBlbGVtZW50cywgdGhpcyBtZXRob2QgY3JlYXRlcyBhIFR3ZWVuTGl0ZVxuXHRcdCAqIGFuZCB0aGVuIGNvbXBhcmVzIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIG9mIGFsbCB0aGUgdGFyZ2V0J3MgY2hpbGQgZWxlbWVudHMgYXQgdGhlIHR3ZWVuJ3Mgc3RhcnQgYW5kIGVuZCwgYW5kXG5cdFx0ICogaWYgYW55IGFyZSBkaWZmZXJlbnQsIGl0IGFsc28gY3JlYXRlcyB0d2VlbnMgZm9yIHRob3NlIGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgQUxMIG9mIHRoZSByZXN1bHRpbmdcblx0XHQgKiB0d2VlbnMgKHNvIHRoYXQgeW91IGNhbiBlYXNpbHkgYWRkKCkgdGhlbSB0byBhIFRpbWVsaW5lTGl0ZSwgZm9yIGV4YW1wbGUpLiBUaGUgcmVhc29uIHRoaXMgZnVuY3Rpb25hbGl0eSBpc1xuXHRcdCAqIHdyYXBwZWQgaW50byBhIHNlcGFyYXRlIHN0YXRpYyBtZXRob2Qgb2YgQ1NTUGx1Z2luIGluc3RlYWQgb2YgYmVpbmcgaW50ZWdyYXRlZCBpbnRvIGFsbCByZWd1bGFyIGNsYXNzTmFtZSB0d2VlbnNcblx0XHQgKiBpcyBiZWNhdXNlIGl0IGNyZWF0ZXMgZW50aXJlbHkgbmV3IHR3ZWVucyB0aGF0IG1heSBoYXZlIGNvbXBsZXRlbHkgZGlmZmVyZW50IHRhcmdldHMgdGhhbiB0aGUgb3JpZ2luYWwgdHdlZW4sXG5cdFx0ICogc28gaWYgdGhleSB3ZXJlIGFsbCBsdW1wZWQgaW50byB0aGUgb3JpZ2luYWwgdHdlZW4gaW5zdGFuY2UsIGl0IHdvdWxkIGJlIGluY29uc2lzdGVudCB3aXRoIHRoZSByZXN0IG9mIHRoZSBBUElcblx0XHQgKiBhbmQgaXQgd291bGQgY3JlYXRlIG90aGVyIHByb2JsZW1zLiBGb3IgZXhhbXBsZTpcblx0XHQgKiAgLSBJZiBJIGNyZWF0ZSBhIHR3ZWVuIG9mIGVsZW1lbnRBLCB0aGF0IHR3ZWVuIGluc3RhbmNlIG1heSBzdWRkZW5seSBjaGFuZ2UgaXRzIHRhcmdldCB0byBpbmNsdWRlIDUwIG90aGVyIGVsZW1lbnRzICh1bmludHVpdGl2ZSBpZiBJIHNwZWNpZmljYWxseSBkZWZpbmVkIHRoZSB0YXJnZXQgSSB3YW50ZWQpXG5cdFx0ICogIC0gV2UgY2FuJ3QganVzdCBjcmVhdGUgbmV3IGluZGVwZW5kZW50IHR3ZWVucyBiZWNhdXNlIG90aGVyd2lzZSwgd2hhdCBoYXBwZW5zIGlmIHRoZSBvcmlnaW5hbC9wYXJlbnQgdHdlZW4gaXMgcmV2ZXJzZWQgb3IgcGF1c2Ugb3IgZHJvcHBlZCBpbnRvIGEgVGltZWxpbmVMaXRlIGZvciB0aWdodCBjb250cm9sPyBZb3UnZCBleHBlY3QgdGhhdCB0d2VlbidzIGJlaGF2aW9yIHRvIGFmZmVjdCBhbGwgdGhlIG90aGVycy5cblx0XHQgKiAgLSBBbmFseXppbmcgZXZlcnkgc3R5bGUgcHJvcGVydHkgb2YgZXZlcnkgY2hpbGQgYmVmb3JlIGFuZCBhZnRlciB0aGUgdHdlZW4gaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbiB3aGVuIHRoZXJlIGFyZSBtYW55IGNoaWxkcmVuLCBzbyB0aGlzIGJlaGF2aW9yIHNob3VsZG4ndCBiZSBpbXBvc2VkIG9uIGFsbCBjbGFzc05hbWUgdHdlZW5zIGJ5IGRlZmF1bHQsIGVzcGVjaWFsbHkgc2luY2UgaXQncyBwcm9iYWJseSByYXJlIHRoYXQgdGhpcyBleHRyYSBmdW5jdGlvbmFsaXR5IGlzIG5lZWRlZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgb2JqZWN0IHRvIGJlIHR3ZWVuZWRcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gRHVyYXRpb24gaW4gc2Vjb25kcyAob3IgZnJhbWVzIGZvciBmcmFtZXMtYmFzZWQgdHdlZW5zKVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgZW5kIHZhbHVlcywgbGlrZSB7Y2xhc3NOYW1lOlwibmV3Q2xhc3NcIiwgZWFzZTpMaW5lYXIuZWFzZU5vbmV9XG5cdFx0ICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIFR3ZWVuTGl0ZSBpbnN0YW5jZXNcblx0XHQgKi9cblx0XHRDU1NQbHVnaW4uY2FzY2FkZVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0dmFyIHR3ZWVuID0gVHdlZW5MaXRlLnRvKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpLFxuXHRcdFx0XHRyZXN1bHRzID0gW3R3ZWVuXSxcblx0XHRcdFx0YiA9IFtdLFxuXHRcdFx0XHRlID0gW10sXG5cdFx0XHRcdHRhcmdldHMgPSBbXSxcblx0XHRcdFx0X3Jlc2VydmVkUHJvcHMgPSBUd2VlbkxpdGUuX2ludGVybmFscy5yZXNlcnZlZFByb3BzLFxuXHRcdFx0XHRpLCBkaWZzLCBwLCBmcm9tO1xuXHRcdFx0dGFyZ2V0ID0gdHdlZW4uX3RhcmdldHMgfHwgdHdlZW4udGFyZ2V0O1xuXHRcdFx0X2dldENoaWxkU3R5bGVzKHRhcmdldCwgYiwgdGFyZ2V0cyk7XG5cdFx0XHR0d2Vlbi5yZW5kZXIoZHVyYXRpb24sIHRydWUsIHRydWUpO1xuXHRcdFx0X2dldENoaWxkU3R5bGVzKHRhcmdldCwgZSk7XG5cdFx0XHR0d2Vlbi5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHR0d2Vlbi5fZW5hYmxlZCh0cnVlKTtcblx0XHRcdGkgPSB0YXJnZXRzLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRkaWZzID0gX2Nzc0RpZih0YXJnZXRzW2ldLCBiW2ldLCBlW2ldKTtcblx0XHRcdFx0aWYgKGRpZnMuZmlyc3RNUFQpIHtcblx0XHRcdFx0XHRkaWZzID0gZGlmcy5kaWZzO1xuXHRcdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0XHRpZiAoX3Jlc2VydmVkUHJvcHNbcF0pIHtcblx0XHRcdFx0XHRcdFx0ZGlmc1twXSA9IHZhcnNbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZyb20gPSB7fTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gZGlmcykge1xuXHRcdFx0XHRcdFx0ZnJvbVtwXSA9IGJbaV1bcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdHMucHVzaChUd2VlbkxpdGUuZnJvbVRvKHRhcmdldHNbaV0sIGR1cmF0aW9uLCBmcm9tLCBkaWZzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0XHRUd2VlblBsdWdpbi5hY3RpdmF0ZShbQ1NTUGx1Z2luXSk7XG5cdFx0cmV0dXJuIENTU1BsdWdpbjtcblxuXHR9LCB0cnVlKTtcblxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBSb3VuZFByb3BzUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0KGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIFJvdW5kUHJvcHNQbHVnaW4gPSBfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRcdFx0cHJvcE5hbWU6IFwicm91bmRQcm9wc1wiLFxuXHRcdFx0XHR2ZXJzaW9uOiBcIjEuNVwiLFxuXHRcdFx0XHRwcmlvcml0eTogLTEsXG5cdFx0XHRcdEFQSTogMixcblxuXHRcdFx0XHQvL2NhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdFx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX3R3ZWVuID0gdHdlZW47XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSksXG5cdFx0XHRfcm91bmRMaW5rZWRMaXN0ID0gZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0XHR3aGlsZSAobm9kZSkge1xuXHRcdFx0XHRcdGlmICghbm9kZS5mICYmICFub2RlLmJsb2IpIHtcblx0XHRcdFx0XHRcdG5vZGUuciA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGUgPSBub2RlLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cCA9IFJvdW5kUHJvcHNQbHVnaW4ucHJvdG90eXBlO1xuXG5cdFx0cC5fb25Jbml0QWxsUHJvcHMgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX3R3ZWVuLFxuXHRcdFx0XHRycCA9ICh0d2Vlbi52YXJzLnJvdW5kUHJvcHMuam9pbikgPyB0d2Vlbi52YXJzLnJvdW5kUHJvcHMgOiB0d2Vlbi52YXJzLnJvdW5kUHJvcHMuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRpID0gcnAubGVuZ3RoLFxuXHRcdFx0XHRsb29rdXAgPSB7fSxcblx0XHRcdFx0cnB0ID0gdHdlZW4uX3Byb3BMb29rdXAucm91bmRQcm9wcyxcblx0XHRcdFx0cHJvcCwgcHQsIG5leHQ7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0bG9va3VwW3JwW2ldXSA9IDE7XG5cdFx0XHR9XG5cdFx0XHRpID0gcnAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHByb3AgPSBycFtpXTtcblx0XHRcdFx0cHQgPSB0d2Vlbi5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0bmV4dCA9IHB0Ll9uZXh0OyAvL3JlY29yZCBoZXJlLCBiZWNhdXNlIGl0IG1heSBnZXQgcmVtb3ZlZFxuXHRcdFx0XHRcdGlmIChwdC5wZykge1xuXHRcdFx0XHRcdFx0cHQudC5fcm91bmRQcm9wcyhsb29rdXAsIHRydWUpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQubiA9PT0gcHJvcCkge1xuXHRcdFx0XHRcdFx0aWYgKHB0LmYgPT09IDIgJiYgcHQudCkgeyAvL2EgYmxvYiAodGV4dCBjb250YWluaW5nIG11bHRpcGxlIG51bWVyaWMgdmFsdWVzKVxuXHRcdFx0XHRcdFx0XHRfcm91bmRMaW5rZWRMaXN0KHB0LnQuX2ZpcnN0UFQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWRkKHB0LnQsIHByb3AsIHB0LnMsIHB0LmMpO1xuXHRcdFx0XHRcdFx0XHQvL3JlbW92ZSBmcm9tIGxpbmtlZCBsaXN0XG5cdFx0XHRcdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHRcdFx0XHR0d2Vlbi5fZmlyc3RQVCA9IG5leHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHQuX25leHQgPSBwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLl9wcm9wTG9va3VwW3Byb3BdID0gcnB0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5fYWRkID0gZnVuY3Rpb24odGFyZ2V0LCBwLCBzLCBjKSB7XG5cdFx0XHR0aGlzLl9hZGRUd2Vlbih0YXJnZXQsIHAsIHMsIHMgKyBjLCBwLCB0cnVlKTtcblx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0fTtcblxuXHR9KCkpO1xuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQXR0clBsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblx0KGZ1bmN0aW9uKCkge1xuXG5cdFx0X2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0XHRwcm9wTmFtZTogXCJhdHRyXCIsXG5cdFx0XHRBUEk6IDIsXG5cdFx0XHR2ZXJzaW9uOiBcIjAuNS4wXCIsXG5cblx0XHRcdC8vY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdFx0XHR2YXIgcDtcblx0XHRcdFx0aWYgKHR5cGVvZih0YXJnZXQuc2V0QXR0cmlidXRlKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocCBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdHRoaXMuX2FkZFR3ZWVuKHRhcmdldCwgXCJzZXRBdHRyaWJ1dGVcIiwgdGFyZ2V0LmdldEF0dHJpYnV0ZShwKSArIFwiXCIsIHZhbHVlW3BdICsgXCJcIiwgcCwgZmFsc2UsIHApO1xuXHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHR9KTtcblxuXHR9KCkpO1xuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGlyZWN0aW9uYWxSb3RhdGlvblBsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdHByb3BOYW1lOiBcImRpcmVjdGlvbmFsUm90YXRpb25cIixcblx0XHR2ZXJzaW9uOiBcIjAuMi4xXCIsXG5cdFx0QVBJOiAyLFxuXG5cdFx0Ly9jYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgaXMgd2hlcmUgaW5pdGlhbCB2YWx1ZXMgc2hvdWxkIGJlIHJlY29yZGVkIGFuZCBhbnkgc2V0dXAgcm91dGluZXMgc2hvdWxkIHJ1bi5cblx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdFx0aWYgKHR5cGVvZih2YWx1ZSkgIT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0dmFsdWUgPSB7cm90YXRpb246dmFsdWV9O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5maW5hbHMgPSB7fTtcblx0XHRcdHZhciBjYXAgPSAodmFsdWUudXNlUmFkaWFucyA9PT0gdHJ1ZSkgPyBNYXRoLlBJICogMiA6IDM2MCxcblx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdHAsIHYsIHN0YXJ0LCBlbmQsIGRpZiwgc3BsaXQ7XG5cdFx0XHRmb3IgKHAgaW4gdmFsdWUpIHtcblx0XHRcdFx0aWYgKHAgIT09IFwidXNlUmFkaWFuc1wiKSB7XG5cdFx0XHRcdFx0c3BsaXQgPSAodmFsdWVbcF0gKyBcIlwiKS5zcGxpdChcIl9cIik7XG5cdFx0XHRcdFx0diA9IHNwbGl0WzBdO1xuXHRcdFx0XHRcdHN0YXJ0ID0gcGFyc2VGbG9hdCggKHR5cGVvZih0YXJnZXRbcF0pICE9PSBcImZ1bmN0aW9uXCIpID8gdGFyZ2V0W3BdIDogdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSgpICk7XG5cdFx0XHRcdFx0ZW5kID0gdGhpcy5maW5hbHNbcF0gPSAodHlwZW9mKHYpID09PSBcInN0cmluZ1wiICYmIHYuY2hhckF0KDEpID09PSBcIj1cIikgPyBzdGFydCArIHBhcnNlSW50KHYuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIE51bWJlcih2LnN1YnN0cigyKSkgOiBOdW1iZXIodikgfHwgMDtcblx0XHRcdFx0XHRkaWYgPSBlbmQgLSBzdGFydDtcblx0XHRcdFx0XHRpZiAoc3BsaXQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR2ID0gc3BsaXQuam9pbihcIl9cIik7XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwic2hvcnRcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IGRpZiAlIGNhcDtcblx0XHRcdFx0XHRcdFx0aWYgKGRpZiAhPT0gZGlmICUgKGNhcCAvIDIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlmID0gKGRpZiA8IDApID8gZGlmICsgY2FwIDogZGlmIC0gY2FwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwiX2N3XCIpICE9PSAtMSAmJiBkaWYgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmICsgY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuaW5kZXhPZihcImNjd1wiKSAhPT0gLTEgJiYgZGlmID4gMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiAtIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGlmID4gbWluIHx8IGRpZiA8IC1taW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZFR3ZWVuKHRhcmdldCwgcCwgc3RhcnQsIHN0YXJ0ICsgZGlmLCBwKTtcblx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly9jYWxsZWQgZWFjaCB0aW1lIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQsIGFuZCB0aGUgcmF0aW8gZ2V0cyBwYXNzZWQgYXMgdGhlIG9ubHkgcGFyYW1ldGVyICh0eXBpY2FsbHkgaXQncyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgYnV0IGl0IGNhbiBleGNlZWQgdGhvc2Ugd2hlbiB1c2luZyBhbiBlYXNlIGxpa2UgRWxhc3RpYy5lYXNlT3V0IG9yIEJhY2suZWFzZU91dCwgZXRjLilcblx0XHRzZXQ6IGZ1bmN0aW9uKHJhdGlvKSB7XG5cdFx0XHR2YXIgcHQ7XG5cdFx0XHRpZiAocmF0aW8gIT09IDEpIHtcblx0XHRcdFx0dGhpcy5fc3VwZXIuc2V0UmF0aW8uY2FsbCh0aGlzLCByYXRpbyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdKHRoaXMuZmluYWxzW3B0LnBdKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHRoaXMuZmluYWxzW3B0LnBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0pLl9hdXRvQ1NTID0gdHJ1ZTtcblxuXG5cblxuXG5cblxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBFYXNlUGFja1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcImVhc2luZy5CYWNrXCIsIFtcImVhc2luZy5FYXNlXCJdLCBmdW5jdGlvbihFYXNlKSB7XG5cdFx0XG5cdFx0dmFyIHcgPSAoX2dzU2NvcGUuR3JlZW5Tb2NrR2xvYmFscyB8fCBfZ3NTY29wZSksXG5cdFx0XHRncyA9IHcuY29tLmdyZWVuc29jayxcblx0XHRcdF8yUEkgPSBNYXRoLlBJICogMixcblx0XHRcdF9IQUxGX1BJID0gTWF0aC5QSSAvIDIsXG5cdFx0XHRfY2xhc3MgPSBncy5fY2xhc3MsXG5cdFx0XHRfY3JlYXRlID0gZnVuY3Rpb24obiwgZikge1xuXHRcdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIiArIG4sIGZ1bmN0aW9uKCl7fSwgdHJ1ZSksXG5cdFx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdFx0cC5jb25zdHJ1Y3RvciA9IEM7XG5cdFx0XHRcdHAuZ2V0UmF0aW8gPSBmO1xuXHRcdFx0XHRyZXR1cm4gQztcblx0XHRcdH0sXG5cdFx0XHRfZWFzZVJlZyA9IEVhc2UucmVnaXN0ZXIgfHwgZnVuY3Rpb24oKXt9LCAvL3B1dCBhbiBlbXB0eSBmdW5jdGlvbiBpbiBwbGFjZSBqdXN0IGFzIGEgc2FmZXR5IG1lYXN1cmUgaW4gY2FzZSBzb21lb25lIGxvYWRzIGFuIE9MRCB2ZXJzaW9uIG9mIFR3ZWVuTGl0ZS5qcyB3aGVyZSBFYXNlLnJlZ2lzdGVyIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRfd3JhcCA9IGZ1bmN0aW9uKG5hbWUsIEVhc2VPdXQsIEVhc2VJbiwgRWFzZUluT3V0LCBhbGlhc2VzKSB7XG5cdFx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiK25hbWUsIHtcblx0XHRcdFx0XHRlYXNlT3V0Om5ldyBFYXNlT3V0KCksXG5cdFx0XHRcdFx0ZWFzZUluOm5ldyBFYXNlSW4oKSxcblx0XHRcdFx0XHRlYXNlSW5PdXQ6bmV3IEVhc2VJbk91dCgpXG5cdFx0XHRcdH0sIHRydWUpO1xuXHRcdFx0XHRfZWFzZVJlZyhDLCBuYW1lKTtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXHRcdFx0RWFzZVBvaW50ID0gZnVuY3Rpb24odGltZSwgdmFsdWUsIG5leHQpIHtcblx0XHRcdFx0dGhpcy50ID0gdGltZTtcblx0XHRcdFx0dGhpcy52ID0gdmFsdWU7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0dGhpcy5uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRuZXh0LnByZXYgPSB0aGlzO1xuXHRcdFx0XHRcdHRoaXMuYyA9IG5leHQudiAtIHZhbHVlO1xuXHRcdFx0XHRcdHRoaXMuZ2FwID0gbmV4dC50IC0gdGltZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly9CYWNrXG5cdFx0XHRfY3JlYXRlQmFjayA9IGZ1bmN0aW9uKG4sIGYpIHtcblx0XHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbihvdmVyc2hvb3QpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3AxID0gKG92ZXJzaG9vdCB8fCBvdmVyc2hvb3QgPT09IDApID8gb3ZlcnNob290IDogMS43MDE1ODtcblx0XHRcdFx0XHRcdHRoaXMuX3AyID0gdGhpcy5fcDEgKiAxLjUyNTtcblx0XHRcdFx0XHR9LCB0cnVlKSxcblx0XHRcdFx0XHRwID0gQy5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdFx0XHRwLmNvbnN0cnVjdG9yID0gQztcblx0XHRcdFx0cC5nZXRSYXRpbyA9IGY7XG5cdFx0XHRcdHAuY29uZmlnID0gZnVuY3Rpb24ob3ZlcnNob290KSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBDKG92ZXJzaG9vdCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBDO1xuXHRcdFx0fSxcblxuXHRcdFx0QmFjayA9IF93cmFwKFwiQmFja1wiLFxuXHRcdFx0XHRfY3JlYXRlQmFjayhcIkJhY2tPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRcdHJldHVybiAoKHAgPSBwIC0gMSkgKiBwICogKCh0aGlzLl9wMSArIDEpICogcCArIHRoaXMuX3AxKSArIDEpO1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0X2NyZWF0ZUJhY2soXCJCYWNrSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRcdHJldHVybiBwICogcCAqICgodGhpcy5fcDEgKyAxKSAqIHAgLSB0aGlzLl9wMSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRfY3JlYXRlQmFjayhcIkJhY2tJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgocCAqPSAyKSA8IDEpID8gMC41ICogcCAqIHAgKiAoKHRoaXMuX3AyICsgMSkgKiBwIC0gdGhpcy5fcDIpIDogMC41ICogKChwIC09IDIpICogcCAqICgodGhpcy5fcDIgKyAxKSAqIHAgKyB0aGlzLl9wMikgKyAyKTtcblx0XHRcdFx0fSlcblx0XHRcdCksXG5cblxuXHRcdFx0Ly9TbG93TW9cblx0XHRcdFNsb3dNbyA9IF9jbGFzcyhcImVhc2luZy5TbG93TW9cIiwgZnVuY3Rpb24obGluZWFyUmF0aW8sIHBvd2VyLCB5b3lvTW9kZSkge1xuXHRcdFx0XHRwb3dlciA9IChwb3dlciB8fCBwb3dlciA9PT0gMCkgPyBwb3dlciA6IDAuNztcblx0XHRcdFx0aWYgKGxpbmVhclJhdGlvID09IG51bGwpIHtcblx0XHRcdFx0XHRsaW5lYXJSYXRpbyA9IDAuNztcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lYXJSYXRpbyA+IDEpIHtcblx0XHRcdFx0XHRsaW5lYXJSYXRpbyA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcCA9IChsaW5lYXJSYXRpbyAhPT0gMSkgPyBwb3dlciA6IDA7XG5cdFx0XHRcdHRoaXMuX3AxID0gKDEgLSBsaW5lYXJSYXRpbykgLyAyO1xuXHRcdFx0XHR0aGlzLl9wMiA9IGxpbmVhclJhdGlvO1xuXHRcdFx0XHR0aGlzLl9wMyA9IHRoaXMuX3AxICsgdGhpcy5fcDI7XG5cdFx0XHRcdHRoaXMuX2NhbGNFbmQgPSAoeW95b01vZGUgPT09IHRydWUpO1xuXHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRwID0gU2xvd01vLnByb3RvdHlwZSA9IG5ldyBFYXNlKCksXG5cdFx0XHRTdGVwcGVkRWFzZSwgUm91Z2hFYXNlLCBfY3JlYXRlRWxhc3RpYztcblxuXHRcdHAuY29uc3RydWN0b3IgPSBTbG93TW87XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdHZhciByID0gcCArICgwLjUgLSBwKSAqIHRoaXMuX3A7XG5cdFx0XHRpZiAocCA8IHRoaXMuX3AxKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gMSAtICgocCA9IDEgLSAocCAvIHRoaXMuX3AxKSkgKiBwKSA6IHIgLSAoKHAgPSAxIC0gKHAgLyB0aGlzLl9wMSkpICogcCAqIHAgKiBwICogcik7XG5cdFx0XHR9IGVsc2UgaWYgKHAgPiB0aGlzLl9wMykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FsY0VuZCA/IDEgLSAocCA9IChwIC0gdGhpcy5fcDMpIC8gdGhpcy5fcDEpICogcCA6IHIgKyAoKHAgLSByKSAqIChwID0gKHAgLSB0aGlzLl9wMykgLyB0aGlzLl9wMSkgKiBwICogcCAqIHApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGNFbmQgPyAxIDogcjtcblx0XHR9O1xuXHRcdFNsb3dNby5lYXNlID0gbmV3IFNsb3dNbygwLjcsIDAuNyk7XG5cblx0XHRwLmNvbmZpZyA9IFNsb3dNby5jb25maWcgPSBmdW5jdGlvbihsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNsb3dNbyhsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKTtcblx0XHR9O1xuXG5cblx0XHQvL1N0ZXBwZWRFYXNlXG5cdFx0U3RlcHBlZEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuU3RlcHBlZEVhc2VcIiwgZnVuY3Rpb24oc3RlcHMpIHtcblx0XHRcdFx0c3RlcHMgPSBzdGVwcyB8fCAxO1xuXHRcdFx0XHR0aGlzLl9wMSA9IDEgLyBzdGVwcztcblx0XHRcdFx0dGhpcy5fcDIgPSBzdGVwcyArIDE7XG5cdFx0XHR9LCB0cnVlKTtcblx0XHRwID0gU3RlcHBlZEVhc2UucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gU3RlcHBlZEVhc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdGlmIChwIDwgMCkge1xuXHRcdFx0XHRwID0gMDtcblx0XHRcdH0gZWxzZSBpZiAocCA+PSAxKSB7XG5cdFx0XHRcdHAgPSAwLjk5OTk5OTk5OTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoKHRoaXMuX3AyICogcCkgPj4gMCkgKiB0aGlzLl9wMTtcblx0XHR9O1xuXHRcdHAuY29uZmlnID0gU3RlcHBlZEVhc2UuY29uZmlnID0gZnVuY3Rpb24oc3RlcHMpIHtcblx0XHRcdHJldHVybiBuZXcgU3RlcHBlZEVhc2Uoc3RlcHMpO1xuXHRcdH07XG5cblxuXHRcdC8vUm91Z2hFYXNlXG5cdFx0Um91Z2hFYXNlID0gX2NsYXNzKFwiZWFzaW5nLlJvdWdoRWFzZVwiLCBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdHZhciB0YXBlciA9IHZhcnMudGFwZXIgfHwgXCJub25lXCIsXG5cdFx0XHRcdGEgPSBbXSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0cG9pbnRzID0gKHZhcnMucG9pbnRzIHx8IDIwKSB8IDAsXG5cdFx0XHRcdGkgPSBwb2ludHMsXG5cdFx0XHRcdHJhbmRvbWl6ZSA9ICh2YXJzLnJhbmRvbWl6ZSAhPT0gZmFsc2UpLFxuXHRcdFx0XHRjbGFtcCA9ICh2YXJzLmNsYW1wID09PSB0cnVlKSxcblx0XHRcdFx0dGVtcGxhdGUgPSAodmFycy50ZW1wbGF0ZSBpbnN0YW5jZW9mIEVhc2UpID8gdmFycy50ZW1wbGF0ZSA6IG51bGwsXG5cdFx0XHRcdHN0cmVuZ3RoID0gKHR5cGVvZih2YXJzLnN0cmVuZ3RoKSA9PT0gXCJudW1iZXJcIikgPyB2YXJzLnN0cmVuZ3RoICogMC40IDogMC40LFxuXHRcdFx0XHR4LCB5LCBidW1wLCBpbnZYLCBvYmosIHBudDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHR4ID0gcmFuZG9taXplID8gTWF0aC5yYW5kb20oKSA6ICgxIC8gcG9pbnRzKSAqIGk7XG5cdFx0XHRcdHkgPSB0ZW1wbGF0ZSA/IHRlbXBsYXRlLmdldFJhdGlvKHgpIDogeDtcblx0XHRcdFx0aWYgKHRhcGVyID09PSBcIm5vbmVcIikge1xuXHRcdFx0XHRcdGJ1bXAgPSBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmICh0YXBlciA9PT0gXCJvdXRcIikge1xuXHRcdFx0XHRcdGludlggPSAxIC0geDtcblx0XHRcdFx0XHRidW1wID0gaW52WCAqIGludlggKiBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmICh0YXBlciA9PT0gXCJpblwiKSB7XG5cdFx0XHRcdFx0YnVtcCA9IHggKiB4ICogc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAoeCA8IDAuNSkgeyAgLy9cImJvdGhcIiAoc3RhcnQpXG5cdFx0XHRcdFx0aW52WCA9IHggKiAyO1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2Uge1x0XHRcdFx0Ly9cImJvdGhcIiAoZW5kKVxuXHRcdFx0XHRcdGludlggPSAoMSAtIHgpICogMjtcblx0XHRcdFx0XHRidW1wID0gaW52WCAqIGludlggKiAwLjUgKiBzdHJlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmFuZG9taXplKSB7XG5cdFx0XHRcdFx0eSArPSAoTWF0aC5yYW5kb20oKSAqIGJ1bXApIC0gKGJ1bXAgKiAwLjUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGkgJSAyKSB7XG5cdFx0XHRcdFx0eSArPSBidW1wICogMC41O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHkgLT0gYnVtcCAqIDAuNTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2xhbXApIHtcblx0XHRcdFx0XHRpZiAoeSA+IDEpIHtcblx0XHRcdFx0XHRcdHkgPSAxO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoeSA8IDApIHtcblx0XHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhW2NudCsrXSA9IHt4OngsIHk6eX07XG5cdFx0XHR9XG5cdFx0XHRhLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYS54IC0gYi54O1xuXHRcdFx0fSk7XG5cblx0XHRcdHBudCA9IG5ldyBFYXNlUG9pbnQoMSwgMSwgbnVsbCk7XG5cdFx0XHRpID0gcG9pbnRzO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdG9iaiA9IGFbaV07XG5cdFx0XHRcdHBudCA9IG5ldyBFYXNlUG9pbnQob2JqLngsIG9iai55LCBwbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9wcmV2ID0gbmV3IEVhc2VQb2ludCgwLCAwLCAocG50LnQgIT09IDApID8gcG50IDogcG50Lm5leHQpO1xuXHRcdH0sIHRydWUpO1xuXHRcdHAgPSBSb3VnaEVhc2UucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gUm91Z2hFYXNlO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHR2YXIgcG50ID0gdGhpcy5fcHJldjtcblx0XHRcdGlmIChwID4gcG50LnQpIHtcblx0XHRcdFx0d2hpbGUgKHBudC5uZXh0ICYmIHAgPj0gcG50LnQpIHtcblx0XHRcdFx0XHRwbnQgPSBwbnQubmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwbnQgPSBwbnQucHJldjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlIChwbnQucHJldiAmJiBwIDw9IHBudC50KSB7XG5cdFx0XHRcdFx0cG50ID0gcG50LnByZXY7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX3ByZXYgPSBwbnQ7XG5cdFx0XHRyZXR1cm4gKHBudC52ICsgKChwIC0gcG50LnQpIC8gcG50LmdhcCkgKiBwbnQuYyk7XG5cdFx0fTtcblx0XHRwLmNvbmZpZyA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgUm91Z2hFYXNlKHZhcnMpO1xuXHRcdH07XG5cdFx0Um91Z2hFYXNlLmVhc2UgPSBuZXcgUm91Z2hFYXNlKCk7XG5cblxuXHRcdC8vQm91bmNlXG5cdFx0X3dyYXAoXCJCb3VuY2VcIixcblx0XHRcdF9jcmVhdGUoXCJCb3VuY2VPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAocCA8IDEgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIHAgKiBwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAocCAtPSAxLjUgLyAyLjc1KSAqIHAgKyAwLjc1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyLjUgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChwIC09IDIuMjUgLyAyLjc1KSAqIHAgKyAwLjkzNzU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChwIC09IDIuNjI1IC8gMi43NSkgKiBwICsgMC45ODQzNzU7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJCb3VuY2VJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmICgocCA9IDEgLSBwKSA8IDEgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogcCAqIHApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIChwIC09IDEuNSAvIDIuNzUpICogcCArIDAuNzUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyLjUgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogKHAgLT0gMi4yNSAvIDIuNzUpICogcCArIDAuOTM3NSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogKHAgLT0gMi42MjUgLyAyLjc1KSAqIHAgKyAwLjk4NDM3NSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJCb3VuY2VJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHZhciBpbnZlcnQgPSAocCA8IDAuNSk7XG5cdFx0XHRcdGlmIChpbnZlcnQpIHtcblx0XHRcdFx0XHRwID0gMSAtIChwICogMik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cCA9IChwICogMikgLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogcCAqIHA7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIChwIC09IDEuNSAvIDIuNzUpICogcCArIDAuNzU7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogKHAgLT0gMi4yNSAvIDIuNzUpICogcCArIDAuOTM3NTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogKHAgLT0gMi42MjUgLyAyLjc1KSAqIHAgKyAwLjk4NDM3NTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gaW52ZXJ0ID8gKDEgLSBwKSAqIDAuNSA6IHAgKiAwLjUgKyAwLjU7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblxuXHRcdC8vQ0lSQ1xuXHRcdF93cmFwKFwiQ2lyY1wiLFxuXHRcdFx0X2NyZWF0ZShcIkNpcmNPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAocCA9IHAgLSAxKSAqIHApO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQ2lyY0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSAocCAqIHApKSAtIDEpO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQ2lyY0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuICgocCo9MikgPCAxKSA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBwICogcCkgLSAxKSA6IDAuNSAqIChNYXRoLnNxcnQoMSAtIChwIC09IDIpICogcCkgKyAxKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXG5cdFx0Ly9FbGFzdGljXG5cdFx0X2NyZWF0ZUVsYXN0aWMgPSBmdW5jdGlvbihuLCBmLCBkZWYpIHtcblx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiICsgbiwgZnVuY3Rpb24oYW1wbGl0dWRlLCBwZXJpb2QpIHtcblx0XHRcdFx0XHR0aGlzLl9wMSA9IChhbXBsaXR1ZGUgPj0gMSkgPyBhbXBsaXR1ZGUgOiAxOyAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuXHRcdFx0XHRcdHRoaXMuX3AyID0gKHBlcmlvZCB8fCBkZWYpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKTtcblx0XHRcdFx0XHR0aGlzLl9wMyA9IHRoaXMuX3AyIC8gXzJQSSAqIChNYXRoLmFzaW4oMSAvIHRoaXMuX3AxKSB8fCAwKTtcblx0XHRcdFx0XHR0aGlzLl9wMiA9IF8yUEkgLyB0aGlzLl9wMjsgLy9wcmVjYWxjdWxhdGUgdG8gb3B0aW1pemVcblx0XHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRwLmNvbnN0cnVjdG9yID0gQztcblx0XHRcdHAuZ2V0UmF0aW8gPSBmO1xuXHRcdFx0cC5jb25maWcgPSBmdW5jdGlvbihhbXBsaXR1ZGUsIHBlcmlvZCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEMoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBDO1xuXHRcdH07XG5cdFx0X3dyYXAoXCJFbGFzdGljXCIsXG5cdFx0XHRfY3JlYXRlRWxhc3RpYyhcIkVsYXN0aWNPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcDEgKiBNYXRoLnBvdygyLCAtMTAgKiBwKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyICkgKyAxO1xuXHRcdFx0fSwgMC4zKSxcblx0XHRcdF9jcmVhdGVFbGFzdGljKFwiRWxhc3RpY0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC0odGhpcy5fcDEgKiBNYXRoLnBvdygyLCAxMCAqIChwIC09IDEpKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyICkpO1xuXHRcdFx0fSwgMC4zKSxcblx0XHRcdF9jcmVhdGVFbGFzdGljKFwiRWxhc3RpY0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuICgocCAqPSAyKSA8IDEpID8gLTAuNSAqICh0aGlzLl9wMSAqIE1hdGgucG93KDIsIDEwICogKHAgLT0gMSkpICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIpKSA6IHRoaXMuX3AxICogTWF0aC5wb3coMiwgLTEwICoocCAtPSAxKSkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMiApICogMC41ICsgMTtcblx0XHRcdH0sIDAuNDUpXG5cdFx0KTtcblxuXG5cdFx0Ly9FeHBvXG5cdFx0X3dyYXAoXCJFeHBvXCIsXG5cdFx0XHRfY3JlYXRlKFwiRXhwb091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAxIC0gTWF0aC5wb3coMiwgLTEwICogcCk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJFeHBvSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5wb3coMiwgMTAgKiAocCAtIDEpKSAtIDAuMDAxO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiRXhwb0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuICgocCAqPSAyKSA8IDEpID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAocCAtIDEpKSA6IDAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHAgLSAxKSkpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cblx0XHQvL1NpbmVcblx0XHRfd3JhcChcIlNpbmVcIixcblx0XHRcdF9jcmVhdGUoXCJTaW5lT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguc2luKHAgKiBfSEFMRl9QSSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJTaW5lSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLU1hdGguY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiU2luZUluT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHApIC0gMSk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblx0XHRfY2xhc3MoXCJlYXNpbmcuRWFzZUxvb2t1cFwiLCB7XG5cdFx0XHRcdGZpbmQ6ZnVuY3Rpb24ocykge1xuXHRcdFx0XHRcdHJldHVybiBFYXNlLm1hcFtzXTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdHJ1ZSk7XG5cblx0XHQvL3JlZ2lzdGVyIHRoZSBub24tc3RhbmRhcmQgZWFzZXNcblx0XHRfZWFzZVJlZyh3LlNsb3dNbywgXCJTbG93TW9cIiwgXCJlYXNlLFwiKTtcblx0XHRfZWFzZVJlZyhSb3VnaEVhc2UsIFwiUm91Z2hFYXNlXCIsIFwiZWFzZSxcIik7XG5cdFx0X2Vhc2VSZWcoU3RlcHBlZEVhc2UsIFwiU3RlcHBlZEVhc2VcIiwgXCJlYXNlLFwiKTtcblxuXHRcdHJldHVybiBCYWNrO1xuXHRcdFxuXHR9LCB0cnVlKTtcblxuXG59KTtcblxuaWYgKF9nc1Njb3BlLl9nc0RlZmluZSkgeyBfZ3NTY29wZS5fZ3NRdWV1ZS5wb3AoKSgpOyB9IC8vbmVjZXNzYXJ5IGluIGNhc2UgVHdlZW5MaXRlIHdhcyBhbHJlYWR5IGxvYWRlZCBzZXBhcmF0ZWx5LlxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCYXNlIGNsYXNzZXMgbGlrZSBUd2VlbkxpdGUsIFNpbXBsZVRpbWVsaW5lLCBFYXNlLCBUaWNrZXIsIGV0Yy5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgbW9kdWxlTmFtZSkge1xuXG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9nbG9iYWxzID0gd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyB8fCB3aW5kb3c7XG5cdFx0aWYgKF9nbG9iYWxzLlR3ZWVuTGl0ZSkge1xuXHRcdFx0cmV0dXJuOyAvL2luIGNhc2UgdGhlIGNvcmUgc2V0IG9mIGNsYXNzZXMgaXMgYWxyZWFkeSBsb2FkZWQsIGRvbid0IGluc3RhbnRpYXRlIHR3aWNlLlxuXHRcdH1cblx0XHR2YXIgX25hbWVzcGFjZSA9IGZ1bmN0aW9uKG5zKSB7XG5cdFx0XHRcdHZhciBhID0gbnMuc3BsaXQoXCIuXCIpLFxuXHRcdFx0XHRcdHAgPSBfZ2xvYmFscywgaTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwW2FbaV1dID0gcCA9IHBbYVtpXV0gfHwge307XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHR9LFxuXHRcdFx0Z3MgPSBfbmFtZXNwYWNlKFwiY29tLmdyZWVuc29ja1wiKSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0X3NsaWNlID0gZnVuY3Rpb24oYSkgeyAvL2Rvbid0IHVzZSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0YXJnZXQsIDApIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdHZhciBiID0gW10sXG5cdFx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgIT09IGw7IGIucHVzaChhW2krK10pKSB7fVxuXHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdH0sXG5cdFx0XHRfZW1wdHlGdW5jID0gZnVuY3Rpb24oKSB7fSxcblx0XHRcdF9pc0FycmF5ID0gKGZ1bmN0aW9uKCkgeyAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gaWZyYW1lIGVudmlyb25tZW50cyB3aGVyZSB0aGUgQXJyYXkgZ2xvYmFsIGlzbid0IHNoYXJlZCwgdGh1cyBpZiB0aGUgb2JqZWN0IG9yaWdpbmF0ZXMgaW4gYSBkaWZmZXJlbnQgd2luZG93L2lmcmFtZSwgXCIob2JqIGluc3RhbmNlb2YgQXJyYXkpXCIgd2lsbCBldmFsdWF0ZSBmYWxzZS4gV2UgYWRkZWQgc29tZSBzcGVlZCBvcHRpbWl6YXRpb25zIHRvIGF2b2lkIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgpIHVubGVzcyBpdCdzIGFic29sdXRlbHkgbmVjZXNzYXJ5IGJlY2F1c2UgaXQncyBWRVJZIHNsb3cgKGxpa2UgMjB4IHNsb3dlcilcblx0XHRcdFx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcblx0XHRcdFx0XHRhcnJheSA9IHRvU3RyaW5nLmNhbGwoW10pO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIChvYmogaW5zdGFuY2VvZiBBcnJheSB8fCAodHlwZW9mKG9iaikgPT09IFwib2JqZWN0XCIgJiYgISFvYmoucHVzaCAmJiB0b1N0cmluZy5jYWxsKG9iaikgPT09IGFycmF5KSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KCkpLFxuXHRcdFx0YSwgaSwgcCwgX3RpY2tlciwgX3RpY2tlckFjdGl2ZSxcblx0XHRcdF9kZWZMb29rdXAgPSB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHRcdCAqIERlZmluZXMgYSBHcmVlblNvY2sgY2xhc3MsIG9wdGlvbmFsbHkgd2l0aCBhbiBhcnJheSBvZiBkZXBlbmRlbmNpZXMgdGhhdCBtdXN0IGJlIGluc3RhbnRpYXRlZCBmaXJzdCBhbmQgcGFzc2VkIGludG8gdGhlIGRlZmluaXRpb24uXG5cdFx0XHQgKiBUaGlzIGFsbG93cyB1c2VycyB0byBsb2FkIEdyZWVuU29jayBKUyBmaWxlcyBpbiBhbnkgb3JkZXIgZXZlbiBpZiB0aGV5IGhhdmUgaW50ZXJkZXBlbmRlbmNpZXMgKGxpa2UgQ1NTUGx1Z2luIGV4dGVuZHMgVHdlZW5QbHVnaW4gd2hpY2ggaXNcblx0XHRcdCAqIGluc2lkZSBUd2VlbkxpdGUuanMsIGJ1dCBpZiBDU1NQbHVnaW4gaXMgbG9hZGVkIGZpcnN0LCBpdCBzaG91bGQgd2FpdCB0byBydW4gaXRzIGNvZGUgdW50aWwgVHdlZW5MaXRlLmpzIGxvYWRzIGFuZCBpbnN0YW50aWF0ZXMgVHdlZW5QbHVnaW5cblx0XHRcdCAqIGFuZCB0aGVuIHBhc3MgVHdlZW5QbHVnaW4gdG8gQ1NTUGx1Z2luJ3MgZGVmaW5pdGlvbikuIFRoaXMgaXMgYWxsIGRvbmUgYXV0b21hdGljYWxseSBhbmQgaW50ZXJuYWxseS5cblx0XHRcdCAqXG5cdFx0XHQgKiBFdmVyeSBkZWZpbml0aW9uIHdpbGwgYmUgYWRkZWQgdG8gYSBcImNvbS5ncmVlbnNvY2tcIiBnbG9iYWwgb2JqZWN0ICh0eXBpY2FsbHkgd2luZG93LCBidXQgaWYgYSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyBvYmplY3QgaXMgZm91bmQsXG5cdFx0XHQgKiBpdCB3aWxsIGdvIHRoZXJlIGFzIG9mIHYxLjcpLiBGb3IgZXhhbXBsZSwgVHdlZW5MaXRlIHdpbGwgYmUgZm91bmQgYXQgd2luZG93LmNvbS5ncmVlbnNvY2suVHdlZW5MaXRlIGFuZCBzaW5jZSBpdCdzIGEgZ2xvYmFsIGNsYXNzIHRoYXQgc2hvdWxkIGJlIGF2YWlsYWJsZSBhbnl3aGVyZSxcblx0XHRcdCAqIGl0IGlzIEFMU08gcmVmZXJlbmNlZCBhdCB3aW5kb3cuVHdlZW5MaXRlLiBIb3dldmVyIHNvbWUgY2xhc3NlcyBhcmVuJ3QgY29uc2lkZXJlZCBnbG9iYWwsIGxpa2UgdGhlIGJhc2UgY29tLmdyZWVuc29jay5jb3JlLkFuaW1hdGlvbiBjbGFzcywgc29cblx0XHRcdCAqIHRob3NlIHdpbGwgb25seSBiZSBhdCB0aGUgcGFja2FnZSBsaWtlIHdpbmRvdy5jb20uZ3JlZW5zb2NrLmNvcmUuQW5pbWF0aW9uLiBBZ2FpbiwgaWYgeW91IGRlZmluZSBhIEdyZWVuU29ja0dsb2JhbHMgb2JqZWN0IG9uIHRoZSB3aW5kb3csIGV2ZXJ5dGhpbmdcblx0XHRcdCAqIGdldHMgdHVja2VkIG5lYXRseSBpbnNpZGUgdGhlcmUgaW5zdGVhZCBvZiBvbiB0aGUgd2luZG93IGRpcmVjdGx5LiBUaGlzIGFsbG93cyB5b3UgdG8gZG8gYWR2YW5jZWQgdGhpbmdzIGxpa2UgbG9hZCBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBHcmVlblNvY2tcblx0XHRcdCAqIGZpbGVzIGFuZCBwdXQgdGhlbSBpbnRvIGRpc3RpbmN0IG9iamVjdHMgKGltYWdpbmUgYSBiYW5uZXIgYWQgdXNlcyBhIG5ld2VyIHZlcnNpb24gYnV0IHRoZSBtYWluIHNpdGUgdXNlcyBhbiBvbGRlciBvbmUpLiBJbiB0aGF0IGNhc2UsIHlvdSBjb3VsZFxuXHRcdFx0ICogc2FuZGJveCB0aGUgYmFubmVyIG9uZSBsaWtlOlxuXHRcdFx0ICpcblx0XHRcdCAqIDxzY3JpcHQ+XG5cdFx0XHQgKiAgICAgdmFyIGdzID0gd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB7fTsgLy90aGUgbmV3ZXIgdmVyc2lvbiB3ZSdyZSBhYm91dCB0byBsb2FkIGNvdWxkIG5vdyBiZSByZWZlcmVuY2VkIGluIGEgXCJnc1wiIG9iamVjdCwgbGlrZSBncy5Ud2VlbkxpdGUudG8oLi4uKS4gVXNlIHdoYXRldmVyIGFsaWFzIHlvdSB3YW50IGFzIGxvbmcgYXMgaXQncyB1bmlxdWUsIFwiZ3NcIiBvciBcImJhbm5lclwiIG9yIHdoYXRldmVyLlxuXHRcdFx0ICogPC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0IHNyYz1cImpzL2dyZWVuc29jay92MS43L1R3ZWVuTWF4LmpzXCI+PC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93Ll9nc1F1ZXVlID0gd2luZG93Ll9nc0RlZmluZSA9IG51bGw7IC8vcmVzZXQgaXQgYmFjayB0byBudWxsIChhbG9uZyB3aXRoIHRoZSBzcGVjaWFsIF9nc1F1ZXVlIHZhcmlhYmxlKSBzbyB0aGF0IHRoZSBuZXh0IGxvYWQgb2YgVHdlZW5NYXggYWZmZWN0cyB0aGUgd2luZG93IGFuZCB3ZSBjYW4gcmVmZXJlbmNlIHRoaW5ncyBkaXJlY3RseSBsaWtlIFR3ZWVuTGl0ZS50byguLi4pXG5cdFx0XHQgKiA8L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQgc3JjPVwianMvZ3JlZW5zb2NrL3YxLjYvVHdlZW5NYXguanNcIj48L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQ+XG5cdFx0XHQgKiAgICAgZ3MuVHdlZW5MaXRlLnRvKC4uLik7IC8vd291bGQgdXNlIHYxLjdcblx0XHRcdCAqICAgICBUd2VlbkxpdGUudG8oLi4uKTsgLy93b3VsZCB1c2UgdjEuNlxuXHRcdFx0ICogPC9zY3JpcHQ+XG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBucyBUaGUgbmFtZXNwYWNlIG9mIHRoZSBjbGFzcyBkZWZpbml0aW9uLCBsZWF2aW5nIG9mZiBcImNvbS5ncmVlbnNvY2suXCIgYXMgdGhhdCdzIGFzc3VtZWQuIEZvciBleGFtcGxlLCBcIlR3ZWVuTGl0ZVwiIG9yIFwicGx1Z2lucy5DU1NQbHVnaW5cIiBvciBcImVhc2luZy5CYWNrXCIuXG5cdFx0XHQgKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPn0gZGVwZW5kZW5jaWVzIEFuIGFycmF5IG9mIGRlcGVuZGVuY2llcyAoZGVzY3JpYmVkIGFzIHRoZWlyIG5hbWVzcGFjZXMgbWludXMgXCJjb20uZ3JlZW5zb2NrLlwiIHByZWZpeCkuIEZvciBleGFtcGxlIFtcIlR3ZWVuTGl0ZVwiLFwicGx1Z2lucy5Ud2VlblBsdWdpblwiLFwiY29yZS5BbmltYXRpb25cIl1cblx0XHRcdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6T2JqZWN0fSBmdW5jIFRoZSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgYW5kIHBhc3NlZCB0aGUgcmVzb2x2ZWQgZGVwZW5kZW5jaWVzIHdoaWNoIHdpbGwgcmV0dXJuIHRoZSBhY3R1YWwgY2xhc3MgZm9yIHRoaXMgZGVmaW5pdGlvbi5cblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGdsb2JhbCBJZiB0cnVlLCB0aGUgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgZ2xvYmFsIHNjb3BlICh0eXBpY2FsbHkgd2luZG93IHVubGVzcyB5b3UgZGVmaW5lIGEgd2luZG93LkdyZWVuU29ja0dsb2JhbHMgb2JqZWN0KVxuXHRcdFx0ICovXG5cdFx0XHREZWZpbml0aW9uID0gZnVuY3Rpb24obnMsIGRlcGVuZGVuY2llcywgZnVuYywgZ2xvYmFsKSB7XG5cdFx0XHRcdHRoaXMuc2MgPSAoX2RlZkxvb2t1cFtuc10pID8gX2RlZkxvb2t1cFtuc10uc2MgOiBbXTsgLy9zdWJjbGFzc2VzXG5cdFx0XHRcdF9kZWZMb29rdXBbbnNdID0gdGhpcztcblx0XHRcdFx0dGhpcy5nc0NsYXNzID0gbnVsbDtcblx0XHRcdFx0dGhpcy5mdW5jID0gZnVuYztcblx0XHRcdFx0dmFyIF9jbGFzc2VzID0gW107XG5cdFx0XHRcdHRoaXMuY2hlY2sgPSBmdW5jdGlvbihpbml0KSB7XG5cdFx0XHRcdFx0dmFyIGkgPSBkZXBlbmRlbmNpZXMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0bWlzc2luZyA9IGksXG5cdFx0XHRcdFx0XHRjdXIsIGEsIG4sIGNsLCBoYXNNb2R1bGU7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoKGN1ciA9IF9kZWZMb29rdXBbZGVwZW5kZW5jaWVzW2ldXSB8fCBuZXcgRGVmaW5pdGlvbihkZXBlbmRlbmNpZXNbaV0sIFtdKSkuZ3NDbGFzcykge1xuXHRcdFx0XHRcdFx0XHRfY2xhc3Nlc1tpXSA9IGN1ci5nc0NsYXNzO1xuXHRcdFx0XHRcdFx0XHRtaXNzaW5nLS07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGluaXQpIHtcblx0XHRcdFx0XHRcdFx0Y3VyLnNjLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtaXNzaW5nID09PSAwICYmIGZ1bmMpIHtcblx0XHRcdFx0XHRcdGEgPSAoXCJjb20uZ3JlZW5zb2NrLlwiICsgbnMpLnNwbGl0KFwiLlwiKTtcblx0XHRcdFx0XHRcdG4gPSBhLnBvcCgpO1xuXHRcdFx0XHRcdFx0Y2wgPSBfbmFtZXNwYWNlKGEuam9pbihcIi5cIikpW25dID0gdGhpcy5nc0NsYXNzID0gZnVuYy5hcHBseShmdW5jLCBfY2xhc3Nlcyk7XG5cblx0XHRcdFx0XHRcdC8vZXhwb3J0cyB0byBtdWx0aXBsZSBlbnZpcm9ubWVudHNcblx0XHRcdFx0XHRcdGlmIChnbG9iYWwpIHtcblx0XHRcdFx0XHRcdFx0X2dsb2JhbHNbbl0gPSBjbDsgLy9wcm92aWRlcyBhIHdheSB0byBhdm9pZCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvbi4gQnkgZGVmYXVsdCwgdGhlIG1haW4gY2xhc3NlcyBsaWtlIFR3ZWVuTGl0ZSwgUG93ZXIxLCBTdHJvbmcsIGV0Yy4gYXJlIGFkZGVkIHRvIHdpbmRvdyB1bmxlc3MgYSBHcmVlblNvY2tHbG9iYWxzIGlzIGRlZmluZWQuIFNvIGlmIHlvdSB3YW50IHRvIGhhdmUgdGhpbmdzIGFkZGVkIHRvIGEgY3VzdG9tIG9iamVjdCBpbnN0ZWFkLCBqdXN0IGRvIHNvbWV0aGluZyBsaWtlIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0ge30gYmVmb3JlIGxvYWRpbmcgYW55IEdyZWVuU29jayBmaWxlcy4gWW91IGNhbiBldmVuIHNldCB1cCBhbiBhbGlhcyBsaWtlIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93cy5ncyA9IHt9IHNvIHRoYXQgeW91IGNhbiBhY2Nlc3MgZXZlcnl0aGluZyBsaWtlIGdzLlR3ZWVuTGl0ZS4gQWxzbyByZW1lbWJlciB0aGF0IEFMTCBjbGFzc2VzIGFyZSBhZGRlZCB0byB0aGUgd2luZG93LmNvbS5ncmVlbnNvY2sgb2JqZWN0IChpbiB0aGVpciByZXNwZWN0aXZlIHBhY2thZ2VzLCBsaWtlIGNvbS5ncmVlbnNvY2suZWFzaW5nLlBvd2VyMSwgY29tLmdyZWVuc29jay5Ud2VlbkxpdGUsIGV0Yy4pXG5cdFx0XHRcdFx0XHRcdGhhc01vZHVsZSA9ICh0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyk7XG5cdFx0XHRcdFx0XHRcdGlmICghaGFzTW9kdWxlICYmIHR5cGVvZihkZWZpbmUpID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCl7IC8vQU1EXG5cdFx0XHRcdFx0XHRcdFx0ZGVmaW5lKCh3aW5kb3cuR3JlZW5Tb2NrQU1EUGF0aCA/IHdpbmRvdy5HcmVlblNvY2tBTURQYXRoICsgXCIvXCIgOiBcIlwiKSArIG5zLnNwbGl0KFwiLlwiKS5wb3AoKSwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2w7IH0pO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG5zID09PSBtb2R1bGVOYW1lICYmIGhhc01vZHVsZSl7IC8vbm9kZVxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZS5leHBvcnRzID0gY2w7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLnNjLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2NbaV0uY2hlY2soKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuY2hlY2sodHJ1ZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL3VzZWQgdG8gY3JlYXRlIERlZmluaXRpb24gaW5zdGFuY2VzICh3aGljaCBiYXNpY2FsbHkgcmVnaXN0ZXJzIGEgY2xhc3MgdGhhdCBoYXMgZGVwZW5kZW5jaWVzKS5cblx0XHRcdF9nc0RlZmluZSA9IHdpbmRvdy5fZ3NEZWZpbmUgPSBmdW5jdGlvbihucywgZGVwZW5kZW5jaWVzLCBmdW5jLCBnbG9iYWwpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBEZWZpbml0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2EgcXVpY2sgd2F5IHRvIGNyZWF0ZSBhIGNsYXNzIHRoYXQgZG9lc24ndCBoYXZlIGFueSBkZXBlbmRlbmNpZXMuIFJldHVybnMgdGhlIGNsYXNzLCBidXQgZmlyc3QgcmVnaXN0ZXJzIGl0IGluIHRoZSBHcmVlblNvY2sgbmFtZXNwYWNlIHNvIHRoYXQgb3RoZXIgY2xhc3NlcyBjYW4gZ3JhYiBpdCAob3RoZXIgY2xhc3NlcyBtaWdodCBiZSBkZXBlbmRlbnQgb24gdGhlIGNsYXNzKS5cblx0XHRcdF9jbGFzcyA9IGdzLl9jbGFzcyA9IGZ1bmN0aW9uKG5zLCBmdW5jLCBnbG9iYWwpIHtcblx0XHRcdFx0ZnVuYyA9IGZ1bmMgfHwgZnVuY3Rpb24oKSB7fTtcblx0XHRcdFx0X2dzRGVmaW5lKG5zLCBbXSwgZnVuY3Rpb24oKXsgcmV0dXJuIGZ1bmM7IH0sIGdsb2JhbCk7XG5cdFx0XHRcdHJldHVybiBmdW5jO1xuXHRcdFx0fTtcblxuXHRcdF9nc0RlZmluZS5nbG9iYWxzID0gX2dsb2JhbHM7XG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRWFzZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIF9iYXNlUGFyYW1zID0gWzAsIDAsIDEsIDFdLFxuXHRcdFx0X2JsYW5rQXJyYXkgPSBbXSxcblx0XHRcdEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuRWFzZVwiLCBmdW5jdGlvbihmdW5jLCBleHRyYVBhcmFtcywgdHlwZSwgcG93ZXIpIHtcblx0XHRcdFx0dGhpcy5fZnVuYyA9IGZ1bmM7XG5cdFx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3Bvd2VyID0gcG93ZXIgfHwgMDtcblx0XHRcdFx0dGhpcy5fcGFyYW1zID0gZXh0cmFQYXJhbXMgPyBfYmFzZVBhcmFtcy5jb25jYXQoZXh0cmFQYXJhbXMpIDogX2Jhc2VQYXJhbXM7XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdF9lYXNlTWFwID0gRWFzZS5tYXAgPSB7fSxcblx0XHRcdF9lYXNlUmVnID0gRWFzZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGVhc2UsIG5hbWVzLCB0eXBlcywgY3JlYXRlKSB7XG5cdFx0XHRcdHZhciBuYSA9IG5hbWVzLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRpID0gbmEubGVuZ3RoLFxuXHRcdFx0XHRcdHRhID0gKHR5cGVzIHx8IFwiZWFzZUluLGVhc2VPdXQsZWFzZUluT3V0XCIpLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRlLCBuYW1lLCBqLCB0eXBlO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRuYW1lID0gbmFbaV07XG5cdFx0XHRcdFx0ZSA9IGNyZWF0ZSA/IF9jbGFzcyhcImVhc2luZy5cIituYW1lLCBudWxsLCB0cnVlKSA6IGdzLmVhc2luZ1tuYW1lXSB8fCB7fTtcblx0XHRcdFx0XHRqID0gdGEubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdFx0XHRcdFx0dHlwZSA9IHRhW2pdO1xuXHRcdFx0XHRcdFx0X2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgdHlwZV0gPSBfZWFzZU1hcFt0eXBlICsgbmFtZV0gPSBlW3R5cGVdID0gZWFzZS5nZXRSYXRpbyA/IGVhc2UgOiBlYXNlW3R5cGVdIHx8IG5ldyBlYXNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0cCA9IEVhc2UucHJvdG90eXBlO1xuXHRcdHAuX2NhbGNFbmQgPSBmYWxzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYgKHRoaXMuX2Z1bmMpIHtcblx0XHRcdFx0dGhpcy5fcGFyYW1zWzBdID0gcDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2Z1bmMuYXBwbHkobnVsbCwgdGhpcy5fcGFyYW1zKTtcblx0XHRcdH1cblx0XHRcdHZhciB0ID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0cHcgPSB0aGlzLl9wb3dlcixcblx0XHRcdFx0ciA9ICh0ID09PSAxKSA/IDEgLSBwIDogKHQgPT09IDIpID8gcCA6IChwIDwgMC41KSA/IHAgKiAyIDogKDEgLSBwKSAqIDI7XG5cdFx0XHRpZiAocHcgPT09IDEpIHtcblx0XHRcdFx0ciAqPSByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gMikge1xuXHRcdFx0XHRyICo9IHIgKiByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gMykge1xuXHRcdFx0XHRyICo9IHIgKiByICogcjtcblx0XHRcdH0gZWxzZSBpZiAocHcgPT09IDQpIHtcblx0XHRcdFx0ciAqPSByICogciAqIHIgKiByO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgLSByIDogKHQgPT09IDIpID8gciA6IChwIDwgMC41KSA/IHIgLyAyIDogMSAtIChyIC8gMik7XG5cdFx0fTtcblxuXHRcdC8vY3JlYXRlIGFsbCB0aGUgc3RhbmRhcmQgZWFzZXMgbGlrZSBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBhbmQgUG93ZXI0IChlYWNoIHdpdGggZWFzZUluLCBlYXNlT3V0LCBhbmQgZWFzZUluT3V0KVxuXHRcdGEgPSBbXCJMaW5lYXJcIixcIlF1YWRcIixcIkN1YmljXCIsXCJRdWFydFwiLFwiUXVpbnQsU3Ryb25nXCJdO1xuXHRcdGkgPSBhLmxlbmd0aDtcblx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdHAgPSBhW2ldK1wiLFBvd2VyXCIraTtcblx0XHRcdF9lYXNlUmVnKG5ldyBFYXNlKG51bGwsbnVsbCwxLGkpLCBwLCBcImVhc2VPdXRcIiwgdHJ1ZSk7XG5cdFx0XHRfZWFzZVJlZyhuZXcgRWFzZShudWxsLG51bGwsMixpKSwgcCwgXCJlYXNlSW5cIiArICgoaSA9PT0gMCkgPyBcIixlYXNlTm9uZVwiIDogXCJcIikpO1xuXHRcdFx0X2Vhc2VSZWcobmV3IEVhc2UobnVsbCxudWxsLDMsaSksIHAsIFwiZWFzZUluT3V0XCIpO1xuXHRcdH1cblx0XHRfZWFzZU1hcC5saW5lYXIgPSBncy5lYXNpbmcuTGluZWFyLmVhc2VJbjtcblx0XHRfZWFzZU1hcC5zd2luZyA9IGdzLmVhc2luZy5RdWFkLmVhc2VJbk91dDsgLy9mb3IgalF1ZXJ5IGZvbGtzXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEV2ZW50RGlzcGF0Y2hlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIEV2ZW50RGlzcGF0Y2hlciA9IF9jbGFzcyhcImV2ZW50cy5FdmVudERpc3BhdGNoZXJcIiwgZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRcdHRoaXMuX2V2ZW50VGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXM7XG5cdFx0fSk7XG5cdFx0cCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XG5cblx0XHRwLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgc2NvcGUsIHVzZVBhcmFtLCBwcmlvcml0eSkge1xuXHRcdFx0cHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGlzdGVuZXIsIGk7XG5cdFx0XHRpZiAobGlzdCA9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IGxpc3QgPSBbXTtcblx0XHRcdH1cblx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRsaXN0ZW5lciA9IGxpc3RbaV07XG5cdFx0XHRcdGlmIChsaXN0ZW5lci5jID09PSBjYWxsYmFjayAmJiBsaXN0ZW5lci5zID09PSBzY29wZSkge1xuXHRcdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGluZGV4ID09PSAwICYmIGxpc3RlbmVyLnByIDwgcHJpb3JpdHkpIHtcblx0XHRcdFx0XHRpbmRleCA9IGkgKyAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsaXN0LnNwbGljZShpbmRleCwgMCwge2M6Y2FsbGJhY2ssIHM6c2NvcGUsIHVwOnVzZVBhcmFtLCBwcjpwcmlvcml0eX0pO1xuXHRcdFx0aWYgKHRoaXMgPT09IF90aWNrZXIgJiYgIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSwgaTtcblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGxpc3RbaV0uYyA9PT0gY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSxcblx0XHRcdFx0aSwgdCwgbGlzdGVuZXI7XG5cdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdHQgPSB0aGlzLl9ldmVudFRhcmdldDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXIgPSBsaXN0W2ldO1xuXHRcdFx0XHRcdGlmIChsaXN0ZW5lcikge1xuXHRcdFx0XHRcdFx0aWYgKGxpc3RlbmVyLnVwKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmMuY2FsbChsaXN0ZW5lci5zIHx8IHQsIHt0eXBlOnR5cGUsIHRhcmdldDp0fSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5jLmNhbGwobGlzdGVuZXIucyB8fCB0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUaWNrZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuIFx0XHR2YXIgX3JlcUFuaW1GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG5cdFx0XHRfY2FuY2VsQW5pbUZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lLFxuXHRcdFx0X2dldFRpbWUgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7fSxcblx0XHRcdF9sYXN0VXBkYXRlID0gX2dldFRpbWUoKTtcblxuXHRcdC8vbm93IHRyeSB0byBkZXRlcm1pbmUgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBhbmQgY2FuY2VsQW5pbWF0aW9uRnJhbWUgZnVuY3Rpb25zIGFuZCBpZiBub25lIGFyZSBmb3VuZCwgd2UnbGwgdXNlIGEgc2V0VGltZW91dCgpL2NsZWFyVGltZW91dCgpIHBvbHlmaWxsLlxuXHRcdGEgPSBbXCJtc1wiLFwibW96XCIsXCJ3ZWJraXRcIixcIm9cIl07XG5cdFx0aSA9IGEubGVuZ3RoO1xuXHRcdHdoaWxlICgtLWkgPiAtMSAmJiAhX3JlcUFuaW1GcmFtZSkge1xuXHRcdFx0X3JlcUFuaW1GcmFtZSA9IHdpbmRvd1thW2ldICsgXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG5cdFx0XHRfY2FuY2VsQW5pbUZyYW1lID0gd2luZG93W2FbaV0gKyBcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdIHx8IHdpbmRvd1thW2ldICsgXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG5cdFx0fVxuXG5cdFx0X2NsYXNzKFwiVGlja2VyXCIsIGZ1bmN0aW9uKGZwcywgdXNlUkFGKSB7XG5cdFx0XHR2YXIgX3NlbGYgPSB0aGlzLFxuXHRcdFx0XHRfc3RhcnRUaW1lID0gX2dldFRpbWUoKSxcblx0XHRcdFx0X3VzZVJBRiA9ICh1c2VSQUYgIT09IGZhbHNlICYmIF9yZXFBbmltRnJhbWUpID8gXCJhdXRvXCIgOiBmYWxzZSxcblx0XHRcdFx0X2xhZ1RocmVzaG9sZCA9IDUwMCxcblx0XHRcdFx0X2FkanVzdGVkTGFnID0gMzMsXG5cdFx0XHRcdF90aWNrV29yZCA9IFwidGlja1wiLCAvL2hlbHBzIHJlZHVjZSBnYyBidXJkZW5cblx0XHRcdFx0X2ZwcywgX3JlcSwgX2lkLCBfZ2FwLCBfbmV4dFRpbWUsXG5cdFx0XHRcdF90aWNrID0gZnVuY3Rpb24obWFudWFsKSB7XG5cdFx0XHRcdFx0dmFyIGVsYXBzZWQgPSBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUsXG5cdFx0XHRcdFx0XHRvdmVybGFwLCBkaXNwYXRjaDtcblx0XHRcdFx0XHRpZiAoZWxhcHNlZCA+IF9sYWdUaHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdF9zdGFydFRpbWUgKz0gZWxhcHNlZCAtIF9hZGp1c3RlZExhZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X2xhc3RVcGRhdGUgKz0gZWxhcHNlZDtcblx0XHRcdFx0XHRfc2VsZi50aW1lID0gKF9sYXN0VXBkYXRlIC0gX3N0YXJ0VGltZSkgLyAxMDAwO1xuXHRcdFx0XHRcdG92ZXJsYXAgPSBfc2VsZi50aW1lIC0gX25leHRUaW1lO1xuXHRcdFx0XHRcdGlmICghX2ZwcyB8fCBvdmVybGFwID4gMCB8fCBtYW51YWwgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdF9zZWxmLmZyYW1lKys7XG5cdFx0XHRcdFx0XHRfbmV4dFRpbWUgKz0gb3ZlcmxhcCArIChvdmVybGFwID49IF9nYXAgPyAwLjAwNCA6IF9nYXAgLSBvdmVybGFwKTtcblx0XHRcdFx0XHRcdGRpc3BhdGNoID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1hbnVhbCAhPT0gdHJ1ZSkgeyAvL21ha2Ugc3VyZSB0aGUgcmVxdWVzdCBpcyBtYWRlIGJlZm9yZSB3ZSBkaXNwYXRjaCB0aGUgXCJ0aWNrXCIgZXZlbnQgc28gdGhhdCB0aW1pbmcgaXMgbWFpbnRhaW5lZC4gT3RoZXJ3aXNlLCBpZiBwcm9jZXNzaW5nIHRoZSBcInRpY2tcIiByZXF1aXJlcyBhIGJ1bmNoIG9mIHRpbWUgKGxpa2UgMTVtcykgYW5kIHdlJ3JlIHVzaW5nIGEgc2V0VGltZW91dCgpIHRoYXQncyBiYXNlZCBvbiAxNi43bXMsIGl0J2QgdGVjaG5pY2FsbHkgdGFrZSAzMS43bXMgYmV0d2VlbiBmcmFtZXMgb3RoZXJ3aXNlLlxuXHRcdFx0XHRcdFx0X2lkID0gX3JlcShfdGljayk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChkaXNwYXRjaCkge1xuXHRcdFx0XHRcdFx0X3NlbGYuZGlzcGF0Y2hFdmVudChfdGlja1dvcmQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0RXZlbnREaXNwYXRjaGVyLmNhbGwoX3NlbGYpO1xuXHRcdFx0X3NlbGYudGltZSA9IF9zZWxmLmZyYW1lID0gMDtcblx0XHRcdF9zZWxmLnRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0X3RpY2sodHJ1ZSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi5sYWdTbW9vdGhpbmcgPSBmdW5jdGlvbih0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG5cdFx0XHRcdF9sYWdUaHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgKDEgLyBfdGlueU51bSk7IC8vemVybyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzaWNhbGx5IHVubGltaXRlZFxuXHRcdFx0XHRfYWRqdXN0ZWRMYWcgPSBNYXRoLm1pbihhZGp1c3RlZExhZywgX2xhZ1RocmVzaG9sZCwgMCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi5zbGVlcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX2lkID09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFfdXNlUkFGIHx8ICFfY2FuY2VsQW5pbUZyYW1lKSB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KF9pZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2NhbmNlbEFuaW1GcmFtZShfaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yZXEgPSBfZW1wdHlGdW5jO1xuXHRcdFx0XHRfaWQgPSBudWxsO1xuXHRcdFx0XHRpZiAoX3NlbGYgPT09IF90aWNrZXIpIHtcblx0XHRcdFx0XHRfdGlja2VyQWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLndha2UgPSBmdW5jdGlvbihzZWFtbGVzcykge1xuXHRcdFx0XHRpZiAoX2lkICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0X3NlbGYuc2xlZXAoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChzZWFtbGVzcykge1xuXHRcdFx0XHRcdF9zdGFydFRpbWUgKz0gLV9sYXN0VXBkYXRlICsgKF9sYXN0VXBkYXRlID0gX2dldFRpbWUoKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoX3NlbGYuZnJhbWUgPiAxMCkgeyAvL2Rvbid0IHRyaWdnZXIgbGFnU21vb3RoaW5nIGlmIHdlJ3JlIGp1c3Qgd2FraW5nIHVwLCBhbmQgbWFrZSBzdXJlIHRoYXQgYXQgbGVhc3QgMTAgZnJhbWVzIGhhdmUgZWxhcHNlZCBiZWNhdXNlIG9mIHRoZSBpT1MgYnVnIHRoYXQgd2Ugd29yayBhcm91bmQgYmVsb3cgd2l0aCB0aGUgMS41LXNlY29uZCBzZXRUaW1vdXQoKS5cblx0XHRcdFx0XHRfbGFzdFVwZGF0ZSA9IF9nZXRUaW1lKCkgLSBfbGFnVGhyZXNob2xkICsgNTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVxID0gKF9mcHMgPT09IDApID8gX2VtcHR5RnVuYyA6ICghX3VzZVJBRiB8fCAhX3JlcUFuaW1GcmFtZSkgPyBmdW5jdGlvbihmKSB7IHJldHVybiBzZXRUaW1lb3V0KGYsICgoX25leHRUaW1lIC0gX3NlbGYudGltZSkgKiAxMDAwICsgMSkgfCAwKTsgfSA6IF9yZXFBbmltRnJhbWU7XG5cdFx0XHRcdGlmIChfc2VsZiA9PT0gX3RpY2tlcikge1xuXHRcdFx0XHRcdF90aWNrZXJBY3RpdmUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF90aWNrKDIpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYuZnBzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9mcHM7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2ZwcyA9IHZhbHVlO1xuXHRcdFx0XHRfZ2FwID0gMSAvIChfZnBzIHx8IDYwKTtcblx0XHRcdFx0X25leHRUaW1lID0gdGhpcy50aW1lICsgX2dhcDtcblx0XHRcdFx0X3NlbGYud2FrZSgpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYudXNlUkFGID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF91c2VSQUY7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3NlbGYuc2xlZXAoKTtcblx0XHRcdFx0X3VzZVJBRiA9IHZhbHVlO1xuXHRcdFx0XHRfc2VsZi5mcHMoX2Zwcyk7XG5cdFx0XHR9O1xuXHRcdFx0X3NlbGYuZnBzKGZwcyk7XG5cblx0XHRcdC8vYSBidWcgaW4gaU9TIDYgU2FmYXJpIG9jY2FzaW9uYWxseSBwcmV2ZW50cyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZyb20gd29ya2luZyBpbml0aWFsbHksIHNvIHdlIHVzZSBhIDEuNS1zZWNvbmQgdGltZW91dCB0aGF0IGF1dG9tYXRpY2FsbHkgZmFsbHMgYmFjayB0byBzZXRUaW1lb3V0KCkgaWYgaXQgc2Vuc2VzIHRoaXMgY29uZGl0aW9uLlxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF91c2VSQUYgPT09IFwiYXV0b1wiICYmIF9zZWxmLmZyYW1lIDwgNSAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCIpIHtcblx0XHRcdFx0XHRfc2VsZi51c2VSQUYoZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAxNTAwKTtcblx0XHR9KTtcblxuXHRcdHAgPSBncy5UaWNrZXIucHJvdG90eXBlID0gbmV3IGdzLmV2ZW50cy5FdmVudERpc3BhdGNoZXIoKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gZ3MuVGlja2VyO1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBbmltYXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBBbmltYXRpb24gPSBfY2xhc3MoXCJjb3JlLkFuaW1hdGlvblwiLCBmdW5jdGlvbihkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0XHR0aGlzLnZhcnMgPSB2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gZHVyYXRpb24gfHwgMDtcblx0XHRcdFx0dGhpcy5fZGVsYXkgPSBOdW1iZXIodmFycy5kZWxheSkgfHwgMDtcblx0XHRcdFx0dGhpcy5fdGltZVNjYWxlID0gMTtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5kYXRhID0gdmFycy5kYXRhO1xuXHRcdFx0XHR0aGlzLl9yZXZlcnNlZCA9ICh2YXJzLnJldmVyc2VkID09PSB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIV9yb290VGltZWxpbmUpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7IC8vc29tZSBicm93c2VycyAobGlrZSBpT1MgNiBTYWZhcmkpIHNodXQgZG93biBKYXZhU2NyaXB0IGV4ZWN1dGlvbiB3aGVuIHRoZSB0YWIgaXMgZGlzYWJsZWQgYW5kIHRoZXkgW29jY2FzaW9uYWxseV0gbmVnbGVjdCB0byBzdGFydCB1cCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYWdhaW4gd2hlbiByZXR1cm5pbmcgLSB0aGlzIGNvZGUgZW5zdXJlcyB0aGF0IHRoZSBlbmdpbmUgc3RhcnRzIHVwIGFnYWluIHByb3Blcmx5LlxuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHRsID0gdGhpcy52YXJzLnVzZUZyYW1lcyA/IF9yb290RnJhbWVzVGltZWxpbmUgOiBfcm9vdFRpbWVsaW5lO1xuXHRcdFx0XHR0bC5hZGQodGhpcywgdGwuX3RpbWUpO1xuXG5cdFx0XHRcdGlmICh0aGlzLnZhcnMucGF1c2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0X3RpY2tlciA9IEFuaW1hdGlvbi50aWNrZXIgPSBuZXcgZ3MuVGlja2VyKCk7XG5cdFx0cCA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5cdFx0cC5fZGlydHkgPSBwLl9nYyA9IHAuX2luaXR0ZWQgPSBwLl9wYXVzZWQgPSBmYWxzZTtcblx0XHRwLl90b3RhbFRpbWUgPSBwLl90aW1lID0gMDtcblx0XHRwLl9yYXdQcmV2VGltZSA9IC0xO1xuXHRcdHAuX25leHQgPSBwLl9sYXN0ID0gcC5fb25VcGRhdGUgPSBwLl90aW1lbGluZSA9IHAudGltZWxpbmUgPSBudWxsO1xuXHRcdHAuX3BhdXNlZCA9IGZhbHNlO1xuXG5cblx0XHQvL3NvbWUgYnJvd3NlcnMgKGxpa2UgaU9TKSBvY2Nhc2lvbmFsbHkgZHJvcCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGV2ZW50IHdoZW4gdGhlIHVzZXIgc3dpdGNoZXMgdG8gYSBkaWZmZXJlbnQgdGFiIGFuZCB0aGVuIGNvbWVzIGJhY2sgYWdhaW4sIHNvIHdlIHVzZSBhIDItc2Vjb25kIHNldFRpbWVvdXQoKSB0byBzZW5zZSBpZi93aGVuIHRoYXQgY29uZGl0aW9uIG9jY3VycyBhbmQgdGhlbiB3YWtlKCkgdGhlIHRpY2tlci5cblx0XHR2YXIgX2NoZWNrVGltZW91dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX3RpY2tlckFjdGl2ZSAmJiBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUgPiAyMDAwKSB7XG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0VGltZW91dChfY2hlY2tUaW1lb3V0LCAyMDAwKTtcblx0XHRcdH07XG5cdFx0X2NoZWNrVGltZW91dCgpO1xuXG5cblx0XHRwLnBsYXkgPSBmdW5jdGlvbihmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucGF1c2UgPSBmdW5jdGlvbihhdFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoYXRUaW1lICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJlc3VtZSA9IGZ1bmN0aW9uKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnNlZWsgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKE51bWJlcih0aW1lKSwgc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXN0YXJ0ID0gZnVuY3Rpb24oaW5jbHVkZURlbGF5LCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSkudG90YWxUaW1lKGluY2x1ZGVEZWxheSA/IC10aGlzLl9kZWxheSA6IDAsIChzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpLCB0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXZlcnNlID0gZnVuY3Rpb24oZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKChmcm9tIHx8IHRoaXMudG90YWxEdXJhdGlvbigpKSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQodHJ1ZSkucGF1c2VkKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdC8vc3R1YiAtIHdlIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGluIHN1YmNsYXNzZXMuXG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IDA7XG5cdFx0XHR0aGlzLl9pbml0dGVkID0gdGhpcy5fZ2MgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gLTE7XG5cdFx0XHRpZiAodGhpcy5fZ2MgfHwgIXRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGwgPSB0aGlzLl90aW1lbGluZSwgLy90aGUgMiByb290IHRpbWVsaW5lcyB3b24ndCBoYXZlIGEgX3RpbWVsaW5lOyB0aGV5J3JlIGFsd2F5cyBhY3RpdmUuXG5cdFx0XHRcdHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cmF3VGltZTtcblx0XHRcdHJldHVybiAoIXRsIHx8ICghdGhpcy5fZ2MgJiYgIXRoaXMuX3BhdXNlZCAmJiB0bC5pc0FjdGl2ZSgpICYmIChyYXdUaW1lID0gdGwucmF3VGltZSgpKSA+PSBzdGFydFRpbWUgJiYgcmF3VGltZSA8IHN0YXJ0VGltZSArIHRoaXMudG90YWxEdXJhdGlvbigpIC8gdGhpcy5fdGltZVNjYWxlKSk7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2djID0gIWVuYWJsZWQ7XG5cdFx0XHR0aGlzLl9hY3RpdmUgPSB0aGlzLmlzQWN0aXZlKCk7XG5cdFx0XHRpZiAoaWdub3JlVGltZWxpbmUgIT09IHRydWUpIHtcblx0XHRcdFx0aWYgKGVuYWJsZWQgJiYgIXRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lbGluZS5hZGQodGhpcywgdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fZGVsYXkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFlbmFibGVkICYmIHRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lbGluZS5fcmVtb3ZlKHRoaXMsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9raWxsKHZhcnMsIHRhcmdldCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fdW5jYWNoZSA9IGZ1bmN0aW9uKGluY2x1ZGVTZWxmKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSBpbmNsdWRlU2VsZiA/IHRoaXMgOiB0aGlzLnRpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVuLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fc3dhcFNlbGZJblBhcmFtcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdFx0dmFyIGkgPSBwYXJhbXMubGVuZ3RoLFxuXHRcdFx0XHRjb3B5ID0gcGFyYW1zLmNvbmNhdCgpO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChwYXJhbXNbaV0gPT09IFwie3NlbGZ9XCIpIHtcblx0XHRcdFx0XHRjb3B5W2ldID0gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0fTtcblxuXHRcdHAuX2NhbGxiYWNrID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIHYgPSB0aGlzLnZhcnM7XG5cdFx0XHR2W3R5cGVdLmFwcGx5KHZbdHlwZSArIFwiU2NvcGVcIl0gfHwgdi5jYWxsYmFja1Njb3BlIHx8IHRoaXMsIHZbdHlwZSArIFwiUGFyYW1zXCJdIHx8IF9ibGFua0FycmF5KTtcblx0XHR9O1xuXG4vLy0tLS1BbmltYXRpb24gZ2V0dGVycy9zZXR0ZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0aWYgKCh0eXBlIHx8IFwiXCIpLnN1YnN0cigwLDIpID09PSBcIm9uXCIpIHtcblx0XHRcdFx0dmFyIHYgPSB0aGlzLnZhcnM7XG5cdFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZbdHlwZV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNhbGxiYWNrID09IG51bGwpIHtcblx0XHRcdFx0XHRkZWxldGUgdlt0eXBlXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2W3R5cGVdID0gY2FsbGJhY2s7XG5cdFx0XHRcdFx0dlt0eXBlICsgXCJQYXJhbXNcIl0gPSAoX2lzQXJyYXkocGFyYW1zKSAmJiBwYXJhbXMuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkgPyB0aGlzLl9zd2FwU2VsZkluUGFyYW1zKHBhcmFtcykgOiBwYXJhbXM7XG5cdFx0XHRcdFx0dlt0eXBlICsgXCJTY29wZVwiXSA9IHNjb3BlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlID09PSBcIm9uVXBkYXRlXCIpIHtcblx0XHRcdFx0XHR0aGlzLl9vblVwZGF0ZSA9IGNhbGxiYWNrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5kZWxheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2RlbGF5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdHRoaXMuc3RhcnRUaW1lKCB0aGlzLl9zdGFydFRpbWUgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTsgLy90cnVlIGluIGNhc2UgaXQncyBhIFR3ZWVuTWF4IG9yIFRpbWVsaW5lTWF4IHRoYXQgaGFzIGEgcmVwZWF0IC0gd2UnbGwgbmVlZCB0byByZWZyZXNoIHRoZSB0b3RhbER1cmF0aW9uLlxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSBpZiAodGhpcy5fdGltZSA+IDApIGlmICh0aGlzLl90aW1lIDwgdGhpcy5fZHVyYXRpb24pIGlmICh2YWx1ZSAhPT0gMCkge1xuXHRcdFx0XHR0aGlzLnRvdGFsVGltZSh0aGlzLl90b3RhbFRpbWUgKiAodmFsdWUgLyB0aGlzLl9kdXJhdGlvbiksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy5kdXJhdGlvbih2YWx1ZSk7XG5cdFx0fTtcblxuXHRcdHAudGltZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKCh2YWx1ZSA+IHRoaXMuX2R1cmF0aW9uKSA/IHRoaXMuX2R1cmF0aW9uIDogdmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbFRpbWUgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgdW5jYXBwZWQpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxUaW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdGlmICh0aW1lIDwgMCAmJiAhdW5jYXBwZWQpIHtcblx0XHRcdFx0XHR0aW1lICs9IHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB0b3RhbER1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbixcblx0XHRcdFx0XHRcdHRsID0gdGhpcy5fdGltZWxpbmU7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPiB0b3RhbER1cmF0aW9uICYmICF1bmNhcHBlZCkge1xuXHRcdFx0XHRcdFx0dGltZSA9IHRvdGFsRHVyYXRpb247XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICh0aGlzLl9wYXVzZWQgPyB0aGlzLl9wYXVzZVRpbWUgOiB0bC5fdGltZSkgLSAoKCF0aGlzLl9yZXZlcnNlZCA/IHRpbWUgOiB0b3RhbER1cmF0aW9uIC0gdGltZSkgLyB0aGlzLl90aW1lU2NhbGUpO1xuXHRcdFx0XHRcdGlmICghdGwuX2RpcnR5KSB7IC8vZm9yIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LiBJZiB0aGUgcGFyZW50J3MgY2FjaGUgaXMgYWxyZWFkeSBkaXJ0eSwgaXQgYWxyZWFkeSB0b29rIGNhcmUgb2YgbWFya2luZyB0aGUgYW5jZXN0b3JzIGFzIGRpcnR5IHRvbywgc28gc2tpcCB0aGUgZnVuY3Rpb24gY2FsbCBoZXJlLlxuXHRcdFx0XHRcdFx0dGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vaW4gY2FzZSBhbnkgb2YgdGhlIGFuY2VzdG9yIHRpbWVsaW5lcyBoYWQgY29tcGxldGVkIGJ1dCBzaG91bGQgbm93IGJlIGVuYWJsZWQsIHdlIHNob3VsZCByZXNldCB0aGVpciB0b3RhbFRpbWUoKSB3aGljaCB3aWxsIGFsc28gZW5zdXJlIHRoYXQgdGhleSdyZSBsaW5lZCB1cCBwcm9wZXJseSBhbmQgZW5hYmxlZC4gU2tpcCBmb3IgYW5pbWF0aW9ucyB0aGF0IGFyZSBvbiB0aGUgcm9vdCAod2FzdGVmdWwpLiBFeGFtcGxlOiBhIFRpbWVsaW5lTGl0ZS5leHBvcnRSb290KCkgaXMgcGVyZm9ybWVkIHdoZW4gdGhlcmUncyBhIHBhdXNlZCB0d2VlbiBvbiB0aGUgcm9vdCwgdGhlIGV4cG9ydCB3aWxsIG5vdCBjb21wbGV0ZSB1bnRpbCB0aGF0IHR3ZWVuIGlzIHVucGF1c2VkLCBidXQgaW1hZ2luZSBhIGNoaWxkIGdldHMgcmVzdGFydGVkIGxhdGVyLCBhZnRlciBhbGwgW3VucGF1c2VkXSB0d2VlbnMgaGF2ZSBjb21wbGV0ZWQuIFRoZSBzdGFydFRpbWUgb2YgdGhhdCBjaGlsZCB3b3VsZCBnZXQgcHVzaGVkIG91dCwgYnV0IG9uZSBvZiB0aGUgYW5jZXN0b3JzIG1heSBoYXZlIGNvbXBsZXRlZC5cblx0XHRcdFx0XHRpZiAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0bC5fdGltZWxpbmUuX3RpbWUgIT09ICh0bC5fc3RhcnRUaW1lICsgdGwuX3RvdGFsVGltZSkgLyB0bC5fdGltZVNjYWxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGwudG90YWxUaW1lKHRsLl90b3RhbFRpbWUsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fdG90YWxUaW1lICE9PSB0aW1lIHx8IHRoaXMuX2R1cmF0aW9uID09PSAwKSB7XG5cdFx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZhbHNlKTtcblx0XHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5wcm9ncmVzcyA9IHAudG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0dmFyIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyAoZHVyYXRpb24gPyB0aGlzLl90aW1lIC8gZHVyYXRpb24gOiB0aGlzLnJhdGlvKSA6IHRoaXMudG90YWxUaW1lKGR1cmF0aW9uICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFydFRpbWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zdGFydFRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IHRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKHRoaXMudGltZWxpbmUpIGlmICh0aGlzLnRpbWVsaW5lLl9zb3J0Q2hpbGRyZW4pIHtcblx0XHRcdFx0XHR0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLCB2YWx1ZSAtIHRoaXMuX2RlbGF5KTsgLy9lbnN1cmVzIHRoYXQgYW55IG5lY2Vzc2FyeSByZS1zZXF1ZW5jaW5nIG9mIEFuaW1hdGlvbnMgaW4gdGhlIHRpbWVsaW5lIG9jY3VycyB0byBtYWtlIHN1cmUgdGhlIHJlbmRlcmluZyBvcmRlciBpcyBjb3JyZWN0LlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5lbmRUaW1lID0gZnVuY3Rpb24oaW5jbHVkZVJlcGVhdHMpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zdGFydFRpbWUgKyAoKGluY2x1ZGVSZXBlYXRzICE9IGZhbHNlKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIHRoaXMuX3RpbWVTY2FsZTtcblx0XHR9O1xuXG5cdFx0cC50aW1lU2NhbGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lU2NhbGU7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHZhbHVlIHx8IF90aW55TnVtOyAvL2Nhbid0IGFsbG93IHplcm8gYmVjYXVzZSBpdCdsbCB0aHJvdyB0aGUgbWF0aCBvZmZcblx0XHRcdGlmICh0aGlzLl90aW1lbGluZSAmJiB0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHR2YXIgcGF1c2VUaW1lID0gdGhpcy5fcGF1c2VUaW1lLFxuXHRcdFx0XHRcdHQgPSAocGF1c2VUaW1lIHx8IHBhdXNlVGltZSA9PT0gMCkgPyBwYXVzZVRpbWUgOiB0aGlzLl90aW1lbGluZS50b3RhbFRpbWUoKTtcblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdCAtICgodCAtIHRoaXMuX3N0YXJ0VGltZSkgKiB0aGlzLl90aW1lU2NhbGUgLyB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90aW1lU2NhbGUgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXZlcnNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlICE9IHRoaXMuX3JldmVyc2VkKSB7XG5cdFx0XHRcdHRoaXMuX3JldmVyc2VkID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMudG90YWxUaW1lKCgodGhpcy5fdGltZWxpbmUgJiYgIXRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIC0gdGhpcy5fdG90YWxUaW1lIDogdGhpcy5fdG90YWxUaW1lKSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5wYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYXVzZWQ7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGwgPSB0aGlzLl90aW1lbGluZSxcblx0XHRcdFx0cmF3LCBlbGFwc2VkO1xuXHRcdFx0aWYgKHZhbHVlICE9IHRoaXMuX3BhdXNlZCkgaWYgKHRsKSB7XG5cdFx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSAmJiAhdmFsdWUpIHtcblx0XHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyYXcgPSB0bC5yYXdUaW1lKCk7XG5cdFx0XHRcdGVsYXBzZWQgPSByYXcgLSB0aGlzLl9wYXVzZVRpbWU7XG5cdFx0XHRcdGlmICghdmFsdWUgJiYgdGwuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgKz0gZWxhcHNlZDtcblx0XHRcdFx0XHR0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9wYXVzZVRpbWUgPSB2YWx1ZSA/IHJhdyA6IG51bGw7XG5cdFx0XHRcdHRoaXMuX3BhdXNlZCA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0aGlzLmlzQWN0aXZlKCk7XG5cdFx0XHRcdGlmICghdmFsdWUgJiYgZWxhcHNlZCAhPT0gMCAmJiB0aGlzLl9pbml0dGVkICYmIHRoaXMuZHVyYXRpb24oKSkge1xuXHRcdFx0XHRcdHJhdyA9IHRsLnNtb290aENoaWxkVGltaW5nID8gdGhpcy5fdG90YWxUaW1lIDogKHJhdyAtIHRoaXMuX3N0YXJ0VGltZSkgLyB0aGlzLl90aW1lU2NhbGU7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIocmF3LCAocmF3ID09PSB0aGlzLl90b3RhbFRpbWUpLCB0cnVlKTsgLy9pbiBjYXNlIHRoZSB0YXJnZXQncyBwcm9wZXJ0aWVzIGNoYW5nZWQgdmlhIHNvbWUgb3RoZXIgdHdlZW4gb3IgbWFudWFsIHVwZGF0ZSBieSB0aGUgdXNlciwgd2Ugc2hvdWxkIGZvcmNlIGEgcmVuZGVyLlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZ2MgJiYgIXZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogU2ltcGxlVGltZWxpbmVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBTaW1wbGVUaW1lbGluZSA9IF9jbGFzcyhcImNvcmUuU2ltcGxlVGltZWxpbmVcIiwgZnVuY3Rpb24odmFycykge1xuXHRcdFx0QW5pbWF0aW9uLmNhbGwodGhpcywgMCwgdmFycyk7XG5cdFx0XHR0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9IHRoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSB0cnVlO1xuXHRcdH0pO1xuXG5cdFx0cCA9IFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZSA9IG5ldyBBbmltYXRpb24oKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gU2ltcGxlVGltZWxpbmU7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cdFx0cC5fZmlyc3QgPSBwLl9sYXN0ID0gcC5fcmVjZW50ID0gbnVsbDtcblx0XHRwLl9zb3J0Q2hpbGRyZW4gPSBmYWxzZTtcblxuXHRcdHAuYWRkID0gcC5pbnNlcnQgPSBmdW5jdGlvbihjaGlsZCwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHR2YXIgcHJldlR3ZWVuLCBzdDtcblx0XHRcdGNoaWxkLl9zdGFydFRpbWUgPSBOdW1iZXIocG9zaXRpb24gfHwgMCkgKyBjaGlsZC5fZGVsYXk7XG5cdFx0XHRpZiAoY2hpbGQuX3BhdXNlZCkgaWYgKHRoaXMgIT09IGNoaWxkLl90aW1lbGluZSkgeyAvL3dlIG9ubHkgYWRqdXN0IHRoZSBfcGF1c2VUaW1lIGlmIGl0IHdhc24ndCBpbiB0aGlzIHRpbWVsaW5lIGFscmVhZHkuIFJlbWVtYmVyLCBzb21ldGltZXMgYSB0d2VlbiB3aWxsIGJlIGluc2VydGVkIGFnYWluIGludG8gdGhlIHNhbWUgdGltZWxpbmUgd2hlbiBpdHMgc3RhcnRUaW1lIGlzIGNoYW5nZWQgc28gdGhhdCB0aGUgdHdlZW5zIGluIHRoZSBUaW1lbGluZUxpdGUvTWF4IGFyZSByZS1vcmRlcmVkIHByb3Blcmx5IGluIHRoZSBsaW5rZWQgbGlzdCAoc28gZXZlcnl0aGluZyByZW5kZXJzIGluIHRoZSBwcm9wZXIgb3JkZXIpLlxuXHRcdFx0XHRjaGlsZC5fcGF1c2VUaW1lID0gY2hpbGQuX3N0YXJ0VGltZSArICgodGhpcy5yYXdUaW1lKCkgLSBjaGlsZC5fc3RhcnRUaW1lKSAvIGNoaWxkLl90aW1lU2NhbGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNoaWxkLnRpbWVsaW5lKSB7XG5cdFx0XHRcdGNoaWxkLnRpbWVsaW5lLl9yZW1vdmUoY2hpbGQsIHRydWUpOyAvL3JlbW92ZXMgZnJvbSBleGlzdGluZyB0aW1lbGluZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSBhZGRlZCB0byB0aGlzIG9uZS5cblx0XHRcdH1cblx0XHRcdGNoaWxkLnRpbWVsaW5lID0gY2hpbGQuX3RpbWVsaW5lID0gdGhpcztcblx0XHRcdGlmIChjaGlsZC5fZ2MpIHtcblx0XHRcdFx0Y2hpbGQuX2VuYWJsZWQodHJ1ZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRwcmV2VHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0aWYgKHRoaXMuX3NvcnRDaGlsZHJlbikge1xuXHRcdFx0XHRzdCA9IGNoaWxkLl9zdGFydFRpbWU7XG5cdFx0XHRcdHdoaWxlIChwcmV2VHdlZW4gJiYgcHJldlR3ZWVuLl9zdGFydFRpbWUgPiBzdCkge1xuXHRcdFx0XHRcdHByZXZUd2VlbiA9IHByZXZUd2Vlbi5fcHJldjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHByZXZUd2Vlbikge1xuXHRcdFx0XHRjaGlsZC5fbmV4dCA9IHByZXZUd2Vlbi5fbmV4dDtcblx0XHRcdFx0cHJldlR3ZWVuLl9uZXh0ID0gY2hpbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGlsZC5fbmV4dCA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR0aGlzLl9maXJzdCA9IGNoaWxkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNoaWxkLl9uZXh0KSB7XG5cdFx0XHRcdGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9sYXN0ID0gY2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHRjaGlsZC5fcHJldiA9IHByZXZUd2Vlbjtcblx0XHRcdHRoaXMuX3JlY2VudCA9IGNoaWxkO1xuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fcmVtb3ZlID0gZnVuY3Rpb24odHdlZW4sIHNraXBEaXNhYmxlKSB7XG5cdFx0XHRpZiAodHdlZW4udGltZWxpbmUgPT09IHRoaXMpIHtcblx0XHRcdFx0aWYgKCFza2lwRGlzYWJsZSkge1xuXHRcdFx0XHRcdHR3ZWVuLl9lbmFibGVkKGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0d2Vlbi5fcHJldikge1xuXHRcdFx0XHRcdHR3ZWVuLl9wcmV2Ll9uZXh0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZmlyc3QgPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3QgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHdlZW4uX25leHQpIHtcblx0XHRcdFx0XHR0d2Vlbi5fbmV4dC5fcHJldiA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2xhc3QgPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0dGhpcy5fbGFzdCA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuLl9uZXh0ID0gdHdlZW4uX3ByZXYgPSB0d2Vlbi50aW1lbGluZSA9IG51bGw7XG5cdFx0XHRcdGlmICh0d2VlbiA9PT0gdGhpcy5fcmVjZW50KSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVjZW50ID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdG5leHQ7XG5cdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0aW1lID49IHR3ZWVuLl9zdGFydFRpbWUgJiYgIXR3ZWVuLl9wYXVzZWQpKSB7XG5cdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAucmF3VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsVGltZTtcblx0XHR9O1xuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVHdlZW5MaXRlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgVHdlZW5MaXRlID0gX2NsYXNzKFwiVHdlZW5MaXRlXCIsIGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdFx0QW5pbWF0aW9uLmNhbGwodGhpcywgZHVyYXRpb24sIHZhcnMpO1xuXHRcdFx0XHR0aGlzLnJlbmRlciA9IFR3ZWVuTGl0ZS5wcm90b3R5cGUucmVuZGVyOyAvL3NwZWVkIG9wdGltaXphdGlvbiAoYXZvaWQgcHJvdG90eXBlIGxvb2t1cCBvbiB0aGlzIFwiaG90XCIgbWV0aG9kKVxuXG5cdFx0XHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRocm93IFwiQ2Fubm90IHR3ZWVuIGEgbnVsbCB0YXJnZXQuXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnRhcmdldCA9IHRhcmdldCA9ICh0eXBlb2YodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIikgPyB0YXJnZXQgOiBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cblx0XHRcdFx0dmFyIGlzU2VsZWN0b3IgPSAodGFyZ2V0LmpxdWVyeSB8fCAodGFyZ2V0Lmxlbmd0aCAmJiB0YXJnZXQgIT09IHdpbmRvdyAmJiB0YXJnZXRbMF0gJiYgKHRhcmdldFswXSA9PT0gd2luZG93IHx8ICh0YXJnZXRbMF0ubm9kZVR5cGUgJiYgdGFyZ2V0WzBdLnN0eWxlICYmICF0YXJnZXQubm9kZVR5cGUpKSkpLFxuXHRcdFx0XHRcdG92ZXJ3cml0ZSA9IHRoaXMudmFycy5vdmVyd3JpdGUsXG5cdFx0XHRcdFx0aSwgdGFyZywgdGFyZ2V0cztcblxuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGUgPSBvdmVyd3JpdGUgPSAob3ZlcndyaXRlID09IG51bGwpID8gX292ZXJ3cml0ZUxvb2t1cFtUd2VlbkxpdGUuZGVmYXVsdE92ZXJ3cml0ZV0gOiAodHlwZW9mKG92ZXJ3cml0ZSkgPT09IFwibnVtYmVyXCIpID8gb3ZlcndyaXRlID4+IDAgOiBfb3ZlcndyaXRlTG9va3VwW292ZXJ3cml0ZV07XG5cblx0XHRcdFx0aWYgKChpc1NlbGVjdG9yIHx8IHRhcmdldCBpbnN0YW5jZW9mIEFycmF5IHx8ICh0YXJnZXQucHVzaCAmJiBfaXNBcnJheSh0YXJnZXQpKSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHR0aGlzLl90YXJnZXRzID0gdGFyZ2V0cyA9IF9zbGljZSh0YXJnZXQpOyAgLy9kb24ndCB1c2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGFyZ2V0LCAwKSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHRcdHRoaXMuX3Byb3BMb29rdXAgPSBbXTtcblx0XHRcdFx0XHR0aGlzLl9zaWJsaW5ncyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0YXJnID0gdGFyZ2V0c1tpXTtcblx0XHRcdFx0XHRcdGlmICghdGFyZykge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLS0sIDEpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHRhcmcpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmcgPSB0YXJnZXRzW2ktLV0gPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZyk7IC8vaW4gY2FzZSBpdCdzIGFuIGFycmF5IG9mIHN0cmluZ3Ncblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZih0YXJnKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGkrMSwgMSk7IC8vdG8gYXZvaWQgYW4gZW5kbGVzcyBsb29wIChjYW4ndCBpbWFnaW5lIHdoeSB0aGUgc2VsZWN0b3Igd291bGQgcmV0dXJuIGEgc3RyaW5nLCBidXQganVzdCBpbiBjYXNlKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0YXJnLmxlbmd0aCAmJiB0YXJnICE9PSB3aW5kb3cgJiYgdGFyZ1swXSAmJiAodGFyZ1swXSA9PT0gd2luZG93IHx8ICh0YXJnWzBdLm5vZGVUeXBlICYmIHRhcmdbMF0uc3R5bGUgJiYgIXRhcmcubm9kZVR5cGUpKSkgeyAvL2luIGNhc2UgdGhlIHVzZXIgaXMgcGFzc2luZyBpbiBhbiBhcnJheSBvZiBzZWxlY3RvciBvYmplY3RzIChsaWtlIGpRdWVyeSBvYmplY3RzKSwgd2UgbmVlZCB0byBjaGVjayBvbmUgbW9yZSBsZXZlbCBhbmQgcHVsbCB0aGluZ3Mgb3V0IGlmIG5lY2Vzc2FyeS4gQWxzbyBub3RlIHRoYXQgPHNlbGVjdD4gZWxlbWVudHMgcGFzcyBhbGwgdGhlIGNyaXRlcmlhIHJlZ2FyZGluZyBsZW5ndGggYW5kIHRoZSBmaXJzdCBjaGlsZCBoYXZpbmcgc3R5bGUsIHNvIHdlIG11c3QgYWxzbyBjaGVjayB0byBlbnN1cmUgdGhlIHRhcmdldCBpc24ndCBhbiBIVE1MIG5vZGUgaXRzZWxmLlxuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLS0sIDEpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl90YXJnZXRzID0gdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KF9zbGljZSh0YXJnKSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fc2libGluZ3NbaV0gPSBfcmVnaXN0ZXIodGFyZywgdGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdFx0aWYgKG92ZXJ3cml0ZSA9PT0gMSkgaWYgKHRoaXMuX3NpYmxpbmdzW2ldLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdFx0X2FwcGx5T3ZlcndyaXRlKHRhcmcsIHRoaXMsIG51bGwsIDEsIHRoaXMuX3NpYmxpbmdzW2ldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9wcm9wTG9va3VwID0ge307XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBfcmVnaXN0ZXIodGFyZ2V0LCB0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0aWYgKG92ZXJ3cml0ZSA9PT0gMSkgaWYgKHRoaXMuX3NpYmxpbmdzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdF9hcHBseU92ZXJ3cml0ZSh0YXJnZXQsIHRoaXMsIG51bGwsIDEsIHRoaXMuX3NpYmxpbmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIgfHwgKGR1cmF0aW9uID09PSAwICYmIHRoaXMuX2RlbGF5ID09PSAwICYmIHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlKSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSAtX3RpbnlOdW07IC8vZm9yY2VzIGEgcmVuZGVyIHdpdGhvdXQgaGF2aW5nIHRvIHNldCB0aGUgcmVuZGVyKCkgXCJmb3JjZVwiIHBhcmFtZXRlciB0byB0cnVlIGJlY2F1c2Ugd2Ugd2FudCB0byBhbGxvdyBsYXp5aW5nIGJ5IGRlZmF1bHQgKHVzaW5nIHRoZSBcImZvcmNlXCIgcGFyYW1ldGVyIGFsd2F5cyBmb3JjZXMgYW4gaW1tZWRpYXRlIGZ1bGwgcmVuZGVyKVxuXHRcdFx0XHRcdHRoaXMucmVuZGVyKE1hdGgubWluKDAsIC10aGlzLl9kZWxheSkpOyAvL2luIGNhc2UgZGVsYXkgaXMgbmVnYXRpdmVcblx0XHRcdFx0fVxuXHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRfaXNTZWxlY3RvciA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0cmV0dXJuICh2ICYmIHYubGVuZ3RoICYmIHYgIT09IHdpbmRvdyAmJiB2WzBdICYmICh2WzBdID09PSB3aW5kb3cgfHwgKHZbMF0ubm9kZVR5cGUgJiYgdlswXS5zdHlsZSAmJiAhdi5ub2RlVHlwZSkpKTsgLy93ZSBjYW5ub3QgY2hlY2sgXCJub2RlVHlwZVwiIGlmIHRoZSB0YXJnZXQgaXMgd2luZG93IGZyb20gd2l0aGluIGFuIGlmcmFtZSwgb3RoZXJ3aXNlIGl0IHdpbGwgdHJpZ2dlciBhIHNlY3VyaXR5IGVycm9yIGluIHNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxuXHRcdFx0fSxcblx0XHRcdF9hdXRvQ1NTID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHRcdHZhciBjc3MgPSB7fSxcblx0XHRcdFx0XHRwO1xuXHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdGlmICghX3Jlc2VydmVkUHJvcHNbcF0gJiYgKCEocCBpbiB0YXJnZXQpIHx8IHAgPT09IFwidHJhbnNmb3JtXCIgfHwgcCA9PT0gXCJ4XCIgfHwgcCA9PT0gXCJ5XCIgfHwgcCA9PT0gXCJ3aWR0aFwiIHx8IHAgPT09IFwiaGVpZ2h0XCIgfHwgcCA9PT0gXCJjbGFzc05hbWVcIiB8fCBwID09PSBcImJvcmRlclwiKSAmJiAoIV9wbHVnaW5zW3BdIHx8IChfcGx1Z2luc1twXSAmJiBfcGx1Z2luc1twXS5fYXV0b0NTUykpKSB7IC8vbm90ZTogPGltZz4gZWxlbWVudHMgY29udGFpbiByZWFkLW9ubHkgXCJ4XCIgYW5kIFwieVwiIHByb3BlcnRpZXMuIFdlIHNob3VsZCBhbHNvIHByaW9yaXRpemUgZWRpdGluZyBjc3Mgd2lkdGgvaGVpZ2h0IHJhdGhlciB0aGFuIHRoZSBlbGVtZW50J3MgcHJvcGVydGllcy5cblx0XHRcdFx0XHRcdGNzc1twXSA9IHZhcnNbcF07XG5cdFx0XHRcdFx0XHRkZWxldGUgdmFyc1twXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFycy5jc3MgPSBjc3M7XG5cdFx0XHR9O1xuXG5cdFx0cCA9IFR3ZWVuTGl0ZS5wcm90b3R5cGUgPSBuZXcgQW5pbWF0aW9uKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFR3ZWVuTGl0ZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblxuLy8tLS0tVHdlZW5MaXRlIGRlZmF1bHRzLCBvdmVyd3JpdGUgbWFuYWdlbWVudCwgYW5kIHJvb3QgdXBkYXRlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLnJhdGlvID0gMDtcblx0XHRwLl9maXJzdFBUID0gcC5fdGFyZ2V0cyA9IHAuX292ZXJ3cml0dGVuUHJvcHMgPSBwLl9zdGFydEF0ID0gbnVsbDtcblx0XHRwLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gcC5fbGF6eSA9IGZhbHNlO1xuXG5cdFx0VHdlZW5MaXRlLnZlcnNpb24gPSBcIjEuMTguNFwiO1xuXHRcdFR3ZWVuTGl0ZS5kZWZhdWx0RWFzZSA9IHAuX2Vhc2UgPSBuZXcgRWFzZShudWxsLCBudWxsLCAxLCAxKTtcblx0XHRUd2VlbkxpdGUuZGVmYXVsdE92ZXJ3cml0ZSA9IFwiYXV0b1wiO1xuXHRcdFR3ZWVuTGl0ZS50aWNrZXIgPSBfdGlja2VyO1xuXHRcdFR3ZWVuTGl0ZS5hdXRvU2xlZXAgPSAxMjA7XG5cdFx0VHdlZW5MaXRlLmxhZ1Ntb290aGluZyA9IGZ1bmN0aW9uKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpIHtcblx0XHRcdF90aWNrZXIubGFnU21vb3RoaW5nKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuc2VsZWN0b3IgPSB3aW5kb3cuJCB8fCB3aW5kb3cualF1ZXJ5IHx8IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBzZWxlY3RvciA9IHdpbmRvdy4kIHx8IHdpbmRvdy5qUXVlcnk7XG5cdFx0XHRpZiAoc2VsZWN0b3IpIHtcblx0XHRcdFx0VHdlZW5MaXRlLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdHJldHVybiBzZWxlY3RvcihlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodHlwZW9mKGRvY3VtZW50KSA9PT0gXCJ1bmRlZmluZWRcIikgPyBlIDogKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGUpIDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoKGUuY2hhckF0KDApID09PSBcIiNcIikgPyBlLnN1YnN0cigxKSA6IGUpKTtcblx0XHR9O1xuXG5cdFx0dmFyIF9sYXp5VHdlZW5zID0gW10sXG5cdFx0XHRfbGF6eUxvb2t1cCA9IHt9LFxuXHRcdFx0X251bWJlcnNFeHAgPSAvKD86KC18LT18XFwrPSk/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vaWcsXG5cdFx0XHQvL19ub25OdW1iZXJzRXhwID0gLyg/OihbXFwtK10oPyEoXFxkfD0pKSl8W15cXGRcXC0rPWVdfChlKD8hW1xcLStdW1xcZF0pKSkrL2lnLFxuXHRcdFx0X3NldFJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRcdHZhbDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0dmFsID0gIXB0LmJsb2IgPyBwdC5jICogdiArIHB0LnMgOiB2ID8gdGhpcy5qb2luKFwiXCIpIDogdGhpcy5zdGFydDtcblx0XHRcdFx0XHRpZiAocHQucikge1xuXHRcdFx0XHRcdFx0dmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsIDwgbWluKSBpZiAodmFsID4gLW1pbikgeyAvL3ByZXZlbnRzIGlzc3VlcyB3aXRoIGNvbnZlcnRpbmcgdmVyeSBzbWFsbCBudW1iZXJzIHRvIHN0cmluZ3MgaW4gdGhlIGJyb3dzZXJcblx0XHRcdFx0XHRcdHZhbCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghcHQuZikge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHZhbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LmZwKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LmZwLCB2YWwpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdKHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvL2NvbXBhcmVzIHR3byBzdHJpbmdzIChzdGFydC9lbmQpLCBmaW5kcyB0aGUgbnVtYmVycyB0aGF0IGFyZSBkaWZmZXJlbnQgYW5kIHNwaXRzIGJhY2sgYW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSB3aG9sZSB2YWx1ZSBidXQgd2l0aCB0aGUgY2hhbmdpbmcgdmFsdWVzIGlzb2xhdGVkIGFzIGVsZW1lbnRzLiBGb3IgZXhhbXBsZSwgXCJyZ2IoMCwwLDApXCIgYW5kIFwicmdiKDEwMCw1MCwwKVwiIHdvdWxkIGJlY29tZSBbXCJyZ2IoXCIsIDAsIFwiLFwiLCA1MCwgXCIsMClcIl0uIE5vdGljZSBpdCBtZXJnZXMgdGhlIHBhcnRzIHRoYXQgYXJlIGlkZW50aWNhbCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKS4gVGhlIGFycmF5IGFsc28gaGFzIGEgbGlua2VkIGxpc3Qgb2YgUHJvcFR3ZWVucyBhdHRhY2hlZCBzdGFydGluZyB3aXRoIF9maXJzdFBUIHRoYXQgY29udGFpbiB0aGUgdHdlZW5pbmcgZGF0YSAodCwgcCwgcywgYywgZiwgZXRjLikuIEl0IGFsc28gc3RvcmVzIHRoZSBzdGFydGluZyB2YWx1ZSBhcyBhIFwic3RhcnRcIiBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiByZXZlcnQgdG8gaXQgaWYvd2hlbiBuZWNlc3NhcnksIGxpa2Ugd2hlbiBhIHR3ZWVuIHJld2luZHMgZnVsbHkuIElmIHRoZSBxdWFudGl0eSBvZiBudW1iZXJzIGRpZmZlcnMgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCwgaXQgd2lsbCBhbHdheXMgcHJpb3JpdGl6ZSB0aGUgZW5kIHZhbHVlKHMpLiBUaGUgcHQgcGFyYW1ldGVyIGlzIG9wdGlvbmFsIC0gaXQncyBmb3IgYSBQcm9wVHdlZW4gdGhhdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0IGFuZCBpcyB0eXBpY2FsbHkgZm9yIGFjdHVhbGx5IHNldHRpbmcgdGhlIHZhbHVlIGFmdGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgaGF2ZSBiZWVuIHVwZGF0ZWQgKHdpdGggYXJyYXkuam9pbihcIlwiKSkuXG5cdFx0XHRfYmxvYkRpZiA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGZpbHRlciwgcHQpIHtcblx0XHRcdFx0dmFyIGEgPSBbc3RhcnQsIGVuZF0sXG5cdFx0XHRcdFx0Y2hhckluZGV4ID0gMCxcblx0XHRcdFx0XHRzID0gXCJcIixcblx0XHRcdFx0XHRjb2xvciA9IDAsXG5cdFx0XHRcdFx0c3RhcnROdW1zLCBlbmROdW1zLCBudW0sIGksIGwsIG5vbk51bWJlcnMsIGN1cnJlbnROdW07XG5cdFx0XHRcdGEuc3RhcnQgPSBzdGFydDtcblx0XHRcdFx0aWYgKGZpbHRlcikge1xuXHRcdFx0XHRcdGZpbHRlcihhKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLlxuXHRcdFx0XHRcdHN0YXJ0ID0gYVswXTtcblx0XHRcdFx0XHRlbmQgPSBhWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGEubGVuZ3RoID0gMDtcblx0XHRcdFx0c3RhcnROdW1zID0gc3RhcnQubWF0Y2goX251bWJlcnNFeHApIHx8IFtdO1xuXHRcdFx0XHRlbmROdW1zID0gZW5kLm1hdGNoKF9udW1iZXJzRXhwKSB8fCBbXTtcblx0XHRcdFx0aWYgKHB0KSB7XG5cdFx0XHRcdFx0cHQuX25leHQgPSBudWxsO1xuXHRcdFx0XHRcdHB0LmJsb2IgPSAxO1xuXHRcdFx0XHRcdGEuX2ZpcnN0UFQgPSBwdDsgLy9hcHBseSBsYXN0IGluIHRoZSBsaW5rZWQgbGlzdCAod2hpY2ggbWVhbnMgaW5zZXJ0aW5nIGl0IGZpcnN0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdGwgPSBlbmROdW1zLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGN1cnJlbnROdW0gPSBlbmROdW1zW2ldO1xuXHRcdFx0XHRcdG5vbk51bWJlcnMgPSBlbmQuc3Vic3RyKGNoYXJJbmRleCwgZW5kLmluZGV4T2YoY3VycmVudE51bSwgY2hhckluZGV4KS1jaGFySW5kZXgpO1xuXHRcdFx0XHRcdHMgKz0gKG5vbk51bWJlcnMgfHwgIWkpID8gbm9uTnVtYmVycyA6IFwiLFwiOyAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cblx0XHRcdFx0XHRjaGFySW5kZXggKz0gbm9uTnVtYmVycy5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKGNvbG9yKSB7IC8vc2Vuc2UgcmdiYSgpIHZhbHVlcyBhbmQgcm91bmQgdGhlbS5cblx0XHRcdFx0XHRcdGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9uTnVtYmVycy5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIpIHtcblx0XHRcdFx0XHRcdGNvbG9yID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnROdW0gPT09IHN0YXJ0TnVtc1tpXSB8fCBzdGFydE51bXMubGVuZ3RoIDw9IGkpIHtcblx0XHRcdFx0XHRcdHMgKz0gY3VycmVudE51bTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKHMpIHtcblx0XHRcdFx0XHRcdFx0YS5wdXNoKHMpO1xuXHRcdFx0XHRcdFx0XHRzID0gXCJcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG51bSA9IHBhcnNlRmxvYXQoc3RhcnROdW1zW2ldKTtcblx0XHRcdFx0XHRcdGEucHVzaChudW0pO1xuXHRcdFx0XHRcdFx0YS5fZmlyc3RQVCA9IHtfbmV4dDogYS5fZmlyc3RQVCwgdDphLCBwOiBhLmxlbmd0aC0xLCBzOm51bSwgYzooKGN1cnJlbnROdW0uY2hhckF0KDEpID09PSBcIj1cIikgPyBwYXJzZUludChjdXJyZW50TnVtLmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KGN1cnJlbnROdW0uc3Vic3RyKDIpKSA6IChwYXJzZUZsb2F0KGN1cnJlbnROdW0pIC0gbnVtKSkgfHwgMCwgZjowLCByOihjb2xvciAmJiBjb2xvciA8IDQpfTtcblx0XHRcdFx0XHRcdC8vbm90ZTogd2UgZG9uJ3Qgc2V0IF9wcmV2IGJlY2F1c2Ugd2UnbGwgbmV2ZXIgbmVlZCB0byByZW1vdmUgaW5kaXZpZHVhbCBQcm9wVHdlZW5zIGZyb20gdGhpcyBsaXN0LlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjaGFySW5kZXggKz0gY3VycmVudE51bS5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0cyArPSBlbmQuc3Vic3RyKGNoYXJJbmRleCk7XG5cdFx0XHRcdGlmIChzKSB7XG5cdFx0XHRcdFx0YS5wdXNoKHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGEuc2V0UmF0aW8gPSBfc2V0UmF0aW87XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fSxcblx0XHRcdC8vbm90ZTogXCJmdW5jUGFyYW1cIiBpcyBvbmx5IG5lY2Vzc2FyeSBmb3IgZnVuY3Rpb24tYmFzZWQgZ2V0dGVycy9zZXR0ZXJzIHRoYXQgcmVxdWlyZSBhbiBleHRyYSBwYXJhbWV0ZXIgbGlrZSBnZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSBhbmQgc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdmFsdWUpLiBJbiB0aGlzIGV4YW1wbGUsIGZ1bmNQYXJhbSB3b3VsZCBiZSBcIndpZHRoXCIuIFVzZWQgYnkgQXR0clBsdWdpbiBmb3IgZXhhbXBsZS5cblx0XHRcdF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQsIG92ZXJ3cml0ZVByb3AsIHJvdW5kLCBmdW5jUGFyYW0sIHN0cmluZ0ZpbHRlcikge1xuXHRcdFx0XHR2YXIgcyA9IChzdGFydCA9PT0gXCJnZXRcIikgPyB0YXJnZXRbcHJvcF0gOiBzdGFydCxcblx0XHRcdFx0XHR0eXBlID0gdHlwZW9mKHRhcmdldFtwcm9wXSksXG5cdFx0XHRcdFx0aXNSZWxhdGl2ZSA9ICh0eXBlb2YoZW5kKSA9PT0gXCJzdHJpbmdcIiAmJiBlbmQuY2hhckF0KDEpID09PSBcIj1cIiksXG5cdFx0XHRcdFx0cHQgPSB7dDp0YXJnZXQsIHA6cHJvcCwgczpzLCBmOih0eXBlID09PSBcImZ1bmN0aW9uXCIpLCBwZzowLCBuOm92ZXJ3cml0ZVByb3AgfHwgcHJvcCwgcjpyb3VuZCwgcHI6MCwgYzppc1JlbGF0aXZlID8gcGFyc2VJbnQoZW5kLmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KGVuZC5zdWJzdHIoMikpIDogKHBhcnNlRmxvYXQoZW5kKSAtIHMpIHx8IDB9LFxuXHRcdFx0XHRcdGJsb2IsIGdldHRlck5hbWU7XG5cdFx0XHRcdGlmICh0eXBlICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiBzdGFydCA9PT0gXCJnZXRcIikge1xuXHRcdFx0XHRcdFx0Z2V0dGVyTmFtZSA9ICgocHJvcC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwcm9wIDogXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpKTtcblx0XHRcdFx0XHRcdHB0LnMgPSBzID0gZnVuY1BhcmFtID8gdGFyZ2V0W2dldHRlck5hbWVdKGZ1bmNQYXJhbSkgOiB0YXJnZXRbZ2V0dGVyTmFtZV0oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGVvZihzKSA9PT0gXCJzdHJpbmdcIiAmJiAoZnVuY1BhcmFtIHx8IGlzTmFOKHMpKSkge1xuXHRcdFx0XHRcdFx0Ly9hIGJsb2IgKHN0cmluZyB0aGF0IGhhcyBtdWx0aXBsZSBudW1iZXJzIGluIGl0KVxuXHRcdFx0XHRcdFx0cHQuZnAgPSBmdW5jUGFyYW07XG5cdFx0XHRcdFx0XHRibG9iID0gX2Jsb2JEaWYocywgZW5kLCBzdHJpbmdGaWx0ZXIgfHwgVHdlZW5MaXRlLmRlZmF1bHRTdHJpbmdGaWx0ZXIsIHB0KTtcblx0XHRcdFx0XHRcdHB0ID0ge3Q6YmxvYiwgcDpcInNldFJhdGlvXCIsIHM6MCwgYzoxLCBmOjIsIHBnOjAsIG46b3ZlcndyaXRlUHJvcCB8fCBwcm9wLCBwcjowfTsgLy9cIjJcIiBpbmRpY2F0ZXMgaXQncyBhIEJsb2IgcHJvcGVydHkgdHdlZW4uIE5lZWRlZCBmb3IgUm91bmRQcm9wc1BsdWdpbiBmb3IgZXhhbXBsZS5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFpc1JlbGF0aXZlKSB7XG5cdFx0XHRcdFx0XHRwdC5zID0gcGFyc2VGbG9hdChzKTtcblx0XHRcdFx0XHRcdHB0LmMgPSAocGFyc2VGbG9hdChlbmQpIC0gcHQucykgfHwgMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0LmMpIHsgLy9vbmx5IGFkZCBpdCB0byB0aGUgbGlua2VkIGxpc3QgaWYgdGhlcmUncyBhIGNoYW5nZS5cblx0XHRcdFx0XHRpZiAoKHB0Ll9uZXh0ID0gdGhpcy5fZmlyc3RQVCkpIHtcblx0XHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdDtcblx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfaW50ZXJuYWxzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMgPSB7aXNBcnJheTpfaXNBcnJheSwgaXNTZWxlY3RvcjpfaXNTZWxlY3RvciwgbGF6eVR3ZWVuczpfbGF6eVR3ZWVucywgYmxvYkRpZjpfYmxvYkRpZn0sIC8vZ2l2ZXMgdXMgYSB3YXkgdG8gZXhwb3NlIGNlcnRhaW4gcHJpdmF0ZSB2YWx1ZXMgdG8gb3RoZXIgR3JlZW5Tb2NrIGNsYXNzZXMgd2l0aG91dCBjb250YW1pbmF0aW5nIHRoYSBtYWluIFR3ZWVuTGl0ZSBvYmplY3QuXG5cdFx0XHRfcGx1Z2lucyA9IFR3ZWVuTGl0ZS5fcGx1Z2lucyA9IHt9LFxuXHRcdFx0X3R3ZWVuTG9va3VwID0gX2ludGVybmFscy50d2Vlbkxvb2t1cCA9IHt9LFxuXHRcdFx0X3R3ZWVuTG9va3VwTnVtID0gMCxcblx0XHRcdF9yZXNlcnZlZFByb3BzID0gX2ludGVybmFscy5yZXNlcnZlZFByb3BzID0ge2Vhc2U6MSwgZGVsYXk6MSwgb3ZlcndyaXRlOjEsIG9uQ29tcGxldGU6MSwgb25Db21wbGV0ZVBhcmFtczoxLCBvbkNvbXBsZXRlU2NvcGU6MSwgdXNlRnJhbWVzOjEsIHJ1bkJhY2t3YXJkczoxLCBzdGFydEF0OjEsIG9uVXBkYXRlOjEsIG9uVXBkYXRlUGFyYW1zOjEsIG9uVXBkYXRlU2NvcGU6MSwgb25TdGFydDoxLCBvblN0YXJ0UGFyYW1zOjEsIG9uU3RhcnRTY29wZToxLCBvblJldmVyc2VDb21wbGV0ZToxLCBvblJldmVyc2VDb21wbGV0ZVBhcmFtczoxLCBvblJldmVyc2VDb21wbGV0ZVNjb3BlOjEsIG9uUmVwZWF0OjEsIG9uUmVwZWF0UGFyYW1zOjEsIG9uUmVwZWF0U2NvcGU6MSwgZWFzZVBhcmFtczoxLCB5b3lvOjEsIGltbWVkaWF0ZVJlbmRlcjoxLCByZXBlYXQ6MSwgcmVwZWF0RGVsYXk6MSwgZGF0YToxLCBwYXVzZWQ6MSwgcmV2ZXJzZWQ6MSwgYXV0b0NTUzoxLCBsYXp5OjEsIG9uT3ZlcndyaXRlOjEsIGNhbGxiYWNrU2NvcGU6MSwgc3RyaW5nRmlsdGVyOjF9LFxuXHRcdFx0X292ZXJ3cml0ZUxvb2t1cCA9IHtub25lOjAsIGFsbDoxLCBhdXRvOjIsIGNvbmN1cnJlbnQ6MywgYWxsT25TdGFydDo0LCBwcmVleGlzdGluZzo1LCBcInRydWVcIjoxLCBcImZhbHNlXCI6MH0sXG5cdFx0XHRfcm9vdEZyYW1lc1RpbWVsaW5lID0gQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmUgPSBuZXcgU2ltcGxlVGltZWxpbmUoKSxcblx0XHRcdF9yb290VGltZWxpbmUgPSBBbmltYXRpb24uX3Jvb3RUaW1lbGluZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpLFxuXHRcdFx0X25leHRHQ0ZyYW1lID0gMzAsXG5cdFx0XHRfbGF6eVJlbmRlciA9IF9pbnRlcm5hbHMubGF6eVJlbmRlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaSA9IF9sYXp5VHdlZW5zLmxlbmd0aCxcblx0XHRcdFx0XHR0d2Vlbjtcblx0XHRcdFx0X2xhenlMb29rdXAgPSB7fTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0dHdlZW4gPSBfbGF6eVR3ZWVuc1tpXTtcblx0XHRcdFx0XHRpZiAodHdlZW4gJiYgdHdlZW4uX2xhenkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIodHdlZW4uX2xhenlbMF0sIHR3ZWVuLl9sYXp5WzFdLCB0cnVlKTtcblx0XHRcdFx0XHRcdHR3ZWVuLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cdFx0XHR9O1xuXG5cdFx0X3Jvb3RUaW1lbGluZS5fc3RhcnRUaW1lID0gX3RpY2tlci50aW1lO1xuXHRcdF9yb290RnJhbWVzVGltZWxpbmUuX3N0YXJ0VGltZSA9IF90aWNrZXIuZnJhbWU7XG5cdFx0X3Jvb3RUaW1lbGluZS5fYWN0aXZlID0gX3Jvb3RGcmFtZXNUaW1lbGluZS5fYWN0aXZlID0gdHJ1ZTtcblx0XHRzZXRUaW1lb3V0KF9sYXp5UmVuZGVyLCAxKTsgLy9vbiBzb21lIG1vYmlsZSBkZXZpY2VzLCB0aGVyZSBpc24ndCBhIFwidGlja1wiIGJlZm9yZSBjb2RlIHJ1bnMgd2hpY2ggbWVhbnMgYW55IGxhenkgcmVuZGVycyB3b3VsZG4ndCBydW4gYmVmb3JlIHRoZSBuZXh0IG9mZmljaWFsIFwidGlja1wiLlxuXG5cdFx0QW5pbWF0aW9uLl91cGRhdGVSb290ID0gVHdlZW5MaXRlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaSwgYSwgcDtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2lmIGNvZGUgaXMgcnVuIG91dHNpZGUgb2YgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBsb29wLCB0aGVyZSBtYXkgYmUgdHdlZW5zIHF1ZXVlZCBBRlRFUiB0aGUgZW5naW5lIHJlZnJlc2hlZCwgc28gd2UgbmVlZCB0byBlbnN1cmUgYW55IHBlbmRpbmcgcmVuZGVycyBvY2N1ciBiZWZvcmUgd2UgcmVmcmVzaCBhZ2Fpbi5cblx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yb290VGltZWxpbmUucmVuZGVyKChfdGlja2VyLnRpbWUgLSBfcm9vdFRpbWVsaW5lLl9zdGFydFRpbWUpICogX3Jvb3RUaW1lbGluZS5fdGltZVNjYWxlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRfcm9vdEZyYW1lc1RpbWVsaW5lLnJlbmRlcigoX3RpY2tlci5mcmFtZSAtIF9yb290RnJhbWVzVGltZWxpbmUuX3N0YXJ0VGltZSkgKiBfcm9vdEZyYW1lc1RpbWVsaW5lLl90aW1lU2NhbGUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHtcblx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfdGlja2VyLmZyYW1lID49IF9uZXh0R0NGcmFtZSkgeyAvL2R1bXAgZ2FyYmFnZSBldmVyeSAxMjAgZnJhbWVzIG9yIHdoYXRldmVyIHRoZSB1c2VyIHNldHMgVHdlZW5MaXRlLmF1dG9TbGVlcCB0b1xuXHRcdFx0XHRcdF9uZXh0R0NGcmFtZSA9IF90aWNrZXIuZnJhbWUgKyAocGFyc2VJbnQoVHdlZW5MaXRlLmF1dG9TbGVlcCwgMTApIHx8IDEyMCk7XG5cdFx0XHRcdFx0Zm9yIChwIGluIF90d2Vlbkxvb2t1cCkge1xuXHRcdFx0XHRcdFx0YSA9IF90d2Vlbkxvb2t1cFtwXS50d2VlbnM7XG5cdFx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFbaV0uX2djKSB7XG5cdFx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChhLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgX3R3ZWVuTG9va3VwW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2lmIHRoZXJlIGFyZSBubyBtb3JlIHR3ZWVucyBpbiB0aGUgcm9vdCB0aW1lbGluZXMsIG9yIGlmIHRoZXkncmUgYWxsIHBhdXNlZCwgbWFrZSB0aGUgX3RpbWVyIHNsZWVwIHRvIHJlZHVjZSBsb2FkIG9uIHRoZSBDUFUgc2xpZ2h0bHlcblx0XHRcdFx0XHRwID0gX3Jvb3RUaW1lbGluZS5fZmlyc3Q7XG5cdFx0XHRcdFx0aWYgKCFwIHx8IHAuX3BhdXNlZCkgaWYgKFR3ZWVuTGl0ZS5hdXRvU2xlZXAgJiYgIV9yb290RnJhbWVzVGltZWxpbmUuX2ZpcnN0ICYmIF90aWNrZXIuX2xpc3RlbmVycy50aWNrLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKHAgJiYgcC5fcGF1c2VkKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSBwLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCFwKSB7XG5cdFx0XHRcdFx0XHRcdF90aWNrZXIuc2xlZXAoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRfdGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIEFuaW1hdGlvbi5fdXBkYXRlUm9vdCk7XG5cblx0XHR2YXIgX3JlZ2lzdGVyID0gZnVuY3Rpb24odGFyZ2V0LCB0d2Vlbiwgc2NydWIpIHtcblx0XHRcdFx0dmFyIGlkID0gdGFyZ2V0Ll9nc1R3ZWVuSUQsIGEsIGk7XG5cdFx0XHRcdGlmICghX3R3ZWVuTG9va3VwW2lkIHx8ICh0YXJnZXQuX2dzVHdlZW5JRCA9IGlkID0gXCJ0XCIgKyAoX3R3ZWVuTG9va3VwTnVtKyspKV0pIHtcblx0XHRcdFx0XHRfdHdlZW5Mb29rdXBbaWRdID0ge3RhcmdldDp0YXJnZXQsIHR3ZWVuczpbXX07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0YSA9IF90d2Vlbkxvb2t1cFtpZF0udHdlZW5zO1xuXHRcdFx0XHRcdGFbKGkgPSBhLmxlbmd0aCldID0gdHdlZW47XG5cdFx0XHRcdFx0aWYgKHNjcnViKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFbaV0gPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIF90d2Vlbkxvb2t1cFtpZF0udHdlZW5zO1xuXHRcdFx0fSxcblx0XHRcdF9vbk92ZXJ3cml0ZSA9IGZ1bmN0aW9uKG92ZXJ3cml0dGVuVHdlZW4sIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkUHJvcHMpIHtcblx0XHRcdFx0dmFyIGZ1bmMgPSBvdmVyd3JpdHRlblR3ZWVuLnZhcnMub25PdmVyd3JpdGUsIHIxLCByMjtcblx0XHRcdFx0aWYgKGZ1bmMpIHtcblx0XHRcdFx0XHRyMSA9IGZ1bmMob3ZlcndyaXR0ZW5Ud2Vlbiwgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWRQcm9wcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuYyA9IFR3ZWVuTGl0ZS5vbk92ZXJ3cml0ZTtcblx0XHRcdFx0aWYgKGZ1bmMpIHtcblx0XHRcdFx0XHRyMiA9IGZ1bmMob3ZlcndyaXR0ZW5Ud2Vlbiwgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWRQcm9wcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIChyMSAhPT0gZmFsc2UgJiYgcjIgIT09IGZhbHNlKTtcblx0XHRcdH0sXG5cdFx0XHRfYXBwbHlPdmVyd3JpdGUgPSBmdW5jdGlvbih0YXJnZXQsIHR3ZWVuLCBwcm9wcywgbW9kZSwgc2libGluZ3MpIHtcblx0XHRcdFx0dmFyIGksIGNoYW5nZWQsIGN1clR3ZWVuLCBsO1xuXHRcdFx0XHRpZiAobW9kZSA9PT0gMSB8fCBtb2RlID49IDQpIHtcblx0XHRcdFx0XHRsID0gc2libGluZ3MubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmICgoY3VyVHdlZW4gPSBzaWJsaW5nc1tpXSkgIT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghY3VyVHdlZW4uX2djKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGN1clR3ZWVuLl9raWxsKG51bGwsIHRhcmdldCwgdHdlZW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobW9kZSA9PT0gNSkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9OT1RFOiBBZGQgMC4wMDAwMDAwMDAxIHRvIG92ZXJjb21lIGZsb2F0aW5nIHBvaW50IGVycm9ycyB0aGF0IGNhbiBjYXVzZSB0aGUgc3RhcnRUaW1lIHRvIGJlIFZFUlkgc2xpZ2h0bHkgb2ZmICh3aGVuIGEgdHdlZW4ncyB0aW1lKCkgaXMgc2V0IGZvciBleGFtcGxlKVxuXHRcdFx0XHR2YXIgc3RhcnRUaW1lID0gdHdlZW4uX3N0YXJ0VGltZSArIF90aW55TnVtLFxuXHRcdFx0XHRcdG92ZXJsYXBzID0gW10sXG5cdFx0XHRcdFx0b0NvdW50ID0gMCxcblx0XHRcdFx0XHR6ZXJvRHVyID0gKHR3ZWVuLl9kdXJhdGlvbiA9PT0gMCksXG5cdFx0XHRcdFx0Z2xvYmFsU3RhcnQ7XG5cdFx0XHRcdGkgPSBzaWJsaW5ncy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmICgoY3VyVHdlZW4gPSBzaWJsaW5nc1tpXSkgPT09IHR3ZWVuIHx8IGN1clR3ZWVuLl9nYyB8fCBjdXJUd2Vlbi5fcGF1c2VkKSB7XG5cdFx0XHRcdFx0XHQvL2lnbm9yZVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY3VyVHdlZW4uX3RpbWVsaW5lICE9PSB0d2Vlbi5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdGdsb2JhbFN0YXJ0ID0gZ2xvYmFsU3RhcnQgfHwgX2NoZWNrT3ZlcmxhcCh0d2VlbiwgMCwgemVyb0R1cik7XG5cdFx0XHRcdFx0XHRpZiAoX2NoZWNrT3ZlcmxhcChjdXJUd2VlbiwgZ2xvYmFsU3RhcnQsIHplcm9EdXIpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJsYXBzW29Db3VudCsrXSA9IGN1clR3ZWVuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY3VyVHdlZW4uX3N0YXJ0VGltZSA8PSBzdGFydFRpbWUpIGlmIChjdXJUd2Vlbi5fc3RhcnRUaW1lICsgY3VyVHdlZW4udG90YWxEdXJhdGlvbigpIC8gY3VyVHdlZW4uX3RpbWVTY2FsZSA+IHN0YXJ0VGltZSkgaWYgKCEoKHplcm9EdXIgfHwgIWN1clR3ZWVuLl9pbml0dGVkKSAmJiBzdGFydFRpbWUgLSBjdXJUd2Vlbi5fc3RhcnRUaW1lIDw9IDAuMDAwMDAwMDAwMikpIHtcblx0XHRcdFx0XHRcdG92ZXJsYXBzW29Db3VudCsrXSA9IGN1clR3ZWVuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgPSBvQ291bnQ7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGN1clR3ZWVuID0gb3ZlcmxhcHNbaV07XG5cdFx0XHRcdFx0aWYgKG1vZGUgPT09IDIpIGlmIChjdXJUd2Vlbi5fa2lsbChwcm9wcywgdGFyZ2V0LCB0d2VlbikpIHtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobW9kZSAhPT0gMiB8fCAoIWN1clR3ZWVuLl9maXJzdFBUICYmIGN1clR3ZWVuLl9pbml0dGVkKSkge1xuXHRcdFx0XHRcdFx0aWYgKG1vZGUgIT09IDIgJiYgIV9vbk92ZXJ3cml0ZShjdXJUd2VlbiwgdHdlZW4pKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGN1clR3ZWVuLl9lbmFibGVkKGZhbHNlLCBmYWxzZSkpIHsgLy9pZiBhbGwgcHJvcGVydHkgdHdlZW5zIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiwga2lsbCB0aGUgdHdlZW4uXG5cdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdH0sXG5cdFx0XHRfY2hlY2tPdmVybGFwID0gZnVuY3Rpb24odHdlZW4sIHJlZmVyZW5jZSwgemVyb0R1cikge1xuXHRcdFx0XHR2YXIgdGwgPSB0d2Vlbi5fdGltZWxpbmUsXG5cdFx0XHRcdFx0dHMgPSB0bC5fdGltZVNjYWxlLFxuXHRcdFx0XHRcdHQgPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dCArPSB0bC5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdHRzICo9IHRsLl90aW1lU2NhbGU7XG5cdFx0XHRcdFx0aWYgKHRsLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiAtMTAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0IC89IHRzO1xuXHRcdFx0XHRyZXR1cm4gKHQgPiByZWZlcmVuY2UpID8gdCAtIHJlZmVyZW5jZSA6ICgoemVyb0R1ciAmJiB0ID09PSByZWZlcmVuY2UpIHx8ICghdHdlZW4uX2luaXR0ZWQgJiYgdCAtIHJlZmVyZW5jZSA8IDIgKiBfdGlueU51bSkpID8gX3RpbnlOdW0gOiAoKHQgKz0gdHdlZW4udG90YWxEdXJhdGlvbigpIC8gdHdlZW4uX3RpbWVTY2FsZSAvIHRzKSA+IHJlZmVyZW5jZSArIF90aW55TnVtKSA/IDAgOiB0IC0gcmVmZXJlbmNlIC0gX3RpbnlOdW07XG5cdFx0XHR9O1xuXG5cbi8vLS0tLSBUd2VlbkxpdGUgaW5zdGFuY2UgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5faW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHYgPSB0aGlzLnZhcnMsXG5cdFx0XHRcdG9wID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyxcblx0XHRcdFx0ZHVyID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdGltbWVkaWF0ZSA9ICEhdi5pbW1lZGlhdGVSZW5kZXIsXG5cdFx0XHRcdGVhc2UgPSB2LmVhc2UsXG5cdFx0XHRcdGksIGluaXRQbHVnaW5zLCBwdCwgcCwgc3RhcnRWYXJzO1xuXHRcdFx0aWYgKHYuc3RhcnRBdCkge1xuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTsgLy9pZiB3ZSd2ZSBydW4gYSBzdGFydEF0IHByZXZpb3VzbHkgKHdoZW4gdGhlIHR3ZWVuIGluc3RhbnRpYXRlZCksIHdlIHNob3VsZCByZXZlcnQgaXQgc28gdGhhdCB0aGUgdmFsdWVzIHJlLWluc3RhbnRpYXRlIGNvcnJlY3RseSBwYXJ0aWN1bGFybHkgZm9yIHJlbGF0aXZlIHR3ZWVucy4gV2l0aG91dCB0aGlzLCBhIFR3ZWVuTGl0ZS5mcm9tVG8ob2JqLCAxLCB7eDpcIis9MTAwXCJ9LCB7eDpcIi09MTAwXCJ9KSwgZm9yIGV4YW1wbGUsIHdvdWxkIGFjdHVhbGx5IGp1bXAgdG8gKz0yMDAgYmVjYXVzZSB0aGUgc3RhcnRBdCB3b3VsZCBydW4gdHdpY2UsIGRvdWJsaW5nIHRoZSByZWxhdGl2ZSBjaGFuZ2UuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5raWxsKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhcnRWYXJzID0ge307XG5cdFx0XHRcdGZvciAocCBpbiB2LnN0YXJ0QXQpIHsgLy9jb3B5IHRoZSBwcm9wZXJ0aWVzL3ZhbHVlcyBpbnRvIGEgbmV3IG9iamVjdCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlIHZhciB0byA9IHt4OjB9LCBmcm9tID0ge3g6NTAwfTsgdGltZWxpbmUuZnJvbVRvKGUsIDEsIGZyb20sIHRvKS5mcm9tVG8oZSwgMSwgdG8sIGZyb20pO1xuXHRcdFx0XHRcdHN0YXJ0VmFyc1twXSA9IHYuc3RhcnRBdFtwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydFZhcnMub3ZlcndyaXRlID0gZmFsc2U7XG5cdFx0XHRcdHN0YXJ0VmFycy5pbW1lZGlhdGVSZW5kZXIgPSB0cnVlO1xuXHRcdFx0XHRzdGFydFZhcnMubGF6eSA9IChpbW1lZGlhdGUgJiYgdi5sYXp5ICE9PSBmYWxzZSk7XG5cdFx0XHRcdHN0YXJ0VmFycy5zdGFydEF0ID0gc3RhcnRWYXJzLmRlbGF5ID0gbnVsbDsgLy9ubyBuZXN0aW5nIG9mIHN0YXJ0QXQgb2JqZWN0cyBhbGxvd2VkIChvdGhlcndpc2UgaXQgY291bGQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCkuXG5cdFx0XHRcdHRoaXMuX3N0YXJ0QXQgPSBUd2VlbkxpdGUudG8odGhpcy50YXJnZXQsIDAsIHN0YXJ0VmFycyk7XG5cdFx0XHRcdGlmIChpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQgPSBudWxsOyAvL3R3ZWVucyB0aGF0IHJlbmRlciBpbW1lZGlhdGVseSAobGlrZSBtb3N0IGZyb20oKSBhbmQgZnJvbVRvKCkgdHdlZW5zKSBzaG91bGRuJ3QgcmV2ZXJ0IHdoZW4gdGhlaXIgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSBzdGFydFRpbWUgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgY291bGQgaGF2ZSBoYXBwZW5lZCBhbnl0aW1lIGFuZCBpdCBzaG91bGRuJ3QgYmUgZGlyZWN0bHkgY29ycmVsYXRlZCB0byB0aGlzIHR3ZWVuJ3Mgc3RhcnRUaW1lLiBJbWFnaW5lIHNldHRpbmcgdXAgYSBjb21wbGV4IGFuaW1hdGlvbiB3aGVyZSB0aGUgYmVnaW5uaW5nIHN0YXRlcyBvZiB2YXJpb3VzIG9iamVjdHMgYXJlIHJlbmRlcmVkIGltbWVkaWF0ZWx5IGJ1dCB0aGUgdHdlZW4gZG9lc24ndCBoYXBwZW4gZm9yIHF1aXRlIHNvbWUgdGltZSAtIGlmIHdlIHJldmVydCB0byB0aGUgc3RhcnRpbmcgdmFsdWVzIGFzIHNvb24gYXMgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgdHdlZW4ncyBzdGFydFRpbWUsIGl0IHdpbGwgdGhyb3cgdGhpbmdzIG9mZiB2aXN1YWxseS4gUmV2ZXJzaW9uIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBUaW1lbGluZUxpdGUvTWF4IGluc3RhbmNlcyB3aGVyZSBpbW1lZGlhdGVSZW5kZXIgd2FzIGZhbHNlICh3aGljaCBpcyB0aGUgZGVmYXVsdCBpbiB0aGUgY29udmVuaWVuY2UgbWV0aG9kcyBsaWtlIGZyb20oKSkuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChkdXIgIT09IDApIHtcblx0XHRcdFx0XHRcdHJldHVybjsgLy93ZSBza2lwIGluaXRpYWxpemF0aW9uIGhlcmUgc28gdGhhdCBvdmVyd3JpdGluZyBkb2Vzbid0IG9jY3VyIHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMuIE90aGVyd2lzZSwgaWYgeW91IGNyZWF0ZSBzZXZlcmFsIGltbWVkaWF0ZVJlbmRlcjp0cnVlIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQvcHJvcGVydGllcyB0byBkcm9wIGludG8gYSBUaW1lbGluZUxpdGUgb3IgVGltZWxpbmVNYXgsIHRoZSBsYXN0IG9uZSBjcmVhdGVkIHdvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lcyBiZWNhdXNlIHRoZXkgZGlkbid0IGdldCBwbGFjZWQgaW50byB0aGUgdGltZWxpbmUgeWV0IGJlZm9yZSB0aGUgZmlyc3QgcmVuZGVyIG9jY3VycyBhbmQga2lja3MgaW4gb3ZlcndyaXRpbmcuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHYucnVuQmFja3dhcmRzICYmIGR1ciAhPT0gMCkge1xuXHRcdFx0XHQvL2Zyb20oKSB0d2VlbnMgbXVzdCBiZSBoYW5kbGVkIHVuaXF1ZWx5OiB0aGVpciBiZWdpbm5pbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQgYnV0IHdlIGRvbid0IHdhbnQgb3ZlcndyaXRpbmcgdG8gb2NjdXIgeWV0ICh3aGVuIHRpbWUgaXMgc3RpbGwgMCkuIFdhaXQgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucyBiZWZvcmUgZG9pbmcgYWxsIHRoZSByb3V0aW5lcyBsaWtlIG92ZXJ3cml0aW5nLiBBdCB0aGF0IHRpbWUsIHdlIHNob3VsZCByZW5kZXIgYXQgdGhlIEVORCBvZiB0aGUgdHdlZW4gdG8gZW5zdXJlIHRoYXQgdGhpbmdzIGluaXRpYWxpemUgY29ycmVjdGx5IChyZW1lbWJlciwgZnJvbSgpIHR3ZWVucyBnbyBiYWNrd2FyZHMpXG5cdFx0XHRcdGlmICh0aGlzLl9zdGFydEF0KSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpO1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQua2lsbCgpO1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lICE9PSAwKSB7IC8vaW4gcmFyZSBjYXNlcyAobGlrZSBpZiBhIGZyb20oKSB0d2VlbiBydW5zIGFuZCB0aGVuIGlzIGludmFsaWRhdGUoKS1lZCksIGltbWVkaWF0ZVJlbmRlciBjb3VsZCBiZSB0cnVlIGJ1dCB0aGUgaW5pdGlhbCBmb3JjZWQtcmVuZGVyIGdldHMgc2tpcHBlZCwgc28gdGhlcmUncyBubyBuZWVkIHRvIGZvcmNlIHRoZSByZW5kZXIgaW4gdGhpcyBjb250ZXh0IHdoZW4gdGhlIF90aW1lIGlzIGdyZWF0ZXIgdGhhbiAwXG5cdFx0XHRcdFx0XHRpbW1lZGlhdGUgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSB7fTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gdikgeyAvL2NvcHkgcHJvcHMgaW50byBhIG5ldyBvYmplY3QgYW5kIHNraXAgYW55IHJlc2VydmVkIHByb3BzLCBvdGhlcndpc2Ugb25Db21wbGV0ZSBvciBvblVwZGF0ZSBvciBvblN0YXJ0IGNvdWxkIGZpcmUuIFdlIHNob3VsZCwgaG93ZXZlciwgcGVybWl0IGF1dG9DU1MgdG8gZ28gdGhyb3VnaC5cblx0XHRcdFx0XHRcdGlmICghX3Jlc2VydmVkUHJvcHNbcF0gfHwgcCA9PT0gXCJhdXRvQ1NTXCIpIHtcblx0XHRcdFx0XHRcdFx0cHRbcF0gPSB2W3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdC5vdmVyd3JpdGUgPSAwO1xuXHRcdFx0XHRcdHB0LmRhdGEgPSBcImlzRnJvbVN0YXJ0XCI7IC8vd2UgdGFnIHRoZSB0d2VlbiB3aXRoIGFzIFwiaXNGcm9tU3RhcnRcIiBzbyB0aGF0IGlmIFtpbnNpZGUgYSBwbHVnaW5dIHdlIG5lZWQgdG8gb25seSBkbyBzb21ldGhpbmcgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4sIHdlIGhhdmUgYSB3YXkgb2YgaWRlbnRpZnlpbmcgdGhpcyB0d2VlbiBhcyBtZXJlbHkgdGhlIG9uZSB0aGF0J3Mgc2V0dGluZyB0aGUgYmVnaW5uaW5nIHZhbHVlcyBmb3IgYSBcImZyb20oKVwiIHR3ZWVuLiBGb3IgZXhhbXBsZSwgY2xlYXJQcm9wcyBpbiBDU1NQbHVnaW4gc2hvdWxkIG9ubHkgZ2V0IGFwcGxpZWQgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4gYW5kIHdpdGhvdXQgdGhpcyB0YWcsIGZyb20oLi4ue2hlaWdodDoxMDAsIGNsZWFyUHJvcHM6XCJoZWlnaHRcIiwgZGVsYXk6MX0pIHdvdWxkIHdpcGUgdGhlIGhlaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiBhbmQgYWZ0ZXIgMSBzZWNvbmQsIGl0J2Qga2ljayBiYWNrIGluLlxuXHRcdFx0XHRcdHB0LmxhenkgPSAoaW1tZWRpYXRlICYmIHYubGF6eSAhPT0gZmFsc2UpO1xuXHRcdFx0XHRcdHB0LmltbWVkaWF0ZVJlbmRlciA9IGltbWVkaWF0ZTsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyByZW5kZXIgaW1tZWRpYXRlbHkgYnkgZGVmYXVsdCwgYnV0IGlmIHdlJ3JlIG5vdCBzcGVjaWZpY2FsbHkgaW5zdHJ1Y3RlZCB0byByZW5kZXIgdGhpcyB0d2VlbiBpbW1lZGlhdGVseSwgd2Ugc2hvdWxkIHNraXAgdGhpcyBhbmQgbWVyZWx5IF9pbml0KCkgdG8gcmVjb3JkIHRoZSBzdGFydGluZyB2YWx1ZXMgKHJlbmRlcmluZyB0aGVtIGltbWVkaWF0ZWx5IHdvdWxkIHB1c2ggdGhlbSB0byBjb21wbGV0aW9uIHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoYXQgY2FzZSAtIHdlJ2QgaGF2ZSB0byByZW5kZXIoLTEpIGltbWVkaWF0ZWx5IGFmdGVyKVxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQgPSBUd2VlbkxpdGUudG8odGhpcy50YXJnZXQsIDAsIHB0KTtcblx0XHRcdFx0XHRpZiAoIWltbWVkaWF0ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5faW5pdCgpOyAvL2Vuc3VyZXMgdGhhdCB0aGUgaW5pdGlhbCB2YWx1ZXMgYXJlIHJlY29yZGVkXG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0Ll9lbmFibGVkKGZhbHNlKTsgLy9ubyBuZWVkIHRvIGhhdmUgdGhlIHR3ZWVuIHJlbmRlciBvbiB0aGUgbmV4dCBjeWNsZS4gRGlzYWJsZSBpdCBiZWNhdXNlIHdlJ2xsIGFsd2F5cyBtYW51YWxseSBjb250cm9sIHRoZSByZW5kZXJzIG9mIHRoZSBfc3RhcnRBdCB0d2Vlbi5cblx0XHRcdFx0XHRcdGlmICh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZWFzZSA9IGVhc2UgPSAoIWVhc2UpID8gVHdlZW5MaXRlLmRlZmF1bHRFYXNlIDogKGVhc2UgaW5zdGFuY2VvZiBFYXNlKSA/IGVhc2UgOiAodHlwZW9mKGVhc2UpID09PSBcImZ1bmN0aW9uXCIpID8gbmV3IEVhc2UoZWFzZSwgdi5lYXNlUGFyYW1zKSA6IF9lYXNlTWFwW2Vhc2VdIHx8IFR3ZWVuTGl0ZS5kZWZhdWx0RWFzZTtcblx0XHRcdGlmICh2LmVhc2VQYXJhbXMgaW5zdGFuY2VvZiBBcnJheSAmJiBlYXNlLmNvbmZpZykge1xuXHRcdFx0XHR0aGlzLl9lYXNlID0gZWFzZS5jb25maWcuYXBwbHkoZWFzZSwgdi5lYXNlUGFyYW1zKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2Vhc2VUeXBlID0gdGhpcy5fZWFzZS5fdHlwZTtcblx0XHRcdHRoaXMuX2Vhc2VQb3dlciA9IHRoaXMuX2Vhc2UuX3Bvd2VyO1xuXHRcdFx0dGhpcy5fZmlyc3RQVCA9IG51bGw7XG5cblx0XHRcdGlmICh0aGlzLl90YXJnZXRzKSB7XG5cdFx0XHRcdGkgPSB0aGlzLl90YXJnZXRzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLl9pbml0UHJvcHMoIHRoaXMuX3RhcmdldHNbaV0sICh0aGlzLl9wcm9wTG9va3VwW2ldID0ge30pLCB0aGlzLl9zaWJsaW5nc1tpXSwgKG9wID8gb3BbaV0gOiBudWxsKSkgKSB7XG5cdFx0XHRcdFx0XHRpbml0UGx1Z2lucyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbml0UGx1Z2lucyA9IHRoaXMuX2luaXRQcm9wcyh0aGlzLnRhcmdldCwgdGhpcy5fcHJvcExvb2t1cCwgdGhpcy5fc2libGluZ3MsIG9wKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGluaXRQbHVnaW5zKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudChcIl9vbkluaXRBbGxQcm9wc1wiLCB0aGlzKTsgLy9yZW9yZGVycyB0aGUgYXJyYXkgaW4gb3JkZXIgb2YgcHJpb3JpdHkuIFVzZXMgYSBzdGF0aWMgVHdlZW5QbHVnaW4gbWV0aG9kIGluIG9yZGVyIHRvIG1pbmltaXplIGZpbGUgc2l6ZSBpbiBUd2VlbkxpdGVcblx0XHRcdH1cblx0XHRcdGlmIChvcCkgaWYgKCF0aGlzLl9maXJzdFBUKSBpZiAodHlwZW9mKHRoaXMudGFyZ2V0KSAhPT0gXCJmdW5jdGlvblwiKSB7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuLCBraWxsIHRoZSB0d2Vlbi4gSWYgdGhlIHRhcmdldCBpcyBhIGZ1bmN0aW9uLCBpdCdzIHByb2JhYmx5IGEgZGVsYXllZENhbGwgc28gbGV0IGl0IGxpdmUuXG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmICh2LnJ1bkJhY2t3YXJkcykge1xuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdHB0LnMgKz0gcHQuYztcblx0XHRcdFx0XHRwdC5jID0gLXB0LmM7XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fb25VcGRhdGUgPSB2Lm9uVXBkYXRlO1xuXHRcdFx0dGhpcy5faW5pdHRlZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdHAuX2luaXRQcm9wcyA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMpIHtcblx0XHRcdHZhciBwLCBpLCBpbml0UGx1Z2lucywgcGx1Z2luLCBwdCwgdjtcblx0XHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChfbGF6eUxvb2t1cFt0YXJnZXQuX2dzVHdlZW5JRF0pIHtcblx0XHRcdFx0X2xhenlSZW5kZXIoKTsgLy9pZiBvdGhlciB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0IGhhdmUgcmVjZW50bHkgaW5pdHRlZCBidXQgaGF2ZW4ndCByZW5kZXJlZCB5ZXQsIHdlJ3ZlIGdvdCB0byBmb3JjZSB0aGUgcmVuZGVyIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmUgY29ycmVjdCAoaW1hZ2luZSBwb3B1bGF0aW5nIGEgdGltZWxpbmUgd2l0aCBhIGJ1bmNoIG9mIHNlcXVlbnRpYWwgdHdlZW5zIGFuZCB0aGVuIGp1bXBpbmcgdG8gdGhlIGVuZClcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLnZhcnMuY3NzKSBpZiAodGFyZ2V0LnN0eWxlKSBpZiAodGFyZ2V0ICE9PSB3aW5kb3cgJiYgdGFyZ2V0Lm5vZGVUeXBlKSBpZiAoX3BsdWdpbnMuY3NzKSBpZiAodGhpcy52YXJzLmF1dG9DU1MgIT09IGZhbHNlKSB7IC8vaXQncyBzbyBjb21tb24gdG8gdXNlIFR3ZWVuTGl0ZS9NYXggdG8gYW5pbWF0ZSB0aGUgY3NzIG9mIERPTSBlbGVtZW50cywgd2UgYXNzdW1lIHRoYXQgaWYgdGhlIHRhcmdldCBpcyBhIERPTSBlbGVtZW50LCB0aGF0J3Mgd2hhdCBpcyBpbnRlbmRlZCAoYSBjb252ZW5pZW5jZSBzbyB0aGF0IHVzZXJzIGRvbid0IGhhdmUgdG8gd3JhcCB0aGluZ3MgaW4gY3NzOnt9LCBhbHRob3VnaCB3ZSBzdGlsbCByZWNvbW1lbmQgaXQgZm9yIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGJvb3N0IGFuZCBiZXR0ZXIgc3BlY2lmaWNpdHkpLiBOb3RlOiB3ZSBjYW5ub3QgY2hlY2sgXCJub2RlVHlwZVwiIG9uIHRoZSB3aW5kb3cgaW5zaWRlIGFuIGlmcmFtZS5cblx0XHRcdFx0X2F1dG9DU1ModGhpcy52YXJzLCB0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChwIGluIHRoaXMudmFycykge1xuXHRcdFx0XHR2ID0gdGhpcy52YXJzW3BdO1xuXHRcdFx0XHRpZiAoX3Jlc2VydmVkUHJvcHNbcF0pIHtcblx0XHRcdFx0XHRpZiAodikgaWYgKCh2IGluc3RhbmNlb2YgQXJyYXkpIHx8ICh2LnB1c2ggJiYgX2lzQXJyYXkodikpKSBpZiAodi5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnZhcnNbcF0gPSB2ID0gdGhpcy5fc3dhcFNlbGZJblBhcmFtcyh2LCB0aGlzKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gbmV3IF9wbHVnaW5zW3BdKCkpLl9vbkluaXRUd2Vlbih0YXJnZXQsIHRoaXMudmFyc1twXSwgdGhpcykpIHtcblxuXHRcdFx0XHRcdC8vdCAtIHRhcmdldCBcdFx0W29iamVjdF1cblx0XHRcdFx0XHQvL3AgLSBwcm9wZXJ0eSBcdFx0W3N0cmluZ11cblx0XHRcdFx0XHQvL3MgLSBzdGFydFx0XHRcdFtudW1iZXJdXG5cdFx0XHRcdFx0Ly9jIC0gY2hhbmdlXHRcdFtudW1iZXJdXG5cdFx0XHRcdFx0Ly9mIC0gaXNGdW5jdGlvblx0W2Jvb2xlYW5dXG5cdFx0XHRcdFx0Ly9uIC0gbmFtZVx0XHRcdFtzdHJpbmddXG5cdFx0XHRcdFx0Ly9wZyAtIGlzUGx1Z2luIFx0W2Jvb2xlYW5dXG5cdFx0XHRcdFx0Ly9wciAtIHByaW9yaXR5XHRcdFtudW1iZXJdXG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0ID0ge19uZXh0OnRoaXMuX2ZpcnN0UFQsIHQ6cGx1Z2luLCBwOlwic2V0UmF0aW9cIiwgczowLCBjOjEsIGY6MSwgbjpwLCBwZzoxLCBwcjpwbHVnaW4uX3ByaW9yaXR5fTtcblx0XHRcdFx0XHRpID0gcGx1Z2luLl9vdmVyd3JpdGVQcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRwcm9wTG9va3VwW3BsdWdpbi5fb3ZlcndyaXRlUHJvcHNbaV1dID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBsdWdpbi5fcHJpb3JpdHkgfHwgcGx1Z2luLl9vbkluaXRBbGxQcm9wcykge1xuXHRcdFx0XHRcdFx0aW5pdFBsdWdpbnMgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGx1Z2luLl9vbkRpc2FibGUgfHwgcGx1Z2luLl9vbkVuYWJsZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwcm9wTG9va3VwW3BdID0gX2FkZFByb3BUd2Vlbi5jYWxsKHRoaXMsIHRhcmdldCwgcCwgXCJnZXRcIiwgdiwgcCwgMCwgbnVsbCwgdGhpcy52YXJzLnN0cmluZ0ZpbHRlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG92ZXJ3cml0dGVuUHJvcHMpIGlmICh0aGlzLl9raWxsKG92ZXJ3cml0dGVuUHJvcHMsIHRhcmdldCkpIHsgLy9hbm90aGVyIHR3ZWVuIG1heSBoYXZlIHRyaWVkIHRvIG92ZXJ3cml0ZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHdlZW4gYmVmb3JlIGluaXQoKSB3YXMgY2FsbGVkIChsaWtlIGlmIHR3byB0d2VlbnMgc3RhcnQgYXQgdGhlIHNhbWUgdGltZSwgdGhlIG9uZSBjcmVhdGVkIHNlY29uZCB3aWxsIHJ1biBmaXJzdClcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2luaXRQcm9wcyh0YXJnZXQsIHByb3BMb29rdXAsIHNpYmxpbmdzLCBvdmVyd3JpdHRlblByb3BzKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9vdmVyd3JpdGUgPiAxKSBpZiAodGhpcy5fZmlyc3RQVCkgaWYgKHNpYmxpbmdzLmxlbmd0aCA+IDEpIGlmIChfYXBwbHlPdmVyd3JpdGUodGFyZ2V0LCB0aGlzLCBwcm9wTG9va3VwLCB0aGlzLl9vdmVyd3JpdGUsIHNpYmxpbmdzKSkge1xuXHRcdFx0XHR0aGlzLl9raWxsKHByb3BMb29rdXAsIHRhcmdldCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9pbml0UHJvcHModGFyZ2V0LCBwcm9wTG9va3VwLCBzaWJsaW5ncywgb3ZlcndyaXR0ZW5Qcm9wcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZmlyc3RQVCkgaWYgKCh0aGlzLnZhcnMubGF6eSAhPT0gZmFsc2UgJiYgdGhpcy5fZHVyYXRpb24pIHx8ICh0aGlzLnZhcnMubGF6eSAmJiAhdGhpcy5fZHVyYXRpb24pKSB7IC8vemVybyBkdXJhdGlvbiB0d2VlbnMgZG9uJ3QgbGF6eSByZW5kZXIgYnkgZGVmYXVsdDsgZXZlcnl0aGluZyBlbHNlIGRvZXMuXG5cdFx0XHRcdF9sYXp5TG9va3VwW3RhcmdldC5fZ3NUd2VlbklEXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5pdFBsdWdpbnM7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHR2YXIgcHJldlRpbWUgPSB0aGlzLl90aW1lLFxuXHRcdFx0XHRkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRwcmV2UmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0aXNDb21wbGV0ZSwgY2FsbGJhY2ssIHB0LCByYXdQcmV2VGltZTtcblx0XHRcdGlmICh0aW1lID49IGR1cmF0aW9uIC0gMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cy5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IGR1cmF0aW9uO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMSkgOiAxO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkICkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0Zm9yY2UgPSAoZm9yY2UgfHwgdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKTsgLy9vdGhlcndpc2UsIGlmIHRoZSBhbmltYXRpb24gaXMgdW5wYXVzZWQvYWN0aXZhdGVkIGFmdGVyIGl0J3MgYWxyZWFkeSBmaW5pc2hlZCwgaXQgZG9lc24ndCBnZXQgcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgdGltZWxpbmUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRpZiAodGhpcy5fc3RhcnRUaW1lID09PSB0aGlzLl90aW1lbGluZS5fZHVyYXRpb24pIHsgLy9pZiBhIHplcm8tZHVyYXRpb24gdHdlZW4gaXMgYXQgdGhlIFZFUlkgZW5kIG9mIGEgdGltZWxpbmUgYW5kIHRoYXQgdGltZWxpbmUgcmVuZGVycyBhdCBpdHMgZW5kLCBpdCB3aWxsIHR5cGljYWxseSBhZGQgYSB0aW55IGJpdCBvZiBjdXNoaW9uIHRvIHRoZSByZW5kZXIgdGltZSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9ycyBmcm9tIGdldHRpbmcgaW4gdGhlIHdheSBvZiB0d2VlbnMgcmVuZGVyaW5nIHRoZWlyIFZFUlkgZW5kLiBJZiB3ZSB0aGVuIHJldmVyc2UoKSB0aGF0IHRpbWVsaW5lLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiB3aWxsIHRyaWdnZXIgaXRzIG9uUmV2ZXJzZUNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5IHRoZSBwbGF5aGVhZCBkaWRuJ3QgcGFzcyBvdmVyIGl0IGFnYWluLiBJdCdzIGEgdmVyeSBzcGVjaWZpYyBlZGdlIGNhc2Ugd2UgbXVzdCBhY2NvbW1vZGF0ZS5cblx0XHRcdFx0XHRcdHRpbWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lIDwgMCB8fCAodGltZSA8PSAwICYmIHRpbWUgPj0gLTAuMDAwMDAwMSkgfHwgKHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgdGhpcy5kYXRhICE9PSBcImlzUGF1c2VcIikpIGlmIChwcmV2UmF3UHJldlRpbWUgIT09IHRpbWUpIHsgLy9ub3RlOiB3aGVuIHRoaXMuZGF0YSBpcyBcImlzUGF1c2VcIiwgaXQncyBhIGNhbGxiYWNrIGFkZGVkIGJ5IGFkZFBhdXNlKCkgb24gYSB0aW1lbGluZSB0aGF0IHdlIHNob3VsZCBub3QgYmUgdHJpZ2dlcmVkIHdoZW4gTEVBVklORyBpdHMgZXhhY3Qgc3RhcnQgdGltZS4gSW4gb3RoZXIgd29yZHMsIHRsLmFkZFBhdXNlKDEpLnBsYXkoMSkgc2hvdWxkbid0IHBhdXNlLlxuXHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKGR1cmF0aW9uID09PSAwICYmIHByZXZSYXdQcmV2VGltZSA+IDApKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID49IDAgJiYgIShwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHRoaXMuZGF0YSA9PT0gXCJpc1BhdXNlXCIpKSB7XG5cdFx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7IC8vaWYgd2UgcmVuZGVyIHRoZSB2ZXJ5IGJlZ2lubmluZyAodGltZSA9PSAwKSBvZiBhIGZyb21UbygpLCB3ZSBtdXN0IGZvcmNlIHRoZSByZW5kZXIgKG5vcm1hbCB0d2VlbnMgd291bGRuJ3QgbmVlZCB0byByZW5kZXIgYXQgYSB0aW1lIG9mIDAgd2hlbiB0aGUgcHJldlRpbWUgd2FzIGFsc28gMCkuIFRoaXMgaXMgYWxzbyBtYW5kYXRvcnkgdG8gbWFrZSBzdXJlIG92ZXJ3cml0aW5nIGtpY2tzIGluIGltbWVkaWF0ZWx5LlxuXHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRpbWU7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2Vhc2VUeXBlKSB7XG5cdFx0XHRcdFx0dmFyIHIgPSB0aW1lIC8gZHVyYXRpb24sIHR5cGUgPSB0aGlzLl9lYXNlVHlwZSwgcG93ID0gdGhpcy5fZWFzZVBvd2VyO1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxIHx8ICh0eXBlID09PSAzICYmIHIgPj0gMC41KSkge1xuXHRcdFx0XHRcdFx0ciA9IDEgLSByO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocG93ID09PSAxKSB7XG5cdFx0XHRcdFx0XHRyICo9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDIpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSA0KSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogciAqIHI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGltZSAvIGR1cmF0aW9uIDwgMC41KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gciAvIDI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gKHIgLyAyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl90aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCB8fCB0aGlzLl9nYykgeyAvL2ltbWVkaWF0ZVJlbmRlciB0d2VlbnMgdHlwaWNhbGx5IHdvbid0IGluaXRpYWxpemUgdW50aWwgdGhlIHBsYXloZWFkIGFkdmFuY2VzIChfdGltZSBpcyBncmVhdGVyIHRoYW4gMCkgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgb3ZlcndyaXRpbmcgb2NjdXJzIHByb3Blcmx5LiBBbHNvLCBpZiBhbGwgb2YgdGhlIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuICh3aGljaCB3b3VsZCBjYXVzZSBfZ2MgdG8gYmUgdHJ1ZSwgYXMgc2V0IGluIF9pbml0KCkpLCB3ZSBzaG91bGRuJ3QgY29udGludWUgb3RoZXJ3aXNlIGFuIG9uU3RhcnQgY2FsbGJhY2sgY291bGQgYmUgY2FsbGVkIGZvciBleGFtcGxlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmICghZm9yY2UgJiYgdGhpcy5fZmlyc3RQVCAmJiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IHByZXZUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcHJldlJhd1ByZXZUaW1lO1xuXHRcdFx0XHRcdF9sYXp5VHdlZW5zLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0dGhpcy5fbGF6eSA9IFt0aW1lLCBzdXBwcmVzc0V2ZW50c107XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vX2Vhc2UgaXMgaW5pdGlhbGx5IHNldCB0byBkZWZhdWx0RWFzZSwgc28gbm93IHRoYXQgaW5pdCgpIGhhcyBydW4sIF9lYXNlIGlzIHNldCBwcm9wZXJseSBhbmQgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgcmF0aW8uIE92ZXJhbGwgdGhpcyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjb25kaXRpb25hbCBsb2dpYyBlYXJsaWVyIGluIHRoZSBtZXRob2QgdG8gYXZvaWQgaGF2aW5nIHRvIHNldCByYXRpbyB0d2ljZSBiZWNhdXNlIHdlIG9ubHkgaW5pdCgpIG9uY2UgYnV0IHJlbmRlclRpbWUoKSBnZXRzIGNhbGxlZCBWRVJZIGZyZXF1ZW50bHkuXG5cdFx0XHRcdGlmICh0aGlzLl90aW1lICYmICFpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc0NvbXBsZXRlICYmIHRoaXMuX2Vhc2UuX2NhbGNFbmQpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbygodGhpcy5fdGltZSA9PT0gMCkgPyAwIDogMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9sYXp5ICE9PSBmYWxzZSkgeyAvL2luIGNhc2UgYSBsYXp5IHJlbmRlciBpcyBwZW5kaW5nLCB3ZSBzaG91bGQgZmx1c2ggaXQgYmVjYXVzZSB0aGUgbmV3IHJlbmRlciBpcyBvY2N1cnJpbmcgbm93IChpbWFnaW5lIGEgbGF6eSB0d2VlbiBpbnN0YW50aWF0aW5nIGFuZCB0aGVuIGltbWVkaWF0ZWx5IHRoZSB1c2VyIGNhbGxzIHR3ZWVuLnNlZWsodHdlZW4uZHVyYXRpb24oKSksIHNraXBwaW5nIHRvIHRoZSBlbmQgLSB0aGUgZW5kIHJlbmRlciB3b3VsZCBiZSBmb3JjZWQsIGFuZCB0aGVuIGlmIHdlIGRpZG4ndCBmbHVzaCB0aGUgbGF6eSByZW5kZXIsIGl0J2QgZmlyZSBBRlRFUiB0aGUgc2VlaygpLCByZW5kZXJpbmcgaXQgYXQgdGhlIHdyb25nIHRpbWUuXG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90aW1lICE9PSBwcmV2VGltZSAmJiB0aW1lID49IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgIC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGEgdHdlZW4gKGFzIG9wcG9zZWQgdG8gdGhlIHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIHRoZSB0aW1lbGluZSBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0d2VlbiBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZS5cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VGltZSA9PT0gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJfZHVtbXlHU1wiOyAvL2lmIG5vIGNhbGxiYWNrIGlzIGRlZmluZWQsIHVzZSBhIGR1bW15IHZhbHVlIGp1c3Qgc28gdGhhdCB0aGUgY29uZGl0aW9uIGF0IHRoZSBlbmQgZXZhbHVhdGVzIGFzIHRydWUgYmVjYXVzZSBfc3RhcnRBdCBzaG91bGQgcmVuZGVyIEFGVEVSIHRoZSBub3JtYWwgcmVuZGVyIGxvb3Agd2hlbiB0aGUgdGltZSBpcyBuZWdhdGl2ZS4gV2UgY291bGQgaGFuZGxlIHRoaXMgaW4gYSBtb3JlIGludHVpdGl2ZSB3YXksIG9mIGNvdXJzZSwgYnV0IHRoZSByZW5kZXIgbG9vcCBpcyB0aGUgTU9TVCBpbXBvcnRhbnQgdGhpbmcgdG8gb3B0aW1pemUsIHNvIHRoaXMgdGVjaG5pcXVlIGFsbG93cyB1cyB0byBhdm9pZCBhZGRpbmcgZXh0cmEgY29uZGl0aW9uYWwgbG9naWMgaW4gYSBoaWdoLWZyZXF1ZW5jeSBhcmVhLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90aW1lICE9PSAwIHx8IGR1cmF0aW9uID09PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucztcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwKSBpZiAodGhpcy5fc3RhcnRBdCAmJiB0aW1lICE9PSAtMC4wMDAxKSB7IC8vaWYgdGhlIHR3ZWVuIGlzIHBvc2l0aW9uZWQgYXQgdGhlIFZFUlkgYmVnaW5uaW5nIChfc3RhcnRUaW1lIDApIG9mIGl0cyBwYXJlbnQgdGltZWxpbmUsIGl0J3MgaWxsZWdhbCBmb3IgdGhlIHBsYXloZWFkIHRvIGdvIGJhY2sgZnVydGhlciwgc28gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlIHJlY29yZGVkIHN0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7IC8vbm90ZTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIHR1Y2sgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgbGVzcyB0cmF2ZWxlZCBhcmVhcyAobW9zdCB0d2VlbnMgZG9uJ3QgaGF2ZSBhbiBvblVwZGF0ZSkuIFdlJ2QganVzdCBoYXZlIGl0IGF0IHRoZSBlbmQgYmVmb3JlIHRoZSBvbkNvbXBsZXRlLCBidXQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCBiZWZvcmUgYW55IG9uVXBkYXRlIGlzIGNhbGxlZCwgc28gd2UgQUxTTyBwdXQgaXQgaGVyZSBhbmQgdGhlbiBpZiBpdCdzIG5vdCBjYWxsZWQsIHdlIGRvIHNvIGxhdGVyIG5lYXIgdGhlIG9uQ29tcGxldGUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKHRoaXMuX3RpbWUgIT09IHByZXZUaW1lIHx8IGlzQ29tcGxldGUgfHwgZm9yY2UpIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fZ2MgfHwgZm9yY2UpIHsgLy9jaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGltZSAhPT0gLTAuMDAwMSkgeyAvLy0wLjAwMDEgaXMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgd2UgdXNlIHdoZW4gbG9vcGluZyBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgb2YgYSByZXBlYXRlZCBUaW1lbGluZU1heCwgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRuJ3QgcmVuZGVyIHRoZSBfc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgcmF3UHJldlRpbWUgIT09IF90aW55TnVtKSB7IC8vdGhlIG9uQ29tcGxldGUgb3Igb25SZXZlcnNlQ29tcGxldGUgY291bGQgdHJpZ2dlciBtb3ZlbWVudCBvZiB0aGUgcGxheWhlYWQgYW5kIGZvciB6ZXJvLWR1cmF0aW9uIHR3ZWVucyAod2hpY2ggbXVzdCBkaXNjZXJuIGRpcmVjdGlvbikgdGhhdCBsYW5kIGRpcmVjdGx5IGJhY2sgb24gdGhlaXIgc3RhcnQgdGltZSwgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGFnYWluIG9uIHRoZSBuZXh0IHJlbmRlci4gVGhpbmsgb2Ygc2V2ZXJhbCBhZGRQYXVzZSgpJ3MgaW4gYSB0aW1lbGluZSB0aGF0IGZvcmNlcyB0aGUgcGxheWhlYWQgdG8gYSBjZXJ0YWluIHNwb3QsIGJ1dCB3aGF0IGlmIGl0J3MgYWxyZWFkeSBwYXVzZWQgYW5kIGFub3RoZXIgdHdlZW4gaXMgdHdlZW5pbmcgdGhlIFwidGltZVwiIG9mIHRoZSB0aW1lbGluZT8gRWFjaCB0aW1lIGl0IG1vdmVzIFtmb3J3YXJkXSBwYXN0IHRoYXQgc3BvdCwgaXQgd291bGQgbW92ZSBiYWNrLCBhbmQgc2luY2Ugc3VwcHJlc3NFdmVudHMgaXMgdHJ1ZSwgaXQnZCByZXNldCBfcmF3UHJldlRpbWUgdG8gX3RpbnlOdW0gc28gdGhhdCB3aGVuIGl0IGJlZ2lucyBhZ2FpbiwgdGhlIGNhbGxiYWNrIHdvdWxkIGZpcmUgKHNvIHVsdGltYXRlbHkgaXQgY291bGQgYm91bmNlIGJhY2sgYW5kIGZvcnRoIGR1cmluZyB0aGF0IHR3ZWVuKS4gQWdhaW4sIHRoaXMgaXMgYSB2ZXJ5IHVuY29tbW9uIHNjZW5hcmlvLCBidXQgcG9zc2libGUgbm9uZXRoZWxlc3MuXG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQsIG92ZXJ3cml0aW5nVHdlZW4pIHtcblx0XHRcdGlmICh2YXJzID09PSBcImFsbFwiKSB7XG5cdFx0XHRcdHZhcnMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhcnMgPT0gbnVsbCkgaWYgKHRhcmdldCA9PSBudWxsIHx8IHRhcmdldCA9PT0gdGhpcy50YXJnZXQpIHtcblx0XHRcdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/ICh0YXJnZXQgfHwgdGhpcy5fdGFyZ2V0cyB8fCB0aGlzLnRhcmdldCkgOiBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cdFx0XHR2YXIgc2ltdWx0YW5lb3VzT3ZlcndyaXRlID0gKG92ZXJ3cml0aW5nVHdlZW4gJiYgdGhpcy5fdGltZSAmJiBvdmVyd3JpdGluZ1R3ZWVuLl9zdGFydFRpbWUgPT09IHRoaXMuX3N0YXJ0VGltZSAmJiB0aGlzLl90aW1lbGluZSA9PT0gb3ZlcndyaXRpbmdUd2Vlbi5fdGltZWxpbmUpLFxuXHRcdFx0XHRpLCBvdmVyd3JpdHRlblByb3BzLCBwLCBwdCwgcHJvcExvb2t1cCwgY2hhbmdlZCwga2lsbFByb3BzLCByZWNvcmQsIGtpbGxlZDtcblx0XHRcdGlmICgoX2lzQXJyYXkodGFyZ2V0KSB8fCBfaXNTZWxlY3Rvcih0YXJnZXQpKSAmJiB0eXBlb2YodGFyZ2V0WzBdKSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRpID0gdGFyZ2V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2tpbGwodmFycywgdGFyZ2V0W2ldLCBvdmVyd3JpdGluZ1R3ZWVuKSkge1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5fdGFyZ2V0cykge1xuXHRcdFx0XHRcdGkgPSB0aGlzLl90YXJnZXRzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0YXJnZXQgPT09IHRoaXMuX3RhcmdldHNbaV0pIHtcblx0XHRcdFx0XHRcdFx0cHJvcExvb2t1cCA9IHRoaXMuX3Byb3BMb29rdXBbaV0gfHwge307XG5cdFx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRvdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IHZhcnMgPyB0aGlzLl9vdmVyd3JpdHRlblByb3BzW2ldIHx8IHt9IDogXCJhbGxcIjtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy50YXJnZXQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJvcExvb2t1cCA9IHRoaXMuX3Byb3BMb29rdXA7XG5cdFx0XHRcdFx0b3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgPSB2YXJzID8gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyB8fCB7fSA6IFwiYWxsXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocHJvcExvb2t1cCkge1xuXHRcdFx0XHRcdGtpbGxQcm9wcyA9IHZhcnMgfHwgcHJvcExvb2t1cDtcblx0XHRcdFx0XHRyZWNvcmQgPSAodmFycyAhPT0gb3ZlcndyaXR0ZW5Qcm9wcyAmJiBvdmVyd3JpdHRlblByb3BzICE9PSBcImFsbFwiICYmIHZhcnMgIT09IHByb3BMb29rdXAgJiYgKHR5cGVvZih2YXJzKSAhPT0gXCJvYmplY3RcIiB8fCAhdmFycy5fdGVtcEtpbGwpKTsgLy9fdGVtcEtpbGwgaXMgYSBzdXBlci1zZWNyZXQgd2F5IHRvIGRlbGV0ZSBhIHBhcnRpY3VsYXIgdHdlZW5pbmcgcHJvcGVydHkgYnV0IE5PVCBoYXZlIGl0IHJlbWVtYmVyZWQgYXMgYW4gb2ZmaWNpYWwgb3ZlcndyaXR0ZW4gcHJvcGVydHkgKGxpa2UgaW4gQmV6aWVyUGx1Z2luKVxuXHRcdFx0XHRcdGlmIChvdmVyd3JpdGluZ1R3ZWVuICYmIChUd2VlbkxpdGUub25PdmVyd3JpdGUgfHwgdGhpcy52YXJzLm9uT3ZlcndyaXRlKSkge1xuXHRcdFx0XHRcdFx0Zm9yIChwIGluIGtpbGxQcm9wcykge1xuXHRcdFx0XHRcdFx0XHRpZiAocHJvcExvb2t1cFtwXSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICgha2lsbGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRraWxsZWQgPSBbXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0a2lsbGVkLnB1c2gocCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICgoa2lsbGVkIHx8ICF2YXJzKSAmJiAhX29uT3ZlcndyaXRlKHRoaXMsIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkKSkgeyAvL2lmIHRoZSBvbk92ZXJ3cml0ZSByZXR1cm5lZCBmYWxzZSwgdGhhdCBtZWFucyB0aGUgdXNlciB3YW50cyB0byBvdmVycmlkZSB0aGUgb3ZlcndyaXRpbmcgKGNhbmNlbCBpdCkuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKHAgaW4ga2lsbFByb3BzKSB7XG5cdFx0XHRcdFx0XHRpZiAoKHB0ID0gcHJvcExvb2t1cFtwXSkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHNpbXVsdGFuZW91c092ZXJ3cml0ZSkgeyAvL2lmIGFub3RoZXIgdHdlZW4gb3ZlcndyaXRlcyB0aGlzIG9uZSBhbmQgdGhleSBib3RoIHN0YXJ0IGF0IGV4YWN0bHkgdGhlIHNhbWUgdGltZSwgeWV0IHRoaXMgdHdlZW4gaGFzIGFscmVhZHkgcmVuZGVyZWQgb25jZSAoZm9yIGV4YW1wbGUsIGF0IDAuMDAxKSBiZWNhdXNlIGl0J3MgZmlyc3QgaW4gdGhlIHF1ZXVlLCB3ZSBzaG91bGQgcmV2ZXJ0IHRoZSB2YWx1ZXMgdG8gd2hlcmUgdGhleSB3ZXJlIGF0IDAgc28gdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWVzIGFyZW4ndCBjb250YW1pbmF0ZWQgb24gdGhlIG92ZXJ3cml0aW5nIHR3ZWVuLlxuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LnMpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQucztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHB0LnBnICYmIHB0LnQuX2tpbGwoa2lsbFByb3BzKSkge1xuXHRcdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlOyAvL3NvbWUgcGx1Z2lucyBuZWVkIHRvIGJlIG5vdGlmaWVkIHNvIHRoZXkgY2FuIHBlcmZvcm0gY2xlYW51cCB0YXNrcyBmaXJzdFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICghcHQucGcgfHwgcHQudC5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHQgPT09IHRoaXMuX2ZpcnN0UFQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRwdC5fbmV4dCA9IHB0Ll9wcmV2ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRkZWxldGUgcHJvcExvb2t1cFtwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChyZWNvcmQpIHtcblx0XHRcdFx0XHRcdFx0b3ZlcndyaXR0ZW5Qcm9wc1twXSA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghdGhpcy5fZmlyc3RQVCAmJiB0aGlzLl9pbml0dGVkKSB7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgYXJlIGtpbGxlZCwga2lsbCB0aGUgdHdlZW4uIFdpdGhvdXQgdGhpcyBsaW5lLCBpZiB0aGVyZSdzIGEgdHdlZW4gd2l0aCBtdWx0aXBsZSB0YXJnZXRzIGFuZCB0aGVuIHlvdSBraWxsVHdlZW5zT2YoKSBlYWNoIHRhcmdldCBpbmRpdmlkdWFsbHksIHRoZSB0d2VlbiB3b3VsZCB0ZWNobmljYWxseSBzdGlsbCByZW1haW4gYWN0aXZlIGFuZCBmaXJlIGl0cyBvbkNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBwcm9wZXJ0aWVzIHR3ZWVuaW5nLlxuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQpIHtcblx0XHRcdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KFwiX29uRGlzYWJsZVwiLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2ZpcnN0UFQgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdGhpcy5fc3RhcnRBdCA9IHRoaXMuX29uVXBkYXRlID0gbnVsbDtcblx0XHRcdHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgPSB0aGlzLl9hY3RpdmUgPSB0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9wcm9wTG9va3VwID0gKHRoaXMuX3RhcmdldHMpID8ge30gOiBbXTtcblx0XHRcdEFuaW1hdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cdFx0XHRcdHRoaXMucmVuZGVyKE1hdGgubWluKDAsIC10aGlzLl9kZWxheSkpOyAvL2luIGNhc2UgZGVsYXkgaXMgbmVnYXRpdmUuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fZW5hYmxlZCA9IGZ1bmN0aW9uKGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZW5hYmxlZCAmJiB0aGlzLl9nYykge1xuXHRcdFx0XHR2YXIgdGFyZ2V0cyA9IHRoaXMuX3RhcmdldHMsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0aWYgKHRhcmdldHMpIHtcblx0XHRcdFx0XHRpID0gdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zaWJsaW5nc1tpXSA9IF9yZWdpc3Rlcih0YXJnZXRzW2ldLCB0aGlzLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBfcmVnaXN0ZXIodGhpcy50YXJnZXQsIHRoaXMsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRBbmltYXRpb24ucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcywgZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpO1xuXHRcdFx0aWYgKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQpIGlmICh0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdHJldHVybiBUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoKGVuYWJsZWQgPyBcIl9vbkVuYWJsZVwiIDogXCJfb25EaXNhYmxlXCIpLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cbi8vLS0tLVR3ZWVuTGl0ZSBzdGF0aWMgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0VHdlZW5MaXRlLnRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5mcm9tID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5mcm9tVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIGR1cmF0aW9uLCB0b1ZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwgPSBmdW5jdGlvbihkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUsIHVzZUZyYW1lcykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUoY2FsbGJhY2ssIDAsIHtkZWxheTpkZWxheSwgb25Db21wbGV0ZTpjYWxsYmFjaywgb25Db21wbGV0ZVBhcmFtczpwYXJhbXMsIGNhbGxiYWNrU2NvcGU6c2NvcGUsIG9uUmV2ZXJzZUNvbXBsZXRlOmNhbGxiYWNrLCBvblJldmVyc2VDb21wbGV0ZVBhcmFtczpwYXJhbXMsIGltbWVkaWF0ZVJlbmRlcjpmYWxzZSwgbGF6eTpmYWxzZSwgdXNlRnJhbWVzOnVzZUZyYW1lcywgb3ZlcndyaXRlOjB9KTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCAwLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmdldFR3ZWVuc09mID0gZnVuY3Rpb24odGFyZ2V0LCBvbmx5QWN0aXZlKSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHsgcmV0dXJuIFtdOyB9XG5cdFx0XHR0YXJnZXQgPSAodHlwZW9mKHRhcmdldCkgIT09IFwic3RyaW5nXCIpID8gdGFyZ2V0IDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXHRcdFx0dmFyIGksIGEsIGosIHQ7XG5cdFx0XHRpZiAoKF9pc0FycmF5KHRhcmdldCkgfHwgX2lzU2VsZWN0b3IodGFyZ2V0KSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0aSA9IHRhcmdldC5sZW5ndGg7XG5cdFx0XHRcdGEgPSBbXTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0YSA9IGEuY29uY2F0KFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXRbaV0sIG9ubHlBY3RpdmUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdC8vbm93IGdldCByaWQgb2YgYW55IGR1cGxpY2F0ZXMgKHR3ZWVucyBvZiBhcnJheXMgb2Ygb2JqZWN0cyBjb3VsZCBjYXVzZSBkdXBsaWNhdGVzKVxuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0ID0gYVtpXTtcblx0XHRcdFx0XHRqID0gaTtcblx0XHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0ID09PSBhW2pdKSB7XG5cdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YSA9IF9yZWdpc3Rlcih0YXJnZXQpLmNvbmNhdCgpO1xuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChhW2ldLl9nYyB8fCAob25seUFjdGl2ZSAmJiAhYVtpXS5pc0FjdGl2ZSgpKSkge1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmtpbGxUd2VlbnNPZiA9IFR3ZWVuTGl0ZS5raWxsRGVsYXllZENhbGxzVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9ubHlBY3RpdmUsIHZhcnMpIHtcblx0XHRcdGlmICh0eXBlb2Yob25seUFjdGl2ZSkgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0dmFycyA9IG9ubHlBY3RpdmU7IC8vZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChiZWZvcmUgXCJvbmx5QWN0aXZlXCIgcGFyYW1ldGVyIHdhcyBpbnNlcnRlZClcblx0XHRcdFx0b25seUFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0LCBvbmx5QWN0aXZlKSxcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGFbaV0uX2tpbGwodmFycywgdGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFR3ZWVuUGx1Z2luICAgKGNvdWxkIGVhc2lseSBiZSBzcGxpdCBvdXQgYXMgYSBzZXBhcmF0ZSBmaWxlL2NsYXNzLCBidXQgaW5jbHVkZWQgZm9yIGVhc2Ugb2YgdXNlIChzbyB0aGF0IHBlb3BsZSBkb24ndCBuZWVkIHRvIGluY2x1ZGUgYW5vdGhlciBzY3JpcHQgY2FsbCBiZWZvcmUgbG9hZGluZyBwbHVnaW5zIHdoaWNoIGlzIGVhc3kgdG8gZm9yZ2V0KVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFR3ZWVuUGx1Z2luID0gX2NsYXNzKFwicGx1Z2lucy5Ud2VlblBsdWdpblwiLCBmdW5jdGlvbihwcm9wcywgcHJpb3JpdHkpIHtcblx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IChwcm9wcyB8fCBcIlwiKS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcE5hbWUgPSB0aGlzLl9vdmVyd3JpdGVQcm9wc1swXTtcblx0XHRcdFx0XHR0aGlzLl9wcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBUd2VlblBsdWdpbi5wcm90b3R5cGU7XG5cdFx0XHRcdH0sIHRydWUpO1xuXG5cdFx0cCA9IFR3ZWVuUGx1Z2luLnByb3RvdHlwZTtcblx0XHRUd2VlblBsdWdpbi52ZXJzaW9uID0gXCIxLjE4LjBcIjtcblx0XHRUd2VlblBsdWdpbi5BUEkgPSAyO1xuXHRcdHAuX2ZpcnN0UFQgPSBudWxsO1xuXHRcdHAuX2FkZFR3ZWVuID0gX2FkZFByb3BUd2Vlbjtcblx0XHRwLnNldFJhdGlvID0gX3NldFJhdGlvO1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGEgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRpO1xuXHRcdFx0aWYgKGxvb2t1cFt0aGlzLl9wcm9wTmFtZV0gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAobG9va3VwW2FbaV1dICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChsb29rdXBbcHQubl0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5fcm91bmRQcm9wcyA9IGZ1bmN0aW9uKGxvb2t1cCwgdmFsdWUpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKGxvb2t1cFt0aGlzLl9wcm9wTmFtZV0gfHwgKHB0Lm4gIT0gbnVsbCAmJiBsb29rdXBbIHB0Lm4uc3BsaXQodGhpcy5fcHJvcE5hbWUgKyBcIl9cIikuam9pbihcIlwiKSBdKSkgeyAvL3NvbWUgcHJvcGVydGllcyB0aGF0IGFyZSB2ZXJ5IHBsdWdpbi1zcGVjaWZpYyBhZGQgYSBwcmVmaXggbmFtZWQgYWZ0ZXIgdGhlIF9wcm9wTmFtZSBwbHVzIGFuIHVuZGVyc2NvcmUsIHNvIHdlIG5lZWQgdG8gaWdub3JlIHRoYXQgZXh0cmEgc3R1ZmYgaGVyZS5cblx0XHRcdFx0XHRwdC5yID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50ID0gZnVuY3Rpb24odHlwZSwgdHdlZW4pIHtcblx0XHRcdHZhciBwdCA9IHR3ZWVuLl9maXJzdFBULFxuXHRcdFx0XHRjaGFuZ2VkLCBwdDIsIGZpcnN0LCBsYXN0LCBuZXh0O1xuXHRcdFx0aWYgKHR5cGUgPT09IFwiX29uSW5pdEFsbFByb3BzXCIpIHtcblx0XHRcdFx0Ly9zb3J0cyB0aGUgUHJvcFR3ZWVuIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByaW9yaXR5IGJlY2F1c2Ugc29tZSBwbHVnaW5zIG5lZWQgdG8gcmVuZGVyIGVhcmxpZXIvbGF0ZXIgdGhhbiBvdGhlcnMsIGxpa2UgTW90aW9uQmx1clBsdWdpbiBhcHBsaWVzIGl0cyBlZmZlY3RzIGFmdGVyIGFsbCB4L3kvYWxwaGEgdHdlZW5zIGhhdmUgcmVuZGVyZWQgb24gZWFjaCBmcmFtZS5cblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0bmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdHB0MiA9IGZpcnN0O1xuXHRcdFx0XHRcdHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcblx0XHRcdFx0XHRcdHB0MiA9IHB0Mi5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpKSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9uZXh0ID0gcHQyKSkge1xuXHRcdFx0XHRcdFx0cHQyLl9wcmV2ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxhc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gdHdlZW4uX2ZpcnN0UFQgPSBmaXJzdDtcblx0XHRcdH1cblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQucGcpIGlmICh0eXBlb2YocHQudFt0eXBlXSkgPT09IFwiZnVuY3Rpb25cIikgaWYgKHB0LnRbdHlwZV0oKSkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUgPSBmdW5jdGlvbihwbHVnaW5zKSB7XG5cdFx0XHR2YXIgaSA9IHBsdWdpbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChwbHVnaW5zW2ldLkFQSSA9PT0gVHdlZW5QbHVnaW4uQVBJKSB7XG5cdFx0XHRcdFx0X3BsdWdpbnNbKG5ldyBwbHVnaW5zW2ldKCkpLl9wcm9wTmFtZV0gPSBwbHVnaW5zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0Ly9wcm92aWRlcyBhIG1vcmUgY29uY2lzZSB3YXkgdG8gZGVmaW5lIHBsdWdpbnMgdGhhdCBoYXZlIG5vIGRlcGVuZGVuY2llcyBiZXNpZGVzIFR3ZWVuUGx1Z2luIGFuZCBUd2VlbkxpdGUsIHdyYXBwaW5nIGNvbW1vbiBib2lsZXJwbGF0ZSBzdHVmZiBpbnRvIG9uZSBmdW5jdGlvbiAoYWRkZWQgaW4gMS45LjApLiBZb3UgZG9uJ3QgTkVFRCB0byB1c2UgdGhpcyB0byBkZWZpbmUgYSBwbHVnaW4gLSB0aGUgb2xkIHdheSBzdGlsbCB3b3JrcyBhbmQgY2FuIGJlIHVzZWZ1bCBpbiBjZXJ0YWluIChyYXJlKSBzaXR1YXRpb25zLlxuXHRcdF9nc0RlZmluZS5wbHVnaW4gPSBmdW5jdGlvbihjb25maWcpIHtcblx0XHRcdGlmICghY29uZmlnIHx8ICFjb25maWcucHJvcE5hbWUgfHwgIWNvbmZpZy5pbml0IHx8ICFjb25maWcuQVBJKSB7IHRocm93IFwiaWxsZWdhbCBwbHVnaW4gZGVmaW5pdGlvbi5cIjsgfVxuXHRcdFx0dmFyIHByb3BOYW1lID0gY29uZmlnLnByb3BOYW1lLFxuXHRcdFx0XHRwcmlvcml0eSA9IGNvbmZpZy5wcmlvcml0eSB8fCAwLFxuXHRcdFx0XHRvdmVyd3JpdGVQcm9wcyA9IGNvbmZpZy5vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0bWFwID0ge2luaXQ6XCJfb25Jbml0VHdlZW5cIiwgc2V0Olwic2V0UmF0aW9cIiwga2lsbDpcIl9raWxsXCIsIHJvdW5kOlwiX3JvdW5kUHJvcHNcIiwgaW5pdEFsbDpcIl9vbkluaXRBbGxQcm9wc1wifSxcblx0XHRcdFx0UGx1Z2luID0gX2NsYXNzKFwicGx1Z2lucy5cIiArIHByb3BOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcE5hbWUuc3Vic3RyKDEpICsgXCJQbHVnaW5cIixcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFR3ZWVuUGx1Z2luLmNhbGwodGhpcywgcHJvcE5hbWUsIHByaW9yaXR5KTtcblx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzID0gb3ZlcndyaXRlUHJvcHMgfHwgW107XG5cdFx0XHRcdFx0fSwgKGNvbmZpZy5nbG9iYWwgPT09IHRydWUpKSxcblx0XHRcdFx0cCA9IFBsdWdpbi5wcm90b3R5cGUgPSBuZXcgVHdlZW5QbHVnaW4ocHJvcE5hbWUpLFxuXHRcdFx0XHRwcm9wO1xuXHRcdFx0cC5jb25zdHJ1Y3RvciA9IFBsdWdpbjtcblx0XHRcdFBsdWdpbi5BUEkgPSBjb25maWcuQVBJO1xuXHRcdFx0Zm9yIChwcm9wIGluIG1hcCkge1xuXHRcdFx0XHRpZiAodHlwZW9mKGNvbmZpZ1twcm9wXSkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHBbbWFwW3Byb3BdXSA9IGNvbmZpZ1twcm9wXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0UGx1Z2luLnZlcnNpb24gPSBjb25maWcudmVyc2lvbjtcblx0XHRcdFR3ZWVuUGx1Z2luLmFjdGl2YXRlKFtQbHVnaW5dKTtcblx0XHRcdHJldHVybiBQbHVnaW47XG5cdFx0fTtcblxuXG5cdFx0Ly9ub3cgcnVuIHRocm91Z2ggYWxsIHRoZSBkZXBlbmRlbmNpZXMgZGlzY292ZXJlZCBhbmQgaWYgYW55IGFyZSBtaXNzaW5nLCBsb2cgdGhhdCB0byB0aGUgY29uc29sZSBhcyBhIHdhcm5pbmcuIFRoaXMgaXMgd2h5IGl0J3MgYmVzdCB0byBoYXZlIFR3ZWVuTGl0ZSBsb2FkIGxhc3QgLSBpdCBjYW4gY2hlY2sgYWxsIHRoZSBkZXBlbmRlbmNpZXMgZm9yIHlvdS5cblx0XHRhID0gd2luZG93Ll9nc1F1ZXVlO1xuXHRcdGlmIChhKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRhW2ldKCk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHAgaW4gX2RlZkxvb2t1cCkge1xuXHRcdFx0XHRpZiAoIV9kZWZMb29rdXBbcF0uZnVuYykge1xuXHRcdFx0XHRcdHdpbmRvdy5jb25zb2xlLmxvZyhcIkdTQVAgZW5jb3VudGVyZWQgbWlzc2luZyBkZXBlbmRlbmN5OiBjb20uZ3JlZW5zb2NrLlwiICsgcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRfdGlja2VyQWN0aXZlID0gZmFsc2U7IC8vZW5zdXJlcyB0aGF0IHRoZSBmaXJzdCBvZmZpY2lhbCBhbmltYXRpb24gZm9yY2VzIGEgdGlja2VyLnRpY2soKSB0byB1cGRhdGUgdGhlIHRpbWUgd2hlbiBpdCBpcyBpbnN0YW50aWF0ZWRcblxufSkoKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93LCBcIlR3ZWVuTWF4XCIpOyIsIi8qIVxuICogU2Nyb2xsTWFnaWMgdjIuMC41ICgyMDE1LTA0LTI5KVxuICogVGhlIGphdmFzY3JpcHQgbGlicmFyeSBmb3IgbWFnaWNhbCBzY3JvbGwgaW50ZXJhY3Rpb25zLlxuICogKGMpIDIwMTUgSmFuIFBhZXBrZSAoQGphbnBhZXBrZSlcbiAqIFByb2plY3QgV2Vic2l0ZTogaHR0cDovL3Njcm9sbG1hZ2ljLmlvXG4gKiBcbiAqIEB2ZXJzaW9uIDIuMC41XG4gKiBAbGljZW5zZSBEdWFsIGxpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlIGFuZCBHUEwuXG4gKiBAYXV0aG9yIEphbiBQYWVwa2UgLSBlLW1haWxAamFucGFlcGtlLmRlXG4gKlxuICogQGZpbGUgU2Nyb2xsTWFnaWMgbWFpbiBsaWJyYXJ5LlxuICovXG4vKipcbiAqIEBuYW1lc3BhY2UgU2Nyb2xsTWFnaWNcbiAqL1xuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxcblx0XHRyb290LlNjcm9sbE1hZ2ljID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIFNjcm9sbE1hZ2ljID0gZnVuY3Rpb24gKCkge1xuXHRcdF91dGlsLmxvZygyLCAnKENPTVBBVElCSUxJVFkgTk9USUNFKSAtPiBBcyBvZiBTY3JvbGxNYWdpYyAyLjAuMCB5b3UgbmVlZCB0byB1c2UgXFwnbmV3IFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIoKVxcJyB0byBjcmVhdGUgYSBuZXcgY29udHJvbGxlciBpbnN0YW5jZS4gVXNlIFxcJ25ldyBTY3JvbGxNYWdpYy5TY2VuZSgpXFwnIHRvIGluc3RhbmNlIGEgc2NlbmUuJyk7XG5cdH07XG5cblx0U2Nyb2xsTWFnaWMudmVyc2lvbiA9IFwiMi4wLjVcIjtcblxuXHQvLyBUT0RPOiB0ZW1wb3Jhcnkgd29ya2Fyb3VuZCBmb3IgY2hyb21lJ3Mgc2Nyb2xsIGppdHRlciBidWdcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXdoZWVsXCIsIGZ1bmN0aW9uICgpIHt9KTtcblxuXHQvLyBnbG9iYWwgY29uc3Rcblx0dmFyIFBJTl9TUEFDRVJfQVRUUklCVVRFID0gXCJkYXRhLXNjcm9sbG1hZ2ljLXBpbi1zcGFjZXJcIjtcblxuXHQvKipcblx0ICogVGhlIG1haW4gY2xhc3MgdGhhdCBpcyBuZWVkZWQgb25jZSBwZXIgc2Nyb2xsIGNvbnRhaW5lci5cblx0ICpcblx0ICogQGNsYXNzXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGJhc2ljIGluaXRpYWxpemF0aW9uXG5cdCAqIHZhciBjb250cm9sbGVyID0gbmV3IFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIoKTtcblx0ICpcblx0ICogLy8gcGFzc2luZyBvcHRpb25zXG5cdCAqIHZhciBjb250cm9sbGVyID0gbmV3IFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIoe2NvbnRhaW5lcjogXCIjbXlDb250YWluZXJcIiwgbG9nbGV2ZWw6IDN9KTtcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIEFuIG9iamVjdCBjb250YWluaW5nIG9uZSBvciBtb3JlIG9wdGlvbnMgZm9yIHRoZSBjb250cm9sbGVyLlxuXHQgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gW29wdGlvbnMuY29udGFpbmVyPXdpbmRvd10gLSBBIHNlbGVjdG9yLCBET00gb2JqZWN0IHRoYXQgcmVmZXJlbmNlcyB0aGUgbWFpbiBjb250YWluZXIgZm9yIHNjcm9sbGluZy5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy52ZXJ0aWNhbD10cnVlXSAtIFNldHMgdGhlIHNjcm9sbCBtb2RlIHRvIHZlcnRpY2FsIChgdHJ1ZWApIG9yIGhvcml6b250YWwgKGBmYWxzZWApIHNjcm9sbGluZy5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmdsb2JhbFNjZW5lT3B0aW9ucz17fV0gLSBUaGVzZSBvcHRpb25zIHdpbGwgYmUgcGFzc2VkIHRvIGV2ZXJ5IFNjZW5lIHRoYXQgaXMgYWRkZWQgdG8gdGhlIGNvbnRyb2xsZXIgdXNpbmcgdGhlIGFkZFNjZW5lIG1ldGhvZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gU2NlbmUgb3B0aW9ucyBzZWUge0BsaW5rIFNjcm9sbE1hZ2ljLlNjZW5lfS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvZ2xldmVsPTJdIExvZ2xldmVsIGZvciBkZWJ1Z2dpbmcuIE5vdGUgdGhhdCBsb2dnaW5nIGlzIGRpc2FibGVkIGluIHRoZSBtaW5pZmllZCB2ZXJzaW9uIG9mIFNjcm9sbE1hZ2ljLlxuXHQgKiogYDBgID0+IHNpbGVudFxuXHQgKiogYDFgID0+IGVycm9yc1xuXHQgKiogYDJgID0+IGVycm9ycywgd2FybmluZ3Ncblx0ICoqIGAzYCA9PiBlcnJvcnMsIHdhcm5pbmdzLCBkZWJ1Z2luZm9cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWZyZXNoSW50ZXJ2YWw9MTAwXSAtIFNvbWUgY2hhbmdlcyBkb24ndCBjYWxsIGV2ZW50cyBieSBkZWZhdWx0LCBsaWtlIGNoYW5naW5nIHRoZSBjb250YWluZXIgc2l6ZSBvciBtb3ZpbmcgYSBzY2VuZSB0cmlnZ2VyIGVsZW1lbnQuICBcblx0IFRoaXMgaW50ZXJ2YWwgcG9sbHMgdGhlc2UgcGFyYW1ldGVycyB0byBmaXJlIHRoZSBuZWNlc3NhcnkgZXZlbnRzLiAgXG5cdCBJZiB5b3UgZG9uJ3QgdXNlIGN1c3RvbSBjb250YWluZXJzLCB0cmlnZ2VyIGVsZW1lbnRzIG9yIGhhdmUgc3RhdGljIGxheW91dHMsIHdoZXJlIHRoZSBwb3NpdGlvbnMgb2YgdGhlIHRyaWdnZXIgZWxlbWVudHMgZG9uJ3QgY2hhbmdlLCB5b3UgY2FuIHNldCB0aGlzIHRvIDAgZGlzYWJsZSBpbnRlcnZhbCBjaGVja2luZyBhbmQgaW1wcm92ZSBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICovXG5cdFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuLypcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKiBzZXR0aW5nc1xuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqL1xuXHRcdHZhclxuXHRcdE5BTUVTUEFDRSA9ICdTY3JvbGxNYWdpYy5Db250cm9sbGVyJyxcblx0XHRcdFNDUk9MTF9ESVJFQ1RJT05fRk9SV0FSRCA9ICdGT1JXQVJEJyxcblx0XHRcdFNDUk9MTF9ESVJFQ1RJT05fUkVWRVJTRSA9ICdSRVZFUlNFJyxcblx0XHRcdFNDUk9MTF9ESVJFQ1RJT05fUEFVU0VEID0gJ1BBVVNFRCcsXG5cdFx0XHRERUZBVUxUX09QVElPTlMgPSBDT05UUk9MTEVSX09QVElPTlMuZGVmYXVsdHM7XG5cbi8qXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogcHJpdmF0ZSB2YXJzXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICovXG5cdFx0dmFyXG5cdFx0Q29udHJvbGxlciA9IHRoaXMsXG5cdFx0XHRfb3B0aW9ucyA9IF91dGlsLmV4dGVuZCh7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKSxcblx0XHRcdF9zY2VuZU9iamVjdHMgPSBbXSxcblx0XHRcdF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSA9IGZhbHNlLFxuXHRcdFx0Ly8gY2FuIGJlIGJvb2xlYW4gKHRydWUgPT4gYWxsIHNjZW5lcykgb3IgYW4gYXJyYXkgb2Ygc2NlbmVzIHRvIGJlIHVwZGF0ZWRcblx0XHRcdF9zY3JvbGxQb3MgPSAwLFxuXHRcdFx0X3Njcm9sbERpcmVjdGlvbiA9IFNDUk9MTF9ESVJFQ1RJT05fUEFVU0VELFxuXHRcdFx0X2lzRG9jdW1lbnQgPSB0cnVlLFxuXHRcdFx0X3ZpZXdQb3J0U2l6ZSA9IDAsXG5cdFx0XHRfZW5hYmxlZCA9IHRydWUsXG5cdFx0XHRfdXBkYXRlVGltZW91dCwgX3JlZnJlc2hUaW1lb3V0O1xuXG4vKlxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIHByaXZhdGUgZnVuY3Rpb25zXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICovXG5cblx0XHQvKipcblx0XHQgKiBJbnRlcm5hbCBjb25zdHJ1Y3RvciBmdW5jdGlvbiBvZiB0aGUgU2Nyb2xsTWFnaWMgQ29udHJvbGxlclxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBfb3B0aW9ucykge1xuXHRcdFx0XHRpZiAoIURFRkFVTFRfT1BUSU9OUy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0bG9nKDIsIFwiV0FSTklORzogVW5rbm93biBvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiXCIpO1xuXHRcdFx0XHRcdGRlbGV0ZSBfb3B0aW9uc1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRfb3B0aW9ucy5jb250YWluZXIgPSBfdXRpbC5nZXQuZWxlbWVudHMoX29wdGlvbnMuY29udGFpbmVyKVswXTtcblx0XHRcdC8vIGNoZWNrIFNjcm9sbENvbnRhaW5lclxuXHRcdFx0aWYgKCFfb3B0aW9ucy5jb250YWluZXIpIHtcblx0XHRcdFx0bG9nKDEsIFwiRVJST1IgY3JlYXRpbmcgb2JqZWN0IFwiICsgTkFNRVNQQUNFICsgXCI6IE5vIHZhbGlkIHNjcm9sbCBjb250YWluZXIgc3VwcGxpZWRcIik7XG5cdFx0XHRcdHRocm93IE5BTUVTUEFDRSArIFwiIGluaXQgZmFpbGVkLlwiOyAvLyBjYW5jZWxcblx0XHRcdH1cblx0XHRcdF9pc0RvY3VtZW50ID0gX29wdGlvbnMuY29udGFpbmVyID09PSB3aW5kb3cgfHwgX29wdGlvbnMuY29udGFpbmVyID09PSBkb2N1bWVudC5ib2R5IHx8ICFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKF9vcHRpb25zLmNvbnRhaW5lcik7XG5cdFx0XHQvLyBub3JtYWxpemUgdG8gd2luZG93XG5cdFx0XHRpZiAoX2lzRG9jdW1lbnQpIHtcblx0XHRcdFx0X29wdGlvbnMuY29udGFpbmVyID0gd2luZG93O1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGNvbnRhaW5lciBzaXplIGltbWVkaWF0ZWx5XG5cdFx0XHRfdmlld1BvcnRTaXplID0gZ2V0Vmlld3BvcnRTaXplKCk7XG5cdFx0XHQvLyBzZXQgZXZlbnQgaGFuZGxlcnNcblx0XHRcdF9vcHRpb25zLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uQ2hhbmdlKTtcblx0XHRcdF9vcHRpb25zLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIG9uQ2hhbmdlKTtcblxuXHRcdFx0X29wdGlvbnMucmVmcmVzaEludGVydmFsID0gcGFyc2VJbnQoX29wdGlvbnMucmVmcmVzaEludGVydmFsKSB8fCBERUZBVUxUX09QVElPTlMucmVmcmVzaEludGVydmFsO1xuXHRcdFx0c2NoZWR1bGVSZWZyZXNoKCk7XG5cblx0XHRcdGxvZygzLCBcImFkZGVkIG5ldyBcIiArIE5BTUVTUEFDRSArIFwiIGNvbnRyb2xsZXIgKHZcIiArIFNjcm9sbE1hZ2ljLnZlcnNpb24gKyBcIilcIik7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFNjaGVkdWxlIHRoZSBuZXh0IGV4ZWN1dGlvbiBvZiB0aGUgcmVmcmVzaCBmdW5jdGlvblxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHNjaGVkdWxlUmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChfb3B0aW9ucy5yZWZyZXNoSW50ZXJ2YWwgPiAwKSB7XG5cdFx0XHRcdF9yZWZyZXNoVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHJlZnJlc2gsIF9vcHRpb25zLnJlZnJlc2hJbnRlcnZhbCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmF1bHQgZnVuY3Rpb24gdG8gZ2V0IHNjcm9sbCBwb3MgLSBvdmVyd3JpdGVhYmxlIHVzaW5nIGBDb250cm9sbGVyLnNjcm9sbFBvcyhuZXdGdW5jdGlvbilgXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgZ2V0U2Nyb2xsUG9zID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIF9vcHRpb25zLnZlcnRpY2FsID8gX3V0aWwuZ2V0LnNjcm9sbFRvcChfb3B0aW9ucy5jb250YWluZXIpIDogX3V0aWwuZ2V0LnNjcm9sbExlZnQoX29wdGlvbnMuY29udGFpbmVyKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgY3VycmVudCB2aWV3cG9ydCBTaXplICh3aWR0aCB2b3IgaG9yaXpvbnRhbCwgaGVpZ2h0IGZvciB2ZXJ0aWNhbClcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciBnZXRWaWV3cG9ydFNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gX29wdGlvbnMudmVydGljYWwgPyBfdXRpbC5nZXQuaGVpZ2h0KF9vcHRpb25zLmNvbnRhaW5lcikgOiBfdXRpbC5nZXQud2lkdGgoX29wdGlvbnMuY29udGFpbmVyKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmYXVsdCBmdW5jdGlvbiB0byBzZXQgc2Nyb2xsIHBvcyAtIG92ZXJ3cml0ZWFibGUgdXNpbmcgYENvbnRyb2xsZXIuc2Nyb2xsVG8obmV3RnVuY3Rpb24pYFxuXHRcdCAqIE1ha2UgYXZhaWxhYmxlIHB1YmxpY2x5IGZvciBwaW5uZWQgbW91c2V3aGVlbCB3b3JrYXJvdW5kLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHNldFNjcm9sbFBvcyA9IHRoaXMuX3NldFNjcm9sbFBvcyA9IGZ1bmN0aW9uIChwb3MpIHtcblx0XHRcdGlmIChfb3B0aW9ucy52ZXJ0aWNhbCkge1xuXHRcdFx0XHRpZiAoX2lzRG9jdW1lbnQpIHtcblx0XHRcdFx0XHR3aW5kb3cuc2Nyb2xsVG8oX3V0aWwuZ2V0LnNjcm9sbExlZnQoKSwgcG9zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfb3B0aW9ucy5jb250YWluZXIuc2Nyb2xsVG9wID0gcG9zO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoX2lzRG9jdW1lbnQpIHtcblx0XHRcdFx0XHR3aW5kb3cuc2Nyb2xsVG8ocG9zLCBfdXRpbC5nZXQuc2Nyb2xsVG9wKCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9vcHRpb25zLmNvbnRhaW5lci5zY3JvbGxMZWZ0ID0gcG9zO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZSB1cGRhdGVzIGluIGN5Y2xlcyBpbnN0ZWFkIG9mIG9uIHNjcm9sbCAocGVyZm9ybWFuY2UpXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgdXBkYXRlU2NlbmVzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKF9lbmFibGVkICYmIF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSkge1xuXHRcdFx0XHQvLyBkZXRlcm1pbmUgc2NlbmVzIHRvIHVwZGF0ZVxuXHRcdFx0XHR2YXIgc2NlbmVzVG9VcGRhdGUgPSBfdXRpbC50eXBlLkFycmF5KF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSkgPyBfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUgOiBfc2NlbmVPYmplY3RzLnNsaWNlKDApO1xuXHRcdFx0XHQvLyByZXNldCBzY2VuZXNcblx0XHRcdFx0X3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlID0gZmFsc2U7XG5cdFx0XHRcdHZhciBvbGRTY3JvbGxQb3MgPSBfc2Nyb2xsUG9zO1xuXHRcdFx0XHQvLyB1cGRhdGUgc2Nyb2xsIHBvcyBub3cgaW5zdGVhZCBvZiBvbkNoYW5nZSwgYXMgaXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNpbmNlIHNjaGVkdWxpbmcgKGkuZS4gaW4tYnJvd3NlciBzbW9vdGggc2Nyb2xsKVxuXHRcdFx0XHRfc2Nyb2xsUG9zID0gQ29udHJvbGxlci5zY3JvbGxQb3MoKTtcblx0XHRcdFx0dmFyIGRlbHRhU2Nyb2xsID0gX3Njcm9sbFBvcyAtIG9sZFNjcm9sbFBvcztcblx0XHRcdFx0aWYgKGRlbHRhU2Nyb2xsICE9PSAwKSB7IC8vIHNjcm9sbCBwb3NpdGlvbiBjaGFuZ2VkP1xuXHRcdFx0XHRcdF9zY3JvbGxEaXJlY3Rpb24gPSAoZGVsdGFTY3JvbGwgPiAwKSA/IFNDUk9MTF9ESVJFQ1RJT05fRk9SV0FSRCA6IFNDUk9MTF9ESVJFQ1RJT05fUkVWRVJTRTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZXZlcnNlIG9yZGVyIG9mIHNjZW5lcyBpZiBzY3JvbGxpbmcgcmV2ZXJzZVxuXHRcdFx0XHRpZiAoX3Njcm9sbERpcmVjdGlvbiA9PT0gU0NST0xMX0RJUkVDVElPTl9SRVZFUlNFKSB7XG5cdFx0XHRcdFx0c2NlbmVzVG9VcGRhdGUucmV2ZXJzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHVwZGF0ZSBzY2VuZXNcblx0XHRcdFx0c2NlbmVzVG9VcGRhdGUuZm9yRWFjaChmdW5jdGlvbiAoc2NlbmUsIGluZGV4KSB7XG5cdFx0XHRcdFx0bG9nKDMsIFwidXBkYXRpbmcgU2NlbmUgXCIgKyAoaW5kZXggKyAxKSArIFwiL1wiICsgc2NlbmVzVG9VcGRhdGUubGVuZ3RoICsgXCIgKFwiICsgX3NjZW5lT2JqZWN0cy5sZW5ndGggKyBcIiB0b3RhbClcIik7XG5cdFx0XHRcdFx0c2NlbmUudXBkYXRlKHRydWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHNjZW5lc1RvVXBkYXRlLmxlbmd0aCA9PT0gMCAmJiBfb3B0aW9ucy5sb2dsZXZlbCA+PSAzKSB7XG5cdFx0XHRcdFx0bG9nKDMsIFwidXBkYXRpbmcgMCBTY2VuZXMgKG5vdGhpbmcgYWRkZWQgdG8gY29udHJvbGxlcilcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZXMgckFGIGNhbGxiYWNrXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgZGVib3VuY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfdXBkYXRlVGltZW91dCA9IF91dGlsLnJBRih1cGRhdGVTY2VuZXMpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVzIENvbnRhaW5lciBjaGFuZ2VzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgb25DaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0bG9nKDMsIFwiZXZlbnQgZmlyZWQgY2F1c2luZyBhbiB1cGRhdGU6XCIsIGUudHlwZSk7XG5cdFx0XHRpZiAoZS50eXBlID09IFwicmVzaXplXCIpIHtcblx0XHRcdFx0Ly8gcmVzaXplXG5cdFx0XHRcdF92aWV3UG9ydFNpemUgPSBnZXRWaWV3cG9ydFNpemUoKTtcblx0XHRcdFx0X3Njcm9sbERpcmVjdGlvbiA9IFNDUk9MTF9ESVJFQ1RJT05fUEFVU0VEO1xuXHRcdFx0fVxuXHRcdFx0Ly8gc2NoZWR1bGUgdXBkYXRlXG5cdFx0XHRpZiAoX3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlICE9PSB0cnVlKSB7XG5cdFx0XHRcdF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSA9IHRydWU7XG5cdFx0XHRcdGRlYm91bmNlVXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciByZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCFfaXNEb2N1bWVudCkge1xuXHRcdFx0XHQvLyBzaW11bGF0ZSByZXNpemUgZXZlbnQuIE9ubHkgd29ya3MgZm9yIHZpZXdwb3J0IHJlbGV2YW50IHBhcmFtIChwZXJmb3JtYW5jZSlcblx0XHRcdFx0aWYgKF92aWV3UG9ydFNpemUgIT0gZ2V0Vmlld3BvcnRTaXplKCkpIHtcblx0XHRcdFx0XHR2YXIgcmVzaXplRXZlbnQ7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHJlc2l6ZUV2ZW50ID0gbmV3IEV2ZW50KCdyZXNpemUnLCB7XG5cdFx0XHRcdFx0XHRcdGJ1YmJsZXM6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRjYW5jZWxhYmxlOiBmYWxzZVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkgeyAvLyBzdHVwaWQgSUVcblx0XHRcdFx0XHRcdHJlc2l6ZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcblx0XHRcdFx0XHRcdHJlc2l6ZUV2ZW50LmluaXRFdmVudChcInJlc2l6ZVwiLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfb3B0aW9ucy5jb250YWluZXIuZGlzcGF0Y2hFdmVudChyZXNpemVFdmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdF9zY2VuZU9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoc2NlbmUsIGluZGV4KSB7IC8vIHJlZnJlc2ggYWxsIHNjZW5lc1xuXHRcdFx0XHRzY2VuZS5yZWZyZXNoKCk7XG5cdFx0XHR9KTtcblx0XHRcdHNjaGVkdWxlUmVmcmVzaCgpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBTZW5kIGEgZGVidWcgbWVzc2FnZSB0byB0aGUgY29uc29sZS5cblx0XHQgKiBwcm92aWRlZCBwdWJsaWNseSB3aXRoIF9sb2cgZm9yIHBsdWdpbnNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGxvZ2xldmVsIC0gVGhlIGxvZ2xldmVsIHJlcXVpcmVkIHRvIGluaXRpYXRlIG91dHB1dCBmb3IgdGhlIG1lc3NhZ2UuXG5cdFx0ICogQHBhcmFtIHsuLi5taXhlZH0gb3V0cHV0IC0gT25lIG9yIG1vcmUgdmFyaWFibGVzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgY29uc29sZS5cblx0XHQgKi9cblx0XHR2YXIgbG9nID0gdGhpcy5fbG9nID0gZnVuY3Rpb24gKGxvZ2xldmVsLCBvdXRwdXQpIHtcblx0XHRcdGlmIChfb3B0aW9ucy5sb2dsZXZlbCA+PSBsb2dsZXZlbCkge1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAwLCBcIihcIiArIE5BTUVTUEFDRSArIFwiKSAtPlwiKTtcblx0XHRcdFx0X3V0aWwubG9nLmFwcGx5KHdpbmRvdywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdC8vIGZvciBzY2VuZXMgd2UgaGF2ZSBnZXR0ZXJzIGZvciBlYWNoIG9wdGlvbiwgYnV0IGZvciB0aGUgY29udHJvbGxlciB3ZSBkb24ndCwgc28gd2UgbmVlZCB0byBtYWtlIGl0IGF2YWlsYWJsZSBleHRlcm5hbGx5IGZvciBwbHVnaW5zXG5cdFx0dGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuXG5cdFx0LyoqXG5cdFx0ICogU29ydCBzY2VuZXMgaW4gYXNjZW5kaW5nIG9yZGVyIG9mIHRoZWlyIHN0YXJ0IG9mZnNldC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHthcnJheX0gU2NlbmVzQXJyYXkgLSBhbiBhcnJheSBvZiBTY3JvbGxNYWdpYyBTY2VuZXMgdGhhdCBzaG91bGQgYmUgc29ydGVkXG5cdFx0ICogQHJldHVybiB7YXJyYXl9IFRoZSBzb3J0ZWQgYXJyYXkgb2YgU2NlbmVzLlxuXHRcdCAqL1xuXHRcdHZhciBzb3J0U2NlbmVzID0gZnVuY3Rpb24gKFNjZW5lc0FycmF5KSB7XG5cdFx0XHRpZiAoU2NlbmVzQXJyYXkubGVuZ3RoIDw9IDEpIHtcblx0XHRcdFx0cmV0dXJuIFNjZW5lc0FycmF5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNjZW5lcyA9IFNjZW5lc0FycmF5LnNsaWNlKDApO1xuXHRcdFx0XHRzY2VuZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRcdHJldHVybiBhLnNjcm9sbE9mZnNldCgpID4gYi5zY3JvbGxPZmZzZXQoKSA/IDEgOiAtMTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBzY2VuZXM7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKiBwdWJsaWMgZnVuY3Rpb25zXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkIG9uZSBvcmUgbW9yZSBzY2VuZShzKSB0byB0aGUgY29udHJvbGxlci4gIFxuXHRcdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgdG8gYFNjZW5lLmFkZFRvKGNvbnRyb2xsZXIpYC5cblx0XHQgKiBAcHVibGljXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyB3aXRoIGEgcHJldmlvdXNseSBkZWZpbmVkIHNjZW5lXG5cdFx0ICogY29udHJvbGxlci5hZGRTY2VuZShzY2VuZSk7XG5cdFx0ICpcblx0XHQgKiAvLyB3aXRoIGEgbmV3bHkgY3JlYXRlZCBzY2VuZS5cblx0XHQgKiBjb250cm9sbGVyLmFkZFNjZW5lKG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7ZHVyYXRpb24gOiAwfSkpO1xuXHRcdCAqXG5cdFx0ICogLy8gYWRkaW5nIG11bHRpcGxlIHNjZW5lc1xuXHRcdCAqIGNvbnRyb2xsZXIuYWRkU2NlbmUoW3NjZW5lLCBzY2VuZTIsIG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7ZHVyYXRpb24gOiAwfSldKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7KFNjcm9sbE1hZ2ljLlNjZW5lfGFycmF5KX0gbmV3U2NlbmUgLSBTY3JvbGxNYWdpYyBTY2VuZSBvciBBcnJheSBvZiBTY2VuZXMgdG8gYmUgYWRkZWQgdG8gdGhlIGNvbnRyb2xsZXIuXG5cdFx0ICogQHJldHVybiB7Q29udHJvbGxlcn0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5hZGRTY2VuZSA9IGZ1bmN0aW9uIChuZXdTY2VuZSkge1xuXHRcdFx0aWYgKF91dGlsLnR5cGUuQXJyYXkobmV3U2NlbmUpKSB7XG5cdFx0XHRcdG5ld1NjZW5lLmZvckVhY2goZnVuY3Rpb24gKHNjZW5lLCBpbmRleCkge1xuXHRcdFx0XHRcdENvbnRyb2xsZXIuYWRkU2NlbmUoc2NlbmUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAobmV3U2NlbmUgaW5zdGFuY2VvZiBTY3JvbGxNYWdpYy5TY2VuZSkge1xuXHRcdFx0XHRpZiAobmV3U2NlbmUuY29udHJvbGxlcigpICE9PSBDb250cm9sbGVyKSB7XG5cdFx0XHRcdFx0bmV3U2NlbmUuYWRkVG8oQ29udHJvbGxlcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoX3NjZW5lT2JqZWN0cy5pbmRleE9mKG5ld1NjZW5lKSA8IDApIHtcblx0XHRcdFx0XHQvLyBuZXcgc2NlbmVcblx0XHRcdFx0XHRfc2NlbmVPYmplY3RzLnB1c2gobmV3U2NlbmUpOyAvLyBhZGQgdG8gYXJyYXlcblx0XHRcdFx0XHRfc2NlbmVPYmplY3RzID0gc29ydFNjZW5lcyhfc2NlbmVPYmplY3RzKTsgLy8gc29ydFxuXHRcdFx0XHRcdG5ld1NjZW5lLm9uKFwic2hpZnQuY29udHJvbGxlcl9zb3J0XCIsIGZ1bmN0aW9uICgpIHsgLy8gcmVzb3J0IHdoZW5ldmVyIHNjZW5lIG1vdmVzXG5cdFx0XHRcdFx0XHRfc2NlbmVPYmplY3RzID0gc29ydFNjZW5lcyhfc2NlbmVPYmplY3RzKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHQvLyBpbnNlcnQgR2xvYmFsIGRlZmF1bHRzLlxuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBfb3B0aW9ucy5nbG9iYWxTY2VuZU9wdGlvbnMpIHtcblx0XHRcdFx0XHRcdGlmIChuZXdTY2VuZVtrZXldKSB7XG5cdFx0XHRcdFx0XHRcdG5ld1NjZW5lW2tleV0uY2FsbChuZXdTY2VuZSwgX29wdGlvbnMuZ2xvYmFsU2NlbmVPcHRpb25zW2tleV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsb2coMywgXCJhZGRpbmcgU2NlbmUgKG5vdyBcIiArIF9zY2VuZU9iamVjdHMubGVuZ3RoICsgXCIgdG90YWwpXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsb2coMSwgXCJFUlJPUjogaW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCBmb3IgJy5hZGRTY2VuZSgpJ1wiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBDb250cm9sbGVyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgb25lIG9yZSBtb3JlIHNjZW5lKHMpIGZyb20gdGhlIGNvbnRyb2xsZXIuICBcblx0XHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IHRvIGBTY2VuZS5yZW1vdmUoKWAuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gcmVtb3ZlIGEgc2NlbmUgZnJvbSB0aGUgY29udHJvbGxlclxuXHRcdCAqIGNvbnRyb2xsZXIucmVtb3ZlU2NlbmUoc2NlbmUpO1xuXHRcdCAqXG5cdFx0ICogLy8gcmVtb3ZlIG11bHRpcGxlIHNjZW5lcyBmcm9tIHRoZSBjb250cm9sbGVyXG5cdFx0ICogY29udHJvbGxlci5yZW1vdmVTY2VuZShbc2NlbmUsIHNjZW5lMiwgc2NlbmUzXSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyhTY3JvbGxNYWdpYy5TY2VuZXxhcnJheSl9IFNjZW5lIC0gU2Nyb2xsTWFnaWMgU2NlbmUgb3IgQXJyYXkgb2YgU2NlbmVzIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgY29udHJvbGxlci5cblx0XHQgKiBAcmV0dXJucyB7Q29udHJvbGxlcn0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5yZW1vdmVTY2VuZSA9IGZ1bmN0aW9uIChTY2VuZSkge1xuXHRcdFx0aWYgKF91dGlsLnR5cGUuQXJyYXkoU2NlbmUpKSB7XG5cdFx0XHRcdFNjZW5lLmZvckVhY2goZnVuY3Rpb24gKHNjZW5lLCBpbmRleCkge1xuXHRcdFx0XHRcdENvbnRyb2xsZXIucmVtb3ZlU2NlbmUoc2NlbmUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IF9zY2VuZU9iamVjdHMuaW5kZXhPZihTY2VuZSk7XG5cdFx0XHRcdGlmIChpbmRleCA+IC0xKSB7XG5cdFx0XHRcdFx0U2NlbmUub2ZmKFwic2hpZnQuY29udHJvbGxlcl9zb3J0XCIpO1xuXHRcdFx0XHRcdF9zY2VuZU9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRsb2coMywgXCJyZW1vdmluZyBTY2VuZSAobm93IFwiICsgX3NjZW5lT2JqZWN0cy5sZW5ndGggKyBcIiBsZWZ0KVwiKTtcblx0XHRcdFx0XHRTY2VuZS5yZW1vdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIENvbnRyb2xsZXI7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSBvbmUgb3JlIG1vcmUgc2NlbmUocykgYWNjb3JkaW5nIHRvIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lci4gIFxuXHRcdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgdG8gYFNjZW5lLnVwZGF0ZSgpYC4gIFxuXHRcdCAqIFRoZSB1cGRhdGUgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIHNjZW5lJ3Mgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbiAoYmFzZWQgb24gdGhlIHRyaWdnZXIgZWxlbWVudCwgdHJpZ2dlciBob29rLCBkdXJhdGlvbiBhbmQgb2Zmc2V0KSBhbmQgY2hlY2tzIGl0IGFnYWluc3QgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIuICBcblx0XHQgKiBJdCB0aGVuIHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2NlbmUgc3RhdGUgYWNjb3JkaW5nbHkgKG9yIGRvZXMgbm90aGluZywgaWYgdGhlIHN0YXRlIGlzIGFscmVhZHkgY29ycmVjdCkg4oCTIFBpbnMgd2lsbCBiZSBzZXQgdG8gdGhlaXIgY29ycmVjdCBwb3NpdGlvbiBhbmQgdHdlZW5zIHdpbGwgYmUgdXBkYXRlZCB0byB0aGVpciBjb3JyZWN0IHByb2dyZXNzLiAgXG5cdFx0ICogXyoqTm90ZToqKiBUaGlzIG1ldGhvZCBnZXRzIGNhbGxlZCBjb25zdGFudGx5IHdoZW5ldmVyIENvbnRyb2xsZXIgZGV0ZWN0cyBhIGNoYW5nZS4gVGhlIG9ubHkgYXBwbGljYXRpb24gZm9yIHlvdSBpcyBpZiB5b3UgY2hhbmdlIHNvbWV0aGluZyBvdXRzaWRlIG9mIHRoZSByZWFsbSBvZiBTY3JvbGxNYWdpYywgbGlrZSBtb3ZpbmcgdGhlIHRyaWdnZXIgb3IgY2hhbmdpbmcgdHdlZW4gcGFyYW1ldGVycy5fXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gdXBkYXRlIGEgc3BlY2lmaWMgc2NlbmUgb24gbmV4dCBjeWNsZVxuXHRcdCAqIGNvbnRyb2xsZXIudXBkYXRlU2NlbmUoc2NlbmUpO1xuXHRcdCAqXG5cdFx0ICogLy8gdXBkYXRlIGEgc3BlY2lmaWMgc2NlbmUgaW1tZWRpYXRlbHlcblx0XHQgKiBjb250cm9sbGVyLnVwZGF0ZVNjZW5lKHNjZW5lLCB0cnVlKTtcblx0XHQgKlxuXHRcdCAqIC8vIHVwZGF0ZSBtdWx0aXBsZSBzY2VuZXMgc2NlbmUgb24gbmV4dCBjeWNsZVxuXHRcdCAqIGNvbnRyb2xsZXIudXBkYXRlU2NlbmUoW3NjZW5lMSwgc2NlbmUyLCBzY2VuZTNdKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U2Nyb2xsTWFnaWMuU2NlbmV9IFNjZW5lIC0gU2Nyb2xsTWFnaWMgU2NlbmUgb3IgQXJyYXkgb2YgU2NlbmVzIHRoYXQgaXMvYXJlIHN1cHBvc2VkIHRvIGJlIHVwZGF0ZWQuXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbaW1tZWRpYXRlbHk9ZmFsc2VdIC0gSWYgYHRydWVgIHRoZSB1cGRhdGUgd2lsbCBiZSBpbnN0YW50LCBpZiBgZmFsc2VgIGl0IHdpbGwgd2FpdCB1bnRpbCBuZXh0IHVwZGF0ZSBjeWNsZS4gIFxuXHRcdCBUaGlzIGlzIHVzZWZ1bCB3aGVuIGNoYW5naW5nIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgdGhlIHNjZW5lIC0gdGhpcyB3YXkgaXQgd2lsbCBvbmx5IGJlIHVwZGF0ZWQgb25jZSBhbGwgbmV3IHByb3BlcnRpZXMgYXJlIHNldCAodXBkYXRlU2NlbmVzKS5cblx0XHQgKiBAcmV0dXJuIHtDb250cm9sbGVyfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnVwZGF0ZVNjZW5lID0gZnVuY3Rpb24gKFNjZW5lLCBpbW1lZGlhdGVseSkge1xuXHRcdFx0aWYgKF91dGlsLnR5cGUuQXJyYXkoU2NlbmUpKSB7XG5cdFx0XHRcdFNjZW5lLmZvckVhY2goZnVuY3Rpb24gKHNjZW5lLCBpbmRleCkge1xuXHRcdFx0XHRcdENvbnRyb2xsZXIudXBkYXRlU2NlbmUoc2NlbmUsIGltbWVkaWF0ZWx5KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaW1tZWRpYXRlbHkpIHtcblx0XHRcdFx0XHRTY2VuZS51cGRhdGUodHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoX3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlICE9PSB0cnVlICYmIFNjZW5lIGluc3RhbmNlb2YgU2Nyb2xsTWFnaWMuU2NlbmUpIHsgLy8gaWYgX3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlIGlzIHRydWUsIGFsbCBjb25uZWN0ZWQgc2NlbmVzIGFyZSBhbHJlYWR5IHNjaGVkdWxlZCBmb3IgdXBkYXRlXG5cdFx0XHRcdFx0Ly8gcHJlcCBhcnJheSBmb3IgbmV4dCB1cGRhdGUgY3ljbGVcblx0XHRcdFx0XHRfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUgPSBfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUgfHwgW107XG5cdFx0XHRcdFx0aWYgKF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZS5pbmRleE9mKFNjZW5lKSA9PSAtMSkge1xuXHRcdFx0XHRcdFx0X3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlLnB1c2goU2NlbmUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUgPSBzb3J0U2NlbmVzKF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSk7IC8vIHNvcnRcblx0XHRcdFx0XHRkZWJvdW5jZVVwZGF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQ29udHJvbGxlcjtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgY29udHJvbGxlciBwYXJhbXMgYW5kIGNhbGxzIHVwZGF0ZVNjZW5lIG9uIGV2ZXJ5IHNjZW5lLCB0aGF0IGlzIGF0dGFjaGVkIHRvIHRoZSBjb250cm9sbGVyLiAgXG5cdFx0ICogU2VlIGBDb250cm9sbGVyLnVwZGF0ZVNjZW5lKClgIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgdGhpcyBtZWFucy4gIFxuXHRcdCAqIEluIG1vc3QgY2FzZXMgeW91IHdpbGwgbm90IG5lZWQgdGhpcyBmdW5jdGlvbiwgYXMgaXQgaXMgY2FsbGVkIGNvbnN0YW50bHksIHdoZW5ldmVyIFNjcm9sbE1hZ2ljIGRldGVjdHMgYSBzdGF0ZSBjaGFuZ2UgZXZlbnQsIGxpa2UgcmVzaXplIG9yIHNjcm9sbC4gIFxuXHRcdCAqIFRoZSBvbmx5IGFwcGxpY2F0aW9uIGZvciB0aGlzIG1ldGhvZCBpcyB3aGVuIFNjcm9sbE1hZ2ljIGZhaWxzIHRvIGRldGVjdCB0aGVzZSBldmVudHMuICBcblx0XHQgKiBPbmUgYXBwbGljYXRpb24gaXMgd2l0aCBzb21lIGV4dGVybmFsIHNjcm9sbCBsaWJyYXJpZXMgKGxpa2UgaVNjcm9sbCkgdGhhdCBtb3ZlIGFuIGludGVybmFsIGNvbnRhaW5lciB0byBhIG5lZ2F0aXZlIG9mZnNldCBpbnN0ZWFkIG9mIGFjdHVhbGx5IHNjcm9sbGluZy4gSW4gdGhpcyBjYXNlIHRoZSB1cGRhdGUgb24gdGhlIGNvbnRyb2xsZXIgbmVlZHMgdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBjaGlsZCBjb250YWluZXIncyBwb3NpdGlvbiBjaGFuZ2VzLlxuXHRcdCAqIEZvciB0aGlzIGNhc2UgdGhlcmUgd2lsbCBhbHNvIGJlIHRoZSBuZWVkIHRvIHByb3ZpZGUgYSBjdXN0b20gZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHNjcm9sbCBwb3NpdGlvbi4gU2VlIGBDb250cm9sbGVyLnNjcm9sbFBvcygpYCBmb3IgZGV0YWlscy5cblx0XHQgKiBAcHVibGljXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyB1cGRhdGUgdGhlIGNvbnRyb2xsZXIgb24gbmV4dCBjeWNsZSAoc2F2ZXMgcGVyZm9ybWFuY2UgZHVlIHRvIGVsaW1pbmF0aW9uIG9mIHJlZHVuZGFudCB1cGRhdGVzKVxuXHRcdCAqIGNvbnRyb2xsZXIudXBkYXRlKCk7XG5cdFx0ICpcblx0XHQgKiAvLyB1cGRhdGUgdGhlIGNvbnRyb2xsZXIgaW1tZWRpYXRlbHlcblx0XHQgKiBjb250cm9sbGVyLnVwZGF0ZSh0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbWVkaWF0ZWx5PWZhbHNlXSAtIElmIGB0cnVlYCB0aGUgdXBkYXRlIHdpbGwgYmUgaW5zdGFudCwgaWYgYGZhbHNlYCBpdCB3aWxsIHdhaXQgdW50aWwgbmV4dCB1cGRhdGUgY3ljbGUgKGJldHRlciBwZXJmb3JtYW5jZSlcblx0XHQgKiBAcmV0dXJuIHtDb250cm9sbGVyfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbW1lZGlhdGVseSkge1xuXHRcdFx0b25DaGFuZ2Uoe1xuXHRcdFx0XHR0eXBlOiBcInJlc2l6ZVwiXG5cdFx0XHR9KTsgLy8gd2lsbCB1cGRhdGUgc2l6ZSBhbmQgc2V0IF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSB0byB0cnVlXG5cdFx0XHRpZiAoaW1tZWRpYXRlbHkpIHtcblx0XHRcdFx0dXBkYXRlU2NlbmVzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQ29udHJvbGxlcjtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogU2Nyb2xsIHRvIGEgbnVtZXJpYyBzY3JvbGwgb2Zmc2V0LCBhIERPTSBlbGVtZW50LCB0aGUgc3RhcnQgb2YgYSBzY2VuZSBvciBwcm92aWRlIGFuIGFsdGVybmF0ZSBtZXRob2QgZm9yIHNjcm9sbGluZy4gIFxuXHRcdCAqIEZvciB2ZXJ0aWNhbCBjb250cm9sbGVycyBpdCB3aWxsIGNoYW5nZSB0aGUgdG9wIHNjcm9sbCBvZmZzZXQgYW5kIGZvciBob3Jpem9udGFsIGFwcGxpY2F0aW9ucyBpdCB3aWxsIGNoYW5nZSB0aGUgbGVmdCBvZmZzZXQuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqXG5cdFx0ICogQHNpbmNlIDEuMS4wXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBzY3JvbGwgdG8gYW4gb2Zmc2V0IG9mIDEwMFxuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsVG8oMTAwKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNjcm9sbCB0byBhIERPTSBlbGVtZW50XG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxUbyhcIiNhbmNob3JcIik7XG5cdFx0ICpcblx0XHQgKiAvLyBzY3JvbGwgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHNjZW5lXG5cdFx0ICogdmFyIHNjZW5lID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtvZmZzZXQ6IDIwMH0pO1xuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsVG8oc2NlbmUpO1xuXHRcdCAqXG5cdFx0ICogLy8gZGVmaW5lIGEgbmV3IHNjcm9sbCBwb3NpdGlvbiBtb2RpZmljYXRpb24gZnVuY3Rpb24gKGpRdWVyeSBhbmltYXRlIGluc3RlYWQgb2YganVtcClcblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFRvKGZ1bmN0aW9uIChuZXdTY3JvbGxQb3MpIHtcblx0XHQgKlx0JChcImh0bWwsIGJvZHlcIikuYW5pbWF0ZSh7c2Nyb2xsVG9wOiBuZXdTY3JvbGxQb3N9KTtcblx0XHQgKiB9KTtcblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFRvKDEwMCk7IC8vIGNhbGwgYXMgdXN1YWwsIGJ1dCB0aGUgbmV3IGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCBpbnN0ZWFkXG5cdFx0ICpcblx0XHQgKiAvLyBkZWZpbmUgYSBuZXcgc2Nyb2xsIGZ1bmN0aW9uIHdpdGggYW4gYWRkaXRpb25hbCBwYXJhbWV0ZXJcblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFRvKGZ1bmN0aW9uIChuZXdTY3JvbGxQb3MsIG1lc3NhZ2UpIHtcblx0XHQgKiAgY29uc29sZS5sb2cobWVzc2FnZSk7XG5cdFx0ICpcdCQodGhpcykuYW5pbWF0ZSh7c2Nyb2xsVG9wOiBuZXdTY3JvbGxQb3N9KTtcblx0XHQgKiB9KTtcblx0XHQgKiAvLyBjYWxsIGFzIHVzdWFsLCBidXQgc3VwcGx5IGFuIGV4dHJhIHBhcmFtZXRlciB0byB0aGUgZGVmaW5lZCBjdXN0b20gZnVuY3Rpb25cblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFRvKDEwMCwgXCJteSBtZXNzYWdlXCIpO1xuXHRcdCAqXG5cdFx0ICogLy8gZGVmaW5lIGEgbmV3IHNjcm9sbCBmdW5jdGlvbiB3aXRoIGFuIGFkZGl0aW9uYWwgcGFyYW1ldGVyIGNvbnRhaW5pbmcgbXVsdGlwbGUgdmFyaWFibGVzXG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxUbyhmdW5jdGlvbiAobmV3U2Nyb2xsUG9zLCBvcHRpb25zKSB7XG5cdFx0ICogIHNvbWVHbG9iYWxWYXIgPSBvcHRpb25zLmEgKyBvcHRpb25zLmI7XG5cdFx0ICpcdCQodGhpcykuYW5pbWF0ZSh7c2Nyb2xsVG9wOiBuZXdTY3JvbGxQb3N9KTtcblx0XHQgKiB9KTtcblx0XHQgKiAvLyBjYWxsIGFzIHVzdWFsLCBidXQgc3VwcGx5IGFuIGV4dHJhIHBhcmFtZXRlciBjb250YWluaW5nIG11bHRpcGxlIG9wdGlvbnNcblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFRvKDEwMCwge2E6IDEsIGI6IDJ9KTtcblx0XHQgKlxuXHRcdCAqIC8vIGRlZmluZSBhIG5ldyBzY3JvbGwgZnVuY3Rpb24gd2l0aCBhIGNhbGxiYWNrIHN1cHBsaWVkIGFzIGFuIGFkZGl0aW9uYWwgcGFyYW1ldGVyXG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxUbyhmdW5jdGlvbiAobmV3U2Nyb2xsUG9zLCBjYWxsYmFjaykge1xuXHRcdCAqXHQkKHRoaXMpLmFuaW1hdGUoe3Njcm9sbFRvcDogbmV3U2Nyb2xsUG9zfSwgNDAwLCBcInN3aW5nXCIsIGNhbGxiYWNrKTtcblx0XHQgKiB9KTtcblx0XHQgKiAvLyBjYWxsIGFzIHVzdWFsLCBidXQgc3VwcGx5IGFuIGV4dHJhIHBhcmFtZXRlciwgd2hpY2ggaXMgdXNlZCBhcyBhIGNhbGxiYWNrIGluIHRoZSBwcmV2aW91c2x5IGRlZmluZWQgY3VzdG9tIHNjcm9sbCBmdW5jdGlvblxuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsVG8oMTAwLCBmdW5jdGlvbigpIHtcblx0XHQgKlx0Y29uc29sZS5sb2coXCJzY3JvbGwgaGFzIGZpbmlzaGVkLlwiKTtcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IHNjcm9sbFRhcmdldCAtIFRoZSBzdXBwbGllZCBhcmd1bWVudCBjYW4gYmUgb25lIG9mIHRoZXNlIHR5cGVzOlxuXHRcdCAqIDEuIGBudW1iZXJgIC0+IFRoZSBjb250YWluZXIgd2lsbCBzY3JvbGwgdG8gdGhpcyBuZXcgc2Nyb2xsIG9mZnNldC5cblx0XHQgKiAyLiBgc3RyaW5nYCBvciBgb2JqZWN0YCAtPiBDYW4gYmUgYSBzZWxlY3RvciBvciBhIERPTSBvYmplY3QuICBcblx0XHQgKiAgVGhlIGNvbnRhaW5lciB3aWxsIHNjcm9sbCB0byB0aGUgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50LlxuXHRcdCAqIDMuIGBTY3JvbGxNYWdpYyBTY2VuZWAgLT4gVGhlIGNvbnRhaW5lciB3aWxsIHNjcm9sbCB0byB0aGUgc3RhcnQgb2YgdGhpcyBzY2VuZS5cblx0XHQgKiA0LiBgZnVuY3Rpb25gIC0+IFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGZvciBmdXR1cmUgc2Nyb2xsIHBvc2l0aW9uIG1vZGlmaWNhdGlvbnMuICBcblx0XHQgKiAgVGhpcyBwcm92aWRlcyBhIHdheSBmb3IgeW91IHRvIGNoYW5nZSB0aGUgYmVoYXZpb3VyIG9mIHNjcm9sbGluZyBhbmQgYWRkaW5nIG5ldyBiZWhhdmlvdXIgbGlrZSBhbmltYXRpb24uIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgbmV3IHNjcm9sbCBwb3NpdGlvbiBhcyBhIHBhcmFtZXRlciBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIGNvbnRhaW5lciBlbGVtZW50IHVzaW5nIGB0aGlzYC4gIFxuXHRcdCAqICBJdCBtYXkgYWxzbyBvcHRpb25hbGx5IHJlY2VpdmUgYW4gb3B0aW9uYWwgYWRkaXRpb25hbCBwYXJhbWV0ZXIgKHNlZSBiZWxvdykgIFxuXHRcdCAqICBfKipOT1RFOioqICBcblx0XHQgKiAgQWxsIG90aGVyIG9wdGlvbnMgd2lsbCBzdGlsbCB3b3JrIGFzIGV4cGVjdGVkLCB1c2luZyB0aGUgbmV3IGZ1bmN0aW9uIHRvIHNjcm9sbC5fXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gW2FkZGl0aW9uYWxQYXJhbWV0ZXJdIC0gSWYgYSBjdXN0b20gc2Nyb2xsIGZ1bmN0aW9uIHdhcyBkZWZpbmVkIChzZWUgYWJvdmUgNC4pLCB5b3UgbWF5IHdhbnQgdG8gc3VwcGx5IGFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byBpdCwgd2hlbiBjYWxsaW5nIGl0LiBZb3UgY2FuIGRvIHRoaXMgdXNpbmcgdGhpcyBwYXJhbWV0ZXIg4oCTIHNlZSBleGFtcGxlcyBmb3IgZGV0YWlscy4gUGxlYXNlIG5vdGUsIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBoYXZlIG5vIGVmZmVjdCwgaWYgeW91IHVzZSB0aGUgZGVmYXVsdCBzY3JvbGxpbmcgZnVuY3Rpb24uXG5cdFx0ICogQHJldHVybnMge0NvbnRyb2xsZXJ9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMuc2Nyb2xsVG8gPSBmdW5jdGlvbiAoc2Nyb2xsVGFyZ2V0LCBhZGRpdGlvbmFsUGFyYW1ldGVyKSB7XG5cdFx0XHRpZiAoX3V0aWwudHlwZS5OdW1iZXIoc2Nyb2xsVGFyZ2V0KSkgeyAvLyBleGNlY3V0ZVxuXHRcdFx0XHRzZXRTY3JvbGxQb3MuY2FsbChfb3B0aW9ucy5jb250YWluZXIsIHNjcm9sbFRhcmdldCwgYWRkaXRpb25hbFBhcmFtZXRlcik7XG5cdFx0XHR9IGVsc2UgaWYgKHNjcm9sbFRhcmdldCBpbnN0YW5jZW9mIFNjcm9sbE1hZ2ljLlNjZW5lKSB7IC8vIHNjcm9sbCB0byBzY2VuZVxuXHRcdFx0XHRpZiAoc2Nyb2xsVGFyZ2V0LmNvbnRyb2xsZXIoKSA9PT0gQ29udHJvbGxlcikgeyAvLyBjaGVjayBpZiB0aGUgY29udHJvbGxlciBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBzY2VuZVxuXHRcdFx0XHRcdENvbnRyb2xsZXIuc2Nyb2xsVG8oc2Nyb2xsVGFyZ2V0LnNjcm9sbE9mZnNldCgpLCBhZGRpdGlvbmFsUGFyYW1ldGVyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2coMiwgXCJzY3JvbGxUbygpOiBUaGUgc3VwcGxpZWQgc2NlbmUgZG9lcyBub3QgYmVsb25nIHRvIHRoaXMgY29udHJvbGxlci4gU2Nyb2xsIGNhbmNlbGxlZC5cIiwgc2Nyb2xsVGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChfdXRpbC50eXBlLkZ1bmN0aW9uKHNjcm9sbFRhcmdldCkpIHsgLy8gYXNzaWduIG5ldyBzY3JvbGwgZnVuY3Rpb25cblx0XHRcdFx0c2V0U2Nyb2xsUG9zID0gc2Nyb2xsVGFyZ2V0O1xuXHRcdFx0fSBlbHNlIHsgLy8gc2Nyb2xsIHRvIGVsZW1lbnRcblx0XHRcdFx0dmFyIGVsZW0gPSBfdXRpbC5nZXQuZWxlbWVudHMoc2Nyb2xsVGFyZ2V0KVswXTtcblx0XHRcdFx0aWYgKGVsZW0pIHtcblx0XHRcdFx0XHQvLyBpZiBwYXJlbnQgaXMgcGluIHNwYWNlciwgdXNlIHNwYWNlciBwb3NpdGlvbiBpbnN0ZWFkIHNvIGNvcnJlY3Qgc3RhcnQgcG9zaXRpb24gaXMgcmV0dXJuZWQgZm9yIHBpbm5lZCBlbGVtZW50cy5cblx0XHRcdFx0XHR3aGlsZSAoZWxlbS5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShQSU5fU1BBQ0VSX0FUVFJJQlVURSkpIHtcblx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0cGFyYW0gPSBfb3B0aW9ucy52ZXJ0aWNhbCA/IFwidG9wXCIgOiBcImxlZnRcIixcblx0XHRcdFx0XHRcdC8vIHdoaWNoIHBhcmFtIGlzIG9mIGludGVyZXN0ID9cblx0XHRcdFx0XHRcdGNvbnRhaW5lck9mZnNldCA9IF91dGlsLmdldC5vZmZzZXQoX29wdGlvbnMuY29udGFpbmVyKSxcblx0XHRcdFx0XHRcdC8vIGNvbnRhaW5lciBwb3NpdGlvbiBpcyBuZWVkZWQgYmVjYXVzZSBlbGVtZW50IG9mZnNldCBpcyByZXR1cm5lZCBpbiByZWxhdGlvbiB0byBkb2N1bWVudCwgbm90IGluIHJlbGF0aW9uIHRvIGNvbnRhaW5lci5cblx0XHRcdFx0XHRcdGVsZW1lbnRPZmZzZXQgPSBfdXRpbC5nZXQub2Zmc2V0KGVsZW0pO1xuXG5cdFx0XHRcdFx0aWYgKCFfaXNEb2N1bWVudCkgeyAvLyBjb250YWluZXIgaXMgbm90IHRoZSBkb2N1bWVudCByb290LCBzbyBzdWJzdHJhY3Qgc2Nyb2xsIFBvc2l0aW9uIHRvIGdldCBjb3JyZWN0IHRyaWdnZXIgZWxlbWVudCBwb3NpdGlvbiByZWxhdGl2ZSB0byBzY3JvbGxjb250ZW50XG5cdFx0XHRcdFx0XHRjb250YWluZXJPZmZzZXRbcGFyYW1dIC09IENvbnRyb2xsZXIuc2Nyb2xsUG9zKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Q29udHJvbGxlci5zY3JvbGxUbyhlbGVtZW50T2Zmc2V0W3BhcmFtXSAtIGNvbnRhaW5lck9mZnNldFtwYXJhbV0sIGFkZGl0aW9uYWxQYXJhbWV0ZXIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxvZygyLCBcInNjcm9sbFRvKCk6IFRoZSBzdXBwbGllZCBhcmd1bWVudCBpcyBpbnZhbGlkLiBTY3JvbGwgY2FuY2VsbGVkLlwiLCBzY3JvbGxUYXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQ29udHJvbGxlcjtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiB0aGUgY3VycmVudCBzY3JvbGxQb3NpdGlvbiBvciAqKlNldCoqIGEgbmV3IG1ldGhvZCB0byBjYWxjdWxhdGUgaXQuICBcblx0XHQgKiAtPiAqKkdFVCoqOlxuXHRcdCAqIFdoZW4gdXNlZCBhcyBhIGdldHRlciB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbi4gIFxuXHRcdCAqIFRvIGdldCBhIGNhY2hlZCB2YWx1ZSB1c2UgQ29udHJvbGxlci5pbmZvKFwic2Nyb2xsUG9zXCIpLCB3aGljaCB3aWxsIGJlIHVwZGF0ZWQgaW4gdGhlIHVwZGF0ZSBjeWNsZS4gIFxuXHRcdCAqIEZvciB2ZXJ0aWNhbCBjb250cm9sbGVycyBpdCB3aWxsIHJldHVybiB0aGUgdG9wIHNjcm9sbCBvZmZzZXQgYW5kIGZvciBob3Jpem9udGFsIGFwcGxpY2F0aW9ucyBpdCB3aWxsIHJldHVybiB0aGUgbGVmdCBvZmZzZXQuXG5cdFx0ICpcblx0XHQgKiAtPiAqKlNFVCoqOlxuXHRcdCAqIFdoZW4gdXNlZCBhcyBhIHNldHRlciB0aGlzIG1ldGhvZCBwcm9kZXMgYSB3YXkgdG8gcGVybWFuZW50bHkgb3ZlcndyaXRlIHRoZSBjb250cm9sbGVyJ3Mgc2Nyb2xsIHBvc2l0aW9uIGNhbGN1bGF0aW9uLiAgXG5cdFx0ICogQSB0eXBpY2FsIHVzZWNhc2UgaXMgd2hlbiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIG5vdCByZWZsZWN0ZWQgYnkgdGhlIGNvbnRhaW5lcnMgc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQgdmFsdWVzLCBidXQgZm9yIGV4YW1wbGUgYnkgdGhlIGlubmVyIG9mZnNldCBvZiBhIGNoaWxkIGNvbnRhaW5lci4gIFxuXHRcdCAqIE1vdmluZyBhIGNoaWxkIGNvbnRhaW5lciBpbnNpZGUgYSBwYXJlbnQgaXMgYSBjb21tb25seSB1c2VkIG1ldGhvZCBmb3Igc2V2ZXJhbCBzY3JvbGxpbmcgZnJhbWV3b3JrcywgaW5jbHVkaW5nIGlTY3JvbGwuICBcblx0XHQgKiBCeSBwcm92aWRpbmcgYW4gYWx0ZXJuYXRlIGNhbGN1bGF0aW9uIGZ1bmN0aW9uIHlvdSBjYW4gbWFrZSBzdXJlIFNjcm9sbE1hZ2ljIHJlY2VpdmVzIHRoZSBjb3JyZWN0IHNjcm9sbCBwb3NpdGlvbi4gIFxuXHRcdCAqIFBsZWFzZSBhbHNvIGJlYXIgaW4gbWluZCB0aGF0IHlvdXIgZnVuY3Rpb24gc2hvdWxkIHJldHVybiB5IHZhbHVlcyBmb3IgdmVydGljYWwgc2Nyb2xscyBhbiB4IGZvciBob3Jpem9udGFscy5cblx0XHQgKlxuXHRcdCAqIFRvIGNoYW5nZSB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gcGxlYXNlIHVzZSBgQ29udHJvbGxlci5zY3JvbGxUbygpYC5cblx0XHQgKiBAcHVibGljXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCBzY3JvbGwgUG9zaXRpb25cblx0XHQgKiB2YXIgc2Nyb2xsUG9zID0gY29udHJvbGxlci5zY3JvbGxQb3MoKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNldCBhIG5ldyBzY3JvbGwgcG9zaXRpb24gY2FsY3VsYXRpb24gbWV0aG9kXG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxQb3MoZnVuY3Rpb24gKCkge1xuXHRcdCAqXHRyZXR1cm4gdGhpcy5pbmZvKFwidmVydGljYWxcIikgPyAtbXljaGlsZGNvbnRhaW5lci55IDogLW15Y2hpbGRjb250YWluZXIueFxuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW3Njcm9sbFBvc01ldGhvZF0gLSBUaGUgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgdGhlIHNjcm9sbCBwb3NpdGlvbiBjYWxjdWxhdGlvbiBvZiB0aGUgY29udGFpbmVyLlxuXHRcdCAqIEByZXR1cm5zIHsobnVtYmVyfENvbnRyb2xsZXIpfSBDdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBvciBwYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnNjcm9sbFBvcyA9IGZ1bmN0aW9uIChzY3JvbGxQb3NNZXRob2QpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkgeyAvLyBnZXRcblx0XHRcdFx0cmV0dXJuIGdldFNjcm9sbFBvcy5jYWxsKENvbnRyb2xsZXIpO1xuXHRcdFx0fSBlbHNlIHsgLy8gc2V0XG5cdFx0XHRcdGlmIChfdXRpbC50eXBlLkZ1bmN0aW9uKHNjcm9sbFBvc01ldGhvZCkpIHtcblx0XHRcdFx0XHRnZXRTY3JvbGxQb3MgPSBzY3JvbGxQb3NNZXRob2Q7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bG9nKDIsIFwiUHJvdmlkZWQgdmFsdWUgZm9yIG1ldGhvZCAnc2Nyb2xsUG9zJyBpcyBub3QgYSBmdW5jdGlvbi4gVG8gY2hhbmdlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiB1c2UgJ3Njcm9sbFRvKCknLlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIENvbnRyb2xsZXI7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0KiogYWxsIGluZm9zIG9yIG9uZSBpbiBwYXJ0aWN1bGFyIGFib3V0IHRoZSBjb250cm9sbGVyLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHJldHVybnMgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIChudW1iZXIpXG5cdFx0ICogdmFyIHNjcm9sbFBvcyA9IGNvbnRyb2xsZXIuaW5mbyhcInNjcm9sbFBvc1wiKTtcblx0XHQgKlxuXHRcdCAqIC8vIHJldHVybnMgYWxsIGluZm9zIGFzIGFuIG9iamVjdFxuXHRcdCAqIHZhciBpbmZvcyA9IGNvbnRyb2xsZXIuaW5mbygpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFthYm91dF0gLSBJZiBwYXNzZWQgb25seSB0aGlzIGluZm8gd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIG9iamVjdCBjb250YWluaW5nIGFsbC4gIFxuXHRcdCBWYWxpZCBvcHRpb25zIGFyZTpcblx0XHQgKiogYFwic2l6ZVwiYCA9PiB0aGUgY3VycmVudCB2aWV3cG9ydCBzaXplIG9mIHRoZSBjb250YWluZXJcblx0XHQgKiogYFwidmVydGljYWxcImAgPT4gdHJ1ZSBpZiB2ZXJ0aWNhbCBzY3JvbGxpbmcsIG90aGVyd2lzZSBmYWxzZVxuXHRcdCAqKiBgXCJzY3JvbGxQb3NcImAgPT4gdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG5cdFx0ICoqIGBcInNjcm9sbERpcmVjdGlvblwiYCA9PiB0aGUgbGFzdCBrbm93biBkaXJlY3Rpb24gb2YgdGhlIHNjcm9sbFxuXHRcdCAqKiBgXCJjb250YWluZXJcImAgPT4gdGhlIGNvbnRhaW5lciBlbGVtZW50XG5cdFx0ICoqIGBcImlzRG9jdW1lbnRcImAgPT4gdHJ1ZSBpZiBjb250YWluZXIgZWxlbWVudCBpcyB0aGUgZG9jdW1lbnQuXG5cdFx0ICogQHJldHVybnMgeyhtaXhlZHxvYmplY3QpfSBUaGUgcmVxdWVzdGVkIGluZm8ocykuXG5cdFx0ICovXG5cdFx0dGhpcy5pbmZvID0gZnVuY3Rpb24gKGFib3V0KSB7XG5cdFx0XHR2YXIgdmFsdWVzID0ge1xuXHRcdFx0XHRzaXplOiBfdmlld1BvcnRTaXplLFxuXHRcdFx0XHQvLyBjb250YWlucyBoZWlnaHQgb3Igd2lkdGggKGluIHJlZ2FyZCB0byBvcmllbnRhdGlvbik7XG5cdFx0XHRcdHZlcnRpY2FsOiBfb3B0aW9ucy52ZXJ0aWNhbCxcblx0XHRcdFx0c2Nyb2xsUG9zOiBfc2Nyb2xsUG9zLFxuXHRcdFx0XHRzY3JvbGxEaXJlY3Rpb246IF9zY3JvbGxEaXJlY3Rpb24sXG5cdFx0XHRcdGNvbnRhaW5lcjogX29wdGlvbnMuY29udGFpbmVyLFxuXHRcdFx0XHRpc0RvY3VtZW50OiBfaXNEb2N1bWVudFxuXHRcdFx0fTtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkgeyAvLyBnZXQgYWxsIGFzIGFuIG9iamVjdFxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZXNbYWJvdXRdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlc1thYm91dF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsb2coMSwgXCJFUlJPUjogb3B0aW9uIFxcXCJcIiArIGFib3V0ICsgXCJcXFwiIGlzIG5vdCBhdmFpbGFibGVcIik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiBvciAqKlNldCoqIHRoZSBjdXJyZW50IGxvZ2xldmVsIG9wdGlvbiB2YWx1ZS5cblx0XHQgKiBAcHVibGljXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCB2YWx1ZVxuXHRcdCAqIHZhciBsb2dsZXZlbCA9IGNvbnRyb2xsZXIubG9nbGV2ZWwoKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNldCBhIG5ldyB2YWx1ZVxuXHRcdCAqIGNvbnRyb2xsZXIubG9nbGV2ZWwoMyk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gW25ld0xvZ2xldmVsXSAtIFRoZSBuZXcgbG9nbGV2ZWwgc2V0dGluZyBvZiB0aGUgQ29udHJvbGxlci4gYFswLTNdYFxuXHRcdCAqIEByZXR1cm5zIHsobnVtYmVyfENvbnRyb2xsZXIpfSBDdXJyZW50IGxvZ2xldmVsIG9yIHBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMubG9nbGV2ZWwgPSBmdW5jdGlvbiAobmV3TG9nbGV2ZWwpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkgeyAvLyBnZXRcblx0XHRcdFx0cmV0dXJuIF9vcHRpb25zLmxvZ2xldmVsO1xuXHRcdFx0fSBlbHNlIGlmIChfb3B0aW9ucy5sb2dsZXZlbCAhPSBuZXdMb2dsZXZlbCkgeyAvLyBzZXRcblx0XHRcdFx0X29wdGlvbnMubG9nbGV2ZWwgPSBuZXdMb2dsZXZlbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBDb250cm9sbGVyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIG9yICoqU2V0KiogdGhlIGN1cnJlbnQgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgY29udHJvbGxlci4gIFxuXHRcdCAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGlzYWJsZSBhbGwgU2NlbmVzIGNvbm5lY3RlZCB0byB0aGUgY29udHJvbGxlciB3aXRob3V0IGRlc3Ryb3lpbmcgb3IgcmVtb3ZpbmcgdGhlbS5cblx0XHQgKiBAcHVibGljXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCB2YWx1ZVxuXHRcdCAqIHZhciBlbmFibGVkID0gY29udHJvbGxlci5lbmFibGVkKCk7XG5cdFx0ICpcblx0XHQgKiAvLyBkaXNhYmxlIHRoZSBjb250cm9sbGVyXG5cdFx0ICogY29udHJvbGxlci5lbmFibGVkKGZhbHNlKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW25ld1N0YXRlXSAtIFRoZSBuZXcgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgY29udHJvbGxlciBgdHJ1ZWAgb3IgYGZhbHNlYC5cblx0XHQgKiBAcmV0dXJucyB7KGJvb2xlYW58Q29udHJvbGxlcil9IEN1cnJlbnQgZW5hYmxlZCBzdGF0ZSBvciBwYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLmVuYWJsZWQgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkgeyAvLyBnZXRcblx0XHRcdFx0cmV0dXJuIF9lbmFibGVkO1xuXHRcdFx0fSBlbHNlIGlmIChfZW5hYmxlZCAhPSBuZXdTdGF0ZSkgeyAvLyBzZXRcblx0XHRcdFx0X2VuYWJsZWQgPSAhISBuZXdTdGF0ZTtcblx0XHRcdFx0Q29udHJvbGxlci51cGRhdGVTY2VuZShfc2NlbmVPYmplY3RzLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBDb250cm9sbGVyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95IHRoZSBDb250cm9sbGVyLCBhbGwgU2NlbmVzIGFuZCBldmVyeXRoaW5nLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gd2l0aG91dCByZXNldHRpbmcgdGhlIHNjZW5lc1xuXHRcdCAqIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyLmRlc3Ryb3koKTtcblx0XHQgKlxuXHRcdCAqIC8vIHdpdGggc2NlbmUgcmVzZXRcblx0XHQgKiBjb250cm9sbGVyID0gY29udHJvbGxlci5kZXN0cm95KHRydWUpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbcmVzZXRTY2VuZXM9ZmFsc2VdIC0gSWYgYHRydWVgIHRoZSBwaW5zIGFuZCB0d2VlbnMgKGlmIGV4aXN0ZW50KSBvZiBhbGwgc2NlbmVzIHdpbGwgYmUgcmVzZXQuXG5cdFx0ICogQHJldHVybnMge251bGx9IE51bGwgdG8gdW5zZXQgaGFuZGxlciB2YXJpYWJsZXMuXG5cdFx0ICovXG5cdFx0dGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKHJlc2V0U2NlbmVzKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KF9yZWZyZXNoVGltZW91dCk7XG5cdFx0XHR2YXIgaSA9IF9zY2VuZU9iamVjdHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRfc2NlbmVPYmplY3RzW2ldLmRlc3Ryb3kocmVzZXRTY2VuZXMpO1xuXHRcdFx0fVxuXHRcdFx0X29wdGlvbnMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25DaGFuZ2UpO1xuXHRcdFx0X29wdGlvbnMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgb25DaGFuZ2UpO1xuXHRcdFx0X3V0aWwuY0FGKF91cGRhdGVUaW1lb3V0KTtcblx0XHRcdGxvZygzLCBcImRlc3Ryb3llZCBcIiArIE5BTUVTUEFDRSArIFwiIChyZXNldDogXCIgKyAocmVzZXRTY2VuZXMgPyBcInRydWVcIiA6IFwiZmFsc2VcIikgKyBcIilcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXG5cdFx0Ly8gSU5JVFxuXHRcdGNvbnN0cnVjdCgpO1xuXHRcdHJldHVybiBDb250cm9sbGVyO1xuXHR9O1xuXG5cdC8vIHN0b3JlIHBhZ2V3aWRlIGNvbnRyb2xsZXIgb3B0aW9uc1xuXHR2YXIgQ09OVFJPTExFUl9PUFRJT05TID0ge1xuXHRcdGRlZmF1bHRzOiB7XG5cdFx0XHRjb250YWluZXI6IHdpbmRvdyxcblx0XHRcdHZlcnRpY2FsOiB0cnVlLFxuXHRcdFx0Z2xvYmFsU2NlbmVPcHRpb25zOiB7fSxcblx0XHRcdGxvZ2xldmVsOiAyLFxuXHRcdFx0cmVmcmVzaEludGVydmFsOiAxMDBcblx0XHR9XG5cdH07XG4vKlxuICogbWV0aG9kIHVzZWQgdG8gYWRkIGFuIG9wdGlvbiB0byBTY3JvbGxNYWdpYyBTY2VuZXMuXG4gKi9cblx0U2Nyb2xsTWFnaWMuQ29udHJvbGxlci5hZGRPcHRpb24gPSBmdW5jdGlvbiAobmFtZSwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0Q09OVFJPTExFUl9PUFRJT05TLmRlZmF1bHRzW25hbWVdID0gZGVmYXVsdFZhbHVlO1xuXHR9O1xuXHQvLyBpbnN0YW5jZSBleHRlbnNpb24gZnVuY3Rpb24gZm9yIHBsdWdpbnNcblx0U2Nyb2xsTWFnaWMuQ29udHJvbGxlci5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG5cdFx0dmFyIG9sZENsYXNzID0gdGhpcztcblx0XHRTY3JvbGxNYWdpYy5Db250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0b2xkQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuJHN1cGVyID0gX3V0aWwuZXh0ZW5kKHt9LCB0aGlzKTsgLy8gY29weSBwYXJlbnQgc3RhdGVcblx0XHRcdHJldHVybiBleHRlbnNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHRcdH07XG5cdFx0X3V0aWwuZXh0ZW5kKFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIsIG9sZENsYXNzKTsgLy8gY29weSBwcm9wZXJ0aWVzXG5cdFx0U2Nyb2xsTWFnaWMuQ29udHJvbGxlci5wcm90b3R5cGUgPSBvbGRDbGFzcy5wcm90b3R5cGU7IC8vIGNvcHkgcHJvdG90eXBlXG5cdFx0U2Nyb2xsTWFnaWMuQ29udHJvbGxlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY3JvbGxNYWdpYy5Db250cm9sbGVyOyAvLyByZXN0b3JlIGNvbnN0cnVjdG9yXG5cdH07XG5cblxuXHQvKipcblx0ICogQSBTY2VuZSBkZWZpbmVzIHdoZXJlIHRoZSBjb250cm9sbGVyIHNob3VsZCByZWFjdCBhbmQgaG93LlxuXHQgKlxuXHQgKiBAY2xhc3Ncblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogLy8gY3JlYXRlIGEgc3RhbmRhcmQgc2NlbmUgYW5kIGFkZCBpdCB0byBhIGNvbnRyb2xsZXJcblx0ICogbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKClcblx0ICpcdFx0LmFkZFRvKGNvbnRyb2xsZXIpO1xuXHQgKlxuXHQgKiAvLyBjcmVhdGUgYSBzY2VuZSB3aXRoIGN1c3RvbSBvcHRpb25zIGFuZCBhc3NpZ24gYSBoYW5kbGVyIHRvIGl0LlxuXHQgKiB2YXIgc2NlbmUgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe1xuXHQgKiBcdFx0ZHVyYXRpb246IDEwMCxcblx0ICpcdFx0b2Zmc2V0OiAyMDAsXG5cdCAqXHRcdHRyaWdnZXJIb29rOiBcIm9uRW50ZXJcIixcblx0ICpcdFx0cmV2ZXJzZTogZmFsc2Vcblx0ICogfSk7XG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciB0aGUgU2NlbmUuIFRoZSBvcHRpb25zIGNhbiBiZSB1cGRhdGVkIGF0IGFueSB0aW1lLiAgXG5cdCBJbnN0ZWFkIG9mIHNldHRpbmcgdGhlIG9wdGlvbnMgZm9yIGVhY2ggc2NlbmUgaW5kaXZpZHVhbGx5IHlvdSBjYW4gYWxzbyBzZXQgdGhlbSBnbG9iYWxseSBpbiB0aGUgY29udHJvbGxlciBhcyB0aGUgY29udHJvbGxlcnMgYGdsb2JhbFNjZW5lT3B0aW9uc2Agb3B0aW9uLiBUaGUgb2JqZWN0IGFjY2VwdHMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyB0aGUgb25lcyBiZWxvdy4gIFxuXHQgV2hlbiBhIHNjZW5lIGlzIGFkZGVkIHRvIHRoZSBjb250cm9sbGVyIHRoZSBvcHRpb25zIGRlZmluZWQgdXNpbmcgdGhlIFNjZW5lIGNvbnN0cnVjdG9yIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhvc2Ugc2V0IGluIGBnbG9iYWxTY2VuZU9wdGlvbnNgLlxuXHQgKiBAcGFyYW0geyhudW1iZXJ8ZnVuY3Rpb24pfSBbb3B0aW9ucy5kdXJhdGlvbj0wXSAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgc2NlbmUuIFxuXHQgSWYgYDBgIHR3ZWVucyB3aWxsIGF1dG8tcGxheSB3aGVuIHJlYWNoaW5nIHRoZSBzY2VuZSBzdGFydCBwb2ludCwgcGlucyB3aWxsIGJlIHBpbm5lZCBpbmRlZmluZXRseSBzdGFydGluZyBhdCB0aGUgc3RhcnQgcG9zaXRpb24uICBcblx0IEEgZnVuY3Rpb24gcmV0dW5pbmcgdGhlIGR1cmF0aW9uIHZhbHVlIGlzIGFsc28gc3VwcG9ydGVkLiBQbGVhc2Ugc2VlIGBTY2VuZS5kdXJhdGlvbigpYCBmb3IgZGV0YWlscy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm9mZnNldD0wXSAtIE9mZnNldCBWYWx1ZSBmb3IgdGhlIFRyaWdnZXIgUG9zaXRpb24uIElmIG5vIHRyaWdnZXJFbGVtZW50IGlzIGRlZmluZWQgdGhpcyB3aWxsIGJlIHRoZSBzY3JvbGwgZGlzdGFuY2UgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhZ2UsIGFmdGVyIHdoaWNoIHRoZSBzY2VuZSB3aWxsIHN0YXJ0LlxuXHQgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gW29wdGlvbnMudHJpZ2dlckVsZW1lbnQ9bnVsbF0gLSBTZWxlY3RvciBvciBET00gb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgc3RhcnQgb2YgdGhlIHNjZW5lLiBJZiB1bmRlZmluZWQgdGhlIHNjZW5lIHdpbGwgc3RhcnQgcmlnaHQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYWdlICh1bmxlc3MgYW4gb2Zmc2V0IGlzIHNldCkuXG5cdCAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBbb3B0aW9ucy50cmlnZ2VySG9vaz1cIm9uQ2VudGVyXCJdIC0gQ2FuIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBkZWZpbmluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHRyaWdnZXIgSG9vayBpbiByZWxhdGlvbiB0byB0aGUgdmlld3BvcnQuICBcblx0IENhbiBhbHNvIGJlIGRlZmluZWQgdXNpbmcgYSBzdHJpbmc6XG5cdCAqKiBgXCJvbkVudGVyXCJgID0+IGAxYFxuXHQgKiogYFwib25DZW50ZXJcImAgPT4gYDAuNWBcblx0ICoqIGBcIm9uTGVhdmVcImAgPT4gYDBgXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV2ZXJzZT10cnVlXSAtIFNob3VsZCB0aGUgc2NlbmUgcmV2ZXJzZSwgd2hlbiBzY3JvbGxpbmcgdXA/XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sb2dsZXZlbD0yXSAtIExvZ2xldmVsIGZvciBkZWJ1Z2dpbmcuIE5vdGUgdGhhdCBsb2dnaW5nIGlzIGRpc2FibGVkIGluIHRoZSBtaW5pZmllZCB2ZXJzaW9uIG9mIFNjcm9sbE1hZ2ljLlxuXHQgKiogYDBgID0+IHNpbGVudFxuXHQgKiogYDFgID0+IGVycm9yc1xuXHQgKiogYDJgID0+IGVycm9ycywgd2FybmluZ3Ncblx0ICoqIGAzYCA9PiBlcnJvcnMsIHdhcm5pbmdzLCBkZWJ1Z2luZm9cblx0ICogXG5cdCAqL1xuXHRTY3JvbGxNYWdpYy5TY2VuZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbi8qXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogc2V0dGluZ3Ncblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKi9cblxuXHRcdHZhclxuXHRcdE5BTUVTUEFDRSA9ICdTY3JvbGxNYWdpYy5TY2VuZScsXG5cdFx0XHRTQ0VORV9TVEFURV9CRUZPUkUgPSAnQkVGT1JFJyxcblx0XHRcdFNDRU5FX1NUQVRFX0RVUklORyA9ICdEVVJJTkcnLFxuXHRcdFx0U0NFTkVfU1RBVEVfQUZURVIgPSAnQUZURVInLFxuXHRcdFx0REVGQVVMVF9PUFRJT05TID0gU0NFTkVfT1BUSU9OUy5kZWZhdWx0cztcblxuLypcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKiBwcml2YXRlIHZhcnNcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKi9cblxuXHRcdHZhclxuXHRcdFNjZW5lID0gdGhpcyxcblx0XHRcdF9vcHRpb25zID0gX3V0aWwuZXh0ZW5kKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpLFxuXHRcdFx0X3N0YXRlID0gU0NFTkVfU1RBVEVfQkVGT1JFLFxuXHRcdFx0X3Byb2dyZXNzID0gMCxcblx0XHRcdF9zY3JvbGxPZmZzZXQgPSB7XG5cdFx0XHRcdHN0YXJ0OiAwLFxuXHRcdFx0XHRlbmQ6IDBcblx0XHRcdH0sXG5cdFx0XHQvLyByZWZsZWN0cyB0aGUgY29udHJvbGxlcnMncyBzY3JvbGwgcG9zaXRpb24gZm9yIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBzY2VuZSByZXNwZWN0aXZlbHlcblx0XHRcdF90cmlnZ2VyUG9zID0gMCxcblx0XHRcdF9lbmFibGVkID0gdHJ1ZSxcblx0XHRcdF9kdXJhdGlvblVwZGF0ZU1ldGhvZCwgX2NvbnRyb2xsZXI7XG5cblx0XHQvKipcblx0XHQgKiBJbnRlcm5hbCBjb25zdHJ1Y3RvciBmdW5jdGlvbiBvZiB0aGUgU2Nyb2xsTWFnaWMgU2NlbmVcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gX29wdGlvbnMpIHsgLy8gY2hlY2sgc3VwcGxpZWQgb3B0aW9uc1xuXHRcdFx0XHRpZiAoIURFRkFVTFRfT1BUSU9OUy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0bG9nKDIsIFwiV0FSTklORzogVW5rbm93biBvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiXCIpO1xuXHRcdFx0XHRcdGRlbGV0ZSBfb3B0aW9uc1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGQgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgcG9zc2libGUgb3B0aW9uc1xuXHRcdFx0Zm9yICh2YXIgb3B0aW9uTmFtZSBpbiBERUZBVUxUX09QVElPTlMpIHtcblx0XHRcdFx0YWRkU2NlbmVPcHRpb24ob3B0aW9uTmFtZSk7XG5cdFx0XHR9XG5cdFx0XHQvLyB2YWxpZGF0ZSBhbGwgb3B0aW9uc1xuXHRcdFx0dmFsaWRhdGVPcHRpb24oKTtcblx0XHR9O1xuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRXZlbnQgTWFuYWdlbWVudFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblx0XHR2YXIgX2xpc3RlbmVycyA9IHt9O1xuXHRcdC8qKlxuXHRcdCAqIFNjZW5lIHN0YXJ0IGV2ZW50LiAgXG5cdFx0ICogRmlyZXMgd2hlbmV2ZXIgdGhlIHNjcm9sbCBwb3NpdGlvbiBpdHMgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBzY2VuZS4gIFxuXHRcdCAqIEl0IHdpbGwgYWxzbyBmaXJlIHdoZW4gc2Nyb2xsaW5nIGJhY2sgdXAgZ29pbmcgb3ZlciB0aGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNjZW5lLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9ubHkgd2hlbiBzY3JvbGxpbmcgZG93bi9yaWdodCwgdXNlIHRoZSBzY3JvbGxEaXJlY3Rpb24gcGFyYW1ldGVyIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG5cdFx0ICpcblx0XHQgKiBGb3IgZGV0YWlscyBvbiB0aGlzIGV2ZW50IGFuZCB0aGUgb3JkZXIgaW4gd2hpY2ggaXQgaXMgZmlyZWQsIHBsZWFzZSByZXZpZXcgdGhlIHtAbGluayBTY2VuZS5wcm9ncmVzc30gbWV0aG9kLlxuXHRcdCAqXG5cdFx0ICogQGV2ZW50IFNjcm9sbE1hZ2ljLlNjZW5lI3N0YXJ0XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lLm9uKFwic3RhcnRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogXHRjb25zb2xlLmxvZyhcIkhpdCBzdGFydCBwb2ludCBvZiBzY2VuZS5cIik7XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgT2JqZWN0IHBhc3NlZCB0byBlYWNoIGNhbGxiYWNrXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge1NjZW5lfSBldmVudC50YXJnZXQgLSBUaGUgU2NlbmUgb2JqZWN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnQucHJvZ3Jlc3MgLSBSZWZsZWN0cyB0aGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgc2NlbmVcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQuc3RhdGUgLSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2NlbmUgYFwiQkVGT1JFXCJgIG9yIGBcIkRVUklOR1wiYFxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5zY3JvbGxEaXJlY3Rpb24gLSBJbmRpY2F0ZXMgd2hpY2ggd2F5IHdlIGFyZSBzY3JvbGxpbmcgYFwiUEFVU0VEXCJgLCBgXCJGT1JXQVJEXCJgIG9yIGBcIlJFVkVSU0VcImBcblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBTY2VuZSBlbmQgZXZlbnQuICBcblx0XHQgKiBGaXJlcyB3aGVuZXZlciB0aGUgc2Nyb2xsIHBvc2l0aW9uIGl0cyB0aGUgZW5kaW5nIHBvaW50IG9mIHRoZSBzY2VuZS4gIFxuXHRcdCAqIEl0IHdpbGwgYWxzbyBmaXJlIHdoZW4gc2Nyb2xsaW5nIGJhY2sgdXAgZnJvbSBhZnRlciB0aGUgc2NlbmUgYW5kIGdvaW5nIG92ZXIgaXRzIGVuZCBwb3NpdGlvbi4gSWYgeW91IHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbmx5IHdoZW4gc2Nyb2xsaW5nIGRvd24vcmlnaHQsIHVzZSB0aGUgc2Nyb2xsRGlyZWN0aW9uIHBhcmFtZXRlciBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLlxuXHRcdCAqXG5cdFx0ICogRm9yIGRldGFpbHMgb24gdGhpcyBldmVudCBhbmQgdGhlIG9yZGVyIGluIHdoaWNoIGl0IGlzIGZpcmVkLCBwbGVhc2UgcmV2aWV3IHRoZSB7QGxpbmsgU2NlbmUucHJvZ3Jlc3N9IG1ldGhvZC5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBTY3JvbGxNYWdpYy5TY2VuZSNlbmRcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUub24oXCJlbmRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogXHRjb25zb2xlLmxvZyhcIkhpdCBlbmQgcG9pbnQgb2Ygc2NlbmUuXCIpO1xuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IE9iamVjdCBwYXNzZWQgdG8gZWFjaCBjYWxsYmFja1xuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtTY2VuZX0gZXZlbnQudGFyZ2V0IC0gVGhlIFNjZW5lIG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50LnByb2dyZXNzIC0gUmVmbGVjdHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIHNjZW5lXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnN0YXRlIC0gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNjZW5lIGBcIkRVUklOR1wiYCBvciBgXCJBRlRFUlwiYFxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5zY3JvbGxEaXJlY3Rpb24gLSBJbmRpY2F0ZXMgd2hpY2ggd2F5IHdlIGFyZSBzY3JvbGxpbmcgYFwiUEFVU0VEXCJgLCBgXCJGT1JXQVJEXCJgIG9yIGBcIlJFVkVSU0VcImBcblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBTY2VuZSBlbnRlciBldmVudC4gIFxuXHRcdCAqIEZpcmVzIHdoZW5ldmVyIHRoZSBzY2VuZSBlbnRlcnMgdGhlIFwiRFVSSU5HXCIgc3RhdGUuICBcblx0XHQgKiBLZWVwIGluIG1pbmQgdGhhdCBpdCBkb2Vzbid0IG1hdHRlciBpZiB0aGUgc2NlbmUgcGxheXMgZm9yd2FyZCBvciBiYWNrd2FyZDogVGhpcyBldmVudCBhbHdheXMgZmlyZXMgd2hlbiB0aGUgc2NlbmUgZW50ZXJzIGl0cyBhY3RpdmUgc2Nyb2xsIHRpbWVmcmFtZSwgcmVnYXJkbGVzcyBvZiB0aGUgc2Nyb2xsLWRpcmVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEZvciBkZXRhaWxzIG9uIHRoaXMgZXZlbnQgYW5kIHRoZSBvcmRlciBpbiB3aGljaCBpdCBpcyBmaXJlZCwgcGxlYXNlIHJldmlldyB0aGUge0BsaW5rIFNjZW5lLnByb2dyZXNzfSBtZXRob2QuXG5cdFx0ICpcblx0XHQgKiBAZXZlbnQgU2Nyb2xsTWFnaWMuU2NlbmUjZW50ZXJcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUub24oXCJlbnRlclwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiBcdGNvbnNvbGUubG9nKFwiU2NlbmUgZW50ZXJlZC5cIik7XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgT2JqZWN0IHBhc3NlZCB0byBlYWNoIGNhbGxiYWNrXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge1NjZW5lfSBldmVudC50YXJnZXQgLSBUaGUgU2NlbmUgb2JqZWN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnQucHJvZ3Jlc3MgLSBSZWZsZWN0cyB0aGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgc2NlbmVcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQuc3RhdGUgLSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2NlbmUgLSBhbHdheXMgYFwiRFVSSU5HXCJgXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnNjcm9sbERpcmVjdGlvbiAtIEluZGljYXRlcyB3aGljaCB3YXkgd2UgYXJlIHNjcm9sbGluZyBgXCJQQVVTRURcImAsIGBcIkZPUldBUkRcImAgb3IgYFwiUkVWRVJTRVwiYFxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFNjZW5lIGxlYXZlIGV2ZW50LiAgXG5cdFx0ICogRmlyZXMgd2hlbmV2ZXIgdGhlIHNjZW5lJ3Mgc3RhdGUgZ29lcyBmcm9tIFwiRFVSSU5HXCIgdG8gZWl0aGVyIFwiQkVGT1JFXCIgb3IgXCJBRlRFUlwiLiAgXG5cdFx0ICogS2VlcCBpbiBtaW5kIHRoYXQgaXQgZG9lc24ndCBtYXR0ZXIgaWYgdGhlIHNjZW5lIHBsYXlzIGZvcndhcmQgb3IgYmFja3dhcmQ6IFRoaXMgZXZlbnQgYWx3YXlzIGZpcmVzIHdoZW4gdGhlIHNjZW5lIGxlYXZlcyBpdHMgYWN0aXZlIHNjcm9sbCB0aW1lZnJhbWUsIHJlZ2FyZGxlc3Mgb2YgdGhlIHNjcm9sbC1kaXJlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBGb3IgZGV0YWlscyBvbiB0aGlzIGV2ZW50IGFuZCB0aGUgb3JkZXIgaW4gd2hpY2ggaXQgaXMgZmlyZWQsIHBsZWFzZSByZXZpZXcgdGhlIHtAbGluayBTY2VuZS5wcm9ncmVzc30gbWV0aG9kLlxuXHRcdCAqXG5cdFx0ICogQGV2ZW50IFNjcm9sbE1hZ2ljLlNjZW5lI2xlYXZlXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lLm9uKFwibGVhdmVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogXHRjb25zb2xlLmxvZyhcIlNjZW5lIGxlZnQuXCIpO1xuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IE9iamVjdCBwYXNzZWQgdG8gZWFjaCBjYWxsYmFja1xuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtTY2VuZX0gZXZlbnQudGFyZ2V0IC0gVGhlIFNjZW5lIG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50LnByb2dyZXNzIC0gUmVmbGVjdHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIHNjZW5lXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnN0YXRlIC0gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNjZW5lIGBcIkJFRk9SRVwiYCBvciBgXCJBRlRFUlwiYFxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5zY3JvbGxEaXJlY3Rpb24gLSBJbmRpY2F0ZXMgd2hpY2ggd2F5IHdlIGFyZSBzY3JvbGxpbmcgYFwiUEFVU0VEXCJgLCBgXCJGT1JXQVJEXCJgIG9yIGBcIlJFVkVSU0VcImBcblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBTY2VuZSB1cGRhdGUgZXZlbnQuICBcblx0XHQgKiBGaXJlcyB3aGVuZXZlciB0aGUgc2NlbmUgaXMgdXBkYXRlZCAoYnV0IG5vdCBuZWNlc3NhcmlseSBjaGFuZ2VzIHRoZSBwcm9ncmVzcykuXG5cdFx0ICpcblx0XHQgKiBAZXZlbnQgU2Nyb2xsTWFnaWMuU2NlbmUjdXBkYXRlXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lLm9uKFwidXBkYXRlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqIFx0Y29uc29sZS5sb2coXCJTY2VuZSB1cGRhdGVkLlwiKTtcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBPYmplY3QgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2tcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7U2NlbmV9IGV2ZW50LnRhcmdldCAtIFRoZSBTY2VuZSBvYmplY3QgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudC5zdGFydFBvcyAtIFRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiB0aGUgc2NlbmUgKGluIHJlbGF0aW9uIHRvIHRoZSBjb25haW5lcilcblx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnQuZW5kUG9zIC0gVGhlIGVuZGluZyBwb3NpdGlvbiBvZiB0aGUgc2NlbmUgKGluIHJlbGF0aW9uIHRvIHRoZSBjb25haW5lcilcblx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnQuc2Nyb2xsUG9zIC0gVGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXJcblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBTY2VuZSBwcm9ncmVzcyBldmVudC4gIFxuXHRcdCAqIEZpcmVzIHdoZW5ldmVyIHRoZSBwcm9ncmVzcyBvZiB0aGUgc2NlbmUgY2hhbmdlcy5cblx0XHQgKlxuXHRcdCAqIEZvciBkZXRhaWxzIG9uIHRoaXMgZXZlbnQgYW5kIHRoZSBvcmRlciBpbiB3aGljaCBpdCBpcyBmaXJlZCwgcGxlYXNlIHJldmlldyB0aGUge0BsaW5rIFNjZW5lLnByb2dyZXNzfSBtZXRob2QuXG5cdFx0ICpcblx0XHQgKiBAZXZlbnQgU2Nyb2xsTWFnaWMuU2NlbmUjcHJvZ3Jlc3Ncblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUub24oXCJwcm9ncmVzc1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiBcdGNvbnNvbGUubG9nKFwiU2NlbmUgcHJvZ3Jlc3MgY2hhbmdlZCB0byBcIiArIGV2ZW50LnByb2dyZXNzKTtcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBPYmplY3QgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2tcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7U2NlbmV9IGV2ZW50LnRhcmdldCAtIFRoZSBTY2VuZSBvYmplY3QgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudC5wcm9ncmVzcyAtIFJlZmxlY3RzIHRoZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoZSBzY2VuZVxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5zdGF0ZSAtIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzY2VuZSBgXCJCRUZPUkVcImAsIGBcIkRVUklOR1wiYCBvciBgXCJBRlRFUlwiYFxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5zY3JvbGxEaXJlY3Rpb24gLSBJbmRpY2F0ZXMgd2hpY2ggd2F5IHdlIGFyZSBzY3JvbGxpbmcgYFwiUEFVU0VEXCJgLCBgXCJGT1JXQVJEXCJgIG9yIGBcIlJFVkVSU0VcImBcblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBTY2VuZSBjaGFuZ2UgZXZlbnQuICBcblx0XHQgKiBGaXJlcyB3aGVudmV2ZXIgYSBwcm9wZXJ0eSBvZiB0aGUgc2NlbmUgaXMgY2hhbmdlZC5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBTY3JvbGxNYWdpYy5TY2VuZSNjaGFuZ2Vcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogXHRjb25zb2xlLmxvZyhcIlNjZW5lIFByb3BlcnR5IFxcXCJcIiArIGV2ZW50LndoYXQgKyBcIlxcXCIgY2hhbmdlZCB0byBcIiArIGV2ZW50Lm5ld3ZhbCk7XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgT2JqZWN0IHBhc3NlZCB0byBlYWNoIGNhbGxiYWNrXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge1NjZW5lfSBldmVudC50YXJnZXQgLSBUaGUgU2NlbmUgb2JqZWN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQud2hhdCAtIEluZGljYXRlcyB3aGF0IHZhbHVlIGhhcyBiZWVuIGNoYW5nZWRcblx0XHQgKiBAcHJvcGVydHkge21peGVkfSBldmVudC5uZXd2YWwgLSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBjaGFuZ2VkIHByb3BlcnR5XG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogU2NlbmUgc2hpZnQgZXZlbnQuICBcblx0XHQgKiBGaXJlcyB3aGVudmV2ZXIgdGhlIHN0YXJ0IG9yIGVuZCAqKnNjcm9sbCBvZmZzZXQqKiBvZiB0aGUgc2NlbmUgY2hhbmdlLlxuXHRcdCAqIFRoaXMgaGFwcGVucyBleHBsaWNpdGVseSwgd2hlbiBvbmUgb2YgdGhlc2UgdmFsdWVzIGNoYW5nZTogYG9mZnNldGAsIGBkdXJhdGlvbmAgb3IgYHRyaWdnZXJIb29rYC5cblx0XHQgKiBJdCB3aWxsIGZpcmUgaW1wbGljaXRseSB3aGVuIHRoZSBgdHJpZ2dlckVsZW1lbnRgIGNoYW5nZXMsIGlmIHRoZSBuZXcgZWxlbWVudCBoYXMgYSBkaWZmZXJlbnQgcG9zaXRpb24gKG1vc3QgY2FzZXMpLlxuXHRcdCAqIEl0IHdpbGwgYWxzbyBmaXJlIGltcGxpY2l0bHkgd2hlbiB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyIGNoYW5nZXMgYW5kIHRoZSB0cmlnZ2VySG9vayBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGBvbkxlYXZlYC5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBTY3JvbGxNYWdpYy5TY2VuZSNzaGlmdFxuXHRcdCAqIEBzaW5jZSAxLjEuMFxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZS5vbihcInNoaWZ0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqIFx0Y29uc29sZS5sb2coXCJTY2VuZSBtb3ZlZCwgYmVjYXVzZSB0aGUgXCIgKyBldmVudC5yZWFzb24gKyBcIiBoYXMgY2hhbmdlZC4pXCIpO1xuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IE9iamVjdCBwYXNzZWQgdG8gZWFjaCBjYWxsYmFja1xuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtTY2VuZX0gZXZlbnQudGFyZ2V0IC0gVGhlIFNjZW5lIG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnJlYXNvbiAtIEluZGljYXRlcyB3aHkgdGhlIHNjZW5lIGhhcyBzaGlmdGVkXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogU2NlbmUgZGVzdHJveSBldmVudC4gIFxuXHRcdCAqIEZpcmVzIHdoZW52ZXZlciB0aGUgc2NlbmUgaXMgZGVzdHJveWVkLlxuXHRcdCAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gdGlkeSB1cCBjdXN0b20gYmVoYXZpb3VyIHVzZWQgaW4gZXZlbnRzLlxuXHRcdCAqXG5cdFx0ICogQGV2ZW50IFNjcm9sbE1hZ2ljLlNjZW5lI2Rlc3Ryb3lcblx0XHQgKiBAc2luY2UgMS4xLjBcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUub24oXCJlbnRlclwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiAgICAgICAgLy8gYWRkIGN1c3RvbSBhY3Rpb25cblx0XHQgKiAgICAgICAgJChcIiNteS1lbGVtXCIpLmxlZnQoXCIyMDBcIik7XG5cdFx0ICogICAgICB9KVxuXHRcdCAqICAgICAgLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiAgICAgICAgLy8gcmVzZXQgbXkgZWxlbWVudCB0byBzdGFydCBwb3NpdGlvblxuXHRcdCAqICAgICAgICBpZiAoZXZlbnQucmVzZXQpIHtcblx0XHQgKiAgICAgICAgICAkKFwiI215LWVsZW1cIikubGVmdChcIjBcIik7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IE9iamVjdCBwYXNzZWQgdG8gZWFjaCBjYWxsYmFja1xuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtTY2VuZX0gZXZlbnQudGFyZ2V0IC0gVGhlIFNjZW5lIG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtib29sZWFufSBldmVudC5yZXNldCAtIEluZGljYXRlcyBpZiB0aGUgZGVzdHJveSBtZXRob2Qgd2FzIGNhbGxlZCB3aXRoIHJlc2V0IGB0cnVlYCBvciBgZmFsc2VgLlxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFNjZW5lIGFkZCBldmVudC4gIFxuXHRcdCAqIEZpcmVzIHdoZW4gdGhlIHNjZW5lIGlzIGFkZGVkIHRvIGEgY29udHJvbGxlci5cblx0XHQgKiBUaGlzIGlzIG1vc3RseSB1c2VkIGJ5IHBsdWdpbnMgdG8ga25vdyB0aGF0IGNoYW5nZSBtaWdodCBiZSBkdWUuXG5cdFx0ICpcblx0XHQgKiBAZXZlbnQgU2Nyb2xsTWFnaWMuU2NlbmUjYWRkXG5cdFx0ICogQHNpbmNlIDIuMC4wXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lLm9uKFwiYWRkXCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqIFx0Y29uc29sZS5sb2coJ1NjZW5lIHdhcyBhZGRlZCB0byBhIG5ldyBjb250cm9sbGVyLicpO1xuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IE9iamVjdCBwYXNzZWQgdG8gZWFjaCBjYWxsYmFja1xuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtTY2VuZX0gZXZlbnQudGFyZ2V0IC0gVGhlIFNjZW5lIG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtib29sZWFufSBldmVudC5jb250cm9sbGVyIC0gVGhlIGNvbnRyb2xsZXIgb2JqZWN0IHRoZSBzY2VuZSB3YXMgYWRkZWQgdG8uXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogU2NlbmUgcmVtb3ZlIGV2ZW50LiAgXG5cdFx0ICogRmlyZXMgd2hlbiB0aGUgc2NlbmUgaXMgcmVtb3ZlZCBmcm9tIGEgY29udHJvbGxlci5cblx0XHQgKiBUaGlzIGlzIG1vc3RseSB1c2VkIGJ5IHBsdWdpbnMgdG8ga25vdyB0aGF0IGNoYW5nZSBtaWdodCBiZSBkdWUuXG5cdFx0ICpcblx0XHQgKiBAZXZlbnQgU2Nyb2xsTWFnaWMuU2NlbmUjcmVtb3ZlXG5cdFx0ICogQHNpbmNlIDIuMC4wXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lLm9uKFwicmVtb3ZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqIFx0Y29uc29sZS5sb2coJ1NjZW5lIHdhcyByZW1vdmVkIGZyb20gaXRzIGNvbnRyb2xsZXIuJyk7XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgT2JqZWN0IHBhc3NlZCB0byBlYWNoIGNhbGxiYWNrXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge1NjZW5lfSBldmVudC50YXJnZXQgLSBUaGUgU2NlbmUgb2JqZWN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBvbmUgb3JlIG1vcmUgZXZlbnQgbGlzdGVuZXIuICBcblx0XHQgKiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBmaXJlZCBhdCB0aGUgcmVzcGVjdGl2ZSBldmVudCwgYW5kIGFuIG9iamVjdCBjb250YWluaW5nIHJlbGV2YW50IGRhdGEgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjb25cblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogZnVuY3Rpb24gY2FsbGJhY2sgKGV2ZW50KSB7XG5cdFx0ICogXHRcdGNvbnNvbGUubG9nKFwiRXZlbnQgZmlyZWQhIChcIiArIGV2ZW50LnR5cGUgKyBcIilcIik7XG5cdFx0ICogfVxuXHRcdCAqIC8vIGFkZCBsaXN0ZW5lcnNcblx0XHQgKiBzY2VuZS5vbihcImNoYW5nZSB1cGRhdGUgcHJvZ3Jlc3Mgc3RhcnQgZW5kIGVudGVyIGxlYXZlXCIsIGNhbGxiYWNrKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lcyAtIFRoZSBuYW1lIG9yIG5hbWVzIG9mIHRoZSBldmVudCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCwgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC4gQW4gZXZlbnQgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMub24gPSBmdW5jdGlvbiAobmFtZXMsIGNhbGxiYWNrKSB7XG5cdFx0XHRpZiAoX3V0aWwudHlwZS5GdW5jdGlvbihjYWxsYmFjaykpIHtcblx0XHRcdFx0bmFtZXMgPSBuYW1lcy50cmltKCkuc3BsaXQoJyAnKTtcblx0XHRcdFx0bmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZnVsbG5hbWUpIHtcblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRuYW1lcGFydHMgPSBmdWxsbmFtZS5zcGxpdCgnLicpLFxuXHRcdFx0XHRcdFx0ZXZlbnRuYW1lID0gbmFtZXBhcnRzWzBdLFxuXHRcdFx0XHRcdFx0bmFtZXNwYWNlID0gbmFtZXBhcnRzWzFdO1xuXHRcdFx0XHRcdGlmIChldmVudG5hbWUgIT0gXCIqXCIpIHsgLy8gZGlzYWxsb3cgd2lsZGNhcmRzXG5cdFx0XHRcdFx0XHRpZiAoIV9saXN0ZW5lcnNbZXZlbnRuYW1lXSkge1xuXHRcdFx0XHRcdFx0XHRfbGlzdGVuZXJzW2V2ZW50bmFtZV0gPSBbXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdF9saXN0ZW5lcnNbZXZlbnRuYW1lXS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UgfHwgJycsXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrOiBjYWxsYmFja1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvZygxLCBcIkVSUk9SIHdoZW4gY2FsbGluZyAnLm9uKCknOiBTdXBwbGllZCBjYWxsYmFjayBmb3IgJ1wiICsgbmFtZXMgKyBcIicgaXMgbm90IGEgdmFsaWQgZnVuY3Rpb24hXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgb25lIG9yIG1vcmUgZXZlbnQgbGlzdGVuZXIuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNvZmZcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogZnVuY3Rpb24gY2FsbGJhY2sgKGV2ZW50KSB7XG5cdFx0ICogXHRcdGNvbnNvbGUubG9nKFwiRXZlbnQgZmlyZWQhIChcIiArIGV2ZW50LnR5cGUgKyBcIilcIik7XG5cdFx0ICogfVxuXHRcdCAqIC8vIGFkZCBsaXN0ZW5lcnNcblx0XHQgKiBzY2VuZS5vbihcImNoYW5nZSB1cGRhdGVcIiwgY2FsbGJhY2spO1xuXHRcdCAqIC8vIHJlbW92ZSBsaXN0ZW5lcnNcblx0XHQgKiBzY2VuZS5vZmYoXCJjaGFuZ2UgdXBkYXRlXCIsIGNhbGxiYWNrKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lcyAtIFRoZSBuYW1lIG9yIG5hbWVzIG9mIHRoZSBldmVudCB0aGF0IHNob3VsZCBiZSByZW1vdmVkLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gLSBBIHNwZWNpZmljIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQuIElmIG5vbmUgaXMgcGFzc2VkIGFsbCBjYWxsYmFja3MgdG8gdGhlIGV2ZW50IGxpc3RlbmVyIHdpbGwgYmUgcmVtb3ZlZC5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMub2ZmID0gZnVuY3Rpb24gKG5hbWVzLCBjYWxsYmFjaykge1xuXHRcdFx0aWYgKCFuYW1lcykge1xuXHRcdFx0XHRsb2coMSwgXCJFUlJPUjogSW52YWxpZCBldmVudCBuYW1lIHN1cHBsaWVkLlwiKTtcblx0XHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdFx0fVxuXHRcdFx0bmFtZXMgPSBuYW1lcy50cmltKCkuc3BsaXQoJyAnKTtcblx0XHRcdG5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGZ1bGxuYW1lLCBrZXkpIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdG5hbWVwYXJ0cyA9IGZ1bGxuYW1lLnNwbGl0KCcuJyksXG5cdFx0XHRcdFx0ZXZlbnRuYW1lID0gbmFtZXBhcnRzWzBdLFxuXHRcdFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVwYXJ0c1sxXSB8fCAnJyxcblx0XHRcdFx0XHRyZW1vdmVMaXN0ID0gZXZlbnRuYW1lID09PSAnKicgPyBPYmplY3Qua2V5cyhfbGlzdGVuZXJzKSA6IFtldmVudG5hbWVdO1xuXHRcdFx0XHRyZW1vdmVMaXN0LmZvckVhY2goZnVuY3Rpb24gKHJlbW92ZSkge1xuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdGxpc3QgPSBfbGlzdGVuZXJzW3JlbW92ZV0gfHwgW10sXG5cdFx0XHRcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdFx0dmFyIGxpc3RlbmVyID0gbGlzdFtpXTtcblx0XHRcdFx0XHRcdGlmIChsaXN0ZW5lciAmJiAobmFtZXNwYWNlID09PSBsaXN0ZW5lci5uYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSAnKicpICYmICghY2FsbGJhY2sgfHwgY2FsbGJhY2sgPT0gbGlzdGVuZXIuY2FsbGJhY2spKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIWxpc3QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgX2xpc3RlbmVyc1tyZW1vdmVdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlciBhbiBldmVudC5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3RyaWdnZXJcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogdGhpcy50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdGhhdCBzaG91bGQgYmUgdHJpZ2dlcmVkLlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBbdmFyc10gLSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFycykge1xuXHRcdFx0aWYgKG5hbWUpIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdG5hbWVwYXJ0cyA9IG5hbWUudHJpbSgpLnNwbGl0KCcuJyksXG5cdFx0XHRcdFx0ZXZlbnRuYW1lID0gbmFtZXBhcnRzWzBdLFxuXHRcdFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVwYXJ0c1sxXSxcblx0XHRcdFx0XHRsaXN0ZW5lcnMgPSBfbGlzdGVuZXJzW2V2ZW50bmFtZV07XG5cdFx0XHRcdGxvZygzLCAnZXZlbnQgZmlyZWQ6JywgZXZlbnRuYW1lLCB2YXJzID8gXCItPlwiIDogJycsIHZhcnMgfHwgJycpO1xuXHRcdFx0XHRpZiAobGlzdGVuZXJzKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyLCBrZXkpIHtcblx0XHRcdFx0XHRcdGlmICghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gbGlzdGVuZXIubmFtZXNwYWNlKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmNhbGxiYWNrLmNhbGwoU2NlbmUsIG5ldyBTY3JvbGxNYWdpYy5FdmVudChldmVudG5hbWUsIGxpc3RlbmVyLm5hbWVzcGFjZSwgU2NlbmUsIHZhcnMpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bG9nKDEsIFwiRVJST1I6IEludmFsaWQgZXZlbnQgbmFtZSBzdXBwbGllZC5cIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8vIHNldCBldmVudCBsaXN0ZW5lcnNcblx0XHRTY2VuZS5vbihcImNoYW5nZS5pbnRlcm5hbFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0aWYgKGUud2hhdCAhPT0gXCJsb2dsZXZlbFwiICYmIGUud2hhdCAhPT0gXCJ0d2VlbkNoYW5nZXNcIikgeyAvLyBubyBuZWVkIGZvciBhIHNjZW5lIHVwZGF0ZSBzY2VuZSB3aXRoIHRoZXNlIG9wdGlvbnMuLi5cblx0XHRcdFx0aWYgKGUud2hhdCA9PT0gXCJ0cmlnZ2VyRWxlbWVudFwiKSB7XG5cdFx0XHRcdFx0dXBkYXRlVHJpZ2dlckVsZW1lbnRQb3NpdGlvbigpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGUud2hhdCA9PT0gXCJyZXZlcnNlXCIpIHsgLy8gdGhlIG9ubHkgcHJvcGVydHkgbGVmdCB0aGF0IG1heSBoYXZlIGFuIGltcGFjdCBvbiB0aGUgY3VycmVudCBzY2VuZSBzdGF0ZS4gRXZlcnl0aGluZyBlbHNlIGlzIGhhbmRsZWQgYnkgdGhlIHNoaWZ0IGV2ZW50LlxuXHRcdFx0XHRcdFNjZW5lLnVwZGF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSkub24oXCJzaGlmdC5pbnRlcm5hbFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dXBkYXRlU2Nyb2xsT2Zmc2V0KCk7XG5cdFx0XHRTY2VuZS51cGRhdGUoKTsgLy8gdXBkYXRlIHNjZW5lIHRvIHJlZmxlY3QgbmV3IHBvc2l0aW9uXG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBTZW5kIGEgZGVidWcgbWVzc2FnZSB0byB0aGUgY29uc29sZS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIGJ1dCBwcm92aWRlZCBwdWJsaWNseSB3aXRoIF9sb2cgZm9yIHBsdWdpbnNcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBsb2dsZXZlbCAtIFRoZSBsb2dsZXZlbCByZXF1aXJlZCB0byBpbml0aWF0ZSBvdXRwdXQgZm9yIHRoZSBtZXNzYWdlLlxuXHRcdCAqIEBwYXJhbSB7Li4ubWl4ZWR9IG91dHB1dCAtIE9uZSBvciBtb3JlIHZhcmlhYmxlcyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGNvbnNvbGUuXG5cdFx0ICovXG5cdFx0dmFyIGxvZyA9IHRoaXMuX2xvZyA9IGZ1bmN0aW9uIChsb2dsZXZlbCwgb3V0cHV0KSB7XG5cdFx0XHRpZiAoX29wdGlvbnMubG9nbGV2ZWwgPj0gbG9nbGV2ZWwpIHtcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgMCwgXCIoXCIgKyBOQU1FU1BBQ0UgKyBcIikgLT5cIik7XG5cdFx0XHRcdF91dGlsLmxvZy5hcHBseSh3aW5kb3csIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCB0aGUgc2NlbmUgdG8gYSBjb250cm9sbGVyLiAgXG5cdFx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCB0byBgQ29udHJvbGxlci5hZGRTY2VuZShzY2VuZSlgLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjYWRkVG9cblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gYWRkIGEgc2NlbmUgdG8gYSBTY3JvbGxNYWdpYyBDb250cm9sbGVyXG5cdFx0ICogc2NlbmUuYWRkVG8oY29udHJvbGxlcik7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1Njcm9sbE1hZ2ljLkNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciB0byB3aGljaCB0aGUgc2NlbmUgc2hvdWxkIGJlIGFkZGVkLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5hZGRUbyA9IGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG5cdFx0XHRpZiAoIShjb250cm9sbGVyIGluc3RhbmNlb2YgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcikpIHtcblx0XHRcdFx0bG9nKDEsIFwiRVJST1I6IHN1cHBsaWVkIGFyZ3VtZW50IG9mICdhZGRUbygpJyBpcyBub3QgYSB2YWxpZCBTY3JvbGxNYWdpYyBDb250cm9sbGVyXCIpO1xuXHRcdFx0fSBlbHNlIGlmIChfY29udHJvbGxlciAhPSBjb250cm9sbGVyKSB7XG5cdFx0XHRcdC8vIG5ldyBjb250cm9sbGVyXG5cdFx0XHRcdGlmIChfY29udHJvbGxlcikgeyAvLyB3YXMgYXNzb2NpYXRlZCB0byBhIGRpZmZlcmVudCBjb250cm9sbGVyIGJlZm9yZSwgc28gcmVtb3ZlIGl0Li4uXG5cdFx0XHRcdFx0X2NvbnRyb2xsZXIucmVtb3ZlU2NlbmUoU2NlbmUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9jb250cm9sbGVyID0gY29udHJvbGxlcjtcblx0XHRcdFx0dmFsaWRhdGVPcHRpb24oKTtcblx0XHRcdFx0dXBkYXRlRHVyYXRpb24odHJ1ZSk7XG5cdFx0XHRcdHVwZGF0ZVRyaWdnZXJFbGVtZW50UG9zaXRpb24odHJ1ZSk7XG5cdFx0XHRcdHVwZGF0ZVNjcm9sbE9mZnNldCgpO1xuXHRcdFx0XHRfY29udHJvbGxlci5pbmZvKFwiY29udGFpbmVyXCIpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uQ29udGFpbmVyUmVzaXplKTtcblx0XHRcdFx0Y29udHJvbGxlci5hZGRTY2VuZShTY2VuZSk7XG5cdFx0XHRcdFNjZW5lLnRyaWdnZXIoXCJhZGRcIiwge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXI6IF9jb250cm9sbGVyXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRsb2coMywgXCJhZGRlZCBcIiArIE5BTUVTUEFDRSArIFwiIHRvIGNvbnRyb2xsZXJcIik7XG5cdFx0XHRcdFNjZW5lLnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIG9yICoqU2V0KiogdGhlIGN1cnJlbnQgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgc2NlbmUuICBcblx0XHQgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGRpc2FibGUgdGhpcyBzY2VuZSB3aXRob3V0IHJlbW92aW5nIG9yIGRlc3Ryb3lpbmcgaXQuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNlbmFibGVkXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCB2YWx1ZVxuXHRcdCAqIHZhciBlbmFibGVkID0gc2NlbmUuZW5hYmxlZCgpO1xuXHRcdCAqXG5cdFx0ICogLy8gZGlzYWJsZSB0aGUgc2NlbmVcblx0XHQgKiBzY2VuZS5lbmFibGVkKGZhbHNlKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW25ld1N0YXRlXSAtIFRoZSBuZXcgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgc2NlbmUgYHRydWVgIG9yIGBmYWxzZWAuXG5cdFx0ICogQHJldHVybnMgeyhib29sZWFufFNjZW5lKX0gQ3VycmVudCBlbmFibGVkIHN0YXRlIG9yIHBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMuZW5hYmxlZCA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7IC8vIGdldFxuXHRcdFx0XHRyZXR1cm4gX2VuYWJsZWQ7XG5cdFx0XHR9IGVsc2UgaWYgKF9lbmFibGVkICE9IG5ld1N0YXRlKSB7IC8vIHNldFxuXHRcdFx0XHRfZW5hYmxlZCA9ICEhIG5ld1N0YXRlO1xuXHRcdFx0XHRTY2VuZS51cGRhdGUodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSB0aGUgc2NlbmUgZnJvbSB0aGUgY29udHJvbGxlci4gIFxuXHRcdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgdG8gYENvbnRyb2xsZXIucmVtb3ZlU2NlbmUoc2NlbmUpYC5cblx0XHQgKiBUaGUgc2NlbmUgd2lsbCBub3QgYmUgdXBkYXRlZCBhbnltb3JlIHVudGlsIHlvdSByZWFkZCBpdCB0byBhIGNvbnRyb2xsZXIuXG5cdFx0ICogVG8gcmVtb3ZlIHRoZSBwaW4gb3IgdGhlIHR3ZWVuIHlvdSBuZWVkIHRvIGNhbGwgcmVtb3ZlVHdlZW4oKSBvciByZW1vdmVQaW4oKSByZXNwZWN0aXZlbHkuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNyZW1vdmVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHJlbW92ZSB0aGUgc2NlbmUgZnJvbSBpdHMgY29udHJvbGxlclxuXHRcdCAqIHNjZW5lLnJlbW92ZSgpO1xuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChfY29udHJvbGxlcikge1xuXHRcdFx0XHRfY29udHJvbGxlci5pbmZvKFwiY29udGFpbmVyXCIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uQ29udGFpbmVyUmVzaXplKTtcblx0XHRcdFx0dmFyIHRtcFBhcmVudCA9IF9jb250cm9sbGVyO1xuXHRcdFx0XHRfY29udHJvbGxlciA9IHVuZGVmaW5lZDtcblx0XHRcdFx0dG1wUGFyZW50LnJlbW92ZVNjZW5lKFNjZW5lKTtcblx0XHRcdFx0U2NlbmUudHJpZ2dlcihcInJlbW92ZVwiKTtcblx0XHRcdFx0bG9nKDMsIFwicmVtb3ZlZCBcIiArIE5BTUVTUEFDRSArIFwiIGZyb20gY29udHJvbGxlclwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSB0aGUgc2NlbmUgYW5kIGV2ZXJ5dGhpbmcuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNkZXN0cm95XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBkZXN0cm95IHRoZSBzY2VuZSB3aXRob3V0IHJlc2V0dGluZyB0aGUgcGluIGFuZCB0d2VlbiB0byB0aGVpciBpbml0aWFsIHBvc2l0aW9uc1xuXHRcdCAqIHNjZW5lID0gc2NlbmUuZGVzdHJveSgpO1xuXHRcdCAqXG5cdFx0ICogLy8gZGVzdHJveSB0aGUgc2NlbmUgYW5kIHJlc2V0IHRoZSBwaW4gYW5kIHR3ZWVuXG5cdFx0ICogc2NlbmUgPSBzY2VuZS5kZXN0cm95KHRydWUpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbcmVzZXQ9ZmFsc2VdIC0gSWYgYHRydWVgIHRoZSBwaW4gYW5kIHR3ZWVuIChpZiBleGlzdGVudCkgd2lsbCBiZSByZXNldC5cblx0XHQgKiBAcmV0dXJucyB7bnVsbH0gTnVsbCB0byB1bnNldCBoYW5kbGVyIHZhcmlhYmxlcy5cblx0XHQgKi9cblx0XHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAocmVzZXQpIHtcblx0XHRcdFNjZW5lLnRyaWdnZXIoXCJkZXN0cm95XCIsIHtcblx0XHRcdFx0cmVzZXQ6IHJlc2V0XG5cdFx0XHR9KTtcblx0XHRcdFNjZW5lLnJlbW92ZSgpO1xuXHRcdFx0U2NlbmUub2ZmKFwiKi4qXCIpO1xuXHRcdFx0bG9nKDMsIFwiZGVzdHJveWVkIFwiICsgTkFNRVNQQUNFICsgXCIgKHJlc2V0OiBcIiArIChyZXNldCA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKSArIFwiKVwiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIFNjZW5lIHRvIHJlZmxlY3QgdGhlIGN1cnJlbnQgc3RhdGUuICBcblx0XHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IHRvIGBDb250cm9sbGVyLnVwZGF0ZVNjZW5lKHNjZW5lLCBpbW1lZGlhdGVseSlgLiAgXG5cdFx0ICogVGhlIHVwZGF0ZSBtZXRob2QgY2FsY3VsYXRlcyB0aGUgc2NlbmUncyBzdGFydCBhbmQgZW5kIHBvc2l0aW9uIChiYXNlZCBvbiB0aGUgdHJpZ2dlciBlbGVtZW50LCB0cmlnZ2VyIGhvb2ssIGR1cmF0aW9uIGFuZCBvZmZzZXQpIGFuZCBjaGVja3MgaXQgYWdhaW5zdCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lci4gIFxuXHRcdCAqIEl0IHRoZW4gdXBkYXRlcyB0aGUgY3VycmVudCBzY2VuZSBzdGF0ZSBhY2NvcmRpbmdseSAob3IgZG9lcyBub3RoaW5nLCBpZiB0aGUgc3RhdGUgaXMgYWxyZWFkeSBjb3JyZWN0KSDigJMgUGlucyB3aWxsIGJlIHNldCB0byB0aGVpciBjb3JyZWN0IHBvc2l0aW9uIGFuZCB0d2VlbnMgd2lsbCBiZSB1cGRhdGVkIHRvIHRoZWlyIGNvcnJlY3QgcHJvZ3Jlc3MuXG5cdFx0ICogVGhpcyBtZWFucyBhbiB1cGRhdGUgZG9lc24ndCBuZWNlc3NhcmlseSByZXN1bHQgaW4gYSBwcm9ncmVzcyBjaGFuZ2UuIFRoZSBgcHJvZ3Jlc3NgIGV2ZW50IHdpbGwgYmUgZmlyZWQgaWYgdGhlIHByb2dyZXNzIGhhcyBpbmRlZWQgY2hhbmdlZCBiZXR3ZWVuIHRoaXMgdXBkYXRlIGFuZCB0aGUgbGFzdC4gIFxuXHRcdCAqIF8qKk5PVEU6KiogVGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQgY29uc3RhbnRseSB3aGVuZXZlciBTY3JvbGxNYWdpYyBkZXRlY3RzIGEgY2hhbmdlLiBUaGUgb25seSBhcHBsaWNhdGlvbiBmb3IgeW91IGlzIGlmIHlvdSBjaGFuZ2Ugc29tZXRoaW5nIG91dHNpZGUgb2YgdGhlIHJlYWxtIG9mIFNjcm9sbE1hZ2ljLCBsaWtlIG1vdmluZyB0aGUgdHJpZ2dlciBvciBjaGFuZ2luZyB0d2VlbiBwYXJhbWV0ZXJzLl9cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3VwZGF0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gdXBkYXRlIHRoZSBzY2VuZSBvbiBuZXh0IHRpY2tcblx0XHQgKiBzY2VuZS51cGRhdGUoKTtcblx0XHQgKlxuXHRcdCAqIC8vIHVwZGF0ZSB0aGUgc2NlbmUgaW1tZWRpYXRlbHlcblx0XHQgKiBzY2VuZS51cGRhdGUodHJ1ZSk7XG5cdFx0ICpcblx0XHQgKiBAZmlyZXMgU2NlbmUudXBkYXRlXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbW1lZGlhdGVseT1mYWxzZV0gLSBJZiBgdHJ1ZWAgdGhlIHVwZGF0ZSB3aWxsIGJlIGluc3RhbnQsIGlmIGBmYWxzZWAgaXQgd2lsbCB3YWl0IHVudGlsIG5leHQgdXBkYXRlIGN5Y2xlIChiZXR0ZXIgcGVyZm9ybWFuY2UpLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoaW1tZWRpYXRlbHkpIHtcblx0XHRcdGlmIChfY29udHJvbGxlcikge1xuXHRcdFx0XHRpZiAoaW1tZWRpYXRlbHkpIHtcblx0XHRcdFx0XHRpZiAoX2NvbnRyb2xsZXIuZW5hYmxlZCgpICYmIF9lbmFibGVkKSB7XG5cdFx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdHNjcm9sbFBvcyA9IF9jb250cm9sbGVyLmluZm8oXCJzY3JvbGxQb3NcIiksXG5cdFx0XHRcdFx0XHRcdG5ld1Byb2dyZXNzO1xuXG5cdFx0XHRcdFx0XHRpZiAoX29wdGlvbnMuZHVyYXRpb24gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdG5ld1Byb2dyZXNzID0gKHNjcm9sbFBvcyAtIF9zY3JvbGxPZmZzZXQuc3RhcnQpIC8gKF9zY3JvbGxPZmZzZXQuZW5kIC0gX3Njcm9sbE9mZnNldC5zdGFydCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRuZXdQcm9ncmVzcyA9IHNjcm9sbFBvcyA+PSBfc2Nyb2xsT2Zmc2V0LnN0YXJ0ID8gMSA6IDA7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFNjZW5lLnRyaWdnZXIoXCJ1cGRhdGVcIiwge1xuXHRcdFx0XHRcdFx0XHRzdGFydFBvczogX3Njcm9sbE9mZnNldC5zdGFydCxcblx0XHRcdFx0XHRcdFx0ZW5kUG9zOiBfc2Nyb2xsT2Zmc2V0LmVuZCxcblx0XHRcdFx0XHRcdFx0c2Nyb2xsUG9zOiBzY3JvbGxQb3Ncblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRTY2VuZS5wcm9ncmVzcyhuZXdQcm9ncmVzcyk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChfcGluICYmIF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfRFVSSU5HKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVQaW5TdGF0ZSh0cnVlKTsgLy8gdW5waW4gaW4gcG9zaXRpb25cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2NvbnRyb2xsZXIudXBkYXRlU2NlbmUoU2NlbmUsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIGR5bmFtaWMgc2NlbmUgdmFyaWFibGVzIGxpa2UgdGhlIHRyaWdnZXIgZWxlbWVudCBwb3NpdGlvbiBvciB0aGUgZHVyYXRpb24uXG5cdFx0ICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgaW4gcmVndWxhciBpbnRlcnZhbHMgZnJvbSB0aGUgY29udHJvbGxlci4gU2VlIHtAbGluayBTY3JvbGxNYWdpYy5Db250cm9sbGVyfSBvcHRpb24gYHJlZnJlc2hJbnRlcnZhbGAuXG5cdFx0ICogXG5cdFx0ICogWW91IGNhbiBjYWxsIGl0IHRvIG1pbmltaXplIGxhZywgZm9yIGV4YW1wbGUgd2hlbiB5b3UgaW50ZW50aW9uYWxseSBjaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIHRoZSB0cmlnZ2VyRWxlbWVudC5cblx0XHQgKiBJZiB5b3UgZG9uJ3QgaXQgd2lsbCBzaW1wbHkgYmUgdXBkYXRlZCBpbiB0aGUgbmV4dCByZWZyZXNoIGludGVydmFsIG9mIHRoZSBjb250YWluZXIsIHdoaWNoIGlzIHVzdWFsbHkgc3VmZmljaWVudC5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjcmVmcmVzaFxuXHRcdCAqIEBzaW5jZSAxLjEuMFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe3RyaWdnZXJFbGVtZW50OiBcIiN0cmlnZ2VyXCJ9KTtcblx0XHQgKiBcblx0XHQgKiAvLyBjaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIHRoZSB0cmlnZ2VyXG5cdFx0ICogJChcIiN0cmlnZ2VyXCIpLmNzcyhcInRvcFwiLCA1MDApO1xuXHRcdCAqIC8vIGltbWVkaWF0ZWx5IGxldCB0aGUgc2NlbmUga25vdyBvZiB0aGlzIGNoYW5nZVxuXHRcdCAqIHNjZW5lLnJlZnJlc2goKTtcblx0XHQgKlxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuc2hpZnR9LCBpZiB0aGUgdHJpZ2dlciBlbGVtZW50IHBvc2l0aW9uIG9yIHRoZSBkdXJhdGlvbiBjaGFuZ2VkXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5jaGFuZ2V9LCBpZiB0aGUgZHVyYXRpb24gY2hhbmdlZFxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR1cGRhdGVEdXJhdGlvbigpO1xuXHRcdFx0dXBkYXRlVHJpZ2dlckVsZW1lbnRQb3NpdGlvbigpO1xuXHRcdFx0Ly8gdXBkYXRlIHRyaWdnZXIgZWxlbWVudCBwb3NpdGlvblxuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIG9yICoqU2V0KiogdGhlIHNjZW5lJ3MgcHJvZ3Jlc3MuICBcblx0XHQgKiBVc3VhbGx5IGl0IHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgdG8gdXNlIHRoaXMgYXMgYSBzZXR0ZXIsIGFzIGl0IGlzIHNldCBhdXRvbWF0aWNhbGx5IGJ5IHNjZW5lLnVwZGF0ZSgpLiAgXG5cdFx0ICogVGhlIG9yZGVyIGluIHdoaWNoIHRoZSBldmVudHMgYXJlIGZpcmVkIGRlcGVuZHMgb24gdGhlIGR1cmF0aW9uIG9mIHRoZSBzY2VuZTpcblx0XHQgKiAgMS4gU2NlbmVzIHdpdGggYGR1cmF0aW9uID09IDBgOiAgXG5cdFx0ICogIFNjZW5lcyB0aGF0IGhhdmUgbm8gZHVyYXRpb24gYnkgZGVmaW5pdGlvbiBoYXZlIG5vIGVuZGluZy4gVGh1cyB0aGUgYGVuZGAgZXZlbnQgd2lsbCBuZXZlciBiZSBmaXJlZC4gIFxuXHRcdCAqICBXaGVuIHRoZSB0cmlnZ2VyIHBvc2l0aW9uIG9mIHRoZSBzY2VuZSBpcyBwYXNzZWQgdGhlIGV2ZW50cyBhcmUgYWx3YXlzIGZpcmVkIGluIHRoaXMgb3JkZXI6ICBcblx0XHQgKiAgYGVudGVyYCwgYHN0YXJ0YCwgYHByb2dyZXNzYCB3aGVuIHNjcm9sbGluZyBmb3J3YXJkICBcblx0XHQgKiAgYW5kICBcblx0XHQgKiAgYHByb2dyZXNzYCwgYHN0YXJ0YCwgYGxlYXZlYCB3aGVuIHNjcm9sbGluZyBpbiByZXZlcnNlXG5cdFx0ICogIDIuIFNjZW5lcyB3aXRoIGBkdXJhdGlvbiA+IDBgOiAgXG5cdFx0ICogIFNjZW5lcyB3aXRoIGEgc2V0IGR1cmF0aW9uIGhhdmUgYSBkZWZpbmVkIHN0YXJ0IGFuZCBlbmQgcG9pbnQuICBcblx0XHQgKiAgV2hlbiBzY3JvbGxpbmcgcGFzdCB0aGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNjZW5lIGl0IHdpbGwgZmlyZSB0aGVzZSBldmVudHMgaW4gdGhpcyBvcmRlcjogIFxuXHRcdCAqICBgZW50ZXJgLCBgc3RhcnRgLCBgcHJvZ3Jlc3NgICBcblx0XHQgKiAgV2hlbiBjb250aW51aW5nIHRvIHNjcm9sbCBhbmQgcGFzc2luZyB0aGUgZW5kIHBvaW50IGl0IHdpbGwgZmlyZSB0aGVzZSBldmVudHM6ICBcblx0XHQgKiAgYHByb2dyZXNzYCwgYGVuZGAsIGBsZWF2ZWAgIFxuXHRcdCAqICBXaGVuIHJldmVyc2luZyB0aHJvdWdoIHRoZSBlbmQgcG9pbnQgdGhlc2UgZXZlbnRzIGFyZSBmaXJlZDogIFxuXHRcdCAqICBgZW50ZXJgLCBgZW5kYCwgYHByb2dyZXNzYCAgXG5cdFx0ICogIEFuZCB3aGVuIGNvbnRpbnVpbmcgdG8gc2Nyb2xsIHBhc3QgdGhlIHN0YXJ0IHBvc2l0aW9uIGluIHJldmVyc2UgaXQgd2lsbCBmaXJlOiAgXG5cdFx0ICogIGBwcm9ncmVzc2AsIGBzdGFydGAsIGBsZWF2ZWAgIFxuXHRcdCAqICBJbiBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdGhlIGBwcm9ncmVzc2AgZXZlbnQgd2lsbCBiZSBjYWxsZWQgY29uc3RhbnRseSwgd2hlbmV2ZXIgdGhlIHByb2dyZXNzIGNoYW5nZXMuXG5cdFx0ICogXG5cdFx0ICogSW4gc2hvcnQ6ICBcblx0XHQgKiBgZW50ZXJgIGV2ZW50cyB3aWxsIGFsd2F5cyB0cmlnZ2VyICoqYmVmb3JlKiogdGhlIHByb2dyZXNzIHVwZGF0ZSBhbmQgYGxlYXZlYCBlbnZlbnRzIHdpbGwgdHJpZ2dlciAqKmFmdGVyKiogdGhlIHByb2dyZXNzIHVwZGF0ZS4gIFxuXHRcdCAqIGBzdGFydGAgYW5kIGBlbmRgIHdpbGwgYWx3YXlzIHRyaWdnZXIgYXQgdGhlaXIgcmVzcGVjdGl2ZSBwb3NpdGlvbi5cblx0XHQgKiBcblx0XHQgKiBQbGVhc2UgcmV2aWV3IHRoZSBldmVudCBkZXNjcmlwdGlvbnMgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50cyBhbmQgdGhlIGV2ZW50IG9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG5cdFx0ICogXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNwcm9ncmVzc1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IHNjZW5lIHByb2dyZXNzXG5cdFx0ICogdmFyIHByb2dyZXNzID0gc2NlbmUucHJvZ3Jlc3MoKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNldCBuZXcgc2NlbmUgcHJvZ3Jlc3Ncblx0XHQgKiBzY2VuZS5wcm9ncmVzcygwLjMpO1xuXHRcdCAqXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5lbnRlcn0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLnN0YXJ0fSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUucHJvZ3Jlc3N9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5lbmR9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5sZWF2ZX0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvZ3Jlc3NdIC0gVGhlIG5ldyBwcm9ncmVzcyB2YWx1ZSBvZiB0aGUgc2NlbmUgYFswLTFdYC5cblx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfSBgZ2V0YCAtICBDdXJyZW50IHNjZW5lIHByb2dyZXNzLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gYHNldGAgLSAgUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7IC8vIGdldFxuXHRcdFx0XHRyZXR1cm4gX3Byb2dyZXNzO1xuXHRcdFx0fSBlbHNlIHsgLy8gc2V0XG5cdFx0XHRcdHZhclxuXHRcdFx0XHRkb1VwZGF0ZSA9IGZhbHNlLFxuXHRcdFx0XHRcdG9sZFN0YXRlID0gX3N0YXRlLFxuXHRcdFx0XHRcdHNjcm9sbERpcmVjdGlvbiA9IF9jb250cm9sbGVyID8gX2NvbnRyb2xsZXIuaW5mbyhcInNjcm9sbERpcmVjdGlvblwiKSA6ICdQQVVTRUQnLFxuXHRcdFx0XHRcdHJldmVyc2VPckZvcndhcmQgPSBfb3B0aW9ucy5yZXZlcnNlIHx8IHByb2dyZXNzID49IF9wcm9ncmVzcztcblx0XHRcdFx0aWYgKF9vcHRpb25zLmR1cmF0aW9uID09PSAwKSB7XG5cdFx0XHRcdFx0Ly8gemVybyBkdXJhdGlvbiBzY2VuZXNcblx0XHRcdFx0XHRkb1VwZGF0ZSA9IF9wcm9ncmVzcyAhPSBwcm9ncmVzcztcblx0XHRcdFx0XHRfcHJvZ3Jlc3MgPSBwcm9ncmVzcyA8IDEgJiYgcmV2ZXJzZU9yRm9yd2FyZCA/IDAgOiAxO1xuXHRcdFx0XHRcdF9zdGF0ZSA9IF9wcm9ncmVzcyA9PT0gMCA/IFNDRU5FX1NUQVRFX0JFRk9SRSA6IFNDRU5FX1NUQVRFX0RVUklORztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBzY2VuZXMgd2l0aCBzdGFydCBhbmQgZW5kXG5cdFx0XHRcdFx0aWYgKHByb2dyZXNzIDwgMCAmJiBfc3RhdGUgIT09IFNDRU5FX1NUQVRFX0JFRk9SRSAmJiByZXZlcnNlT3JGb3J3YXJkKSB7XG5cdFx0XHRcdFx0XHQvLyBnbyBiYWNrIHRvIGluaXRpYWwgc3RhdGVcblx0XHRcdFx0XHRcdF9wcm9ncmVzcyA9IDA7XG5cdFx0XHRcdFx0XHRfc3RhdGUgPSBTQ0VORV9TVEFURV9CRUZPUkU7XG5cdFx0XHRcdFx0XHRkb1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwcm9ncmVzcyA+PSAwICYmIHByb2dyZXNzIDwgMSAmJiByZXZlcnNlT3JGb3J3YXJkKSB7XG5cdFx0XHRcdFx0XHRfcHJvZ3Jlc3MgPSBwcm9ncmVzcztcblx0XHRcdFx0XHRcdF9zdGF0ZSA9IFNDRU5FX1NUQVRFX0RVUklORztcblx0XHRcdFx0XHRcdGRvVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb2dyZXNzID49IDEgJiYgX3N0YXRlICE9PSBTQ0VORV9TVEFURV9BRlRFUikge1xuXHRcdFx0XHRcdFx0X3Byb2dyZXNzID0gMTtcblx0XHRcdFx0XHRcdF9zdGF0ZSA9IFNDRU5FX1NUQVRFX0FGVEVSO1xuXHRcdFx0XHRcdFx0ZG9VcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoX3N0YXRlID09PSBTQ0VORV9TVEFURV9EVVJJTkcgJiYgIXJldmVyc2VPckZvcndhcmQpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZVBpblN0YXRlKCk7IC8vIGluIGNhc2Ugd2Ugc2Nyb2xsZWQgYmFja3dhcmRzIG1pZC1zY2VuZSBhbmQgcmV2ZXJzZSBpcyBkaXNhYmxlZCA9PiB1cGRhdGUgdGhlIHBpbiBwb3NpdGlvbiwgc28gaXQgZG9lc24ndCBtb3ZlIGJhY2sgYXMgd2VsbC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRvVXBkYXRlKSB7XG5cdFx0XHRcdFx0Ly8gZmlyZSBldmVudHNcblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRldmVudFZhcnMgPSB7XG5cdFx0XHRcdFx0XHRwcm9ncmVzczogX3Byb2dyZXNzLFxuXHRcdFx0XHRcdFx0c3RhdGU6IF9zdGF0ZSxcblx0XHRcdFx0XHRcdHNjcm9sbERpcmVjdGlvbjogc2Nyb2xsRGlyZWN0aW9uXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHN0YXRlQ2hhbmdlZCA9IF9zdGF0ZSAhPSBvbGRTdGF0ZTtcblxuXHRcdFx0XHRcdHZhciB0cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkgeyAvLyB0bXAgaGVscGVyIHRvIHNpbXBsaWZ5IGNvZGVcblx0XHRcdFx0XHRcdFNjZW5lLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFZhcnMpO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoc3RhdGVDaGFuZ2VkKSB7IC8vIGVudGVyIGV2ZW50c1xuXHRcdFx0XHRcdFx0aWYgKG9sZFN0YXRlICE9PSBTQ0VORV9TVEFURV9EVVJJTkcpIHtcblx0XHRcdFx0XHRcdFx0dHJpZ2dlcihcImVudGVyXCIpO1xuXHRcdFx0XHRcdFx0XHR0cmlnZ2VyKG9sZFN0YXRlID09PSBTQ0VORV9TVEFURV9CRUZPUkUgPyBcInN0YXJ0XCIgOiBcImVuZFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHJpZ2dlcihcInByb2dyZXNzXCIpO1xuXHRcdFx0XHRcdGlmIChzdGF0ZUNoYW5nZWQpIHsgLy8gbGVhdmUgZXZlbnRzXG5cdFx0XHRcdFx0XHRpZiAoX3N0YXRlICE9PSBTQ0VORV9TVEFURV9EVVJJTkcpIHtcblx0XHRcdFx0XHRcdFx0dHJpZ2dlcihfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0JFRk9SRSA/IFwic3RhcnRcIiA6IFwiZW5kXCIpO1xuXHRcdFx0XHRcdFx0XHR0cmlnZ2VyKFwibGVhdmVcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdFx0fVxuXHRcdH07XG5cblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSB0aGUgc3RhcnQgYW5kIGVuZCBzY3JvbGxPZmZzZXQgb2YgdGhlIGNvbnRhaW5lci5cblx0XHQgKiBUaGUgcG9zaXRpb25zIHJlZmxlY3Qgd2hhdCB0aGUgY29udHJvbGxlcidzIHNjcm9sbCBwb3NpdGlvbiB3aWxsIGJlIGF0IHRoZSBzdGFydCBhbmQgZW5kIHJlc3BlY3RpdmVseS5cblx0XHQgKiBJcyBjYWxsZWQsIHdoZW46XG5cdFx0ICogICAtIFNjZW5lIGV2ZW50IFwiY2hhbmdlXCIgaXMgY2FsbGVkIHdpdGg6IG9mZnNldCwgdHJpZ2dlckhvb2ssIGR1cmF0aW9uIFxuXHRcdCAqICAgLSBzY3JvbGwgY29udGFpbmVyIGV2ZW50IFwicmVzaXplXCIgaXMgY2FsbGVkXG5cdFx0ICogICAtIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHJpZ2dlckVsZW1lbnQgY2hhbmdlc1xuXHRcdCAqICAgLSB0aGUgY29udHJvbGxlciBjaGFuZ2VzIC0+IGFkZFRvKClcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciB1cGRhdGVTY3JvbGxPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfc2Nyb2xsT2Zmc2V0ID0ge1xuXHRcdFx0XHRzdGFydDogX3RyaWdnZXJQb3MgKyBfb3B0aW9ucy5vZmZzZXRcblx0XHRcdH07XG5cdFx0XHRpZiAoX2NvbnRyb2xsZXIgJiYgX29wdGlvbnMudHJpZ2dlckVsZW1lbnQpIHtcblx0XHRcdFx0Ly8gdGFrZSBhd2F5IHRyaWdnZXJIb29rIHBvcnRpb24gdG8gZ2V0IHJlbGF0aXZlIHRvIHRvcFxuXHRcdFx0XHRfc2Nyb2xsT2Zmc2V0LnN0YXJ0IC09IF9jb250cm9sbGVyLmluZm8oXCJzaXplXCIpICogX29wdGlvbnMudHJpZ2dlckhvb2s7XG5cdFx0XHR9XG5cdFx0XHRfc2Nyb2xsT2Zmc2V0LmVuZCA9IF9zY3JvbGxPZmZzZXQuc3RhcnQgKyBfb3B0aW9ucy5kdXJhdGlvbjtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgZHVyYXRpb24gaWYgc2V0IHRvIGEgZHluYW1pYyBmdW5jdGlvbi5cblx0XHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgc2NlbmUgaXMgYWRkZWQgdG8gYSBjb250cm9sbGVyIGFuZCBpbiByZWd1bGFyIGludGVydmFscyBmcm9tIHRoZSBjb250cm9sbGVyIHRocm91Z2ggc2NlbmUucmVmcmVzaCgpLlxuXHRcdCAqIFxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuY2hhbmdlfSwgaWYgdGhlIGR1cmF0aW9uIGNoYW5nZWRcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLnNoaWZ0fSwgaWYgdGhlIGR1cmF0aW9uIGNoYW5nZWRcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N1cHByZXNzRXZlbnRzPWZhbHNlXSAtIElmIHRydWUgdGhlIHNoaWZ0IGV2ZW50IHdpbGwgYmUgc3VwcHJlc3NlZC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciB1cGRhdGVEdXJhdGlvbiA9IGZ1bmN0aW9uIChzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0Ly8gdXBkYXRlIGR1cmF0aW9uXG5cdFx0XHRpZiAoX2R1cmF0aW9uVXBkYXRlTWV0aG9kKSB7XG5cdFx0XHRcdHZhciB2YXJuYW1lID0gXCJkdXJhdGlvblwiO1xuXHRcdFx0XHRpZiAoY2hhbmdlT3B0aW9uKHZhcm5hbWUsIF9kdXJhdGlvblVwZGF0ZU1ldGhvZC5jYWxsKFNjZW5lKSkgJiYgIXN1cHByZXNzRXZlbnRzKSB7IC8vIHNldFxuXHRcdFx0XHRcdFNjZW5lLnRyaWdnZXIoXCJjaGFuZ2VcIiwge1xuXHRcdFx0XHRcdFx0d2hhdDogdmFybmFtZSxcblx0XHRcdFx0XHRcdG5ld3ZhbDogX29wdGlvbnNbdmFybmFtZV1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRTY2VuZS50cmlnZ2VyKFwic2hpZnRcIiwge1xuXHRcdFx0XHRcdFx0cmVhc29uOiB2YXJuYW1lXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHRyaWdnZXJFbGVtZW50LCBpZiBwcmVzZW50LlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCAuLi5cblx0XHQgKiAgLSAuLi4gd2hlbiB0aGUgdHJpZ2dlckVsZW1lbnQgaXMgY2hhbmdlZFxuXHRcdCAqICAtIC4uLiB3aGVuIHRoZSBzY2VuZSBpcyBhZGRlZCB0byBhIChuZXcpIGNvbnRyb2xsZXJcblx0XHQgKiAgLSAuLi4gaW4gcmVndWxhciBpbnRlcnZhbHMgZnJvbSB0aGUgY29udHJvbGxlciB0aHJvdWdoIHNjZW5lLnJlZnJlc2goKS5cblx0XHQgKiBcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLnNoaWZ0fSwgaWYgdGhlIHBvc2l0aW9uIGNoYW5nZWRcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N1cHByZXNzRXZlbnRzPWZhbHNlXSAtIElmIHRydWUgdGhlIHNoaWZ0IGV2ZW50IHdpbGwgYmUgc3VwcHJlc3NlZC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciB1cGRhdGVUcmlnZ2VyRWxlbWVudFBvc2l0aW9uID0gZnVuY3Rpb24gKHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHR2YXJcblx0XHRcdGVsZW1lbnRQb3MgPSAwLFxuXHRcdFx0XHR0ZWxlbSA9IF9vcHRpb25zLnRyaWdnZXJFbGVtZW50O1xuXHRcdFx0aWYgKF9jb250cm9sbGVyICYmIHRlbGVtKSB7XG5cdFx0XHRcdHZhclxuXHRcdFx0XHRjb250cm9sbGVySW5mbyA9IF9jb250cm9sbGVyLmluZm8oKSxcblx0XHRcdFx0XHRjb250YWluZXJPZmZzZXQgPSBfdXRpbC5nZXQub2Zmc2V0KGNvbnRyb2xsZXJJbmZvLmNvbnRhaW5lciksXG5cdFx0XHRcdFx0Ly8gY29udGFpbmVyIHBvc2l0aW9uIGlzIG5lZWRlZCBiZWNhdXNlIGVsZW1lbnQgb2Zmc2V0IGlzIHJldHVybmVkIGluIHJlbGF0aW9uIHRvIGRvY3VtZW50LCBub3QgaW4gcmVsYXRpb24gdG8gY29udGFpbmVyLlxuXHRcdFx0XHRcdHBhcmFtID0gY29udHJvbGxlckluZm8udmVydGljYWwgPyBcInRvcFwiIDogXCJsZWZ0XCI7IC8vIHdoaWNoIHBhcmFtIGlzIG9mIGludGVyZXN0ID9cblx0XHRcdFx0Ly8gaWYgcGFyZW50IGlzIHNwYWNlciwgdXNlIHNwYWNlciBwb3NpdGlvbiBpbnN0ZWFkIHNvIGNvcnJlY3Qgc3RhcnQgcG9zaXRpb24gaXMgcmV0dXJuZWQgZm9yIHBpbm5lZCBlbGVtZW50cy5cblx0XHRcdFx0d2hpbGUgKHRlbGVtLnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKFBJTl9TUEFDRVJfQVRUUklCVVRFKSkge1xuXHRcdFx0XHRcdHRlbGVtID0gdGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBlbGVtZW50T2Zmc2V0ID0gX3V0aWwuZ2V0Lm9mZnNldCh0ZWxlbSk7XG5cblx0XHRcdFx0aWYgKCFjb250cm9sbGVySW5mby5pc0RvY3VtZW50KSB7IC8vIGNvbnRhaW5lciBpcyBub3QgdGhlIGRvY3VtZW50IHJvb3QsIHNvIHN1YnN0cmFjdCBzY3JvbGwgUG9zaXRpb24gdG8gZ2V0IGNvcnJlY3QgdHJpZ2dlciBlbGVtZW50IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHNjcm9sbGNvbnRlbnRcblx0XHRcdFx0XHRjb250YWluZXJPZmZzZXRbcGFyYW1dIC09IF9jb250cm9sbGVyLnNjcm9sbFBvcygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbWVudFBvcyA9IGVsZW1lbnRPZmZzZXRbcGFyYW1dIC0gY29udGFpbmVyT2Zmc2V0W3BhcmFtXTtcblx0XHRcdH1cblx0XHRcdHZhciBjaGFuZ2VkID0gZWxlbWVudFBvcyAhPSBfdHJpZ2dlclBvcztcblx0XHRcdF90cmlnZ2VyUG9zID0gZWxlbWVudFBvcztcblx0XHRcdGlmIChjaGFuZ2VkICYmICFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRTY2VuZS50cmlnZ2VyKFwic2hpZnRcIiwge1xuXHRcdFx0XHRcdHJlYXNvbjogXCJ0cmlnZ2VyRWxlbWVudFBvc2l0aW9uXCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRyaWdnZXIgYSBzaGlmdCBldmVudCwgd2hlbiB0aGUgY29udGFpbmVyIGlzIHJlc2l6ZWQgYW5kIHRoZSB0cmlnZ2VySG9vayBpcyA+IDEuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgb25Db250YWluZXJSZXNpemUgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0aWYgKF9vcHRpb25zLnRyaWdnZXJIb29rID4gMCkge1xuXHRcdFx0XHRTY2VuZS50cmlnZ2VyKFwic2hpZnRcIiwge1xuXHRcdFx0XHRcdHJlYXNvbjogXCJjb250YWluZXJSZXNpemVcIlxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIF92YWxpZGF0ZSA9IF91dGlsLmV4dGVuZChTQ0VORV9PUFRJT05TLnZhbGlkYXRlLCB7XG5cdFx0XHQvLyB2YWxpZGF0aW9uIGZvciBkdXJhdGlvbiBoYW5kbGVkIGludGVybmFsbHkgZm9yIHJlZmVyZW5jZSB0byBwcml2YXRlIHZhciBfZHVyYXRpb25NZXRob2Rcblx0XHRcdGR1cmF0aW9uOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdGlmIChfdXRpbC50eXBlLlN0cmluZyh2YWwpICYmIHZhbC5tYXRjaCgvXihcXC58XFxkKSpcXGQrJSQvKSkge1xuXHRcdFx0XHRcdC8vIHBlcmNlbnRhZ2UgdmFsdWVcblx0XHRcdFx0XHR2YXIgcGVyYyA9IHBhcnNlRmxvYXQodmFsKSAvIDEwMDtcblx0XHRcdFx0XHR2YWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gX2NvbnRyb2xsZXIgPyBfY29udHJvbGxlci5pbmZvKFwic2l6ZVwiKSAqIHBlcmMgOiAwO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF91dGlsLnR5cGUuRnVuY3Rpb24odmFsKSkge1xuXHRcdFx0XHRcdC8vIGZ1bmN0aW9uXG5cdFx0XHRcdFx0X2R1cmF0aW9uVXBkYXRlTWV0aG9kID0gdmFsO1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBwYXJzZUZsb2F0KF9kdXJhdGlvblVwZGF0ZU1ldGhvZCgpKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSAtMTsgLy8gd2lsbCBjYXVzZSBlcnJvciBiZWxvd1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB2YWwgaGFzIHRvIGJlIGZsb2F0XG5cdFx0XHRcdHZhbCA9IHBhcnNlRmxvYXQodmFsKTtcblx0XHRcdFx0aWYgKCFfdXRpbC50eXBlLk51bWJlcih2YWwpIHx8IHZhbCA8IDApIHtcblx0XHRcdFx0XHRpZiAoX2R1cmF0aW9uVXBkYXRlTWV0aG9kKSB7XG5cdFx0XHRcdFx0XHRfZHVyYXRpb25VcGRhdGVNZXRob2QgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHR0aHJvdyBbXCJJbnZhbGlkIHJldHVybiB2YWx1ZSBvZiBzdXBwbGllZCBmdW5jdGlvbiBmb3Igb3B0aW9uIFxcXCJkdXJhdGlvblxcXCI6XCIsIHZhbF07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IFtcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiZHVyYXRpb25cXFwiOlwiLCB2YWxdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogQ2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBhIHNwZWNpZmljIG9yIGFsbCBvcHRpb25zIGFuZCByZXNldCB0byBkZWZhdWx0IGlmIG5lY2Nlc3NhcnkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgdmFsaWRhdGVPcHRpb24gPSBmdW5jdGlvbiAoY2hlY2spIHtcblx0XHRcdGNoZWNrID0gYXJndW1lbnRzLmxlbmd0aCA/IFtjaGVja10gOiBPYmplY3Qua2V5cyhfdmFsaWRhdGUpO1xuXHRcdFx0Y2hlY2suZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uTmFtZSwga2V5KSB7XG5cdFx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdFx0aWYgKF92YWxpZGF0ZVtvcHRpb25OYW1lXSkgeyAvLyB0aGVyZSBpcyBhIHZhbGlkYXRpb24gbWV0aG9kIGZvciB0aGlzIG9wdGlvblxuXHRcdFx0XHRcdHRyeSB7IC8vIHZhbGlkYXRlIHZhbHVlXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IF92YWxpZGF0ZVtvcHRpb25OYW1lXShfb3B0aW9uc1tvcHRpb25OYW1lXSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkgeyAvLyB2YWxpZGF0aW9uIGZhaWxlZCAtPiByZXNldCB0byBkZWZhdWx0XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IERFRkFVTFRfT1BUSU9OU1tvcHRpb25OYW1lXTtcblx0XHRcdFx0XHRcdHZhciBsb2dNU0cgPSBfdXRpbC50eXBlLlN0cmluZyhlKSA/IFtlXSA6IGU7XG5cdFx0XHRcdFx0XHRpZiAoX3V0aWwudHlwZS5BcnJheShsb2dNU0cpKSB7XG5cdFx0XHRcdFx0XHRcdGxvZ01TR1swXSA9IFwiRVJST1I6IFwiICsgbG9nTVNHWzBdO1xuXHRcdFx0XHRcdFx0XHRsb2dNU0cudW5zaGlmdCgxKTsgLy8gbG9nbGV2ZWwgMSBmb3IgZXJyb3IgbXNnXG5cdFx0XHRcdFx0XHRcdGxvZy5hcHBseSh0aGlzLCBsb2dNU0cpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bG9nKDEsIFwiRVJST1I6IFByb2JsZW0gZXhlY3V0aW5nIHZhbGlkYXRpb24gY2FsbGJhY2sgZm9yIG9wdGlvbiAnXCIgKyBvcHRpb25OYW1lICsgXCInOlwiLCBlLm1lc3NhZ2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRfb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhlbHBlciB1c2VkIGJ5IHRoZSBzZXR0ZXIvZ2V0dGVycyBmb3Igc2NlbmUgb3B0aW9uc1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIGNoYW5nZU9wdGlvbiA9IGZ1bmN0aW9uICh2YXJuYW1lLCBuZXd2YWwpIHtcblx0XHRcdHZhclxuXHRcdFx0Y2hhbmdlZCA9IGZhbHNlLFxuXHRcdFx0XHRvbGR2YWwgPSBfb3B0aW9uc1t2YXJuYW1lXTtcblx0XHRcdGlmIChfb3B0aW9uc1t2YXJuYW1lXSAhPSBuZXd2YWwpIHtcblx0XHRcdFx0X29wdGlvbnNbdmFybmFtZV0gPSBuZXd2YWw7XG5cdFx0XHRcdHZhbGlkYXRlT3B0aW9uKHZhcm5hbWUpOyAvLyByZXNldHMgdG8gZGVmYXVsdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0Y2hhbmdlZCA9IG9sZHZhbCAhPSBfb3B0aW9uc1t2YXJuYW1lXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHQvLyBnZW5lcmF0ZSBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBvcHRpb25zXG5cdFx0dmFyIGFkZFNjZW5lT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbk5hbWUpIHtcblx0XHRcdGlmICghU2NlbmVbb3B0aW9uTmFtZV0pIHtcblx0XHRcdFx0U2NlbmVbb3B0aW9uTmFtZV0gPSBmdW5jdGlvbiAobmV3VmFsKSB7XG5cdFx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7IC8vIGdldFxuXHRcdFx0XHRcdFx0cmV0dXJuIF9vcHRpb25zW29wdGlvbk5hbWVdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob3B0aW9uTmFtZSA9PT0gXCJkdXJhdGlvblwiKSB7IC8vIG5ldyBkdXJhdGlvbiBpcyBzZXQsIHNvIGFueSBwcmV2aW91c2x5IHNldCBmdW5jdGlvbiBtdXN0IGJlIHVuc2V0XG5cdFx0XHRcdFx0XHRcdF9kdXJhdGlvblVwZGF0ZU1ldGhvZCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChjaGFuZ2VPcHRpb24ob3B0aW9uTmFtZSwgbmV3VmFsKSkgeyAvLyBzZXRcblx0XHRcdFx0XHRcdFx0U2NlbmUudHJpZ2dlcihcImNoYW5nZVwiLCB7XG5cdFx0XHRcdFx0XHRcdFx0d2hhdDogb3B0aW9uTmFtZSxcblx0XHRcdFx0XHRcdFx0XHRuZXd2YWw6IF9vcHRpb25zW29wdGlvbk5hbWVdXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRpZiAoU0NFTkVfT1BUSU9OUy5zaGlmdHMuaW5kZXhPZihvcHRpb25OYW1lKSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0U2NlbmUudHJpZ2dlcihcInNoaWZ0XCIsIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlYXNvbjogb3B0aW9uTmFtZVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBTY2VuZTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiBvciAqKlNldCoqIHRoZSBkdXJhdGlvbiBvcHRpb24gdmFsdWUuXG5cdFx0ICogQXMgYSBzZXR0ZXIgaXQgYWxzbyBhY2NlcHRzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgbnVtZXJpYyB2YWx1ZS4gIFxuXHRcdCAqIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgcmVzcG9uc2l2ZSBzZXR1cHMuXG5cdFx0ICpcblx0XHQgKiBUaGUgZHVyYXRpb24gaXMgdXBkYXRlZCB1c2luZyB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gZXZlcnkgdGltZSBgU2NlbmUucmVmcmVzaCgpYCBpcyBjYWxsZWQsIHdoaWNoIGhhcHBlbnMgcGVyaW9kaWNhbGx5IGZyb20gdGhlIGNvbnRyb2xsZXIgKHNlZSBTY3JvbGxNYWdpYy5Db250cm9sbGVyIG9wdGlvbiBgcmVmcmVzaEludGVydmFsYCkuICBcblx0XHQgKiBfKipOT1RFOioqIEJlIGF3YXJlIHRoYXQgaXQncyBhbiBlYXN5IHdheSB0byBraWxsIHBlcmZvcm1hbmNlLCBpZiB5b3Ugc3VwcGx5IGEgZnVuY3Rpb24gdGhhdCBoYXMgaGlnaCBDUFUgZGVtYW5kLiAgXG5cdFx0ICogRXZlbiBmb3Igc2l6ZSBhbmQgcG9zaXRpb24gY2FsY3VsYXRpb25zIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhIHZhcmlhYmxlIHRvIGNhY2hlIHRoZSB2YWx1ZS4gKHNlZSBleGFtcGxlKSAgXG5cdFx0ICogVGhpcyBjb3VudHMgZG91YmxlIGlmIHlvdSB1c2UgdGhlIHNhbWUgZnVuY3Rpb24gZm9yIG11bHRpcGxlIHNjZW5lcy5fXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI2R1cmF0aW9uXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgZHVyYXRpb24gdmFsdWVcblx0XHQgKiB2YXIgZHVyYXRpb24gPSBzY2VuZS5kdXJhdGlvbigpO1xuXHRcdCAqXG5cdFx0ICogLy8gc2V0IGEgbmV3IGR1cmF0aW9uXG5cdFx0ICogc2NlbmUuZHVyYXRpb24oMzAwKTtcblx0XHQgKlxuXHRcdCAqIC8vIHVzZSBhIGZ1bmN0aW9uIHRvIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHRoZSBkdXJhdGlvbiB0byB0aGUgd2luZG93IGhlaWdodC5cblx0XHQgKiB2YXIgZHVyYXRpb25WYWx1ZUNhY2hlO1xuXHRcdCAqIGZ1bmN0aW9uIGdldER1cmF0aW9uICgpIHtcblx0XHQgKiAgIHJldHVybiBkdXJhdGlvblZhbHVlQ2FjaGU7XG5cdFx0ICogfVxuXHRcdCAqIGZ1bmN0aW9uIHVwZGF0ZUR1cmF0aW9uIChlKSB7XG5cdFx0ICogICBkdXJhdGlvblZhbHVlQ2FjaGUgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cdFx0ICogfVxuXHRcdCAqICQod2luZG93KS5vbihcInJlc2l6ZVwiLCB1cGRhdGVEdXJhdGlvbik7IC8vIHVwZGF0ZSB0aGUgZHVyYXRpb24gd2hlbiB0aGUgd2luZG93IHNpemUgY2hhbmdlc1xuXHRcdCAqICQod2luZG93KS50cmlnZ2VySGFuZGxlcihcInJlc2l6ZVwiKTsgLy8gc2V0IHRvIGluaXRpYWwgdmFsdWVcblx0XHQgKiBzY2VuZS5kdXJhdGlvbihnZXREdXJhdGlvbik7IC8vIHN1cHBseSBkdXJhdGlvbiBtZXRob2Rcblx0XHQgKlxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuY2hhbmdlfSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuc2hpZnR9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQHBhcmFtIHsobnVtYmVyfGZ1bmN0aW9uKX0gW25ld0R1cmF0aW9uXSAtIFRoZSBuZXcgZHVyYXRpb24gb2YgdGhlIHNjZW5lLlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IGBnZXRgIC0gIEN1cnJlbnQgc2NlbmUgZHVyYXRpb24uXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBgc2V0YCAtICBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0Kiogb3IgKipTZXQqKiB0aGUgb2Zmc2V0IG9wdGlvbiB2YWx1ZS5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI29mZnNldFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IG9mZnNldFxuXHRcdCAqIHZhciBvZmZzZXQgPSBzY2VuZS5vZmZzZXQoKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNldCBhIG5ldyBvZmZzZXRcblx0XHQgKiBzY2VuZS5vZmZzZXQoMTAwKTtcblx0XHQgKlxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuY2hhbmdlfSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuc2hpZnR9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IFtuZXdPZmZzZXRdIC0gVGhlIG5ldyBvZmZzZXQgb2YgdGhlIHNjZW5lLlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IGBnZXRgIC0gIEN1cnJlbnQgc2NlbmUgb2Zmc2V0LlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gYHNldGAgLSAgUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIG9yICoqU2V0KiogdGhlIHRyaWdnZXJFbGVtZW50IG9wdGlvbiB2YWx1ZS5cblx0XHQgKiBEb2VzICoqbm90KiogZmlyZSBgU2NlbmUuc2hpZnRgLCBiZWNhdXNlIGNoYW5naW5nIHRoZSB0cmlnZ2VyIEVsZW1lbnQgZG9lc24ndCBuZWNlc3NhcmlseSBtZWFuIHRoZSBzdGFydCBwb3NpdGlvbiBjaGFuZ2VzLiBUaGlzIHdpbGwgYmUgZGV0ZXJtaW5lZCBpbiBgU2NlbmUucmVmcmVzaCgpYCwgd2hpY2ggaXMgYXV0b21hdGljYWxseSB0cmlnZ2VyZWQuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSN0cmlnZ2VyRWxlbWVudFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IHRyaWdnZXJFbGVtZW50XG5cdFx0ICogdmFyIHRyaWdnZXJFbGVtZW50ID0gc2NlbmUudHJpZ2dlckVsZW1lbnQoKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNldCBhIG5ldyB0cmlnZ2VyRWxlbWVudCB1c2luZyBhIHNlbGVjdG9yXG5cdFx0ICogc2NlbmUudHJpZ2dlckVsZW1lbnQoXCIjdHJpZ2dlclwiKTtcblx0XHQgKiAvLyBzZXQgYSBuZXcgdHJpZ2dlckVsZW1lbnQgdXNpbmcgYSBET00gb2JqZWN0XG5cdFx0ICogc2NlbmUudHJpZ2dlckVsZW1lbnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0cmlnZ2VyXCIpKTtcblx0XHQgKlxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuY2hhbmdlfSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSBbbmV3VHJpZ2dlckVsZW1lbnRdIC0gVGhlIG5ldyB0cmlnZ2VyIGVsZW1lbnQgZm9yIHRoZSBzY2VuZS5cblx0XHQgKiBAcmV0dXJucyB7KHN0cmluZ3xvYmplY3QpfSBgZ2V0YCAtICBDdXJyZW50IHRyaWdnZXJFbGVtZW50LlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gYHNldGAgLSAgUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIG9yICoqU2V0KiogdGhlIHRyaWdnZXJIb29rIG9wdGlvbiB2YWx1ZS5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3RyaWdnZXJIb29rXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgdHJpZ2dlckhvb2sgdmFsdWVcblx0XHQgKiB2YXIgdHJpZ2dlckhvb2sgPSBzY2VuZS50cmlnZ2VySG9vaygpO1xuXHRcdCAqXG5cdFx0ICogLy8gc2V0IGEgbmV3IHRyaWdnZXJIb29rIHVzaW5nIGEgc3RyaW5nXG5cdFx0ICogc2NlbmUudHJpZ2dlckhvb2soXCJvbkxlYXZlXCIpO1xuXHRcdCAqIC8vIHNldCBhIG5ldyB0cmlnZ2VySG9vayB1c2luZyBhIG51bWJlclxuXHRcdCAqIHNjZW5lLnRyaWdnZXJIb29rKDAuNyk7XG5cdFx0ICpcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmNoYW5nZX0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLnNoaWZ0fSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBbbmV3VHJpZ2dlckhvb2tdIC0gVGhlIG5ldyB0cmlnZ2VySG9vayBvZiB0aGUgc2NlbmUuIFNlZSB7QGxpbmsgU2NlbmV9IHBhcmFtZXRlciBkZXNjcmlwdGlvbiBmb3IgdmFsdWUgb3B0aW9ucy5cblx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfSBgZ2V0YCAtICBDdXJyZW50IHRyaWdnZXJIb29rIChBTFdBWVMgbnVtZXJpY2FsKS5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IGBzZXRgIC0gIFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiBvciAqKlNldCoqIHRoZSByZXZlcnNlIG9wdGlvbiB2YWx1ZS5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3JldmVyc2Vcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCByZXZlcnNlIG9wdGlvblxuXHRcdCAqIHZhciByZXZlcnNlID0gc2NlbmUucmV2ZXJzZSgpO1xuXHRcdCAqXG5cdFx0ICogLy8gc2V0IG5ldyByZXZlcnNlIG9wdGlvblxuXHRcdCAqIHNjZW5lLnJldmVyc2UoZmFsc2UpO1xuXHRcdCAqXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5jaGFuZ2V9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbbmV3UmV2ZXJzZV0gLSBUaGUgbmV3IHJldmVyc2Ugc2V0dGluZyBvZiB0aGUgc2NlbmUuXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59IGBnZXRgIC0gIEN1cnJlbnQgcmV2ZXJzZSBvcHRpb24gdmFsdWUuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBgc2V0YCAtICBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0Kiogb3IgKipTZXQqKiB0aGUgbG9nbGV2ZWwgb3B0aW9uIHZhbHVlLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjbG9nbGV2ZWxcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCBsb2dsZXZlbFxuXHRcdCAqIHZhciBsb2dsZXZlbCA9IHNjZW5lLmxvZ2xldmVsKCk7XG5cdFx0ICpcblx0XHQgKiAvLyBzZXQgbmV3IGxvZ2xldmVsXG5cdFx0ICogc2NlbmUubG9nbGV2ZWwoMyk7XG5cdFx0ICpcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmNoYW5nZX0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gW25ld0xvZ2xldmVsXSAtIFRoZSBuZXcgbG9nbGV2ZWwgc2V0dGluZyBvZiB0aGUgc2NlbmUuIGBbMC0zXWBcblx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfSBgZ2V0YCAtICBDdXJyZW50IGxvZ2xldmVsLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gYHNldGAgLSAgUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIHRoZSBhc3NvY2lhdGVkIGNvbnRyb2xsZXIuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNjb250cm9sbGVyXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGNvbnRyb2xsZXIgb2YgYSBzY2VuZVxuXHRcdCAqIHZhciBjb250cm9sbGVyID0gc2NlbmUuY29udHJvbGxlcigpO1xuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge1Njcm9sbE1hZ2ljLkNvbnRyb2xsZXJ9IFBhcmVudCBjb250cm9sbGVyIG9yIGB1bmRlZmluZWRgXG5cdFx0ICovXG5cdFx0dGhpcy5jb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIF9jb250cm9sbGVyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIHRoZSBjdXJyZW50IHN0YXRlLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjc3RhdGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCBzdGF0ZVxuXHRcdCAqIHZhciBzdGF0ZSA9IHNjZW5lLnN0YXRlKCk7XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBgXCJCRUZPUkVcImAsIGBcIkRVUklOR1wiYCBvciBgXCJBRlRFUlwiYFxuXHRcdCAqL1xuXHRcdHRoaXMuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gX3N0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIHRoZSBjdXJyZW50IHNjcm9sbCBvZmZzZXQgZm9yIHRoZSBzdGFydCBvZiB0aGUgc2NlbmUuICBcblx0XHQgKiBNaW5kLCB0aGF0IHRoZSBzY3JvbGxPZmZzZXQgaXMgcmVsYXRlZCB0byB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyLCBpZiBgdHJpZ2dlckhvb2tgIGlzIGJpZ2dlciB0aGFuIGAwYCAob3IgYFwib25MZWF2ZVwiYCkuICBcblx0XHQgKiBUaGlzIG1lYW5zLCB0aGF0IHJlc2l6aW5nIHRoZSBjb250YWluZXIgb3IgY2hhbmdpbmcgdGhlIGB0cmlnZ2VySG9va2Agd2lsbCBpbmZsdWVuY2UgdGhlIHNjZW5lJ3Mgc3RhcnQgb2Zmc2V0LlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjc2Nyb2xsT2Zmc2V0XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgc2Nyb2xsIG9mZnNldCBmb3IgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHNjZW5lLlxuXHRcdCAqIHZhciBzdGFydCA9IHNjZW5lLnNjcm9sbE9mZnNldCgpO1xuXHRcdCAqIHZhciBlbmQgPSBzY2VuZS5zY3JvbGxPZmZzZXQoKSArIHNjZW5lLmR1cmF0aW9uKCk7XG5cdFx0ICogY29uc29sZS5sb2coXCJ0aGUgc2NlbmUgc3RhcnRzIGF0XCIsIHN0YXJ0LCBcImFuZCBlbmRzIGF0XCIsIGVuZCk7XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc2Nyb2xsIG9mZnNldCAob2YgdGhlIGNvbnRhaW5lcikgYXQgd2hpY2ggdGhlIHNjZW5lIHdpbGwgdHJpZ2dlci4gWSB2YWx1ZSBmb3IgdmVydGljYWwgYW5kIFggdmFsdWUgZm9yIGhvcml6b250YWwgc2Nyb2xscy5cblx0XHQgKi9cblx0XHR0aGlzLnNjcm9sbE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBfc2Nyb2xsT2Zmc2V0LnN0YXJ0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIHRoZSB0cmlnZ2VyIHBvc2l0aW9uIG9mIHRoZSBzY2VuZSAoaW5jbHVkaW5nIHRoZSB2YWx1ZSBvZiB0aGUgYG9mZnNldGAgb3B0aW9uKS4gIFxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjdHJpZ2dlclBvc2l0aW9uXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIHNjZW5lJ3MgdHJpZ2dlciBwb3NpdGlvblxuXHRcdCAqIHZhciB0cmlnZ2VyUG9zaXRpb24gPSBzY2VuZS50cmlnZ2VyUG9zaXRpb24oKTtcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IFN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzY2VuZS4gVG9wIHBvc2l0aW9uIHZhbHVlIGZvciB2ZXJ0aWNhbCBhbmQgbGVmdCBwb3NpdGlvbiB2YWx1ZSBmb3IgaG9yaXpvbnRhbCBzY3JvbGxzLlxuXHRcdCAqL1xuXHRcdHRoaXMudHJpZ2dlclBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHBvcyA9IF9vcHRpb25zLm9mZnNldDsgLy8gdGhlIG9mZnNldCBpcyB0aGUgYmFzaXNcblx0XHRcdGlmIChfY29udHJvbGxlcikge1xuXHRcdFx0XHQvLyBnZXQgdGhlIHRyaWdnZXIgcG9zaXRpb25cblx0XHRcdFx0aWYgKF9vcHRpb25zLnRyaWdnZXJFbGVtZW50KSB7XG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBhcyB0cmlnZ2VyXG5cdFx0XHRcdFx0cG9zICs9IF90cmlnZ2VyUG9zO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB0cmlnZ2VySG9vayB0byBzdGFydCBhdCB0aGUgYmVnaW5uaW5nXG5cdFx0XHRcdFx0cG9zICs9IF9jb250cm9sbGVyLmluZm8oXCJzaXplXCIpICogU2NlbmUudHJpZ2dlckhvb2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBvcztcblx0XHR9O1xuXG5cdFx0dmFyXG5cdFx0X3BpbiwgX3Bpbk9wdGlvbnM7XG5cblx0XHRTY2VuZS5vbihcInNoaWZ0LmludGVybmFsXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgZHVyYXRpb25DaGFuZ2VkID0gZS5yZWFzb24gPT09IFwiZHVyYXRpb25cIjtcblx0XHRcdGlmICgoX3N0YXRlID09PSBTQ0VORV9TVEFURV9BRlRFUiAmJiBkdXJhdGlvbkNoYW5nZWQpIHx8IChfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0RVUklORyAmJiBfb3B0aW9ucy5kdXJhdGlvbiA9PT0gMCkpIHtcblx0XHRcdFx0Ly8gaWYgW2R1cmF0aW9uIGNoYW5nZWQgYWZ0ZXIgYSBzY2VuZSAoaW5zaWRlIHNjZW5lIHByb2dyZXNzIHVwZGF0ZXMgcGluIHBvc2l0aW9uKV0gb3IgW2R1cmF0aW9uIGlzIDAsIHdlIGFyZSBpbiBwaW4gcGhhc2UgYW5kIHNvbWUgb3RoZXIgdmFsdWUgY2hhbmdlZF0uXG5cdFx0XHRcdHVwZGF0ZVBpblN0YXRlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZHVyYXRpb25DaGFuZ2VkKSB7XG5cdFx0XHRcdHVwZGF0ZVBpbkRpbWVuc2lvbnMoKTtcblx0XHRcdH1cblx0XHR9KS5vbihcInByb2dyZXNzLmludGVybmFsXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR1cGRhdGVQaW5TdGF0ZSgpO1xuXHRcdH0pLm9uKFwiYWRkLmludGVybmFsXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR1cGRhdGVQaW5EaW1lbnNpb25zKCk7XG5cdFx0fSkub24oXCJkZXN0cm95LmludGVybmFsXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRTY2VuZS5yZW1vdmVQaW4oZS5yZXNldCk7XG5cdFx0fSk7XG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBwaW4gc3RhdGUuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgdXBkYXRlUGluU3RhdGUgPSBmdW5jdGlvbiAoZm9yY2VVbnBpbikge1xuXHRcdFx0aWYgKF9waW4gJiYgX2NvbnRyb2xsZXIpIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdGNvbnRhaW5lckluZm8gPSBfY29udHJvbGxlci5pbmZvKCksXG5cdFx0XHRcdFx0cGluVGFyZ2V0ID0gX3Bpbk9wdGlvbnMuc3BhY2VyLmZpcnN0Q2hpbGQ7IC8vIG1heSBiZSBwaW4gZWxlbWVudCBvciBhbm90aGVyIHNwYWNlciwgaWYgY2FzY2FkaW5nIHBpbnNcblx0XHRcdFx0aWYgKCFmb3JjZVVucGluICYmIF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfRFVSSU5HKSB7IC8vIGR1cmluZyBzY2VuZSBvciBpZiBkdXJhdGlvbiBpcyAwIGFuZCB3ZSBhcmUgcGFzdCB0aGUgdHJpZ2dlclxuXHRcdFx0XHRcdC8vIHBpbm5lZCBzdGF0ZVxuXHRcdFx0XHRcdGlmIChfdXRpbC5jc3MocGluVGFyZ2V0LCBcInBvc2l0aW9uXCIpICE9IFwiZml4ZWRcIikge1xuXHRcdFx0XHRcdFx0Ly8gY2hhbmdlIHN0YXRlIGJlZm9yZSB1cGRhdGluZyBwaW4gc3BhY2VyIChwb3NpdGlvbiBjaGFuZ2VzIGR1ZSB0byBmaXhlZCBjb2xsYXBzaW5nIG1pZ2h0IG9jY3VyLilcblx0XHRcdFx0XHRcdF91dGlsLmNzcyhwaW5UYXJnZXQsIHtcblx0XHRcdFx0XHRcdFx0XCJwb3NpdGlvblwiOiBcImZpeGVkXCJcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHBpbiBzcGFjZXJcblx0XHRcdFx0XHRcdHVwZGF0ZVBpbkRpbWVuc2lvbnMoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRmaXhlZFBvcyA9IF91dGlsLmdldC5vZmZzZXQoX3Bpbk9wdGlvbnMuc3BhY2VyLCB0cnVlKSxcblx0XHRcdFx0XHRcdC8vIGdldCB2aWV3cG9ydCBwb3NpdGlvbiBvZiBzcGFjZXJcblx0XHRcdFx0XHRcdHNjcm9sbERpc3RhbmNlID0gX29wdGlvbnMucmV2ZXJzZSB8fCBfb3B0aW9ucy5kdXJhdGlvbiA9PT0gMCA/IGNvbnRhaW5lckluZm8uc2Nyb2xsUG9zIC0gX3Njcm9sbE9mZnNldC5zdGFydCAvLyBxdWlja2VyXG5cdFx0XHRcdFx0XHQ6IE1hdGgucm91bmQoX3Byb2dyZXNzICogX29wdGlvbnMuZHVyYXRpb24gKiAxMCkgLyAxMDsgLy8gaWYgbm8gcmV2ZXJzZSBhbmQgZHVyaW5nIHBpbiB0aGUgcG9zaXRpb24gbmVlZHMgdG8gYmUgcmVjYWxjdWxhdGVkIHVzaW5nIHRoZSBwcm9ncmVzc1xuXHRcdFx0XHRcdC8vIGFkZCBzY3JvbGxEaXN0YW5jZVxuXHRcdFx0XHRcdGZpeGVkUG9zW2NvbnRhaW5lckluZm8udmVydGljYWwgPyBcInRvcFwiIDogXCJsZWZ0XCJdICs9IHNjcm9sbERpc3RhbmNlO1xuXG5cdFx0XHRcdFx0Ly8gc2V0IG5ldyB2YWx1ZXNcblx0XHRcdFx0XHRfdXRpbC5jc3MoX3Bpbk9wdGlvbnMuc3BhY2VyLmZpcnN0Q2hpbGQsIHtcblx0XHRcdFx0XHRcdHRvcDogZml4ZWRQb3MudG9wLFxuXHRcdFx0XHRcdFx0bGVmdDogZml4ZWRQb3MubGVmdFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVucGlubmVkIHN0YXRlXG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0bmV3Q1NTID0ge1xuXHRcdFx0XHRcdFx0cG9zaXRpb246IF9waW5PcHRpb25zLmluRmxvdyA/IFwicmVsYXRpdmVcIiA6IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRcdGxlZnQ6IDBcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0Y2hhbmdlID0gX3V0aWwuY3NzKHBpblRhcmdldCwgXCJwb3NpdGlvblwiKSAhPSBuZXdDU1MucG9zaXRpb247XG5cblx0XHRcdFx0XHRpZiAoIV9waW5PcHRpb25zLnB1c2hGb2xsb3dlcnMpIHtcblx0XHRcdFx0XHRcdG5ld0NTU1tjb250YWluZXJJbmZvLnZlcnRpY2FsID8gXCJ0b3BcIiA6IFwibGVmdFwiXSA9IF9vcHRpb25zLmR1cmF0aW9uICogX3Byb2dyZXNzO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoX29wdGlvbnMuZHVyYXRpb24gPiAwKSB7IC8vIG9ubHkgY29uY2VybnMgc2NlbmVzIHdpdGggZHVyYXRpb25cblx0XHRcdFx0XHRcdGlmIChfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0FGVEVSICYmIHBhcnNlRmxvYXQoX3V0aWwuY3NzKF9waW5PcHRpb25zLnNwYWNlciwgXCJwYWRkaW5nLXRvcFwiKSkgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0Y2hhbmdlID0gdHJ1ZTsgLy8gaWYgaW4gYWZ0ZXIgc3RhdGUgYnV0IGhhdmVudCB1cGRhdGVkIHNwYWNlciB5ZXQgKGp1bXBlZCBwYXN0IHBpbilcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoX3N0YXRlID09PSBTQ0VORV9TVEFURV9CRUZPUkUgJiYgcGFyc2VGbG9hdChfdXRpbC5jc3MoX3Bpbk9wdGlvbnMuc3BhY2VyLCBcInBhZGRpbmctYm90dG9tXCIpKSA9PT0gMCkgeyAvLyBiZWZvcmVcblx0XHRcdFx0XHRcdFx0Y2hhbmdlID0gdHJ1ZTsgLy8ganVtcGVkIHBhc3QgZml4ZWQgc3RhdGUgdXB3YXJkIGRpcmVjdGlvblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBzZXQgbmV3IHZhbHVlc1xuXHRcdFx0XHRcdF91dGlsLmNzcyhwaW5UYXJnZXQsIG5ld0NTUyk7XG5cdFx0XHRcdFx0aWYgKGNoYW5nZSkge1xuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHBpbiBzcGFjZXIgaWYgc3RhdGUgY2hhbmdlZFxuXHRcdFx0XHRcdFx0dXBkYXRlUGluRGltZW5zaW9ucygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdGhlIHBpbiBzcGFjZXIgYW5kL29yIGVsZW1lbnQgc2l6ZS5cblx0XHQgKiBUaGUgc2l6ZSBvZiB0aGUgc3BhY2VyIG5lZWRzIHRvIGJlIHVwZGF0ZWQgd2hlbmV2ZXIgdGhlIGR1cmF0aW9uIG9mIHRoZSBzY2VuZSBjaGFuZ2VzLCBpZiBpdCBpcyB0byBwdXNoIGRvd24gZm9sbG93aW5nIGVsZW1lbnRzLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHVwZGF0ZVBpbkRpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoX3BpbiAmJiBfY29udHJvbGxlciAmJiBfcGluT3B0aW9ucy5pbkZsb3cpIHsgLy8gbm8gc3BhY2VycmVzaXplLCBpZiBvcmlnaW5hbCBwb3NpdGlvbiBpcyBhYnNvbHV0ZVxuXHRcdFx0XHR2YXJcblx0XHRcdFx0YWZ0ZXIgPSAoX3N0YXRlID09PSBTQ0VORV9TVEFURV9BRlRFUiksXG5cdFx0XHRcdFx0YmVmb3JlID0gKF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfQkVGT1JFKSxcblx0XHRcdFx0XHRkdXJpbmcgPSAoX3N0YXRlID09PSBTQ0VORV9TVEFURV9EVVJJTkcpLFxuXHRcdFx0XHRcdHZlcnRpY2FsID0gX2NvbnRyb2xsZXIuaW5mbyhcInZlcnRpY2FsXCIpLFxuXHRcdFx0XHRcdHBpblRhcmdldCA9IF9waW5PcHRpb25zLnNwYWNlci5maXJzdENoaWxkLFxuXHRcdFx0XHRcdC8vIHVzdWFsbHkgdGhlIHBpbmVkIGVsZW1lbnQgYnV0IGNhbiBhbHNvIGJlIGFub3RoZXIgc3BhY2VyIChjYXNjYWRlZCBwaW5zKVxuXHRcdFx0XHRcdG1hcmdpbkNvbGxhcHNlID0gX3V0aWwuaXNNYXJnaW5Db2xsYXBzZVR5cGUoX3V0aWwuY3NzKF9waW5PcHRpb25zLnNwYWNlciwgXCJkaXNwbGF5XCIpKSxcblx0XHRcdFx0XHRjc3MgPSB7fTtcblxuXHRcdFx0XHQvLyBzZXQgbmV3IHNpemVcblx0XHRcdFx0Ly8gaWYgcmVsc2l6ZTogc3BhY2VyIC0+IHBpbiB8IGVsc2U6IHBpbiAtPiBzcGFjZXJcblx0XHRcdFx0aWYgKF9waW5PcHRpb25zLnJlbFNpemUud2lkdGggfHwgX3Bpbk9wdGlvbnMucmVsU2l6ZS5hdXRvRnVsbFdpZHRoKSB7XG5cdFx0XHRcdFx0aWYgKGR1cmluZykge1xuXHRcdFx0XHRcdFx0X3V0aWwuY3NzKF9waW4sIHtcblx0XHRcdFx0XHRcdFx0XCJ3aWR0aFwiOiBfdXRpbC5nZXQud2lkdGgoX3Bpbk9wdGlvbnMuc3BhY2VyKVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdF91dGlsLmNzcyhfcGluLCB7XG5cdFx0XHRcdFx0XHRcdFwid2lkdGhcIjogXCIxMDAlXCJcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBtaW53aWR0aCBpcyBuZWVkZWQgZm9yIGNhc2NhZGVkIHBpbnMuXG5cdFx0XHRcdFx0Y3NzW1wibWluLXdpZHRoXCJdID0gX3V0aWwuZ2V0LndpZHRoKHZlcnRpY2FsID8gX3BpbiA6IHBpblRhcmdldCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0Y3NzLndpZHRoID0gZHVyaW5nID8gY3NzW1wibWluLXdpZHRoXCJdIDogXCJhdXRvXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9waW5PcHRpb25zLnJlbFNpemUuaGVpZ2h0KSB7XG5cdFx0XHRcdFx0aWYgKGR1cmluZykge1xuXHRcdFx0XHRcdFx0Ly8gdGhlIG9ubHkgcGFkZGluZyB0aGUgc3BhY2VyIHNob3VsZCBldmVyIGluY2x1ZGUgaXMgdGhlIGR1cmF0aW9uIChpZiBwdXNoRm9sbG93ZXJzID0gdHJ1ZSksIHNvIHdlIG5lZWQgdG8gc3Vic3RyYWN0IHRoYXQuXG5cdFx0XHRcdFx0XHRfdXRpbC5jc3MoX3Bpbiwge1xuXHRcdFx0XHRcdFx0XHRcImhlaWdodFwiOiBfdXRpbC5nZXQuaGVpZ2h0KF9waW5PcHRpb25zLnNwYWNlcikgLSAoX3Bpbk9wdGlvbnMucHVzaEZvbGxvd2VycyA/IF9vcHRpb25zLmR1cmF0aW9uIDogMClcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfdXRpbC5jc3MoX3Bpbiwge1xuXHRcdFx0XHRcdFx0XHRcImhlaWdodFwiOiBcIjEwMCVcIlxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG1hcmdpbiBpcyBvbmx5IGluY2x1ZGVkIGlmIGl0J3MgYSBjYXNjYWRlZCBwaW4gdG8gcmVzb2x2ZSBhbiBJRTkgYnVnXG5cdFx0XHRcdFx0Y3NzW1wibWluLWhlaWdodFwiXSA9IF91dGlsLmdldC5oZWlnaHQodmVydGljYWwgPyBwaW5UYXJnZXQgOiBfcGluLCB0cnVlLCAhbWFyZ2luQ29sbGFwc2UpOyAvLyBuZWVkZWQgZm9yIGNhc2NhZGluZyBwaW5zXG5cdFx0XHRcdFx0Y3NzLmhlaWdodCA9IGR1cmluZyA/IGNzc1tcIm1pbi1oZWlnaHRcIl0gOiBcImF1dG9cIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFkZCBzcGFjZSBmb3IgZHVyYXRpb24gaWYgcHVzaEZvbGxvd2VycyBpcyB0cnVlXG5cdFx0XHRcdGlmIChfcGluT3B0aW9ucy5wdXNoRm9sbG93ZXJzKSB7XG5cdFx0XHRcdFx0Y3NzW1wicGFkZGluZ1wiICsgKHZlcnRpY2FsID8gXCJUb3BcIiA6IFwiTGVmdFwiKV0gPSBfb3B0aW9ucy5kdXJhdGlvbiAqIF9wcm9ncmVzcztcblx0XHRcdFx0XHRjc3NbXCJwYWRkaW5nXCIgKyAodmVydGljYWwgPyBcIkJvdHRvbVwiIDogXCJSaWdodFwiKV0gPSBfb3B0aW9ucy5kdXJhdGlvbiAqICgxIC0gX3Byb2dyZXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdXRpbC5jc3MoX3Bpbk9wdGlvbnMuc3BhY2VyLCBjc3MpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBQaW4gc3RhdGUgKGluIGNlcnRhaW4gc2NlbmFyaW9zKVxuXHRcdCAqIElmIHRoZSBjb250cm9sbGVyIGNvbnRhaW5lciBpcyBub3QgdGhlIGRvY3VtZW50IGFuZCB3ZSBhcmUgbWlkLXBpbi1waGFzZSBzY3JvbGxpbmcgb3IgcmVzaXppbmcgdGhlIG1haW4gZG9jdW1lbnQgY2FuIHJlc3VsdCB0byB3cm9uZyBwaW4gcG9zaXRpb25zLlxuXHRcdCAqIFNvIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIHJlc2l6ZSBhbmQgc2Nyb2xsIG9mIHRoZSBkb2N1bWVudC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciB1cGRhdGVQaW5JbkNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChfY29udHJvbGxlciAmJiBfcGluICYmIF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfRFVSSU5HICYmICFfY29udHJvbGxlci5pbmZvKFwiaXNEb2N1bWVudFwiKSkge1xuXHRcdFx0XHR1cGRhdGVQaW5TdGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBQaW4gc3BhY2VyIHNpemUgc3RhdGUgKGluIGNlcnRhaW4gc2NlbmFyaW9zKVxuXHRcdCAqIElmIGNvbnRhaW5lciBpcyByZXNpemVkIGR1cmluZyBwaW4gYW5kIHJlbGF0aXZlbHkgc2l6ZWQgdGhlIHNpemUgb2YgdGhlIHBpbiBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWQuLi5cblx0XHQgKiBTbyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiByZXNpemUgb2YgdGhlIGNvbnRhaW5lci5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciB1cGRhdGVSZWxhdGl2ZVBpblNwYWNlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChfY29udHJvbGxlciAmJiBfcGluICYmIC8vIHdlbGwsIGR1aFxuXHRcdFx0X3N0YXRlID09PSBTQ0VORV9TVEFURV9EVVJJTkcgJiYgLy8gZWxlbWVudCBpbiBwaW5uZWQgc3RhdGU/XG5cdFx0XHQoIC8vIGlzIHdpZHRoIG9yIGhlaWdodCByZWxhdGl2ZWx5IHNpemVkLCBidXQgbm90IGluIHJlbGF0aW9uIHRvIGJvZHk/IHRoZW4gd2UgbmVlZCB0byByZWNhbGMuXG5cdFx0XHQoKF9waW5PcHRpb25zLnJlbFNpemUud2lkdGggfHwgX3Bpbk9wdGlvbnMucmVsU2l6ZS5hdXRvRnVsbFdpZHRoKSAmJiBfdXRpbC5nZXQud2lkdGgod2luZG93KSAhPSBfdXRpbC5nZXQud2lkdGgoX3Bpbk9wdGlvbnMuc3BhY2VyLnBhcmVudE5vZGUpKSB8fCAoX3Bpbk9wdGlvbnMucmVsU2l6ZS5oZWlnaHQgJiYgX3V0aWwuZ2V0LmhlaWdodCh3aW5kb3cpICE9IF91dGlsLmdldC5oZWlnaHQoX3Bpbk9wdGlvbnMuc3BhY2VyLnBhcmVudE5vZGUpKSkpIHtcblx0XHRcdFx0dXBkYXRlUGluRGltZW5zaW9ucygpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBJcyBjYWxsZWQsIHdoZW4gdGhlIG1vdXNld2hlbCBpcyB1c2VkIHdoaWxlIG92ZXIgYSBwaW5uZWQgZWxlbWVudCBpbnNpZGUgYSBkaXYgY29udGFpbmVyLlxuXHRcdCAqIElmIHRoZSBzY2VuZSBpcyBpbiBmaXhlZCBzdGF0ZSBzY3JvbGwgZXZlbnRzIHdvdWxkIGJlIGNvdW50ZWQgdG93YXJkcyB0aGUgYm9keS4gVGhpcyBmb3J3YXJkcyB0aGUgZXZlbnQgdG8gdGhlIHNjcm9sbCBjb250YWluZXIuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgb25Nb3VzZXdoZWVsT3ZlclBpbiA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoX2NvbnRyb2xsZXIgJiYgX3BpbiAmJiBfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0RVUklORyAmJiAhX2NvbnRyb2xsZXIuaW5mbyhcImlzRG9jdW1lbnRcIikpIHsgLy8gaW4gcGluIHN0YXRlXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0X2NvbnRyb2xsZXIuX3NldFNjcm9sbFBvcyhfY29udHJvbGxlci5pbmZvKFwic2Nyb2xsUG9zXCIpIC0gKChlLndoZWVsRGVsdGEgfHwgZVtfY29udHJvbGxlci5pbmZvKFwidmVydGljYWxcIikgPyBcIndoZWVsRGVsdGFZXCIgOiBcIndoZWVsRGVsdGFYXCJdKSAvIDMgfHwgLWUuZGV0YWlsICogMzApKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUGluIGFuIGVsZW1lbnQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgdHdlZW4uICBcblx0XHQgKiBJZiB0aGUgc2NlbmUgZHVyYXRpb24gaXMgMCB0aGUgZWxlbWVudCB3aWxsIG9ubHkgYmUgdW5waW5uZWQsIGlmIHRoZSB1c2VyIHNjcm9sbHMgYmFjayBwYXN0IHRoZSBzdGFydCBwb3NpdGlvbi4gIFxuXHRcdCAqIE1ha2Ugc3VyZSBvbmx5IG9uZSBwaW4gaXMgYXBwbGllZCB0byBhbiBlbGVtZW50IGF0IHRoZSBzYW1lIHRpbWUuXG5cdFx0ICogQW4gZWxlbWVudCBjYW4gYmUgcGlubmVkIG11bHRpcGxlIHRpbWVzLCBidXQgb25seSBzdWNjZXNzaXZlbHkuXG5cdFx0ICogXyoqTk9URToqKiBUaGUgb3B0aW9uIGBwdXNoRm9sbG93ZXJzYCBoYXMgbm8gZWZmZWN0LCB3aGVuIHRoZSBzY2VuZSBkdXJhdGlvbiBpcyAwLl9cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3NldFBpblxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gcGluIGVsZW1lbnQgYW5kIHB1c2ggYWxsIGZvbGxvd2luZyBlbGVtZW50cyBkb3duIGJ5IHRoZSBhbW91bnQgb2YgdGhlIHBpbiBkdXJhdGlvbi5cblx0XHQgKiBzY2VuZS5zZXRQaW4oXCIjcGluXCIpO1xuXHRcdCAqXG5cdFx0ICogLy8gcGluIGVsZW1lbnQgYW5kIGtlZXBpbmcgYWxsIGZvbGxvd2luZyBlbGVtZW50cyBpbiB0aGVpciBwbGFjZS4gVGhlIHBpbm5lZCBlbGVtZW50IHdpbGwgbW92ZSBwYXN0IHRoZW0uXG5cdFx0ICogc2NlbmUuc2V0UGluKFwiI3BpblwiLCB7cHVzaEZvbGxvd2VyczogZmFsc2V9KTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSBlbGVtZW50IC0gQSBTZWxlY3RvciB0YXJnZXRpbmcgYW4gZWxlbWVudCBvciBhIERPTSBvYmplY3QgdGhhdCBpcyBzdXBwb3NlZCB0byBiZSBwaW5uZWQuXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFtzZXR0aW5nc10gLSBzZXR0aW5ncyBmb3IgdGhlIHBpblxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldHRpbmdzLnB1c2hGb2xsb3dlcnM9dHJ1ZV0gLSBJZiBgdHJ1ZWAgZm9sbG93aW5nIGVsZW1lbnRzIHdpbGwgYmUgXCJwdXNoZWRcIiBkb3duIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHBpbiwgaWYgYGZhbHNlYCB0aGUgcGlubmVkIGVsZW1lbnQgd2lsbCBqdXN0IHNjcm9sbCBwYXN0IHRoZW0uICBcblx0XHQgSWdub3JlZCwgd2hlbiBkdXJhdGlvbiBpcyBgMGAuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtzZXR0aW5ncy5zcGFjZXJDbGFzcz1cInNjcm9sbG1hZ2ljLXBpbi1zcGFjZXJcIl0gLSBDbGFzc25hbWUgb2YgdGhlIHBpbiBzcGFjZXIgZWxlbWVudCwgd2hpY2ggaXMgdXNlZCB0byByZXBsYWNlIHRoZSBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnNldFBpbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZXR0aW5ncykge1xuXHRcdFx0dmFyXG5cdFx0XHRkZWZhdWx0U2V0dGluZ3MgPSB7XG5cdFx0XHRcdHB1c2hGb2xsb3dlcnM6IHRydWUsXG5cdFx0XHRcdHNwYWNlckNsYXNzOiBcInNjcm9sbG1hZ2ljLXBpbi1zcGFjZXJcIlxuXHRcdFx0fTtcblx0XHRcdHNldHRpbmdzID0gX3V0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHNldHRpbmdzKTtcblxuXHRcdFx0Ly8gdmFsaWRhdGUgRWxlbWVudFxuXHRcdFx0ZWxlbWVudCA9IF91dGlsLmdldC5lbGVtZW50cyhlbGVtZW50KVswXTtcblx0XHRcdGlmICghZWxlbWVudCkge1xuXHRcdFx0XHRsb2coMSwgXCJFUlJPUiBjYWxsaW5nIG1ldGhvZCAnc2V0UGluKCknOiBJbnZhbGlkIHBpbiBlbGVtZW50IHN1cHBsaWVkLlwiKTtcblx0XHRcdFx0cmV0dXJuIFNjZW5lOyAvLyBjYW5jZWxcblx0XHRcdH0gZWxzZSBpZiAoX3V0aWwuY3NzKGVsZW1lbnQsIFwicG9zaXRpb25cIikgPT09IFwiZml4ZWRcIikge1xuXHRcdFx0XHRsb2coMSwgXCJFUlJPUiBjYWxsaW5nIG1ldGhvZCAnc2V0UGluKCknOiBQaW4gZG9lcyBub3Qgd29yayB3aXRoIGVsZW1lbnRzIHRoYXQgYXJlIHBvc2l0aW9uZWQgJ2ZpeGVkJy5cIik7XG5cdFx0XHRcdHJldHVybiBTY2VuZTsgLy8gY2FuY2VsXG5cdFx0XHR9XG5cblx0XHRcdGlmIChfcGluKSB7IC8vIHByZWV4aXN0aW5nIHBpbj9cblx0XHRcdFx0aWYgKF9waW4gPT09IGVsZW1lbnQpIHtcblx0XHRcdFx0XHQvLyBzYW1lIHBpbiB3ZSBhbHJlYWR5IGhhdmUgLT4gZG8gbm90aGluZ1xuXHRcdFx0XHRcdHJldHVybiBTY2VuZTsgLy8gY2FuY2VsXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8ga2lsbCBvbGQgcGluXG5cdFx0XHRcdFx0U2NlbmUucmVtb3ZlUGluKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdFx0X3BpbiA9IGVsZW1lbnQ7XG5cblx0XHRcdHZhclxuXHRcdFx0cGFyZW50RGlzcGxheSA9IF9waW4ucGFyZW50Tm9kZS5zdHlsZS5kaXNwbGF5LFxuXHRcdFx0XHRib3VuZHNQYXJhbXMgPSBbXCJ0b3BcIiwgXCJsZWZ0XCIsIFwiYm90dG9tXCIsIFwicmlnaHRcIiwgXCJtYXJnaW5cIiwgXCJtYXJnaW5MZWZ0XCIsIFwibWFyZ2luUmlnaHRcIiwgXCJtYXJnaW5Ub3BcIiwgXCJtYXJnaW5Cb3R0b21cIl07XG5cblx0XHRcdF9waW4ucGFyZW50Tm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBoYWNrIHN0YXJ0IHRvIGZvcmNlIGNzcyB0byByZXR1cm4gc3R5bGVzaGVldCB2YWx1ZXMgaW5zdGVhZCBvZiBjYWxjdWxhdGVkIHB4IHZhbHVlcy5cblx0XHRcdHZhclxuXHRcdFx0aW5GbG93ID0gX3V0aWwuY3NzKF9waW4sIFwicG9zaXRpb25cIikgIT0gXCJhYnNvbHV0ZVwiLFxuXHRcdFx0XHRwaW5DU1MgPSBfdXRpbC5jc3MoX3BpbiwgYm91bmRzUGFyYW1zLmNvbmNhdChbXCJkaXNwbGF5XCJdKSksXG5cdFx0XHRcdHNpemVDU1MgPSBfdXRpbC5jc3MoX3BpbiwgW1wid2lkdGhcIiwgXCJoZWlnaHRcIl0pO1xuXHRcdFx0X3Bpbi5wYXJlbnROb2RlLnN0eWxlLmRpc3BsYXkgPSBwYXJlbnREaXNwbGF5OyAvLyBoYWNrIGVuZC5cblx0XHRcdGlmICghaW5GbG93ICYmIHNldHRpbmdzLnB1c2hGb2xsb3dlcnMpIHtcblx0XHRcdFx0bG9nKDIsIFwiV0FSTklORzogSWYgdGhlIHBpbm5lZCBlbGVtZW50IGlzIHBvc2l0aW9uZWQgYWJzb2x1dGVseSBwdXNoRm9sbG93ZXJzIHdpbGwgYmUgZGlzYWJsZWQuXCIpO1xuXHRcdFx0XHRzZXR0aW5ncy5wdXNoRm9sbG93ZXJzID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IC8vIHdhaXQgdW50aWwgYWxsIGZpbmlzaGVkLCBiZWNhdXNlIHdpdGggcmVzcG9uc2l2ZSBkdXJhdGlvbiBpdCB3aWxsIG9ubHkgYmUgc2V0IGFmdGVyIHNjZW5lIGlzIGFkZGVkIHRvIGNvbnRyb2xsZXJcblx0XHRcdFx0aWYgKF9waW4gJiYgX29wdGlvbnMuZHVyYXRpb24gPT09IDAgJiYgc2V0dGluZ3MucHVzaEZvbGxvd2Vycykge1xuXHRcdFx0XHRcdGxvZygyLCBcIldBUk5JTkc6IHB1c2hGb2xsb3dlcnMgPVwiLCB0cnVlLCBcImhhcyBubyBlZmZlY3QsIHdoZW4gc2NlbmUgZHVyYXRpb24gaXMgMC5cIik7XG5cdFx0XHRcdH1cblx0XHRcdH0sIDApO1xuXG5cdFx0XHQvLyBjcmVhdGUgc3BhY2VyIGFuZCBpbnNlcnRcblx0XHRcdHZhclxuXHRcdFx0c3BhY2VyID0gX3Bpbi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgX3BpbiksXG5cdFx0XHRcdHNwYWNlckNTUyA9IF91dGlsLmV4dGVuZChwaW5DU1MsIHtcblx0XHRcdFx0XHRwb3NpdGlvbjogaW5GbG93ID8gXCJyZWxhdGl2ZVwiIDogXCJhYnNvbHV0ZVwiLFxuXHRcdFx0XHRcdGJveFNpemluZzogXCJjb250ZW50LWJveFwiLFxuXHRcdFx0XHRcdG1vekJveFNpemluZzogXCJjb250ZW50LWJveFwiLFxuXHRcdFx0XHRcdHdlYmtpdEJveFNpemluZzogXCJjb250ZW50LWJveFwiXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIWluRmxvdykgeyAvLyBjb3B5IHNpemUgaWYgcG9zaXRpb25lZCBhYnNvbHV0ZWx5LCB0byB3b3JrIGZvciBib3R0b20vcmlnaHQgcG9zaXRpb25lZCBlbGVtZW50cy5cblx0XHRcdFx0X3V0aWwuZXh0ZW5kKHNwYWNlckNTUywgX3V0aWwuY3NzKF9waW4sIFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdKSk7XG5cdFx0XHR9XG5cblx0XHRcdF91dGlsLmNzcyhzcGFjZXIsIHNwYWNlckNTUyk7XG5cdFx0XHRzcGFjZXIuc2V0QXR0cmlidXRlKFBJTl9TUEFDRVJfQVRUUklCVVRFLCBcIlwiKTtcblx0XHRcdF91dGlsLmFkZENsYXNzKHNwYWNlciwgc2V0dGluZ3Muc3BhY2VyQ2xhc3MpO1xuXG5cdFx0XHQvLyBzZXQgdGhlIHBpbiBPcHRpb25zXG5cdFx0XHRfcGluT3B0aW9ucyA9IHtcblx0XHRcdFx0c3BhY2VyOiBzcGFjZXIsXG5cdFx0XHRcdHJlbFNpemU6IHsgLy8gc2F2ZSBpZiBzaXplIGlzIGRlZmluZWQgdXNpbmcgJSB2YWx1ZXMuIGlmIHNvLCBoYW5kbGUgc3BhY2VyIHJlc2l6ZSBkaWZmZXJlbnRseS4uLlxuXHRcdFx0XHRcdHdpZHRoOiBzaXplQ1NTLndpZHRoLnNsaWNlKC0xKSA9PT0gXCIlXCIsXG5cdFx0XHRcdFx0aGVpZ2h0OiBzaXplQ1NTLmhlaWdodC5zbGljZSgtMSkgPT09IFwiJVwiLFxuXHRcdFx0XHRcdGF1dG9GdWxsV2lkdGg6IHNpemVDU1Mud2lkdGggPT09IFwiYXV0b1wiICYmIGluRmxvdyAmJiBfdXRpbC5pc01hcmdpbkNvbGxhcHNlVHlwZShwaW5DU1MuZGlzcGxheSlcblx0XHRcdFx0fSxcblx0XHRcdFx0cHVzaEZvbGxvd2Vyczogc2V0dGluZ3MucHVzaEZvbGxvd2Vycyxcblx0XHRcdFx0aW5GbG93OiBpbkZsb3csXG5cdFx0XHRcdC8vIHN0b3JlcyBpZiB0aGUgZWxlbWVudCB0YWtlcyB1cCBzcGFjZSBpbiB0aGUgZG9jdW1lbnQgZmxvd1xuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCFfcGluLl9fX29yaWdTdHlsZSkge1xuXHRcdFx0XHRfcGluLl9fX29yaWdTdHlsZSA9IHt9O1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0cGluSW5saW5lQ1NTID0gX3Bpbi5zdHlsZSxcblx0XHRcdFx0XHRjb3B5U3R5bGVzID0gYm91bmRzUGFyYW1zLmNvbmNhdChbXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcInBvc2l0aW9uXCIsIFwiYm94U2l6aW5nXCIsIFwibW96Qm94U2l6aW5nXCIsIFwid2Via2l0Qm94U2l6aW5nXCJdKTtcblx0XHRcdFx0Y29weVN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0XHRfcGluLl9fX29yaWdTdHlsZVt2YWxdID0gcGluSW5saW5lQ1NTW3ZhbF0gfHwgXCJcIjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHJlbGF0aXZlIHNpemUsIHRyYW5zZmVyIGl0IHRvIHNwYWNlciBhbmQgbWFrZSBwaW4gY2FsY3VsYXRlIGl0Li4uXG5cdFx0XHRpZiAoX3Bpbk9wdGlvbnMucmVsU2l6ZS53aWR0aCkge1xuXHRcdFx0XHRfdXRpbC5jc3Moc3BhY2VyLCB7XG5cdFx0XHRcdFx0d2lkdGg6IHNpemVDU1Mud2lkdGhcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX3Bpbk9wdGlvbnMucmVsU2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0X3V0aWwuY3NzKHNwYWNlciwge1xuXHRcdFx0XHRcdGhlaWdodDogc2l6ZUNTUy5oZWlnaHRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG5vdyBwbGFjZSB0aGUgcGluIGVsZW1lbnQgaW5zaWRlIHRoZSBzcGFjZXJcdFxuXHRcdFx0c3BhY2VyLmFwcGVuZENoaWxkKF9waW4pO1xuXHRcdFx0Ly8gYW5kIHNldCBuZXcgY3NzXG5cdFx0XHRfdXRpbC5jc3MoX3Bpbiwge1xuXHRcdFx0XHRwb3NpdGlvbjogaW5GbG93ID8gXCJyZWxhdGl2ZVwiIDogXCJhYnNvbHV0ZVwiLFxuXHRcdFx0XHRtYXJnaW46IFwiYXV0b1wiLFxuXHRcdFx0XHR0b3A6IFwiYXV0b1wiLFxuXHRcdFx0XHRsZWZ0OiBcImF1dG9cIixcblx0XHRcdFx0Ym90dG9tOiBcImF1dG9cIixcblx0XHRcdFx0cmlnaHQ6IFwiYXV0b1wiXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKF9waW5PcHRpb25zLnJlbFNpemUud2lkdGggfHwgX3Bpbk9wdGlvbnMucmVsU2l6ZS5hdXRvRnVsbFdpZHRoKSB7XG5cdFx0XHRcdF91dGlsLmNzcyhfcGluLCB7XG5cdFx0XHRcdFx0Ym94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRtb3pCb3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHdlYmtpdEJveFNpemluZzogXCJib3JkZXItYm94XCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCBsaXN0ZW5lciB0byBkb2N1bWVudCB0byB1cGRhdGUgcGluIHBvc2l0aW9uIGluIGNhc2UgY29udHJvbGxlciBpcyBub3QgdGhlIGRvY3VtZW50LlxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZVBpbkluQ29udGFpbmVyKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVQaW5JbkNvbnRhaW5lcik7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlUmVsYXRpdmVQaW5TcGFjZXIpO1xuXHRcdFx0Ly8gYWRkIG1vdXNld2hlZWwgbGlzdGVuZXIgdG8gY2F0Y2ggc2Nyb2xscyBvdmVyIGZpeGVkIGVsZW1lbnRzXG5cdFx0XHRfcGluLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXdoZWVsXCIsIG9uTW91c2V3aGVlbE92ZXJQaW4pO1xuXHRcdFx0X3Bpbi5hZGRFdmVudExpc3RlbmVyKFwiRE9NTW91c2VTY3JvbGxcIiwgb25Nb3VzZXdoZWVsT3ZlclBpbik7XG5cblx0XHRcdGxvZygzLCBcImFkZGVkIHBpblwiKTtcblxuXHRcdFx0Ly8gZmluYWxseSB1cGRhdGUgdGhlIHBpbiB0byBpbml0XG5cdFx0XHR1cGRhdGVQaW5TdGF0ZSgpO1xuXG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSB0aGUgcGluIGZyb20gdGhlIHNjZW5lLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjcmVtb3ZlUGluXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyByZW1vdmUgdGhlIHBpbiBmcm9tIHRoZSBzY2VuZSB3aXRob3V0IHJlc2V0dGluZyBpdCAodGhlIHNwYWNlciBpcyBub3QgcmVtb3ZlZClcblx0XHQgKiBzY2VuZS5yZW1vdmVQaW4oKTtcblx0XHQgKlxuXHRcdCAqIC8vIHJlbW92ZSB0aGUgcGluIGZyb20gdGhlIHNjZW5lIGFuZCByZXNldCB0aGUgcGluIGVsZW1lbnQgdG8gaXRzIGluaXRpYWwgcG9zaXRpb24gKHNwYWNlciBpcyByZW1vdmVkKVxuXHRcdCAqIHNjZW5lLnJlbW92ZVBpbih0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0PWZhbHNlXSAtIElmIGBmYWxzZWAgdGhlIHNwYWNlciB3aWxsIG5vdCBiZSByZW1vdmVkIGFuZCB0aGUgZWxlbWVudCdzIHBvc2l0aW9uIHdpbGwgbm90IGJlIHJlc2V0LlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5yZW1vdmVQaW4gPSBmdW5jdGlvbiAocmVzZXQpIHtcblx0XHRcdGlmIChfcGluKSB7XG5cdFx0XHRcdGlmIChfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0RVUklORykge1xuXHRcdFx0XHRcdHVwZGF0ZVBpblN0YXRlKHRydWUpOyAvLyBmb3JjZSB1bnBpbiBhdCBwb3NpdGlvblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNldCB8fCAhX2NvbnRyb2xsZXIpIHsgLy8gaWYgdGhlcmUncyBubyBjb250cm9sbGVyIG5vIHByb2dyZXNzIHdhcyBtYWRlIGFueXdheS4uLlxuXHRcdFx0XHRcdHZhciBwaW5UYXJnZXQgPSBfcGluT3B0aW9ucy5zcGFjZXIuZmlyc3RDaGlsZDsgLy8gdXN1YWxseSB0aGUgcGluIGVsZW1lbnQsIGJ1dCBtYXkgYmUgYW5vdGhlciBzcGFjZXIgKGNhc2NhZGVkIHBpbnMpLi4uXG5cdFx0XHRcdFx0aWYgKHBpblRhcmdldC5oYXNBdHRyaWJ1dGUoUElOX1NQQUNFUl9BVFRSSUJVVEUpKSB7IC8vIGNvcHkgbWFyZ2lucyB0byBjaGlsZCBzcGFjZXJcblx0XHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0c3R5bGUgPSBfcGluT3B0aW9ucy5zcGFjZXIuc3R5bGUsXG5cdFx0XHRcdFx0XHRcdHZhbHVlcyA9IFtcIm1hcmdpblwiLCBcIm1hcmdpbkxlZnRcIiwgXCJtYXJnaW5SaWdodFwiLCBcIm1hcmdpblRvcFwiLCBcIm1hcmdpbkJvdHRvbVwiXTtcblx0XHRcdFx0XHRcdG1hcmdpbnMgPSB7fTtcblx0XHRcdFx0XHRcdHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0XHRcdFx0bWFyZ2luc1t2YWxdID0gc3R5bGVbdmFsXSB8fCBcIlwiO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRfdXRpbC5jc3MocGluVGFyZ2V0LCBtYXJnaW5zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X3Bpbk9wdGlvbnMuc3BhY2VyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBpblRhcmdldCwgX3Bpbk9wdGlvbnMuc3BhY2VyKTtcblx0XHRcdFx0XHRfcGluT3B0aW9ucy5zcGFjZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfcGluT3B0aW9ucy5zcGFjZXIpO1xuXHRcdFx0XHRcdGlmICghX3Bpbi5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShQSU5fU1BBQ0VSX0FUVFJJQlVURSkpIHsgLy8gaWYgaXQncyB0aGUgbGFzdCBwaW4gZm9yIHRoaXMgZWxlbWVudCAtPiByZXN0b3JlIGlubGluZSBzdHlsZXNcblx0XHRcdFx0XHRcdC8vIFRPRE86IG9ubHkgY29ycmVjdGx5IHNldCBmb3IgZmlyc3QgcGluICh3aGVuIGNhc2NhZGluZykgLSBob3cgdG8gZml4P1xuXHRcdFx0XHRcdFx0X3V0aWwuY3NzKF9waW4sIF9waW4uX19fb3JpZ1N0eWxlKTtcblx0XHRcdFx0XHRcdGRlbGV0ZSBfcGluLl9fX29yaWdTdHlsZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZVBpbkluQ29udGFpbmVyKTtcblx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZVBpbkluQ29udGFpbmVyKTtcblx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZVJlbGF0aXZlUGluU3BhY2VyKTtcblx0XHRcdFx0X3Bpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLCBvbk1vdXNld2hlZWxPdmVyUGluKTtcblx0XHRcdFx0X3Bpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTW91c2VTY3JvbGxcIiwgb25Nb3VzZXdoZWVsT3ZlclBpbik7XG5cdFx0XHRcdF9waW4gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGxvZygzLCBcInJlbW92ZWQgcGluIChyZXNldDogXCIgKyAocmVzZXQgPyBcInRydWVcIiA6IFwiZmFsc2VcIikgKyBcIilcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXG5cdFx0dmFyXG5cdFx0X2Nzc0NsYXNzZXMsIF9jc3NDbGFzc0VsZW1zID0gW107XG5cblx0XHRTY2VuZS5vbihcImRlc3Ryb3kuaW50ZXJuYWxcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFNjZW5lLnJlbW92ZUNsYXNzVG9nZ2xlKGUucmVzZXQpO1xuXHRcdH0pO1xuXHRcdC8qKlxuXHRcdCAqIERlZmluZSBhIGNzcyBjbGFzcyBtb2RpZmljYXRpb24gd2hpbGUgdGhlIHNjZW5lIGlzIGFjdGl2ZS4gIFxuXHRcdCAqIFdoZW4gdGhlIHNjZW5lIHRyaWdnZXJzIHRoZSBjbGFzc2VzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHN1cHBsaWVkIGVsZW1lbnQgYW5kIHJlbW92ZWQsIHdoZW4gdGhlIHNjZW5lIGlzIG92ZXIuXG5cdFx0ICogSWYgdGhlIHNjZW5lIGR1cmF0aW9uIGlzIDAgdGhlIGNsYXNzZXMgd2lsbCBvbmx5IGJlIHJlbW92ZWQgaWYgdGhlIHVzZXIgc2Nyb2xscyBiYWNrIHBhc3QgdGhlIHN0YXJ0IHBvc2l0aW9uLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjc2V0Q2xhc3NUb2dnbGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGFkZCB0aGUgY2xhc3MgJ215Y2xhc3MnIHRvIHRoZSBlbGVtZW50IHdpdGggdGhlIGlkICdteS1lbGVtJyBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBzY2VuZVxuXHRcdCAqIHNjZW5lLnNldENsYXNzVG9nZ2xlKFwiI215LWVsZW1cIiwgXCJteWNsYXNzXCIpO1xuXHRcdCAqXG5cdFx0ICogLy8gYWRkIG11bHRpcGxlIGNsYXNzZXMgdG8gbXVsdGlwbGUgZWxlbWVudHMgZGVmaW5lZCBieSB0aGUgc2VsZWN0b3IgJy5jbGFzc0NoYW5nZSdcblx0XHQgKiBzY2VuZS5zZXRDbGFzc1RvZ2dsZShcIi5jbGFzc0NoYW5nZVwiLCBcImNsYXNzMSBjbGFzczIgY2xhc3MzXCIpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IGVsZW1lbnQgLSBBIFNlbGVjdG9yIHRhcmdldGluZyBvbmUgb3IgbW9yZSBlbGVtZW50cyBvciBhIERPTSBvYmplY3QgdGhhdCBpcyBzdXBwb3NlZCB0byBiZSBtb2RpZmllZC5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyAtIE9uZSBvciBtb3JlIENsYXNzbmFtZXMgKHNlcGFyYXRlZCBieSBzcGFjZSkgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGVsZW1lbnQgZHVyaW5nIHRoZSBzY2VuZS5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5zZXRDbGFzc1RvZ2dsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc2VzKSB7XG5cdFx0XHR2YXIgZWxlbXMgPSBfdXRpbC5nZXQuZWxlbWVudHMoZWxlbWVudCk7XG5cdFx0XHRpZiAoZWxlbXMubGVuZ3RoID09PSAwIHx8ICFfdXRpbC50eXBlLlN0cmluZyhjbGFzc2VzKSkge1xuXHRcdFx0XHRsb2coMSwgXCJFUlJPUiBjYWxsaW5nIG1ldGhvZCAnc2V0Q2xhc3NUb2dnbGUoKSc6IEludmFsaWQgXCIgKyAoZWxlbXMubGVuZ3RoID09PSAwID8gXCJlbGVtZW50XCIgOiBcImNsYXNzZXNcIikgKyBcIiBzdXBwbGllZC5cIik7XG5cdFx0XHRcdHJldHVybiBTY2VuZTtcblx0XHRcdH1cblx0XHRcdGlmIChfY3NzQ2xhc3NFbGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8vIHJlbW92ZSBvbGQgb25lc1xuXHRcdFx0XHRTY2VuZS5yZW1vdmVDbGFzc1RvZ2dsZSgpO1xuXHRcdFx0fVxuXHRcdFx0X2Nzc0NsYXNzZXMgPSBjbGFzc2VzO1xuXHRcdFx0X2Nzc0NsYXNzRWxlbXMgPSBlbGVtcztcblx0XHRcdFNjZW5lLm9uKFwiZW50ZXIuaW50ZXJuYWxfY2xhc3MgbGVhdmUuaW50ZXJuYWxfY2xhc3NcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dmFyIHRvZ2dsZSA9IGUudHlwZSA9PT0gXCJlbnRlclwiID8gX3V0aWwuYWRkQ2xhc3MgOiBfdXRpbC5yZW1vdmVDbGFzcztcblx0XHRcdFx0X2Nzc0NsYXNzRWxlbXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbSwga2V5KSB7XG5cdFx0XHRcdFx0dG9nZ2xlKGVsZW0sIF9jc3NDbGFzc2VzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIHRoZSBjbGFzcyBiaW5kaW5nIGZyb20gdGhlIHNjZW5lLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjcmVtb3ZlQ2xhc3NUb2dnbGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHJlbW92ZSBjbGFzcyBiaW5kaW5nIGZyb20gdGhlIHNjZW5lIHdpdGhvdXQgcmVzZXRcblx0XHQgKiBzY2VuZS5yZW1vdmVDbGFzc1RvZ2dsZSgpO1xuXHRcdCAqXG5cdFx0ICogLy8gcmVtb3ZlIGNsYXNzIGJpbmRpbmcgYW5kIHJlbW92ZSB0aGUgY2hhbmdlcyBpdCBjYXVzZWRcblx0XHQgKiBzY2VuZS5yZW1vdmVDbGFzc1RvZ2dsZSh0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0PWZhbHNlXSAtIElmIGBmYWxzZWAgYW5kIHRoZSBjbGFzc2VzIGFyZSBjdXJyZW50bHkgYWN0aXZlLCB0aGV5IHdpbGwgcmVtYWluIG9uIHRoZSBlbGVtZW50LiBJZiBgdHJ1ZWAgdGhleSB3aWxsIGJlIHJlbW92ZWQuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnJlbW92ZUNsYXNzVG9nZ2xlID0gZnVuY3Rpb24gKHJlc2V0KSB7XG5cdFx0XHRpZiAocmVzZXQpIHtcblx0XHRcdFx0X2Nzc0NsYXNzRWxlbXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbSwga2V5KSB7XG5cdFx0XHRcdFx0X3V0aWwucmVtb3ZlQ2xhc3MoZWxlbSwgX2Nzc0NsYXNzZXMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdFNjZW5lLm9mZihcInN0YXJ0LmludGVybmFsX2NsYXNzIGVuZC5pbnRlcm5hbF9jbGFzc1wiKTtcblx0XHRcdF9jc3NDbGFzc2VzID0gdW5kZWZpbmVkO1xuXHRcdFx0X2Nzc0NsYXNzRWxlbXMgPSBbXTtcblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0Ly8gSU5JVFxuXHRcdGNvbnN0cnVjdCgpO1xuXHRcdHJldHVybiBTY2VuZTtcblx0fTtcblxuXHQvLyBzdG9yZSBwYWdld2lkZSBzY2VuZSBvcHRpb25zXG5cdHZhciBTQ0VORV9PUFRJT05TID0ge1xuXHRcdGRlZmF1bHRzOiB7XG5cdFx0XHRkdXJhdGlvbjogMCxcblx0XHRcdG9mZnNldDogMCxcblx0XHRcdHRyaWdnZXJFbGVtZW50OiB1bmRlZmluZWQsXG5cdFx0XHR0cmlnZ2VySG9vazogMC41LFxuXHRcdFx0cmV2ZXJzZTogdHJ1ZSxcblx0XHRcdGxvZ2xldmVsOiAyXG5cdFx0fSxcblx0XHR2YWxpZGF0ZToge1xuXHRcdFx0b2Zmc2V0OiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdHZhbCA9IHBhcnNlRmxvYXQodmFsKTtcblx0XHRcdFx0aWYgKCFfdXRpbC50eXBlLk51bWJlcih2YWwpKSB7XG5cdFx0XHRcdFx0dGhyb3cgW1wiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJvZmZzZXRcXFwiOlwiLCB2YWxdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlckVsZW1lbnQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0dmFsID0gdmFsIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKHZhbCkge1xuXHRcdFx0XHRcdHZhciBlbGVtID0gX3V0aWwuZ2V0LmVsZW1lbnRzKHZhbClbMF07XG5cdFx0XHRcdFx0aWYgKGVsZW0pIHtcblx0XHRcdFx0XHRcdHZhbCA9IGVsZW07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IFtcIkVsZW1lbnQgZGVmaW5lZCBpbiBvcHRpb24gXFxcInRyaWdnZXJFbGVtZW50XFxcIiB3YXMgbm90IGZvdW5kOlwiLCB2YWxdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXJIb29rOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdHZhciB0cmFuc2xhdGUgPSB7XG5cdFx0XHRcdFx0XCJvbkNlbnRlclwiOiAwLjUsXG5cdFx0XHRcdFx0XCJvbkVudGVyXCI6IDEsXG5cdFx0XHRcdFx0XCJvbkxlYXZlXCI6IDBcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKF91dGlsLnR5cGUuTnVtYmVyKHZhbCkpIHtcblx0XHRcdFx0XHR2YWwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYXJzZUZsb2F0KHZhbCksIDEpKTsgLy8gIG1ha2Ugc3VyZSBpdHMgYmV0d2VlZW4gMCBhbmQgMVxuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbCBpbiB0cmFuc2xhdGUpIHtcblx0XHRcdFx0XHR2YWwgPSB0cmFuc2xhdGVbdmFsXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBbXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInRyaWdnZXJIb29rXFxcIjogXCIsIHZhbF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH0sXG5cdFx0XHRyZXZlcnNlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdHJldHVybiAhIXZhbDsgLy8gZm9yY2UgYm9vbGVhblxuXHRcdFx0fSxcblx0XHRcdGxvZ2xldmVsOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdHZhbCA9IHBhcnNlSW50KHZhbCk7XG5cdFx0XHRcdGlmICghX3V0aWwudHlwZS5OdW1iZXIodmFsKSB8fCB2YWwgPCAwIHx8IHZhbCA+IDMpIHtcblx0XHRcdFx0XHR0aHJvdyBbXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImxvZ2xldmVsXFxcIjpcIiwgdmFsXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ly8gaG9sZGVyIGZvciAgdmFsaWRhdGlvbiBtZXRob2RzLiBkdXJhdGlvbiB2YWxpZGF0aW9uIGlzIGhhbmRsZWQgaW4gJ2dldHRlcnMtc2V0dGVycy5qcydcblx0XHRzaGlmdHM6IFtcImR1cmF0aW9uXCIsIFwib2Zmc2V0XCIsIFwidHJpZ2dlckhvb2tcIl0sXG5cdFx0Ly8gbGlzdCBvZiBvcHRpb25zIHRoYXQgdHJpZ2dlciBhIGBzaGlmdGAgZXZlbnRcblx0fTtcbi8qXG4gKiBtZXRob2QgdXNlZCB0byBhZGQgYW4gb3B0aW9uIHRvIFNjcm9sbE1hZ2ljIFNjZW5lcy5cbiAqIFRPRE86IERPQyAocHJpdmF0ZSBmb3IgZGV2KVxuICovXG5cdFNjcm9sbE1hZ2ljLlNjZW5lLmFkZE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBkZWZhdWx0VmFsdWUsIHZhbGlkYXRpb25DYWxsYmFjaywgc2hpZnRzKSB7XG5cdFx0aWYgKCEobmFtZSBpbiBTQ0VORV9PUFRJT05TLmRlZmF1bHRzKSkge1xuXHRcdFx0U0NFTkVfT1BUSU9OUy5kZWZhdWx0c1tuYW1lXSA9IGRlZmF1bHRWYWx1ZTtcblx0XHRcdFNDRU5FX09QVElPTlMudmFsaWRhdGVbbmFtZV0gPSB2YWxpZGF0aW9uQ2FsbGJhY2s7XG5cdFx0XHRpZiAoc2hpZnRzKSB7XG5cdFx0XHRcdFNDRU5FX09QVElPTlMuc2hpZnRzLnB1c2gobmFtZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdFNjcm9sbE1hZ2ljLl91dGlsLmxvZygxLCBcIltzdGF0aWNdIFNjcm9sbE1hZ2ljLlNjZW5lIC0+IENhbm5vdCBhZGQgU2NlbmUgb3B0aW9uICdcIiArIG5hbWUgKyBcIicsIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXCIpO1xuXHRcdH1cblx0fTtcblx0Ly8gaW5zdGFuY2UgZXh0ZW5zaW9uIGZ1bmN0aW9uIGZvciBwbHVnaW5zXG5cdC8vIFRPRE86IERPQyAocHJpdmF0ZSBmb3IgZGV2KVxuXHRTY3JvbGxNYWdpYy5TY2VuZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG5cdFx0dmFyIG9sZENsYXNzID0gdGhpcztcblx0XHRTY3JvbGxNYWdpYy5TY2VuZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdG9sZENsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLiRzdXBlciA9IF91dGlsLmV4dGVuZCh7fSwgdGhpcyk7IC8vIGNvcHkgcGFyZW50IHN0YXRlXG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0XHR9O1xuXHRcdF91dGlsLmV4dGVuZChTY3JvbGxNYWdpYy5TY2VuZSwgb2xkQ2xhc3MpOyAvLyBjb3B5IHByb3BlcnRpZXNcblx0XHRTY3JvbGxNYWdpYy5TY2VuZS5wcm90b3R5cGUgPSBvbGRDbGFzcy5wcm90b3R5cGU7IC8vIGNvcHkgcHJvdG90eXBlXG5cdFx0U2Nyb2xsTWFnaWMuU2NlbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2Nyb2xsTWFnaWMuU2NlbmU7IC8vIHJlc3RvcmUgY29uc3RydWN0b3Jcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBUT0RPOiBET0NTIChwcml2YXRlIGZvciBkZXYpXG5cdCAqIEBjbGFzc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblxuXHRTY3JvbGxNYWdpYy5FdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lc3BhY2UsIHRhcmdldCwgdmFycykge1xuXHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdGZvciAodmFyIGtleSBpbiB2YXJzKSB7XG5cdFx0XHR0aGlzW2tleV0gPSB2YXJzW2tleV07XG5cdFx0fVxuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy50YXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG5cdFx0dGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2UgfHwgJyc7XG5cdFx0dGhpcy50aW1lU3RhbXAgPSB0aGlzLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cbi8qXG4gKiBUT0RPOiBET0NTIChwcml2YXRlIGZvciBkZXYpXG4gKi9cblxuXHR2YXIgX3V0aWwgPSBTY3JvbGxNYWdpYy5fdXRpbCA9IChmdW5jdGlvbiAod2luZG93KSB7XG5cdFx0dmFyIFUgPSB7fSxcblx0XHRcdGk7XG5cblx0XHQvKipcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKiBpbnRlcm5hbCBoZWxwZXJzXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICovXG5cblx0XHQvLyBwYXJzZSBmbG9hdCBhbmQgZmFsbCBiYWNrIHRvIDAuXG5cdFx0dmFyIGZsb2F0dmFsID0gZnVuY3Rpb24gKG51bWJlcikge1xuXHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQobnVtYmVyKSB8fCAwO1xuXHRcdH07XG5cdFx0Ly8gZ2V0IGN1cnJlbnQgc3R5bGUgSUUgc2FmZSAob3RoZXJ3aXNlIElFIHdvdWxkIHJldHVybiBjYWxjdWxhdGVkIHZhbHVlcyBmb3IgJ2F1dG8nKVxuXHRcdHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uIChlbGVtKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5jdXJyZW50U3R5bGUgPyBlbGVtLmN1cnJlbnRTdHlsZSA6IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuXHRcdH07XG5cblx0XHQvLyBnZXQgZWxlbWVudCBkaW1lbnNpb24gKHdpZHRoIG9yIGhlaWdodClcblx0XHR2YXIgX2RpbWVuc2lvbiA9IGZ1bmN0aW9uICh3aGljaCwgZWxlbSwgb3V0ZXIsIGluY2x1ZGVNYXJnaW4pIHtcblx0XHRcdGVsZW0gPSAoZWxlbSA9PT0gZG9jdW1lbnQpID8gd2luZG93IDogZWxlbTtcblx0XHRcdGlmIChlbGVtID09PSB3aW5kb3cpIHtcblx0XHRcdFx0aW5jbHVkZU1hcmdpbiA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICghX3R5cGUuRG9tRWxlbWVudChlbGVtKSkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdHdoaWNoID0gd2hpY2guY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3aGljaC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciBkaW1lbnNpb24gPSAob3V0ZXIgPyBlbGVtWydvZmZzZXQnICsgd2hpY2hdIHx8IGVsZW1bJ291dGVyJyArIHdoaWNoXSA6IGVsZW1bJ2NsaWVudCcgKyB3aGljaF0gfHwgZWxlbVsnaW5uZXInICsgd2hpY2hdKSB8fCAwO1xuXHRcdFx0aWYgKG91dGVyICYmIGluY2x1ZGVNYXJnaW4pIHtcblx0XHRcdFx0dmFyIHN0eWxlID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbSk7XG5cdFx0XHRcdGRpbWVuc2lvbiArPSB3aGljaCA9PT0gJ0hlaWdodCcgPyBmbG9hdHZhbChzdHlsZS5tYXJnaW5Ub3ApICsgZmxvYXR2YWwoc3R5bGUubWFyZ2luQm90dG9tKSA6IGZsb2F0dmFsKHN0eWxlLm1hcmdpbkxlZnQpICsgZmxvYXR2YWwoc3R5bGUubWFyZ2luUmlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRpbWVuc2lvbjtcblx0XHR9O1xuXHRcdC8vIGNvbnZlcnRzICdtYXJnaW4tdG9wJyBpbnRvICdtYXJnaW5Ub3AnXG5cdFx0dmFyIF9jYW1lbENhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL15bXmEtel0rKFthLXpdKS9nLCAnJDEnKS5yZXBsYWNlKC8tKFthLXpdKS9nLCBmdW5jdGlvbiAoZykge1xuXHRcdFx0XHRyZXR1cm4gZ1sxXS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqIGV4dGVybmFsIGhlbHBlcnNcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKi9cblxuXHRcdC8vIGV4dGVuZCBvYmog4oCTIHNhbWUgYXMgalF1ZXJ5LmV4dGVuZCh7fSwgb2JqQSwgb2JqQilcblx0XHRVLmV4dGVuZCA9IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IG9iaiB8fCB7fTtcblx0XHRcdGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKCFhcmd1bWVudHNbaV0pIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzW2ldKSB7XG5cdFx0XHRcdFx0aWYgKGFyZ3VtZW50c1tpXS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRvYmpba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9O1xuXG5cdFx0Ly8gY2hlY2sgaWYgYSBjc3MgZGlzcGxheSB0eXBlIHJlc3VsdHMgaW4gbWFyZ2luLWNvbGxhcHNlIG9yIG5vdFxuXHRcdFUuaXNNYXJnaW5Db2xsYXBzZVR5cGUgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0XHRyZXR1cm4gW1wiYmxvY2tcIiwgXCJmbGV4XCIsIFwibGlzdC1pdGVtXCIsIFwidGFibGVcIiwgXCItd2Via2l0LWJveFwiXS5pbmRleE9mKHN0cikgPiAtMTtcblx0XHR9O1xuXG5cdFx0Ly8gaW1wbGVtZW50YXRpb24gb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0Ly8gYmFzZWQgb24gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzFcblx0XHR2YXJcblx0XHRsYXN0VGltZSA9IDAsXG5cdFx0XHR2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcblx0XHR2YXIgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0dmFyIF9jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZTtcblx0XHQvLyB0cnkgdmVuZG9yIHByZWZpeGVzIGlmIHRoZSBhYm92ZSBkb2Vzbid0IHdvcmtcblx0XHRmb3IgKGkgPSAwOyAhX3JlcXVlc3RBbmltYXRpb25GcmFtZSAmJiBpIDwgdmVuZG9ycy5sZW5ndGg7ICsraSkge1xuXHRcdFx0X3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW2ldICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuXHRcdFx0X2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3aW5kb3dbdmVuZG9yc1tpXSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcblx0XHR9XG5cblx0XHQvLyBmYWxsYmFja3Ncblx0XHRpZiAoIV9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRcdF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCksXG5cdFx0XHRcdFx0dGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKSxcblx0XHRcdFx0XHRpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XG5cdFx0XHRcdFx0fSwgdGltZVRvQ2FsbCk7XG5cdFx0XHRcdGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuXHRcdFx0XHRyZXR1cm4gaWQ7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAoIV9jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuXHRcdFx0X2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0VS5yQUYgPSBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KTtcblx0XHRVLmNBRiA9IF9jYW5jZWxBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyk7XG5cblx0XHR2YXJcblx0XHRsb2dsZXZlbHMgPSBbXCJlcnJvclwiLCBcIndhcm5cIiwgXCJsb2dcIl0sXG5cdFx0XHRjb25zb2xlID0gd2luZG93LmNvbnNvbGUgfHwge307XG5cblx0XHRjb25zb2xlLmxvZyA9IGNvbnNvbGUubG9nIHx8XG5cdFx0ZnVuY3Rpb24gKCkge307IC8vIG5vIGNvbnNvbGUgbG9nLCB3ZWxsIC0gZG8gbm90aGluZyB0aGVuLi4uXG5cdFx0Ly8gbWFrZSBzdXJlIG1ldGhvZHMgZm9yIGFsbCBsZXZlbHMgZXhpc3QuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxvZ2xldmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG1ldGhvZCA9IGxvZ2xldmVsc1tpXTtcblx0XHRcdGlmICghY29uc29sZVttZXRob2RdKSB7XG5cdFx0XHRcdGNvbnNvbGVbbWV0aG9kXSA9IGNvbnNvbGUubG9nOyAvLyBwcmVmZXIgLmxvZyBvdmVyIG5vdGhpbmdcblx0XHRcdH1cblx0XHR9XG5cdFx0VS5sb2cgPSBmdW5jdGlvbiAobG9nbGV2ZWwpIHtcblx0XHRcdGlmIChsb2dsZXZlbCA+IGxvZ2xldmVscy5sZW5ndGggfHwgbG9nbGV2ZWwgPD0gMCkgbG9nbGV2ZWwgPSBsb2dsZXZlbHMubGVuZ3RoO1xuXHRcdFx0dmFyIG5vdyA9IG5ldyBEYXRlKCksXG5cdFx0XHRcdHRpbWUgPSAoXCIwXCIgKyBub3cuZ2V0SG91cnMoKSkuc2xpY2UoLTIpICsgXCI6XCIgKyAoXCIwXCIgKyBub3cuZ2V0TWludXRlcygpKS5zbGljZSgtMikgKyBcIjpcIiArIChcIjBcIiArIG5vdy5nZXRTZWNvbmRzKCkpLnNsaWNlKC0yKSArIFwiOlwiICsgKFwiMDBcIiArIG5vdy5nZXRNaWxsaXNlY29uZHMoKSkuc2xpY2UoLTMpLFxuXHRcdFx0XHRtZXRob2QgPSBsb2dsZXZlbHNbbG9nbGV2ZWwgLSAxXSxcblx0XHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuXHRcdFx0XHRmdW5jID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChjb25zb2xlW21ldGhvZF0sIGNvbnNvbGUpO1xuXHRcdFx0YXJncy51bnNoaWZ0KHRpbWUpO1xuXHRcdFx0ZnVuYy5hcHBseShjb25zb2xlLCBhcmdzKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICogdHlwZSB0ZXN0aW5nXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICovXG5cblx0XHR2YXIgX3R5cGUgPSBVLnR5cGUgPSBmdW5jdGlvbiAodikge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KS5yZXBsYWNlKC9eXFxbb2JqZWN0ICguKylcXF0kLywgXCIkMVwiKS50b0xvd2VyQ2FzZSgpO1xuXHRcdH07XG5cdFx0X3R5cGUuU3RyaW5nID0gZnVuY3Rpb24gKHYpIHtcblx0XHRcdHJldHVybiBfdHlwZSh2KSA9PT0gJ3N0cmluZyc7XG5cdFx0fTtcblx0XHRfdHlwZS5GdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRyZXR1cm4gX3R5cGUodikgPT09ICdmdW5jdGlvbic7XG5cdFx0fTtcblx0XHRfdHlwZS5BcnJheSA9IGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2KTtcblx0XHR9O1xuXHRcdF90eXBlLk51bWJlciA9IGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRyZXR1cm4gIV90eXBlLkFycmF5KHYpICYmICh2IC0gcGFyc2VGbG9hdCh2KSArIDEpID49IDA7XG5cdFx0fTtcblx0XHRfdHlwZS5Eb21FbGVtZW50ID0gZnVuY3Rpb24gKG8pIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHR0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwib2JqZWN0XCIgPyBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgOiAvL0RPTTJcblx0XHRcdG8gJiYgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSBcInN0cmluZ1wiKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICogRE9NIEVsZW1lbnQgaW5mb1xuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqL1xuXHRcdC8vIGFsd2F5cyByZXR1cm5zIGEgbGlzdCBvZiBtYXRjaGluZyBET00gZWxlbWVudHMsIGZyb20gYSBzZWxlY3RvciwgYSBET00gZWxlbWVudCBvciBhbiBsaXN0IG9mIGVsZW1lbnRzIG9yIGV2ZW4gYW4gYXJyYXkgb2Ygc2VsZWN0b3JzXG5cdFx0dmFyIF9nZXQgPSBVLmdldCA9IHt9O1xuXHRcdF9nZXQuZWxlbWVudHMgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0XHRcdHZhciBhcnIgPSBbXTtcblx0XHRcdGlmIChfdHlwZS5TdHJpbmcoc2VsZWN0b3IpKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkgeyAvLyBpbnZhbGlkIHNlbGVjdG9yXG5cdFx0XHRcdFx0cmV0dXJuIGFycjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKF90eXBlKHNlbGVjdG9yKSA9PT0gJ25vZGVsaXN0JyB8fCBfdHlwZS5BcnJheShzZWxlY3RvcikpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIHJlZiA9IGFyci5sZW5ndGggPSBzZWxlY3Rvci5sZW5ndGg7IGkgPCByZWY7IGkrKykgeyAvLyBsaXN0IG9mIGVsZW1lbnRzXG5cdFx0XHRcdFx0dmFyIGVsZW0gPSBzZWxlY3RvcltpXTtcblx0XHRcdFx0XHRhcnJbaV0gPSBfdHlwZS5Eb21FbGVtZW50KGVsZW0pID8gZWxlbSA6IF9nZXQuZWxlbWVudHMoZWxlbSk7IC8vIGlmIG5vdCBhbiBlbGVtZW50LCB0cnkgdG8gcmVzb2x2ZSByZWN1cnNpdmVseVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKF90eXBlLkRvbUVsZW1lbnQoc2VsZWN0b3IpIHx8IHNlbGVjdG9yID09PSBkb2N1bWVudCB8fCBzZWxlY3RvciA9PT0gd2luZG93KSB7XG5cdFx0XHRcdGFyciA9IFtzZWxlY3Rvcl07IC8vIG9ubHkgdGhlIGVsZW1lbnRcblx0XHRcdH1cblx0XHRcdHJldHVybiBhcnI7XG5cdFx0fTtcblx0XHQvLyBnZXQgc2Nyb2xsIHRvcCB2YWx1ZVxuXHRcdF9nZXQuc2Nyb2xsVG9wID0gZnVuY3Rpb24gKGVsZW0pIHtcblx0XHRcdHJldHVybiAoZWxlbSAmJiB0eXBlb2YgZWxlbS5zY3JvbGxUb3AgPT09ICdudW1iZXInKSA/IGVsZW0uc2Nyb2xsVG9wIDogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IDA7XG5cdFx0fTtcblx0XHQvLyBnZXQgc2Nyb2xsIGxlZnQgdmFsdWVcblx0XHRfZ2V0LnNjcm9sbExlZnQgPSBmdW5jdGlvbiAoZWxlbSkge1xuXHRcdFx0cmV0dXJuIChlbGVtICYmIHR5cGVvZiBlbGVtLnNjcm9sbExlZnQgPT09ICdudW1iZXInKSA/IGVsZW0uc2Nyb2xsTGVmdCA6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCAwO1xuXHRcdH07XG5cdFx0Ly8gZ2V0IGVsZW1lbnQgaGVpZ2h0XG5cdFx0X2dldC53aWR0aCA9IGZ1bmN0aW9uIChlbGVtLCBvdXRlciwgaW5jbHVkZU1hcmdpbikge1xuXHRcdFx0cmV0dXJuIF9kaW1lbnNpb24oJ3dpZHRoJywgZWxlbSwgb3V0ZXIsIGluY2x1ZGVNYXJnaW4pO1xuXHRcdH07XG5cdFx0Ly8gZ2V0IGVsZW1lbnQgd2lkdGhcblx0XHRfZ2V0LmhlaWdodCA9IGZ1bmN0aW9uIChlbGVtLCBvdXRlciwgaW5jbHVkZU1hcmdpbikge1xuXHRcdFx0cmV0dXJuIF9kaW1lbnNpb24oJ2hlaWdodCcsIGVsZW0sIG91dGVyLCBpbmNsdWRlTWFyZ2luKTtcblx0XHR9O1xuXG5cdFx0Ly8gZ2V0IGVsZW1lbnQgcG9zaXRpb24gKG9wdGlvbmFsbHkgcmVsYXRpdmUgdG8gdmlld3BvcnQpXG5cdFx0X2dldC5vZmZzZXQgPSBmdW5jdGlvbiAoZWxlbSwgcmVsYXRpdmVUb1ZpZXdwb3J0KSB7XG5cdFx0XHR2YXIgb2Zmc2V0ID0ge1xuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdGxlZnQ6IDBcblx0XHRcdH07XG5cdFx0XHRpZiAoZWxlbSAmJiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkgeyAvLyBjaGVjayBpZiBhdmFpbGFibGVcblx0XHRcdFx0dmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRvZmZzZXQudG9wID0gcmVjdC50b3A7XG5cdFx0XHRcdG9mZnNldC5sZWZ0ID0gcmVjdC5sZWZ0O1xuXHRcdFx0XHRpZiAoIXJlbGF0aXZlVG9WaWV3cG9ydCkgeyAvLyBjbGllbnRSZWN0IGlzIGJ5IGRlZmF1bHQgcmVsYXRpdmUgdG8gdmlld3BvcnQuLi5cblx0XHRcdFx0XHRvZmZzZXQudG9wICs9IF9nZXQuc2Nyb2xsVG9wKCk7XG5cdFx0XHRcdFx0b2Zmc2V0LmxlZnQgKz0gX2dldC5zY3JvbGxMZWZ0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvZmZzZXQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqIERPTSBFbGVtZW50IG1hbmlwdWxhdGlvblxuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqL1xuXG5cdFx0VS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlbGVtLCBjbGFzc25hbWUpIHtcblx0XHRcdGlmIChjbGFzc25hbWUpIHtcblx0XHRcdFx0aWYgKGVsZW0uY2xhc3NMaXN0KSBlbGVtLmNsYXNzTGlzdC5hZGQoY2xhc3NuYW1lKTtcblx0XHRcdFx0ZWxzZSBlbGVtLmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc25hbWU7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRVLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsZW0sIGNsYXNzbmFtZSkge1xuXHRcdFx0aWYgKGNsYXNzbmFtZSkge1xuXHRcdFx0XHRpZiAoZWxlbS5jbGFzc0xpc3QpIGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc25hbWUpO1xuXHRcdFx0XHRlbHNlIGVsZW0uY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKCcoXnxcXFxcYiknICsgY2xhc3NuYW1lLnNwbGl0KCcgJykuam9pbignfCcpICsgJyhcXFxcYnwkKScsICdnaScpLCAnICcpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Ly8gaWYgb3B0aW9ucyBpcyBzdHJpbmcgLT4gcmV0dXJucyBjc3MgdmFsdWVcblx0XHQvLyBpZiBvcHRpb25zIGlzIGFycmF5IC0+IHJldHVybnMgb2JqZWN0IHdpdGggY3NzIHZhbHVlIHBhaXJzXG5cdFx0Ly8gaWYgb3B0aW9ucyBpcyBvYmplY3QgLT4gc2V0IG5ldyBjc3MgdmFsdWVzXG5cdFx0VS5jc3MgPSBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucykge1xuXHRcdFx0aWYgKF90eXBlLlN0cmluZyhvcHRpb25zKSkge1xuXHRcdFx0XHRyZXR1cm4gX2dldENvbXB1dGVkU3R5bGUoZWxlbSlbX2NhbWVsQ2FzZShvcHRpb25zKV07XG5cdFx0XHR9IGVsc2UgaWYgKF90eXBlLkFycmF5KG9wdGlvbnMpKSB7XG5cdFx0XHRcdHZhclxuXHRcdFx0XHRvYmogPSB7fSxcblx0XHRcdFx0XHRzdHlsZSA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuXHRcdFx0XHRvcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbiwga2V5KSB7XG5cdFx0XHRcdFx0b2JqW29wdGlvbl0gPSBzdHlsZVtfY2FtZWxDYXNlKG9wdGlvbildO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IG9wdGlvbnNbb3B0aW9uXTtcblx0XHRcdFx0XHRpZiAodmFsID09IHBhcnNlRmxvYXQodmFsKSkgeyAvLyBhc3N1bWUgcGl4ZWwgZm9yIHNlZW1pbmdseSBudW1lcmljYWwgdmFsdWVzXG5cdFx0XHRcdFx0XHR2YWwgKz0gJ3B4Jztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZVtfY2FtZWxDYXNlKG9wdGlvbildID0gdmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJldHVybiBVO1xuXHR9KHdpbmRvdyB8fCB7fSkpO1xuXG5cdFNjcm9sbE1hZ2ljLlNjZW5lLnByb3RvdHlwZS5hZGRJbmRpY2F0b3JzID0gZnVuY3Rpb24gKCkge1xuXHRcdFNjcm9sbE1hZ2ljLl91dGlsLmxvZygxLCAnKFNjcm9sbE1hZ2ljLlNjZW5lKSAtPiBFUlJPUiBjYWxsaW5nIGFkZEluZGljYXRvcnMoKSBkdWUgdG8gbWlzc2luZyBQbHVnaW4gXFwnZGVidWcuYWRkSW5kaWNhdG9yc1xcJy4gUGxlYXNlIG1ha2Ugc3VyZSB0byBpbmNsdWRlIHBsdWdpbnMvZGVidWcuYWRkSW5kaWNhdG9ycy5qcycpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdFNjcm9sbE1hZ2ljLlNjZW5lLnByb3RvdHlwZS5yZW1vdmVJbmRpY2F0b3JzID0gZnVuY3Rpb24gKCkge1xuXHRcdFNjcm9sbE1hZ2ljLl91dGlsLmxvZygxLCAnKFNjcm9sbE1hZ2ljLlNjZW5lKSAtPiBFUlJPUiBjYWxsaW5nIHJlbW92ZUluZGljYXRvcnMoKSBkdWUgdG8gbWlzc2luZyBQbHVnaW4gXFwnZGVidWcuYWRkSW5kaWNhdG9yc1xcJy4gUGxlYXNlIG1ha2Ugc3VyZSB0byBpbmNsdWRlIHBsdWdpbnMvZGVidWcuYWRkSW5kaWNhdG9ycy5qcycpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdFNjcm9sbE1hZ2ljLlNjZW5lLnByb3RvdHlwZS5zZXRUd2VlbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRTY3JvbGxNYWdpYy5fdXRpbC5sb2coMSwgJyhTY3JvbGxNYWdpYy5TY2VuZSkgLT4gRVJST1IgY2FsbGluZyBzZXRUd2VlbigpIGR1ZSB0byBtaXNzaW5nIFBsdWdpbiBcXCdhbmltYXRpb24uZ3NhcFxcJy4gUGxlYXNlIG1ha2Ugc3VyZSB0byBpbmNsdWRlIHBsdWdpbnMvYW5pbWF0aW9uLmdzYXAuanMnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRTY3JvbGxNYWdpYy5TY2VuZS5wcm90b3R5cGUucmVtb3ZlVHdlZW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0U2Nyb2xsTWFnaWMuX3V0aWwubG9nKDEsICcoU2Nyb2xsTWFnaWMuU2NlbmUpIC0+IEVSUk9SIGNhbGxpbmcgcmVtb3ZlVHdlZW4oKSBkdWUgdG8gbWlzc2luZyBQbHVnaW4gXFwnYW5pbWF0aW9uLmdzYXBcXCcuIFBsZWFzZSBtYWtlIHN1cmUgdG8gaW5jbHVkZSBwbHVnaW5zL2FuaW1hdGlvbi5nc2FwLmpzJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0U2Nyb2xsTWFnaWMuU2NlbmUucHJvdG90eXBlLnNldFZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuXHRcdFNjcm9sbE1hZ2ljLl91dGlsLmxvZygxLCAnKFNjcm9sbE1hZ2ljLlNjZW5lKSAtPiBFUlJPUiBjYWxsaW5nIHNldFZlbG9jaXR5KCkgZHVlIHRvIG1pc3NpbmcgUGx1Z2luIFxcJ2FuaW1hdGlvbi52ZWxvY2l0eVxcJy4gUGxlYXNlIG1ha2Ugc3VyZSB0byBpbmNsdWRlIHBsdWdpbnMvYW5pbWF0aW9uLnZlbG9jaXR5LmpzJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0U2Nyb2xsTWFnaWMuU2NlbmUucHJvdG90eXBlLnJlbW92ZVZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuXHRcdFNjcm9sbE1hZ2ljLl91dGlsLmxvZygxLCAnKFNjcm9sbE1hZ2ljLlNjZW5lKSAtPiBFUlJPUiBjYWxsaW5nIHJlbW92ZVZlbG9jaXR5KCkgZHVlIHRvIG1pc3NpbmcgUGx1Z2luIFxcJ2FuaW1hdGlvbi52ZWxvY2l0eVxcJy4gUGxlYXNlIG1ha2Ugc3VyZSB0byBpbmNsdWRlIHBsdWdpbnMvYW5pbWF0aW9uLnZlbG9jaXR5LmpzJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRyZXR1cm4gU2Nyb2xsTWFnaWM7XG59KSk7IiwiLyohXG4gKiBTY3JvbGxNYWdpYyB2Mi4wLjUgKDIwMTUtMDQtMjkpXG4gKiBUaGUgamF2YXNjcmlwdCBsaWJyYXJ5IGZvciBtYWdpY2FsIHNjcm9sbCBpbnRlcmFjdGlvbnMuXG4gKiAoYykgMjAxNSBKYW4gUGFlcGtlIChAamFucGFlcGtlKVxuICogUHJvamVjdCBXZWJzaXRlOiBodHRwOi8vc2Nyb2xsbWFnaWMuaW9cbiAqIFxuICogQHZlcnNpb24gMi4wLjVcbiAqIEBsaWNlbnNlIER1YWwgbGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2UgYW5kIEdQTC5cbiAqIEBhdXRob3IgSmFuIFBhZXBrZSAtIGUtbWFpbEBqYW5wYWVwa2UuZGVcbiAqXG4gKiBAZmlsZSBTY3JvbGxNYWdpYyBHU0FQIEFuaW1hdGlvbiBQbHVnaW4uXG4gKlxuICogcmVxdWlyZXM6IEdTQVAgfjEuMTRcbiAqIFBvd2VyZWQgYnkgdGhlIEdyZWVuc29jayBBbmltYXRpb24gUGxhdGZvcm0gKEdTQVApOiBodHRwOi8vd3d3LmdyZWVuc29jay5jb20vanNcbiAqIEdyZWVuc29jayBMaWNlbnNlIGluZm8gYXQgaHR0cDovL3d3dy5ncmVlbnNvY2suY29tL2xpY2Vuc2luZy9cbiAqL1xuLyoqXG4gKiBUaGlzIHBsdWdpbiBpcyBtZWFudCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIEdyZWVuc29jayBBbmltYXRpb24gUGxhdHRmb3JtLiAgXG4gKiBJdCBvZmZlcnMgYW4gZWFzeSBBUEkgdG8gdHJpZ2dlciBUd2VlbnMgb3Igc3luY2hyb25pemUgdGhlbSB0byB0aGUgc2Nyb2xsYmFyIG1vdmVtZW50LlxuICpcbiAqIEJvdGggdGhlIGBsaXRlYCBhbmQgdGhlIGBtYXhgIHZlcnNpb25zIG9mIHRoZSBHU0FQIGxpYnJhcnkgYXJlIHN1cHBvcnRlZC4gIFxuICogVGhlIG1vc3QgYmFzaWMgcmVxdWlyZW1lbnQgaXMgYFR3ZWVuTGl0ZWAuXG4gKiBcbiAqIFRvIGhhdmUgYWNjZXNzIHRvIHRoaXMgZXh0ZW5zaW9uLCBwbGVhc2UgaW5jbHVkZSBgcGx1Z2lucy9hbmltYXRpb24uZ3NhcC5qc2AuXG4gKiBAcmVxdWlyZXMge0BsaW5rIGh0dHA6Ly9ncmVlbnNvY2suY29tL2dzYXB8R1NBUCB+MS4xNC54fVxuICogQG1peGluIGFuaW1hdGlvbi5HU0FQXG4gKi9cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbJ1Njcm9sbE1hZ2ljJywgJ1R3ZWVuTWF4JywgJ1RpbWVsaW5lTWF4J10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0Ly8gTG9hZHMgd2hvbGUgZ3NhcCBwYWNrYWdlIG9udG8gZ2xvYmFsIHNjb3BlLlxuXHRcdHJlcXVpcmUoJ2dzYXAnKTtcblx0XHRmYWN0b3J5KHJlcXVpcmUoJ3Njcm9sbG1hZ2ljJyksIFR3ZWVuTWF4LCBUaW1lbGluZU1heCk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeShyb290LlNjcm9sbE1hZ2ljIHx8IChyb290LmpRdWVyeSAmJiByb290LmpRdWVyeS5TY3JvbGxNYWdpYyksIHJvb3QuVHdlZW5NYXggfHwgcm9vdC5Ud2VlbkxpdGUsIHJvb3QuVGltZWxpbmVNYXggfHwgcm9vdC5UaW1lbGluZUxpdGUpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChTY3JvbGxNYWdpYywgVHdlZW4sIFRpbWVsaW5lKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgTkFNRVNQQUNFID0gXCJhbmltYXRpb24uZ3NhcFwiO1xuXG5cdHZhclxuXHRjb25zb2xlID0gd2luZG93LmNvbnNvbGUgfHwge30sXG5cdFx0ZXJyID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nIHx8XG5cdFx0ZnVuY3Rpb24gKCkge30sIGNvbnNvbGUpO1xuXHRpZiAoIVNjcm9sbE1hZ2ljKSB7XG5cdFx0ZXJyKFwiKFwiICsgTkFNRVNQQUNFICsgXCIpIC0+IEVSUk9SOiBUaGUgU2Nyb2xsTWFnaWMgbWFpbiBtb2R1bGUgY291bGQgbm90IGJlIGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIGl0J3MgbG9hZGVkIGJlZm9yZSB0aGlzIHBsdWdpbiBvciB1c2UgYW4gYXN5bmNocm9ub3VzIGxvYWRlciBsaWtlIHJlcXVpcmVqcy5cIik7XG5cdH1cblx0aWYgKCFUd2Vlbikge1xuXHRcdGVycihcIihcIiArIE5BTUVTUEFDRSArIFwiKSAtPiBFUlJPUjogVHdlZW5MaXRlIG9yIFR3ZWVuTWF4IGNvdWxkIG5vdCBiZSBmb3VuZC4gUGxlYXNlIG1ha2Ugc3VyZSBHU0FQIGlzIGxvYWRlZCBiZWZvcmUgU2Nyb2xsTWFnaWMgb3IgdXNlIGFuIGFzeW5jaHJvbm91cyBsb2FkZXIgbGlrZSByZXF1aXJlanMuXCIpO1xuXHR9XG5cbi8qXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogRXh0ZW5zaW9ucyBmb3IgU2NlbmVcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKi9cblx0LyoqXG5cdCAqIEV2ZXJ5IGluc3RhbmNlIG9mIFNjcm9sbE1hZ2ljLlNjZW5lIG5vdyBhY2NlcHRzIGFuIGFkZGl0aW9uYWwgb3B0aW9uLiAgXG5cdCAqIFNlZSB7QGxpbmsgU2Nyb2xsTWFnaWMuU2NlbmV9IGZvciBhIGNvbXBsZXRlIGxpc3Qgb2YgdGhlIHN0YW5kYXJkIG9wdGlvbnMuXG5cdCAqIEBtZW1iZXJvZiEgYW5pbWF0aW9uLkdTQVAjXG5cdCAqIEBtZXRob2QgbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKG9wdGlvbnMpXG5cdCAqIEBleGFtcGxlXG5cdCAqIHZhciBzY2VuZSA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7dHdlZW5DaGFuZ2VzOiB0cnVlfSk7XG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciB0aGUgU2NlbmUuIFRoZSBvcHRpb25zIGNhbiBiZSB1cGRhdGVkIGF0IGFueSB0aW1lLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnR3ZWVuQ2hhbmdlcz1mYWxzZV0gLSBUd2VlbnMgQW5pbWF0aW9uIHRvIHRoZSBwcm9ncmVzcyB0YXJnZXQgaW5zdGVhZCBvZiBzZXR0aW5nIGl0LiAgXG5cdCBEb2VzIG5vdCBhZmZlY3QgYW5pbWF0aW9ucyB3aGVyZSBkdXJhdGlvbiBpcyBgMGAuXG5cdCAqL1xuXHQvKipcblx0ICogKipHZXQqKiBvciAqKlNldCoqIHRoZSB0d2VlbkNoYW5nZXMgb3B0aW9uIHZhbHVlLiAgXG5cdCAqIFRoaXMgb25seSBhZmZlY3RzIHNjZW5lcyB3aXRoIGEgZHVyYXRpb24uIElmIGB0d2VlbkNoYW5nZXNgIGlzIGB0cnVlYCwgdGhlIHByb2dyZXNzIHVwZGF0ZSB3aGVuIHNjcm9sbGluZyB3aWxsIG5vdCBiZSBpbW1lZGlhdGUsIGJ1dCBpbnN0ZWFkIHRoZSBhbmltYXRpb24gd2lsbCBzbW9vdGhseSBhbmltYXRlIHRvIHRoZSB0YXJnZXQgc3RhdGUuICBcblx0ICogRm9yIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcsIHRyeSBlbmFibGluZyBhbmQgZGlzYWJsaW5nIHRoaXMgb3B0aW9uIGluIHRoZSBbU2NlbmUgTWFuaXB1bGF0aW9uIEV4YW1wbGVdKC4uL2V4YW1wbGVzL2Jhc2ljL3NjZW5lX21hbmlwdWxhdGlvbi5odG1sKS5cblx0ICogQG1lbWJlcm9mISBhbmltYXRpb24uR1NBUCNcblx0ICogQG1ldGhvZCBTY2VuZS50d2VlbkNoYW5nZXNcblx0ICogXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGdldCB0aGUgY3VycmVudCB0d2VlbkNoYW5nZXMgb3B0aW9uXG5cdCAqIHZhciB0d2VlbkNoYW5nZXMgPSBzY2VuZS50d2VlbkNoYW5nZXMoKTtcblx0ICpcblx0ICogLy8gc2V0IG5ldyB0d2VlbkNoYW5nZXMgb3B0aW9uXG5cdCAqIHNjZW5lLnR3ZWVuQ2hhbmdlcyh0cnVlKTtcblx0ICpcblx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5jaGFuZ2V9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW25ld1R3ZWVuQ2hhbmdlc10gLSBUaGUgbmV3IHR3ZWVuQ2hhbmdlcyBzZXR0aW5nIG9mIHRoZSBzY2VuZS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IGBnZXRgIC0gIEN1cnJlbnQgdHdlZW5DaGFuZ2VzIG9wdGlvbiB2YWx1ZS5cblx0ICogQHJldHVybnMge1NjZW5lfSBgc2V0YCAtICBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0ICovXG5cdC8vIGFkZCBvcHRpb24gKFRPRE86IERPQyAocHJpdmF0ZSBmb3IgZGV2KSlcblx0U2Nyb2xsTWFnaWMuU2NlbmUuYWRkT3B0aW9uKFwidHdlZW5DaGFuZ2VzXCIsIC8vIG5hbWVcblx0ZmFsc2UsIC8vIGRlZmF1bHRcblxuXG5cdGZ1bmN0aW9uICh2YWwpIHsgLy8gdmFsaWRhdGlvbiBjYWxsYmFja1xuXHRcdHJldHVybiAhIXZhbDtcblx0fSk7XG5cdC8vIGV4dGVuZCBzY2VuZVxuXHRTY3JvbGxNYWdpYy5TY2VuZS5leHRlbmQoZnVuY3Rpb24gKCkge1xuXHRcdHZhciBTY2VuZSA9IHRoaXMsXG5cdFx0XHRfdHdlZW47XG5cblx0XHR2YXIgbG9nID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKFNjZW5lLl9sb2cpIHsgLy8gbm90IGF2YWlsYWJsZSwgd2hlbiBtYWluIHNvdXJjZSBtaW5pZmllZFxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAwLCBcIihcIiArIE5BTUVTUEFDRSArIFwiKVwiLCBcIi0+XCIpO1xuXHRcdFx0XHRTY2VuZS5fbG9nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIHNldCBsaXN0ZW5lcnNcblx0XHRTY2VuZS5vbihcInByb2dyZXNzLnBsdWdpbl9nc2FwXCIsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHVwZGF0ZVR3ZWVuUHJvZ3Jlc3MoKTtcblx0XHR9KTtcblx0XHRTY2VuZS5vbihcImRlc3Ryb3kucGx1Z2luX2dzYXBcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFNjZW5lLnJlbW92ZVR3ZWVuKGUucmVzZXQpO1xuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSB0d2VlbiBwcm9ncmVzcyB0byBjdXJyZW50IHBvc2l0aW9uLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHVwZGF0ZVR3ZWVuUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoX3R3ZWVuKSB7XG5cdFx0XHRcdHZhclxuXHRcdFx0XHRwcm9ncmVzcyA9IFNjZW5lLnByb2dyZXNzKCksXG5cdFx0XHRcdFx0c3RhdGUgPSBTY2VuZS5zdGF0ZSgpO1xuXHRcdFx0XHRpZiAoX3R3ZWVuLnJlcGVhdCAmJiBfdHdlZW4ucmVwZWF0KCkgPT09IC0xKSB7XG5cdFx0XHRcdFx0Ly8gaW5maW5pdGUgbG9vcCwgc28gbm90IGluIHJlbGF0aW9uIHRvIHByb2dyZXNzXG5cdFx0XHRcdFx0aWYgKHN0YXRlID09PSAnRFVSSU5HJyAmJiBfdHdlZW4ucGF1c2VkKCkpIHtcblx0XHRcdFx0XHRcdF90d2Vlbi5wbGF5KCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzdGF0ZSAhPT0gJ0RVUklORycgJiYgIV90d2Vlbi5wYXVzZWQoKSkge1xuXHRcdFx0XHRcdFx0X3R3ZWVuLnBhdXNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHByb2dyZXNzICE9IF90d2Vlbi5wcm9ncmVzcygpKSB7IC8vIGRvIHdlIGV2ZW4gbmVlZCB0byB1cGRhdGUgdGhlIHByb2dyZXNzP1xuXHRcdFx0XHRcdC8vIG5vIGluZmluaXRlIGxvb3AgLSBzbyBzaG91bGQgd2UganVzdCBwbGF5IG9yIGdvIHRvIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZT9cblx0XHRcdFx0XHRpZiAoU2NlbmUuZHVyYXRpb24oKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Ly8gcGxheSB0aGUgYW5pbWF0aW9uXG5cdFx0XHRcdFx0XHRpZiAocHJvZ3Jlc3MgPiAwKSB7IC8vIHBsYXkgZnJvbSAwIHRvIDFcblx0XHRcdFx0XHRcdFx0X3R3ZWVuLnBsYXkoKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7IC8vIHBsYXkgZnJvbSAxIHRvIDBcblx0XHRcdFx0XHRcdFx0X3R3ZWVuLnJldmVyc2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gZ28gdG8gYSBzcGVjaWZpYyBwb2ludCBpbiB0aW1lXG5cdFx0XHRcdFx0XHRpZiAoU2NlbmUudHdlZW5DaGFuZ2VzKCkgJiYgX3R3ZWVuLnR3ZWVuVG8pIHtcblx0XHRcdFx0XHRcdFx0Ly8gZ28gc21vb3RoXG5cdFx0XHRcdFx0XHRcdF90d2Vlbi50d2VlblRvKHByb2dyZXNzICogX3R3ZWVuLmR1cmF0aW9uKCkpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8ganVzdCBoYXJkIHNldCBpdFxuXHRcdFx0XHRcdFx0XHRfdHdlZW4ucHJvZ3Jlc3MocHJvZ3Jlc3MpLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIHR3ZWVuIHRvIHRoZSBzY2VuZS4gIFxuXHRcdCAqIElmIHlvdSB3YW50IHRvIGFkZCBtdWx0aXBsZSB0d2VlbnMsIGFkZCB0aGVtIGludG8gYSBHU0FQIFRpbWVsaW5lIG9iamVjdCBhbmQgc3VwcGx5IGl0IGluc3RlYWQgKHNlZSBleGFtcGxlIGJlbG93KS4gIFxuXHRcdCAqIFxuXHRcdCAqIElmIHRoZSBzY2VuZSBoYXMgYSBkdXJhdGlvbiwgdGhlIHR3ZWVuJ3MgZHVyYXRpb24gd2lsbCBiZSBwcm9qZWN0ZWQgdG8gdGhlIHNjcm9sbCBkaXN0YW5jZSBvZiB0aGUgc2NlbmUsIG1lYW5pbmcgaXRzIHByb2dyZXNzIHdpbGwgYmUgc3luY2VkIHRvIHNjcm9sbGJhciBtb3ZlbWVudC4gIFxuXHRcdCAqIEZvciBhIHNjZW5lIHdpdGggYSBkdXJhdGlvbiBvZiBgMGAsIHRoZSB0d2VlbiB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHNjcm9sbGluZyBmb3J3YXJkIHBhc3QgdGhlIHNjZW5lJ3MgdHJpZ2dlciBwb3NpdGlvbiBhbmQgcmV2ZXJzZWQsIHdoZW4gc2Nyb2xsaW5nIGJhY2suICBcblx0XHQgKiBUbyBnYWluIGJldHRlciB1bmRlcnN0YW5kaW5nLCBjaGVjayBvdXQgdGhlIFtTaW1wbGUgVHdlZW5pbmcgZXhhbXBsZV0oLi4vZXhhbXBsZXMvYmFzaWMvc2ltcGxlX3R3ZWVuaW5nLmh0bWwpLlxuXHRcdCAqXG5cdFx0ICogSW5zdGVhZCBvZiBzdXBwbHlpbmcgYSB0d2VlbiB0aGlzIG1ldGhvZCBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgc2hvcnRoYW5kIGZvciBgVHdlZW5NYXgudG8oKWAgKHNlZSBleGFtcGxlIGJlbG93KS5cblx0XHQgKiBAbWVtYmVyb2YhIGFuaW1hdGlvbi5HU0FQI1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBhZGQgYSBzaW5nbGUgdHdlZW4gZGlyZWN0bHlcblx0XHQgKiBzY2VuZS5zZXRUd2VlbihUd2Vlbk1heC50byhcIm9ialwiKSwgMSwge3g6IDEwMH0pO1xuXHRcdCAqXG5cdFx0ICogLy8gYWRkIGEgc2luZ2xlIHR3ZWVuIHZpYSB2YXJpYWJsZVxuXHRcdCAqIHZhciB0d2VlbiA9IFR3ZWVuTWF4LnRvKFwib2JqXCIpLCAxLCB7eDogMTAwfTtcblx0XHQgKiBzY2VuZS5zZXRUd2Vlbih0d2Vlbik7XG5cdFx0ICpcblx0XHQgKiAvLyBhZGQgbXVsdGlwbGUgdHdlZW5zLCB3cmFwcGVkIGluIGEgdGltZWxpbmUuXG5cdFx0ICogdmFyIHRpbWVsaW5lID0gbmV3IFRpbWVsaW5lTWF4KCk7XG5cdFx0ICogdmFyIHR3ZWVuMSA9IFR3ZWVuTWF4LmZyb20oXCJvYmoxXCIsIDEsIHt4OiAxMDB9KTtcblx0XHQgKiB2YXIgdHdlZW4yID0gVHdlZW5NYXgudG8oXCJvYmoyXCIsIDEsIHt5OiAxMDB9KTtcblx0XHQgKiB0aW1lbGluZVxuXHRcdCAqXHRcdC5hZGQodHdlZW4xKVxuXHRcdCAqXHRcdC5hZGQodHdlZW4yKTtcblx0XHQgKiBzY2VuZS5hZGRUd2Vlbih0aW1lbGluZSk7XG5cdFx0ICpcblx0XHQgKiAvLyBzaG9ydCBoYW5kIHRvIGFkZCBhIFR3ZWVuTWF4LnRvKCkgdHdlZW5cblx0XHQgKiBzY2VuZS5zZXRUd2VlbihcIm9iajNcIiwgMC41LCB7eTogMTAwfSk7XG5cdFx0ICpcblx0XHQgKiAvLyBzaG9ydCBoYW5kIHRvIGFkZCBhIFR3ZWVuTWF4LnRvKCkgdHdlZW4gZm9yIDEgc2Vjb25kXG5cdFx0ICogLy8gdGhpcyBpcyB1c2VmdWwsIHdoZW4gdGhlIHNjZW5lIGhhcyBhIGR1cmF0aW9uIGFuZCB0aGUgdHdlZW4gZHVyYXRpb24gaXNuJ3QgaW1wb3J0YW50IGFueXdheVxuXHRcdCAqIHNjZW5lLnNldFR3ZWVuKFwib2JqM1wiLCB7eTogMTAwfSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyhvYmplY3R8c3RyaW5nKX0gVHdlZW5PYmplY3QgLSBBIFR3ZWVuTWF4LCBUd2VlbkxpdGUsIFRpbWVsaW5lTWF4IG9yIFRpbWVsaW5lTGl0ZSBvYmplY3QgdGhhdCBzaG91bGQgYmUgYW5pbWF0ZWQgaW4gdGhlIHNjZW5lLiBDYW4gYWxzbyBiZSBhIERvbSBFbGVtZW50IG9yIFNlbGVjdG9yLCB3aGVuIHVzaW5nIGRpcmVjdCB0d2VlbiBkZWZpbml0aW9uIChzZWUgZXhhbXBsZXMpLlxuXHRcdCAqIEBwYXJhbSB7KG51bWJlcnxvYmplY3QpfSBkdXJhdGlvbiAtIEEgZHVyYXRpb24gZm9yIHRoZSB0d2Vlbiwgb3IgdHdlZW4gcGFyYW1ldGVycy4gSWYgYW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBhcmUgc3VwcGxpZWQsIGEgZGVmYXVsdCBkdXJhdGlvbiBvZiAxIHdpbGwgYmUgdXNlZC5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSB0d2VlblxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0U2NlbmUuc2V0VHdlZW4gPSBmdW5jdGlvbiAoVHdlZW5PYmplY3QsIGR1cmF0aW9uLCBwYXJhbXMpIHtcblx0XHRcdHZhciBuZXdUd2Vlbjtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcblx0XHRcdFx0XHRwYXJhbXMgPSBkdXJhdGlvbjtcblx0XHRcdFx0XHRkdXJhdGlvbiA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0VHdlZW5PYmplY3QgPSBUd2Vlbi50byhUd2Vlbk9iamVjdCwgZHVyYXRpb24sIHBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyB3cmFwIFR3ZWVuIGludG8gYSBUaW1lbGluZSBPYmplY3QgaWYgYXZhaWxhYmxlIHRvIGluY2x1ZGUgZGVsYXkgYW5kIHJlcGVhdHMgaW4gdGhlIGR1cmF0aW9uIGFuZCBzdGFuZGFyZGl6ZSBtZXRob2RzLlxuXHRcdFx0XHRpZiAoVGltZWxpbmUpIHtcblx0XHRcdFx0XHRuZXdUd2VlbiA9IG5ldyBUaW1lbGluZSh7XG5cdFx0XHRcdFx0XHRzbW9vdGhDaGlsZFRpbWluZzogdHJ1ZVxuXHRcdFx0XHRcdH0pLmFkZChUd2Vlbk9iamVjdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3VHdlZW4gPSBUd2Vlbk9iamVjdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXdUd2Vlbi5wYXVzZSgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRsb2coMSwgXCJFUlJPUiBjYWxsaW5nIG1ldGhvZCAnc2V0VHdlZW4oKSc6IFN1cHBsaWVkIGFyZ3VtZW50IGlzIG5vdCBhIHZhbGlkIFR3ZWVuT2JqZWN0XCIpO1xuXHRcdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX3R3ZWVuKSB7IC8vIGtpbGwgb2xkIHR3ZWVuP1xuXHRcdFx0XHRTY2VuZS5yZW1vdmVUd2VlbigpO1xuXHRcdFx0fVxuXHRcdFx0X3R3ZWVuID0gbmV3VHdlZW47XG5cblx0XHRcdC8vIHNvbWUgcHJvcGVydGllcyBuZWVkIHRvIGJlIHRyYW5zZmVycmVkIGl0IHRvIHRoZSB3cmFwcGVyLCBvdGhlcndpc2UgdGhleSB3b3VsZCBnZXQgbG9zdC5cblx0XHRcdGlmIChUd2Vlbk9iamVjdC5yZXBlYXQgJiYgVHdlZW5PYmplY3QucmVwZWF0KCkgPT09IC0xKSB7IC8vIFR3ZWVuTWF4IG9yIFRpbWVsaW5lTWF4IE9iamVjdD9cblx0XHRcdFx0X3R3ZWVuLnJlcGVhdCgtMSk7XG5cdFx0XHRcdF90d2Vlbi55b3lvKFR3ZWVuT2JqZWN0LnlveW8oKSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBTb21lIHR3ZWVuIHZhbGlkYXRpb25zIGFuZCBkZWJ1Z2dpbmcgaGVscGVyc1xuXHRcdFx0aWYgKFNjZW5lLnR3ZWVuQ2hhbmdlcygpICYmICFfdHdlZW4udHdlZW5Ubykge1xuXHRcdFx0XHRsb2coMiwgXCJXQVJOSU5HOiB0d2VlbkNoYW5nZXMgd2lsbCBvbmx5IHdvcmsgaWYgdGhlIFRpbWVsaW5lTWF4IG9iamVjdCBpcyBhdmFpbGFibGUgZm9yIFNjcm9sbE1hZ2ljLlwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlcmUgYXJlIHBvc2l0aW9uIHR3ZWVucyBkZWZpbmVkIGZvciB0aGUgdHJpZ2dlciBhbmQgd2FybiBhYm91dCBpdCA6KVxuXHRcdFx0aWYgKF90d2VlbiAmJiBTY2VuZS5jb250cm9sbGVyKCkgJiYgU2NlbmUudHJpZ2dlckVsZW1lbnQoKSAmJiBTY2VuZS5sb2dsZXZlbCgpID49IDIpIHsgLy8gY29udHJvbGxlciBpcyBuZWVkZWQgdG8ga25vdyBzY3JvbGwgZGlyZWN0aW9uLlxuXHRcdFx0XHR2YXJcblx0XHRcdFx0dHJpZ2dlclR3ZWVucyA9IFR3ZWVuLmdldFR3ZWVuc09mKFNjZW5lLnRyaWdnZXJFbGVtZW50KCkpLFxuXHRcdFx0XHRcdHZlcnRpY2FsID0gU2NlbmUuY29udHJvbGxlcigpLmluZm8oXCJ2ZXJ0aWNhbFwiKTtcblx0XHRcdFx0dHJpZ2dlclR3ZWVucy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHR0d2VlbnZhcnMgPSB2YWx1ZS52YXJzLmNzcyB8fCB2YWx1ZS52YXJzLFxuXHRcdFx0XHRcdFx0Y29uZGl0aW9uID0gdmVydGljYWwgPyAodHdlZW52YXJzLnRvcCAhPT0gdW5kZWZpbmVkIHx8IHR3ZWVudmFycy5ib3R0b20gIT09IHVuZGVmaW5lZCkgOiAodHdlZW52YXJzLmxlZnQgIT09IHVuZGVmaW5lZCB8fCB0d2VlbnZhcnMucmlnaHQgIT09IHVuZGVmaW5lZCk7XG5cdFx0XHRcdFx0aWYgKGNvbmRpdGlvbikge1xuXHRcdFx0XHRcdFx0bG9nKDIsIFwiV0FSTklORzogVHdlZW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSB0cmlnZ2VyIGVsZW1lbnQgYWZmZWN0cyB0aGUgc2NlbmUgdGltaW5nIGFuZCBzaG91bGQgYmUgYXZvaWRlZCFcIik7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gd2FybiBhYm91dCB0d2VlbiBvdmVyd3JpdGVzLCB3aGVuIGFuIGVsZW1lbnQgaXMgdHdlZW5lZCBtdWx0aXBsZSB0aW1lc1xuXHRcdFx0aWYgKHBhcnNlRmxvYXQoVHdlZW5MaXRlLnZlcnNpb24pID49IDEuMTQpIHsgLy8gb25PdmVyd3JpdGUgb25seSBwcmVzZW50IHNpbmNlIEdTQVAgdjEuMTQuMFxuXHRcdFx0XHR2YXJcblx0XHRcdFx0bGlzdCA9IF90d2Vlbi5nZXRDaGlsZHJlbiA/IF90d2Vlbi5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkgOiBbX3R3ZWVuXSxcblx0XHRcdFx0XHQvLyBnZXQgYWxsIG5lc3RlZCB0d2VlbiBvYmplY3RzXG5cdFx0XHRcdFx0bmV3Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRsb2coMiwgXCJXQVJOSU5HOiB0d2VlbiB3YXMgb3ZlcndyaXR0ZW4gYnkgYW5vdGhlci4gVG8gbGVhcm4gaG93IHRvIGF2b2lkIHRoaXMgaXNzdWUgc2VlIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5wYWVwa2UvU2Nyb2xsTWFnaWMvd2lraS9XQVJOSU5HOi10d2Vlbi13YXMtb3ZlcndyaXR0ZW4tYnktYW5vdGhlclwiKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgdGhpc1R3ZWVuLCBvbGRDYWxsYmFjazsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHsgLypqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cblx0XHRcdFx0XHR0aGlzVHdlZW4gPSBsaXN0W2ldO1xuXHRcdFx0XHRcdGlmIChvbGRDYWxsYmFjayAhPT0gbmV3Q2FsbGJhY2spIHsgLy8gaWYgdHdlZW5zIGlzIGFkZGVkIG1vcmUgdGhhbiBvbmNlXG5cdFx0XHRcdFx0XHRvbGRDYWxsYmFjayA9IHRoaXNUd2Vlbi52YXJzLm9uT3ZlcndyaXRlO1xuXHRcdFx0XHRcdFx0dGhpc1R3ZWVuLnZhcnMub25PdmVyd3JpdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvbGRDYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0XHRcdG9sZENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bmV3Q2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsb2coMywgXCJhZGRlZCB0d2VlblwiKTtcblxuXHRcdFx0dXBkYXRlVHdlZW5Qcm9ncmVzcygpO1xuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgdGhlIHR3ZWVuIGZyb20gdGhlIHNjZW5lLiAgXG5cdFx0ICogVGhpcyB3aWxsIHRlcm1pbmF0ZSB0aGUgY29udHJvbCBvZiB0aGUgU2NlbmUgb3ZlciB0aGUgdHdlZW4uXG5cdFx0ICpcblx0XHQgKiBVc2luZyB0aGUgcmVzZXQgb3B0aW9uIHlvdSBjYW4gZGVjaWRlIGlmIHRoZSB0d2VlbiBzaG91bGQgcmVtYWluIGluIHRoZSBjdXJyZW50IHN0YXRlIG9yIGJlIHJld291bmQgdG8gc2V0IHRoZSB0YXJnZXQgZWxlbWVudHMgYmFjayB0byB0aGUgc3RhdGUgdGhleSB3ZXJlIGluIGJlZm9yZSB0aGUgdHdlZW4gd2FzIGFkZGVkIHRvIHRoZSBzY2VuZS5cblx0XHQgKiBAbWVtYmVyb2YhIGFuaW1hdGlvbi5HU0FQI1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyByZW1vdmUgdGhlIHR3ZWVuIGZyb20gdGhlIHNjZW5lIHdpdGhvdXQgcmVzZXR0aW5nIGl0XG5cdFx0ICogc2NlbmUucmVtb3ZlVHdlZW4oKTtcblx0XHQgKlxuXHRcdCAqIC8vIHJlbW92ZSB0aGUgdHdlZW4gZnJvbSB0aGUgc2NlbmUgYW5kIHJlc2V0IGl0IHRvIGluaXRpYWwgcG9zaXRpb25cblx0XHQgKiBzY2VuZS5yZW1vdmVUd2Vlbih0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0PWZhbHNlXSAtIElmIGB0cnVlYCB0aGUgdHdlZW4gd2lsbCBiZSByZXNldCB0byBpdHMgaW5pdGlhbCB2YWx1ZXMuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHRTY2VuZS5yZW1vdmVUd2VlbiA9IGZ1bmN0aW9uIChyZXNldCkge1xuXHRcdFx0aWYgKF90d2Vlbikge1xuXHRcdFx0XHRpZiAocmVzZXQpIHtcblx0XHRcdFx0XHRfdHdlZW4ucHJvZ3Jlc3MoMCkucGF1c2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdHdlZW4ua2lsbCgpO1xuXHRcdFx0XHRfdHdlZW4gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGxvZygzLCBcInJlbW92ZWQgdHdlZW4gKHJlc2V0OiBcIiArIChyZXNldCA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKSArIFwiKVwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdH0pO1xufSkpOyIsIi8qISBMYXp5IExvYWQgWFQgdjEuMC41IDIwMTQtMDYtMDVcbiAqIGh0dHA6Ly9yZXNzaW8uZ2l0aHViLmlvL2xhenktbG9hZC14dFxuICogKEMpIDIwMTQgUkVTUy5pb1xuICogTGljZW5zZWQgdW5kZXIgTUlUICovXG5cbihmdW5jdGlvbiAoJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG4gICAgLy8gb3B0aW9uc1xuICAgIHZhciBsYXp5TG9hZFhUID0gJ2xhenlMb2FkWFQnLFxuICAgICAgICBkYXRhTGF6aWVkID0gJ2xhemllZCcsXG4gICAgICAgIGxvYWRfZXJyb3IgPSAnbG9hZCBlcnJvcicsXG4gICAgICAgIGNsYXNzTGF6eUhpZGRlbiA9ICdsYXp5LWhpZGRlbicsXG4gICAgICAgIGRvY0VsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSxcbiAgICAvLyAgZm9yY2UgbG9hZCBhbGwgaW1hZ2VzIGluIE9wZXJhIE1pbmkgYW5kIHNvbWUgbW9iaWxlIGJyb3dzZXJzIHdpdGhvdXQgc2Nyb2xsIGV2ZW50IG9yIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIGZvcmNlTG9hZCA9ICh3aW5kb3cub25zY3JvbGwgPT09IHVuZGVmaW5lZCB8fCAhIXdpbmRvdy5vcGVyYW1pbmkgfHwgIWRvY0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSxcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGF1dG9Jbml0OiB0cnVlLCAvLyBhdXRvIGluaXRpYWxpemUgaW4gJC5yZWFkeVxuICAgICAgICAgICAgc2VsZWN0b3I6ICdpbWdbZGF0YS1zcmNdJywgLy8gc2VsZWN0b3IgZm9yIGxhenlsb2FkaW5nIGVsZW1lbnRzXG4gICAgICAgICAgICBibGFua0ltYWdlOiAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3JyxcbiAgICAgICAgICAgIHRocm90dGxlOiA5OSwgLy8gaW50ZXJ2YWwgKG1zKSBmb3IgY2hhbmdlcyBjaGVja1xuICAgICAgICAgICAgZm9yY2VMb2FkOiBmb3JjZUxvYWQsIC8vIGZvcmNlIGF1dG8gbG9hZCBhbGwgaW1hZ2VzXG5cbiAgICAgICAgICAgIGxvYWRFdmVudDogJ3BhZ2VzaG93JywgLy8gY2hlY2sgQUpBWC1sb2FkZWQgY29udGVudCBpbiBqUXVlcnlNb2JpbGVcbiAgICAgICAgICAgIHVwZGF0ZUV2ZW50OiAnbG9hZCBvcmllbnRhdGlvbmNoYW5nZSByZXNpemUgc2Nyb2xsIHRvdWNobW92ZSBmb2N1cycsIC8vIHBhZ2UtbW9kaWZpZWQgZXZlbnRzXG4gICAgICAgICAgICBmb3JjZUV2ZW50OiAnJywgLy8gZm9yY2UgbG9hZGluZyBvZiBhbGwgZWxlbWVudHNcblxuICAgICAgICAgICAgLy9vbnN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgb25pbml0OiB7cmVtb3ZlQ2xhc3M6ICdsYXp5J30sIC8vIGluaXQgaGFuZGxlclxuICAgICAgICAgICAgb25zaG93OiB7YWRkQ2xhc3M6IGNsYXNzTGF6eUhpZGRlbn0sIC8vIHN0YXJ0IGxvYWRpbmcgaGFuZGxlclxuICAgICAgICAgICAgb25sb2FkOiB7cmVtb3ZlQ2xhc3M6IGNsYXNzTGF6eUhpZGRlbiwgYWRkQ2xhc3M6ICdsYXp5LWxvYWRlZCd9LCAvLyBsb2FkIHN1Y2Nlc3MgaGFuZGxlclxuICAgICAgICAgICAgb25lcnJvcjoge3JlbW92ZUNsYXNzOiBjbGFzc0xhenlIaWRkZW59LCAvLyBlcnJvciBoYW5kbGVyXG4gICAgICAgICAgICAvL29uY29tcGxldGU6IG51bGwsIC8vIGNvbXBsZXRlIGhhbmRsZXJcblxuICAgICAgICAgICAgLy9zY3JvbGxDb250YWluZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlczogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBlbGVtZW50T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNyY0F0dHI6ICdkYXRhLXNyYycsXG4gICAgICAgICAgICBlZGdlWDogMCxcbiAgICAgICAgICAgIGVkZ2VZOiAwLFxuICAgICAgICAgICAgdmlzaWJsZU9ubHk6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJHdpbmRvdyA9ICQod2luZG93KSxcbiAgICAgICAgJGlzRnVuY3Rpb24gPSAkLmlzRnVuY3Rpb24sXG4gICAgICAgICRleHRlbmQgPSAkLmV4dGVuZCxcbiAgICAgICAgJGRhdGEgPSAkLmRhdGEgfHwgZnVuY3Rpb24gKGVsLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJChlbCkuZGF0YShuYW1lKTtcbiAgICAgICAgfSxcbiAgICAvLyAkLmNvbnRhaW5zIGlzIG5vdCBpbmNsdWRlZCBpbnRvIERPTXRhc3RpYywgc28gaW1wbGVtZW50IGl0IHRoZXJlXG4gICAgICAgICRjb250YWlucyA9ICQuY29udGFpbnMgfHwgZnVuY3Rpb24gKHBhcmVudCwgZWwpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbCA9IGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVsZW1lbnRzID0gW10sXG4gICAgICAgIHRvcExhenkgPSAwLFxuICAgIC8qXG4gICAgIHdhaXRpbmdNb2RlPTAgOiBubyBzZXRUaW1lb3V0XG4gICAgIHdhaXRpbmdNb2RlPTEgOiBzZXRUaW1lb3V0LCBubyBkZWZlcnJlZCBldmVudHNcbiAgICAgd2FpdGluZ01vZGU9MiA6IHNldFRpbWVvdXQsIGRlZmVycmVkIGV2ZW50c1xuICAgICAqL1xuICAgICAgICB3YWl0aW5nTW9kZSA9IDA7XG5cbiAgICAkW2xhenlMb2FkWFRdID0gJGV4dGVuZChvcHRpb25zLCBlbGVtZW50T3B0aW9ucywgJFtsYXp5TG9hZFhUXSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gb3B0aW9ucy5wcm9wIGlmIG9iai5wcm9wIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIHJldHVybiBvYmoucHJvcFxuICAgICAqIEBwYXJhbSB7Kn0gb2JqXG4gICAgICogQHBhcmFtIHsqfSBwcm9wXG4gICAgICogQHJldHVybnMgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE9yRGVmKG9iaiwgcHJvcCkge1xuICAgICAgICByZXR1cm4gb2JqW3Byb3BdID09PSB1bmRlZmluZWQgPyBvcHRpb25zW3Byb3BdIDogb2JqW3Byb3BdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2Nyb2xsVG9wKCkge1xuICAgICAgICB2YXIgc2Nyb2xsID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICByZXR1cm4gKHNjcm9sbCA9PT0gdW5kZWZpbmVkKSA/IGRvY0VsZW1lbnQuc2Nyb2xsVG9wIDogc2Nyb2xsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBuZXcgZWxlbWVudHMgdG8gbGF6eS1sb2FkIGxpc3Q6XG4gICAgICogJChlbGVtZW50cykubGF6eUxvYWRYVCgpIG9yICQod2luZG93KS5sYXp5TG9hZFhUKClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3ZlcnJpZGVzXSBvdmVycmlkZSBnbG9iYWwgb3B0aW9uc1xuICAgICAqL1xuICAgICQuZm5bbGF6eUxvYWRYVF0gPSBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIG92ZXJyaWRlcyA9IG92ZXJyaWRlcyB8fCB7fTtcblxuICAgICAgICB2YXIgYmxhbmtJbWFnZSA9IGdldE9yRGVmKG92ZXJyaWRlcywgJ2JsYW5rSW1hZ2UnKSxcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlcyA9IGdldE9yRGVmKG92ZXJyaWRlcywgJ2NoZWNrRHVwbGljYXRlcycpLFxuICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyID0gZ2V0T3JEZWYob3ZlcnJpZGVzLCAnc2Nyb2xsQ29udGFpbmVyJyksXG4gICAgICAgICAgICBlbGVtZW50T3B0aW9uc092ZXJyaWRlcyA9IHt9LFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICAvLyBlbXB0eSBvdmVycmlkZXMuc2Nyb2xsQ29udGFpbmVyIGlzIHN1cHBvcnRlZCBieSBib3RoIGpRdWVyeSBhbmQgWmVwdG9cbiAgICAgICAgJChzY3JvbGxDb250YWluZXIpLm9uKCdzY3JvbGwnLCBxdWV1ZUNoZWNrTGF6eUVsZW1lbnRzKTtcblxuICAgICAgICBmb3IgKHByb3AgaW4gZWxlbWVudE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGVsZW1lbnRPcHRpb25zT3ZlcnJpZGVzW3Byb3BdID0gZ2V0T3JEZWYob3ZlcnJpZGVzLCBwcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbCkge1xuICAgICAgICAgICAgaWYgKGVsID09PSB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAkKG9wdGlvbnMuc2VsZWN0b3IpLmxhenlMb2FkWFQob3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrRHVwbGljYXRlcyAmJiAkZGF0YShlbCwgZGF0YUxhemllZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciAkZWwgPSAkKGVsKS5kYXRhKGRhdGFMYXppZWQsIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJsYW5rSW1hZ2UgJiYgZWwudGFnTmFtZSA9PT0gJ0lNRycgJiYgIWVsLnNyYykge1xuICAgICAgICAgICAgICAgICAgICBlbC5zcmMgPSBibGFua0ltYWdlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNsb25lIGVsZW1lbnRPcHRpb25zT3ZlcnJpZGVzIG9iamVjdFxuICAgICAgICAgICAgICAgICRlbFtsYXp5TG9hZFhUXSA9ICRleHRlbmQoe30sIGVsZW1lbnRPcHRpb25zT3ZlcnJpZGVzKTtcblxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnaW5pdCcsICRlbCk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKCRlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgZnVuY3Rpb24vb2JqZWN0IGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgc3VmZml4XG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJFdmVudChldmVudCwgJGVsKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gb3B0aW9uc1snb24nICsgZXZlbnRdO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKCRpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKCRlbFswXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmFkZENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRlbC5hZGRDbGFzcyhoYW5kbGVyLmFkZENsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmVtb3ZlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsLnJlbW92ZUNsYXNzKGhhbmRsZXIucmVtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICRlbC50cmlnZ2VyKCdsYXp5JyArIGV2ZW50LCBbJGVsXSk7XG5cbiAgICAgICAgLy8gcXVldWUgbmV4dCBjaGVjayBhcyBpbWFnZXMgbWF5IGJlIHJlc2l6ZWQgYWZ0ZXIgbG9hZGluZyBvZiBhY3R1YWwgZmlsZVxuICAgICAgICBxdWV1ZUNoZWNrTGF6eUVsZW1lbnRzKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIG9ubG9hZC9vbmVycm9yIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpZ2dlckxvYWRPckVycm9yKGUpIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50KGUudHlwZSwgJCh0aGlzKS5vZmYobG9hZF9lcnJvciwgdHJpZ2dlckxvYWRPckVycm9yKSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHZpc2libGUgZWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtmb3JjZV0gbG9hZGluZyBvZiBhbGwgZWxlbWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0xhenlFbGVtZW50cyhmb3JjZSkge1xuICAgICAgICBpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yY2UgPSBmb3JjZSB8fCBvcHRpb25zLmZvcmNlTG9hZDtcblxuICAgICAgICB0b3BMYXp5ID0gSW5maW5pdHk7XG5cbiAgICAgICAgdmFyIHZpZXdwb3J0VG9wID0gc2Nyb2xsVG9wKCksXG4gICAgICAgICAgICB2aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2NFbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgIHZpZXdwb3J0V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2NFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyICRlbCA9IGVsZW1lbnRzW2ldLFxuICAgICAgICAgICAgICAgIGVsID0gJGVsWzBdLFxuICAgICAgICAgICAgICAgIG9iakRhdGEgPSAkZWxbbGF6eUxvYWRYVF0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZpc2libGUgPSBmb3JjZSxcbiAgICAgICAgICAgICAgICB0b3BFZGdlO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgaXRlbXMgdGhhdCBhcmUgbm90IGluIERPTVxuICAgICAgICAgICAgaWYgKCEkY29udGFpbnMoZG9jRWxlbWVudCwgZWwpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcmNlIHx8ICFvYmpEYXRhLnZpc2libGVPbmx5IHx8IGVsLm9mZnNldFdpZHRoIHx8IGVsLm9mZnNldEhlaWdodCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbFBvcyA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZVggPSBvYmpEYXRhLmVkZ2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZVkgPSBvYmpEYXRhLmVkZ2VZO1xuXG4gICAgICAgICAgICAgICAgICAgIHRvcEVkZ2UgPSAoZWxQb3MudG9wICsgdmlld3BvcnRUb3AgLSBlZGdlWSkgLSB2aWV3cG9ydEhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlID0gKHRvcEVkZ2UgPD0gdmlld3BvcnRUb3AgJiYgZWxQb3MuYm90dG9tID4gLWVkZ2VZICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFBvcy5sZWZ0IDw9IHZpZXdwb3J0V2lkdGggKyBlZGdlWCAmJiBlbFBvcy5yaWdodCA+IC1lZGdlWCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdzaG93JywgJGVsKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3JjQXR0ciA9IG9iakRhdGEuc3JjQXR0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9ICRpc0Z1bmN0aW9uKHNyY0F0dHIpID8gc3JjQXR0cigkZWwpIDogZWwuZ2V0QXR0cmlidXRlKHNyY0F0dHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZWwub24obG9hZF9lcnJvciwgdHJpZ2dlckxvYWRPckVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BFZGdlIDwgdG9wTGF6eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGF6eSA9IHRvcEVkZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW1vdmVOb2RlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdjb21wbGV0ZScsICQoZG9jRWxlbWVudCkpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSdW4gY2hlY2sgb2YgbGF6eSBlbGVtZW50cyBhZnRlciB0aW1lb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZW91dExhenlFbGVtZW50cygpIHtcbiAgICAgICAgaWYgKHdhaXRpbmdNb2RlID4gMSkge1xuICAgICAgICAgICAgd2FpdGluZ01vZGUgPSAxO1xuICAgICAgICAgICAgY2hlY2tMYXp5RWxlbWVudHMoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dExhenlFbGVtZW50cywgb3B0aW9ucy50aHJvdHRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YWl0aW5nTW9kZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFF1ZXVlIGNoZWNrIG9mIGxhenkgZWxlbWVudHMgYmVjYXVzZSBvZiBldmVudCBlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVldWVDaGVja0xhenlFbGVtZW50cyhlKSB7XG4gICAgICAgIGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmYXN0IGNoZWNrIGZvciBzY3JvbGwgZXZlbnQgd2l0aG91dCBuZXcgdmlzaWJsZSBlbGVtZW50c1xuICAgICAgICBpZiAoZSAmJiBlLnR5cGUgPT09ICdzY3JvbGwnICYmIGUuY3VycmVudFRhcmdldCA9PT0gd2luZG93KSB7XG4gICAgICAgICAgICBpZiAodG9wTGF6eSA+PSBzY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghd2FpdGluZ01vZGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dExhenlFbGVtZW50cywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgd2FpdGluZ01vZGUgPSAyO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBsaXN0IG9mIGhpZGRlbiBlbGVtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRMYXp5RWxlbWVudHMoKSB7XG4gICAgICAgICR3aW5kb3cubGF6eUxvYWRYVCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTG9hZGluZyBvZiBhbGwgZWxlbWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JjZUxvYWRBbGwoKSB7XG4gICAgICAgIGNoZWNrTGF6eUVsZW1lbnRzKHRydWUpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6YXRpb25cbiAgICAgKi9cbiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyaWdnZXJFdmVudCgnc3RhcnQnLCAkd2luZG93KTtcblxuICAgICAgICAkd2luZG93XG4gICAgICAgICAgICAub24ob3B0aW9ucy5sb2FkRXZlbnQsIGluaXRMYXp5RWxlbWVudHMpXG4gICAgICAgICAgICAub24ob3B0aW9ucy51cGRhdGVFdmVudCwgcXVldWVDaGVja0xhenlFbGVtZW50cylcbiAgICAgICAgICAgIC5vbihvcHRpb25zLmZvcmNlRXZlbnQsIGZvcmNlTG9hZEFsbCk7XG5cbiAgICAgICAgJChkb2N1bWVudCkub24ob3B0aW9ucy51cGRhdGVFdmVudCwgcXVldWVDaGVja0xhenlFbGVtZW50cyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0luaXQpIHtcbiAgICAgICAgICAgIGluaXRMYXp5RWxlbWVudHMoKTsgLy8gc3RhbmRhcmQgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KSh3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0byB8fCB3aW5kb3cuJCwgd2luZG93LCBkb2N1bWVudCk7IiwiLyohIExhenkgTG9hZCBYVCB2MS4wLjUgMjAxNC0wNi0wNVxuICogaHR0cDovL3Jlc3Npby5naXRodWIuaW8vbGF6eS1sb2FkLXh0XG4gKiAoQykgMjAxNCBSRVNTLmlvXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKi9cblxuKGZ1bmN0aW9uICgkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSAkLmxhenlMb2FkWFQ7XG5cbiAgICBvcHRpb25zLmZvcmNlRXZlbnQgKz0gJyBsYXp5YXV0b2xvYWQnO1xuICAgIG9wdGlvbnMuYXV0b0xvYWRUaW1lID0gb3B0aW9ucy5hdXRvTG9hZFRpbWUgfHwgNTA7XG5cbiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh3aW5kb3cpLnRyaWdnZXIoJ2xhenlhdXRvbG9hZCcpO1xuICAgICAgICB9LCBvcHRpb25zLmF1dG9Mb2FkVGltZSk7XG4gICAgfSk7XG5cbn0pKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvIHx8IHdpbmRvdy4kKTtcbiIsIi8qISBMYXp5IExvYWQgWFQgdjEuMC41IDIwMTQtMDYtMDVcbiAqIGh0dHA6Ly9yZXNzaW8uZ2l0aHViLmlvL2xhenktbG9hZC14dFxuICogKEMpIDIwMTQgUkVTUy5pb1xuICogTGljZW5zZWQgdW5kZXIgTUlUICovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgIHZhciBvcHRpb25zID0gJC5sYXp5TG9hZFhULFxuICAgICAgICBiZ0F0dHIgPSBvcHRpb25zLmJnQXR0ciB8fCAnZGF0YS1iZyc7XG5cbiAgICBvcHRpb25zLnNlbGVjdG9yICs9ICcsWycgKyBiZ0F0dHIgKyAnXSc7XG5cbiAgICAkKGRvY3VtZW50KS5vbignbGF6eXNob3cnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgJHRoaXMgPSAkKGUudGFyZ2V0KTtcbiAgICAgICAgJHRoaXNcbiAgICAgICAgICAgIC5jc3MoJ2JhY2tncm91bmQtaW1hZ2UnLCBcInVybCgnXCIgKyAkdGhpcy5hdHRyKGJnQXR0cikgKyBcIicpXCIpXG4gICAgICAgICAgICAucmVtb3ZlQXR0cihiZ0F0dHIpO1xuICAgIH0pO1xuXG59KSh3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0byB8fCB3aW5kb3cuJCk7XG4iLCIhZnVuY3Rpb24oJCkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEZPVU5EQVRJT05fVkVSU0lPTiA9ICc2LjIuMSc7XG5cbi8vIEdsb2JhbCBGb3VuZGF0aW9uIG9iamVjdFxuLy8gVGhpcyBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93LCBvciB1c2VkIGFzIGEgbW9kdWxlIGZvciBBTUQvQnJvd3NlcmlmeVxudmFyIEZvdW5kYXRpb24gPSB7XG4gIHZlcnNpb246IEZPVU5EQVRJT05fVkVSU0lPTixcblxuICAvKipcbiAgICogU3RvcmVzIGluaXRpYWxpemVkIHBsdWdpbnMuXG4gICAqL1xuICBfcGx1Z2luczoge30sXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBnZW5lcmF0ZWQgdW5pcXVlIGlkcyBmb3IgcGx1Z2luIGluc3RhbmNlc1xuICAgKi9cbiAgX3V1aWRzOiBbXSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gZm9yIFJUTCBzdXBwb3J0XG4gICAqL1xuICBydGw6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICQoJ2h0bWwnKS5hdHRyKCdkaXInKSA9PT0gJ3J0bCc7XG4gIH0sXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgRm91bmRhdGlvbiBwbHVnaW4sIGFkZGluZyBpdCB0byB0aGUgYEZvdW5kYXRpb25gIG5hbWVzcGFjZSBhbmQgdGhlIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplIHdoZW4gcmVmbG93aW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBwbHVnaW4uXG4gICAqL1xuICBwbHVnaW46IGZ1bmN0aW9uKHBsdWdpbiwgbmFtZSkge1xuICAgIC8vIE9iamVjdCBrZXkgdG8gdXNlIHdoZW4gYWRkaW5nIHRvIGdsb2JhbCBGb3VuZGF0aW9uIG9iamVjdFxuICAgIC8vIEV4YW1wbGVzOiBGb3VuZGF0aW9uLlJldmVhbCwgRm91bmRhdGlvbi5PZmZDYW52YXNcbiAgICB2YXIgY2xhc3NOYW1lID0gKG5hbWUgfHwgZnVuY3Rpb25OYW1lKHBsdWdpbikpO1xuICAgIC8vIE9iamVjdCBrZXkgdG8gdXNlIHdoZW4gc3RvcmluZyB0aGUgcGx1Z2luLCBhbHNvIHVzZWQgdG8gY3JlYXRlIHRoZSBpZGVudGlmeWluZyBkYXRhIGF0dHJpYnV0ZSBmb3IgdGhlIHBsdWdpblxuICAgIC8vIEV4YW1wbGVzOiBkYXRhLXJldmVhbCwgZGF0YS1vZmYtY2FudmFzXG4gICAgdmFyIGF0dHJOYW1lICA9IGh5cGhlbmF0ZShjbGFzc05hbWUpO1xuXG4gICAgLy8gQWRkIHRvIHRoZSBGb3VuZGF0aW9uIG9iamVjdCBhbmQgdGhlIHBsdWdpbnMgbGlzdCAoZm9yIHJlZmxvd2luZylcbiAgICB0aGlzLl9wbHVnaW5zW2F0dHJOYW1lXSA9IHRoaXNbY2xhc3NOYW1lXSA9IHBsdWdpbjtcbiAgfSxcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBQb3B1bGF0ZXMgdGhlIF91dWlkcyBhcnJheSB3aXRoIHBvaW50ZXJzIHRvIGVhY2ggaW5kaXZpZHVhbCBwbHVnaW4gaW5zdGFuY2UuXG4gICAqIEFkZHMgdGhlIGB6ZlBsdWdpbmAgZGF0YS1hdHRyaWJ1dGUgdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGVkIHBsdWdpbnMgdG8gYWxsb3cgdXNlIG9mICQoc2VsZWN0b3IpLmZvdW5kYXRpb24obWV0aG9kKSBjYWxscy5cbiAgICogQWxzbyBmaXJlcyB0aGUgaW5pdGlhbGl6YXRpb24gZXZlbnQgZm9yIGVhY2ggcGx1Z2luLCBjb25zb2xpZGF0aW5nIHJlcGVkaXRpdmUgY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4sIHBhc3NlZCBhcyBhIGNhbWVsQ2FzZWQgc3RyaW5nLlxuICAgKiBAZmlyZXMgUGx1Z2luI2luaXRcbiAgICovXG4gIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbihwbHVnaW4sIG5hbWUpe1xuICAgIHZhciBwbHVnaW5OYW1lID0gbmFtZSA/IGh5cGhlbmF0ZShuYW1lKSA6IGZ1bmN0aW9uTmFtZShwbHVnaW4uY29uc3RydWN0b3IpLnRvTG93ZXJDYXNlKCk7XG4gICAgcGx1Z2luLnV1aWQgPSB0aGlzLkdldFlvRGlnaXRzKDYsIHBsdWdpbk5hbWUpO1xuXG4gICAgaWYoIXBsdWdpbi4kZWxlbWVudC5hdHRyKGBkYXRhLSR7cGx1Z2luTmFtZX1gKSl7IHBsdWdpbi4kZWxlbWVudC5hdHRyKGBkYXRhLSR7cGx1Z2luTmFtZX1gLCBwbHVnaW4udXVpZCk7IH1cbiAgICBpZighcGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykpeyBwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nLCBwbHVnaW4pOyB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBpbml0aWFsaXplZC5cbiAgICAgICAgICAgKiBAZXZlbnQgUGx1Z2luI2luaXRcbiAgICAgICAgICAgKi9cbiAgICBwbHVnaW4uJGVsZW1lbnQudHJpZ2dlcihgaW5pdC56Zi4ke3BsdWdpbk5hbWV9YCk7XG5cbiAgICB0aGlzLl91dWlkcy5wdXNoKHBsdWdpbi51dWlkKTtcblxuICAgIHJldHVybjtcbiAgfSxcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBSZW1vdmVzIHRoZSBwbHVnaW5zIHV1aWQgZnJvbSB0aGUgX3V1aWRzIGFycmF5LlxuICAgKiBSZW1vdmVzIHRoZSB6ZlBsdWdpbiBkYXRhIGF0dHJpYnV0ZSwgYXMgd2VsbCBhcyB0aGUgZGF0YS1wbHVnaW4tbmFtZSBhdHRyaWJ1dGUuXG4gICAqIEFsc28gZmlyZXMgdGhlIGRlc3Ryb3llZCBldmVudCBmb3IgdGhlIHBsdWdpbiwgY29uc29saWRhdGluZyByZXBlZGl0aXZlIGNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBhbiBpbnN0YW5jZSBvZiBhIHBsdWdpbiwgdXN1YWxseSBgdGhpc2AgaW4gY29udGV4dC5cbiAgICogQGZpcmVzIFBsdWdpbiNkZXN0cm95ZWRcbiAgICovXG4gIHVucmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uKHBsdWdpbil7XG4gICAgdmFyIHBsdWdpbk5hbWUgPSBoeXBoZW5hdGUoZnVuY3Rpb25OYW1lKHBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpLmNvbnN0cnVjdG9yKSk7XG5cbiAgICB0aGlzLl91dWlkcy5zcGxpY2UodGhpcy5fdXVpZHMuaW5kZXhPZihwbHVnaW4udXVpZCksIDEpO1xuICAgIHBsdWdpbi4kZWxlbWVudC5yZW1vdmVBdHRyKGBkYXRhLSR7cGx1Z2luTmFtZX1gKS5yZW1vdmVEYXRhKCd6ZlBsdWdpbicpXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBiZWVuIGRlc3Ryb3llZC5cbiAgICAgICAgICAgKiBAZXZlbnQgUGx1Z2luI2Rlc3Ryb3llZFxuICAgICAgICAgICAqL1xuICAgICAgICAgIC50cmlnZ2VyKGBkZXN0cm95ZWQuemYuJHtwbHVnaW5OYW1lfWApO1xuICAgIGZvcih2YXIgcHJvcCBpbiBwbHVnaW4pe1xuICAgICAgcGx1Z2luW3Byb3BdID0gbnVsbDsvL2NsZWFuIHVwIHNjcmlwdCB0byBwcmVwIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgfVxuICAgIHJldHVybjtcbiAgfSxcblxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIENhdXNlcyBvbmUgb3IgbW9yZSBhY3RpdmUgcGx1Z2lucyB0byByZS1pbml0aWFsaXplLCByZXNldHRpbmcgZXZlbnQgbGlzdGVuZXJzLCByZWNhbGN1bGF0aW5nIHBvc2l0aW9ucywgZXRjLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGx1Z2lucyAtIG9wdGlvbmFsIHN0cmluZyBvZiBhbiBpbmRpdmlkdWFsIHBsdWdpbiBrZXksIGF0dGFpbmVkIGJ5IGNhbGxpbmcgYCQoZWxlbWVudCkuZGF0YSgncGx1Z2luTmFtZScpYCwgb3Igc3RyaW5nIG9mIGEgcGx1Z2luIGNsYXNzIGkuZS4gYCdkcm9wZG93bidgXG4gICAqIEBkZWZhdWx0IElmIG5vIGFyZ3VtZW50IGlzIHBhc3NlZCwgcmVmbG93IGFsbCBjdXJyZW50bHkgYWN0aXZlIHBsdWdpbnMuXG4gICAqL1xuICAgcmVJbml0OiBmdW5jdGlvbihwbHVnaW5zKXtcbiAgICAgdmFyIGlzSlEgPSBwbHVnaW5zIGluc3RhbmNlb2YgJDtcbiAgICAgdHJ5e1xuICAgICAgIGlmKGlzSlEpe1xuICAgICAgICAgcGx1Z2lucy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICQodGhpcykuZGF0YSgnemZQbHVnaW4nKS5faW5pdCgpO1xuICAgICAgICAgfSk7XG4gICAgICAgfWVsc2V7XG4gICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBwbHVnaW5zLFxuICAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgZm5zID0ge1xuICAgICAgICAgICAnb2JqZWN0JzogZnVuY3Rpb24ocGxncyl7XG4gICAgICAgICAgICAgcGxncy5mb3JFYWNoKGZ1bmN0aW9uKHApe1xuICAgICAgICAgICAgICAgcCA9IGh5cGhlbmF0ZShwKTtcbiAgICAgICAgICAgICAgICQoJ1tkYXRhLScrIHAgKyddJykuZm91bmRhdGlvbignX2luaXQnKTtcbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgJ3N0cmluZyc6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgcGx1Z2lucyA9IGh5cGhlbmF0ZShwbHVnaW5zKTtcbiAgICAgICAgICAgICAkKCdbZGF0YS0nKyBwbHVnaW5zICsnXScpLmZvdW5kYXRpb24oJ19pbml0Jyk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgICd1bmRlZmluZWQnOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgIHRoaXNbJ29iamVjdCddKE9iamVjdC5rZXlzKF90aGlzLl9wbHVnaW5zKSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH07XG4gICAgICAgICBmbnNbdHlwZV0ocGx1Z2lucyk7XG4gICAgICAgfVxuICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgIH1maW5hbGx5e1xuICAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgICB9XG4gICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm5zIGEgcmFuZG9tIGJhc2UtMzYgdWlkIHdpdGggbmFtZXNwYWNpbmdcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBudW1iZXIgb2YgcmFuZG9tIGJhc2UtMzYgZGlnaXRzIGRlc2lyZWQuIEluY3JlYXNlIGZvciBtb3JlIHJhbmRvbSBzdHJpbmdzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIC0gbmFtZSBvZiBwbHVnaW4gdG8gYmUgaW5jb3Jwb3JhdGVkIGluIHVpZCwgb3B0aW9uYWwuXG4gICAqIEBkZWZhdWx0IHtTdHJpbmd9ICcnIC0gaWYgbm8gcGx1Z2luIG5hbWUgaXMgcHJvdmlkZWQsIG5vdGhpbmcgaXMgYXBwZW5kZWQgdG8gdGhlIHVpZC5cbiAgICogQHJldHVybnMge1N0cmluZ30gLSB1bmlxdWUgaWRcbiAgICovXG4gIEdldFlvRGlnaXRzOiBmdW5jdGlvbihsZW5ndGgsIG5hbWVzcGFjZSl7XG4gICAgbGVuZ3RoID0gbGVuZ3RoIHx8IDY7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKE1hdGgucG93KDM2LCBsZW5ndGggKyAxKSAtIE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygzNiwgbGVuZ3RoKSkpLnRvU3RyaW5nKDM2KS5zbGljZSgxKSArIChuYW1lc3BhY2UgPyBgLSR7bmFtZXNwYWNlfWAgOiAnJyk7XG4gIH0sXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHBsdWdpbnMgb24gYW55IGVsZW1lbnRzIHdpdGhpbiBgZWxlbWAgKGFuZCBgZWxlbWAgaXRzZWxmKSB0aGF0IGFyZW4ndCBhbHJlYWR5IGluaXRpYWxpemVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbSAtIGpRdWVyeSBvYmplY3QgY29udGFpbmluZyB0aGUgZWxlbWVudCB0byBjaGVjayBpbnNpZGUuIEFsc28gY2hlY2tzIHRoZSBlbGVtZW50IGl0c2VsZiwgdW5sZXNzIGl0J3MgdGhlIGBkb2N1bWVudGAgb2JqZWN0LlxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcGx1Z2lucyAtIEEgbGlzdCBvZiBwbHVnaW5zIHRvIGluaXRpYWxpemUuIExlYXZlIHRoaXMgb3V0IHRvIGluaXRpYWxpemUgZXZlcnl0aGluZy5cbiAgICovXG4gIHJlZmxvdzogZnVuY3Rpb24oZWxlbSwgcGx1Z2lucykge1xuXG4gICAgLy8gSWYgcGx1Z2lucyBpcyB1bmRlZmluZWQsIGp1c3QgZ3JhYiBldmVyeXRoaW5nXG4gICAgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcGx1Z2lucyA9IE9iamVjdC5rZXlzKHRoaXMuX3BsdWdpbnMpO1xuICAgIH1cbiAgICAvLyBJZiBwbHVnaW5zIGlzIGEgc3RyaW5nLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggb25lIGl0ZW1cbiAgICBlbHNlIGlmICh0eXBlb2YgcGx1Z2lucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBsdWdpbnMgPSBbcGx1Z2luc107XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHBsdWdpblxuICAgICQuZWFjaChwbHVnaW5zLCBmdW5jdGlvbihpLCBuYW1lKSB7XG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGx1Z2luXG4gICAgICB2YXIgcGx1Z2luID0gX3RoaXMuX3BsdWdpbnNbbmFtZV07XG5cbiAgICAgIC8vIExvY2FsaXplIHRoZSBzZWFyY2ggdG8gYWxsIGVsZW1lbnRzIGluc2lkZSBlbGVtLCBhcyB3ZWxsIGFzIGVsZW0gaXRzZWxmLCB1bmxlc3MgZWxlbSA9PT0gZG9jdW1lbnRcbiAgICAgIHZhciAkZWxlbSA9ICQoZWxlbSkuZmluZCgnW2RhdGEtJytuYW1lKyddJykuYWRkQmFjaygnW2RhdGEtJytuYW1lKyddJyk7XG5cbiAgICAgIC8vIEZvciBlYWNoIHBsdWdpbiBmb3VuZCwgaW5pdGlhbGl6ZSBpdFxuICAgICAgJGVsZW0uZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICRlbCA9ICQodGhpcyksXG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIC8vIERvbid0IGRvdWJsZS1kaXAgb24gcGx1Z2luc1xuICAgICAgICBpZiAoJGVsLmRhdGEoJ3pmUGx1Z2luJykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJUcmllZCB0byBpbml0aWFsaXplIFwiK25hbWUrXCIgb24gYW4gZWxlbWVudCB0aGF0IGFscmVhZHkgaGFzIGEgRm91bmRhdGlvbiBwbHVnaW4uXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCRlbC5hdHRyKCdkYXRhLW9wdGlvbnMnKSl7XG4gICAgICAgICAgdmFyIHRoaW5nID0gJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbihlLCBpKXtcbiAgICAgICAgICAgIHZhciBvcHQgPSBlLnNwbGl0KCc6JykubWFwKGZ1bmN0aW9uKGVsKXsgcmV0dXJuIGVsLnRyaW0oKTsgfSk7XG4gICAgICAgICAgICBpZihvcHRbMF0pIG9wdHNbb3B0WzBdXSA9IHBhcnNlVmFsdWUob3B0WzFdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cnl7XG4gICAgICAgICAgJGVsLmRhdGEoJ3pmUGx1Z2luJywgbmV3IHBsdWdpbigkKHRoaXMpLCBvcHRzKSk7XG4gICAgICAgIH1jYXRjaChlcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcik7XG4gICAgICAgIH1maW5hbGx5e1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIGdldEZuTmFtZTogZnVuY3Rpb25OYW1lLFxuICB0cmFuc2l0aW9uZW5kOiBmdW5jdGlvbigkZWxlbSl7XG4gICAgdmFyIHRyYW5zaXRpb25zID0ge1xuICAgICAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICdNb3pUcmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgJ09UcmFuc2l0aW9uJzogJ290cmFuc2l0aW9uZW5kJ1xuICAgIH07XG4gICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgZW5kO1xuXG4gICAgZm9yICh2YXIgdCBpbiB0cmFuc2l0aW9ucyl7XG4gICAgICBpZiAodHlwZW9mIGVsZW0uc3R5bGVbdF0gIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgZW5kID0gdHJhbnNpdGlvbnNbdF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGVuZCl7XG4gICAgICByZXR1cm4gZW5kO1xuICAgIH1lbHNle1xuICAgICAgZW5kID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAkZWxlbS50cmlnZ2VySGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIFskZWxlbV0pO1xuICAgICAgfSwgMSk7XG4gICAgICByZXR1cm4gJ3RyYW5zaXRpb25lbmQnO1xuICAgIH1cbiAgfVxufTtcblxuRm91bmRhdGlvbi51dGlsID0ge1xuICAvKipcbiAgICogRnVuY3Rpb24gZm9yIGFwcGx5aW5nIGEgZGVib3VuY2UgZWZmZWN0IHRvIGEgZnVuY3Rpb24gY2FsbC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYXQgZW5kIG9mIHRpbWVvdXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIFRpbWUgaW4gbXMgdG8gZGVsYXkgdGhlIGNhbGwgb2YgYGZ1bmNgLlxuICAgKiBAcmV0dXJucyBmdW5jdGlvblxuICAgKi9cbiAgdGhyb3R0bGU6IGZ1bmN0aW9uIChmdW5jLCBkZWxheSkge1xuICAgIHZhciB0aW1lciA9IG51bGw7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICBpZiAodGltZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbi8vIFRPRE86IGNvbnNpZGVyIG5vdCBtYWtpbmcgdGhpcyBhIGpRdWVyeSBmdW5jdGlvblxuLy8gVE9ETzogbmVlZCB3YXkgdG8gcmVmbG93IHZzLiByZS1pbml0aWFsaXplXG4vKipcbiAqIFRoZSBGb3VuZGF0aW9uIGpRdWVyeSBtZXRob2QuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gbWV0aG9kIC0gQW4gYWN0aW9uIHRvIHBlcmZvcm0gb24gdGhlIGN1cnJlbnQgalF1ZXJ5IG9iamVjdC5cbiAqL1xudmFyIGZvdW5kYXRpb24gPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgbWV0aG9kLFxuICAgICAgJG1ldGEgPSAkKCdtZXRhLmZvdW5kYXRpb24tbXEnKSxcbiAgICAgICRub0pTID0gJCgnLm5vLWpzJyk7XG5cbiAgaWYoISRtZXRhLmxlbmd0aCl7XG4gICAgJCgnPG1ldGEgY2xhc3M9XCJmb3VuZGF0aW9uLW1xXCI+JykuYXBwZW5kVG8oZG9jdW1lbnQuaGVhZCk7XG4gIH1cbiAgaWYoJG5vSlMubGVuZ3RoKXtcbiAgICAkbm9KUy5yZW1vdmVDbGFzcygnbm8tanMnKTtcbiAgfVxuXG4gIGlmKHR5cGUgPT09ICd1bmRlZmluZWQnKXsvL25lZWRzIHRvIGluaXRpYWxpemUgdGhlIEZvdW5kYXRpb24gb2JqZWN0LCBvciBhbiBpbmRpdmlkdWFsIHBsdWdpbi5cbiAgICBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuX2luaXQoKTtcbiAgICBGb3VuZGF0aW9uLnJlZmxvdyh0aGlzKTtcbiAgfWVsc2UgaWYodHlwZSA9PT0gJ3N0cmluZycpey8vYW4gaW5kaXZpZHVhbCBtZXRob2QgdG8gaW52b2tlIG9uIGEgcGx1Z2luIG9yIGdyb3VwIG9mIHBsdWdpbnNcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7Ly9jb2xsZWN0IGFsbCB0aGUgYXJndW1lbnRzLCBpZiBuZWNlc3NhcnlcbiAgICB2YXIgcGx1Z0NsYXNzID0gdGhpcy5kYXRhKCd6ZlBsdWdpbicpOy8vZGV0ZXJtaW5lIHRoZSBjbGFzcyBvZiBwbHVnaW5cblxuICAgIGlmKHBsdWdDbGFzcyAhPT0gdW5kZWZpbmVkICYmIHBsdWdDbGFzc1ttZXRob2RdICE9PSB1bmRlZmluZWQpey8vbWFrZSBzdXJlIGJvdGggdGhlIGNsYXNzIGFuZCBtZXRob2QgZXhpc3RcbiAgICAgIGlmKHRoaXMubGVuZ3RoID09PSAxKXsvL2lmIHRoZXJlJ3Mgb25seSBvbmUsIGNhbGwgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgcGx1Z0NsYXNzW21ldGhvZF0uYXBwbHkocGx1Z0NsYXNzLCBhcmdzKTtcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSwgZWwpey8vb3RoZXJ3aXNlIGxvb3AgdGhyb3VnaCB0aGUgalF1ZXJ5IGNvbGxlY3Rpb24gYW5kIGludm9rZSB0aGUgbWV0aG9kIG9uIGVhY2hcbiAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseSgkKGVsKS5kYXRhKCd6ZlBsdWdpbicpLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfWVsc2V7Ly9lcnJvciBmb3Igbm8gY2xhc3Mgb3Igbm8gbWV0aG9kXG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJXZSdyZSBzb3JyeSwgJ1wiICsgbWV0aG9kICsgXCInIGlzIG5vdCBhbiBhdmFpbGFibGUgbWV0aG9kIGZvciBcIiArIChwbHVnQ2xhc3MgPyBmdW5jdGlvbk5hbWUocGx1Z0NsYXNzKSA6ICd0aGlzIGVsZW1lbnQnKSArICcuJyk7XG4gICAgfVxuICB9ZWxzZXsvL2Vycm9yIGZvciBpbnZhbGlkIGFyZ3VtZW50IHR5cGVcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBXZSdyZSBzb3JyeSwgJHt0eXBlfSBpcyBub3QgYSB2YWxpZCBwYXJhbWV0ZXIuIFlvdSBtdXN0IHVzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG1ldGhvZCB5b3Ugd2lzaCB0byBpbnZva2UuYCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG53aW5kb3cuRm91bmRhdGlvbiA9IEZvdW5kYXRpb247XG4kLmZuLmZvdW5kYXRpb24gPSBmb3VuZGF0aW9uO1xuXG4vLyBQb2x5ZmlsbCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4oZnVuY3Rpb24oKSB7XG4gIGlmICghRGF0ZS5ub3cgfHwgIXdpbmRvdy5EYXRlLm5vdylcbiAgICB3aW5kb3cuRGF0ZS5ub3cgPSBEYXRlLm5vdyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG5cbiAgdmFyIHZlbmRvcnMgPSBbJ3dlYmtpdCcsICdtb3onXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKytpKSB7XG4gICAgICB2YXIgdnAgPSB2ZW5kb3JzW2ldO1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2cCsnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSAod2luZG93W3ZwKydDYW5jZWxBbmltYXRpb25GcmFtZSddXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3dbdnArJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddKTtcbiAgfVxuICBpZiAoL2lQKGFkfGhvbmV8b2QpLipPUyA2Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgIHx8ICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8ICF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIG5leHRUaW1lID0gTWF0aC5tYXgobGFzdFRpbWUgKyAxNiwgbm93KTtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGxhc3RUaW1lID0gbmV4dFRpbWUpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0VGltZSAtIG5vdyk7XG4gICAgfTtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjbGVhclRpbWVvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFBvbHlmaWxsIGZvciBwZXJmb3JtYW5jZS5ub3csIHJlcXVpcmVkIGJ5IHJBRlxuICAgKi9cbiAgaWYoIXdpbmRvdy5wZXJmb3JtYW5jZSB8fCAhd2luZG93LnBlcmZvcm1hbmNlLm5vdyl7XG4gICAgd2luZG93LnBlcmZvcm1hbmNlID0ge1xuICAgICAgc3RhcnQ6IERhdGUubm93KCksXG4gICAgICBub3c6IGZ1bmN0aW9uKCl7IHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zdGFydDsgfVxuICAgIH07XG4gIH1cbn0pKCk7XG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24ob1RoaXMpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNVxuICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYUFyZ3MgICA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgIGZUb0JpbmQgPSB0aGlzLFxuICAgICAgICBmTk9QICAgID0gZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgZkJvdW5kICA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QXG4gICAgICAgICAgICAgICAgID8gdGhpc1xuICAgICAgICAgICAgICAgICA6IG9UaGlzLFxuICAgICAgICAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuXG4gICAgaWYgKHRoaXMucHJvdG90eXBlKSB7XG4gICAgICAvLyBuYXRpdmUgZnVuY3Rpb25zIGRvbid0IGhhdmUgYSBwcm90b3R5cGVcbiAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG4gICAgfVxuICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xuXG4gICAgcmV0dXJuIGZCb3VuZDtcbiAgfTtcbn1cbi8vIFBvbHlmaWxsIHRvIGdldCB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIGluIElFOVxuZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGZuKSB7XG4gIGlmIChGdW5jdGlvbi5wcm90b3R5cGUubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZ1bmNOYW1lUmVnZXggPSAvZnVuY3Rpb25cXHMoW14oXXsxLH0pXFwoLztcbiAgICB2YXIgcmVzdWx0cyA9IChmdW5jTmFtZVJlZ2V4KS5leGVjKChmbikudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSkgPyByZXN1bHRzWzFdLnRyaW0oKSA6IFwiXCI7XG4gIH1cbiAgZWxzZSBpZiAoZm4ucHJvdG90eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZm4uY29uc3RydWN0b3IubmFtZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZm4ucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoc3RyKXtcbiAgaWYoL3RydWUvLnRlc3Qoc3RyKSkgcmV0dXJuIHRydWU7XG4gIGVsc2UgaWYoL2ZhbHNlLy50ZXN0KHN0cikpIHJldHVybiBmYWxzZTtcbiAgZWxzZSBpZighaXNOYU4oc3RyICogMSkpIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiBzdHI7XG59XG4vLyBDb252ZXJ0IFBhc2NhbENhc2UgdG8ga2ViYWItY2FzZVxuLy8gVGhhbmsgeW91OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84OTU1NTgwXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG5Gb3VuZGF0aW9uLkJveCA9IHtcbiAgSW1Ob3RUb3VjaGluZ1lvdTogSW1Ob3RUb3VjaGluZ1lvdSxcbiAgR2V0RGltZW5zaW9uczogR2V0RGltZW5zaW9ucyxcbiAgR2V0T2Zmc2V0czogR2V0T2Zmc2V0c1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHRoZSBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQgdG8gYSBjb250YWluZXIgYW5kIGRldGVybWluZXMgY29sbGlzaW9uIGV2ZW50cyB3aXRoIGNvbnRhaW5lci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHRlc3QgZm9yIGNvbGxpc2lvbnMuXG4gKiBAcGFyYW0ge2pRdWVyeX0gcGFyZW50IC0galF1ZXJ5IG9iamVjdCB0byB1c2UgYXMgYm91bmRpbmcgY29udGFpbmVyLlxuICogQHBhcmFtIHtCb29sZWFufSBsck9ubHkgLSBzZXQgdG8gdHJ1ZSB0byBjaGVjayBsZWZ0IGFuZCByaWdodCB2YWx1ZXMgb25seS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdGJPbmx5IC0gc2V0IHRvIHRydWUgdG8gY2hlY2sgdG9wIGFuZCBib3R0b20gdmFsdWVzIG9ubHkuXG4gKiBAZGVmYXVsdCBpZiBubyBwYXJlbnQgb2JqZWN0IHBhc3NlZCwgZGV0ZWN0cyBjb2xsaXNpb25zIHdpdGggYHdpbmRvd2AuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIGNvbGxpc2lvbiBmcmVlLCBmYWxzZSBpZiBhIGNvbGxpc2lvbiBpbiBhbnkgZGlyZWN0aW9uLlxuICovXG5mdW5jdGlvbiBJbU5vdFRvdWNoaW5nWW91KGVsZW1lbnQsIHBhcmVudCwgbHJPbmx5LCB0Yk9ubHkpIHtcbiAgdmFyIGVsZURpbXMgPSBHZXREaW1lbnNpb25zKGVsZW1lbnQpLFxuICAgICAgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0O1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB2YXIgcGFyRGltcyA9IEdldERpbWVuc2lvbnMocGFyZW50KTtcblxuICAgIGJvdHRvbSA9IChlbGVEaW1zLm9mZnNldC50b3AgKyBlbGVEaW1zLmhlaWdodCA8PSBwYXJEaW1zLmhlaWdodCArIHBhckRpbXMub2Zmc2V0LnRvcCk7XG4gICAgdG9wICAgID0gKGVsZURpbXMub2Zmc2V0LnRvcCA+PSBwYXJEaW1zLm9mZnNldC50b3ApO1xuICAgIGxlZnQgICA9IChlbGVEaW1zLm9mZnNldC5sZWZ0ID49IHBhckRpbXMub2Zmc2V0LmxlZnQpO1xuICAgIHJpZ2h0ICA9IChlbGVEaW1zLm9mZnNldC5sZWZ0ICsgZWxlRGltcy53aWR0aCA8PSBwYXJEaW1zLndpZHRoKTtcbiAgfVxuICBlbHNlIHtcbiAgICBib3R0b20gPSAoZWxlRGltcy5vZmZzZXQudG9wICsgZWxlRGltcy5oZWlnaHQgPD0gZWxlRGltcy53aW5kb3dEaW1zLmhlaWdodCArIGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wKTtcbiAgICB0b3AgICAgPSAoZWxlRGltcy5vZmZzZXQudG9wID49IGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wKTtcbiAgICBsZWZ0ICAgPSAoZWxlRGltcy5vZmZzZXQubGVmdCA+PSBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQpO1xuICAgIHJpZ2h0ICA9IChlbGVEaW1zLm9mZnNldC5sZWZ0ICsgZWxlRGltcy53aWR0aCA8PSBlbGVEaW1zLndpbmRvd0RpbXMud2lkdGgpO1xuICB9XG5cbiAgdmFyIGFsbERpcnMgPSBbYm90dG9tLCB0b3AsIGxlZnQsIHJpZ2h0XTtcblxuICBpZiAobHJPbmx5KSB7XG4gICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0ID09PSB0cnVlO1xuICB9XG5cbiAgaWYgKHRiT25seSkge1xuICAgIHJldHVybiB0b3AgPT09IGJvdHRvbSA9PT0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBhbGxEaXJzLmluZGV4T2YoZmFsc2UpID09PSAtMTtcbn07XG5cbi8qKlxuICogVXNlcyBuYXRpdmUgbWV0aG9kcyB0byByZXR1cm4gYW4gb2JqZWN0IG9mIGRpbWVuc2lvbiB2YWx1ZXMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7alF1ZXJ5IHx8IEhUTUx9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IG9yIERPTSBlbGVtZW50IGZvciB3aGljaCB0byBnZXQgdGhlIGRpbWVuc2lvbnMuIENhbiBiZSBhbnkgZWxlbWVudCBvdGhlciB0aGF0IGRvY3VtZW50IG9yIHdpbmRvdy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gbmVzdGVkIG9iamVjdCBvZiBpbnRlZ2VyIHBpeGVsIHZhbHVlc1xuICogVE9ETyAtIGlmIGVsZW1lbnQgaXMgd2luZG93LCByZXR1cm4gb25seSB0aG9zZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIEdldERpbWVuc2lvbnMoZWxlbSwgdGVzdCl7XG4gIGVsZW0gPSBlbGVtLmxlbmd0aCA/IGVsZW1bMF0gOiBlbGVtO1xuXG4gIGlmIChlbGVtID09PSB3aW5kb3cgfHwgZWxlbSA9PT0gZG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJJ20gc29ycnksIERhdmUuIEknbSBhZnJhaWQgSSBjYW4ndCBkbyB0aGF0LlwiKTtcbiAgfVxuXG4gIHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHBhclJlY3QgPSBlbGVtLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB3aW5SZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHdpblkgPSB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICB3aW5YID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICBvZmZzZXQ6IHtcbiAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5ZLFxuICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luWFxuICAgIH0sXG4gICAgcGFyZW50RGltczoge1xuICAgICAgd2lkdGg6IHBhclJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhclJlY3QuaGVpZ2h0LFxuICAgICAgb2Zmc2V0OiB7XG4gICAgICAgIHRvcDogcGFyUmVjdC50b3AgKyB3aW5ZLFxuICAgICAgICBsZWZ0OiBwYXJSZWN0LmxlZnQgKyB3aW5YXG4gICAgICB9XG4gICAgfSxcbiAgICB3aW5kb3dEaW1zOiB7XG4gICAgICB3aWR0aDogd2luUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogd2luUmVjdC5oZWlnaHQsXG4gICAgICBvZmZzZXQ6IHtcbiAgICAgICAgdG9wOiB3aW5ZLFxuICAgICAgICBsZWZ0OiB3aW5YXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2YgdG9wIGFuZCBsZWZ0IGludGVnZXIgcGl4ZWwgdmFsdWVzIGZvciBkeW5hbWljYWxseSByZW5kZXJlZCBlbGVtZW50cyxcbiAqIHN1Y2ggYXM6IFRvb2x0aXAsIFJldmVhbCwgYW5kIERyb3Bkb3duXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCBmb3IgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAqIEBwYXJhbSB7alF1ZXJ5fSBhbmNob3IgLSBqUXVlcnkgb2JqZWN0IGZvciB0aGUgZWxlbWVudCdzIGFuY2hvciBwb2ludC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbiAtIGEgc3RyaW5nIHJlbGF0aW5nIHRvIHRoZSBkZXNpcmVkIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LCByZWxhdGl2ZSB0byBpdCdzIGFuY2hvclxuICogQHBhcmFtIHtOdW1iZXJ9IHZPZmZzZXQgLSBpbnRlZ2VyIHBpeGVsIHZhbHVlIG9mIGRlc2lyZWQgdmVydGljYWwgc2VwYXJhdGlvbiBiZXR3ZWVuIGFuY2hvciBhbmQgZWxlbWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoT2Zmc2V0IC0gaW50ZWdlciBwaXhlbCB2YWx1ZSBvZiBkZXNpcmVkIGhvcml6b250YWwgc2VwYXJhdGlvbiBiZXR3ZWVuIGFuY2hvciBhbmQgZWxlbWVudC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPdmVyZmxvdyAtIGlmIGEgY29sbGlzaW9uIGV2ZW50IGlzIGRldGVjdGVkLCBzZXRzIHRvIHRydWUgdG8gZGVmYXVsdCB0aGUgZWxlbWVudCB0byBmdWxsIHdpZHRoIC0gYW55IGRlc2lyZWQgb2Zmc2V0LlxuICogVE9ETyBhbHRlci9yZXdyaXRlIHRvIHdvcmsgd2l0aCBgZW1gIHZhbHVlcyBhcyB3ZWxsL2luc3RlYWQgb2YgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIEdldE9mZnNldHMoZWxlbWVudCwgYW5jaG9yLCBwb3NpdGlvbiwgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdykge1xuICB2YXIgJGVsZURpbXMgPSBHZXREaW1lbnNpb25zKGVsZW1lbnQpLFxuICAgICAgJGFuY2hvckRpbXMgPSBhbmNob3IgPyBHZXREaW1lbnNpb25zKGFuY2hvcikgOiBudWxsO1xuXG4gIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogKEZvdW5kYXRpb24ucnRsKCkgPyAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICRlbGVEaW1zLndpZHRoICsgJGFuY2hvckRpbXMud2lkdGggOiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCksXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCAtICgkZWxlRGltcy5oZWlnaHQgKyB2T2Zmc2V0KVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICgkZWxlRGltcy53aWR0aCArIGhPZmZzZXQpLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3BcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggKyBoT2Zmc2V0LFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3BcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogKCRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgKCRhbmNob3JEaW1zLndpZHRoIC8gMikpIC0gKCRlbGVEaW1zLndpZHRoIC8gMiksXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCAtICgkZWxlRGltcy5oZWlnaHQgKyB2T2Zmc2V0KVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBpc092ZXJmbG93ID8gaE9mZnNldCA6ICgoJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAoJGFuY2hvckRpbXMud2lkdGggLyAyKSkgLSAoJGVsZURpbXMud2lkdGggLyAyKSksXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXRcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NlbnRlciBsZWZ0JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gKCRlbGVEaW1zLndpZHRoICsgaE9mZnNldCksXG4gICAgICAgIHRvcDogKCRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAoJGFuY2hvckRpbXMuaGVpZ2h0IC8gMikpIC0gKCRlbGVEaW1zLmhlaWdodCAvIDIpXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXIgcmlnaHQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAkYW5jaG9yRGltcy53aWR0aCArIGhPZmZzZXQgKyAxLFxuICAgICAgICB0b3A6ICgkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgKCRhbmNob3JEaW1zLmhlaWdodCAvIDIpKSAtICgkZWxlRGltcy5oZWlnaHQgLyAyKVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICgkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC5sZWZ0ICsgKCRlbGVEaW1zLndpbmRvd0RpbXMud2lkdGggLyAyKSkgLSAoJGVsZURpbXMud2lkdGggLyAyKSxcbiAgICAgICAgdG9wOiAoJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wICsgKCRlbGVEaW1zLndpbmRvd0RpbXMuaGVpZ2h0IC8gMikpIC0gKCRlbGVEaW1zLmhlaWdodCAvIDIpXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZXZlYWwnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogKCRlbGVEaW1zLndpbmRvd0RpbXMud2lkdGggLSAkZWxlRGltcy53aWR0aCkgLyAyLFxuICAgICAgICB0b3A6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCArIHZPZmZzZXRcbiAgICAgIH1cbiAgICBjYXNlICdyZXZlYWwgZnVsbCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC5sZWZ0LFxuICAgICAgICB0b3A6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcFxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCBib3R0b20nOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAoJGVsZURpbXMud2lkdGggKyBoT2Zmc2V0KSxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgJGFuY2hvckRpbXMuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQgYm90dG9tJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggKyBoT2Zmc2V0IC0gJGVsZURpbXMud2lkdGgsXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAoRm91bmRhdGlvbi5ydGwoKSA/ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gJGVsZURpbXMud2lkdGggKyAkYW5jaG9yRGltcy53aWR0aCA6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0KSxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgJGFuY2hvckRpbXMuaGVpZ2h0ICsgdk9mZnNldFxuICAgICAgfVxuICB9XG59XG5cbn0oalF1ZXJ5KTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogVGhpcyB1dGlsIHdhcyBjcmVhdGVkIGJ5IE1hcml1cyBPbGJlcnR6ICpcbiAqIFBsZWFzZSB0aGFuayBNYXJpdXMgb24gR2l0SHViIC9vd2xiZXJ0eiAqXG4gKiBvciB0aGUgd2ViIGh0dHA6Ly93d3cubWFyaXVzb2xiZXJ0ei5kZS8gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuY29uc3Qga2V5Q29kZXMgPSB7XG4gIDk6ICdUQUInLFxuICAxMzogJ0VOVEVSJyxcbiAgMjc6ICdFU0NBUEUnLFxuICAzMjogJ1NQQUNFJyxcbiAgMzc6ICdBUlJPV19MRUZUJyxcbiAgMzg6ICdBUlJPV19VUCcsXG4gIDM5OiAnQVJST1dfUklHSFQnLFxuICA0MDogJ0FSUk9XX0RPV04nXG59XG5cbnZhciBjb21tYW5kcyA9IHt9XG5cbnZhciBLZXlib2FyZCA9IHtcbiAga2V5czogZ2V0S2V5Q29kZXMoa2V5Q29kZXMpLFxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIChrZXlib2FyZCkgZXZlbnQgYW5kIHJldHVybnMgYSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIGl0cyBrZXlcbiAgICogQ2FuIGJlIHVzZWQgbGlrZSBGb3VuZGF0aW9uLnBhcnNlS2V5KGV2ZW50KSA9PT0gRm91bmRhdGlvbi5rZXlzLlNQQUNFXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGdlbmVyYXRlZCBieSB0aGUgZXZlbnQgaGFuZGxlclxuICAgKiBAcmV0dXJuIFN0cmluZyBrZXkgLSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBrZXkgcHJlc3NlZFxuICAgKi9cbiAgcGFyc2VLZXkoZXZlbnQpIHtcbiAgICB2YXIga2V5ID0ga2V5Q29kZXNbZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZV0gfHwgU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC53aGljaCkudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIGtleSA9IGBTSElGVF8ke2tleX1gO1xuICAgIGlmIChldmVudC5jdHJsS2V5KSBrZXkgPSBgQ1RSTF8ke2tleX1gO1xuICAgIGlmIChldmVudC5hbHRLZXkpIGtleSA9IGBBTFRfJHtrZXl9YDtcbiAgICByZXR1cm4ga2V5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiAoa2V5Ym9hcmQpIGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGdlbmVyYXRlZCBieSB0aGUgZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50IC0gRm91bmRhdGlvbiBjb21wb25lbnQncyBuYW1lLCBlLmcuIFNsaWRlciBvciBSZXZlYWxcbiAgICogQHBhcmFtIHtPYmplY3RzfSBmdW5jdGlvbnMgLSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSB0byBiZSBleGVjdXRlZFxuICAgKi9cbiAgaGFuZGxlS2V5KGV2ZW50LCBjb21wb25lbnQsIGZ1bmN0aW9ucykge1xuICAgIHZhciBjb21tYW5kTGlzdCA9IGNvbW1hbmRzW2NvbXBvbmVudF0sXG4gICAgICBrZXlDb2RlID0gdGhpcy5wYXJzZUtleShldmVudCksXG4gICAgICBjbWRzLFxuICAgICAgY29tbWFuZCxcbiAgICAgIGZuO1xuXG4gICAgaWYgKCFjb21tYW5kTGlzdCkgcmV0dXJuIGNvbnNvbGUud2FybignQ29tcG9uZW50IG5vdCBkZWZpbmVkIScpO1xuXG4gICAgaWYgKHR5cGVvZiBjb21tYW5kTGlzdC5sdHIgPT09ICd1bmRlZmluZWQnKSB7IC8vIHRoaXMgY29tcG9uZW50IGRvZXMgbm90IGRpZmZlcmVudGlhdGUgYmV0d2VlbiBsdHIgYW5kIHJ0bFxuICAgICAgICBjbWRzID0gY29tbWFuZExpc3Q7IC8vIHVzZSBwbGFpbiBsaXN0XG4gICAgfSBlbHNlIHsgLy8gbWVyZ2UgbHRyIGFuZCBydGw6IGlmIGRvY3VtZW50IGlzIHJ0bCwgcnRsIG92ZXJ3cml0ZXMgbHRyIGFuZCB2aWNlIHZlcnNhXG4gICAgICAgIGlmIChGb3VuZGF0aW9uLnJ0bCgpKSBjbWRzID0gJC5leHRlbmQoe30sIGNvbW1hbmRMaXN0Lmx0ciwgY29tbWFuZExpc3QucnRsKTtcblxuICAgICAgICBlbHNlIGNtZHMgPSAkLmV4dGVuZCh7fSwgY29tbWFuZExpc3QucnRsLCBjb21tYW5kTGlzdC5sdHIpO1xuICAgIH1cbiAgICBjb21tYW5kID0gY21kc1trZXlDb2RlXTtcblxuICAgIGZuID0gZnVuY3Rpb25zW2NvbW1hbmRdO1xuICAgIGlmIChmbiAmJiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHsgLy8gZXhlY3V0ZSBmdW5jdGlvbiAgaWYgZXhpc3RzXG4gICAgICBmbi5hcHBseSgpO1xuICAgICAgaWYgKGZ1bmN0aW9ucy5oYW5kbGVkIHx8IHR5cGVvZiBmdW5jdGlvbnMuaGFuZGxlZCA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBleGVjdXRlIGZ1bmN0aW9uIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWRcbiAgICAgICAgICBmdW5jdGlvbnMuaGFuZGxlZC5hcHBseSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZnVuY3Rpb25zLnVuaGFuZGxlZCB8fCB0eXBlb2YgZnVuY3Rpb25zLnVuaGFuZGxlZCA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBleGVjdXRlIGZ1bmN0aW9uIHdoZW4gZXZlbnQgd2FzIG5vdCBoYW5kbGVkXG4gICAgICAgICAgZnVuY3Rpb25zLnVuaGFuZGxlZC5hcHBseSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoaW4gdGhlIGdpdmVuIGAkZWxlbWVudGBcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBzZWFyY2ggd2l0aGluXG4gICAqIEByZXR1cm4ge2pRdWVyeX0gJGZvY3VzYWJsZSAtIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIGAkZWxlbWVudGBcbiAgICovXG4gIGZpbmRGb2N1c2FibGUoJGVsZW1lbnQpIHtcbiAgICByZXR1cm4gJGVsZW1lbnQuZmluZCgnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgKlt0YWJpbmRleF0sICpbY29udGVudGVkaXRhYmxlXScpLmZpbHRlcihmdW5jdGlvbigpIHtcbiAgICAgIGlmICghJCh0aGlzKS5pcygnOnZpc2libGUnKSB8fCAkKHRoaXMpLmF0dHIoJ3RhYmluZGV4JykgPCAwKSB7IHJldHVybiBmYWxzZTsgfSAvL29ubHkgaGF2ZSB2aXNpYmxlIGVsZW1lbnRzIGFuZCB0aG9zZSB0aGF0IGhhdmUgYSB0YWJpbmRleCBncmVhdGVyIG9yIGVxdWFsIDBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgbmFtZSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgLSBGb3VuZGF0aW9uIGNvbXBvbmVudCwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXG4gICAqIEByZXR1cm4gU3RyaW5nIGNvbXBvbmVudE5hbWVcbiAgICovXG5cbiAgcmVnaXN0ZXIoY29tcG9uZW50TmFtZSwgY21kcykge1xuICAgIGNvbW1hbmRzW2NvbXBvbmVudE5hbWVdID0gY21kcztcbiAgfVxufVxuXG4vKlxuICogQ29uc3RhbnRzIGZvciBlYXNpZXIgY29tcGFyaW5nLlxuICogQ2FuIGJlIHVzZWQgbGlrZSBGb3VuZGF0aW9uLnBhcnNlS2V5KGV2ZW50KSA9PT0gRm91bmRhdGlvbi5rZXlzLlNQQUNFXG4gKi9cbmZ1bmN0aW9uIGdldEtleUNvZGVzKGtjcykge1xuICB2YXIgayA9IHt9O1xuICBmb3IgKHZhciBrYyBpbiBrY3MpIGtba2NzW2tjXV0gPSBrY3Nba2NdO1xuICByZXR1cm4gaztcbn1cblxuRm91bmRhdGlvbi5LZXlib2FyZCA9IEtleWJvYXJkO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8vIERlZmF1bHQgc2V0IG9mIG1lZGlhIHF1ZXJpZXNcbmNvbnN0IGRlZmF1bHRRdWVyaWVzID0ge1xuICAnZGVmYXVsdCcgOiAnb25seSBzY3JlZW4nLFxuICBsYW5kc2NhcGUgOiAnb25seSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKScsXG4gIHBvcnRyYWl0IDogJ29ubHkgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KScsXG4gIHJldGluYSA6ICdvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMiksJyArXG4gICAgJ29ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyLzEpLCcgK1xuICAgICdvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCcgK1xuICAgICdvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxOTJkcGkpLCcgK1xuICAgICdvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweCknXG59O1xuXG52YXIgTWVkaWFRdWVyeSA9IHtcbiAgcXVlcmllczogW10sXG5cbiAgY3VycmVudDogJycsXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtZWRpYSBxdWVyeSBoZWxwZXIsIGJ5IGV4dHJhY3RpbmcgdGhlIGJyZWFrcG9pbnQgbGlzdCBmcm9tIHRoZSBDU1MgYW5kIGFjdGl2YXRpbmcgdGhlIGJyZWFrcG9pbnQgd2F0Y2hlci5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGV4dHJhY3RlZFN0eWxlcyA9ICQoJy5mb3VuZGF0aW9uLW1xJykuY3NzKCdmb250LWZhbWlseScpO1xuICAgIHZhciBuYW1lZFF1ZXJpZXM7XG5cbiAgICBuYW1lZFF1ZXJpZXMgPSBwYXJzZVN0eWxlVG9PYmplY3QoZXh0cmFjdGVkU3R5bGVzKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBuYW1lZFF1ZXJpZXMpIHtcbiAgICAgIHNlbGYucXVlcmllcy5wdXNoKHtcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICB2YWx1ZTogYG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAke25hbWVkUXVlcmllc1trZXldfSlgXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLl9nZXRDdXJyZW50U2l6ZSgpO1xuXG4gICAgdGhpcy5fd2F0Y2hlcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHNjcmVlbiBpcyBhdCBsZWFzdCBhcyB3aWRlIGFzIGEgYnJlYWtwb2ludC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYnJlYWtwb2ludCBtYXRjaGVzLCBgZmFsc2VgIGlmIGl0J3Mgc21hbGxlci5cbiAgICovXG4gIGF0TGVhc3Qoc2l6ZSkge1xuICAgIHZhciBxdWVyeSA9IHRoaXMuZ2V0KHNpemUpO1xuXG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpLm1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtZWRpYSBxdWVyeSBvZiBhIGJyZWFrcG9pbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IC0gVGhlIG1lZGlhIHF1ZXJ5IG9mIHRoZSBicmVha3BvaW50LCBvciBgbnVsbGAgaWYgdGhlIGJyZWFrcG9pbnQgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGdldChzaXplKSB7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLnF1ZXJpZXMpIHtcbiAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcmllc1tpXTtcbiAgICAgIGlmIChzaXplID09PSBxdWVyeS5uYW1lKSByZXR1cm4gcXVlcnkudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCBuYW1lIGJ5IHRlc3RpbmcgZXZlcnkgYnJlYWtwb2ludCBhbmQgcmV0dXJuaW5nIHRoZSBsYXN0IG9uZSB0byBtYXRjaCAodGhlIGJpZ2dlc3Qgb25lKS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGN1cnJlbnQgYnJlYWtwb2ludC5cbiAgICovXG4gIF9nZXRDdXJyZW50U2l6ZSgpIHtcbiAgICB2YXIgbWF0Y2hlZDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWVyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJpZXNbaV07XG5cbiAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYShxdWVyeS52YWx1ZSkubWF0Y2hlcykge1xuICAgICAgICBtYXRjaGVkID0gcXVlcnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtYXRjaGVkID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG1hdGNoZWQubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGJyZWFrcG9pbnQgd2F0Y2hlciwgd2hpY2ggZmlyZXMgYW4gZXZlbnQgb24gdGhlIHdpbmRvdyB3aGVuZXZlciB0aGUgYnJlYWtwb2ludCBjaGFuZ2VzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93YXRjaGVyKCkge1xuICAgICQod2luZG93KS5vbigncmVzaXplLnpmLm1lZGlhcXVlcnknLCAoKSA9PiB7XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuX2dldEN1cnJlbnRTaXplKCk7XG5cbiAgICAgIGlmIChuZXdTaXplICE9PSB0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gQnJvYWRjYXN0IHRoZSBtZWRpYSBxdWVyeSBjaGFuZ2Ugb24gdGhlIHdpbmRvd1xuICAgICAgICAkKHdpbmRvdykudHJpZ2dlcignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgW25ld1NpemUsIHRoaXMuY3VycmVudF0pO1xuXG4gICAgICAgIC8vIENoYW5nZSB0aGUgY3VycmVudCBtZWRpYSBxdWVyeVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXdTaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5Gb3VuZGF0aW9uLk1lZGlhUXVlcnkgPSBNZWRpYVF1ZXJ5O1xuXG4vLyBtYXRjaE1lZGlhKCkgcG9seWZpbGwgLSBUZXN0IGEgQ1NTIG1lZGlhIHR5cGUvcXVlcnkgaW4gSlMuXG4vLyBBdXRob3JzICYgY29weXJpZ2h0IChjKSAyMDEyOiBTY290dCBKZWhsLCBQYXVsIElyaXNoLCBOaWNob2xhcyBaYWthcywgRGF2aWQgS25pZ2h0LiBEdWFsIE1JVC9CU0QgbGljZW5zZVxud2luZG93Lm1hdGNoTWVkaWEgfHwgKHdpbmRvdy5tYXRjaE1lZGlhID0gZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IG1hdGNoTWVkaXVtIGFwaSBzdWNoIGFzIElFIDkgYW5kIHdlYmtpdFxuICB2YXIgc3R5bGVNZWRpYSA9ICh3aW5kb3cuc3R5bGVNZWRpYSB8fCB3aW5kb3cubWVkaWEpO1xuXG4gIC8vIEZvciB0aG9zZSB0aGF0IGRvbid0IHN1cHBvcnQgbWF0Y2hNZWRpdW1cbiAgaWYgKCFzdHlsZU1lZGlhKSB7XG4gICAgdmFyIHN0eWxlICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpLFxuICAgIHNjcmlwdCAgICAgID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdLFxuICAgIGluZm8gICAgICAgID0gbnVsbDtcblxuICAgIHN0eWxlLnR5cGUgID0gJ3RleHQvY3NzJztcbiAgICBzdHlsZS5pZCAgICA9ICdtYXRjaG1lZGlhanMtdGVzdCc7XG5cbiAgICBzY3JpcHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIHNjcmlwdCk7XG5cbiAgICAvLyAnc3R5bGUuY3VycmVudFN0eWxlJyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICd3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZScgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuICAgIGluZm8gPSAoJ2dldENvbXB1dGVkU3R5bGUnIGluIHdpbmRvdykgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3R5bGUsIG51bGwpIHx8IHN0eWxlLmN1cnJlbnRTdHlsZTtcblxuICAgIHN0eWxlTWVkaWEgPSB7XG4gICAgICBtYXRjaE1lZGl1bShtZWRpYSkge1xuICAgICAgICB2YXIgdGV4dCA9IGBAbWVkaWEgJHttZWRpYX17ICNtYXRjaG1lZGlhanMtdGVzdCB7IHdpZHRoOiAxcHg7IH0gfWA7XG5cbiAgICAgICAgLy8gJ3N0eWxlLnN0eWxlU2hlZXQnIGlzIHVzZWQgYnkgSUUgPD0gOCBhbmQgJ3N0eWxlLnRleHRDb250ZW50JyBmb3IgYWxsIG90aGVyIGJyb3dzZXJzXG4gICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXN0IGlmIG1lZGlhIHF1ZXJ5IGlzIHRydWUgb3IgZmFsc2VcbiAgICAgICAgcmV0dXJuIGluZm8ud2lkdGggPT09ICcxcHgnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihtZWRpYSkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaGVzOiBzdHlsZU1lZGlhLm1hdGNoTWVkaXVtKG1lZGlhIHx8ICdhbGwnKSxcbiAgICAgIG1lZGlhOiBtZWRpYSB8fCAnYWxsJ1xuICAgIH07XG4gIH1cbn0oKSk7XG5cbi8vIFRoYW5rIHlvdTogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmdcbmZ1bmN0aW9uIHBhcnNlU3R5bGVUb09iamVjdChzdHIpIHtcbiAgdmFyIHN0eWxlT2JqZWN0ID0ge307XG5cbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG5cbiAgc3RyID0gc3RyLnRyaW0oKS5zbGljZSgxLCAtMSk7IC8vIGJyb3dzZXJzIHJlLXF1b3RlIHN0cmluZyBzdHlsZSB2YWx1ZXNcblxuICBpZiAoIXN0cikge1xuICAgIHJldHVybiBzdHlsZU9iamVjdDtcbiAgfVxuXG4gIHN0eWxlT2JqZWN0ID0gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uKHJldCwgcGFyYW0pIHtcbiAgICB2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuICAgIHZhciBrZXkgPSBwYXJ0c1swXTtcbiAgICB2YXIgdmFsID0gcGFydHNbMV07XG4gICAga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7XG5cbiAgICAvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuICAgIC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcbiAgICB2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcblxuICAgIGlmICghcmV0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldFtrZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcbiAgICAgIHJldFtrZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gc3R5bGVPYmplY3Q7XG59XG5cbkZvdW5kYXRpb24uTWVkaWFRdWVyeSA9IE1lZGlhUXVlcnk7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLyoqXG4gKiBNb3Rpb24gbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm1vdGlvblxuICovXG5cbmNvbnN0IGluaXRDbGFzc2VzICAgPSBbJ211aS1lbnRlcicsICdtdWktbGVhdmUnXTtcbmNvbnN0IGFjdGl2ZUNsYXNzZXMgPSBbJ211aS1lbnRlci1hY3RpdmUnLCAnbXVpLWxlYXZlLWFjdGl2ZSddO1xuXG5jb25zdCBNb3Rpb24gPSB7XG4gIGFuaW1hdGVJbjogZnVuY3Rpb24oZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICAgIGFuaW1hdGUodHJ1ZSwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYik7XG4gIH0sXG5cbiAgYW5pbWF0ZU91dDogZnVuY3Rpb24oZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICAgIGFuaW1hdGUoZmFsc2UsIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIE1vdmUoZHVyYXRpb24sIGVsZW0sIGZuKXtcbiAgdmFyIGFuaW0sIHByb2csIHN0YXJ0ID0gbnVsbDtcbiAgLy8gY29uc29sZS5sb2coJ2NhbGxlZCcpO1xuXG4gIGZ1bmN0aW9uIG1vdmUodHMpe1xuICAgIGlmKCFzdGFydCkgc3RhcnQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy8gY29uc29sZS5sb2coc3RhcnQsIHRzKTtcbiAgICBwcm9nID0gdHMgLSBzdGFydDtcbiAgICBmbi5hcHBseShlbGVtKTtcblxuICAgIGlmKHByb2cgPCBkdXJhdGlvbil7IGFuaW0gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdmUsIGVsZW0pOyB9XG4gICAgZWxzZXtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltKTtcbiAgICAgIGVsZW0udHJpZ2dlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSkudHJpZ2dlckhhbmRsZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pO1xuICAgIH1cbiAgfVxuICBhbmltID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtb3ZlKTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyBhbiBlbGVtZW50IGluIG9yIG91dCB1c2luZyBhIENTUyB0cmFuc2l0aW9uIGNsYXNzLlxuICogQGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCb29sZWFufSBpc0luIC0gRGVmaW5lcyBpZiB0aGUgYW5pbWF0aW9uIGlzIGluIG9yIG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9yIEhUTUwgb2JqZWN0IHRvIGFuaW1hdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gYW5pbWF0aW9uIC0gQ1NTIGNsYXNzIHRvIHVzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gQ2FsbGJhY2sgdG8gcnVuIHdoZW4gYW5pbWF0aW9uIGlzIGZpbmlzaGVkLlxuICovXG5mdW5jdGlvbiBhbmltYXRlKGlzSW4sIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcbiAgZWxlbWVudCA9ICQoZWxlbWVudCkuZXEoMCk7XG5cbiAgaWYgKCFlbGVtZW50Lmxlbmd0aCkgcmV0dXJuO1xuXG4gIHZhciBpbml0Q2xhc3MgPSBpc0luID8gaW5pdENsYXNzZXNbMF0gOiBpbml0Q2xhc3Nlc1sxXTtcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNJbiA/IGFjdGl2ZUNsYXNzZXNbMF0gOiBhY3RpdmVDbGFzc2VzWzFdO1xuXG4gIC8vIFNldCB1cCB0aGUgYW5pbWF0aW9uXG4gIHJlc2V0KCk7XG5cbiAgZWxlbWVudFxuICAgIC5hZGRDbGFzcyhhbmltYXRpb24pXG4gICAgLmNzcygndHJhbnNpdGlvbicsICdub25lJyk7XG5cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBlbGVtZW50LmFkZENsYXNzKGluaXRDbGFzcyk7XG4gICAgaWYgKGlzSW4pIGVsZW1lbnQuc2hvdygpO1xuICB9KTtcblxuICAvLyBTdGFydCB0aGUgYW5pbWF0aW9uXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgZWxlbWVudFswXS5vZmZzZXRXaWR0aDtcbiAgICBlbGVtZW50XG4gICAgICAuY3NzKCd0cmFuc2l0aW9uJywgJycpXG4gICAgICAuYWRkQ2xhc3MoYWN0aXZlQ2xhc3MpO1xuICB9KTtcblxuICAvLyBDbGVhbiB1cCB0aGUgYW5pbWF0aW9uIHdoZW4gaXQgZmluaXNoZXNcbiAgZWxlbWVudC5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKGVsZW1lbnQpLCBmaW5pc2gpO1xuXG4gIC8vIEhpZGVzIHRoZSBlbGVtZW50IChmb3Igb3V0IGFuaW1hdGlvbnMpLCByZXNldHMgdGhlIGVsZW1lbnQsIGFuZCBydW5zIGEgY2FsbGJhY2tcbiAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIGlmICghaXNJbikgZWxlbWVudC5oaWRlKCk7XG4gICAgcmVzZXQoKTtcbiAgICBpZiAoY2IpIGNiLmFwcGx5KGVsZW1lbnQpO1xuICB9XG5cbiAgLy8gUmVzZXRzIHRyYW5zaXRpb25zIGFuZCByZW1vdmVzIG1vdGlvbi1zcGVjaWZpYyBjbGFzc2VzXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGVsZW1lbnRbMF0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gMDtcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGAke2luaXRDbGFzc30gJHthY3RpdmVDbGFzc30gJHthbmltYXRpb259YCk7XG4gIH1cbn1cblxuRm91bmRhdGlvbi5Nb3ZlID0gTW92ZTtcbkZvdW5kYXRpb24uTW90aW9uID0gTW90aW9uO1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbmNvbnN0IE5lc3QgPSB7XG4gIEZlYXRoZXIobWVudSwgdHlwZSA9ICd6ZicpIHtcbiAgICBtZW51LmF0dHIoJ3JvbGUnLCAnbWVudWJhcicpO1xuXG4gICAgdmFyIGl0ZW1zID0gbWVudS5maW5kKCdsaScpLmF0dHIoeydyb2xlJzogJ21lbnVpdGVtJ30pLFxuICAgICAgICBzdWJNZW51Q2xhc3MgPSBgaXMtJHt0eXBlfS1zdWJtZW51YCxcbiAgICAgICAgc3ViSXRlbUNsYXNzID0gYCR7c3ViTWVudUNsYXNzfS1pdGVtYCxcbiAgICAgICAgaGFzU3ViQ2xhc3MgPSBgaXMtJHt0eXBlfS1zdWJtZW51LXBhcmVudGA7XG5cbiAgICBtZW51LmZpbmQoJ2E6Zmlyc3QnKS5hdHRyKCd0YWJpbmRleCcsIDApO1xuXG4gICAgaXRlbXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciAkaXRlbSA9ICQodGhpcyksXG4gICAgICAgICAgJHN1YiA9ICRpdGVtLmNoaWxkcmVuKCd1bCcpO1xuXG4gICAgICBpZiAoJHN1Yi5sZW5ndGgpIHtcbiAgICAgICAgJGl0ZW1cbiAgICAgICAgICAuYWRkQ2xhc3MoaGFzU3ViQ2xhc3MpXG4gICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxuICAgICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICdhcmlhLWxhYmVsJzogJGl0ZW0uY2hpbGRyZW4oJ2E6Zmlyc3QnKS50ZXh0KClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAkc3ViXG4gICAgICAgICAgLmFkZENsYXNzKGBzdWJtZW51ICR7c3ViTWVudUNsYXNzfWApXG4gICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgJ2RhdGEtc3VibWVudSc6ICcnLFxuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAgICdyb2xlJzogJ21lbnUnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgkaXRlbS5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKSB7XG4gICAgICAgICRpdGVtLmFkZENsYXNzKGBpcy1zdWJtZW51LWl0ZW0gJHtzdWJJdGVtQ2xhc3N9YCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH0sXG5cbiAgQnVybihtZW51LCB0eXBlKSB7XG4gICAgdmFyIGl0ZW1zID0gbWVudS5maW5kKCdsaScpLnJlbW92ZUF0dHIoJ3RhYmluZGV4JyksXG4gICAgICAgIHN1Yk1lbnVDbGFzcyA9IGBpcy0ke3R5cGV9LXN1Ym1lbnVgLFxuICAgICAgICBzdWJJdGVtQ2xhc3MgPSBgJHtzdWJNZW51Q2xhc3N9LWl0ZW1gLFxuICAgICAgICBoYXNTdWJDbGFzcyA9IGBpcy0ke3R5cGV9LXN1Ym1lbnUtcGFyZW50YDtcblxuICAgIG1lbnVcbiAgICAgIC5maW5kKCcqJylcbiAgICAgIC5yZW1vdmVDbGFzcyhgJHtzdWJNZW51Q2xhc3N9ICR7c3ViSXRlbUNsYXNzfSAke2hhc1N1YkNsYXNzfSBpcy1zdWJtZW51LWl0ZW0gc3VibWVudSBpcy1hY3RpdmVgKVxuICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtc3VibWVudScpLmNzcygnZGlzcGxheScsICcnKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCAgICAgIG1lbnUuZmluZCgnLicgKyBzdWJNZW51Q2xhc3MgKyAnLCAuJyArIHN1Ykl0ZW1DbGFzcyArICcsIC5oYXMtc3VibWVudSwgLmlzLXN1Ym1lbnUtaXRlbSwgLnN1Ym1lbnUsIFtkYXRhLXN1Ym1lbnVdJylcbiAgICAvLyAgICAgICAgICAgLnJlbW92ZUNsYXNzKHN1Yk1lbnVDbGFzcyArICcgJyArIHN1Ykl0ZW1DbGFzcyArICcgaGFzLXN1Ym1lbnUgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUnKVxuICAgIC8vICAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51JykpO1xuICAgIC8vIGl0ZW1zLmVhY2goZnVuY3Rpb24oKXtcbiAgICAvLyAgIHZhciAkaXRlbSA9ICQodGhpcyksXG4gICAgLy8gICAgICAgJHN1YiA9ICRpdGVtLmNoaWxkcmVuKCd1bCcpO1xuICAgIC8vICAgaWYoJGl0ZW0ucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCl7XG4gICAgLy8gICAgICRpdGVtLnJlbW92ZUNsYXNzKCdpcy1zdWJtZW51LWl0ZW0gJyArIHN1Ykl0ZW1DbGFzcyk7XG4gICAgLy8gICB9XG4gICAgLy8gICBpZigkc3ViLmxlbmd0aCl7XG4gICAgLy8gICAgICRpdGVtLnJlbW92ZUNsYXNzKCdoYXMtc3VibWVudScpO1xuICAgIC8vICAgICAkc3ViLnJlbW92ZUNsYXNzKCdzdWJtZW51ICcgKyBzdWJNZW51Q2xhc3MpLnJlbW92ZUF0dHIoJ2RhdGEtc3VibWVudScpO1xuICAgIC8vICAgfVxuICAgIC8vIH0pO1xuICB9XG59XG5cbkZvdW5kYXRpb24uTmVzdCA9IE5lc3Q7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuZnVuY3Rpb24gVGltZXIoZWxlbSwgb3B0aW9ucywgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiwvL29wdGlvbnMgaXMgYW4gb2JqZWN0IGZvciBlYXNpbHkgYWRkaW5nIGZlYXR1cmVzIGxhdGVyLlxuICAgICAgbmFtZVNwYWNlID0gT2JqZWN0LmtleXMoZWxlbS5kYXRhKCkpWzBdIHx8ICd0aW1lcicsXG4gICAgICByZW1haW4gPSAtMSxcbiAgICAgIHN0YXJ0LFxuICAgICAgdGltZXI7XG5cbiAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gIHRoaXMucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHJlbWFpbiA9IC0xO1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9XG5cbiAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAvLyBpZighZWxlbS5kYXRhKCdwYXVzZWQnKSl7IHJldHVybiBmYWxzZTsgfS8vbWF5YmUgaW1wbGVtZW50IHRoaXMgc2FuaXR5IGNoZWNrIGlmIHVzZWQgZm9yIG90aGVyIHRoaW5ncy5cbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHJlbWFpbiA9IHJlbWFpbiA8PSAwID8gZHVyYXRpb24gOiByZW1haW47XG4gICAgZWxlbS5kYXRhKCdwYXVzZWQnLCBmYWxzZSk7XG4gICAgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgaWYob3B0aW9ucy5pbmZpbml0ZSl7XG4gICAgICAgIF90aGlzLnJlc3RhcnQoKTsvL3JlcnVuIHRoZSB0aW1lci5cbiAgICAgIH1cbiAgICAgIGNiKCk7XG4gICAgfSwgcmVtYWluKTtcbiAgICBlbGVtLnRyaWdnZXIoYHRpbWVyc3RhcnQuemYuJHtuYW1lU3BhY2V9YCk7XG4gIH1cblxuICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgLy9pZihlbGVtLmRhdGEoJ3BhdXNlZCcpKXsgcmV0dXJuIGZhbHNlOyB9Ly9tYXliZSBpbXBsZW1lbnQgdGhpcyBzYW5pdHkgY2hlY2sgaWYgdXNlZCBmb3Igb3RoZXIgdGhpbmdzLlxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgZWxlbS5kYXRhKCdwYXVzZWQnLCB0cnVlKTtcbiAgICB2YXIgZW5kID0gRGF0ZS5ub3coKTtcbiAgICByZW1haW4gPSByZW1haW4gLSAoZW5kIC0gc3RhcnQpO1xuICAgIGVsZW0udHJpZ2dlcihgdGltZXJwYXVzZWQuemYuJHtuYW1lU3BhY2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSdW5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBpbWFnZXMgYXJlIGZ1bGx5IGxvYWRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZXMgLSBJbWFnZShzKSB0byBjaGVjayBpZiBsb2FkZWQuXG4gKiBAcGFyYW0ge0Z1bmN9IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGltYWdlIGlzIGZ1bGx5IGxvYWRlZC5cbiAqL1xuZnVuY3Rpb24gb25JbWFnZXNMb2FkZWQoaW1hZ2VzLCBjYWxsYmFjayl7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHVubG9hZGVkID0gaW1hZ2VzLmxlbmd0aDtcblxuICBpZiAodW5sb2FkZWQgPT09IDApIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgaW1hZ2VzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29tcGxldGUpIHtcbiAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLm5hdHVyYWxXaWR0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5uYXR1cmFsV2lkdGggPiAwKSB7XG4gICAgICBzaW5nbGVJbWFnZUxvYWRlZCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICQodGhpcykub25lKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHNpbmdsZUltYWdlTG9hZGVkKCkge1xuICAgIHVubG9hZGVkLS07XG4gICAgaWYgKHVubG9hZGVkID09PSAwKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxufVxuXG5Gb3VuZGF0aW9uLlRpbWVyID0gVGltZXI7XG5Gb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkID0gb25JbWFnZXNMb2FkZWQ7XG5cbn0oalF1ZXJ5KTtcbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vKipXb3JrIGluc3BpcmVkIGJ5IG11bHRpcGxlIGpxdWVyeSBzd2lwZSBwbHVnaW5zKipcbi8vKipEb25lIGJ5IFlvaGFpIEFyYXJhdCAqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbihmdW5jdGlvbigkKSB7XG5cbiAgJC5zcG90U3dpcGUgPSB7XG4gICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICBlbmFibGVkOiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuICAgIG1vdmVUaHJlc2hvbGQ6IDc1LFxuICAgIHRpbWVUaHJlc2hvbGQ6IDIwMFxuICB9O1xuXG4gIHZhciAgIHN0YXJ0UG9zWCxcbiAgICAgICAgc3RhcnRQb3NZLFxuICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgIGVsYXBzZWRUaW1lLFxuICAgICAgICBpc01vdmluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVG91Y2hFbmQoKSB7XG4gICAgLy8gIGFsZXJ0KHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcbiAgICBpc01vdmluZyA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoZSkge1xuICAgIGlmICgkLnNwb3RTd2lwZS5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICBpZihpc01vdmluZykge1xuICAgICAgdmFyIHggPSBlLnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICB2YXIgeSA9IGUudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgIHZhciBkeCA9IHN0YXJ0UG9zWCAtIHg7XG4gICAgICB2YXIgZHkgPSBzdGFydFBvc1kgLSB5O1xuICAgICAgdmFyIGRpcjtcbiAgICAgIGVsYXBzZWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWU7XG4gICAgICBpZihNYXRoLmFicyhkeCkgPj0gJC5zcG90U3dpcGUubW92ZVRocmVzaG9sZCAmJiBlbGFwc2VkVGltZSA8PSAkLnNwb3RTd2lwZS50aW1lVGhyZXNob2xkKSB7XG4gICAgICAgIGRpciA9IGR4ID4gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICB9XG4gICAgICAvLyBlbHNlIGlmKE1hdGguYWJzKGR5KSA+PSAkLnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkICYmIGVsYXBzZWRUaW1lIDw9ICQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQpIHtcbiAgICAgIC8vICAgZGlyID0gZHkgPiAwID8gJ2Rvd24nIDogJ3VwJztcbiAgICAgIC8vIH1cbiAgICAgIGlmKGRpcikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9uVG91Y2hFbmQuY2FsbCh0aGlzKTtcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdzd2lwZScsIGRpcikudHJpZ2dlcihgc3dpcGUke2Rpcn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgIHN0YXJ0UG9zWCA9IGUudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgIHN0YXJ0UG9zWSA9IGUudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgIGlzTW92aW5nID0gdHJ1ZTtcbiAgICAgIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlYXJkb3duKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCk7XG4gIH1cblxuICAkLmV2ZW50LnNwZWNpYWwuc3dpcGUgPSB7IHNldHVwOiBpbml0IH07XG5cbiAgJC5lYWNoKFsnbGVmdCcsICd1cCcsICdkb3duJywgJ3JpZ2h0J10sIGZ1bmN0aW9uICgpIHtcbiAgICAkLmV2ZW50LnNwZWNpYWxbYHN3aXBlJHt0aGlzfWBdID0geyBzZXR1cDogZnVuY3Rpb24oKXtcbiAgICAgICQodGhpcykub24oJ3N3aXBlJywgJC5ub29wKTtcbiAgICB9IH07XG4gIH0pO1xufSkoalF1ZXJ5KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNZXRob2QgZm9yIGFkZGluZyBwc3VlZG8gZHJhZyBldmVudHMgdG8gZWxlbWVudHMgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiFmdW5jdGlvbigkKXtcbiAgJC5mbi5hZGRUb3VjaCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGksZWwpe1xuICAgICAgJChlbCkuYmluZCgndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vd2UgcGFzcyB0aGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0IGJlY2F1c2UgdGhlIGpRdWVyeSBldmVudFxuICAgICAgICAvL29iamVjdCBpcyBub3JtYWxpemVkIHRvIHczYyBzcGVjcyBhbmQgZG9lcyBub3QgcHJvdmlkZSB0aGUgVG91Y2hMaXN0XG4gICAgICAgIGhhbmRsZVRvdWNoKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGhhbmRsZVRvdWNoID0gZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgICBmaXJzdCA9IHRvdWNoZXNbMF0sXG4gICAgICAgICAgZXZlbnRUeXBlcyA9IHtcbiAgICAgICAgICAgIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuICAgICAgICAgICAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgIHRvdWNoZW5kOiAnbW91c2V1cCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHR5cGUgPSBldmVudFR5cGVzW2V2ZW50LnR5cGVdLFxuICAgICAgICAgIHNpbXVsYXRlZEV2ZW50XG4gICAgICAgIDtcblxuICAgICAgaWYoJ01vdXNlRXZlbnQnIGluIHdpbmRvdyAmJiB0eXBlb2Ygd2luZG93Lk1vdXNlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2ltdWxhdGVkRXZlbnQgPSB3aW5kb3cuTW91c2VFdmVudCh0eXBlLCB7XG4gICAgICAgICAgJ2J1YmJsZXMnOiB0cnVlLFxuICAgICAgICAgICdjYW5jZWxhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnc2NyZWVuWCc6IGZpcnN0LnNjcmVlblgsXG4gICAgICAgICAgJ3NjcmVlblknOiBmaXJzdC5zY3JlZW5ZLFxuICAgICAgICAgICdjbGllbnRYJzogZmlyc3QuY2xpZW50WCxcbiAgICAgICAgICAnY2xpZW50WSc6IGZpcnN0LmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgICAgIHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSwgZmlyc3Quc2NyZWVuWCwgZmlyc3Quc2NyZWVuWSwgZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAvKmxlZnQqLywgbnVsbCk7XG4gICAgICB9XG4gICAgICBmaXJzdC50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG4gICAgfTtcbiAgfTtcbn0oalF1ZXJ5KTtcblxuXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vKipGcm9tIHRoZSBqUXVlcnkgTW9iaWxlIExpYnJhcnkqKlxuLy8qKm5lZWQgdG8gcmVjcmVhdGUgZnVuY3Rpb25hbGl0eSoqXG4vLyoqYW5kIHRyeSB0byBpbXByb3ZlIGlmIHBvc3NpYmxlKipcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vKiBSZW1vdmluZyB0aGUgalF1ZXJ5IGZ1bmN0aW9uICoqKipcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4oZnVuY3Rpb24oICQsIHdpbmRvdywgdW5kZWZpbmVkICkge1xuXG5cdHZhciAkZG9jdW1lbnQgPSAkKCBkb2N1bWVudCApLFxuXHRcdC8vIHN1cHBvcnRUb3VjaCA9ICQubW9iaWxlLnN1cHBvcnQudG91Y2gsXG5cdFx0dG91Y2hTdGFydEV2ZW50ID0gJ3RvdWNoc3RhcnQnLy9zdXBwb3J0VG91Y2ggPyBcInRvdWNoc3RhcnRcIiA6IFwibW91c2Vkb3duXCIsXG5cdFx0dG91Y2hTdG9wRXZlbnQgPSAndG91Y2hlbmQnLy9zdXBwb3J0VG91Y2ggPyBcInRvdWNoZW5kXCIgOiBcIm1vdXNldXBcIixcblx0XHR0b3VjaE1vdmVFdmVudCA9ICd0b3VjaG1vdmUnLy9zdXBwb3J0VG91Y2ggPyBcInRvdWNobW92ZVwiIDogXCJtb3VzZW1vdmVcIjtcblxuXHQvLyBzZXR1cCBuZXcgZXZlbnQgc2hvcnRjdXRzXG5cdCQuZWFjaCggKCBcInRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIFwiICtcblx0XHRcInN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0XCIgKS5zcGxpdCggXCIgXCIgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0XHQkLmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRyZXR1cm4gZm4gPyB0aGlzLmJpbmQoIG5hbWUsIGZuICkgOiB0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXG5cdFx0Ly8galF1ZXJ5IDwgMS44XG5cdFx0aWYgKCAkLmF0dHJGbiApIHtcblx0XHRcdCQuYXR0ckZuWyBuYW1lIF0gPSB0cnVlO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gdHJpZ2dlckN1c3RvbUV2ZW50KCBvYmosIGV2ZW50VHlwZSwgZXZlbnQsIGJ1YmJsZSApIHtcblx0XHR2YXIgb3JpZ2luYWxUeXBlID0gZXZlbnQudHlwZTtcblx0XHRldmVudC50eXBlID0gZXZlbnRUeXBlO1xuXHRcdGlmICggYnViYmxlICkge1xuXHRcdFx0JC5ldmVudC50cmlnZ2VyKCBldmVudCwgdW5kZWZpbmVkLCBvYmogKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JC5ldmVudC5kaXNwYXRjaC5jYWxsKCBvYmosIGV2ZW50ICk7XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSBvcmlnaW5hbFR5cGU7XG5cdH1cblxuXHQvLyBhbHNvIGhhbmRsZXMgdGFwaG9sZFxuXG5cdC8vIEFsc28gaGFuZGxlcyBzd2lwZWxlZnQsIHN3aXBlcmlnaHRcblx0JC5ldmVudC5zcGVjaWFsLnN3aXBlID0ge1xuXG5cdFx0Ly8gTW9yZSB0aGFuIHRoaXMgaG9yaXpvbnRhbCBkaXNwbGFjZW1lbnQsIGFuZCB3ZSB3aWxsIHN1cHByZXNzIHNjcm9sbGluZy5cblx0XHRzY3JvbGxTdXByZXNzaW9uVGhyZXNob2xkOiAzMCxcblxuXHRcdC8vIE1vcmUgdGltZSB0aGFuIHRoaXMsIGFuZCBpdCBpc24ndCBhIHN3aXBlLlxuXHRcdGR1cmF0aW9uVGhyZXNob2xkOiAxMDAwLFxuXG5cdFx0Ly8gU3dpcGUgaG9yaXpvbnRhbCBkaXNwbGFjZW1lbnQgbXVzdCBiZSBtb3JlIHRoYW4gdGhpcy5cblx0XHRob3Jpem9udGFsRGlzdGFuY2VUaHJlc2hvbGQ6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID49IDIgPyAxNSA6IDMwLFxuXG5cdFx0Ly8gU3dpcGUgdmVydGljYWwgZGlzcGxhY2VtZW50IG11c3QgYmUgbGVzcyB0aGFuIHRoaXMuXG5cdFx0dmVydGljYWxEaXN0YW5jZVRocmVzaG9sZDogd2luZG93LmRldmljZVBpeGVsUmF0aW8gPj0gMiA/IDE1IDogMzAsXG5cblx0XHRnZXRMb2NhdGlvbjogZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdHZhciB3aW5QYWdlWCA9IHdpbmRvdy5wYWdlWE9mZnNldCxcblx0XHRcdFx0d2luUGFnZVkgPSB3aW5kb3cucGFnZVlPZmZzZXQsXG5cdFx0XHRcdHggPSBldmVudC5jbGllbnRYLFxuXHRcdFx0XHR5ID0gZXZlbnQuY2xpZW50WTtcblxuXHRcdFx0aWYgKCBldmVudC5wYWdlWSA9PT0gMCAmJiBNYXRoLmZsb29yKCB5ICkgPiBNYXRoLmZsb29yKCBldmVudC5wYWdlWSApIHx8XG5cdFx0XHRcdGV2ZW50LnBhZ2VYID09PSAwICYmIE1hdGguZmxvb3IoIHggKSA+IE1hdGguZmxvb3IoIGV2ZW50LnBhZ2VYICkgKSB7XG5cblx0XHRcdFx0Ly8gaU9TNCBjbGllbnRYL2NsaWVudFkgaGF2ZSB0aGUgdmFsdWUgdGhhdCBzaG91bGQgaGF2ZSBiZWVuXG5cdFx0XHRcdC8vIGluIHBhZ2VYL3BhZ2VZLiBXaGlsZSBwYWdlWC9wYWdlLyBoYXZlIHRoZSB2YWx1ZSAwXG5cdFx0XHRcdHggPSB4IC0gd2luUGFnZVg7XG5cdFx0XHRcdHkgPSB5IC0gd2luUGFnZVk7XG5cdFx0XHR9IGVsc2UgaWYgKCB5IDwgKCBldmVudC5wYWdlWSAtIHdpblBhZ2VZKSB8fCB4IDwgKCBldmVudC5wYWdlWCAtIHdpblBhZ2VYICkgKSB7XG5cblx0XHRcdFx0Ly8gU29tZSBBbmRyb2lkIGJyb3dzZXJzIGhhdmUgdG90YWxseSBib2d1cyB2YWx1ZXMgZm9yIGNsaWVudFgvWVxuXHRcdFx0XHQvLyB3aGVuIHNjcm9sbGluZy96b29taW5nIGEgcGFnZS4gRGV0ZWN0YWJsZSBzaW5jZSBjbGllbnRYL2NsaWVudFlcblx0XHRcdFx0Ly8gc2hvdWxkIG5ldmVyIGJlIHNtYWxsZXIgdGhhbiBwYWdlWC9wYWdlWSBtaW51cyBwYWdlIHNjcm9sbFxuXHRcdFx0XHR4ID0gZXZlbnQucGFnZVggLSB3aW5QYWdlWDtcblx0XHRcdFx0eSA9IGV2ZW50LnBhZ2VZIC0gd2luUGFnZVk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHlcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdHN0YXJ0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgZGF0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyA/XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWyAwIF0gOiBldmVudCxcblx0XHRcdFx0bG9jYXRpb24gPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZ2V0TG9jYXRpb24oIGRhdGEgKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0aW1lOiAoIG5ldyBEYXRlKCkgKS5nZXRUaW1lKCksXG5cdFx0XHRcdFx0XHRjb29yZHM6IFsgbG9jYXRpb24ueCwgbG9jYXRpb24ueSBdLFxuXHRcdFx0XHRcdFx0b3JpZ2luOiAkKCBldmVudC50YXJnZXQgKVxuXHRcdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdHN0b3A6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBkYXRhID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzID9cblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbIDAgXSA6IGV2ZW50LFxuXHRcdFx0XHRsb2NhdGlvbiA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5nZXRMb2NhdGlvbiggZGF0YSApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHRpbWU6ICggbmV3IERhdGUoKSApLmdldFRpbWUoKSxcblx0XHRcdFx0XHRcdGNvb3JkczogWyBsb2NhdGlvbi54LCBsb2NhdGlvbi55IF1cblx0XHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRoYW5kbGVTd2lwZTogZnVuY3Rpb24oIHN0YXJ0LCBzdG9wLCB0aGlzT2JqZWN0LCBvcmlnVGFyZ2V0ICkge1xuXHRcdFx0aWYgKCBzdG9wLnRpbWUgLSBzdGFydC50aW1lIDwgJC5ldmVudC5zcGVjaWFsLnN3aXBlLmR1cmF0aW9uVGhyZXNob2xkICYmXG5cdFx0XHRcdE1hdGguYWJzKCBzdGFydC5jb29yZHNbIDAgXSAtIHN0b3AuY29vcmRzWyAwIF0gKSA+ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ob3Jpem9udGFsRGlzdGFuY2VUaHJlc2hvbGQgJiZcblx0XHRcdFx0TWF0aC5hYnMoIHN0YXJ0LmNvb3Jkc1sgMSBdIC0gc3RvcC5jb29yZHNbIDEgXSApIDwgJC5ldmVudC5zcGVjaWFsLnN3aXBlLnZlcnRpY2FsRGlzdGFuY2VUaHJlc2hvbGQgKSB7XG5cdFx0XHRcdHZhciBkaXJlY3Rpb24gPSBzdGFydC5jb29yZHNbMF0gPiBzdG9wLmNvb3Jkc1sgMCBdID8gXCJzd2lwZWxlZnRcIiA6IFwic3dpcGVyaWdodFwiO1xuXG5cdFx0XHRcdHRyaWdnZXJDdXN0b21FdmVudCggdGhpc09iamVjdCwgXCJzd2lwZVwiLCAkLkV2ZW50KCBcInN3aXBlXCIsIHsgdGFyZ2V0OiBvcmlnVGFyZ2V0LCBzd2lwZXN0YXJ0OiBzdGFydCwgc3dpcGVzdG9wOiBzdG9wIH0pLCB0cnVlICk7XG5cdFx0XHRcdHRyaWdnZXJDdXN0b21FdmVudCggdGhpc09iamVjdCwgZGlyZWN0aW9uLCQuRXZlbnQoIGRpcmVjdGlvbiwgeyB0YXJnZXQ6IG9yaWdUYXJnZXQsIHN3aXBlc3RhcnQ6IHN0YXJ0LCBzd2lwZXN0b3A6IHN0b3AgfSApLCB0cnVlICk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fSxcblxuXHRcdC8vIFRoaXMgc2VydmVzIGFzIGEgZmxhZyB0byBlbnN1cmUgdGhhdCBhdCBtb3N0IG9uZSBzd2lwZSBldmVudCBldmVudCBpc1xuXHRcdC8vIGluIHdvcmsgYXQgYW55IGdpdmVuIHRpbWVcblx0XHRldmVudEluUHJvZ3Jlc3M6IGZhbHNlLFxuXG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGV2ZW50cyxcblx0XHRcdFx0dGhpc09iamVjdCA9IHRoaXMsXG5cdFx0XHRcdCR0aGlzID0gJCggdGhpc09iamVjdCApLFxuXHRcdFx0XHRjb250ZXh0ID0ge307XG5cblx0XHRcdC8vIFJldHJpZXZlIHRoZSBldmVudHMgZGF0YSBmb3IgdGhpcyBlbGVtZW50IGFuZCBhZGQgdGhlIHN3aXBlIGNvbnRleHRcblx0XHRcdGV2ZW50cyA9ICQuZGF0YSggdGhpcywgXCJtb2JpbGUtZXZlbnRzXCIgKTtcblx0XHRcdGlmICggIWV2ZW50cyApIHtcblx0XHRcdFx0ZXZlbnRzID0geyBsZW5ndGg6IDAgfTtcblx0XHRcdFx0JC5kYXRhKCB0aGlzLCBcIm1vYmlsZS1ldmVudHNcIiwgZXZlbnRzICk7XG5cdFx0XHR9XG5cdFx0XHRldmVudHMubGVuZ3RoKys7XG5cdFx0XHRldmVudHMuc3dpcGUgPSBjb250ZXh0O1xuXG5cdFx0XHRjb250ZXh0LnN0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIEJhaWwgaWYgd2UncmUgYWxyZWFkeSB3b3JraW5nIG9uIGEgc3dpcGUgZXZlbnRcblx0XHRcdFx0aWYgKCAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzID0gdHJ1ZTtcblxuXHRcdFx0XHR2YXIgc3RvcCxcblx0XHRcdFx0XHRzdGFydCA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5zdGFydCggZXZlbnQgKSxcblx0XHRcdFx0XHRvcmlnVGFyZ2V0ID0gZXZlbnQudGFyZ2V0LFxuXHRcdFx0XHRcdGVtaXR0ZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRjb250ZXh0Lm1vdmUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3RhcnQgfHwgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RvcCA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5zdG9wKCBldmVudCApO1xuXHRcdFx0XHRcdGlmICggIWVtaXR0ZWQgKSB7XG5cdFx0XHRcdFx0XHRlbWl0dGVkID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLmhhbmRsZVN3aXBlKCBzdGFydCwgc3RvcCwgdGhpc09iamVjdCwgb3JpZ1RhcmdldCApO1xuXHRcdFx0XHRcdFx0aWYgKCBlbWl0dGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc2V0IHRoZSBjb250ZXh0IHRvIG1ha2Ugd2F5IGZvciB0aGUgbmV4dCBzd2lwZSBldmVudFxuXHRcdFx0XHRcdFx0XHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHByZXZlbnQgc2Nyb2xsaW5nXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggc3RhcnQuY29vcmRzWyAwIF0gLSBzdG9wLmNvb3Jkc1sgMCBdICkgPiAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuc2Nyb2xsU3VwcmVzc2lvblRocmVzaG9sZCApIHtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGNvbnRleHQuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZW1pdHRlZCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdC8vIFJlc2V0IHRoZSBjb250ZXh0IHRvIG1ha2Ugd2F5IGZvciB0aGUgbmV4dCBzd2lwZSBldmVudFxuXHRcdFx0XHRcdFx0JC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0JGRvY3VtZW50Lm9mZiggdG91Y2hNb3ZlRXZlbnQsIGNvbnRleHQubW92ZSApO1xuXHRcdFx0XHRcdFx0Y29udGV4dC5tb3ZlID0gbnVsbDtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQkZG9jdW1lbnQub24oIHRvdWNoTW92ZUV2ZW50LCBjb250ZXh0Lm1vdmUgKVxuXHRcdFx0XHRcdC5vbmUoIHRvdWNoU3RvcEV2ZW50LCBjb250ZXh0LnN0b3AgKTtcblx0XHRcdH07XG5cdFx0XHQkdGhpcy5vbiggdG91Y2hTdGFydEV2ZW50LCBjb250ZXh0LnN0YXJ0ICk7XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBldmVudHMsIGNvbnRleHQ7XG5cblx0XHRcdGV2ZW50cyA9ICQuZGF0YSggdGhpcywgXCJtb2JpbGUtZXZlbnRzXCIgKTtcblx0XHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0XHRjb250ZXh0ID0gZXZlbnRzLnN3aXBlO1xuXHRcdFx0XHRkZWxldGUgZXZlbnRzLnN3aXBlO1xuXHRcdFx0XHRldmVudHMubGVuZ3RoLS07XG5cdFx0XHRcdGlmICggZXZlbnRzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0XHQkLnJlbW92ZURhdGEoIHRoaXMsIFwibW9iaWxlLWV2ZW50c1wiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjb250ZXh0ICkge1xuXHRcdFx0XHRpZiAoIGNvbnRleHQuc3RhcnQgKSB7XG5cdFx0XHRcdFx0JCggdGhpcyApLm9mZiggdG91Y2hTdGFydEV2ZW50LCBjb250ZXh0LnN0YXJ0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjb250ZXh0Lm1vdmUgKSB7XG5cdFx0XHRcdFx0JGRvY3VtZW50Lm9mZiggdG91Y2hNb3ZlRXZlbnQsIGNvbnRleHQubW92ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY29udGV4dC5zdG9wICkge1xuXHRcdFx0XHRcdCRkb2N1bWVudC5vZmYoIHRvdWNoU3RvcEV2ZW50LCBjb250ZXh0LnN0b3AgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0JC5lYWNoKHtcblx0XHRzd2lwZWxlZnQ6IFwic3dpcGUubGVmdFwiLFxuXHRcdHN3aXBlcmlnaHQ6IFwic3dpcGUucmlnaHRcIlxuXHR9LCBmdW5jdGlvbiggZXZlbnQsIHNvdXJjZUV2ZW50ICkge1xuXG5cdFx0JC5ldmVudC5zcGVjaWFsWyBldmVudCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkuYmluZCggc291cmNlRXZlbnQsICQubm9vcCApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLnVuYmluZCggc291cmNlRXZlbnQgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn0pKCBqUXVlcnksIHRoaXMgKTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbmNvbnN0IE11dGF0aW9uT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcHJlZml4ZXMgPSBbJ1dlYktpdCcsICdNb3onLCAnTycsICdNcycsICcnXTtcbiAgZm9yICh2YXIgaT0wOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYCR7cHJlZml4ZXNbaV19TXV0YXRpb25PYnNlcnZlcmAgaW4gd2luZG93KSB7XG4gICAgICByZXR1cm4gd2luZG93W2Ake3ByZWZpeGVzW2ldfU11dGF0aW9uT2JzZXJ2ZXJgXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSgpKTtcblxuY29uc3QgdHJpZ2dlcnMgPSAoZWwsIHR5cGUpID0+IHtcbiAgZWwuZGF0YSh0eXBlKS5zcGxpdCgnICcpLmZvckVhY2goaWQgPT4ge1xuICAgICQoYCMke2lkfWApWyB0eXBlID09PSAnY2xvc2UnID8gJ3RyaWdnZXInIDogJ3RyaWdnZXJIYW5kbGVyJ10oYCR7dHlwZX0uemYudHJpZ2dlcmAsIFtlbF0pO1xuICB9KTtcbn07XG4vLyBFbGVtZW50cyB3aXRoIFtkYXRhLW9wZW5dIHdpbGwgcmV2ZWFsIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuJChkb2N1bWVudCkub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtb3Blbl0nLCBmdW5jdGlvbigpIHtcbiAgdHJpZ2dlcnMoJCh0aGlzKSwgJ29wZW4nKTtcbn0pO1xuXG4vLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NlXSB3aWxsIGNsb3NlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuLy8gSWYgdXNlZCB3aXRob3V0IGEgdmFsdWUgb24gW2RhdGEtY2xvc2VdLCB0aGUgZXZlbnQgd2lsbCBidWJibGUsIGFsbG93aW5nIGl0IHRvIGNsb3NlIGEgcGFyZW50IGNvbXBvbmVudC5cbiQoZG9jdW1lbnQpLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NlXScsIGZ1bmN0aW9uKCkge1xuICBsZXQgaWQgPSAkKHRoaXMpLmRhdGEoJ2Nsb3NlJyk7XG4gIGlmIChpZCkge1xuICAgIHRyaWdnZXJzKCQodGhpcyksICdjbG9zZScpO1xuICB9XG4gIGVsc2Uge1xuICAgICQodGhpcykudHJpZ2dlcignY2xvc2UuemYudHJpZ2dlcicpO1xuICB9XG59KTtcblxuLy8gRWxlbWVudHMgd2l0aCBbZGF0YS10b2dnbGVdIHdpbGwgdG9nZ2xlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuJChkb2N1bWVudCkub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtdG9nZ2xlXScsIGZ1bmN0aW9uKCkge1xuICB0cmlnZ2VycygkKHRoaXMpLCAndG9nZ2xlJyk7XG59KTtcblxuLy8gRWxlbWVudHMgd2l0aCBbZGF0YS1jbG9zYWJsZV0gd2lsbCByZXNwb25kIHRvIGNsb3NlLnpmLnRyaWdnZXIgZXZlbnRzLlxuJChkb2N1bWVudCkub24oJ2Nsb3NlLnpmLnRyaWdnZXInLCAnW2RhdGEtY2xvc2FibGVdJywgZnVuY3Rpb24oZSl7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGxldCBhbmltYXRpb24gPSAkKHRoaXMpLmRhdGEoJ2Nsb3NhYmxlJyk7XG5cbiAgaWYoYW5pbWF0aW9uICE9PSAnJyl7XG4gICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCgkKHRoaXMpLCBhbmltYXRpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjbG9zZWQuemYnKTtcbiAgICB9KTtcbiAgfWVsc2V7XG4gICAgJCh0aGlzKS5mYWRlT3V0KCkudHJpZ2dlcignY2xvc2VkLnpmJyk7XG4gIH1cbn0pO1xuXG4kKGRvY3VtZW50KS5vbignZm9jdXMuemYudHJpZ2dlciBibHVyLnpmLnRyaWdnZXInLCAnW2RhdGEtdG9nZ2xlLWZvY3VzXScsIGZ1bmN0aW9uKCkge1xuICBsZXQgaWQgPSAkKHRoaXMpLmRhdGEoJ3RvZ2dsZS1mb2N1cycpO1xuICAkKGAjJHtpZH1gKS50cmlnZ2VySGFuZGxlcigndG9nZ2xlLnpmLnRyaWdnZXInLCBbJCh0aGlzKV0pO1xufSk7XG5cbi8qKlxuKiBGaXJlcyBvbmNlIGFmdGVyIGFsbCBvdGhlciBzY3JpcHRzIGhhdmUgbG9hZGVkXG4qIEBmdW5jdGlvblxuKiBAcHJpdmF0ZVxuKi9cbiQod2luZG93KS5sb2FkKCgpID0+IHtcbiAgY2hlY2tMaXN0ZW5lcnMoKTtcbn0pO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVycygpIHtcbiAgZXZlbnRzTGlzdGVuZXIoKTtcbiAgcmVzaXplTGlzdGVuZXIoKTtcbiAgc2Nyb2xsTGlzdGVuZXIoKTtcbiAgY2xvc2VtZUxpc3RlbmVyKCk7XG59XG5cbi8vKioqKioqKiogb25seSBmaXJlcyB0aGlzIGZ1bmN0aW9uIG9uY2Ugb24gbG9hZCwgaWYgdGhlcmUncyBzb21ldGhpbmcgdG8gd2F0Y2ggKioqKioqKipcbmZ1bmN0aW9uIGNsb3NlbWVMaXN0ZW5lcihwbHVnaW5OYW1lKSB7XG4gIHZhciB5ZXRpQm94ZXMgPSAkKCdbZGF0YS15ZXRpLWJveF0nKSxcbiAgICAgIHBsdWdOYW1lcyA9IFsnZHJvcGRvd24nLCAndG9vbHRpcCcsICdyZXZlYWwnXTtcblxuICBpZihwbHVnaW5OYW1lKXtcbiAgICBpZih0eXBlb2YgcGx1Z2luTmFtZSA9PT0gJ3N0cmluZycpe1xuICAgICAgcGx1Z05hbWVzLnB1c2gocGx1Z2luTmFtZSk7XG4gICAgfWVsc2UgaWYodHlwZW9mIHBsdWdpbk5hbWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwbHVnaW5OYW1lWzBdID09PSAnc3RyaW5nJyl7XG4gICAgICBwbHVnTmFtZXMuY29uY2F0KHBsdWdpbk5hbWUpO1xuICAgIH1lbHNle1xuICAgICAgY29uc29sZS5lcnJvcignUGx1Z2luIG5hbWVzIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgfVxuICBpZih5ZXRpQm94ZXMubGVuZ3RoKXtcbiAgICBsZXQgbGlzdGVuZXJzID0gcGx1Z05hbWVzLm1hcCgobmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGBjbG9zZW1lLnpmLiR7bmFtZX1gO1xuICAgIH0pLmpvaW4oJyAnKTtcblxuICAgICQod2luZG93KS5vZmYobGlzdGVuZXJzKS5vbihsaXN0ZW5lcnMsIGZ1bmN0aW9uKGUsIHBsdWdpbklkKXtcbiAgICAgIGxldCBwbHVnaW4gPSBlLm5hbWVzcGFjZS5zcGxpdCgnLicpWzBdO1xuICAgICAgbGV0IHBsdWdpbnMgPSAkKGBbZGF0YS0ke3BsdWdpbn1dYCkubm90KGBbZGF0YS15ZXRpLWJveD1cIiR7cGx1Z2luSWR9XCJdYCk7XG5cbiAgICAgIHBsdWdpbnMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICBsZXQgX3RoaXMgPSAkKHRoaXMpO1xuXG4gICAgICAgIF90aGlzLnRyaWdnZXJIYW5kbGVyKCdjbG9zZS56Zi50cmlnZ2VyJywgW190aGlzXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNpemVMaXN0ZW5lcihkZWJvdW5jZSl7XG4gIGxldCB0aW1lcixcbiAgICAgICRub2RlcyA9ICQoJ1tkYXRhLXJlc2l6ZV0nKTtcbiAgaWYoJG5vZGVzLmxlbmd0aCl7XG4gICAgJCh3aW5kb3cpLm9mZigncmVzaXplLnpmLnRyaWdnZXInKVxuICAgIC5vbigncmVzaXplLnpmLnRyaWdnZXInLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGltZXIpIHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfVxuXG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblxuICAgICAgICBpZighTXV0YXRpb25PYnNlcnZlcil7Ly9mYWxsYmFjayBmb3IgSUUgOVxuICAgICAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKCdyZXNpemVtZS56Zi50cmlnZ2VyJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy90cmlnZ2VyIGFsbCBsaXN0ZW5pbmcgZWxlbWVudHMgYW5kIHNpZ25hbCBhIHJlc2l6ZSBldmVudFxuICAgICAgICAkbm9kZXMuYXR0cignZGF0YS1ldmVudHMnLCBcInJlc2l6ZVwiKTtcbiAgICAgIH0sIGRlYm91bmNlIHx8IDEwKTsvL2RlZmF1bHQgdGltZSB0byBlbWl0IHJlc2l6ZSBldmVudFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbExpc3RlbmVyKGRlYm91bmNlKXtcbiAgbGV0IHRpbWVyLFxuICAgICAgJG5vZGVzID0gJCgnW2RhdGEtc2Nyb2xsXScpO1xuICBpZigkbm9kZXMubGVuZ3RoKXtcbiAgICAkKHdpbmRvdykub2ZmKCdzY3JvbGwuemYudHJpZ2dlcicpXG4gICAgLm9uKCdzY3JvbGwuemYudHJpZ2dlcicsIGZ1bmN0aW9uKGUpe1xuICAgICAgaWYodGltZXIpeyBjbGVhclRpbWVvdXQodGltZXIpOyB9XG5cbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXG4gICAgICAgIGlmKCFNdXRhdGlvbk9ic2VydmVyKXsvL2ZhbGxiYWNrIGZvciBJRSA5XG4gICAgICAgICAgJG5vZGVzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICQodGhpcykudHJpZ2dlckhhbmRsZXIoJ3Njcm9sbG1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL3RyaWdnZXIgYWxsIGxpc3RlbmluZyBlbGVtZW50cyBhbmQgc2lnbmFsIGEgc2Nyb2xsIGV2ZW50XG4gICAgICAgICRub2Rlcy5hdHRyKCdkYXRhLWV2ZW50cycsIFwic2Nyb2xsXCIpO1xuICAgICAgfSwgZGVib3VuY2UgfHwgMTApOy8vZGVmYXVsdCB0aW1lIHRvIGVtaXQgc2Nyb2xsIGV2ZW50XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRzTGlzdGVuZXIoKSB7XG4gIGlmKCFNdXRhdGlvbk9ic2VydmVyKXsgcmV0dXJuIGZhbHNlOyB9XG4gIGxldCBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXJlc2l6ZV0sIFtkYXRhLXNjcm9sbF0sIFtkYXRhLW11dGF0ZV0nKTtcblxuICAvL2VsZW1lbnQgY2FsbGJhY2tcbiAgdmFyIGxpc3RlbmluZ0VsZW1lbnRzTXV0YXRpb24gPSBmdW5jdGlvbihtdXRhdGlvblJlY29yZHNMaXN0KSB7XG4gICAgdmFyICR0YXJnZXQgPSAkKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0udGFyZ2V0KTtcbiAgICAvL3RyaWdnZXIgdGhlIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBlbGVtZW50IGRlcGVuZGluZyBvbiB0eXBlXG4gICAgc3dpdGNoICgkdGFyZ2V0LmF0dHIoXCJkYXRhLWV2ZW50c1wiKSkge1xuXG4gICAgICBjYXNlIFwicmVzaXplXCIgOlxuICAgICAgJHRhcmdldC50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0XSk7XG4gICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInNjcm9sbFwiIDpcbiAgICAgICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ3Njcm9sbG1lLnpmLnRyaWdnZXInLCBbJHRhcmdldCwgd2luZG93LnBhZ2VZT2Zmc2V0XSk7XG4gICAgICBicmVhaztcblxuICAgICAgLy8gY2FzZSBcIm11dGF0ZVwiIDpcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdtdXRhdGUnLCAkdGFyZ2V0KTtcbiAgICAgIC8vICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ211dGF0ZS56Zi50cmlnZ2VyJyk7XG4gICAgICAvL1xuICAgICAgLy8gLy9tYWtlIHN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIGFuIGluZmluaXRlIGxvb3AgZnJvbSBzbG9wcHkgY29kZWluZ1xuICAgICAgLy8gaWYgKCR0YXJnZXQuaW5kZXgoJ1tkYXRhLW11dGF0ZV0nKSA9PSAkKFwiW2RhdGEtbXV0YXRlXVwiKS5sZW5ndGgtMSkge1xuICAgICAgLy8gICBkb21NdXRhdGlvbk9ic2VydmVyKCk7XG4gICAgICAvLyB9XG4gICAgICAvLyBicmVhaztcblxuICAgICAgZGVmYXVsdCA6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvL25vdGhpbmdcbiAgICB9XG4gIH1cblxuICBpZihub2Rlcy5sZW5ndGgpe1xuICAgIC8vZm9yIGVhY2ggZWxlbWVudCB0aGF0IG5lZWRzIHRvIGxpc3RlbiBmb3IgcmVzaXppbmcsIHNjcm9sbGluZywgKG9yIGNvbWluZyBzb29uIG11dGF0aW9uKSBhZGQgYSBzaW5nbGUgb2JzZXJ2ZXJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBub2Rlcy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICBsZXQgZWxlbWVudE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbik7XG4gICAgICBlbGVtZW50T2JzZXJ2ZXIub2JzZXJ2ZShub2Rlc1tpXSwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IGZhbHNlLCBjaGFyYWN0ZXJEYXRhOiBmYWxzZSwgc3VidHJlZTpmYWxzZSwgYXR0cmlidXRlRmlsdGVyOltcImRhdGEtZXZlbnRzXCJdfSk7XG4gICAgfVxuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBbUEhdXG4vLyBGb3VuZGF0aW9uLkNoZWNrV2F0Y2hlcnMgPSBjaGVja1dhdGNoZXJzO1xuRm91bmRhdGlvbi5JSGVhcllvdSA9IGNoZWNrTGlzdGVuZXJzO1xuLy8gRm91bmRhdGlvbi5JU2VlWW91ID0gc2Nyb2xsTGlzdGVuZXI7XG4vLyBGb3VuZGF0aW9uLklGZWVsWW91ID0gY2xvc2VtZUxpc3RlbmVyO1xuXG59KGpRdWVyeSk7XG5cbi8vIGZ1bmN0aW9uIGRvbU11dGF0aW9uT2JzZXJ2ZXIoZGVib3VuY2UpIHtcbi8vICAgLy8gISEhIFRoaXMgaXMgY29taW5nIHNvb24gYW5kIG5lZWRzIG1vcmUgd29yazsgbm90IGFjdGl2ZSAgISEhIC8vXG4vLyAgIHZhciB0aW1lcixcbi8vICAgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tdXRhdGVdJyk7XG4vLyAgIC8vXG4vLyAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbi8vICAgICAvLyB2YXIgTXV0YXRpb25PYnNlcnZlciA9IChmdW5jdGlvbiAoKSB7XG4vLyAgICAgLy8gICB2YXIgcHJlZml4ZXMgPSBbJ1dlYktpdCcsICdNb3onLCAnTycsICdNcycsICcnXTtcbi8vICAgICAvLyAgIGZvciAodmFyIGk9MDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgLy8gICAgIGlmIChwcmVmaXhlc1tpXSArICdNdXRhdGlvbk9ic2VydmVyJyBpbiB3aW5kb3cpIHtcbi8vICAgICAvLyAgICAgICByZXR1cm4gd2luZG93W3ByZWZpeGVzW2ldICsgJ011dGF0aW9uT2JzZXJ2ZXInXTtcbi8vICAgICAvLyAgICAgfVxuLy8gICAgIC8vICAgfVxuLy8gICAgIC8vICAgcmV0dXJuIGZhbHNlO1xuLy8gICAgIC8vIH0oKSk7XG4vL1xuLy9cbi8vICAgICAvL2ZvciB0aGUgYm9keSwgd2UgbmVlZCB0byBsaXN0ZW4gZm9yIGFsbCBjaGFuZ2VzIGVmZmVjdGluZyB0aGUgc3R5bGUgYW5kIGNsYXNzIGF0dHJpYnV0ZXNcbi8vICAgICB2YXIgYm9keU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoYm9keU11dGF0aW9uKTtcbi8vICAgICBib2R5T2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogZmFsc2UsIHN1YnRyZWU6dHJ1ZSwgYXR0cmlidXRlRmlsdGVyOltcInN0eWxlXCIsIFwiY2xhc3NcIl19KTtcbi8vXG4vL1xuLy8gICAgIC8vYm9keSBjYWxsYmFja1xuLy8gICAgIGZ1bmN0aW9uIGJvZHlNdXRhdGlvbihtdXRhdGUpIHtcbi8vICAgICAgIC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSBtdXRhdGlvbiBldmVudFxuLy8gICAgICAgaWYgKHRpbWVyKSB7IGNsZWFyVGltZW91dCh0aW1lcik7IH1cbi8vXG4vLyAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgIGJvZHlPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4vLyAgICAgICAgICQoJ1tkYXRhLW11dGF0ZV0nKS5hdHRyKCdkYXRhLWV2ZW50cycsXCJtdXRhdGVcIik7XG4vLyAgICAgICB9LCBkZWJvdW5jZSB8fCAxNTApO1xuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuIiwiLy8gJChkb2N1bWVudCkuZm91bmRhdGlvbigpO1xuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuXHRTaXRlLmluaXQoKTtcbn0pO1xuXG52YXIgU2l0ZSA9IHtcblx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAkKHdpbmRvdykud2lkdGgoKSA+IDY0MCApIHtcblx0XHRcdFNpdGUuc2Nyb2xsbWFnaWMoKTtcblx0XHR9XG5cdH0sXG5cdHNjcm9sbG1hZ2ljOiBmdW5jdGlvbigpIHtcblx0XHQvLyBpbml0IGNvbnRyb2xsZXJcblx0XHR2YXIgY29udHJvbGxlciA9IG5ldyBTY3JvbGxNYWdpYy5Db250cm9sbGVyKCk7XG5cdFx0dmFyIGltYWdlcyA9ICQoJy5wYXJhbGxheCcpO1xuXHRcdHZhciB3aW5kb3dIZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCk7XG5cblx0XHQkLmVhY2goaW1hZ2VzLCBmdW5jdGlvbihpbmRleCwgaW1hZ2Upe1xuXHRcdFx0Ly8gdmFyIHR3ZWVuID0gbmV3IFR3ZWVuTWF4LmZyb21UbyhpbWFnZSwgMSwgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDEyZW0pJyB9LCB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoLThlbSknIH0pXG5cdFx0XHR2YXIgdHdlZW4gPSBuZXcgVHdlZW5NYXguZnJvbVRvKGltYWdlLCAxLCB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoLTRlbSknIH0sIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgxMmVtKScgfSlcblxuXHRcdFx0dmFyIHNjZW5lID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtcblx0XHRcdFx0XHRkdXJhdGlvbjogd2luZG93SGVpZ2h0KjIsXG5cdFx0XHRcdFx0dHJpZ2dlckVsZW1lbnQ6IGltYWdlLFxuXHRcdFx0XHRcdHRyaWdnZXJIb29rOiAxLFxuXHRcdFx0XHRcdC8vIG9mZnNldDogNTAqaW5kZXhcblx0XHRcdFx0XHQvLyBvZmZzZXQ6IDBcblx0XHRcdFx0fSlcblx0XHRcdFx0LnNldFR3ZWVuKCB0d2VlbiApXG5cdFx0XHRcdC5hZGRUbyhjb250cm9sbGVyKVxuXHRcdH0pO1xuXHR9XG59Il0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
