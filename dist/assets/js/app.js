"use strict";

/*!
 * jQuery JavaScript Library v2.2.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-04-05T19:26Z
 */

(function (global, factory) {

	if (typeof module === "object" && typeof module.exports === "object") {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ? factory(global, true) : function (w) {
			if (!w.document) {
				throw new Error("jQuery requires a window with a document");
			}
			return factory(w);
		};
	} else {
		factory(global);
	}

	// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};

	var version = "2.2.3",


	// Define a local copy of jQuery
	jQuery = function (selector, context) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init(selector, context);
	},


	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	    rdashAlpha = /-([\da-z])/gi,


	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function (all, letter) {
		return letter.toUpperCase();
	};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function () {
			return slice.call(this);
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function (num) {
			return num != null ?

			// Return just the one element from the set
			num < 0 ? this[num + this.length] : this[num] :

			// Return all the elements in a clean array
			slice.call(this);
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function (elems) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge(this.constructor(), elems);

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function (callback) {
			return jQuery.each(this, callback);
		},

		map: function (callback) {
			return this.pushStack(jQuery.map(this, function (elem, i) {
				return callback.call(elem, i, elem);
			}));
		},

		slice: function () {
			return this.pushStack(slice.apply(this, arguments));
		},

		first: function () {
			return this.eq(0);
		},

		last: function () {
			return this.eq(-1);
		},

		eq: function (i) {
			var len = this.length,
			    j = +i + (i < 0 ? len : 0);
			return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
		},

		end: function () {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function () {
		var options,
		    name,
		    src,
		    copy,
		    copyIsArray,
		    clone,
		    target = arguments[0] || {},
		    i = 1,
		    length = arguments.length,
		    deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// Skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !jQuery.isFunction(target)) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {

			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {

				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {

						if (copyIsArray) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = jQuery.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function (msg) {
			throw new Error(msg);
		},

		noop: function () {},

		isFunction: function (obj) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function (obj) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function (obj) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;
		},

		isPlainObject: function (obj) {
			var key;

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for (key in obj) {}

			return key === undefined || hasOwn.call(obj, key);
		},

		isEmptyObject: function (obj) {
			var name;
			for (name in obj) {
				return false;
			}
			return true;
		},

		type: function (obj) {
			if (obj == null) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function (code) {
			var script,
			    indirect = eval;

			code = jQuery.trim(code);

			if (code) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if (code.indexOf("use strict") === 1) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild(script).parentNode.removeChild(script);
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect(code);
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function (string) {
			return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
		},

		nodeName: function (elem, name) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function (obj, callback) {
			var length,
			    i = 0;

			if (isArrayLike(obj)) {
				length = obj.length;
				for (; i < length; i++) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function (text) {
			return text == null ? "" : (text + "").replace(rtrim, "");
		},

		// results is for internal usage only
		makeArray: function (arr, results) {
			var ret = results || [];

			if (arr != null) {
				if (isArrayLike(Object(arr))) {
					jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					push.call(ret, arr);
				}
			}

			return ret;
		},

		inArray: function (elem, arr, i) {
			return arr == null ? -1 : indexOf.call(arr, elem, i);
		},

		merge: function (first, second) {
			var len = +second.length,
			    j = 0,
			    i = first.length;

			for (; j < len; j++) {
				first[i++] = second[j];
			}

			first.length = i;

			return first;
		},

		grep: function (elems, callback, invert) {
			var callbackInverse,
			    matches = [],
			    i = 0,
			    length = elems.length,
			    callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for (; i < length; i++) {
				callbackInverse = !callback(elems[i], i);
				if (callbackInverse !== callbackExpect) {
					matches.push(elems[i]);
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function (elems, callback, arg) {
			var length,
			    value,
			    i = 0,
			    ret = [];

			// Go through the array, translating each of the items to their new values
			if (isArrayLike(elems)) {
				length = elems.length;
				for (; i < length; i++) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}

				// Go through every key on the object,
			} else {
				for (i in elems) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply([], ret);
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function (fn, context) {
			var tmp, args, proxy;

			if (typeof context === "string") {
				tmp = fn[context];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if (!jQuery.isFunction(fn)) {
				return undefined;
			}

			// Simulated bind
			args = slice.call(arguments, 2);
			proxy = function () {
				return fn.apply(context || this, args.concat(slice.call(arguments)));
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if (typeof Symbol === "function") {
		jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
		class2type["[object " + name + "]"] = name.toLowerCase();
	});

	function isArrayLike(obj) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
		    type = jQuery.type(obj);

		if (type === "function" || jQuery.isWindow(obj)) {
			return false;
		}

		return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	}
	var Sizzle =
	/*!
  * Sizzle CSS Selector Engine v2.2.1
  * http://sizzlejs.com/
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2015-10-17
  */
	function (window) {

		var i,
		    support,
		    Expr,
		    getText,
		    isXML,
		    tokenize,
		    compile,
		    select,
		    outermostContext,
		    sortInput,
		    hasDuplicate,


		// Local document vars
		setDocument,
		    document,
		    docElem,
		    documentIsHTML,
		    rbuggyQSA,
		    rbuggyMatches,
		    matches,
		    contains,


		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		    preferredDoc = window.document,
		    dirruns = 0,
		    done = 0,
		    classCache = createCache(),
		    tokenCache = createCache(),
		    compilerCache = createCache(),
		    sortOrder = function (a, b) {
			if (a === b) {
				hasDuplicate = true;
			}
			return 0;
		},


		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,


		// Instance methods
		hasOwn = {}.hasOwnProperty,
		    arr = [],
		    pop = arr.pop,
		    push_native = arr.push,
		    push = arr.push,
		    slice = arr.slice,

		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function (list, elem) {
			var i = 0,
			    len = list.length;
			for (; i < len; i++) {
				if (list[i] === elem) {
					return i;
				}
			}
			return -1;
		},
		    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",


		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",


		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
		    pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" + ")\\)|)",


		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp(whitespace + "+", "g"),
		    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
		    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
		    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
		    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
		    rpseudo = new RegExp(pseudos),
		    ridentifier = new RegExp("^" + identifier + "$"),
		    matchExpr = {
			"ID": new RegExp("^#(" + identifier + ")"),
			"CLASS": new RegExp("^\\.(" + identifier + ")"),
			"TAG": new RegExp("^(" + identifier + "|[*])"),
			"ATTR": new RegExp("^" + attributes),
			"PSEUDO": new RegExp("^" + pseudos),
			"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
			"bool": new RegExp("^(?:" + booleans + ")$", "i"),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
		},
		    rinputs = /^(?:input|select|textarea|button)$/i,
		    rheader = /^h\d$/i,
		    rnative = /^[^{]+\{\s*\[native \w/,


		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
		    rsibling = /[+~]/,
		    rescape = /'|\\/g,


		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
		    funescape = function (_, escaped, escapedWhitespace) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ? escaped : high < 0 ?
			// BMP codepoint
			String.fromCharCode(high + 0x10000) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
		},


		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function () {
			setDocument();
		};

		// Optimize for push.apply( _, NodeList )
		try {
			push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
			// Support: Android<4.0
			// Detect silently failing push.apply
			arr[preferredDoc.childNodes.length].nodeType;
		} catch (e) {
			push = { apply: arr.length ?

				// Leverage slice if possible
				function (target, els) {
					push_native.apply(target, slice.call(els));
				} :

				// Support: IE<9
				// Otherwise append directly
				function (target, els) {
					var j = target.length,
					    i = 0;
					// Can't trust NodeList.length
					while (target[j++] = els[i++]) {}
					target.length = j - 1;
				}
			};
		}

		function Sizzle(selector, context, results, seed) {
			var m,
			    i,
			    elem,
			    nid,
			    nidselect,
			    match,
			    groups,
			    newSelector,
			    newContext = context && context.ownerDocument,


			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

			results = results || [];

			// Return early from calls with invalid selector or context
			if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

				return results;
			}

			// Try to shortcut find operations (as opposed to filters) in HTML documents
			if (!seed) {

				if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
					setDocument(context);
				}
				context = context || document;

				if (documentIsHTML) {

					// If the selector is sufficiently simple, try using a "get*By*" DOM method
					// (excepting DocumentFragment context, where the methods don't exist)
					if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

						// ID selector
						if (m = match[1]) {

							// Document context
							if (nodeType === 9) {
								if (elem = context.getElementById(m)) {

									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if (elem.id === m) {
										results.push(elem);
										return results;
									}
								} else {
									return results;
								}

								// Element context
							} else {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {

									results.push(elem);
									return results;
								}
							}

							// Type selector
						} else if (match[2]) {
							push.apply(results, context.getElementsByTagName(selector));
							return results;

							// Class selector
						} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {

							push.apply(results, context.getElementsByClassName(m));
							return results;
						}
					}

					// Take advantage of querySelectorAll
					if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {

						if (nodeType !== 1) {
							newContext = context;
							newSelector = selector;

							// qSA looks outside Element context, which is not what we want
							// Thanks to Andrew Dupont for this workaround technique
							// Support: IE <=8
							// Exclude object elements
						} else if (context.nodeName.toLowerCase() !== "object") {

							// Capture the context ID, setting it first if necessary
							if (nid = context.getAttribute("id")) {
								nid = nid.replace(rescape, "\\$&");
							} else {
								context.setAttribute("id", nid = expando);
							}

							// Prefix every selector in the list
							groups = tokenize(selector);
							i = groups.length;
							nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
							while (i--) {
								groups[i] = nidselect + " " + toSelector(groups[i]);
							}
							newSelector = groups.join(",");

							// Expand context for sibling selectors
							newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
						}

						if (newSelector) {
							try {
								push.apply(results, newContext.querySelectorAll(newSelector));
								return results;
							} catch (qsaError) {} finally {
								if (nid === expando) {
									context.removeAttribute("id");
								}
							}
						}
					}
				}
			}

			// All others
			return select(selector.replace(rtrim, "$1"), context, results, seed);
		}

		/**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
		function createCache() {
			var keys = [];

			function cache(key, value) {
				// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
				if (keys.push(key + " ") > Expr.cacheLength) {
					// Only keep the most recent entries
					delete cache[keys.shift()];
				}
				return cache[key + " "] = value;
			}
			return cache;
		}

		/**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
		function markFunction(fn) {
			fn[expando] = true;
			return fn;
		}

		/**
   * Support testing using an element
   * @param {Function} fn Passed the created div and expects a boolean result
   */
		function assert(fn) {
			var div = document.createElement("div");

			try {
				return !!fn(div);
			} catch (e) {
				return false;
			} finally {
				// Remove from its parent by default
				if (div.parentNode) {
					div.parentNode.removeChild(div);
				}
				// release memory in IE
				div = null;
			}
		}

		/**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
		function addHandle(attrs, handler) {
			var arr = attrs.split("|"),
			    i = arr.length;

			while (i--) {
				Expr.attrHandle[arr[i]] = handler;
			}
		}

		/**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
		function siblingCheck(a, b) {
			var cur = b && a,
			    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

			// Use IE sourceIndex if available on both nodes
			if (diff) {
				return diff;
			}

			// Check if b follows a
			if (cur) {
				while (cur = cur.nextSibling) {
					if (cur === b) {
						return -1;
					}
				}
			}

			return a ? 1 : -1;
		}

		/**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
		function createInputPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
		function createButtonPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return (name === "input" || name === "button") && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
		function createPositionalPseudo(fn) {
			return markFunction(function (argument) {
				argument = +argument;
				return markFunction(function (seed, matches) {
					var j,
					    matchIndexes = fn([], seed.length, argument),
					    i = matchIndexes.length;

					// Match elements found at the specified indexes
					while (i--) {
						if (seed[j = matchIndexes[i]]) {
							seed[j] = !(matches[j] = seed[j]);
						}
					}
				});
			});
		}

		/**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
		function testContext(context) {
			return context && typeof context.getElementsByTagName !== "undefined" && context;
		}

		// Expose support vars for convenience
		support = Sizzle.support = {};

		/**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
		isXML = Sizzle.isXML = function (elem) {
			// documentElement is verified for cases where it doesn't yet exist
			// (such as loading iframes in IE - #4833)
			var documentElement = elem && (elem.ownerDocument || elem).documentElement;
			return documentElement ? documentElement.nodeName !== "HTML" : false;
		};

		/**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
		setDocument = Sizzle.setDocument = function (node) {
			var hasCompare,
			    parent,
			    doc = node ? node.ownerDocument || node : preferredDoc;

			// Return early if doc is invalid or already selected
			if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
				return document;
			}

			// Update global variables
			document = doc;
			docElem = document.documentElement;
			documentIsHTML = !isXML(document);

			// Support: IE 9-11, Edge
			// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
			if ((parent = document.defaultView) && parent.top !== parent) {
				// Support: IE 11
				if (parent.addEventListener) {
					parent.addEventListener("unload", unloadHandler, false);

					// Support: IE 9 - 10 only
				} else if (parent.attachEvent) {
					parent.attachEvent("onunload", unloadHandler);
				}
			}

			/* Attributes
   ---------------------------------------------------------------------- */

			// Support: IE<8
			// Verify that getAttribute really returns attributes and not properties
			// (excepting IE8 booleans)
			support.attributes = assert(function (div) {
				div.className = "i";
				return !div.getAttribute("className");
			});

			/* getElement(s)By*
   ---------------------------------------------------------------------- */

			// Check if getElementsByTagName("*") returns only elements
			support.getElementsByTagName = assert(function (div) {
				div.appendChild(document.createComment(""));
				return !div.getElementsByTagName("*").length;
			});

			// Support: IE<9
			support.getElementsByClassName = rnative.test(document.getElementsByClassName);

			// Support: IE<10
			// Check if getElementById returns elements by name
			// The broken getElementById methods don't pick up programatically-set names,
			// so use a roundabout getElementsByName test
			support.getById = assert(function (div) {
				docElem.appendChild(div).id = expando;
				return !document.getElementsByName || !document.getElementsByName(expando).length;
			});

			// ID find and filter
			if (support.getById) {
				Expr.find["ID"] = function (id, context) {
					if (typeof context.getElementById !== "undefined" && documentIsHTML) {
						var m = context.getElementById(id);
						return m ? [m] : [];
					}
				};
				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						return elem.getAttribute("id") === attrId;
					};
				};
			} else {
				// Support: IE6/7
				// getElementById is not reliable as a find shortcut
				delete Expr.find["ID"];

				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
						return node && node.value === attrId;
					};
				};
			}

			// Tag
			Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
				if (typeof context.getElementsByTagName !== "undefined") {
					return context.getElementsByTagName(tag);

					// DocumentFragment nodes don't have gEBTN
				} else if (support.qsa) {
					return context.querySelectorAll(tag);
				}
			} : function (tag, context) {
				var elem,
				    tmp = [],
				    i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName(tag);

				// Filter out possible comments
				if (tag === "*") {
					while (elem = results[i++]) {
						if (elem.nodeType === 1) {
							tmp.push(elem);
						}
					}

					return tmp;
				}
				return results;
			};

			// Class
			Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
				if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
					return context.getElementsByClassName(className);
				}
			};

			/* QSA/matchesSelector
   ---------------------------------------------------------------------- */

			// QSA and matchesSelector support

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			rbuggyMatches = [];

			// qSa(:focus) reports false when true (Chrome 21)
			// We allow this because of a bug in IE8/9 that throws an error
			// whenever `document.activeElement` is accessed on an iframe
			// So, we allow :focus to pass through QSA all the time to avoid the IE error
			// See http://bugs.jquery.com/ticket/13378
			rbuggyQSA = [];

			if (support.qsa = rnative.test(document.querySelectorAll)) {
				// Build QSA regex
				// Regex strategy adopted from Diego Perini
				assert(function (div) {
					// Select is set to empty string on purpose
					// This is to test IE's treatment of not explicitly
					// setting a boolean content attribute,
					// since its presence should be enough
					// http://bugs.jquery.com/ticket/12359
					docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";

					// Support: IE8, Opera 11-12.16
					// Nothing should be selected when empty strings follow ^= or $= or *=
					// The test attribute must be unknown in Opera but "safe" for WinRT
					// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
					if (div.querySelectorAll("[msallowcapture^='']").length) {
						rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
					}

					// Support: IE8
					// Boolean attributes and "value" are not treated correctly
					if (!div.querySelectorAll("[selected]").length) {
						rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
					}

					// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
					if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
						rbuggyQSA.push("~=");
					}

					// Webkit/Opera - :checked should return selected option elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":checked").length) {
						rbuggyQSA.push(":checked");
					}

					// Support: Safari 8+, iOS 8+
					// https://bugs.webkit.org/show_bug.cgi?id=136851
					// In-page `selector#id sibing-combinator selector` fails
					if (!div.querySelectorAll("a#" + expando + "+*").length) {
						rbuggyQSA.push(".#.+[+~]");
					}
				});

				assert(function (div) {
					// Support: Windows 8 Native Apps
					// The type and name attributes are restricted during .innerHTML assignment
					var input = document.createElement("input");
					input.setAttribute("type", "hidden");
					div.appendChild(input).setAttribute("name", "D");

					// Support: IE8
					// Enforce case-sensitivity of name attribute
					if (div.querySelectorAll("[name=d]").length) {
						rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
					}

					// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":enabled").length) {
						rbuggyQSA.push(":enabled", ":disabled");
					}

					// Opera 10-11 does not throw on post-comma invalid pseudos
					div.querySelectorAll("*,:x");
					rbuggyQSA.push(",.*:");
				});
			}

			if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {

				assert(function (div) {
					// Check to see if it's possible to do matchesSelector
					// on a disconnected node (IE 9)
					support.disconnectedMatch = matches.call(div, "div");

					// This should fail with an exception
					// Gecko does not error, returns false instead
					matches.call(div, "[s!='']:x");
					rbuggyMatches.push("!=", pseudos);
				});
			}

			rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
			rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

			/* Contains
   ---------------------------------------------------------------------- */
			hasCompare = rnative.test(docElem.compareDocumentPosition);

			// Element contains another
			// Purposefully self-exclusive
			// As in, an element does not contain itself
			contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
				    bup = b && b.parentNode;
				return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
			} : function (a, b) {
				if (b) {
					while (b = b.parentNode) {
						if (b === a) {
							return true;
						}
					}
				}
				return false;
			};

			/* Sorting
   ---------------------------------------------------------------------- */

			// Document order sorting
			sortOrder = hasCompare ? function (a, b) {

				// Flag for duplicate removal
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				// Sort on method existence if only one input has compareDocumentPosition
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if (compare) {
					return compare;
				}

				// Calculate position if both inputs belong to the same document
				compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

				// Otherwise we know they are disconnected
				1;

				// Disconnected nodes
				if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {

					// Choose the first element that is related to our preferred document
					if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
						return -1;
					}
					if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
						return 1;
					}

					// Maintain original order
					return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
				}

				return compare & 4 ? -1 : 1;
			} : function (a, b) {
				// Exit early if the nodes are identical
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				var cur,
				    i = 0,
				    aup = a.parentNode,
				    bup = b.parentNode,
				    ap = [a],
				    bp = [b];

				// Parentless nodes are either documents or disconnected
				if (!aup || !bup) {
					return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

					// If the nodes are siblings, we can do a quick check
				} else if (aup === bup) {
					return siblingCheck(a, b);
				}

				// Otherwise we need full lists of their ancestors for comparison
				cur = a;
				while (cur = cur.parentNode) {
					ap.unshift(cur);
				}
				cur = b;
				while (cur = cur.parentNode) {
					bp.unshift(cur);
				}

				// Walk down the tree looking for a discrepancy
				while (ap[i] === bp[i]) {
					i++;
				}

				return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck(ap[i], bp[i]) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
			};

			return document;
		};

		Sizzle.matches = function (expr, elements) {
			return Sizzle(expr, null, null, elements);
		};

		Sizzle.matchesSelector = function (elem, expr) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			// Make sure that attribute selectors are quoted
			expr = expr.replace(rattributeQuotes, "='$1']");

			if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

				try {
					var ret = matches.call(elem, expr);

					// IE 9's matchesSelector returns false on disconnected nodes
					if (ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11) {
						return ret;
					}
				} catch (e) {}
			}

			return Sizzle(expr, document, null, [elem]).length > 0;
		};

		Sizzle.contains = function (context, elem) {
			// Set document vars if needed
			if ((context.ownerDocument || context) !== document) {
				setDocument(context);
			}
			return contains(context, elem);
		};

		Sizzle.attr = function (elem, name) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			var fn = Expr.attrHandle[name.toLowerCase()],

			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

			return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
		};

		Sizzle.error = function (msg) {
			throw new Error("Syntax error, unrecognized expression: " + msg);
		};

		/**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
		Sizzle.uniqueSort = function (results) {
			var elem,
			    duplicates = [],
			    j = 0,
			    i = 0;

			// Unless we *know* we can detect duplicates, assume their presence
			hasDuplicate = !support.detectDuplicates;
			sortInput = !support.sortStable && results.slice(0);
			results.sort(sortOrder);

			if (hasDuplicate) {
				while (elem = results[i++]) {
					if (elem === results[i]) {
						j = duplicates.push(i);
					}
				}
				while (j--) {
					results.splice(duplicates[j], 1);
				}
			}

			// Clear input after sorting to release objects
			// See https://github.com/jquery/sizzle/pull/225
			sortInput = null;

			return results;
		};

		/**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
		getText = Sizzle.getText = function (elem) {
			var node,
			    ret = "",
			    i = 0,
			    nodeType = elem.nodeType;

			if (!nodeType) {
				// If no nodeType, this is expected to be an array
				while (node = elem[i++]) {
					// Do not traverse comment nodes
					ret += getText(node);
				}
			} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
				// Use textContent for elements
				// innerText usage removed for consistency of new lines (jQuery #11153)
				if (typeof elem.textContent === "string") {
					return elem.textContent;
				} else {
					// Traverse its children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						ret += getText(elem);
					}
				}
			} else if (nodeType === 3 || nodeType === 4) {
				return elem.nodeValue;
			}
			// Do not include comment or processing instruction nodes

			return ret;
		};

		Expr = Sizzle.selectors = {

			// Can be adjusted by the user
			cacheLength: 50,

			createPseudo: markFunction,

			match: matchExpr,

			attrHandle: {},

			find: {},

			relative: {
				">": { dir: "parentNode", first: true },
				" ": { dir: "parentNode" },
				"+": { dir: "previousSibling", first: true },
				"~": { dir: "previousSibling" }
			},

			preFilter: {
				"ATTR": function (match) {
					match[1] = match[1].replace(runescape, funescape);

					// Move the given value to match[3] whether quoted or unquoted
					match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

					if (match[2] === "~=") {
						match[3] = " " + match[3] + " ";
					}

					return match.slice(0, 4);
				},

				"CHILD": function (match) {
					/* matches from matchExpr["CHILD"]
     	1 type (only|nth|...)
     	2 what (child|of-type)
     	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
     	4 xn-component of xn+y argument ([+-]?\d*n|)
     	5 sign of xn-component
     	6 x of xn-component
     	7 sign of y-component
     	8 y of y-component
     */
					match[1] = match[1].toLowerCase();

					if (match[1].slice(0, 3) === "nth") {
						// nth-* requires argument
						if (!match[3]) {
							Sizzle.error(match[0]);
						}

						// numeric x and y parameters for Expr.filter.CHILD
						// remember that false/true cast respectively to 0/1
						match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
						match[5] = +(match[7] + match[8] || match[3] === "odd");

						// other types prohibit arguments
					} else if (match[3]) {
						Sizzle.error(match[0]);
					}

					return match;
				},

				"PSEUDO": function (match) {
					var excess,
					    unquoted = !match[6] && match[2];

					if (matchExpr["CHILD"].test(match[0])) {
						return null;
					}

					// Accept quoted arguments as-is
					if (match[3]) {
						match[2] = match[4] || match[5] || "";

						// Strip excess characters from unquoted arguments
					} else if (unquoted && rpseudo.test(unquoted) && (
					// Get excess from tokenize (recursively)
					excess = tokenize(unquoted, true)) && (
					// advance to the next closing parenthesis
					excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

						// excess is a negative index
						match[0] = match[0].slice(0, excess);
						match[2] = unquoted.slice(0, excess);
					}

					// Return only captures needed by the pseudo filter method (type and argument)
					return match.slice(0, 3);
				}
			},

			filter: {

				"TAG": function (nodeNameSelector) {
					var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
					return nodeNameSelector === "*" ? function () {
						return true;
					} : function (elem) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
				},

				"CLASS": function (className) {
					var pattern = classCache[className + " "];

					return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
						return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
					});
				},

				"ATTR": function (name, operator, check) {
					return function (elem) {
						var result = Sizzle.attr(elem, name);

						if (result == null) {
							return operator === "!=";
						}
						if (!operator) {
							return true;
						}

						result += "";

						return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
					};
				},

				"CHILD": function (type, what, argument, first, last) {
					var simple = type.slice(0, 3) !== "nth",
					    forward = type.slice(-4) !== "last",
					    ofType = what === "of-type";

					return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function (elem) {
						return !!elem.parentNode;
					} : function (elem, context, xml) {
						var cache,
						    uniqueCache,
						    outerCache,
						    node,
						    nodeIndex,
						    start,
						    dir = simple !== forward ? "nextSibling" : "previousSibling",
						    parent = elem.parentNode,
						    name = ofType && elem.nodeName.toLowerCase(),
						    useCache = !xml && !ofType,
						    diff = false;

						if (parent) {

							// :(first|last|only)-(child|of-type)
							if (simple) {
								while (dir) {
									node = elem;
									while (node = node[dir]) {
										if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [forward ? parent.firstChild : parent.lastChild];

							// non-xml :nth-child(...) stores cache data on `parent`
							if (forward && useCache) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[expando] || (node[expando] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

								cache = uniqueCache[type] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = nodeIndex && cache[2];
								node = nodeIndex && parent.childNodes[nodeIndex];

								while (node = ++nodeIndex && node && node[dir] || (

								// Fallback to seeking `elem` from the start
								diff = nodeIndex = 0) || start.pop()) {

									// When found, cache indexes on `parent` and break
									if (node.nodeType === 1 && ++diff && node === elem) {
										uniqueCache[type] = [dirruns, nodeIndex, diff];
										break;
									}
								}
							} else {
								// Use previously-cached element index if available
								if (useCache) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[expando] || (node[expando] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

									cache = uniqueCache[type] || [];
									nodeIndex = cache[0] === dirruns && cache[1];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if (diff === false) {
									// Use the same loop as above to seek `elem` from the start
									while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {

										if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {

											// Cache the index of each encountered element
											if (useCache) {
												outerCache = node[expando] || (node[expando] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

												uniqueCache[type] = [dirruns, diff];
											}

											if (node === elem) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || diff % first === 0 && diff / first >= 0;
						}
					};
				},

				"PSEUDO": function (pseudo, argument) {
					// pseudo-class names are case-insensitive
					// http://www.w3.org/TR/selectors/#pseudo-classes
					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
					// Remember that setFilters inherits from pseudos
					var args,
					    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

					// The user may use createPseudo to indicate that
					// arguments are needed to create the filter function
					// just as Sizzle does
					if (fn[expando]) {
						return fn(argument);
					}

					// But maintain support for old signatures
					if (fn.length > 1) {
						args = [pseudo, pseudo, "", argument];
						return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
							var idx,
							    matched = fn(seed, argument),
							    i = matched.length;
							while (i--) {
								idx = indexOf(seed, matched[i]);
								seed[idx] = !(matches[idx] = matched[i]);
							}
						}) : function (elem) {
							return fn(elem, 0, args);
						};
					}

					return fn;
				}
			},

			pseudos: {
				// Potentially complex pseudos
				"not": markFunction(function (selector) {
					// Trim the selector passed to compile
					// to avoid treating leading and trailing
					// spaces as combinators
					var input = [],
					    results = [],
					    matcher = compile(selector.replace(rtrim, "$1"));

					return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
						var elem,
						    unmatched = matcher(seed, null, xml, []),
						    i = seed.length;

						// Match elements unmatched by `matcher`
						while (i--) {
							if (elem = unmatched[i]) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) : function (elem, context, xml) {
						input[0] = elem;
						matcher(input, null, xml, results);
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
				}),

				"has": markFunction(function (selector) {
					return function (elem) {
						return Sizzle(selector, elem).length > 0;
					};
				}),

				"contains": markFunction(function (text) {
					text = text.replace(runescape, funescape);
					return function (elem) {
						return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
					};
				}),

				// "Whether an element is represented by a :lang() selector
				// is based solely on the element's language value
				// being equal to the identifier C,
				// or beginning with the identifier C immediately followed by "-".
				// The matching of C against the element's language value is performed case-insensitively.
				// The identifier C does not have to be a valid language name."
				// http://www.w3.org/TR/selectors/#lang-pseudo
				"lang": markFunction(function (lang) {
					// lang value must be a valid identifier
					if (!ridentifier.test(lang || "")) {
						Sizzle.error("unsupported lang: " + lang);
					}
					lang = lang.replace(runescape, funescape).toLowerCase();
					return function (elem) {
						var elemLang;
						do {
							if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {

								elemLang = elemLang.toLowerCase();
								return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
							}
						} while ((elem = elem.parentNode) && elem.nodeType === 1);
						return false;
					};
				}),

				// Miscellaneous
				"target": function (elem) {
					var hash = window.location && window.location.hash;
					return hash && hash.slice(1) === elem.id;
				},

				"root": function (elem) {
					return elem === docElem;
				},

				"focus": function (elem) {
					return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
				},

				// Boolean properties
				"enabled": function (elem) {
					return elem.disabled === false;
				},

				"disabled": function (elem) {
					return elem.disabled === true;
				},

				"checked": function (elem) {
					// In CSS3, :checked should return both checked and selected elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					var nodeName = elem.nodeName.toLowerCase();
					return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
				},

				"selected": function (elem) {
					// Accessing this property makes selected-by-default
					// options in Safari work properly
					if (elem.parentNode) {
						elem.parentNode.selectedIndex;
					}

					return elem.selected === true;
				},

				// Contents
				"empty": function (elem) {
					// http://www.w3.org/TR/selectors/#empty-pseudo
					// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
					//   but not by others (comment: 8; processing instruction: 7; etc.)
					// nodeType < 6 works because attributes (2) do not appear as children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						if (elem.nodeType < 6) {
							return false;
						}
					}
					return true;
				},

				"parent": function (elem) {
					return !Expr.pseudos["empty"](elem);
				},

				// Element/input types
				"header": function (elem) {
					return rheader.test(elem.nodeName);
				},

				"input": function (elem) {
					return rinputs.test(elem.nodeName);
				},

				"button": function (elem) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === "button" || name === "button";
				},

				"text": function (elem) {
					var attr;
					return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
				},

				// Position-in-collection
				"first": createPositionalPseudo(function () {
					return [0];
				}),

				"last": createPositionalPseudo(function (matchIndexes, length) {
					return [length - 1];
				}),

				"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
					return [argument < 0 ? argument + length : argument];
				}),

				"even": createPositionalPseudo(function (matchIndexes, length) {
					var i = 0;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"odd": createPositionalPseudo(function (matchIndexes, length) {
					var i = 1;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; --i >= 0;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; ++i < length;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				})
			}
		};

		Expr.pseudos["nth"] = Expr.pseudos["eq"];

		// Add button/input type pseudos
		for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
			Expr.pseudos[i] = createInputPseudo(i);
		}
		for (i in { submit: true, reset: true }) {
			Expr.pseudos[i] = createButtonPseudo(i);
		}

		// Easy API for creating new setFilters
		function setFilters() {}
		setFilters.prototype = Expr.filters = Expr.pseudos;
		Expr.setFilters = new setFilters();

		tokenize = Sizzle.tokenize = function (selector, parseOnly) {
			var matched,
			    match,
			    tokens,
			    type,
			    soFar,
			    groups,
			    preFilters,
			    cached = tokenCache[selector + " "];

			if (cached) {
				return parseOnly ? 0 : cached.slice(0);
			}

			soFar = selector;
			groups = [];
			preFilters = Expr.preFilter;

			while (soFar) {

				// Comma and first run
				if (!matched || (match = rcomma.exec(soFar))) {
					if (match) {
						// Don't consume trailing commas as valid
						soFar = soFar.slice(match[0].length) || soFar;
					}
					groups.push(tokens = []);
				}

				matched = false;

				// Combinators
				if (match = rcombinators.exec(soFar)) {
					matched = match.shift();
					tokens.push({
						value: matched,
						// Cast descendant combinators to space
						type: match[0].replace(rtrim, " ")
					});
					soFar = soFar.slice(matched.length);
				}

				// Filters
				for (type in Expr.filter) {
					if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
						matched = match.shift();
						tokens.push({
							value: matched,
							type: type,
							matches: match
						});
						soFar = soFar.slice(matched.length);
					}
				}

				if (!matched) {
					break;
				}
			}

			// Return the length of the invalid excess
			// if we're just parsing
			// Otherwise, throw an error or return tokens
			return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
			// Cache the tokens
			tokenCache(selector, groups).slice(0);
		};

		function toSelector(tokens) {
			var i = 0,
			    len = tokens.length,
			    selector = "";
			for (; i < len; i++) {
				selector += tokens[i].value;
			}
			return selector;
		}

		function addCombinator(matcher, combinator, base) {
			var dir = combinator.dir,
			    checkNonElements = base && dir === "parentNode",
			    doneName = done++;

			return combinator.first ?
			// Check against closest ancestor/preceding element
			function (elem, context, xml) {
				while (elem = elem[dir]) {
					if (elem.nodeType === 1 || checkNonElements) {
						return matcher(elem, context, xml);
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function (elem, context, xml) {
				var oldCache,
				    uniqueCache,
				    outerCache,
				    newCache = [dirruns, doneName];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if (xml) {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							if (matcher(elem, context, xml)) {
								return true;
							}
						}
					}
				} else {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							outerCache = elem[expando] || (elem[expando] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

							if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

								// Assign to newCache so results back-propagate to previous elements
								return newCache[2] = oldCache[2];
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[dir] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if (newCache[2] = matcher(elem, context, xml)) {
									return true;
								}
							}
						}
					}
				}
			};
		}

		function elementMatcher(matchers) {
			return matchers.length > 1 ? function (elem, context, xml) {
				var i = matchers.length;
				while (i--) {
					if (!matchers[i](elem, context, xml)) {
						return false;
					}
				}
				return true;
			} : matchers[0];
		}

		function multipleContexts(selector, contexts, results) {
			var i = 0,
			    len = contexts.length;
			for (; i < len; i++) {
				Sizzle(selector, contexts[i], results);
			}
			return results;
		}

		function condense(unmatched, map, filter, context, xml) {
			var elem,
			    newUnmatched = [],
			    i = 0,
			    len = unmatched.length,
			    mapped = map != null;

			for (; i < len; i++) {
				if (elem = unmatched[i]) {
					if (!filter || filter(elem, context, xml)) {
						newUnmatched.push(elem);
						if (mapped) {
							map.push(i);
						}
					}
				}
			}

			return newUnmatched;
		}

		function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
			if (postFilter && !postFilter[expando]) {
				postFilter = setMatcher(postFilter);
			}
			if (postFinder && !postFinder[expando]) {
				postFinder = setMatcher(postFinder, postSelector);
			}
			return markFunction(function (seed, results, context, xml) {
				var temp,
				    i,
				    elem,
				    preMap = [],
				    postMap = [],
				    preexisting = results.length,


				// Get initial elements from seed or context
				elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),


				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
				    matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || (seed ? preFilter : preexisting || postFilter) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results : matcherIn;

				// Find primary matches
				if (matcher) {
					matcher(matcherIn, matcherOut, context, xml);
				}

				// Apply postFilter
				if (postFilter) {
					temp = condense(matcherOut, postMap);
					postFilter(temp, [], context, xml);

					// Un-match failing elements by moving them back to matcherIn
					i = temp.length;
					while (i--) {
						if (elem = temp[i]) {
							matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
						}
					}
				}

				if (seed) {
					if (postFinder || preFilter) {
						if (postFinder) {
							// Get the final matcherOut by condensing this intermediate into postFinder contexts
							temp = [];
							i = matcherOut.length;
							while (i--) {
								if (elem = matcherOut[i]) {
									// Restore matcherIn since elem is not yet a final match
									temp.push(matcherIn[i] = elem);
								}
							}
							postFinder(null, matcherOut = [], temp, xml);
						}

						// Move matched elements from seed to results to keep them synchronized
						i = matcherOut.length;
						while (i--) {
							if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

								seed[temp] = !(results[temp] = elem);
							}
						}
					}

					// Add elements to results, through postFinder if defined
				} else {
					matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
					if (postFinder) {
						postFinder(null, results, matcherOut, xml);
					} else {
						push.apply(results, matcherOut);
					}
				}
			});
		}

		function matcherFromTokens(tokens) {
			var checkContext,
			    matcher,
			    j,
			    len = tokens.length,
			    leadingRelative = Expr.relative[tokens[0].type],
			    implicitRelative = leadingRelative || Expr.relative[" "],
			    i = leadingRelative ? 1 : 0,


			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator(function (elem) {
				return elem === checkContext;
			}, implicitRelative, true),
			    matchAnyContext = addCombinator(function (elem) {
				return indexOf(checkContext, elem) > -1;
			}, implicitRelative, true),
			    matchers = [function (elem, context, xml) {
				var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			}];

			for (; i < len; i++) {
				if (matcher = Expr.relative[tokens[i].type]) {
					matchers = [addCombinator(elementMatcher(matchers), matcher)];
				} else {
					matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

					// Return special upon seeing a positional matcher
					if (matcher[expando]) {
						// Find the next relative operator (if any) for proper handling
						j = ++i;
						for (; j < len; j++) {
							if (Expr.relative[tokens[j].type]) {
								break;
							}
						}
						return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
					}
					matchers.push(matcher);
				}
			}

			return elementMatcher(matchers);
		}

		function matcherFromGroupMatchers(elementMatchers, setMatchers) {
			var bySet = setMatchers.length > 0,
			    byElement = elementMatchers.length > 0,
			    superMatcher = function (seed, context, xml, results, outermost) {
				var elem,
				    j,
				    matcher,
				    matchedCount = 0,
				    i = "0",
				    unmatched = seed && [],
				    setMatched = [],
				    contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]("*", outermost),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
				    len = elems.length;

				if (outermost) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for (; i !== len && (elem = elems[i]) != null; i++) {
					if (byElement && elem) {
						j = 0;
						if (!context && elem.ownerDocument !== document) {
							setDocument(elem);
							xml = !documentIsHTML;
						}
						while (matcher = elementMatchers[j++]) {
							if (matcher(elem, context || document, xml)) {
								results.push(elem);
								break;
							}
						}
						if (outermost) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if (bySet) {
						// They will have gone through all possible matchers
						if (elem = !matcher && elem) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if (seed) {
							unmatched.push(elem);
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if (bySet && i !== matchedCount) {
					j = 0;
					while (matcher = setMatchers[j++]) {
						matcher(unmatched, setMatched, context, xml);
					}

					if (seed) {
						// Reintegrate element matches to eliminate the need for sorting
						if (matchedCount > 0) {
							while (i--) {
								if (!(unmatched[i] || setMatched[i])) {
									setMatched[i] = pop.call(results);
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense(setMatched);
					}

					// Add matches to results
					push.apply(results, setMatched);

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {

						Sizzle.uniqueSort(results);
					}
				}

				// Override manipulation of globals by nested matchers
				if (outermost) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

			return bySet ? markFunction(superMatcher) : superMatcher;
		}

		compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
			var i,
			    setMatchers = [],
			    elementMatchers = [],
			    cached = compilerCache[selector + " "];

			if (!cached) {
				// Generate a function of recursive functions that can be used to check each element
				if (!match) {
					match = tokenize(selector);
				}
				i = match.length;
				while (i--) {
					cached = matcherFromTokens(match[i]);
					if (cached[expando]) {
						setMatchers.push(cached);
					} else {
						elementMatchers.push(cached);
					}
				}

				// Cache the compiled function
				cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

				// Save selector and tokenization
				cached.selector = selector;
			}
			return cached;
		};

		/**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
		select = Sizzle.select = function (selector, context, results, seed) {
			var i,
			    tokens,
			    token,
			    type,
			    find,
			    compiled = typeof selector === "function" && selector,
			    match = !seed && tokenize(selector = compiled.selector || selector);

			results = results || [];

			// Try to minimize operations if there is only one selector in the list and no seed
			// (the latter of which guarantees us context)
			if (match.length === 1) {

				// Reduce context if the leading compound selector is an ID
				tokens = match[0] = match[0].slice(0);
				if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

					context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
					if (!context) {
						return results;

						// Precompiled matchers will still verify ancestry, so step up a level
					} else if (compiled) {
						context = context.parentNode;
					}

					selector = selector.slice(tokens.shift().value.length);
				}

				// Fetch a seed set for right-to-left matching
				i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
				while (i--) {
					token = tokens[i];

					// Abort if we hit a combinator
					if (Expr.relative[type = token.type]) {
						break;
					}
					if (find = Expr.find[type]) {
						// Search, expanding context for leading sibling combinators
						if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice(i, 1);
							selector = seed.length && toSelector(tokens);
							if (!selector) {
								push.apply(results, seed);
								return results;
							}

							break;
						}
					}
				}
			}

			// Compile and execute a filtering function if one is not provided
			// Provide `match` to avoid retokenization if we modified the selector above
			(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
			return results;
		};

		// One-time assignments

		// Sort stability
		support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

		// Support: Chrome 14-35+
		// Always assume duplicates if they aren't passed to the comparison function
		support.detectDuplicates = !!hasDuplicate;

		// Initialize against the default document
		setDocument();

		// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
		// Detached nodes confoundingly follow *each other*
		support.sortDetached = assert(function (div1) {
			// Should return 1, but returns 4 (following)
			return div1.compareDocumentPosition(document.createElement("div")) & 1;
		});

		// Support: IE<8
		// Prevent attribute/property "interpolation"
		// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
		if (!assert(function (div) {
			div.innerHTML = "<a href='#'></a>";
			return div.firstChild.getAttribute("href") === "#";
		})) {
			addHandle("type|href|height|width", function (elem, name, isXML) {
				if (!isXML) {
					return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
				}
			});
		}

		// Support: IE<9
		// Use defaultValue in place of getAttribute("value")
		if (!support.attributes || !assert(function (div) {
			div.innerHTML = "<input/>";
			div.firstChild.setAttribute("value", "");
			return div.firstChild.getAttribute("value") === "";
		})) {
			addHandle("value", function (elem, name, isXML) {
				if (!isXML && elem.nodeName.toLowerCase() === "input") {
					return elem.defaultValue;
				}
			});
		}

		// Support: IE<9
		// Use getAttributeNode to fetch booleans when getAttribute lies
		if (!assert(function (div) {
			return div.getAttribute("disabled") == null;
		})) {
			addHandle(booleans, function (elem, name, isXML) {
				var val;
				if (!isXML) {
					return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
				}
			});
		}

		return Sizzle;
	}(window);

	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;

	var dir = function (elem, dir, until) {
		var matched = [],
		    truncate = until !== undefined;

		while ((elem = elem[dir]) && elem.nodeType !== 9) {
			if (elem.nodeType === 1) {
				if (truncate && jQuery(elem).is(until)) {
					break;
				}
				matched.push(elem);
			}
		}
		return matched;
	};

	var siblings = function (n, elem) {
		var matched = [];

		for (; n; n = n.nextSibling) {
			if (n.nodeType === 1 && n !== elem) {
				matched.push(n);
			}
		}

		return matched;
	};

	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;

	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow(elements, qualifier, not) {
		if (jQuery.isFunction(qualifier)) {
			return jQuery.grep(elements, function (elem, i) {
				/* jshint -W018 */
				return !!qualifier.call(elem, i, elem) !== not;
			});
		}

		if (qualifier.nodeType) {
			return jQuery.grep(elements, function (elem) {
				return elem === qualifier !== not;
			});
		}

		if (typeof qualifier === "string") {
			if (risSimple.test(qualifier)) {
				return jQuery.filter(qualifier, elements, not);
			}

			qualifier = jQuery.filter(qualifier, elements);
		}

		return jQuery.grep(elements, function (elem) {
			return indexOf.call(qualifier, elem) > -1 !== not;
		});
	}

	jQuery.filter = function (expr, elems, not) {
		var elem = elems[0];

		if (not) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
			return elem.nodeType === 1;
		}));
	};

	jQuery.fn.extend({
		find: function (selector) {
			var i,
			    len = this.length,
			    ret = [],
			    self = this;

			if (typeof selector !== "string") {
				return this.pushStack(jQuery(selector).filter(function () {
					for (i = 0; i < len; i++) {
						if (jQuery.contains(self[i], this)) {
							return true;
						}
					}
				}));
			}

			for (i = 0; i < len; i++) {
				jQuery.find(selector, self[i], ret);
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function (selector) {
			return this.pushStack(winnow(this, selector || [], false));
		},
		not: function (selector) {
			return this.pushStack(winnow(this, selector || [], true));
		},
		is: function (selector) {
			return !!winnow(this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
		}
	});

	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,


	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	    init = jQuery.fn.init = function (selector, context, root) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if (!selector) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if (typeof selector === "string") {
			if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [null, selector, null];
			} else {
				match = rquickExpr.exec(selector);
			}

			// Match html or make sure no context is specified for #id
			if (match && (match[1] || !context)) {

				// HANDLE: $(html) -> $(array)
				if (match[1]) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

					// HANDLE: $(html, props)
					if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
						for (match in context) {

							// Properties of context are called as methods if possible
							if (jQuery.isFunction(this[match])) {
								this[match](context[match]);

								// ...and otherwise set as attributes
							} else {
								this.attr(match, context[match]);
							}
						}
					}

					return this;

					// HANDLE: $(#id)
				} else {
					elem = document.getElementById(match[2]);

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if (elem && elem.parentNode) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

				// HANDLE: $(expr, $(...))
			} else if (!context || context.jquery) {
				return (context || root).find(selector);

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor(context).find(selector);
			}

			// HANDLE: $(DOMElement)
		} else if (selector.nodeType) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

			// HANDLE: $(function)
			// Shortcut for document ready
		} else if (jQuery.isFunction(selector)) {
			return root.ready !== undefined ? root.ready(selector) :

			// Execute immediately if ready is not present
			selector(jQuery);
		}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray(selector, this);
	};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery(document);

	var rparentsprev = /^(?:parents|prev(?:Until|All))/,


	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

	jQuery.fn.extend({
		has: function (target) {
			var targets = jQuery(target, this),
			    l = targets.length;

			return this.filter(function () {
				var i = 0;
				for (; i < l; i++) {
					if (jQuery.contains(this, targets[i])) {
						return true;
					}
				}
			});
		},

		closest: function (selectors, context) {
			var cur,
			    i = 0,
			    l = this.length,
			    matched = [],
			    pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

			for (; i < l; i++) {
				for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

					// Always skip document fragments
					if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

						matched.push(cur);
						break;
					}
				}
			}

			return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
		},

		// Determine the position of an element within the set
		index: function (elem) {

			// No argument, return index in parent
			if (!elem) {
				return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if (typeof elem === "string") {
				return indexOf.call(jQuery(elem), this[0]);
			}

			// Locate the position of the desired element
			return indexOf.call(this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem);
		},

		add: function (selector, context) {
			return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
		},

		addBack: function (selector) {
			return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
		}
	});

	function sibling(cur, dir) {
		while ((cur = cur[dir]) && cur.nodeType !== 1) {}
		return cur;
	}

	jQuery.each({
		parent: function (elem) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function (elem) {
			return dir(elem, "parentNode");
		},
		parentsUntil: function (elem, i, until) {
			return dir(elem, "parentNode", until);
		},
		next: function (elem) {
			return sibling(elem, "nextSibling");
		},
		prev: function (elem) {
			return sibling(elem, "previousSibling");
		},
		nextAll: function (elem) {
			return dir(elem, "nextSibling");
		},
		prevAll: function (elem) {
			return dir(elem, "previousSibling");
		},
		nextUntil: function (elem, i, until) {
			return dir(elem, "nextSibling", until);
		},
		prevUntil: function (elem, i, until) {
			return dir(elem, "previousSibling", until);
		},
		siblings: function (elem) {
			return siblings((elem.parentNode || {}).firstChild, elem);
		},
		children: function (elem) {
			return siblings(elem.firstChild);
		},
		contents: function (elem) {
			return elem.contentDocument || jQuery.merge([], elem.childNodes);
		}
	}, function (name, fn) {
		jQuery.fn[name] = function (until, selector) {
			var matched = jQuery.map(this, fn, until);

			if (name.slice(-5) !== "Until") {
				selector = until;
			}

			if (selector && typeof selector === "string") {
				matched = jQuery.filter(selector, matched);
			}

			if (this.length > 1) {

				// Remove duplicates
				if (!guaranteedUnique[name]) {
					jQuery.uniqueSort(matched);
				}

				// Reverse order for parents* and prev-derivatives
				if (rparentsprev.test(name)) {
					matched.reverse();
				}
			}

			return this.pushStack(matched);
		};
	});
	var rnotwhite = /\S+/g;

	// Convert String-formatted options into Object-formatted ones
	function createOptions(options) {
		var object = {};
		jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
			object[flag] = true;
		});
		return object;
	}

	/*
  * Create a callback list using the following parameters:
  *
  *	options: an optional list of space-separated options that will change how
  *			the callback list behaves or a more traditional option object
  *
  * By default a callback list will act like an event callback list and can be
  * "fired" multiple times.
  *
  * Possible options:
  *
  *	once:			will ensure the callback list can only be fired once (like a Deferred)
  *
  *	memory:			will keep track of previous values and will call any callback added
  *					after the list has been fired right away with the latest "memorized"
  *					values (like a Deferred)
  *
  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  *
  *	stopOnFalse:	interrupt callings when a callback returns false
  *
  */
	jQuery.Callbacks = function (options) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

		var // Flag to know if list is currently firing
		firing,


		// Last fire value for non-forgettable lists
		memory,


		// Flag to know if list was already fired
		fired,


		// Flag to prevent firing
		locked,


		// Actual callback list
		list = [],


		// Queue of execution data for repeatable lists
		queue = [],


		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,


		// Fire callbacks
		fire = function () {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for (; queue.length; firingIndex = -1) {
				memory = queue.shift();
				while (++firingIndex < list.length) {

					// Run callback and check for early termination
					if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if (!options.memory) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if (locked) {

				// Keep an empty list if we have data for future add calls
				if (memory) {
					list = [];

					// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},


		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function () {
				if (list) {

					// If we have memory from a past run, we should fire after adding
					if (memory && !firing) {
						firingIndex = list.length - 1;
						queue.push(memory);
					}

					(function add(args) {
						jQuery.each(args, function (_, arg) {
							if (jQuery.isFunction(arg)) {
								if (!options.unique || !self.has(arg)) {
									list.push(arg);
								}
							} else if (arg && arg.length && jQuery.type(arg) !== "string") {

								// Inspect recursively
								add(arg);
							}
						});
					})(arguments);

					if (memory && !firing) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function () {
				jQuery.each(arguments, function (_, arg) {
					var index;
					while ((index = jQuery.inArray(arg, list, index)) > -1) {
						list.splice(index, 1);

						// Handle firing indexes
						if (index <= firingIndex) {
							firingIndex--;
						}
					}
				});
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function (fn) {
				return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function () {
				if (list) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function () {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function () {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function () {
				locked = queue = [];
				if (!memory) {
					list = memory = "";
				}
				return this;
			},
			locked: function () {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function (context, args) {
				if (!locked) {
					args = args || [];
					args = [context, args.slice ? args.slice() : args];
					queue.push(args);
					if (!firing) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function () {
				self.fireWith(this, arguments);
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function () {
				return !!fired;
			}
		};

		return self;
	};

	jQuery.extend({

		Deferred: function (func) {
			var tuples = [

			// action, add listener, listener list, final state
			["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
			    state = "pending",
			    promise = {
				state: function () {
					return state;
				},
				always: function () {
					deferred.done(arguments).fail(arguments);
					return this;
				},
				then: function () /* fnDone, fnFail, fnProgress */{
					var fns = arguments;
					return jQuery.Deferred(function (newDefer) {
						jQuery.each(tuples, function (i, tuple) {
							var fn = jQuery.isFunction(fns[i]) && fns[i];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[tuple[1]](function () {
								var returned = fn && fn.apply(this, arguments);
								if (returned && jQuery.isFunction(returned.promise)) {
									returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
								} else {
									newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
								}
							});
						});
						fns = null;
					}).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function (obj) {
					return obj != null ? jQuery.extend(obj, promise) : promise;
				}
			},
			    deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each(tuples, function (i, tuple) {
				var list = tuple[2],
				    stateString = tuple[3];

				// promise[ done | fail | progress ] = list.add
				promise[tuple[1]] = list.add;

				// Handle state
				if (stateString) {
					list.add(function () {

						// state = [ resolved | rejected ]
						state = stateString;

						// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
				}

				// deferred[ resolve | reject | notify ]
				deferred[tuple[0]] = function () {
					deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
					return this;
				};
				deferred[tuple[0] + "With"] = list.fireWith;
			});

			// Make the deferred a promise
			promise.promise(deferred);

			// Call given func if any
			if (func) {
				func.call(deferred, deferred);
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function (subordinate /* , ..., subordinateN */) {
			var i = 0,
			    resolveValues = slice.call(arguments),
			    length = resolveValues.length,


			// the count of uncompleted subordinates
			remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,


			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),


			// Update function for both resolve and progress values
			updateFunc = function (i, contexts, values) {
				return function (value) {
					contexts[i] = this;
					values[i] = arguments.length > 1 ? slice.call(arguments) : value;
					if (values === progressValues) {
						deferred.notifyWith(contexts, values);
					} else if (! --remaining) {
						deferred.resolveWith(contexts, values);
					}
				};
			},
			    progressValues,
			    progressContexts,
			    resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if (length > 1) {
				progressValues = new Array(length);
				progressContexts = new Array(length);
				resolveContexts = new Array(length);
				for (; i < length; i++) {
					if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
						resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if (!remaining) {
				deferred.resolveWith(resolveContexts, resolveValues);
			}

			return deferred.promise();
		}
	});

	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function (fn) {

		// Add the callback
		jQuery.ready.promise().done(fn);

		return this;
	};

	jQuery.extend({

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function (hold) {
			if (hold) {
				jQuery.readyWait++;
			} else {
				jQuery.ready(true);
			}
		},

		// Handle when the DOM is ready
		ready: function (wait) {

			// Abort if there are pending holds or we're already ready
			if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if (wait !== true && --jQuery.readyWait > 0) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith(document, [jQuery]);

			// Trigger any bound ready events
			if (jQuery.fn.triggerHandler) {
				jQuery(document).triggerHandler("ready");
				jQuery(document).off("ready");
			}
		}
	});

	/**
  * The ready event handler and self cleanup method
  */
	function completed() {
		document.removeEventListener("DOMContentLoaded", completed);
		window.removeEventListener("load", completed);
		jQuery.ready();
	}

	jQuery.ready.promise = function (obj) {
		if (!readyList) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout(jQuery.ready);
			} else {

				// Use the handy event callback
				document.addEventListener("DOMContentLoaded", completed);

				// A fallback to window.onload, that will always work
				window.addEventListener("load", completed);
			}
		}
		return readyList.promise(obj);
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
		var i = 0,
		    len = elems.length,
		    bulk = key == null;

		// Sets many values
		if (jQuery.type(key) === "object") {
			chainable = true;
			for (i in key) {
				access(elems, fn, i, key[i], true, emptyGet, raw);
			}

			// Sets one value
		} else if (value !== undefined) {
			chainable = true;

			if (!jQuery.isFunction(value)) {
				raw = true;
			}

			if (bulk) {

				// Bulk operations run against the entire set
				if (raw) {
					fn.call(elems, value);
					fn = null;

					// ...except when executing function values
				} else {
					bulk = fn;
					fn = function (elem, key, value) {
						return bulk.call(jQuery(elem), value);
					};
				}
			}

			if (fn) {
				for (; i < len; i++) {
					fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
				}
			}
		}

		return chainable ? elems :

		// Gets
		bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
	};
	var acceptData = function (owner) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	};

	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function (owner, initial) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if (owner.nodeType) {
				owner[this.expando] = value;

				// Otherwise secure it in a non-enumerable, non-writable property
				// configurability must be true to allow the property to be
				// deleted with the delete operator
			} else {
				Object.defineProperty(owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				});
			}
			return owner[this.expando];
		},
		cache: function (owner) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if (!acceptData(owner)) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[this.expando];

			// If not, create one
			if (!value) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if (acceptData(owner)) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if (owner.nodeType) {
						owner[this.expando] = value;

						// Otherwise secure it in a non-enumerable property
						// configurable must be true to allow the property to be
						// deleted when data is removed
					} else {
						Object.defineProperty(owner, this.expando, {
							value: value,
							configurable: true
						});
					}
				}
			}

			return value;
		},
		set: function (owner, data, value) {
			var prop,
			    cache = this.cache(owner);

			// Handle: [ owner, key, value ] args
			if (typeof data === "string") {
				cache[data] = value;

				// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for (prop in data) {
					cache[prop] = data[prop];
				}
			}
			return cache;
		},
		get: function (owner, key) {
			return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
		},
		access: function (owner, key, value) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if (key === undefined || key && typeof key === "string" && value === undefined) {

				stored = this.get(owner, key);

				return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set(owner, key, value);

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function (owner, key) {
			var i,
			    name,
			    camel,
			    cache = owner[this.expando];

			if (cache === undefined) {
				return;
			}

			if (key === undefined) {
				this.register(owner);
			} else {

				// Support array or space separated string of keys
				if (jQuery.isArray(key)) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat(key.map(jQuery.camelCase));
				} else {
					camel = jQuery.camelCase(key);

					// Try the string as a key before any manipulation
					if (key in cache) {
						name = [key, camel];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ? [name] : name.match(rnotwhite) || [];
					}
				}

				i = name.length;

				while (i--) {
					delete cache[name[i]];
				}
			}

			// Remove the expando if there's no more data
			if (key === undefined || jQuery.isEmptyObject(cache)) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if (owner.nodeType) {
					owner[this.expando] = undefined;
				} else {
					delete owner[this.expando];
				}
			}
		},
		hasData: function (owner) {
			var cache = owner[this.expando];
			return cache !== undefined && !jQuery.isEmptyObject(cache);
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();

	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	    rmultiDash = /[A-Z]/g;

	function dataAttr(elem, key, data) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if (data === undefined && elem.nodeType === 1) {
			name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
			data = elem.getAttribute(name);

			if (typeof data === "string") {
				try {
					data = data === "true" ? true : data === "false" ? false : data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
				} catch (e) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set(elem, key, data);
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function (elem) {
			return dataUser.hasData(elem) || dataPriv.hasData(elem);
		},

		data: function (elem, name, data) {
			return dataUser.access(elem, name, data);
		},

		removeData: function (elem, name) {
			dataUser.remove(elem, name);
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function (elem, name, data) {
			return dataPriv.access(elem, name, data);
		},

		_removeData: function (elem, name) {
			dataPriv.remove(elem, name);
		}
	});

	jQuery.fn.extend({
		data: function (key, value) {
			var i,
			    name,
			    data,
			    elem = this[0],
			    attrs = elem && elem.attributes;

			// Gets all values
			if (key === undefined) {
				if (this.length) {
					data = dataUser.get(elem);

					if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
						i = attrs.length;
						while (i--) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if (attrs[i]) {
								name = attrs[i].name;
								if (name.indexOf("data-") === 0) {
									name = jQuery.camelCase(name.slice(5));
									dataAttr(elem, name, data[name]);
								}
							}
						}
						dataPriv.set(elem, "hasDataAttrs", true);
					}
				}

				return data;
			}

			// Sets multiple values
			if (typeof key === "object") {
				return this.each(function () {
					dataUser.set(this, key);
				});
			}

			return access(this, function (value) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if (elem && value === undefined) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get(elem, key) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());

					if (data !== undefined) {
						return data;
					}

					camelKey = jQuery.camelCase(key);

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get(elem, camelKey);
					if (data !== undefined) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr(elem, camelKey, undefined);
					if (data !== undefined) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase(key);
				this.each(function () {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get(this, camelKey);

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set(this, camelKey, value);

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if (key.indexOf("-") > -1 && data !== undefined) {
						dataUser.set(this, key, value);
					}
				});
			}, null, value, arguments.length > 1, null, true);
		},

		removeData: function (key) {
			return this.each(function () {
				dataUser.remove(this, key);
			});
		}
	});

	jQuery.extend({
		queue: function (elem, type, data) {
			var queue;

			if (elem) {
				type = (type || "fx") + "queue";
				queue = dataPriv.get(elem, type);

				// Speed up dequeue by getting out quickly if this is just a lookup
				if (data) {
					if (!queue || jQuery.isArray(data)) {
						queue = dataPriv.access(elem, type, jQuery.makeArray(data));
					} else {
						queue.push(data);
					}
				}
				return queue || [];
			}
		},

		dequeue: function (elem, type) {
			type = type || "fx";

			var queue = jQuery.queue(elem, type),
			    startLength = queue.length,
			    fn = queue.shift(),
			    hooks = jQuery._queueHooks(elem, type),
			    next = function () {
				jQuery.dequeue(elem, type);
			};

			// If the fx queue is dequeued, always remove the progress sentinel
			if (fn === "inprogress") {
				fn = queue.shift();
				startLength--;
			}

			if (fn) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call(elem, next, hooks);
			}

			if (!startLength && hooks) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function (elem, type) {
			var key = type + "queueHooks";
			return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
				empty: jQuery.Callbacks("once memory").add(function () {
					dataPriv.remove(elem, [type + "queue", key]);
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function (type, data) {
			var setter = 2;

			if (typeof type !== "string") {
				data = type;
				type = "fx";
				setter--;
			}

			if (arguments.length < setter) {
				return jQuery.queue(this[0], type);
			}

			return data === undefined ? this : this.each(function () {
				var queue = jQuery.queue(this, type, data);

				// Ensure a hooks for this queue
				jQuery._queueHooks(this, type);

				if (type === "fx" && queue[0] !== "inprogress") {
					jQuery.dequeue(this, type);
				}
			});
		},
		dequeue: function (type) {
			return this.each(function () {
				jQuery.dequeue(this, type);
			});
		},
		clearQueue: function (type) {
			return this.queue(type || "fx", []);
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function (type, obj) {
			var tmp,
			    count = 1,
			    defer = jQuery.Deferred(),
			    elements = this,
			    i = this.length,
			    resolve = function () {
				if (! --count) {
					defer.resolveWith(elements, [elements]);
				}
			};

			if (typeof type !== "string") {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while (i--) {
				tmp = dataPriv.get(elements[i], type + "queueHooks");
				if (tmp && tmp.empty) {
					count++;
					tmp.empty.add(resolve);
				}
			}
			resolve();
			return defer.promise(obj);
		}
	});
	var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

	var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

	var cssExpand = ["Top", "Right", "Bottom", "Left"];

	var isHidden = function (elem, el) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
	};

	function adjustCSS(elem, prop, valueParts, tween) {
		var adjusted,
		    scale = 1,
		    maxIterations = 20,
		    currentValue = tween ? function () {
			return tween.cur();
		} : function () {
			return jQuery.css(elem, prop, "");
		},
		    initial = currentValue(),
		    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),


		// Starting value computation is required for potential unit mismatches
		initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

		if (initialInUnit && initialInUnit[3] !== unit) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[3];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style(elem, prop, initialInUnit + unit);

				// Update scale, tolerating zero or NaN from tween.cur()
				// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
		}

		if (valueParts) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
			if (tween) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = /^(?:checkbox|radio)$/i;

	var rtagName = /<([\w:-]+)/;

	var rscriptType = /^$|\/(?:java|ecma)script/i;

	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [1, "<select multiple='multiple'>", "</select>"],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [1, "<table>", "</table>"],
		col: [2, "<table><colgroup>", "</colgroup></table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

		_default: [0, "", ""]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	function getAll(context, tag) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];

		return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval(elems, refElements) {
		var i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
		}
	}

	var rhtml = /<|&#?\w+;/;

	function buildFragment(elems, context, scripts, selection, ignored) {
		var elem,
		    tmp,
		    tag,
		    wrap,
		    contains,
		    j,
		    fragment = context.createDocumentFragment(),
		    nodes = [],
		    i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			elem = elems[i];

			if (elem || elem === 0) {

				// Add nodes directly
				if (jQuery.type(elem) === "object") {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

					// Convert non-html into a text node
				} else if (!rhtml.test(elem)) {
					nodes.push(context.createTextNode(elem));

					// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild(context.createElement("div"));

					// Deserialize a standard representation
					tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
					wrap = wrapMap[tag] || wrapMap._default;
					tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while (j--) {
						tmp = tmp.lastChild;
					}

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, tmp.childNodes);

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while (elem = nodes[i++]) {

			// Skip elements already in the context collection (trac-4087)
			if (selection && jQuery.inArray(elem, selection) > -1) {
				if (ignored) {
					ignored.push(elem);
				}
				continue;
			}

			contains = jQuery.contains(elem.ownerDocument, elem);

			// Append to fragment
			tmp = getAll(fragment.appendChild(elem), "script");

			// Preserve script evaluation history
			if (contains) {
				setGlobalEval(tmp);
			}

			// Capture executables
			if (scripts) {
				j = 0;
				while (elem = tmp[j++]) {
					if (rscriptType.test(elem.type || "")) {
						scripts.push(elem);
					}
				}
			}
		}

		return fragment;
	}

	(function () {
		var fragment = document.createDocumentFragment(),
		    div = fragment.appendChild(document.createElement("div")),
		    input = document.createElement("input");

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute("type", "radio");
		input.setAttribute("checked", "checked");
		input.setAttribute("name", "t");

		div.appendChild(input);

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
	})();

	var rkeyEvent = /^key/,
	    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch (err) {}
	}

	function on(elem, types, selector, data, fn, one) {
		var origFn, type;

		// Types can be a map of types/handlers
		if (typeof types === "object") {

			// ( types-Object, selector, data )
			if (typeof selector !== "string") {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for (type in types) {
				on(elem, type, selector, data, types[type], one);
			}
			return elem;
		}

		if (data == null && fn == null) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if (fn == null) {
			if (typeof selector === "string") {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if (fn === false) {
			fn = returnFalse;
		} else if (!fn) {
			return elem;
		}

		if (one === 1) {
			origFn = fn;
			fn = function (event) {

				// Can use an empty set, since event contains the info
				jQuery().off(event);
				return origFn.apply(this, arguments);
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
		}
		return elem.each(function () {
			jQuery.event.add(this, types, fn, data, selector);
		});
	}

	/*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
	jQuery.event = {

		global: {},

		add: function (elem, types, handler, data, selector) {

			var handleObjIn,
			    eventHandle,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.get(elem);

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if (!elemData) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if (handler.handler) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if (!handler.guid) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if (!(events = elemData.events)) {
				events = elemData.events = {};
			}
			if (!(eventHandle = elemData.handle)) {
				eventHandle = elemData.handle = function (e) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// There *must* be a type, no attaching namespace-only handlers
				if (!type) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[type] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = (selector ? special.delegateType : special.bindType) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[type] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test(selector),
					namespace: namespaces.join(".")
				}, handleObjIn);

				// Init the event handler queue if we're the first
				if (!(handlers = events[type])) {
					handlers = events[type] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {

						if (elem.addEventListener) {
							elem.addEventListener(type, eventHandle);
						}
					}
				}

				if (special.add) {
					special.add.call(elem, handleObj);

					if (!handleObj.handler.guid) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if (selector) {
					handlers.splice(handlers.delegateCount++, 0, handleObj);
				} else {
					handlers.push(handleObj);
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[type] = true;
			}
		},

		// Detach an event or set of events from an element
		remove: function (elem, types, handler, selector, mappedTypes) {

			var j,
			    origCount,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

			if (!elemData || !(events = elemData.events)) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// Unbind all events (on this namespace, if provided) for the element
				if (!type) {
					for (type in events) {
						jQuery.event.remove(elem, type + types[t], handler, selector, true);
					}
					continue;
				}

				special = jQuery.event.special[type] || {};
				type = (selector ? special.delegateType : special.bindType) || type;
				handlers = events[type] || [];
				tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

				// Remove matching events
				origCount = j = handlers.length;
				while (j--) {
					handleObj = handlers[j];

					if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
						handlers.splice(j, 1);

						if (handleObj.selector) {
							handlers.delegateCount--;
						}
						if (special.remove) {
							special.remove.call(elem, handleObj);
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if (origCount && !handlers.length) {
					if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {

						jQuery.removeEvent(elem, type, elemData.handle);
					}

					delete events[type];
				}
			}

			// Remove data and the expando if it's no longer used
			if (jQuery.isEmptyObject(events)) {
				dataPriv.remove(elem, "handle events");
			}
		},

		dispatch: function (event) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix(event);

			var i,
			    j,
			    ret,
			    matched,
			    handleObj,
			    handlerQueue = [],
			    args = slice.call(arguments),
			    handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
			    special = jQuery.event.special[event.type] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if (special.preDispatch && special.preDispatch.call(this, event) === false) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call(this, event, handlers);

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
				event.currentTarget = matched.elem;

				j = 0;
				while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

						if (ret !== undefined) {
							if ((event.result = ret) === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if (special.postDispatch) {
				special.postDispatch.call(this, event);
			}

			return event.result;
		},

		handlers: function (event, handlers) {
			var i,
			    matches,
			    sel,
			    handleObj,
			    handlerQueue = [],
			    delegateCount = handlers.delegateCount,
			    cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {

				for (; cur !== this; cur = cur.parentNode || this) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
						matches = [];
						for (i = 0; i < delegateCount; i++) {
							handleObj = handlers[i];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if (matches[sel] === undefined) {
								matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
							}
							if (matches[sel]) {
								matches.push(handleObj);
							}
						}
						if (matches.length) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if (delegateCount < handlers.length) {
				handlerQueue.push({ elem: this, handlers: handlers.slice(delegateCount) });
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function (event, original) {

				// Add which for key events
				if (event.which == null) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
			filter: function (event, original) {
				var eventDoc,
				    doc,
				    body,
				    button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if (event.pageX == null && original.clientX != null) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
					event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if (!event.which && button !== undefined) {
					event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
				}

				return event;
			}
		},

		fix: function (event) {
			if (event[jQuery.expando]) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i,
			    prop,
			    copy,
			    type = event.type,
			    originalEvent = event,
			    fixHook = this.fixHooks[type];

			if (!fixHook) {
				this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
			}
			copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

			event = new jQuery.Event(originalEvent);

			i = copy.length;
			while (i--) {
				prop = copy[i];
				event[prop] = originalEvent[prop];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if (!event.target) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if (event.target.nodeType === 3) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function () {
					if (this !== safeActiveElement() && this.focus) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function () {
					if (this === safeActiveElement() && this.blur) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function () {
					if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function (event) {
					return jQuery.nodeName(event.target, "a");
				}
			},

			beforeunload: {
				postDispatch: function (event) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if (event.result !== undefined && event.originalEvent) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function (elem, type, handle) {

		// This "if" is needed for plain objects
		if (elem.removeEventListener) {
			elem.removeEventListener(type, handle);
		}
	};

	jQuery.Event = function (src, props) {

		// Allow instantiation without the 'new' keyword
		if (!(this instanceof jQuery.Event)) {
			return new jQuery.Event(src, props);
		}

		// Event object
		if (src && src.type) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&

			// Support: Android<4.0
			src.returnValue === false ? returnTrue : returnFalse;

			// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if (props) {
			jQuery.extend(this, props);
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[jQuery.expando] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function () {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if (e) {
				e.preventDefault();
			}
		},
		stopPropagation: function () {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if (e) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function () {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if (e) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function (orig, fix) {
		jQuery.event.special[orig] = {
			delegateType: fix,
			bindType: fix,

			handle: function (event) {
				var ret,
				    target = this,
				    related = event.relatedTarget,
				    handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if (!related || related !== target && !jQuery.contains(target, related)) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply(this, arguments);
					event.type = fix;
				}
				return ret;
			}
		};
	});

	jQuery.fn.extend({
		on: function (types, selector, data, fn) {
			return on(this, types, selector, data, fn);
		},
		one: function (types, selector, data, fn) {
			return on(this, types, selector, data, fn, 1);
		},
		off: function (types, selector, fn) {
			var handleObj, type;
			if (types && types.preventDefault && types.handleObj) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
				return this;
			}
			if (typeof types === "object") {

				// ( types-object [, selector] )
				for (type in types) {
					this.off(type, selector, types[type]);
				}
				return this;
			}
			if (selector === false || typeof selector === "function") {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if (fn === false) {
				fn = returnFalse;
			}
			return this.each(function () {
				jQuery.event.remove(this, types, fn, selector);
			});
		}
	});

	var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,


	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,


	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	    rscriptTypeMasked = /^true\/(.*)/,
	    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Manipulating tables requires a tbody
	function manipulationTarget(elem, content) {
		return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript(elem) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript(elem) {
		var match = rscriptTypeMasked.exec(elem.type);

		if (match) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	function cloneCopyEvent(src, dest) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if (dest.nodeType !== 1) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if (dataPriv.hasData(src)) {
			pdataOld = dataPriv.access(src);
			pdataCur = dataPriv.set(dest, pdataOld);
			events = pdataOld.events;

			if (events) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for (type in events) {
					for (i = 0, l = events[type].length; i < l; i++) {
						jQuery.event.add(dest, type, events[type][i]);
					}
				}
			}
		}

		// 2. Copy user data
		if (dataUser.hasData(src)) {
			udataOld = dataUser.access(src);
			udataCur = jQuery.extend({}, udataOld);

			dataUser.set(dest, udataCur);
		}
	}

	// Fix IE bugs, see support tests
	function fixInput(src, dest) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if (nodeName === "input" && rcheckableType.test(src.type)) {
			dest.checked = src.checked;

			// Fails to return the selected option to the default selected state when cloning options
		} else if (nodeName === "input" || nodeName === "textarea") {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip(collection, args, callback, ignored) {

		// Flatten any nested arrays
		args = concat.apply([], args);

		var fragment,
		    first,
		    scripts,
		    hasScripts,
		    node,
		    doc,
		    i = 0,
		    l = collection.length,
		    iNoClone = l - 1,
		    value = args[0],
		    isFunction = jQuery.isFunction(value);

		// We can't cloneNode fragments that contain checked, in WebKit
		if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
			return collection.each(function (index) {
				var self = collection.eq(index);
				if (isFunction) {
					args[0] = value.call(this, index, self.html());
				}
				domManip(self, args, callback, ignored);
			});
		}

		if (l) {
			fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
			first = fragment.firstChild;

			if (fragment.childNodes.length === 1) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if (first || ignored) {
				scripts = jQuery.map(getAll(fragment, "script"), disableScript);
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for (; i < l; i++) {
					node = fragment;

					if (i !== iNoClone) {
						node = jQuery.clone(node, true, true);

						// Keep references to cloned scripts for later restoration
						if (hasScripts) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(scripts, getAll(node, "script"));
						}
					}

					callback.call(collection[i], node, i);
				}

				if (hasScripts) {
					doc = scripts[scripts.length - 1].ownerDocument;

					// Reenable scripts
					jQuery.map(scripts, restoreScript);

					// Evaluate executable scripts on first document insertion
					for (i = 0; i < hasScripts; i++) {
						node = scripts[i];
						if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {

							if (node.src) {

								// Optional AJAX dependency, but won't run scripts if not present
								if (jQuery._evalUrl) {
									jQuery._evalUrl(node.src);
								}
							} else {
								jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove(elem, selector, keepData) {
		var node,
		    nodes = selector ? jQuery.filter(selector, elem) : elem,
		    i = 0;

		for (; (node = nodes[i]) != null; i++) {
			if (!keepData && node.nodeType === 1) {
				jQuery.cleanData(getAll(node));
			}

			if (node.parentNode) {
				if (keepData && jQuery.contains(node.ownerDocument, node)) {
					setGlobalEval(getAll(node, "script"));
				}
				node.parentNode.removeChild(node);
			}
		}

		return elem;
	}

	jQuery.extend({
		htmlPrefilter: function (html) {
			return html.replace(rxhtmlTag, "<$1></$2>");
		},

		clone: function (elem, dataAndEvents, deepDataAndEvents) {
			var i,
			    l,
			    srcElements,
			    destElements,
			    clone = elem.cloneNode(true),
			    inPage = jQuery.contains(elem.ownerDocument, elem);

			// Fix IE cloning issues
			if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll(clone);
				srcElements = getAll(elem);

				for (i = 0, l = srcElements.length; i < l; i++) {
					fixInput(srcElements[i], destElements[i]);
				}
			}

			// Copy the events from the original to the clone
			if (dataAndEvents) {
				if (deepDataAndEvents) {
					srcElements = srcElements || getAll(elem);
					destElements = destElements || getAll(clone);

					for (i = 0, l = srcElements.length; i < l; i++) {
						cloneCopyEvent(srcElements[i], destElements[i]);
					}
				} else {
					cloneCopyEvent(elem, clone);
				}
			}

			// Preserve script evaluation history
			destElements = getAll(clone, "script");
			if (destElements.length > 0) {
				setGlobalEval(destElements, !inPage && getAll(elem, "script"));
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function (elems) {
			var data,
			    elem,
			    type,
			    special = jQuery.event.special,
			    i = 0;

			for (; (elem = elems[i]) !== undefined; i++) {
				if (acceptData(elem)) {
					if (data = elem[dataPriv.expando]) {
						if (data.events) {
							for (type in data.events) {
								if (special[type]) {
									jQuery.event.remove(elem, type);

									// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent(elem, type, data.handle);
								}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataPriv.expando] = undefined;
					}
					if (elem[dataUser.expando]) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataUser.expando] = undefined;
					}
				}
			}
		}
	});

	jQuery.fn.extend({

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function (selector) {
			return remove(this, selector, true);
		},

		remove: function (selector) {
			return remove(this, selector);
		},

		text: function (value) {
			return access(this, function (value) {
				return value === undefined ? jQuery.text(this) : this.empty().each(function () {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						this.textContent = value;
					}
				});
			}, null, value, arguments.length);
		},

		append: function () {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.appendChild(elem);
				}
			});
		},

		prepend: function () {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.insertBefore(elem, target.firstChild);
				}
			});
		},

		before: function () {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this);
				}
			});
		},

		after: function () {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this.nextSibling);
				}
			});
		},

		empty: function () {
			var elem,
			    i = 0;

			for (; (elem = this[i]) != null; i++) {
				if (elem.nodeType === 1) {

					// Prevent memory leaks
					jQuery.cleanData(getAll(elem, false));

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function (dataAndEvents, deepDataAndEvents) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function () {
				return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
			});
		},

		html: function (value) {
			return access(this, function (value) {
				var elem = this[0] || {},
				    i = 0,
				    l = this.length;

				if (value === undefined && elem.nodeType === 1) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

					value = jQuery.htmlPrefilter(value);

					try {
						for (; i < l; i++) {
							elem = this[i] || {};

							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
								elem.innerHTML = value;
							}
						}

						elem = 0;

						// If using innerHTML throws an exception, use the fallback method
					} catch (e) {}
				}

				if (elem) {
					this.empty().append(value);
				}
			}, null, value, arguments.length);
		},

		replaceWith: function () {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip(this, arguments, function (elem) {
				var parent = this.parentNode;

				if (jQuery.inArray(this, ignored) < 0) {
					jQuery.cleanData(getAll(this));
					if (parent) {
						parent.replaceChild(elem, this);
					}
				}

				// Force callback invocation
			}, ignored);
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function (name, original) {
		jQuery.fn[name] = function (selector) {
			var elems,
			    ret = [],
			    insert = jQuery(selector),
			    last = insert.length - 1,
			    i = 0;

			for (; i <= last; i++) {
				elems = i === last ? this : this.clone(true);
				jQuery(insert[i])[original](elems);

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply(ret, elems.get());
			}

			return this.pushStack(ret);
		};
	});

	var iframe,
	    elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

	/**
  * Retrieve the actual display of a element
  * @param {String} name nodeName of the element
  * @param {Object} doc Document object
  */

	// Called only from within defaultDisplay
	function actualDisplay(name, doc) {
		var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
		    display = jQuery.css(elem[0], "display");

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
  * Try to determine the default display value of an element
  * @param {String} nodeName
  */
	function defaultDisplay(nodeName) {
		var doc = document,
		    display = elemdisplay[nodeName];

		if (!display) {
			display = actualDisplay(nodeName, doc);

			// If the simple way fails, read from inside an iframe
			if (display === "none" || !display) {

				// Use the already-created iframe if possible
				iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[0].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay(nodeName, doc);
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[nodeName] = display;
		}

		return display;
	}
	var rmargin = /^margin/;

	var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	var getStyles = function (elem) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if (!view || !view.opener) {
			view = window;
		}

		return view.getComputedStyle(elem);
	};

	var swap = function (elem, options, callback, args) {
		var ret,
		    name,
		    old = {};

		// Remember the old values, and insert the new ones
		for (name in options) {
			old[name] = elem.style[name];
			elem.style[name] = options[name];
		}

		ret = callback.apply(elem, args || []);

		// Revert the old values
		for (name in options) {
			elem.style[name] = old[name];
		}

		return ret;
	};

	var documentElement = document.documentElement;

	(function () {
		var pixelPositionVal,
		    boxSizingReliableVal,
		    pixelMarginRightVal,
		    reliableMarginLeftVal,
		    container = document.createElement("div"),
		    div = document.createElement("div");

		// Finish early in limited (non-browser) environments
		if (!div.style) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode(true).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
		container.appendChild(div);

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild(container);

			var divStyle = window.getComputedStyle(div);
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild(container);
		}

		jQuery.extend(support, {
			pixelPosition: function () {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function () {
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function () {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function () {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function () {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
				    marginDiv = div.appendChild(document.createElement("div"));

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild(container);

				ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);

				documentElement.removeChild(container);
				div.removeChild(marginDiv);

				return ret;
			}
		});
	})();

	function curCSS(elem, name, computed) {
		var width,
		    minWidth,
		    maxWidth,
		    ret,
		    style = elem.style;

		computed = computed || getStyles(elem);
		ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
			ret = jQuery.style(elem, name);
		}

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if (computed) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" : ret;
	}

	function addGetHookIf(conditionFn, hookFn) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function () {
				if (conditionFn()) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply(this, arguments);
			}
		};
	}

	var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	    cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},
	    cssPrefixes = ["Webkit", "O", "Moz", "ms"],
	    emptyStyle = document.createElement("div").style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName(name) {

		// Shortcut for names that are not vendor prefixed
		if (name in emptyStyle) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
		    i = cssPrefixes.length;

		while (i--) {
			name = cssPrefixes[i] + capName;
			if (name in emptyStyle) {
				return name;
			}
		}
	}

	function setPositiveNumber(elem, value, subtract) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec(value);
		return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
	}

	function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
		var i = extra === (isBorderBox ? "border" : "content") ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,
		    val = 0;

		for (; i < 4; i += 2) {

			// Both box models exclude margin, so add it if we want it
			if (extra === "margin") {
				val += jQuery.css(elem, extra + cssExpand[i], true, styles);
			}

			if (isBorderBox) {

				// border-box includes padding, so remove it if we want content
				if (extra === "content") {
					val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
				}

				// At this point, extra isn't border nor margin, so remove border
				if (extra !== "margin") {
					val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

				// At this point, extra isn't content nor padding, so add border
				if (extra !== "padding") {
					val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			}
		}

		return val;
	}

	function getWidthOrHeight(elem, name, extra) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
		    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		    styles = getStyles(elem),
		    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

		// Support: IE11 only
		// In IE 11 fullscreen elements inside of an iframe have
		// 100x too small dimensions (gh-1764).
		if (document.msFullscreenElement && window.top !== window) {

			// Support: IE11 only
			// Running getBoundingClientRect on a disconnected node
			// in IE throws an error.
			if (elem.getClientRects().length) {
				val = Math.round(elem.getBoundingClientRect()[name] * 100);
			}
		}

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if (val <= 0 || val == null) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS(elem, name, styles);
			if (val < 0 || val == null) {
				val = elem.style[name];
			}

			// Computed unit is not pixels. Stop here and return.
			if (rnumnonpx.test(val)) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

			// Normalize "", auto, and prepare for extra
			val = parseFloat(val) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
	}

	function showHide(elements, show) {
		var display,
		    elem,
		    hidden,
		    values = [],
		    index = 0,
		    length = elements.length;

		for (; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}

			values[index] = dataPriv.get(elem, "olddisplay");
			display = elem.style.display;
			if (show) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if (!values[index] && display === "none") {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if (elem.style.display === "" && isHidden(elem)) {
					values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
				}
			} else {
				hidden = isHidden(elem);

				if (display !== "none" || !hidden) {
					dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for (index = 0; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}
			if (!show || elem.style.display === "none" || elem.style.display === "") {
				elem.style.display = show ? values[index] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function (elem, computed) {
					if (computed) {

						// We should always get a number back from opacity
						var ret = curCSS(elem, "opacity");
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function (elem, name, value, extra) {

			// Don't set styles on text and comment nodes
			if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
				return;
			}

			// Make sure that we're working with the right name
			var ret,
			    type,
			    hooks,
			    origName = jQuery.camelCase(name),
			    style = elem.style;

			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// Check if we're setting a value
			if (value !== undefined) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
					value = adjustCSS(elem, name, ret);

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if (value == null || value !== value) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if (type === "number") {
					value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
					style[name] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {

					style[name] = value;
				}
			} else {

				// If a hook was provided get the non-computed value from there
				if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[name];
			}
		},

		css: function (elem, name, extra, styles) {
			var val,
			    num,
			    hooks,
			    origName = jQuery.camelCase(name);

			// Make sure that we're working with the right name
			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// If a hook was provided get the computed value from there
			if (hooks && "get" in hooks) {
				val = hooks.get(elem, true, extra);
			}

			// Otherwise, if a way to get the computed value exists, use that
			if (val === undefined) {
				val = curCSS(elem, name, styles);
			}

			// Convert "normal" to computed value
			if (val === "normal" && name in cssNormalTransform) {
				val = cssNormalTransform[name];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if (extra === "" || extra) {
				num = parseFloat(val);
				return extra === true || isFinite(num) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each(["height", "width"], function (i, name) {
		jQuery.cssHooks[name] = {
			get: function (elem, computed, extra) {
				if (computed) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function () {
						return getWidthOrHeight(elem, name, extra);
					}) : getWidthOrHeight(elem, name, extra);
				}
			},

			set: function (elem, value, extra) {
				var matches,
				    styles = extra && getStyles(elem),
				    subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);

				// Convert to pixels if value adjustment is needed
				if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {

					elem.style[name] = value;
					value = jQuery.css(elem, name);
				}

				return setPositiveNumber(elem, value, subtract);
			}
		};
	});

	jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
		if (computed) {
			return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
				return elem.getBoundingClientRect().left;
			})) + "px";
		}
	});

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
		if (computed) {
			return swap(elem, { "display": "inline-block" }, curCSS, [elem, "marginRight"]);
		}
	});

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function (prefix, suffix) {
		jQuery.cssHooks[prefix + suffix] = {
			expand: function (value) {
				var i = 0,
				    expanded = {},


				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [value];

				for (; i < 4; i++) {
					expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
				}

				return expanded;
			}
		};

		if (!rmargin.test(prefix)) {
			jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function (name, value) {
			return access(this, function (elem, name, value) {
				var styles,
				    len,
				    map = {},
				    i = 0;

				if (jQuery.isArray(name)) {
					styles = getStyles(elem);
					len = name.length;

					for (; i < len; i++) {
						map[name[i]] = jQuery.css(elem, name[i], false, styles);
					}

					return map;
				}

				return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
			}, name, value, arguments.length > 1);
		},
		show: function () {
			return showHide(this, true);
		},
		hide: function () {
			return showHide(this);
		},
		toggle: function (state) {
			if (typeof state === "boolean") {
				return state ? this.show() : this.hide();
			}

			return this.each(function () {
				if (isHidden(this)) {
					jQuery(this).show();
				} else {
					jQuery(this).hide();
				}
			});
		}
	});

	function Tween(elem, options, prop, end, easing) {
		return new Tween.prototype.init(elem, options, prop, end, easing);
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function (elem, options, prop, end, easing, unit) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
		},
		cur: function () {
			var hooks = Tween.propHooks[this.prop];

			return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
		},
		run: function (percent) {
			var eased,
			    hooks = Tween.propHooks[this.prop];

			if (this.options.duration) {
				this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
			} else {
				this.pos = eased = percent;
			}
			this.now = (this.end - this.start) * eased + this.start;

			if (this.options.step) {
				this.options.step.call(this.elem, this.now, this);
			}

			if (hooks && hooks.set) {
				hooks.set(this);
			} else {
				Tween.propHooks._default.set(this);
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function (tween) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
					return tween.elem[tween.prop];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css(tween.elem, tween.prop, "");

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function (tween) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if (jQuery.fx.step[tween.prop]) {
					jQuery.fx.step[tween.prop](tween);
				} else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
					jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
				} else {
					tween.elem[tween.prop] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function (tween) {
			if (tween.elem.nodeType && tween.elem.parentNode) {
				tween.elem[tween.prop] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function (p) {
			return p;
		},
		swing: function (p) {
			return 0.5 - Math.cos(p * Math.PI) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};

	var fxNow,
	    timerId,
	    rfxtypes = /^(?:toggle|show|hide)$/,
	    rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout(function () {
			fxNow = undefined;
		});
		return fxNow = jQuery.now();
	}

	// Generate parameters to create a standard animation
	function genFx(type, includeWidth) {
		var which,
		    i = 0,
		    attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for (; i < 4; i += 2 - includeWidth) {
			which = cssExpand[i];
			attrs["margin" + which] = attrs["padding" + which] = type;
		}

		if (includeWidth) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween(value, prop, animation) {
		var tween,
		    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
		    index = 0,
		    length = collection.length;
		for (; index < length; index++) {
			if (tween = collection[index].call(animation, prop, value)) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter(elem, props, opts) {
		/* jshint validthis: true */
		var prop,
		    value,
		    toggle,
		    tween,
		    hooks,
		    oldfire,
		    display,
		    checkDisplay,
		    anim = this,
		    orig = {},
		    style = elem.style,
		    hidden = elem.nodeType && isHidden(elem),
		    dataShow = dataPriv.get(elem, "fxshow");

		// Handle queue: false promises
		if (!opts.queue) {
			hooks = jQuery._queueHooks(elem, "fx");
			if (hooks.unqueued == null) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function () {
					if (!hooks.unqueued) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function () {

				// Ensure the complete handler is called before this completes
				anim.always(function () {
					hooks.unqueued--;
					if (!jQuery.queue(elem, "fx").length) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Height/width overflow pass
		if (elem.nodeType === 1 && ("height" in props || "width" in props)) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [style.overflow, style.overflowX, style.overflowY];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css(elem, "display");

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

			if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
				style.display = "inline-block";
			}
		}

		if (opts.overflow) {
			style.overflow = "hidden";
			anim.always(function () {
				style.overflow = opts.overflow[0];
				style.overflowX = opts.overflow[1];
				style.overflowY = opts.overflow[2];
			});
		}

		// show/hide pass
		for (prop in props) {
			value = props[prop];
			if (rfxtypes.exec(value)) {
				delete props[prop];
				toggle = toggle || value === "toggle";
				if (value === (hidden ? "hide" : "show")) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if (value === "show" && dataShow && dataShow[prop] !== undefined) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

				// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if (!jQuery.isEmptyObject(orig)) {
			if (dataShow) {
				if ("hidden" in dataShow) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access(elem, "fxshow", {});
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if (toggle) {
				dataShow.hidden = !hidden;
			}
			if (hidden) {
				jQuery(elem).show();
			} else {
				anim.done(function () {
					jQuery(elem).hide();
				});
			}
			anim.done(function () {
				var prop;

				dataPriv.remove(elem, "fxshow");
				for (prop in orig) {
					jQuery.style(elem, prop, orig[prop]);
				}
			});
			for (prop in orig) {
				tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

				if (!(prop in dataShow)) {
					dataShow[prop] = tween.start;
					if (hidden) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

			// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
			style.display = display;
		}
	}

	function propFilter(props, specialEasing) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for (index in props) {
			name = jQuery.camelCase(index);
			easing = specialEasing[name];
			value = props[index];
			if (jQuery.isArray(value)) {
				easing = value[1];
				value = props[index] = value[0];
			}

			if (index !== name) {
				props[name] = value;
				delete props[index];
			}

			hooks = jQuery.cssHooks[name];
			if (hooks && "expand" in hooks) {
				value = hooks.expand(value);
				delete props[name];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for (index in value) {
					if (!(index in props)) {
						props[index] = value[index];
						specialEasing[index] = easing;
					}
				}
			} else {
				specialEasing[name] = easing;
			}
		}
	}

	function Animation(elem, properties, options) {
		var result,
		    stopped,
		    index = 0,
		    length = Animation.prefilters.length,
		    deferred = jQuery.Deferred().always(function () {

			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		    tick = function () {
			if (stopped) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
			    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),


			// Support: Android 2.3
			// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
			temp = remaining / animation.duration || 0,
			    percent = 1 - temp,
			    index = 0,
			    length = animation.tweens.length;

			for (; index < length; index++) {
				animation.tweens[index].run(percent);
			}

			deferred.notifyWith(elem, [animation, percent, remaining]);

			if (percent < 1 && length) {
				return remaining;
			} else {
				deferred.resolveWith(elem, [animation]);
				return false;
			}
		},
		    animation = deferred.promise({
			elem: elem,
			props: jQuery.extend({}, properties),
			opts: jQuery.extend(true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function (prop, end) {
				var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
				animation.tweens.push(tween);
				return tween;
			},
			stop: function (gotoEnd) {
				var index = 0,


				// If we are going to the end, we want to run all the tweens
				// otherwise we skip this part
				length = gotoEnd ? animation.tweens.length : 0;
				if (stopped) {
					return this;
				}
				stopped = true;
				for (; index < length; index++) {
					animation.tweens[index].run(1);
				}

				// Resolve when we played the last frame; otherwise, reject
				if (gotoEnd) {
					deferred.notifyWith(elem, [animation, 1, 0]);
					deferred.resolveWith(elem, [animation, gotoEnd]);
				} else {
					deferred.rejectWith(elem, [animation, gotoEnd]);
				}
				return this;
			}
		}),
		    props = animation.props;

		propFilter(props, animation.opts.specialEasing);

		for (; index < length; index++) {
			result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
			if (result) {
				if (jQuery.isFunction(result.stop)) {
					jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
				}
				return result;
			}
		}

		jQuery.map(props, createTween, animation);

		if (jQuery.isFunction(animation.opts.start)) {
			animation.opts.start.call(elem, animation);
		}

		jQuery.fx.timer(jQuery.extend(tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		}));

		// attach callbacks from options
		return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	}

	jQuery.Animation = jQuery.extend(Animation, {
		tweeners: {
			"*": [function (prop, value) {
				var tween = this.createTween(prop, value);
				adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
				return tween;
			}]
		},

		tweener: function (props, callback) {
			if (jQuery.isFunction(props)) {
				callback = props;
				props = ["*"];
			} else {
				props = props.match(rnotwhite);
			}

			var prop,
			    index = 0,
			    length = props.length;

			for (; index < length; index++) {
				prop = props[index];
				Animation.tweeners[prop] = Animation.tweeners[prop] || [];
				Animation.tweeners[prop].unshift(callback);
			}
		},

		prefilters: [defaultPrefilter],

		prefilter: function (callback, prepend) {
			if (prepend) {
				Animation.prefilters.unshift(callback);
			} else {
				Animation.prefilters.push(callback);
			}
		}
	});

	jQuery.speed = function (speed, easing, fn) {
		var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if (opt.queue == null || opt.queue === true) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function () {
			if (jQuery.isFunction(opt.old)) {
				opt.old.call(this);
			}

			if (opt.queue) {
				jQuery.dequeue(this, opt.queue);
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function (speed, to, easing, callback) {

			// Show any hidden elements after setting opacity to 0
			return this.filter(isHidden).css("opacity", 0).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback);
		},
		animate: function (prop, speed, easing, callback) {
			var empty = jQuery.isEmptyObject(prop),
			    optall = jQuery.speed(speed, easing, callback),
			    doAnimation = function () {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation(this, jQuery.extend({}, prop), optall);

				// Empty animations, or finishing resolves immediately
				if (empty || dataPriv.get(this, "finish")) {
					anim.stop(true);
				}
			};
			doAnimation.finish = doAnimation;

			return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
		},
		stop: function (type, clearQueue, gotoEnd) {
			var stopQueue = function (hooks) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop(gotoEnd);
			};

			if (typeof type !== "string") {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if (clearQueue && type !== false) {
				this.queue(type || "fx", []);
			}

			return this.each(function () {
				var dequeue = true,
				    index = type != null && type + "queueHooks",
				    timers = jQuery.timers,
				    data = dataPriv.get(this);

				if (index) {
					if (data[index] && data[index].stop) {
						stopQueue(data[index]);
					}
				} else {
					for (index in data) {
						if (data[index] && data[index].stop && rrun.test(index)) {
							stopQueue(data[index]);
						}
					}
				}

				for (index = timers.length; index--;) {
					if (timers[index].elem === this && (type == null || timers[index].queue === type)) {

						timers[index].anim.stop(gotoEnd);
						dequeue = false;
						timers.splice(index, 1);
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if (dequeue || !gotoEnd) {
					jQuery.dequeue(this, type);
				}
			});
		},
		finish: function (type) {
			if (type !== false) {
				type = type || "fx";
			}
			return this.each(function () {
				var index,
				    data = dataPriv.get(this),
				    queue = data[type + "queue"],
				    hooks = data[type + "queueHooks"],
				    timers = jQuery.timers,
				    length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue(this, type, []);

				if (hooks && hooks.stop) {
					hooks.stop.call(this, true);
				}

				// Look for any active animations, and finish them
				for (index = timers.length; index--;) {
					if (timers[index].elem === this && timers[index].queue === type) {
						timers[index].anim.stop(true);
						timers.splice(index, 1);
					}
				}

				// Look for any animations in the old queue and finish them
				for (index = 0; index < length; index++) {
					if (queue[index] && queue[index].finish) {
						queue[index].finish.call(this);
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each(["toggle", "show", "hide"], function (i, name) {
		var cssFn = jQuery.fn[name];
		jQuery.fn[name] = function (speed, easing, callback) {
			return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function (name, props) {
		jQuery.fn[name] = function (speed, easing, callback) {
			return this.animate(props, speed, easing, callback);
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function () {
		var timer,
		    i = 0,
		    timers = jQuery.timers;

		fxNow = jQuery.now();

		for (; i < timers.length; i++) {
			timer = timers[i];

			// Checks the timer has not already been removed
			if (!timer() && timers[i] === timer) {
				timers.splice(i--, 1);
			}
		}

		if (!timers.length) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function (timer) {
		jQuery.timers.push(timer);
		if (timer()) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function () {
		if (!timerId) {
			timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
		}
	};

	jQuery.fx.stop = function () {
		window.clearInterval(timerId);

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};

	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function (time, type) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue(type, function (next, hooks) {
			var timeout = window.setTimeout(next, time);
			hooks.stop = function () {
				window.clearTimeout(timeout);
			};
		});
	};

	(function () {
		var input = document.createElement("input"),
		    select = document.createElement("select"),
		    opt = select.appendChild(document.createElement("option"));

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement("input");
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();

	var boolHook,
	    attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function (name, value) {
			return access(this, jQuery.attr, name, value, arguments.length > 1);
		},

		removeAttr: function (name) {
			return this.each(function () {
				jQuery.removeAttr(this, name);
			});
		}
	});

	jQuery.extend({
		attr: function (elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if (typeof elem.getAttribute === "undefined") {
				return jQuery.prop(elem, name, value);
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
			}

			if (value !== undefined) {
				if (value === null) {
					jQuery.removeAttr(elem, name);
					return;
				}

				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				elem.setAttribute(name, value + "");
				return value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			ret = jQuery.find.attr(elem, name);

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function (elem, value) {
					if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
						var val = elem.value;
						elem.setAttribute("type", value);
						if (val) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function (elem, value) {
			var name,
			    propName,
			    i = 0,
			    attrNames = value && value.match(rnotwhite);

			if (attrNames && elem.nodeType === 1) {
				while (name = attrNames[i++]) {
					propName = jQuery.propFix[name] || name;

					// Boolean attributes get special treatment (#10870)
					if (jQuery.expr.match.bool.test(name)) {

						// Set corresponding property to false
						elem[propName] = false;
					}

					elem.removeAttribute(name);
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function (elem, value, name) {
			if (value === false) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr(elem, name);
			} else {
				elem.setAttribute(name, name);
			}
			return name;
		}
	};
	jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
		var getter = attrHandle[name] || jQuery.find.attr;

		attrHandle[name] = function (elem, name, isXML) {
			var ret, handle;
			if (!isXML) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[name];
				attrHandle[name] = ret;
				ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
				attrHandle[name] = handle;
			}
			return ret;
		};
	});

	var rfocusable = /^(?:input|select|textarea|button)$/i,
	    rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend({
		prop: function (name, value) {
			return access(this, jQuery.prop, name, value, arguments.length > 1);
		},

		removeProp: function (name) {
			return this.each(function () {
				delete this[jQuery.propFix[name] || name];
			});
		}
	});

	jQuery.extend({
		prop: function (elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

				// Fix name and attach hooks
				name = jQuery.propFix[name] || name;
				hooks = jQuery.propHooks[name];
			}

			if (value !== undefined) {
				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				return elem[name] = value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			return elem[name];
		},

		propHooks: {
			tabIndex: {
				get: function (elem) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr(elem, "tabindex");

					return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	});

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if (!support.optSelected) {
		jQuery.propHooks.selected = {
			get: function (elem) {
				var parent = elem.parentNode;
				if (parent && parent.parentNode) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function (elem) {
				var parent = elem.parentNode;
				if (parent) {
					parent.selectedIndex;

					if (parent.parentNode) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		jQuery.propFix[this.toLowerCase()] = this;
	});

	var rclass = /[\t\r\n\f]/g;

	function getClass(elem) {
		return elem.getAttribute && elem.getAttribute("class") || "";
	}

	jQuery.fn.extend({
		addClass: function (value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).addClass(value.call(this, j, getClass(this)));
				});
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);
					cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {
							if (cur.indexOf(" " + clazz + " ") < 0) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		removeClass: function (value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).removeClass(value.call(this, j, getClass(this)));
				});
			}

			if (!arguments.length) {
				return this.attr("class", "");
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {

							// Remove *all* instances
							while (cur.indexOf(" " + clazz + " ") > -1) {
								cur = cur.replace(" " + clazz + " ", " ");
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		toggleClass: function (value, stateVal) {
			var type = typeof value;

			if (typeof stateVal === "boolean" && type === "string") {
				return stateVal ? this.addClass(value) : this.removeClass(value);
			}

			if (jQuery.isFunction(value)) {
				return this.each(function (i) {
					jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
				});
			}

			return this.each(function () {
				var className, i, self, classNames;

				if (type === "string") {

					// Toggle individual class names
					i = 0;
					self = jQuery(this);
					classNames = value.match(rnotwhite) || [];

					while (className = classNames[i++]) {

						// Check each className given, space separated list
						if (self.hasClass(className)) {
							self.removeClass(className);
						} else {
							self.addClass(className);
						}
					}

					// Toggle whole class name
				} else if (value === undefined || type === "boolean") {
					className = getClass(this);
					if (className) {

						// Store className if set
						dataPriv.set(this, "__className__", className);
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if (this.setAttribute) {
						this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
					}
				}
			});
		},

		hasClass: function (selector) {
			var className,
			    elem,
			    i = 0;

			className = " " + selector + " ";
			while (elem = this[i++]) {
				if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
					return true;
				}
			}

			return false;
		}
	});

	var rreturn = /\r/g,
	    rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend({
		val: function (value) {
			var hooks,
			    ret,
			    isFunction,
			    elem = this[0];

			if (!arguments.length) {
				if (elem) {
					hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

					if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace(rreturn, "") :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction(value);

			return this.each(function (i) {
				var val;

				if (this.nodeType !== 1) {
					return;
				}

				if (isFunction) {
					val = value.call(this, i, jQuery(this).val());
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if (val == null) {
					val = "";
				} else if (typeof val === "number") {
					val += "";
				} else if (jQuery.isArray(val)) {
					val = jQuery.map(val, function (value) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

				// If set returns undefined, fall back to normal setting
				if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function (elem) {

					var val = jQuery.find.attr(elem, "value");
					return val != null ? val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
				}
			},
			select: {
				get: function (elem) {
					var value,
					    option,
					    options = elem.options,
					    index = elem.selectedIndex,
					    one = elem.type === "select-one" || index < 0,
					    values = one ? null : [],
					    max = one ? index + 1 : options.length,
					    i = index < 0 ? max : one ? index : 0;

					// Loop through all the selected options
					for (; i < max; i++) {
						option = options[i];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ((option.selected || i === index) && (

						// Don't return options that are disabled or in a disabled optgroup
						support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if (one) {
								return value;
							}

							// Multi-Selects return an array
							values.push(value);
						}
					}

					return values;
				},

				set: function (elem, value) {
					var optionSet,
					    option,
					    options = elem.options,
					    values = jQuery.makeArray(value),
					    i = options.length;

					while (i--) {
						option = options[i];
						if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if (!optionSet) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each(["radio", "checkbox"], function () {
		jQuery.valHooks[this] = {
			set: function (elem, value) {
				if (jQuery.isArray(value)) {
					return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
				}
			}
		};
		if (!support.checkOn) {
			jQuery.valHooks[this].get = function (elem) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});

	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend(jQuery.event, {

		trigger: function (event, data, elem, onlyHandlers) {

			var i,
			    cur,
			    tmp,
			    bubbleType,
			    ontype,
			    handle,
			    special,
			    eventPath = [elem || document],
			    type = hasOwn.call(event, "type") ? event.type : event,
			    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if (elem.nodeType === 3 || elem.nodeType === 8) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if (rfocusMorph.test(type + jQuery.event.triggered)) {
				return;
			}

			if (type.indexOf(".") > -1) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if (!event.target) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ? [event] : jQuery.makeArray(data, [event]);

			// Allow special events to draw outside the lines
			special = jQuery.event.special[type] || {};
			if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

				bubbleType = special.delegateType || type;
				if (!rfocusMorph.test(bubbleType + type)) {
					cur = cur.parentNode;
				}
				for (; cur; cur = cur.parentNode) {
					eventPath.push(cur);
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if (tmp === (elem.ownerDocument || document)) {
					eventPath.push(tmp.defaultView || tmp.parentWindow || window);
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

				event.type = i > 1 ? bubbleType : special.bindType || type;

				// jQuery handler
				handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
				if (handle) {
					handle.apply(cur, data);
				}

				// Native handler
				handle = ontype && cur[ontype];
				if (handle && handle.apply && acceptData(cur)) {
					event.result = handle.apply(cur, data);
					if (event.result === false) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if (!onlyHandlers && !event.isDefaultPrevented()) {

				if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ontype];

						if (tmp) {
							elem[ontype] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[type]();
						jQuery.event.triggered = undefined;

						if (tmp) {
							elem[ontype] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		simulate: function (type, elem, event) {
			var e = jQuery.extend(new jQuery.Event(), event, {
				type: type,
				isSimulated: true

				// Previously, `originalEvent: {}` was set here, so stopPropagation call
				// would not be triggered on donor event, since in our own
				// jQuery.event.stopPropagation function we had a check for existence of
				// originalEvent.stopPropagation method, so, consequently it would be a noop.
				//
				// But now, this "simulate" function is used only for events
				// for which stopPropagation() is noop, so there is no need for that anymore.
				//
				// For the 1.x branch though, guard for "click" and "submit"
				// events is still used, but was moved to jQuery.event.stopPropagation function
				// because `originalEvent` should point to the original event for the constancy
				// with other events and for more focused logic
			});

			jQuery.event.trigger(e, null, elem);

			if (e.isDefaultPrevented()) {
				event.preventDefault();
			}
		}

	});

	jQuery.fn.extend({

		trigger: function (type, data) {
			return this.each(function () {
				jQuery.event.trigger(type, data, this);
			});
		},
		triggerHandler: function (type, data) {
			var elem = this[0];
			if (elem) {
				return jQuery.event.trigger(type, data, elem, true);
			}
		}
	});

	jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

		// Handle event binding
		jQuery.fn[name] = function (data, fn) {
			return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
		};
	});

	jQuery.fn.extend({
		hover: function (fnOver, fnOut) {
			return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
		}
	});

	support.focusin = "onfocusin" in window;

	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if (!support.focusin) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function (event) {
				jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
			};

			jQuery.event.special[fix] = {
				setup: function () {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix);

					if (!attaches) {
						doc.addEventListener(orig, handler, true);
					}
					dataPriv.access(doc, fix, (attaches || 0) + 1);
				},
				teardown: function () {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix) - 1;

					if (!attaches) {
						doc.removeEventListener(orig, handler, true);
						dataPriv.remove(doc, fix);
					} else {
						dataPriv.access(doc, fix, attaches);
					}
				}
			};
		});
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = /\?/;

	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function (data) {
		return JSON.parse(data + "");
	};

	// Cross-browser xml parsing
	jQuery.parseXML = function (data) {
		var xml;
		if (!data || typeof data !== "string") {
			return null;
		}

		// Support: IE9
		try {
			xml = new window.DOMParser().parseFromString(data, "text/xml");
		} catch (e) {
			xml = undefined;
		}

		if (!xml || xml.getElementsByTagName("parsererror").length) {
			jQuery.error("Invalid XML: " + data);
		}
		return xml;
	};

	var rhash = /#.*$/,
	    rts = /([?&])_=[^&]*/,
	    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,


	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	    rnoContent = /^(?:GET|HEAD)$/,
	    rprotocol = /^\/\//,


	/* Prefilters
  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  * 2) These are called:
  *    - BEFORE asking for a transport
  *    - AFTER param serialization (s.data is a string if s.processData is true)
  * 3) key is the dataType
  * 4) the catchall symbol "*" can be used
  * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  */
	prefilters = {},


	/* Transports bindings
  * 1) key is the dataType
  * 2) the catchall symbol "*" can be used
  * 3) selection will start with transport dataType and THEN go to "*" if needed
  */
	transports = {},


	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*"),


	// Anchor tag for parsing the document origin
	originAnchor = document.createElement("a");
	originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports(structure) {

		// dataTypeExpression is optional and defaults to "*"
		return function (dataTypeExpression, func) {

			if (typeof dataTypeExpression !== "string") {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
			    i = 0,
			    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

			if (jQuery.isFunction(func)) {

				// For each dataType in the dataTypeExpression
				while (dataType = dataTypes[i++]) {

					// Prepend if requested
					if (dataType[0] === "+") {
						dataType = dataType.slice(1) || "*";
						(structure[dataType] = structure[dataType] || []).unshift(func);

						// Otherwise append
					} else {
						(structure[dataType] = structure[dataType] || []).push(func);
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

		var inspected = {},
		    seekingTransport = structure === transports;

		function inspect(dataType) {
			var selected;
			inspected[dataType] = true;
			jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
				var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
				if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {

					options.dataTypes.unshift(dataTypeOrTransport);
					inspect(dataTypeOrTransport);
					return false;
				} else if (seekingTransport) {
					return !(selected = dataTypeOrTransport);
				}
			});
			return selected;
		}

		return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend(target, src) {
		var key,
		    deep,
		    flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for (key in src) {
			if (src[key] !== undefined) {
				(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
			}
		}
		if (deep) {
			jQuery.extend(true, target, deep);
		}

		return target;
	}

	/* Handles responses to an ajax request:
  * - finds the right dataType (mediates between content-type and expected dataType)
  * - returns the corresponding response
  */
	function ajaxHandleResponses(s, jqXHR, responses) {

		var ct,
		    type,
		    finalDataType,
		    firstDataType,
		    contents = s.contents,
		    dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while (dataTypes[0] === "*") {
			dataTypes.shift();
			if (ct === undefined) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if (ct) {
			for (type in contents) {
				if (contents[type] && contents[type].test(ct)) {
					dataTypes.unshift(type);
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if (dataTypes[0] in responses) {
			finalDataType = dataTypes[0];
		} else {

			// Try convertible dataTypes
			for (type in responses) {
				if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
					finalDataType = type;
					break;
				}
				if (!firstDataType) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if (finalDataType) {
			if (finalDataType !== dataTypes[0]) {
				dataTypes.unshift(finalDataType);
			}
			return responses[finalDataType];
		}
	}

	/* Chain conversions given the request and the original response
  * Also sets the responseXXX fields on the jqXHR instance
  */
	function ajaxConvert(s, response, jqXHR, isSuccess) {
		var conv2,
		    current,
		    conv,
		    tmp,
		    prev,
		    converters = {},


		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if (dataTypes[1]) {
			for (conv in s.converters) {
				converters[conv.toLowerCase()] = s.converters[conv];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while (current) {

			if (s.responseFields[current]) {
				jqXHR[s.responseFields[current]] = response;
			}

			// Apply the dataFilter if provided
			if (!prev && isSuccess && s.dataFilter) {
				response = s.dataFilter(response, s.dataType);
			}

			prev = current;
			current = dataTypes.shift();

			if (current) {

				// There's only work to do if current dataType is non-auto
				if (current === "*") {

					current = prev;

					// Convert response if prev dataType is non-auto and differs from current
				} else if (prev !== "*" && prev !== current) {

					// Seek a direct converter
					conv = converters[prev + " " + current] || converters["* " + current];

					// If none found, seek a pair
					if (!conv) {
						for (conv2 in converters) {

							// If conv2 outputs current
							tmp = conv2.split(" ");
							if (tmp[1] === current) {

								// If prev can be converted to accepted input
								conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
								if (conv) {

									// Condense equivalence converters
									if (conv === true) {
										conv = converters[conv2];

										// Otherwise, insert the intermediate dataType
									} else if (converters[conv2] !== true) {
										current = tmp[0];
										dataTypes.unshift(tmp[1]);
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if (conv !== true) {

						// Unless errors are allowed to bubble, catch and return them
						if (conv && s.throws) {
							response = conv(response);
						} else {
							try {
								response = conv(response);
							} catch (e) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test(location.protocol),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
   timeout: 0,
   data: null,
   dataType: null,
   username: null,
   password: null,
   cache: null,
   throws: false,
   traditional: false,
   headers: {},
   */

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function (target, settings) {
			return settings ?

			// Building a settings object
			ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

			// Extending ajaxSettings
			ajaxExtend(jQuery.ajaxSettings, target);
		},

		ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
		ajaxTransport: addToPrefiltersOrTransports(transports),

		// Main method
		ajax: function (url, options) {

			// If url is an object, simulate pre-1.5 signature
			if (typeof url === "object") {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,


			// URL without anti-cache param
			cacheURL,


			// Response headers
			responseHeadersString,
			    responseHeaders,


			// timeout handle
			timeoutTimer,


			// Url cleanup var
			urlAnchor,


			// To know if global events are to be dispatched
			fireGlobals,


			// Loop variable
			i,


			// Create the final options object
			s = jQuery.ajaxSetup({}, options),


			// Callbacks context
			callbackContext = s.context || s,


			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,


			// Deferreds
			deferred = jQuery.Deferred(),
			    completeDeferred = jQuery.Callbacks("once memory"),


			// Status-dependent callbacks
			statusCode = s.statusCode || {},


			// Headers (they are sent all at once)
			requestHeaders = {},
			    requestHeadersNames = {},


			// The jqXHR state
			state = 0,


			// Default abort message
			strAbort = "canceled",


			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function (key) {
					var match;
					if (state === 2) {
						if (!responseHeaders) {
							responseHeaders = {};
							while (match = rheaders.exec(responseHeadersString)) {
								responseHeaders[match[1].toLowerCase()] = match[2];
							}
						}
						match = responseHeaders[key.toLowerCase()];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function () {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function (name, value) {
					var lname = name.toLowerCase();
					if (!state) {
						name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
						requestHeaders[name] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function (type) {
					if (!state) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function (map) {
					var code;
					if (map) {
						if (state < 2) {
							for (code in map) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[code] = [statusCode[code], map[code]];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always(map[jqXHR.status]);
						}
					}
					return this;
				},

				// Cancel the request
				abort: function (statusText) {
					var finalText = statusText || strAbort;
					if (transport) {
						transport.abort(finalText);
					}
					done(0, finalText);
					return this;
				}
			};

			// Attach deferreds
			deferred.promise(jqXHR).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if (s.crossDomain == null) {
				urlAnchor = document.createElement("a");

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
				} catch (e) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if (s.data && s.processData && typeof s.data !== "string") {
				s.data = jQuery.param(s.data, s.traditional);
			}

			// Apply prefilters
			inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

			// If request was aborted inside a prefilter, stop there
			if (state === 2) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if (fireGlobals && jQuery.active++ === 0) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test(s.type);

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if (!s.hasContent) {

				// If data is available, append data to url
				if (s.data) {
					cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if (s.cache === false) {
					s.url = rts.test(cacheURL) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace(rts, "$1_=" + nonce++) :

					// Otherwise add one to the end
					cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if (s.ifModified) {
				if (jQuery.lastModified[cacheURL]) {
					jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
				}
				if (jQuery.etag[cacheURL]) {
					jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
				}
			}

			// Set the correct header, if data is being sent
			if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
				jqXHR.setRequestHeader("Content-Type", s.contentType);
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

			// Check for headers option
			for (i in s.headers) {
				jqXHR.setRequestHeader(i, s.headers[i]);
			}

			// Allow custom headers/mimetypes and early abort
			if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for (i in { success: 1, error: 1, complete: 1 }) {
				jqXHR[i](s[i]);
			}

			// Get transport
			transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

			// If no transport, we auto-abort
			if (!transport) {
				done(-1, "No Transport");
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if (fireGlobals) {
					globalEventContext.trigger("ajaxSend", [jqXHR, s]);
				}

				// If request was aborted inside ajaxSend, stop there
				if (state === 2) {
					return jqXHR;
				}

				// Timeout
				if (s.async && s.timeout > 0) {
					timeoutTimer = window.setTimeout(function () {
						jqXHR.abort("timeout");
					}, s.timeout);
				}

				try {
					state = 1;
					transport.send(requestHeaders, done);
				} catch (e) {

					// Propagate exception as error if not done
					if (state < 2) {
						done(-1, e);

						// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done(status, nativeStatusText, responses, headers) {
				var isSuccess,
				    success,
				    error,
				    response,
				    modified,
				    statusText = nativeStatusText;

				// Called once
				if (state === 2) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if (timeoutTimer) {
					window.clearTimeout(timeoutTimer);
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if (responses) {
					response = ajaxHandleResponses(s, jqXHR, responses);
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert(s, response, jqXHR, isSuccess);

				// If successful, handle type chaining
				if (isSuccess) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if (s.ifModified) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if (modified) {
							jQuery.lastModified[cacheURL] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if (modified) {
							jQuery.etag[cacheURL] = modified;
						}
					}

					// if no content
					if (status === 204 || s.type === "HEAD") {
						statusText = "nocontent";

						// if not modified
					} else if (status === 304) {
						statusText = "notmodified";

						// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if (status || !statusText) {
						statusText = "error";
						if (status < 0) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = (nativeStatusText || statusText) + "";

				// Success/Error
				if (isSuccess) {
					deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
				} else {
					deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
				}

				// Status-dependent callbacks
				jqXHR.statusCode(statusCode);
				statusCode = undefined;

				if (fireGlobals) {
					globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
				}

				// Complete
				completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

				if (fireGlobals) {
					globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

					// Handle the global AJAX counter
					if (! --jQuery.active) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function (url, data, callback) {
			return jQuery.get(url, data, callback, "json");
		},

		getScript: function (url, callback) {
			return jQuery.get(url, undefined, callback, "script");
		}
	});

	jQuery.each(["get", "post"], function (i, method) {
		jQuery[method] = function (url, data, callback, type) {

			// Shift arguments if data argument was omitted
			if (jQuery.isFunction(data)) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax(jQuery.extend({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject(url) && url));
		};
	});

	jQuery._evalUrl = function (url) {
		return jQuery.ajax({
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};

	jQuery.fn.extend({
		wrapAll: function (html) {
			var wrap;

			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapAll(html.call(this, i));
				});
			}

			if (this[0]) {

				// The elements to wrap the target around
				wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

				if (this[0].parentNode) {
					wrap.insertBefore(this[0]);
				}

				wrap.map(function () {
					var elem = this;

					while (elem.firstElementChild) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append(this);
			}

			return this;
		},

		wrapInner: function (html) {
			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapInner(html.call(this, i));
				});
			}

			return this.each(function () {
				var self = jQuery(this),
				    contents = self.contents();

				if (contents.length) {
					contents.wrapAll(html);
				} else {
					self.append(html);
				}
			});
		},

		wrap: function (html) {
			var isFunction = jQuery.isFunction(html);

			return this.each(function (i) {
				jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
			});
		},

		unwrap: function () {
			return this.parent().each(function () {
				if (!jQuery.nodeName(this, "body")) {
					jQuery(this).replaceWith(this.childNodes);
				}
			}).end();
		}
	});

	jQuery.expr.filters.hidden = function (elem) {
		return !jQuery.expr.filters.visible(elem);
	};
	jQuery.expr.filters.visible = function (elem) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};

	var r20 = /%20/g,
	    rbracket = /\[\]$/,
	    rCRLF = /\r?\n/g,
	    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	    rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams(prefix, obj, traditional, add) {
		var name;

		if (jQuery.isArray(obj)) {

			// Serialize array item.
			jQuery.each(obj, function (i, v) {
				if (traditional || rbracket.test(prefix)) {

					// Treat each array item as a scalar.
					add(prefix, v);
				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
				}
			});
		} else if (!traditional && jQuery.type(obj) === "object") {

			// Serialize object item.
			for (name in obj) {
				buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
			}
		} else {

			// Serialize scalar item.
			add(prefix, obj);
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function (a, traditional) {
		var prefix,
		    s = [],
		    add = function (key, value) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
			s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
		};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if (traditional === undefined) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {

			// Serialize the form elements
			jQuery.each(a, function () {
				add(this.name, this.value);
			});
		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for (prefix in a) {
				buildParams(prefix, a[prefix], traditional, add);
			}
		}

		// Return the resulting serialization
		return s.join("&").replace(r20, "+");
	};

	jQuery.fn.extend({
		serialize: function () {
			return jQuery.param(this.serializeArray());
		},
		serializeArray: function () {
			return this.map(function () {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop(this, "elements");
				return elements ? jQuery.makeArray(elements) : this;
			}).filter(function () {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
			}).map(function (i, elem) {
				var val = jQuery(this).val();

				return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
					return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
				}) : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
			}).get();
		}
	});

	jQuery.ajaxSettings.xhr = function () {
		try {
			return new window.XMLHttpRequest();
		} catch (e) {}
	};

	var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	    xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function (options) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if (support.cors || xhrSupported && !options.crossDomain) {
			return {
				send: function (headers, complete) {
					var i,
					    xhr = options.xhr();

					xhr.open(options.type, options.url, options.async, options.username, options.password);

					// Apply custom fields if provided
					if (options.xhrFields) {
						for (i in options.xhrFields) {
							xhr[i] = options.xhrFields[i];
						}
					}

					// Override mime type if needed
					if (options.mimeType && xhr.overrideMimeType) {
						xhr.overrideMimeType(options.mimeType);
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if (!options.crossDomain && !headers["X-Requested-With"]) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for (i in headers) {
						xhr.setRequestHeader(i, headers[i]);
					}

					// Callback
					callback = function (type) {
						return function () {
							if (callback) {
								callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if (type === "abort") {
									xhr.abort();
								} else if (type === "error") {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if (typeof xhr.status !== "number") {
										complete(0, "error");
									} else {
										complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status, xhr.statusText);
									}
								} else {
									complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback("error");

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if (xhr.onabort !== undefined) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function () {

							// Check readyState before timeout as it changes
							if (xhr.readyState === 4) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout(function () {
									if (callback) {
										errorCallback();
									}
								});
							}
						};
					}

					// Create the abort callback
					callback = callback("abort");

					try {

						// Do send the request (this may raise an exception)
						xhr.send(options.hasContent && options.data || null);
					} catch (e) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if (callback) {
							throw e;
						}
					}
				},

				abort: function () {
					if (callback) {
						callback();
					}
				}
			};
		}
	});

	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function (text) {
				jQuery.globalEval(text);
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter("script", function (s) {
		if (s.cache === undefined) {
			s.cache = false;
		}
		if (s.crossDomain) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport("script", function (s) {

		// This transport only deals with cross domain requests
		if (s.crossDomain) {
			var script, callback;
			return {
				send: function (_, complete) {
					script = jQuery("<script>").prop({
						charset: s.scriptCharset,
						src: s.url
					}).on("load error", callback = function (evt) {
						script.remove();
						callback = null;
						if (evt) {
							complete(evt.type === "error" ? 404 : 200, evt.type);
						}
					});

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild(script[0]);
				},
				abort: function () {
					if (callback) {
						callback();
					}
				}
			};
		}
	});

	var oldCallbacks = [],
	    rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function () {
			var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
			this[callback] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

		var callbackName,
		    overwritten,
		    responseContainer,
		    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if (jsonProp || s.dataTypes[0] === "jsonp") {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

			// Insert callback into url or form data
			if (jsonProp) {
				s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
			} else if (s.jsonp !== false) {
				s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function () {
				if (!responseContainer) {
					jQuery.error(callbackName + " was not called");
				}
				return responseContainer[0];
			};

			// Force json dataType
			s.dataTypes[0] = "json";

			// Install callback
			overwritten = window[callbackName];
			window[callbackName] = function () {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function () {

				// If previous value didn't exist - remove it
				if (overwritten === undefined) {
					jQuery(window).removeProp(callbackName);

					// Otherwise restore preexisting value
				} else {
					window[callbackName] = overwritten;
				}

				// Save back as free
				if (s[callbackName]) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push(callbackName);
				}

				// Call if it was a function and we have a response
				if (responseContainer && jQuery.isFunction(overwritten)) {
					overwritten(responseContainer[0]);
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});

	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function (data, context, keepScripts) {
		if (!data || typeof data !== "string") {
			return null;
		}
		if (typeof context === "boolean") {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec(data),
		    scripts = !keepScripts && [];

		// Single tag
		if (parsed) {
			return [context.createElement(parsed[1])];
		}

		parsed = buildFragment([data], context, scripts);

		if (scripts && scripts.length) {
			jQuery(scripts).remove();
		}

		return jQuery.merge([], parsed.childNodes);
	};

	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
  * Load a url into a page
  */
	jQuery.fn.load = function (url, params, callback) {
		if (typeof url !== "string" && _load) {
			return _load.apply(this, arguments);
		}

		var selector,
		    type,
		    response,
		    self = this,
		    off = url.indexOf(" ");

		if (off > -1) {
			selector = jQuery.trim(url.slice(off));
			url = url.slice(0, off);
		}

		// If it's a function
		if (jQuery.isFunction(params)) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

			// Otherwise, build a param string
		} else if (params && typeof params === "object") {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if (self.length > 0) {
			jQuery.ajax({
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			}).done(function (responseText) {

				// Save response for use in complete callback
				response = arguments;

				self.html(selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

				// Otherwise use the full result
				responseText);

				// If the request succeeds, this function gets "data", "status", "jqXHR"
				// but they are ignored because response was set above.
				// If it fails, this function gets "jqXHR", "status", "error"
			}).always(callback && function (jqXHR, status) {
				self.each(function () {
					callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
				});
			});
		}

		return this;
	};

	// Attach a bunch of functions for handling common AJAX events
	jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
		jQuery.fn[type] = function (fn) {
			return this.on(type, fn);
		};
	});

	jQuery.expr.filters.animated = function (elem) {
		return jQuery.grep(jQuery.timers, function (fn) {
			return elem === fn.elem;
		}).length;
	};

	/**
  * Gets a window from an element
  */
	function getWindow(elem) {
		return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function (elem, options, i) {
			var curPosition,
			    curLeft,
			    curCSSTop,
			    curTop,
			    curOffset,
			    curCSSLeft,
			    calculatePosition,
			    position = jQuery.css(elem, "position"),
			    curElem = jQuery(elem),
			    props = {};

			// Set position first, in-case top/left are set even on static elem
			if (position === "static") {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css(elem, "top");
			curCSSLeft = jQuery.css(elem, "left");
			calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if (calculatePosition) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat(curCSSTop) || 0;
				curLeft = parseFloat(curCSSLeft) || 0;
			}

			if (jQuery.isFunction(options)) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call(elem, i, jQuery.extend({}, curOffset));
			}

			if (options.top != null) {
				props.top = options.top - curOffset.top + curTop;
			}
			if (options.left != null) {
				props.left = options.left - curOffset.left + curLeft;
			}

			if ("using" in options) {
				options.using.call(elem, props);
			} else {
				curElem.css(props);
			}
		}
	};

	jQuery.fn.extend({
		offset: function (options) {
			if (arguments.length) {
				return options === undefined ? this : this.each(function (i) {
					jQuery.offset.setOffset(this, options, i);
				});
			}

			var docElem,
			    win,
			    elem = this[0],
			    box = { top: 0, left: 0 },
			    doc = elem && elem.ownerDocument;

			if (!doc) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if (!jQuery.contains(docElem, elem)) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow(doc);
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function () {
			if (!this[0]) {
				return;
			}

			var offsetParent,
			    offset,
			    elem = this[0],
			    parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if (jQuery.css(elem, "position") === "fixed") {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if (!jQuery.nodeName(offsetParent[0], "html")) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
				parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
				left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function () {
			return this.map(function () {
				var offsetParent = this.offsetParent;

				while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
		var top = "pageYOffset" === prop;

		jQuery.fn[method] = function (val) {
			return access(this, function (elem, method, val) {
				var win = getWindow(elem);

				if (val === undefined) {
					return win ? win[prop] : elem[method];
				}

				if (win) {
					win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
				} else {
					elem[method] = val;
				}
			}, method, val, arguments.length);
		};
	});

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each(["top", "left"], function (i, prop) {
		jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
			if (computed) {
				computed = curCSS(elem, prop);

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
			}
		});
	});

	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
		jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[funcName] = function (margin, value) {
				var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
				    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

				return access(this, function (elem, type, value) {
					var doc;

					if (jQuery.isWindow(elem)) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement["client" + name];
					}

					// Get document width or height
					if (elem.nodeType === 9) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
					}

					return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css(elem, type, extra) :

					// Set width or height on the element
					jQuery.style(elem, type, value, extra);
				}, type, chainable ? margin : undefined, chainable, null);
			};
		});
	});

	jQuery.fn.extend({

		bind: function (types, data, fn) {
			return this.on(types, null, data, fn);
		},
		unbind: function (types, fn) {
			return this.off(types, null, fn);
		},

		delegate: function (selector, types, data, fn) {
			return this.on(types, selector, data, fn);
		},
		undelegate: function (selector, types, fn) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
		},
		size: function () {
			return this.length;
		}
	});

	jQuery.fn.andSelf = jQuery.fn.addBack;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if (typeof define === "function" && define.amd) {
		define("jquery", [], function () {
			return jQuery;
		});
	}

	var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,


	// Map over the $ in case of overwrite
	_$ = window.$;

	jQuery.noConflict = function (deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}

		if (deep && window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if (!noGlobal) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
});
"use strict";

/*!
 * VERSION: 1.18.4
 * DATE: 2016-04-26
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {

	"use strict";

	_gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {

		var _slice = function (a) {
			//don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			var b = [],
			    l = a.length,
			    i;
			for (i = 0; i !== l; b.push(a[i++])) {}
			return b;
		},
		    _applyCycle = function (vars, targets, i) {
			var alt = vars.cycle,
			    p,
			    val;
			for (p in alt) {
				val = alt[p];
				vars[p] = typeof val === "function" ? val.call(targets[i], i) : val[i % val.length];
			}
			delete vars.cycle;
		},
		    TweenMax = function (target, duration, vars) {
			TweenLite.call(this, target, duration, vars);
			this._cycle = 0;
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
			this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _isSelector = TweenLiteInternals.isSelector,
		    _isArray = TweenLiteInternals.isArray,
		    p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
		    _blankArray = [];

		TweenMax.version = "1.18.4";
		p.constructor = TweenMax;
		p.kill()._gc = false;
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
		TweenMax.getTweensOf = TweenLite.getTweensOf;
		TweenMax.lagSmoothing = TweenLite.lagSmoothing;
		TweenMax.ticker = TweenLite.ticker;
		TweenMax.render = TweenLite.render;

		p.invalidate = function () {
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TweenLite.prototype.invalidate.call(this);
		};

		p.updateTo = function (vars, resetDuration) {
			var curRatio = this.ratio,
			    immediate = this.vars.immediateRender || vars.immediateRender,
			    p;
			if (resetDuration && this._startTime < this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled && this._firstPT) {
						TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration > 0.998) {
						//if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
						var prevTime = this._totalTime;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else {
						this._initted = false;
						this._init();
						if (this._time > 0 || immediate) {
							var inv = 1 / (1 - curRatio),
							    pt = this._firstPT,
							    endValue;
							while (pt) {
								endValue = pt.s + pt.c;
								pt.c *= inv;
								pt.s = endValue - pt.c;
								pt = pt._next;
							}
						}
					}
				}
			}
			return this;
		};

		p.render = function (time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) {
				//zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    prevTime = this._time,
			    prevTotalTime = this._totalTime,
			    prevCycle = this._cycle,
			    duration = this._duration,
			    prevRawPrevTime = this._rawPrevTime,
			    isComplete,
			    callback,
			    pt,
			    cycleDuration,
			    r,
			    type,
			    pow,
			    rawPrevTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = "onComplete";
					force = force || this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) {
					//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) {
						//if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause") if (prevRawPrevTime !== time) {
						//note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
			} else if (time < 0.0000001) {
				//to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = this._cycle = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTotalTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) {
						//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) {
					//if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;
				if (this._repeat !== 0) {
					cycleDuration = duration + this._repeatDelay;
					this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
					if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
						this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
					}
					this._time = this._totalTime - this._cycle * cycleDuration;
					if (this._yoyo) if ((this._cycle & 1) !== 0) {
						this._time = duration - this._time;
					}
					if (this._time > duration) {
						this._time = duration;
					} else if (this._time < 0) {
						this._time = 0;
					}
				}

				if (this._easeType) {
					r = this._time / duration;
					type = this._easeType;
					pow = this._easePower;
					if (type === 1 || type === 3 && r >= 0.5) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (this._time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - r / 2;
					}
				} else {
					this.ratio = this._ease.getRatio(this._time / duration);
				}
			}

			if (prevTime === this._time && !force && prevCycle === this._cycle) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
					//so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) {
					//immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
					//we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;
					this._totalTime = prevTotalTime;
					this._rawPrevTime = prevRawPrevTime;
					this._cycle = prevCycle;
					TweenLiteInternals.lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
				}
			}
			if (this._lazy !== false) {
				this._lazy = false;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTotalTime === 0) {
				if (this._initted === 2 && time > 0) {
					//this.invalidate();
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}

			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && this._startTime) {
					//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || callback) {
					this._callback("onUpdate");
				}
			}
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
				this._callback("onRepeat");
			}
			if (callback) if (!this._gc || force) {
				//check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
					//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
					//the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------

		TweenMax.to = function (target, duration, vars) {
			return new TweenMax(target, duration, vars);
		};

		TweenMax.from = function (target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = vars.immediateRender != false;
			return new TweenMax(target, duration, vars);
		};

		TweenMax.fromTo = function (target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return new TweenMax(target, duration, toVars);
		};

		TweenMax.staggerTo = TweenMax.allTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
			    a = [],
			    finalComplete = function () {
				if (vars.onComplete) {
					vars.onComplete.apply(vars.onCompleteScope || this, arguments);
				}
				onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
			},
			    cycle = vars.cycle,
			    fromCycle = vars.startAt && vars.startAt.cycle,
			    l,
			    copy,
			    i,
			    p;
			if (!_isArray(targets)) {
				if (typeof targets === "string") {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i <= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l && onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		};

		TweenMax.staggerFrom = TweenMax.allFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = vars.immediateRender != false;
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		TweenMax.staggerFromTo = TweenMax.allFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		TweenMax.delayedCall = function (delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, { delay: delay, onComplete: callback, onCompleteParams: params, callbackScope: scope, onReverseComplete: callback, onReverseCompleteParams: params, immediateRender: false, useFrames: useFrames, overwrite: 0 });
		};

		TweenMax.set = function (target, vars) {
			return new TweenMax(target, 0, vars);
		};

		TweenMax.isTweening = function (target) {
			return TweenLite.getTweensOf(target, true).length > 0;
		};

		var _getChildrenOf = function (timeline, includeTimelines) {
			var a = [],
			    cnt = 0,
			    tween = timeline._first;
			while (tween) {
				if (tween instanceof TweenLite) {
					a[cnt++] = tween;
				} else {
					if (includeTimelines) {
						a[cnt++] = tween;
					}
					a = a.concat(_getChildrenOf(tween, includeTimelines));
					cnt = a.length;
				}
				tween = tween._next;
			}
			return a;
		},
		    getAllTweens = TweenMax.getAllTweens = function (includeTimelines) {
			return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines));
		};

		TweenMax.killAll = function (complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens(timelines != false),
			    l = a.length,
			    allTrue = tweens && delayedCalls && timelines,
			    isDC,
			    tween,
			    i;
			for (i = 0; i < l; i++) {
				tween = a[i];
				if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		};

		TweenMax.killChildTweensOf = function (parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
			    a,
			    curParent,
			    p,
			    i,
			    l;
			if (typeof parent === "string") {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i > -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		};

		var _changePause = function (pause, tweens, delayedCalls, timelines) {
			tweens = tweens !== false;
			delayedCalls = delayedCalls !== false;
			timelines = timelines !== false;
			var a = getAllTweens(timelines),
			    allTrue = tweens && delayedCalls && timelines,
			    i = a.length,
			    isDC,
			    tween;
			while (--i > -1) {
				tween = a[i];
				if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
					tween.paused(pause);
				}
			}
		};

		TweenMax.pauseAll = function (tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		};

		TweenMax.resumeAll = function (tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		};

		TweenMax.globalTimeScale = function (value) {
			var tl = Animation._rootTimeline,
			    t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		};

		//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------

		p.progress = function (value, suppressEvents) {
			return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
		};

		p.totalProgress = function (value, suppressEvents) {
			return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
		};

		p.time = function (value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.duration = function (value) {
			if (!arguments.length) {
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}
			return Animation.prototype.duration.call(this, value);
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1));
		};

		p.repeat = function (value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function (value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function (value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		return TweenMax;
	}, true);

	/*
  * ----------------------------------------------------------------
  * TimelineLite
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function (vars) {
			SimpleTimeline.call(this, vars);
			this._labels = {};
			this.autoRemoveChildren = this.vars.autoRemoveChildren === true;
			this.smoothChildTiming = this.vars.smoothChildTiming === true;
			this._sortChildren = true;
			this._onUpdate = this.vars.onUpdate;
			var v = this.vars,
			    val,
			    p;
			for (p in v) {
				val = v[p];
				if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
					v[p] = this._swapSelfInParams(val);
				}
			}
			if (_isArray(v.tweens)) {
				this.add(v.tweens, 0, v.align, v.stagger);
			}
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _internals = TimelineLite._internals = {},
		    _isSelector = TweenLiteInternals.isSelector,
		    _isArray = TweenLiteInternals.isArray,
		    _lazyTweens = TweenLiteInternals.lazyTweens,
		    _lazyRender = TweenLiteInternals.lazyRender,
		    _globals = _gsScope._gsDefine.globals,
		    _copy = function (vars) {
			var copy = {},
			    p;
			for (p in vars) {
				copy[p] = vars[p];
			}
			return copy;
		},
		    _applyCycle = function (vars, targets, i) {
			var alt = vars.cycle,
			    p,
			    val;
			for (p in alt) {
				val = alt[p];
				vars[p] = typeof val === "function" ? val.call(targets[i], i) : val[i % val.length];
			}
			delete vars.cycle;
		},
		    _pauseCallback = _internals.pauseCallback = function () {},
		    _slice = function (a) {
			//don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			var b = [],
			    l = a.length,
			    i;
			for (i = 0; i !== l; b.push(a[i++])) {}
			return b;
		},
		    p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.18.4";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = p._hasPause = false;

		/* might use later...
  //translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
  function localToGlobal(time, animation) {
  	while (animation) {
  		time = (time / animation._timeScale) + animation._startTime;
  		animation = animation.timeline;
  	}
  	return time;
  }
  	//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
  function globalToLocal(time, animation) {
  	var scale = 1;
  	time -= localToGlobal(0, animation);
  	while (animation) {
  		scale *= animation._timeScale;
  		animation = animation.timeline;
  	}
  	return time * scale;
  }
  */

		p.to = function (target, duration, vars, position) {
			var Engine = vars.repeat && _globals.TweenMax || TweenLite;
			return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function (target, duration, vars, position) {
			return this.add((vars.repeat && _globals.TweenMax || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function (target, duration, fromVars, toVars, position) {
			var Engine = toVars.repeat && _globals.TweenMax || TweenLite;
			return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({ onComplete: onCompleteAll, onCompleteParams: onCompleteAllParams, callbackScope: onCompleteAllScope, smoothChildTiming: this.smoothChildTiming }),
			    cycle = vars.cycle,
			    copy,
			    i;
			if (typeof targets === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) {
				//senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				copy = _copy(vars);
				if (copy.startAt) {
					copy.startAt = _copy(copy.startAt);
					if (copy.startAt.cycle) {
						_applyCycle(copy.startAt, targets, i);
					}
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
				}
				tl.to(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = vars.immediateRender != false;
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function (targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function (callback, params, scope, position) {
			return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function (target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = position === this._time && !this._paused;
			}
			return this.add(new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function (vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
			    root = tl._timeline,
			    tween,
			    next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		};

		p.add = function (value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof position !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if (value instanceof Array || value && value.push && _isArray(value)) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({ tweens: child });
						}
						this.add(child, curTime);
						if (typeof child !== "string" && typeof child !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + child.totalDuration() / child._timeScale;
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof value === "string") {
					return this.addLabel(value, position);
				} else if (typeof value === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw "Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.";
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = tl.rawTime() > value._startTime; //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function (value) {
			if (value instanceof Animation) {
				this._remove(value, false);
				var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline; //now that it's removed, default it to the root timeline so that if it gets played again, it doesn't jump back into this timeline.
				value._startTime = (value._paused ? value._pauseTime : tl._time) - (!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale; //ensure that if it gets played again, the timing is correct.
				return this;
			} else if (value instanceof Array || value && value.push && _isArray(value)) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof value === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function (tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
				this._time = this.duration();
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function (value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function (value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function (tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function (label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function (position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
			t.vars.onComplete = t.vars.onReverseComplete = callback;
			t.data = "isPause";
			this._hasPause = true;
			return this.add(t, position);
		};

		p.removeLabel = function (label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function (label) {
			return this._labels[label] != null ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function (timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof offsetOrLabel === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && typeof timeOrLabel === "number" && this._labels[offsetOrLabel] == null ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof timeOrLabel === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
				//if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? this._labels[timeOrLabel] = this.duration() + offsetOrLabel : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
				timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function (position, suppressEvents) {
			return this.totalTime(typeof position === "number" ? position : this._parseTimeOrLabel(position), suppressEvents !== false);
		};

		p.stop = function () {
			return this.paused(true);
		};

		p.gotoAndPlay = function (position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function (position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function (time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    prevTime = this._time,
			    prevStart = this._startTime,
			    prevTimeScale = this._timeScale,
			    prevPaused = this._paused,
			    tween,
			    isComplete,
			    next,
			    callback,
			    internalForce,
			    pauseTween,
			    curTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time <= 0 && time >= -0.0000001 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.
			} else if (time < 0.0000001) {
				//to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || time < 0 && this._rawPrevTime >= 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						//ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) {
						//when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) {
						//if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}
			} else {

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					if (time >= prevTime) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
					}
				}

				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= curTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
				//if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) {
						//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p._hasPausedChild = function () {
			var tween = this._first;
			while (tween) {
				if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild()) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function (nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
			    tween = this._first,
			    cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function (target, nested) {
			var disabled = this._gc,
			    a = [],
			    cnt = 0,
			    tweens,
			    i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || nested && this._contains(tweens[i])) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function () {
			return this._recent;
		};

		p._contains = function (tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function (amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
			    labels = this._labels,
			    p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function (vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = !target ? this.getChildren(true, true, false) : this.getTweensOf(target),
			    i = tweens.length,
			    changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function (labels) {
			var tweens = this.getChildren(false, true, true),
			    i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function () {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function (time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
					    tween = this._last,
					    prevStart = 999999999999,
					    prev,
					    end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) {
							//in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) {
							//children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + tween._totalDuration / tween._timeScale;
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return value && this.totalDuration() ? this.timeScale(this._totalDuration / value) : this;
		};

		p.paused = function (value) {
			if (!value) {
				//if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
				    time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function () {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return tl === Animation._rootFramesTimeline;
		};

		p.rawTime = function () {
			return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
		};

		return TimelineLite;
	}, true);

	/*
  * ----------------------------------------------------------------
  * TimelineMax
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (TimelineLite, TweenLite, Ease) {

		var TimelineMax = function (vars) {
			TimelineLite.call(this, vars);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._cycle = 0;
			this._yoyo = this.vars.yoyo === true;
			this._dirty = true;
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _lazyTweens = TweenLiteInternals.lazyTweens,
		    _lazyRender = TweenLiteInternals.lazyRender,
		    _easeNone = new Ease(null, null, 1, 0),
		    p = TimelineMax.prototype = new TimelineLite();

		p.constructor = TimelineMax;
		p.kill()._gc = false;
		TimelineMax.version = "1.18.4";

		p.invalidate = function () {
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TimelineLite.prototype.invalidate.call(this);
		};

		p.addCallback = function (callback, position, params, scope) {
			return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.removeCallback = function (callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
					    i = a.length,
					    time = this._parseTimeOrLabel(position);
					while (--i > -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		};

		p.removePause = function (position) {
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);
		};

		p.tweenTo = function (position, vars) {
			vars = vars || {};
			var copy = { ease: _easeNone, useFrames: this.usesFrames(), immediateRender: false },
			    duration,
			    p,
			    t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = Math.abs(Number(copy.time) - this._time) / this._timeScale || 0.001;
			t = new TweenLite(this, duration, copy);
			copy.onStart = function () {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() && duration === t.duration()) {
					//don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale);
				}
				if (vars.onStart) {
					//in case the user had an onStart in the vars - we don't want to overwrite it.
					t._callback("onStart");
				}
			};
			return t;
		};

		p.tweenFromTo = function (fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = { onComplete: this.seek, onCompleteParams: [fromPosition], callbackScope: this };
			vars.immediateRender = vars.immediateRender !== false;
			var t = this.tweenTo(toPosition, vars);
			return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || 0.001);
		};

		p.render = function (time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    dur = this._duration,
			    prevTime = this._time,
			    prevTotalTime = this._totalTime,
			    prevStart = this._startTime,
			    prevTimeScale = this._timeScale,
			    prevRawPrevTime = this._rawPrevTime,
			    prevPaused = this._paused,
			    prevCycle = this._cycle,
			    tween,
			    isComplete,
			    next,
			    callback,
			    internalForce,
			    cycleDuration,
			    pauseTween,
			    curTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time <= 0 && time >= -0.0000001 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}
			} else if (time < 0.0000001) {
				//to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {
					this._totalTime = this._cycle = 0;
				}
				this._time = 0;
				if (prevTime !== 0 || dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || time < 0 && prevRawPrevTime >= 0) && !this._locked) {
					//edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (prevRawPrevTime >= 0 && this._first) {
						//when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = dur || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) {
						//if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}
			} else {
				if (dur === 0 && prevRawPrevTime < 0) {
					//without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
					internalForce = true;
				}
				this._time = this._rawPrevTime = time;
				if (!this._locked) {
					this._totalTime = time;
					if (this._repeat !== 0) {
						cycleDuration = dur + this._repeatDelay;
						this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						this._time = this._totalTime - this._cycle * cycleDuration;
						if (this._yoyo) if ((this._cycle & 1) !== 0) {
							this._time = dur - this._time;
						}
						if (this._time > dur) {
							this._time = dur;
							time = dur + 0.0001; //to avoid occasional floating point rounding error
						} else if (this._time < 0) {
							this._time = time = 0;
						} else {
							time = this._time;
						}
					}
				}

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					time = this._time;
					if (time >= prevTime) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
					}
				}
			}

			if (this._cycle !== prevCycle) if (!this._locked) {
				/*
    make sure children at the end/beginning of the timeline are rendered properly. If, for example,
    a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
    would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
    could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
    we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
    ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
    */
				var backwards = this._yoyo && (prevCycle & 1) !== 0,
				    wrap = backwards === (this._yoyo && (this._cycle & 1) !== 0),
				    recTotalTime = this._totalTime,
				    recCycle = this._cycle,
				    recRawPrevTime = this._rawPrevTime,
				    recTime = this._time;

				this._totalTime = prevCycle * dur;
				if (this._cycle < prevCycle) {
					backwards = !backwards;
				} else {
					this._totalTime += dur;
				}
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

				this._rawPrevTime = dur === 0 ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
				this._cycle = prevCycle;
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = backwards ? 0 : dur;
				this.render(prevTime, suppressEvents, dur === 0);
				if (!suppressEvents) if (!this._gc) {
					if (this.vars.onRepeat) {
						this._callback("onRepeat");
					}
				}
				if (prevTime !== this._time) {
					//in case there's a callback like onComplete in a nested tween/timeline that changes the playhead position, like via seek(), we should just abort.
					return;
				}
				if (wrap) {
					prevTime = backwards ? dur + 0.0001 : -0.0001;
					this.render(prevTime, true, false);
				}
				this._locked = false;
				if (this._paused && !prevPaused) {
					//if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;
				}
				this._time = recTime;
				this._totalTime = recTotalTime;
				this._cycle = recCycle;
				this._rawPrevTime = recRawPrevTime;
			}

			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
					//so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
				this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
				//if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) {
						//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p.getActive = function (nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [],
			    all = this.getChildren(nested, tweens, timelines),
			    cnt = 0,
			    l = all.length,
			    i,
			    tween;
			for (i = 0; i < l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		};

		p.getLabelAfter = function (time) {
			if (!time) if (time !== 0) {
				//faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
			    l = labels.length,
			    i;
			for (i = 0; i < l; i++) {
				if (labels[i].time > time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelBefore = function (time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
			    i = labels.length;
			while (--i > -1) {
				if (labels[i].time < time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelsArray = function () {
			var a = [],
			    cnt = 0,
			    p;
			for (p in this._labels) {
				a[cnt++] = { time: this._labels[p], name: p };
			}
			a.sort(function (a, b) {
				return a.time - b.time;
			});
			return a;
		};

		//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

		p.progress = function (value, suppressEvents) {
			return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
		};

		p.totalProgress = function (value, suppressEvents) {
			return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
				}
				return this._totalDuration;
			}
			return this._repeat === -1 || !value ? this : this.timeScale(this.totalDuration() / value);
		};

		p.time = function (value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.repeat = function (value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function (value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function (value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		p.currentLabel = function (value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		};

		return TimelineMax;
	}, true);

	/*
  * ----------------------------------------------------------------
  * BezierPlugin
  * ----------------------------------------------------------------
  */
	(function () {

		var _RAD2DEG = 180 / Math.PI,
		    _r1 = [],
		    _r2 = [],
		    _r3 = [],
		    _corProps = {},
		    _globals = _gsScope._gsDefine.globals,
		    Segment = function (a, b, c, d) {
			this.a = a;
			this.b = b;
			this.c = c;
			this.d = d;
			this.da = d - a;
			this.ca = c - a;
			this.ba = b - a;
		},
		    _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
		    cubicToQuadratic = function (a, b, c, d) {
			var q1 = { a: a },
			    q2 = {},
			    q3 = {},
			    q4 = { c: d },
			    mab = (a + b) / 2,
			    mbc = (b + c) / 2,
			    mcd = (c + d) / 2,
			    mabc = (mab + mbc) / 2,
			    mbcd = (mbc + mcd) / 2,
			    m8 = (mbcd - mabc) / 8;
			q1.b = mab + (a - mab) / 4;
			q2.b = mabc + m8;
			q1.c = q2.a = (q1.b + q2.b) / 2;
			q2.c = q3.a = (mabc + mbcd) / 2;
			q3.b = mbcd - m8;
			q4.b = mcd + (d - mcd) / 4;
			q3.c = q4.a = (q3.b + q4.b) / 2;
			return [q1, q2, q3, q4];
		},
		    _calculateControlPoints = function (a, curviness, quad, basic, correlate) {
			var l = a.length - 1,
			    ii = 0,
			    cp1 = a[0].a,
			    i,
			    p1,
			    p2,
			    p3,
			    seg,
			    m1,
			    m2,
			    mm,
			    cp2,
			    qb,
			    r1,
			    r2,
			    tl;
			for (i = 0; i < l; i++) {
				seg = a[ii];
				p1 = seg.a;
				p2 = seg.d;
				p3 = a[ii + 1].d;

				if (correlate) {
					r1 = _r1[i];
					r2 = _r2[i];
					tl = (r2 + r1) * curviness * 0.25 / (basic ? 0.5 : _r3[i] || 0.5);
					m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : r1 !== 0 ? tl / r1 : 0);
					m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : r2 !== 0 ? tl / r2 : 0);
					mm = p2 - (m1 + ((m2 - m1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));
				} else {
					m1 = p2 - (p2 - p1) * curviness * 0.5;
					m2 = p2 + (p3 - p2) * curviness * 0.5;
					mm = p2 - (m1 + m2) / 2;
				}
				m1 += mm;
				m2 += mm;

				seg.c = cp2 = m1;
				if (i !== 0) {
					seg.b = cp1;
				} else {
					seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
				}

				seg.da = p2 - p1;
				seg.ca = cp2 - p1;
				seg.ba = cp1 - p1;

				if (quad) {
					qb = cubicToQuadratic(p1, cp1, cp2, p2);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
					ii += 4;
				} else {
					ii++;
				}

				cp1 = m2;
			}
			seg = a[ii];
			seg.b = cp1;
			seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
			seg.da = seg.d - seg.a;
			seg.ca = seg.c - seg.a;
			seg.ba = cp1 - seg.a;
			if (quad) {
				qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
				a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
			}
		},
		    _parseAnchors = function (values, p, correlate, prepend) {
			var a = [],
			    l,
			    i,
			    p1,
			    p2,
			    p3,
			    tmp;
			if (prepend) {
				values = [prepend].concat(values);
				i = values.length;
				while (--i > -1) {
					if (typeof (tmp = values[i][p]) === "string") if (tmp.charAt(1) === "=") {
						values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
					}
				}
			}
			l = values.length - 2;
			if (l < 0) {
				a[0] = new Segment(values[0][p], 0, 0, values[l < -1 ? 0 : 1][p]);
				return a;
			}
			for (i = 0; i < l; i++) {
				p1 = values[i][p];
				p2 = values[i + 1][p];
				a[i] = new Segment(p1, 0, 0, p2);
				if (correlate) {
					p3 = values[i + 2][p];
					_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
					_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
				}
			}
			a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]);
			return a;
		},
		    bezierThrough = function (values, curviness, quadratic, basic, correlate, prepend) {
			var obj = {},
			    props = [],
			    first = prepend || values[0],
			    i,
			    p,
			    a,
			    j,
			    r,
			    l,
			    seamless,
			    last;
			correlate = typeof correlate === "string" ? "," + correlate + "," : _correlate;
			if (curviness == null) {
				curviness = 1;
			}
			for (p in values[0]) {
				props.push(p);
			}
			//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
			if (values.length > 1) {
				last = values[values.length - 1];
				seamless = true;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					if (Math.abs(first[p] - last[p]) > 0.05) {
						//build in a tolerance of +/-0.05 to accommodate rounding errors.
						seamless = false;
						break;
					}
				}
				if (seamless) {
					values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
					if (prepend) {
						values.unshift(prepend);
					}
					values.push(values[1]);
					prepend = values[values.length - 3];
				}
			}
			_r1.length = _r2.length = _r3.length = 0;
			i = props.length;
			while (--i > -1) {
				p = props[i];
				_corProps[p] = correlate.indexOf("," + p + ",") !== -1;
				obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
			}
			i = _r1.length;
			while (--i > -1) {
				_r1[i] = Math.sqrt(_r1[i]);
				_r2[i] = Math.sqrt(_r2[i]);
			}
			if (!basic) {
				i = props.length;
				while (--i > -1) {
					if (_corProps[p]) {
						a = obj[props[i]];
						l = a.length - 1;
						for (j = 0; j < l; j++) {
							r = a[j + 1].da / _r2[j] + a[j].da / _r1[j] || 0;
							_r3[j] = (_r3[j] || 0) + r * r;
						}
					}
				}
				i = _r3.length;
				while (--i > -1) {
					_r3[i] = Math.sqrt(_r3[i]);
				}
			}
			i = props.length;
			j = quadratic ? 4 : 1;
			while (--i > -1) {
				p = props[i];
				a = obj[p];
				_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
				if (seamless) {
					a.splice(0, j);
					a.splice(a.length - j, j);
				}
			}
			return obj;
		},
		    _parseBezierData = function (values, type, prepend) {
			type = type || "soft";
			var obj = {},
			    inc = type === "cubic" ? 3 : 2,
			    soft = type === "soft",
			    props = [],
			    a,
			    b,
			    c,
			    d,
			    cur,
			    i,
			    j,
			    l,
			    p,
			    cnt,
			    tmp;
			if (soft && prepend) {
				values = [prepend].concat(values);
			}
			if (values == null || values.length < inc + 1) {
				throw "invalid Bezier data";
			}
			for (p in values[0]) {
				props.push(p);
			}
			i = props.length;
			while (--i > -1) {
				p = props[i];
				obj[p] = cur = [];
				cnt = 0;
				l = values.length;
				for (j = 0; j < l; j++) {
					a = prepend == null ? values[j][p] : typeof (tmp = values[j][p]) === "string" && tmp.charAt(1) === "=" ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
					if (soft) if (j > 1) if (j < l - 1) {
						cur[cnt++] = (a + cur[cnt - 2]) / 2;
					}
					cur[cnt++] = a;
				}
				l = cnt - inc + 1;
				cnt = 0;
				for (j = 0; j < l; j += inc) {
					a = cur[j];
					b = cur[j + 1];
					c = cur[j + 2];
					d = inc === 2 ? 0 : cur[j + 3];
					cur[cnt++] = tmp = inc === 3 ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
				}
				cur.length = cnt;
			}
			return obj;
		},
		    _addCubicLengths = function (a, steps, resolution) {
			var inc = 1 / resolution,
			    j = a.length,
			    d,
			    d1,
			    s,
			    da,
			    ca,
			    ba,
			    p,
			    i,
			    inv,
			    bez,
			    index;
			while (--j > -1) {
				bez = a[j];
				s = bez.a;
				da = bez.d - s;
				ca = bez.c - s;
				ba = bez.b - s;
				d = d1 = 0;
				for (i = 1; i <= resolution; i++) {
					p = inc * i;
					inv = 1 - p;
					d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
					index = j * resolution + i - 1;
					steps[index] = (steps[index] || 0) + d * d;
				}
			}
		},
		    _parseLengthData = function (obj, resolution) {
			resolution = resolution >> 0 || 6;
			var a = [],
			    lengths = [],
			    d = 0,
			    total = 0,
			    threshold = resolution - 1,
			    segments = [],
			    curLS = [],
			    //current length segments array
			p,
			    i,
			    l,
			    index;
			for (p in obj) {
				_addCubicLengths(obj[p], a, resolution);
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				d += Math.sqrt(a[i]);
				index = i % resolution;
				curLS[index] = d;
				if (index === threshold) {
					total += d;
					index = i / resolution >> 0;
					segments[index] = curLS;
					lengths[index] = total;
					d = 0;
					curLS = [];
				}
			}
			return { length: total, lengths: lengths, segments: segments };
		},
		    BezierPlugin = _gsScope._gsDefine.plugin({
			propName: "bezier",
			priority: -1,
			version: "1.3.5",
			API: 2,
			global: true,

			//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function (target, vars, tween) {
				this._target = target;
				if (vars instanceof Array) {
					vars = { values: vars };
				}
				this._func = {};
				this._round = {};
				this._props = [];
				this._timeRes = vars.timeResolution == null ? 6 : parseInt(vars.timeResolution, 10);
				var values = vars.values || [],
				    first = {},
				    second = values[0],
				    autoRotate = vars.autoRotate || tween.vars.orientToBezier,
				    p,
				    isFunc,
				    i,
				    j,
				    prepend;

				this._autoRotate = autoRotate ? autoRotate instanceof Array ? autoRotate : [["x", "y", "rotation", autoRotate === true ? 0 : Number(autoRotate) || 0]] : null;
				for (p in second) {
					this._props.push(p);
				}

				i = this._props.length;
				while (--i > -1) {
					p = this._props[i];

					this._overwriteProps.push(p);
					isFunc = this._func[p] = typeof target[p] === "function";
					first[p] = !isFunc ? parseFloat(target[p]) : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]();
					if (!prepend) if (first[p] !== values[0][p]) {
						prepend = first;
					}
				}
				this._beziers = vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft" ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, vars.type === "thruBasic", vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
				this._segCount = this._beziers[p].length;

				if (this._timeRes) {
					var ld = _parseLengthData(this._beziers, this._timeRes);
					this._length = ld.length;
					this._lengths = ld.lengths;
					this._segments = ld.segments;
					this._l1 = this._li = this._s1 = this._si = 0;
					this._l2 = this._lengths[0];
					this._curSeg = this._segments[0];
					this._s2 = this._curSeg[0];
					this._prec = 1 / this._curSeg.length;
				}

				if (autoRotate = this._autoRotate) {
					this._initialRotations = [];
					if (!(autoRotate[0] instanceof Array)) {
						this._autoRotate = autoRotate = [autoRotate];
					}
					i = autoRotate.length;
					while (--i > -1) {
						for (j = 0; j < 3; j++) {
							p = autoRotate[i][j];
							this._func[p] = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)] : false;
						}
						p = autoRotate[i][2];
						this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
					}
				}
				this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
				return true;
			},

			//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
			set: function (v) {
				var segments = this._segCount,
				    func = this._func,
				    target = this._target,
				    notStart = v !== this._startRatio,
				    curIndex,
				    inv,
				    i,
				    p,
				    b,
				    t,
				    val,
				    l,
				    lengths,
				    curSeg;
				if (!this._timeRes) {
					curIndex = v < 0 ? 0 : v >= 1 ? segments - 1 : segments * v >> 0;
					t = (v - curIndex * (1 / segments)) * segments;
				} else {
					lengths = this._lengths;
					curSeg = this._curSeg;
					v *= this._length;
					i = this._li;
					//find the appropriate segment (if the currently cached one isn't correct)
					if (v > this._l2 && i < segments - 1) {
						l = segments - 1;
						while (i < l && (this._l2 = lengths[++i]) <= v) {}
						this._l1 = lengths[i - 1];
						this._li = i;
						this._curSeg = curSeg = this._segments[i];
						this._s2 = curSeg[this._s1 = this._si = 0];
					} else if (v < this._l1 && i > 0) {
						while (i > 0 && (this._l1 = lengths[--i]) >= v) {}
						if (i === 0 && v < this._l1) {
							this._l1 = 0;
						} else {
							i++;
						}
						this._l2 = lengths[i];
						this._li = i;
						this._curSeg = curSeg = this._segments[i];
						this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
						this._s2 = curSeg[this._si];
					}
					curIndex = i;
					//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
					v -= this._l1;
					i = this._si;
					if (v > this._s2 && i < curSeg.length - 1) {
						l = curSeg.length - 1;
						while (i < l && (this._s2 = curSeg[++i]) <= v) {}
						this._s1 = curSeg[i - 1];
						this._si = i;
					} else if (v < this._s1 && i > 0) {
						while (i > 0 && (this._s1 = curSeg[--i]) >= v) {}
						if (i === 0 && v < this._s1) {
							this._s1 = 0;
						} else {
							i++;
						}
						this._s2 = curSeg[i];
						this._si = i;
					}
					t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec || 0;
				}
				inv = 1 - t;

				i = this._props.length;
				while (--i > -1) {
					p = this._props[i];
					b = this._beziers[p][curIndex];
					val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
					if (this._round[p]) {
						val = Math.round(val);
					}
					if (func[p]) {
						target[p](val);
					} else {
						target[p] = val;
					}
				}

				if (this._autoRotate) {
					var ar = this._autoRotate,
					    b2,
					    x1,
					    y1,
					    x2,
					    y2,
					    add,
					    conv;
					i = ar.length;
					while (--i > -1) {
						p = ar[i][2];
						add = ar[i][3] || 0;
						conv = ar[i][4] === true ? 1 : _RAD2DEG;
						b = this._beziers[ar[i][0]];
						b2 = this._beziers[ar[i][1]];

						if (b && b2) {
							//in case one of the properties got overwritten.
							b = b[curIndex];
							b2 = b2[curIndex];

							x1 = b.a + (b.b - b.a) * t;
							x2 = b.b + (b.c - b.b) * t;
							x1 += (x2 - x1) * t;
							x2 += (b.c + (b.d - b.c) * t - x2) * t;

							y1 = b2.a + (b2.b - b2.a) * t;
							y2 = b2.b + (b2.c - b2.b) * t;
							y1 += (y2 - y1) * t;
							y2 += (b2.c + (b2.d - b2.c) * t - y2) * t;

							val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}
					}
				}
			}
		}),
		    p = BezierPlugin.prototype;

		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function (a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function () {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
			    _parseToProxy = _internals._parseToProxy,
			    _setPluginRatio = _internals._setPluginRatio,
			    CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", { parser: function (t, e, prop, cssp, pt, plugin) {
					if (e instanceof Array) {
						e = { values: e };
					}
					plugin = new BezierPlugin();
					var values = e.values,
					    l = values.length - 1,
					    pluginValues = [],
					    v = {},
					    i,
					    p,
					    data;
					if (l < 0) {
						return pt;
					}
					for (i = 0; i <= l; i++) {
						data = _parseToProxy(t, values[i], cssp, pt, plugin, l !== i);
						pluginValues[i] = data.end;
					}
					for (p in e) {
						v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
					}
					v.values = pluginValues;
					pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
					pt.data = data;
					pt.plugin = plugin;
					pt.setRatio = _setPluginRatio;
					if (v.autoRotate === 0) {
						v.autoRotate = true;
					}
					if (v.autoRotate && !(v.autoRotate instanceof Array)) {
						i = v.autoRotate === true ? 0 : Number(v.autoRotate);
						v.autoRotate = data.end.left != null ? [["left", "top", "rotation", i, false]] : data.end.x != null ? [["x", "y", "rotation", i, false]] : false;
					}
					if (v.autoRotate) {
						if (!cssp._transform) {
							cssp._enableTransforms(false);
						}
						data.autoRotate = cssp._target._gsTransform;
					}
					plugin._onInitTween(data.proxy, v, cssp._tween);
					return pt;
				} });
		};

		p._roundProps = function (lookup, value) {
			var op = this._overwriteProps,
			    i = op.length;
			while (--i > -1) {
				if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
					this._round[op[i]] = value;
				}
			}
		};

		p._kill = function (lookup) {
			var a = this._props,
			    p,
			    i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};
	})();

	/*
  * ----------------------------------------------------------------
  * CSSPlugin
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (TweenPlugin, TweenLite) {

		/** @constructor **/
		var CSSPlugin = function () {
			TweenPlugin.call(this, "css");
			this._overwriteProps.length = 0;
			this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
		},
		    _globals = _gsScope._gsDefine.globals,
		    _hasPriority,
		    //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
		_suffixMap,
		    //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
		_cs,
		    //computed style (we store this in a shared variable to conserve memory and make minification tighter
		_overwriteProps,
		    //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
		_specialProps = {},
		    p = CSSPlugin.prototype = new TweenPlugin("css");

		p.constructor = CSSPlugin;
		CSSPlugin.version = "1.18.4";
		CSSPlugin.API = 2;
		CSSPlugin.defaultTransformPerspective = 0;
		CSSPlugin.defaultSkewType = "compensated";
		CSSPlugin.defaultSmoothOrigin = true;
		p = "px"; //we'll reuse the "p" variable to keep file size down
		CSSPlugin.suffixMap = { top: p, right: p, bottom: p, left: p, width: p, height: p, fontSize: p, padding: p, margin: p, perspective: p, lineHeight: "" };

		var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
		    _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
		    _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
		    //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
		_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
		    //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
		_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
		    _opacityExp = /opacity *= *([^)]*)/i,
		    _opacityValExp = /opacity:([^;]*)/i,
		    _alphaFilterExp = /alpha\(opacity *=.+?\)/i,
		    _rgbhslExp = /^(rgb|hsl)/,
		    _capsExp = /([A-Z])/g,
		    _camelExp = /-([a-z])/gi,
		    _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
		    //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
		_camelFunc = function (s, g) {
			return g.toUpperCase();
		},
		    _horizExp = /(?:Left|Right|Width)/i,
		    _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
		    _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
		    _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi,
		    //finds any commas that are not within parenthesis
		_complexExp = /[\s,\(]/i,
		    //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
		_DEG2RAD = Math.PI / 180,
		    _RAD2DEG = 180 / Math.PI,
		    _forcePT = {},
		    _doc = document,
		    _createElement = function (type) {
			return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
		},
		    _tempDiv = _createElement("div"),
		    _tempImg = _createElement("img"),
		    _internals = CSSPlugin._internals = { _specialProps: _specialProps },
		    //provides a hook to a few internal methods that we need to access from inside other plugins
		_agent = navigator.userAgent,
		    _autoRound,
		    _reqSafariFix,
		    //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

		_isSafari,
		    _isFirefox,
		    //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
		_isSafariLT6,
		    //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
		_ieVers,
		    _supportsOpacity = function () {
			//we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
			var i = _agent.indexOf("Android"),
			    a = _createElement("a");
			_isSafari = _agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i + 8, 1)) > 3);
			_isSafariLT6 = _isSafari && Number(_agent.substr(_agent.indexOf("Version/") + 8, 1)) < 6;
			_isFirefox = _agent.indexOf("Firefox") !== -1;
			if (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(_agent)) {
				_ieVers = parseFloat(RegExp.$1);
			}
			if (!a) {
				return false;
			}
			a.style.cssText = "top:1px;opacity:.55;";
			return (/^0.55/.test(a.style.opacity)
			);
		}(),
		    _getIEOpacity = function (v) {
			return _opacityExp.test(typeof v === "string" ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
		},
		    _log = function (s) {
			//for logging messages, but in a way that won't throw errors in old versions of IE.
			if (window.console) {
				console.log(s);
			}
		},
		    _prefixCSS = "",
		    //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
		_prefix = "",
		    //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

		// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
		_checkPropPrefix = function (p, e) {
			e = e || _tempDiv;
			var s = e.style,
			    a,
			    i;
			if (s[p] !== undefined) {
				return p;
			}
			p = p.charAt(0).toUpperCase() + p.substr(1);
			a = ["O", "Moz", "ms", "Ms", "Webkit"];
			i = 5;
			while (--i > -1 && s[a[i] + p] === undefined) {}
			if (i >= 0) {
				_prefix = i === 3 ? "ms" : a[i];
				_prefixCSS = "-" + _prefix.toLowerCase() + "-";
				return _prefix + p;
			}
			return null;
		},
		    _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function () {},


		/**
   * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
   * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
   *
   * @param {!Object} t Target element whose style property you want to query
   * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
   * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
   * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
   * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
   * @return {?string} The current property value
   */
		_getStyle = CSSPlugin.getStyle = function (t, p, cs, calc, dflt) {
			var rv;
			if (!_supportsOpacity) if (p === "opacity") {
				//several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
				return _getIEOpacity(t);
			}
			if (!calc && t.style[p]) {
				rv = t.style[p];
			} else if (cs = cs || _getComputedStyle(t)) {
				rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
			} else if (t.currentStyle) {
				rv = t.currentStyle[p];
			}
			return dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto") ? dflt : rv;
		},


		/**
   * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
   * @param {!Object} t Target element
   * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
   * @param {!number} v Value
   * @param {string=} sfx Suffix (like "px" or "%" or "em")
   * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
   * @return {number} value in pixels
   */
		_convertToPixels = _internals.convertToPixels = function (t, p, v, sfx, recurse) {
			if (sfx === "px" || !sfx) {
				return v;
			}
			if (sfx === "auto" || !v) {
				return 0;
			}
			var horiz = _horizExp.test(p),
			    node = t,
			    style = _tempDiv.style,
			    neg = v < 0,
			    pix,
			    cache,
			    time;
			if (neg) {
				v = -v;
			}
			if (sfx === "%" && p.indexOf("border") !== -1) {
				pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight);
			} else {
				style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
				if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
					node = t.parentNode || _doc.body;
					cache = node._gsCache;
					time = TweenLite.ticker.frame;
					if (cache && horiz && cache.time === time) {
						//performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
						return cache.width * v / 100;
					}
					style[horiz ? "width" : "height"] = v + sfx;
				} else {
					style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx;
				}
				node.appendChild(_tempDiv);
				pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]);
				node.removeChild(_tempDiv);
				if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
					cache = node._gsCache = node._gsCache || {};
					cache.time = time;
					cache.width = pix / v * 100;
				}
				if (pix === 0 && !recurse) {
					pix = _convertToPixels(t, p, v, sfx, true);
				}
			}
			return neg ? -pix : pix;
		},
		    _calculateOffset = _internals.calculateOffset = function (t, p, cs) {
			//for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
			if (_getStyle(t, "position", cs) !== "absolute") {
				return 0;
			}
			var dim = p === "left" ? "Left" : "Top",
			    v = _getStyle(t, "margin" + dim, cs);
			return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
		},


		// @private returns at object containing ALL of the style properties in camelCase and their associated values.
		_getAllStyles = function (t, cs) {
			var s = {},
			    i,
			    tr,
			    p;
			if (cs = cs || _getComputedStyle(t, null)) {
				if (i = cs.length) {
					while (--i > -1) {
						p = cs[i];
						if (p.indexOf("-transform") === -1 || _transformPropCSS === p) {
							//Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
							s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
						}
					}
				} else {
					//some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
					for (i in cs) {
						if (i.indexOf("Transform") === -1 || _transformProp === i) {
							//Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
							s[i] = cs[i];
						}
					}
				}
			} else if (cs = t.currentStyle || t.style) {
				for (i in cs) {
					if (typeof i === "string" && s[i] === undefined) {
						s[i.replace(_camelExp, _camelFunc)] = cs[i];
					}
				}
			}
			if (!_supportsOpacity) {
				s.opacity = _getIEOpacity(t);
			}
			tr = _getTransform(t, cs, false);
			s.rotation = tr.rotation;
			s.skewX = tr.skewX;
			s.scaleX = tr.scaleX;
			s.scaleY = tr.scaleY;
			s.x = tr.x;
			s.y = tr.y;
			if (_supports3D) {
				s.z = tr.z;
				s.rotationX = tr.rotationX;
				s.rotationY = tr.rotationY;
				s.scaleZ = tr.scaleZ;
			}
			if (s.filters) {
				delete s.filters;
			}
			return s;
		},


		// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
		_cssDif = function (t, s1, s2, vars, forceLookup) {
			var difs = {},
			    style = t.style,
			    val,
			    p,
			    mpt;
			for (p in s2) {
				if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p]) if (p.indexOf("Origin") === -1) if (typeof val === "number" || typeof val === "string") {
					difs[p] = val === "auto" && (p === "left" || p === "top") ? _calculateOffset(t, p) : (val === "" || val === "auto" || val === "none") && typeof s1[p] === "string" && s1[p].replace(_NaNExp, "") !== "" ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
					if (style[p] !== undefined) {
						//for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
						mpt = new MiniPropTween(style, p, style[p], mpt);
					}
				}
			}
			if (vars) {
				for (p in vars) {
					//copy properties (except className)
					if (p !== "className") {
						difs[p] = vars[p];
					}
				}
			}
			return { difs: difs, firstMPT: mpt };
		},
		    _dimensions = { width: ["Left", "Right"], height: ["Top", "Bottom"] },
		    _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"],


		/**
   * @private Gets the width or height of an element
   * @param {!Object} t Target element
   * @param {!string} p Property name ("width" or "height")
   * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
   * @return {number} Dimension (in pixels)
   */
		_getDimension = function (t, p, cs) {
			if ((t.nodeName + "").toLowerCase() === "svg") {
				//Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
				return (cs || _getComputedStyle(t))[p] || 0;
			} else if (t.getBBox && _isSVG(t)) {
				return t.getBBox()[p] || 0;
			}
			var v = parseFloat(p === "width" ? t.offsetWidth : t.offsetHeight),
			    a = _dimensions[p],
			    i = a.length;
			cs = cs || _getComputedStyle(t, null);
			while (--i > -1) {
				v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0;
				v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0;
			}
			return v;
		},


		// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
		_parsePosition = function (v, recObj) {
			if (v === "contain" || v === "auto" || v === "auto auto") {
				return v + " ";
			}
			if (v == null || v === "") {
				//note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
				v = "0 0";
			}
			var a = v.split(" "),
			    x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0],
			    y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1],
			    i;
			if (a.length > 3 && !recObj) {
				//multiple positions
				a = v.split(", ").join(",").split(",");
				v = [];
				for (i = 0; i < a.length; i++) {
					v.push(_parsePosition(a[i]));
				}
				return v.join(",");
			}
			if (y == null) {
				y = x === "center" ? "50%" : "0";
			} else if (y === "center") {
				y = "50%";
			}
			if (x === "center" || isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1) {
				//remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
				x = "50%";
			}
			v = x + " " + y + (a.length > 2 ? " " + a[2] : "");
			if (recObj) {
				recObj.oxp = x.indexOf("%") !== -1;
				recObj.oyp = y.indexOf("%") !== -1;
				recObj.oxr = x.charAt(1) === "=";
				recObj.oyr = y.charAt(1) === "=";
				recObj.ox = parseFloat(x.replace(_NaNExp, ""));
				recObj.oy = parseFloat(y.replace(_NaNExp, ""));
				recObj.v = v;
			}
			return recObj || v;
		},


		/**
   * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
   * @param {(number|string)} e End value which is typically a string, but could be a number
   * @param {(number|string)} b Beginning value which is typically a string but could be a number
   * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
   */
		_parseChange = function (e, b) {
			return typeof e === "string" && e.charAt(1) === "=" ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b) || 0;
		},


		/**
   * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
   * @param {Object} v Value to be parsed
   * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
   * @return {number} Parsed value
   */
		_parseVal = function (v, d) {
			return v == null ? d : typeof v === "string" && v.charAt(1) === "=" ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
		},


		/**
   * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
   * @param {Object} v Value to be parsed
   * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
   * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
   * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
   * @return {number} parsed angle in radians
   */
		_parseAngle = function (v, d, p, directionalEnd) {
			var min = 0.000001,
			    cap,
			    split,
			    dif,
			    result,
			    isRelative;
			if (v == null) {
				result = d;
			} else if (typeof v === "number") {
				result = v;
			} else {
				cap = 360;
				split = v.split("_");
				isRelative = v.charAt(1) === "=";
				dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * (v.indexOf("rad") === -1 ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
				if (split.length) {
					if (directionalEnd) {
						directionalEnd[p] = d + dif;
					}
					if (v.indexOf("short") !== -1) {
						dif = dif % cap;
						if (dif !== dif % (cap / 2)) {
							dif = dif < 0 ? dif + cap : dif - cap;
						}
					}
					if (v.indexOf("_cw") !== -1 && dif < 0) {
						dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
					} else if (v.indexOf("ccw") !== -1 && dif > 0) {
						dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
					}
				}
				result = d + dif;
			}
			if (result < min && result > -min) {
				result = 0;
			}
			return result;
		},
		    _colorLookup = { aqua: [0, 255, 255],
			lime: [0, 255, 0],
			silver: [192, 192, 192],
			black: [0, 0, 0],
			maroon: [128, 0, 0],
			teal: [0, 128, 128],
			blue: [0, 0, 255],
			navy: [0, 0, 128],
			white: [255, 255, 255],
			fuchsia: [255, 0, 255],
			olive: [128, 128, 0],
			yellow: [255, 255, 0],
			orange: [255, 165, 0],
			gray: [128, 128, 128],
			purple: [128, 0, 128],
			green: [0, 128, 0],
			red: [255, 0, 0],
			pink: [255, 192, 203],
			cyan: [0, 255, 255],
			transparent: [255, 255, 255, 0] },
		    _hue = function (h, m1, m2) {
			h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
			return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + 0.5 | 0;
		},


		/**
   * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
   * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
   * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
   * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
   */
		_parseColor = CSSPlugin.parseColor = function (v, toHSL) {
			var a, r, g, b, h, s, l, max, min, d, wasHSL;
			if (!v) {
				a = _colorLookup.black;
			} else if (typeof v === "number") {
				a = [v >> 16, v >> 8 & 255, v & 255];
			} else {
				if (v.charAt(v.length - 1) === ",") {
					//sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
					v = v.substr(0, v.length - 1);
				}
				if (_colorLookup[v]) {
					a = _colorLookup[v];
				} else if (v.charAt(0) === "#") {
					if (v.length === 4) {
						//for shorthand like #9F0
						r = v.charAt(1);
						g = v.charAt(2);
						b = v.charAt(3);
						v = "#" + r + r + g + g + b + b;
					}
					v = parseInt(v.substr(1), 16);
					a = [v >> 16, v >> 8 & 255, v & 255];
				} else if (v.substr(0, 3) === "hsl") {
					a = wasHSL = v.match(_numExp);
					if (!toHSL) {
						h = Number(a[0]) % 360 / 360;
						s = Number(a[1]) / 100;
						l = Number(a[2]) / 100;
						g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
						r = l * 2 - g;
						if (a.length > 3) {
							a[3] = Number(v[3]);
						}
						a[0] = _hue(h + 1 / 3, r, g);
						a[1] = _hue(h, r, g);
						a[2] = _hue(h - 1 / 3, r, g);
					} else if (v.indexOf("=") !== -1) {
						//if relative values are found, just return the raw strings with the relative prefixes in place.
						return v.match(_relNumExp);
					}
				} else {
					a = v.match(_numExp) || _colorLookup.transparent;
				}
				a[0] = Number(a[0]);
				a[1] = Number(a[1]);
				a[2] = Number(a[2]);
				if (a.length > 3) {
					a[3] = Number(a[3]);
				}
			}
			if (toHSL && !wasHSL) {
				r = a[0] / 255;
				g = a[1] / 255;
				b = a[2] / 255;
				max = Math.max(r, g, b);
				min = Math.min(r, g, b);
				l = (max + min) / 2;
				if (max === min) {
					h = s = 0;
				} else {
					d = max - min;
					s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
					h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
					h *= 60;
				}
				a[0] = h + 0.5 | 0;
				a[1] = s * 100 + 0.5 | 0;
				a[2] = l * 100 + 0.5 | 0;
			}
			return a;
		},
		    _formatColors = function (s, toHSL) {
			var colors = s.match(_colorExp) || [],
			    charIndex = 0,
			    parsed = colors.length ? "" : s,
			    i,
			    color,
			    temp;
			for (i = 0; i < colors.length; i++) {
				color = colors[i];
				temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
				charIndex += temp.length + color.length;
				color = _parseColor(color, toHSL);
				if (color.length === 3) {
					color.push(1);
				}
				parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
			}
			return parsed + s.substr(charIndex);
		},
		    _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

		for (p in _colorLookup) {
			_colorExp += "|" + p + "\\b";
		}
		_colorExp = new RegExp(_colorExp + ")", "gi");

		CSSPlugin.colorStringFilter = function (a) {
			var combined = a[0] + a[1],
			    toHSL;
			if (_colorExp.test(combined)) {
				toHSL = combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1;
				a[0] = _formatColors(a[0], toHSL);
				a[1] = _formatColors(a[1], toHSL);
			}
			_colorExp.lastIndex = 0;
		};

		if (!TweenLite.defaultStringFilter) {
			TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter;
		}

		/**
   * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
   * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
   * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
   * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
   * @return {Function} formatter function
   */
		var _getFormatter = function (dflt, clr, collapsible, multi) {
			if (dflt == null) {
				return function (v) {
					return v;
				};
			}
			var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
			    dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
			    pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
			    sfx = dflt.charAt(dflt.length - 1) === ")" ? ")" : "",
			    delim = dflt.indexOf(" ") !== -1 ? " " : ",",
			    numVals = dVals.length,
			    dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "",
			    formatter;
			if (!numVals) {
				return function (v) {
					return v;
				};
			}
			if (clr) {
				formatter = function (v) {
					var color, vals, i, a;
					if (typeof v === "number") {
						v += dSfx;
					} else if (multi && _commasOutsideParenExp.test(v)) {
						a = v.replace(_commasOutsideParenExp, "|").split("|");
						for (i = 0; i < a.length; i++) {
							a[i] = formatter(a[i]);
						}
						return a.join(",");
					}
					color = (v.match(_colorExp) || [dColor])[0];
					vals = v.split(color).join("").match(_valuesExp) || [];
					i = vals.length;
					if (numVals > i--) {
						while (++i < numVals) {
							vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
						}
					}
					return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
				};
				return formatter;
			}
			formatter = function (v) {
				var vals, a, i;
				if (typeof v === "number") {
					v += dSfx;
				} else if (multi && _commasOutsideParenExp.test(v)) {
					a = v.replace(_commasOutsideParenExp, "|").split("|");
					for (i = 0; i < a.length; i++) {
						a[i] = formatter(a[i]);
					}
					return a.join(",");
				}
				vals = v.match(_valuesExp) || [];
				i = vals.length;
				if (numVals > i--) {
					while (++i < numVals) {
						vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
					}
				}
				return pfx + vals.join(delim) + sfx;
			};
			return formatter;
		},


		/**
   * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
   * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
   * @return {Function} a formatter function
   */
		_getEdgeParser = function (props) {
			props = props.split(",");
			return function (t, e, p, cssp, pt, plugin, vars) {
				var a = (e + "").split(" "),
				    i;
				vars = {};
				for (i = 0; i < 4; i++) {
					vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0];
				}
				return cssp.parse(t, vars, pt, plugin);
			};
		},


		// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens  which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
		_setPluginRatio = _internals._setPluginRatio = function (v) {
			this.plugin.setRatio(v);
			var d = this.data,
			    proxy = d.proxy,
			    mpt = d.firstMPT,
			    min = 0.000001,
			    val,
			    pt,
			    i,
			    str,
			    p;
			while (mpt) {
				val = proxy[mpt.v];
				if (mpt.r) {
					val = Math.round(val);
				} else if (val < min && val > -min) {
					val = 0;
				}
				mpt.t[mpt.p] = val;
				mpt = mpt._next;
			}
			if (d.autoRotate) {
				d.autoRotate.rotation = proxy.rotation;
			}
			//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.
			if (v === 1 || v === 0) {
				mpt = d.firstMPT;
				p = v === 1 ? "e" : "b";
				while (mpt) {
					pt = mpt.t;
					if (!pt.type) {
						pt[p] = pt.s + pt.xs0;
					} else if (pt.type === 1) {
						str = pt.xs0 + pt.s + pt.xs1;
						for (i = 1; i < pt.l; i++) {
							str += pt["xn" + i] + pt["xs" + (i + 1)];
						}
						pt[p] = str;
					}
					mpt = mpt._next;
				}
			}
		},


		/**
   * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
   * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
   * @param {!string} p property name
   * @param {(number|string|object)} v value
   * @param {MiniPropTween=} next next MiniPropTween in the linked list
   * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
   */
		MiniPropTween = function (t, p, v, next, r) {
			this.t = t;
			this.p = p;
			this.v = v;
			this.r = r;
			if (next) {
				next._prev = this;
				this._next = next;
			}
		},


		/**
   * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
   * This method returns an object that has the following properties:
   *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
   *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
   *  - firstMPT: the first MiniPropTween in the linked list
   *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
   * @param {!Object} t target object to be tweened
   * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
   * @param {!CSSPlugin} cssp The CSSPlugin instance
   * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
   * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
   * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
   * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
   */
		_parseToProxy = _internals._parseToProxy = function (t, vars, cssp, pt, plugin, shallow) {
			var bpt = pt,
			    start = {},
			    end = {},
			    transform = cssp._transform,
			    oldForce = _forcePT,
			    i,
			    p,
			    xp,
			    mpt,
			    firstPT;
			cssp._transform = null;
			_forcePT = vars;
			pt = firstPT = cssp.parse(t, vars, pt, plugin);
			_forcePT = oldForce;
			//break off from the linked list so the new ones are isolated.
			if (shallow) {
				cssp._transform = transform;
				if (bpt) {
					bpt._prev = null;
					if (bpt._prev) {
						bpt._prev._next = null;
					}
				}
			}
			while (pt && pt !== bpt) {
				if (pt.type <= 1) {
					p = pt.p;
					end[p] = pt.s + pt.c;
					start[p] = pt.s;
					if (!shallow) {
						mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
						pt.c = 0;
					}
					if (pt.type === 1) {
						i = pt.l;
						while (--i > 0) {
							xp = "xn" + i;
							p = pt.p + "_" + xp;
							end[p] = pt.data[xp];
							start[p] = pt[xp];
							if (!shallow) {
								mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
							}
						}
					}
				}
				pt = pt._next;
			}
			return { proxy: start, end: end, firstMPT: mpt, pt: firstPT };
		},


		/**
   * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
   * CSSPropTweens have the following optional properties as well (not defined through the constructor):
   *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
   *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
   *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
   *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
   *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
   * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
   * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
   * @param {number} s Starting numeric value
   * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
   * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
   * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
   * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
   * @param {boolean=} r If true, the value(s) should be rounded
   * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
   * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
   * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
   */
		CSSPropTween = _internals.CSSPropTween = function (t, p, s, c, next, type, n, r, pr, b, e) {
			this.t = t; //target
			this.p = p; //property
			this.s = s; //starting value
			this.c = c; //change value
			this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
			if (!(t instanceof CSSPropTween)) {
				_overwriteProps.push(this.n);
			}
			this.r = r; //round (boolean)
			this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
			if (pr) {
				this.pr = pr;
				_hasPriority = true;
			}
			this.b = b === undefined ? s : b;
			this.e = e === undefined ? s + c : e;
			if (next) {
				this._next = next;
				next._prev = this;
			}
		},
		    _addNonTweeningNumericPT = function (target, prop, start, end, next, overwriteProp) {
			//cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
			var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
			pt.b = start;
			pt.e = pt.xs0 = end;
			return pt;
		},


		/**
   * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
   * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
   * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
   * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
   *
   * @param {!Object} t Target whose property will be tweened
   * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
   * @param {string} b Beginning value
   * @param {string} e Ending value
   * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
   * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
   * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
   * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
   * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
   * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
   * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
   */
		_parseComplex = CSSPlugin.parseComplex = function (t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
			//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
			b = b || dflt || "";
			pt = new CSSPropTween(t, p, 0, 0, pt, setRatio ? 2 : 1, null, false, pr, b, e);
			e += ""; //ensures it's a string
			if (clrs && _colorExp.test(e + b)) {
				//if colors are found, normalize the formatting to rgba() or hsla().
				e = [b, e];
				CSSPlugin.colorStringFilter(e);
				b = e[0];
				e = e[1];
			}
			var ba = b.split(", ").join(",").split(" "),
			    //beginning array
			ea = e.split(", ").join(",").split(" "),
			    //ending array
			l = ba.length,
			    autoRound = _autoRound !== false,
			    i,
			    xi,
			    ni,
			    bv,
			    ev,
			    bnums,
			    enums,
			    bn,
			    hasAlpha,
			    temp,
			    cv,
			    str,
			    useHSL;
			if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
				ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
				ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
				l = ba.length;
			}
			if (l !== ea.length) {
				//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
				ba = (dflt || "").split(" ");
				l = ba.length;
			}
			pt.plugin = plugin;
			pt.setRatio = setRatio;
			_colorExp.lastIndex = 0;
			for (i = 0; i < l; i++) {
				bv = ba[i];
				ev = ea[i];
				bn = parseFloat(bv);
				//if the value begins with a number (most common). It's fine if it has a suffix like px
				if (bn || bn === 0) {
					pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && ev.indexOf("px") !== -1, true);

					//if the value is a color
				} else if (clrs && _colorExp.test(bv)) {
					str = ev.indexOf(")") + 1;
					str = ")" + (str ? ev.substr(str) : ""); //if there's a comma or ) at the end, retain it.
					useHSL = ev.indexOf("hsl") !== -1 && _supportsOpacity;
					bv = _parseColor(bv, useHSL);
					ev = _parseColor(ev, useHSL);
					hasAlpha = bv.length + ev.length > 6;
					if (hasAlpha && !_supportsOpacity && ev[3] === 0) {
						//older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
						pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
						pt.e = pt.e.split(ea[i]).join("transparent");
					} else {
						if (!_supportsOpacity) {
							//old versions of IE don't support rgba().
							hasAlpha = false;
						}
						if (useHSL) {
							pt.appendXtra(hasAlpha ? "hsla(" : "hsl(", bv[0], _parseChange(ev[0], bv[0]), ",", false, true).appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false).appendXtra("", bv[2], _parseChange(ev[2], bv[2]), hasAlpha ? "%," : "%" + str, false);
						} else {
							pt.appendXtra(hasAlpha ? "rgba(" : "rgb(", bv[0], ev[0] - bv[0], ",", true, true).appendXtra("", bv[1], ev[1] - bv[1], ",", true).appendXtra("", bv[2], ev[2] - bv[2], hasAlpha ? "," : str, true);
						}

						if (hasAlpha) {
							bv = bv.length < 4 ? 1 : bv[3];
							pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, false);
						}
					}
					_colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.
				} else {
					bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

					//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
					if (!bnums) {
						pt["xs" + pt.l] += pt.l || pt["xs" + pt.l] ? " " + ev : ev;

						//loop through all the numbers that are found and construct the extra values on the pt.
					} else {
						enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
						if (!enums || enums.length !== bnums.length) {
							//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
							return pt;
						}
						ni = 0;
						for (xi = 0; xi < bnums.length; xi++) {
							cv = bnums[xi];
							temp = bv.indexOf(cv, ni);
							pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && bv.substr(temp + cv.length, 2) === "px", xi === 0);
							ni = temp + cv.length;
						}
						pt["xs" + pt.l] += bv.substr(ni);
					}
				}
			}
			//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
			if (e.indexOf("=") !== -1) if (pt.data) {
				str = pt.xs0 + pt.data.s;
				for (i = 1; i < pt.l; i++) {
					str += pt["xs" + i] + pt.data["xn" + i];
				}
				pt.e = str + pt["xs" + i];
			}
			if (!pt.l) {
				pt.type = -1;
				pt.xs0 = pt.e;
			}
			return pt.xfirst || pt;
		},
		    i = 9;

		p = CSSPropTween.prototype;
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
		while (--i > 0) {
			p["xn" + i] = 0;
			p["xs" + i] = "";
		}
		p.xs0 = "";
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;

		/**
   * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
   * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
   * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
   * @param {string=} pfx Prefix (if any)
   * @param {!number} s Starting value
   * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
   * @param {string=} sfx Suffix (if any)
   * @param {boolean=} r Round (if true).
   * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
   * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
   */
		p.appendXtra = function (pfx, s, c, sfx, r, pad) {
			var pt = this,
			    l = pt.l;
			pt["xs" + l] += pad && (l || pt["xs" + l]) ? " " + pfx : pfx || "";
			if (!c) if (l !== 0 && !pt.plugin) {
				//typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt["xs" + pt.l] = sfx || "";
			if (l > 0) {
				pt.data["xn" + l] = s + c;
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt["xn" + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}
				return pt;
			}
			pt.data = { s: s + c };
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		};

		/**
   * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
   * @param {!string} p Property name (like "boxShadow" or "throwProps")
   * @param {Object=} options An object containing any of the following configuration options:
   *                      - defaultValue: the default value
   *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
   *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
   *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
   *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
   *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
   *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
   *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
   *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
   */
		var SpecialProp = function (p, options) {
			options = options || {};
			this.p = options.prefix ? _checkPropPrefix(p) || p : p;
			_specialProps[p] = _specialProps[this.p] = this;
			this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
			if (options.parser) {
				this.parse = options.parser;
			}
			this.clrs = options.color;
			this.multi = options.multi;
			this.keyword = options.keyword;
			this.dflt = options.defaultValue;
			this.pr = options.priority || 0;
		},


		//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
		_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function (p, options, defaults) {
			if (typeof options !== "object") {
				options = { parser: defaults }; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
			}
			var a = p.split(","),
			    d = options.defaultValue,
			    i,
			    temp;
			defaults = defaults || [d];
			for (i = 0; i < a.length; i++) {
				options.prefix = i === 0 && options.prefix;
				options.defaultValue = defaults[i] || d;
				temp = new SpecialProp(a[i], options);
			}
		},


		//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
		_registerPluginProp = function (p) {
			if (!_specialProps[p]) {
				var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
				_registerComplexSpecialProp(p, { parser: function (t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log("Error: " + pluginName + " js file not loaded.");
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					} });
			}
		};

		p = SpecialProp.prototype;

		/**
   * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
   * @param {!Object} t target element
   * @param {(string|number|object)} b beginning value
   * @param {(string|number|object)} e ending (destination) value
   * @param {CSSPropTween=} pt next CSSPropTween in the linked list
   * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
   * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
   * @return {CSSPropTween=} First CSSPropTween in the linked list
   */
		p.parseComplex = function (t, b, e, pt, plugin, setRatio) {
			var kwd = this.keyword,
			    i,
			    ba,
			    ea,
			    l,
			    bi,
			    ei;
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
				ba = b.replace(_commasOutsideParenExp, "|").split("|");
				ea = e.replace(_commasOutsideParenExp, "|").split("|");
			} else if (kwd) {
				ba = [b];
				ea = [e];
			}
			if (ea) {
				l = ea.length > ba.length ? ea.length : ba.length;
				for (i = 0; i < l; i++) {
					b = ba[i] = ba[i] || this.dflt;
					e = ea[i] = ea[i] || this.dflt;
					if (kwd) {
						bi = b.indexOf(kwd);
						ei = e.indexOf(kwd);
						if (bi !== ei) {
							if (ei === -1) {
								//if the keyword isn't in the end value, remove it from the beginning one.
								ba[i] = ba[i].split(kwd).join("");
							} else if (bi === -1) {
								//if the keyword isn't in the beginning, add it.
								ba[i] += " " + kwd;
							}
						}
					}
				}
				b = ba.join(", ");
				e = ea.join(", ");
			}
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
		};

		/**
   * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
   * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
   * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
   * @param {!Object} t Target object whose property is being tweened
   * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
   * @param {!string} p Property name
   * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
   * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
   * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
   * @param {Object=} vars Original vars object that contains the data for parsing.
   * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
   */
		p.parse = function (t, e, p, cssp, pt, plugin, vars) {
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};

		/**
   * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
   *  1) Target object whose property should be tweened (typically a DOM element)
   *  2) The end/destination value (could be a string, number, object, or whatever you want)
   *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
   *
   * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
   *
   * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
   *      var start = target.style.width;
   *      return function(ratio) {
   *              target.style.width = (start + value * ratio) + "px";
   *              console.log("set width to " + target.style.width);
   *          }
   * }, 0);
   *
   * Then, when I do this tween, it will trigger my special property:
   *
   * TweenLite.to(element, 1, {css:{myCustomProp:100}});
   *
   * In the example, of course, we're just changing the width, but you can do anything you want.
   *
   * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
   * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
   * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
   */
		CSSPlugin.registerSpecialProp = function (name, onInitTween, priority) {
			_registerComplexSpecialProp(name, { parser: function (t, e, p, cssp, pt, plugin, vars) {
					var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
					rv.plugin = plugin;
					rv.setRatio = onInitTween(t, e, cssp._tween, p);
					return rv;
				}, priority: priority });
		};

		//transform-related methods and properties
		CSSPlugin.useSVGTransformAttr = _isSafari || _isFirefox; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).
		var _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
		    _transformProp = _checkPropPrefix("transform"),
		    //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
		_transformPropCSS = _prefixCSS + "transform",
		    _transformOriginProp = _checkPropPrefix("transformOrigin"),
		    _supports3D = _checkPropPrefix("perspective") !== null,
		    Transform = _internals.Transform = function () {
			this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
			this.force3D = CSSPlugin.defaultForce3D === false || !_supports3D ? false : CSSPlugin.defaultForce3D || "auto";
		},
		    _SVGElement = window.SVGElement,
		    _useSVGTransformAttr,

		//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

		_createSVG = function (type, container, attributes) {
			var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
			    reg = /([a-z])([A-Z])/g,
			    p;
			for (p in attributes) {
				element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
			}
			container.appendChild(element);
			return element;
		},
		    _docElement = _doc.documentElement,
		    _forceSVGTransformAttr = function () {
			//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
			var force = _ieVers || /Android/i.test(_agent) && !window.chrome,
			    svg,
			    rect,
			    width;
			if (_doc.createElementNS && !force) {
				//IE8 and earlier doesn't support SVG anyway
				svg = _createSVG("svg", _docElement);
				rect = _createSVG("rect", svg, { width: 100, height: 50, x: 100 });
				width = rect.getBoundingClientRect().width;
				rect.style[_transformOriginProp] = "50% 50%";
				rect.style[_transformProp] = "scaleX(0.5)";
				force = width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
				_docElement.removeChild(svg);
			}
			return force;
		}(),
		    _parseSVGOrigin = function (e, local, decoratee, absolute, smoothOrigin, skipRecord) {
			var tm = e._gsTransform,
			    m = _getMatrix(e, true),
			    v,
			    x,
			    y,
			    xOrigin,
			    yOrigin,
			    a,
			    b,
			    c,
			    d,
			    tx,
			    ty,
			    determinant,
			    xOriginOld,
			    yOriginOld;
			if (tm) {
				xOriginOld = tm.xOrigin; //record the original values before we alter them.
				yOriginOld = tm.yOrigin;
			}
			if (!absolute || (v = absolute.split(" ")).length < 2) {
				b = e.getBBox();
				local = _parsePosition(local).split(" ");
				v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x, (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
			}
			decoratee.xOrigin = xOrigin = parseFloat(v[0]);
			decoratee.yOrigin = yOrigin = parseFloat(v[1]);
			if (absolute && m !== _identity2DMatrix) {
				//if svgOrigin is being set, we must invert the matrix and determine where the absolute point is, factoring in the current transforms. Otherwise, the svgOrigin would be based on the element's non-transformed position on the canvas.
				a = m[0];
				b = m[1];
				c = m[2];
				d = m[3];
				tx = m[4];
				ty = m[5];
				determinant = a * d - b * c;
				x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
				y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
				xOrigin = decoratee.xOrigin = v[0] = x;
				yOrigin = decoratee.yOrigin = v[1] = y;
			}
			if (tm) {
				//avoid jump when transformOrigin is changed - adjust the x/y values accordingly
				if (skipRecord) {
					decoratee.xOffset = tm.xOffset;
					decoratee.yOffset = tm.yOffset;
					tm = decoratee;
				}
				if (smoothOrigin || smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false) {
					x = xOrigin - xOriginOld;
					y = yOrigin - yOriginOld;
					//originally, we simply adjusted the x and y values, but that would cause problems if, for example, you created a rotational tween part-way through an x/y tween. Managing the offset in a separate variable gives us ultimate flexibility.
					//tm.x -= x - (x * m[0] + y * m[2]);
					//tm.y -= y - (x * m[1] + y * m[3]);
					tm.xOffset += x * m[0] + y * m[2] - x;
					tm.yOffset += x * m[1] + y * m[3] - y;
				} else {
					tm.xOffset = tm.yOffset = 0;
				}
			}
			if (!skipRecord) {
				e.setAttribute("data-svg-origin", v.join(" "));
			}
		},
		    _canGetBBox = function (e) {
			try {
				return e.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
			} catch (e) {}
		},
		    _isSVG = function (e) {
			//reports if the element is an SVG on which getBBox() actually works
			return !!(_SVGElement && e.getBBox && e.getCTM && _canGetBBox(e) && (!e.parentNode || e.parentNode.getBBox && e.parentNode.getCTM));
		},
		    _identity2DMatrix = [1, 0, 0, 1, 0, 0],
		    _getMatrix = function (e, force2D) {
			var tm = e._gsTransform || new Transform(),
			    rnd = 100000,
			    isDefault,
			    s,
			    m,
			    n,
			    dec;
			if (_transformProp) {
				s = _getStyle(e, _transformPropCSS, null, true);
			} else if (e.currentStyle) {
				//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
				s = e.currentStyle.filter.match(_ieGetMatrixExp);
				s = s && s.length === 4 ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0].join(",") : "";
			}
			isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)";
			if (tm.svg || e.getBBox && _isSVG(e)) {
				if (isDefault && (e.style[_transformProp] + "").indexOf("matrix") !== -1) {
					//some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
					s = e.style[_transformProp];
					isDefault = 0;
				}
				m = e.getAttribute("transform");
				if (isDefault && m) {
					if (m.indexOf("matrix") !== -1) {
						//just in case there's a "transform" value specified as an attribute instead of CSS style. Accept either a matrix() or simple translate() value though.
						s = m;
						isDefault = 0;
					} else if (m.indexOf("translate") !== -1) {
						s = "matrix(1,0,0,1," + m.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")";
						isDefault = 0;
					}
				}
			}
			if (isDefault) {
				return _identity2DMatrix;
			}
			//split the matrix values out into an array (m for matrix)
			m = (s || "").match(_numExp) || [];
			i = m.length;
			while (--i > -1) {
				n = Number(m[i]);
				m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (dec < 0 ? -0.5 : 0.5) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
			}
			return force2D && m.length > 6 ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
		},


		/**
   * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
   * @param {!Object} t target element
   * @param {Object=} cs computed style object (optional)
   * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
   * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
   * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
   */
		_getTransform = _internals.getTransform = function (t, cs, rec, parse) {
			if (t._gsTransform && rec && !parse) {
				return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
			}
			var tm = rec ? t._gsTransform || new Transform() : new Transform(),
			    invX = tm.scaleX < 0,
			    //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
			min = 0.00002,
			    rnd = 100000,
			    zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
			    defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
			    m,
			    i,
			    scaleX,
			    scaleY,
			    rotation,
			    skewX;

			tm.svg = !!(t.getBBox && _isSVG(t));
			if (tm.svg) {
				_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, _cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
				_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
			}
			m = _getMatrix(t);
			if (m !== _identity2DMatrix) {

				if (m.length === 16) {
					//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
					var a11 = m[0],
					    a21 = m[1],
					    a31 = m[2],
					    a41 = m[3],
					    a12 = m[4],
					    a22 = m[5],
					    a32 = m[6],
					    a42 = m[7],
					    a13 = m[8],
					    a23 = m[9],
					    a33 = m[10],
					    a14 = m[12],
					    a24 = m[13],
					    a34 = m[14],
					    a43 = m[11],
					    angle = Math.atan2(a32, a33),
					    t1,
					    t2,
					    t3,
					    t4,
					    cos,
					    sin;

					//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
					if (tm.zOrigin) {
						a34 = -tm.zOrigin;
						a14 = a13 * a34 - m[12];
						a24 = a23 * a34 - m[13];
						a34 = a33 * a34 + tm.zOrigin - m[14];
					}
					tm.rotationX = angle * _RAD2DEG;
					//rotationX
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						t1 = a12 * cos + a13 * sin;
						t2 = a22 * cos + a23 * sin;
						t3 = a32 * cos + a33 * sin;
						a13 = a12 * -sin + a13 * cos;
						a23 = a22 * -sin + a23 * cos;
						a33 = a32 * -sin + a33 * cos;
						a43 = a42 * -sin + a43 * cos;
						a12 = t1;
						a22 = t2;
						a32 = t3;
					}
					//rotationY
					angle = Math.atan2(-a31, a33);
					tm.rotationY = angle * _RAD2DEG;
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						t1 = a11 * cos - a13 * sin;
						t2 = a21 * cos - a23 * sin;
						t3 = a31 * cos - a33 * sin;
						a23 = a21 * sin + a23 * cos;
						a33 = a31 * sin + a33 * cos;
						a43 = a41 * sin + a43 * cos;
						a11 = t1;
						a21 = t2;
						a31 = t3;
					}
					//rotationZ
					angle = Math.atan2(a21, a11);
					tm.rotation = angle * _RAD2DEG;
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						a11 = a11 * cos + a12 * sin;
						t2 = a21 * cos + a22 * sin;
						a22 = a21 * -sin + a22 * cos;
						a32 = a31 * -sin + a32 * cos;
						a21 = t2;
					}

					if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) {
						//when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
						tm.rotationX = tm.rotation = 0;
						tm.rotationY = 180 - tm.rotationY;
					}

					tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5 | 0) / rnd;
					tm.scaleY = (Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5 | 0) / rnd;
					tm.scaleZ = (Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5 | 0) / rnd;
					tm.skewX = a12 || a22 ? Math.atan2(a12, a22) * _RAD2DEG + tm.rotation : tm.skewX || 0;
					if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
						if (invX) {
							tm.scaleX *= -1;
							tm.skewX += tm.rotation <= 0 ? 180 : -180;
							tm.rotation += tm.rotation <= 0 ? 180 : -180;
						} else {
							tm.scaleY *= -1;
							tm.skewX += tm.skewX <= 0 ? 180 : -180;
						}
					}
					tm.perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
					tm.x = a14;
					tm.y = a24;
					tm.z = a34;
					if (tm.svg) {
						tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
						tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
					}
				} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || !tm.rotationX && !tm.rotationY) && !(tm.x !== undefined && _getStyle(t, "display", cs) === "none")) {
					//sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
					var k = m.length >= 6,
					    a = k ? m[0] : 1,
					    b = m[1] || 0,
					    c = m[2] || 0,
					    d = k ? m[3] : 1;
					tm.x = m[4] || 0;
					tm.y = m[5] || 0;
					scaleX = Math.sqrt(a * a + b * b);
					scaleY = Math.sqrt(d * d + c * c);
					rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
					skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
					if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
						if (invX) {
							scaleX *= -1;
							skewX += rotation <= 0 ? 180 : -180;
							rotation += rotation <= 0 ? 180 : -180;
						} else {
							scaleY *= -1;
							skewX += skewX <= 0 ? 180 : -180;
						}
					}
					tm.scaleX = scaleX;
					tm.scaleY = scaleY;
					tm.rotation = rotation;
					tm.skewX = skewX;
					if (_supports3D) {
						tm.rotationX = tm.rotationY = tm.z = 0;
						tm.perspective = defaultTransformPerspective;
						tm.scaleZ = 1;
					}
					if (tm.svg) {
						tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
						tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
					}
				}
				tm.zOrigin = zOrigin;
				//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
				for (i in tm) {
					if (tm[i] < min) if (tm[i] > -min) {
						tm[i] = 0;
					}
				}
			}
			//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);
			if (rec) {
				t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
				if (tm.svg) {
					//if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
					if (_useSVGTransformAttr && t.style[_transformProp]) {
						TweenLite.delayedCall(0.001, function () {
							//if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
							_removeProp(t.style, _transformProp);
						});
					} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
						TweenLite.delayedCall(0.001, function () {
							t.removeAttribute("transform");
						});
					}
				}
			}
			return tm;
		},


		//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
		_setIETransformRatio = function (v) {
			var t = this.data,
			    //refers to the element's _gsTransform object
			ang = -t.rotation * _DEG2RAD,
			    skew = ang + t.skewX * _DEG2RAD,
			    rnd = 100000,
			    a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd,
			    b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd,
			    c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd,
			    d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd,
			    style = this.t.style,
			    cs = this.t.currentStyle,
			    filters,
			    val;
			if (!cs) {
				return;
			}
			val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
			b = -c;
			c = -val;
			filters = cs.filter;
			style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
			var w = this.t.offsetWidth,
			    h = this.t.offsetHeight,
			    clip = cs.position !== "absolute",
			    m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
			    ox = t.x + w * t.xPercent / 100,
			    oy = t.y + h * t.yPercent / 100,
			    dx,
			    dy;

			//if transformOrigin is being used, adjust the offset x and y
			if (t.ox != null) {
				dx = (t.oxp ? w * t.ox * 0.01 : t.ox) - w / 2;
				dy = (t.oyp ? h * t.oy * 0.01 : t.oy) - h / 2;
				ox += dx - (dx * a + dy * b);
				oy += dy - (dx * c + dy * d);
			}

			if (!clip) {
				m += ", sizingMethod='auto expand')";
			} else {
				dx = w / 2;
				dy = h / 2;
				//translate to ensure that transformations occur around the correct origin (default is center).
				m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
			}
			if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
				style.filter = filters.replace(_ieSetMatrixExp, m);
			} else {
				style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
			}

			//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
			if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
				style.removeAttribute("filter");
			}

			//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
			if (!clip) {
				var mult = _ieVers < 8 ? 1 : -1,
				    //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
				marg,
				    prop,
				    dif;
				dx = t.ieOffsetX || 0;
				dy = t.ieOffsetY || 0;
				t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
				t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
				for (i = 0; i < 4; i++) {
					prop = _margins[i];
					marg = cs[prop];
					//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
					val = marg.indexOf("px") !== -1 ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
					if (val !== t[prop]) {
						dif = i < 2 ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
					} else {
						dif = i < 2 ? dx - t.ieOffsetX : dy - t.ieOffsetY;
					}
					style[prop] = (t[prop] = Math.round(val - dif * (i === 0 || i === 2 ? 1 : mult))) + "px";
				}
			}
		},


		/* translates a super small decimal to a string WITHOUT scientific notation
  _safeDecimal = function(n) {
  	var s = (n < 0 ? -n : n) + "",
  		a = s.split("e-");
  	return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
  },
  */

		_setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function (v) {
			var t = this.data,
			    //refers to the element's _gsTransform object
			style = this.t.style,
			    angle = t.rotation,
			    rotationX = t.rotationX,
			    rotationY = t.rotationY,
			    sx = t.scaleX,
			    sy = t.scaleY,
			    sz = t.scaleZ,
			    x = t.x,
			    y = t.y,
			    z = t.z,
			    isSVG = t.svg,
			    perspective = t.perspective,
			    force3D = t.force3D,
			    a11,
			    a12,
			    a13,
			    a21,
			    a22,
			    a23,
			    a31,
			    a32,
			    a33,
			    a41,
			    a42,
			    a43,
			    zOrigin,
			    min,
			    cos,
			    sin,
			    t1,
			    t2,
			    transform,
			    comma,
			    zero,
			    skew,
			    rnd;
			//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
			if (((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1 || _useSVGTransformAttr && isSVG || !_supports3D) {
				//on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.

				//2D
				if (angle || t.skewX || isSVG) {
					angle *= _DEG2RAD;
					skew = t.skewX * _DEG2RAD;
					rnd = 100000;
					a11 = Math.cos(angle) * sx;
					a21 = Math.sin(angle) * sx;
					a12 = Math.sin(angle - skew) * -sy;
					a22 = Math.cos(angle - skew) * sy;
					if (skew && t.skewType === "simple") {
						//by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
						t1 = Math.tan(skew);
						t1 = Math.sqrt(1 + t1 * t1);
						a12 *= t1;
						a22 *= t1;
						if (t.skewY) {
							a11 *= t1;
							a21 *= t1;
						}
					}
					if (isSVG) {
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
						if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) {
							//The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
							min = this.t.getBBox();
							x += t.xPercent * 0.01 * min.width;
							y += t.yPercent * 0.01 * min.height;
						}
						min = 0.000001;
						if (x < min) if (x > -min) {
							x = 0;
						}
						if (y < min) if (y > -min) {
							y = 0;
						}
					}
					transform = (a11 * rnd | 0) / rnd + "," + (a21 * rnd | 0) / rnd + "," + (a12 * rnd | 0) / rnd + "," + (a22 * rnd | 0) / rnd + "," + x + "," + y + ")";
					if (isSVG && _useSVGTransformAttr) {
						this.t.setAttribute("transform", "matrix(" + transform);
					} else {
						//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
						style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
					}
				} else {
					style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
				}
				return;
			}
			if (_isFirefox) {
				//Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
				min = 0.0001;
				if (sx < min && sx > -min) {
					sx = sz = 0.00002;
				}
				if (sy < min && sy > -min) {
					sy = sz = 0.00002;
				}
				if (perspective && !t.z && !t.rotationX && !t.rotationY) {
					//Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
					perspective = 0;
				}
			}
			if (angle || t.skewX) {
				angle *= _DEG2RAD;
				cos = a11 = Math.cos(angle);
				sin = a21 = Math.sin(angle);
				if (t.skewX) {
					angle -= t.skewX * _DEG2RAD;
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					if (t.skewType === "simple") {
						//by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
						t1 = Math.tan(t.skewX * _DEG2RAD);
						t1 = Math.sqrt(1 + t1 * t1);
						cos *= t1;
						sin *= t1;
						if (t.skewY) {
							a11 *= t1;
							a21 *= t1;
						}
					}
				}
				a12 = -sin;
				a22 = cos;
			} else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) {
				//if we're only translating and/or 2D scaling, this is faster...
				style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + (sx !== 1 || sy !== 1 ? " scale(" + sx + "," + sy + ")" : "");
				return;
			} else {
				a11 = a22 = 1;
				a12 = a21 = 0;
			}
			// KEY  INDEX   AFFECTS
			// a11  0       rotation, rotationY, scaleX
			// a21  1       rotation, rotationY, scaleX
			// a31  2       rotationY, scaleX
			// a41  3       rotationY, scaleX
			// a12  4       rotation, skewX, rotationX, scaleY
			// a22  5       rotation, skewX, rotationX, scaleY
			// a32  6       rotationX, scaleY
			// a42  7       rotationX, scaleY
			// a13  8       rotationY, rotationX, scaleZ
			// a23  9       rotationY, rotationX, scaleZ
			// a33  10      rotationY, rotationX, scaleZ
			// a43  11      rotationY, rotationX, perspective, scaleZ
			// a14  12      x, zOrigin, svgOrigin
			// a24  13      y, zOrigin, svgOrigin
			// a34  14      z, zOrigin
			// a44  15
			// rotation: Math.atan2(a21, a11)
			// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
			// rotationX: Math.atan2(a32, a33)
			a33 = 1;
			a13 = a23 = a31 = a32 = a41 = a42 = 0;
			a43 = perspective ? -1 / perspective : 0;
			zOrigin = t.zOrigin;
			min = 0.000001; //threshold below which browsers use scientific notation which won't work.
			comma = ",";
			zero = "0";
			angle = rotationY * _DEG2RAD;
			if (angle) {
				cos = Math.cos(angle);
				sin = Math.sin(angle);
				a31 = -sin;
				a41 = a43 * -sin;
				a13 = a11 * sin;
				a23 = a21 * sin;
				a33 = cos;
				a43 *= cos;
				a11 *= cos;
				a21 *= cos;
			}
			angle = rotationX * _DEG2RAD;
			if (angle) {
				cos = Math.cos(angle);
				sin = Math.sin(angle);
				t1 = a12 * cos + a13 * sin;
				t2 = a22 * cos + a23 * sin;
				a32 = a33 * sin;
				a42 = a43 * sin;
				a13 = a12 * -sin + a13 * cos;
				a23 = a22 * -sin + a23 * cos;
				a33 = a33 * cos;
				a43 = a43 * cos;
				a12 = t1;
				a22 = t2;
			}
			if (sz !== 1) {
				a13 *= sz;
				a23 *= sz;
				a33 *= sz;
				a43 *= sz;
			}
			if (sy !== 1) {
				a12 *= sy;
				a22 *= sy;
				a32 *= sy;
				a42 *= sy;
			}
			if (sx !== 1) {
				a11 *= sx;
				a21 *= sx;
				a31 *= sx;
				a41 *= sx;
			}

			if (zOrigin || isSVG) {
				if (zOrigin) {
					x += a13 * -zOrigin;
					y += a23 * -zOrigin;
					z += a33 * -zOrigin + zOrigin;
				}
				if (isSVG) {
					//due to bugs in some browsers, we need to manage the transform-origin of SVG manually
					x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
					y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
				}
				if (x < min && x > -min) {
					x = zero;
				}
				if (y < min && y > -min) {
					y = zero;
				}
				if (z < min && z > -min) {
					z = 0; //don't use string because we calculate perspective later and need the number.
				}
			}

			//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
			transform = t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(";
			transform += (a11 < min && a11 > -min ? zero : a11) + comma + (a21 < min && a21 > -min ? zero : a21) + comma + (a31 < min && a31 > -min ? zero : a31);
			transform += comma + (a41 < min && a41 > -min ? zero : a41) + comma + (a12 < min && a12 > -min ? zero : a12) + comma + (a22 < min && a22 > -min ? zero : a22);
			if (rotationX || rotationY || sz !== 1) {
				//performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
				transform += comma + (a32 < min && a32 > -min ? zero : a32) + comma + (a42 < min && a42 > -min ? zero : a42) + comma + (a13 < min && a13 > -min ? zero : a13);
				transform += comma + (a23 < min && a23 > -min ? zero : a23) + comma + (a33 < min && a33 > -min ? zero : a33) + comma + (a43 < min && a43 > -min ? zero : a43) + comma;
			} else {
				transform += ",0,0,0,0,1,0,";
			}
			transform += x + comma + y + comma + z + comma + (perspective ? 1 + -z / perspective : 1) + ")";

			style[_transformProp] = transform;
		};

		p = Transform.prototype;
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;

		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", { parser: function (t, e, p, cssp, pt, plugin, vars) {
				if (cssp._lastParsedTransform === vars) {
					return pt;
				} //only need to parse the transform once, and only if the browser supports it.
				cssp._lastParsedTransform = vars;
				var originalGSTransform = t._gsTransform,
				    style = t.style,
				    min = 0.000001,
				    i = _transformProps.length,
				    v = vars,
				    endRotations = {},
				    transformOriginString = "transformOrigin",
				    m1,
				    m2,
				    copy,
				    orig,
				    has3D,
				    hasChange,
				    dr,
				    x,
				    y,
				    matrix;
				if (vars.display) {
					//if the user is setting display during this tween, it may not be instantiated yet but we must force it here in order to get accurate readings. If display is "none", some browsers refuse to report the transform properties correctly.
					copy = _getStyle(t, "display");
					style.display = "block";
					m1 = _getTransform(t, _cs, true, vars.parseTransform);
					style.display = copy;
				} else {
					m1 = _getTransform(t, _cs, true, vars.parseTransform);
				}
				cssp._transform = m1;
				if (typeof v.transform === "string" && _transformProp) {
					//for values like transform:"rotate(60deg) scale(0.5, 0.8)"
					copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
					copy[_transformProp] = v.transform;
					copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
					copy.position = "absolute";
					_doc.body.appendChild(_tempDiv);
					m2 = _getTransform(_tempDiv, null, false);
					if (m1.svg) {
						//if it's an SVG element, x/y part of the matrix will be affected by whatever we use as the origin and the offsets, so compensate here...
						x = m1.xOrigin;
						y = m1.yOrigin;
						m2.x -= m1.xOffset;
						m2.y -= m1.yOffset;
						if (v.transformOrigin || v.svgOrigin) {
							//if this tween is altering the origin, we must factor that in here. The actual work of recording the transformOrigin values and setting up the PropTween is done later (still inside this function) so we cannot leave the changes intact here - we only want to update the x/y accordingly.
							orig = {};
							_parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
							x = orig.xOrigin;
							y = orig.yOrigin;
							m2.x -= orig.xOffset - m1.xOffset;
							m2.y -= orig.yOffset - m1.yOffset;
						}
						if (x || y) {
							matrix = _getMatrix(_tempDiv);
							m2.x -= x - (x * matrix[0] + y * matrix[2]);
							m2.y -= y - (x * matrix[1] + y * matrix[3]);
						}
					}
					_doc.body.removeChild(_tempDiv);
					if (!m2.perspective) {
						m2.perspective = m1.perspective; //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
					}
					if (v.xPercent != null) {
						m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
					}
					if (v.yPercent != null) {
						m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
					}
				} else if (typeof v === "object") {
					//for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
					m2 = { scaleX: _parseVal(v.scaleX != null ? v.scaleX : v.scale, m1.scaleX),
						scaleY: _parseVal(v.scaleY != null ? v.scaleY : v.scale, m1.scaleY),
						scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
						x: _parseVal(v.x, m1.x),
						y: _parseVal(v.y, m1.y),
						z: _parseVal(v.z, m1.z),
						xPercent: _parseVal(v.xPercent, m1.xPercent),
						yPercent: _parseVal(v.yPercent, m1.yPercent),
						perspective: _parseVal(v.transformPerspective, m1.perspective) };
					dr = v.directionalRotation;
					if (dr != null) {
						if (typeof dr === "object") {
							for (copy in dr) {
								v[copy] = dr[copy];
							}
						} else {
							v.rotation = dr;
						}
					}
					if (typeof v.x === "string" && v.x.indexOf("%") !== -1) {
						m2.x = 0;
						m2.xPercent = _parseVal(v.x, m1.xPercent);
					}
					if (typeof v.y === "string" && v.y.indexOf("%") !== -1) {
						m2.y = 0;
						m2.yPercent = _parseVal(v.y, m1.yPercent);
					}

					m2.rotation = _parseAngle("rotation" in v ? v.rotation : "shortRotation" in v ? v.shortRotation + "_short" : "rotationZ" in v ? v.rotationZ : m1.rotation - m1.skewY, m1.rotation - m1.skewY, "rotation", endRotations); //see notes below about skewY for why we subtract it from rotation here
					if (_supports3D) {
						m2.rotationX = _parseAngle("rotationX" in v ? v.rotationX : "shortRotationX" in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
						m2.rotationY = _parseAngle("rotationY" in v ? v.rotationY : "shortRotationY" in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
					}
					m2.skewX = _parseAngle(v.skewX, m1.skewX - m1.skewY); //see notes below about skewY and why we subtract it from skewX here

					//note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
					if (m2.skewY = _parseAngle(v.skewY, m1.skewY)) {
						m2.skewX += m2.skewY;
						m2.rotation += m2.skewY;
					}
				}
				if (_supports3D && v.force3D != null) {
					m1.force3D = v.force3D;
					hasChange = true;
				}

				m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;

				has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective;
				if (!has3D && v.scale != null) {
					m2.scaleZ = 1; //no need to tween scaleZ.
				}

				while (--i > -1) {
					p = _transformProps[i];
					orig = m2[p] - m1[p];
					if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
						hasChange = true;
						pt = new CSSPropTween(m1, p, m1[p], orig, pt);
						if (p in endRotations) {
							pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
						}
						pt.xs0 = 0; //ensures the value stays numeric in setRatio()
						pt.plugin = plugin;
						cssp._overwriteProps.push(pt.n);
					}
				}

				orig = v.transformOrigin;
				if (m1.svg && (orig || v.svgOrigin)) {
					x = m1.xOffset; //when we change the origin, in order to prevent things from jumping we adjust the x/y so we must record those here so that we can create PropTweens for them and flip them at the same time as the origin
					y = m1.yOffset;
					_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
					pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString); //note: if there wasn't a transformOrigin defined yet, just start with the destination one; it's wasteful otherwise, and it causes problems with fromTo() tweens. For example, TweenLite.to("#wheel", 3, {rotation:180, transformOrigin:"50% 50%", delay:1}); TweenLite.fromTo("#wheel", 3, {scale:0.5, transformOrigin:"50% 50%"}, {scale:1, delay:2}); would cause a jump when the from values revert at the beginning of the 2nd tween.
					pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
					if (x !== m1.xOffset || y !== m1.yOffset) {
						pt = _addNonTweeningNumericPT(m1, "xOffset", originalGSTransform ? x : m1.xOffset, m1.xOffset, pt, transformOriginString);
						pt = _addNonTweeningNumericPT(m1, "yOffset", originalGSTransform ? y : m1.yOffset, m1.yOffset, pt, transformOriginString);
					}
					orig = _useSVGTransformAttr ? null : "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
				}
				if (orig || _supports3D && has3D && m1.zOrigin) {
					//if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
					if (_transformProp) {
						hasChange = true;
						p = _transformOriginProp;
						orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
						pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
						pt.b = style[p];
						pt.plugin = plugin;
						if (_supports3D) {
							copy = m1.zOrigin;
							orig = orig.split(" ");
							m1.zOrigin = (orig.length > 2 && !(copy !== 0 && orig[2] === "0px") ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
							pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
							pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
							pt.b = copy;
							pt.xs0 = pt.e = m1.zOrigin;
						} else {
							pt.xs0 = pt.e = orig;
						}

						//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
					} else {
						_parsePosition(orig + "", m1);
					}
				}
				if (hasChange) {
					cssp._transformType = !(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3) ? 3 : 2; //quicker than calling cssp._enableTransforms();
				}
				return pt;
			}, prefix: true });

		_registerComplexSpecialProp("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: true, color: true, multi: true, keyword: "inset" });

		_registerComplexSpecialProp("borderRadius", { defaultValue: "0px", parser: function (t, e, p, cssp, pt, plugin) {
				e = this.format(e);
				var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
				    style = t.style,
				    ea1,
				    i,
				    es2,
				    bs2,
				    bs,
				    es,
				    bn,
				    en,
				    w,
				    h,
				    esfx,
				    bsfx,
				    rel,
				    hn,
				    vn,
				    em;
				w = parseFloat(t.offsetWidth);
				h = parseFloat(t.offsetHeight);
				ea1 = e.split(" ");
				for (i = 0; i < props.length; i++) {
					//if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
					if (this.p.indexOf("border")) {
						//older browsers used a prefix
						props[i] = _checkPropPrefix(props[i]);
					}
					bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
					if (bs.indexOf(" ") !== -1) {
						bs2 = bs.split(" ");
						bs = bs2[0];
						bs2 = bs2[1];
					}
					es = es2 = ea1[i];
					bn = parseFloat(bs);
					bsfx = bs.substr((bn + "").length);
					rel = es.charAt(1) === "=";
					if (rel) {
						en = parseInt(es.charAt(0) + "1", 10);
						es = es.substr(2);
						en *= parseFloat(es);
						esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
					} else {
						en = parseFloat(es);
						esfx = es.substr((en + "").length);
					}
					if (esfx === "") {
						esfx = _suffixMap[p] || bsfx;
					}
					if (esfx !== bsfx) {
						hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
						vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
						if (esfx === "%") {
							bs = hn / w * 100 + "%";
							bs2 = vn / h * 100 + "%";
						} else if (esfx === "em") {
							em = _convertToPixels(t, "borderLeft", 1, "em");
							bs = hn / em + "em";
							bs2 = vn / em + "em";
						} else {
							bs = hn + "px";
							bs2 = vn + "px";
						}
						if (rel) {
							es = parseFloat(bs) + en + esfx;
							es2 = parseFloat(bs2) + en + esfx;
						}
					}
					pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
				}
				return pt;
			}, prefix: true, formatter: _getFormatter("0px 0px 0px 0px", false, true) });
		_registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", { defaultValue: "0px", parser: function (t, e, p, cssp, pt, plugin) {
				return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
			}, prefix: true, formatter: _getFormatter("0px 0px", false, true) });
		_registerComplexSpecialProp("backgroundPosition", { defaultValue: "0 0", parser: function (t, e, p, cssp, pt, plugin) {
				var bp = "background-position",
				    cs = _cs || _getComputedStyle(t, null),
				    bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
				    //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),
				    ba,
				    ea,
				    i,
				    pct,
				    overlap,
				    src;
				if (bs.indexOf("%") !== -1 !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
					src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
					if (src && src !== "none") {
						ba = bs.split(" ");
						ea = es.split(" ");
						_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
						i = 2;
						while (--i > -1) {
							bs = ba[i];
							pct = bs.indexOf("%") !== -1;
							if (pct !== (ea[i].indexOf("%") !== -1)) {
								overlap = i === 0 ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
								ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%";
							}
						}
						bs = ba.join(" ");
					}
				}
				return this.parseComplex(t.style, bs, es, pt, plugin);
			}, formatter: _parsePosition });
		_registerComplexSpecialProp("backgroundSize", { defaultValue: "0 0", formatter: _parsePosition });
		_registerComplexSpecialProp("perspective", { defaultValue: "0px", prefix: true });
		_registerComplexSpecialProp("perspectiveOrigin", { defaultValue: "50% 50%", prefix: true });
		_registerComplexSpecialProp("transformStyle", { prefix: true });
		_registerComplexSpecialProp("backfaceVisibility", { prefix: true });
		_registerComplexSpecialProp("userSelect", { prefix: true });
		_registerComplexSpecialProp("margin", { parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft") });
		_registerComplexSpecialProp("padding", { parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft") });
		_registerComplexSpecialProp("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function (t, e, p, cssp, pt, plugin) {
				var b, cs, delim;
				if (_ieVers < 9) {
					//IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
					cs = t.currentStyle;
					delim = _ieVers < 8 ? " " : ",";
					b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
					e = this.format(e).split(",").join(delim);
				} else {
					b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
					e = this.format(e);
				}
				return this.parseComplex(t.style, b, e, pt, plugin);
			} });
		_registerComplexSpecialProp("textShadow", { defaultValue: "0px 0px 0px #999", color: true, multi: true });
		_registerComplexSpecialProp("autoRound,strictUnits", { parser: function (t, e, p, cssp, pt) {
				return pt;
			} }); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", { defaultValue: "0px solid #000", parser: function (t, e, p, cssp, pt, plugin) {
				return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, false, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), this.format(e), pt, plugin);
			}, color: true, formatter: function (v) {
				var a = v.split(" ");
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
			} });
		_registerComplexSpecialProp("borderWidth", { parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", { parser: function (t, e, p, cssp, pt, plugin) {
				var s = t.style,
				    prop = "cssFloat" in s ? "cssFloat" : "styleFloat";
				return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
			} });

		//opacity-related
		var _setIEOpacityRatio = function (v) {
			var t = this.t,
			    //refers to the element's style property
			filters = t.filter || _getStyle(this.data, "filter") || "",
			    val = this.s + this.c * v | 0,
			    skip;
			if (val === 100) {
				//for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
				if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
					t.removeAttribute("filter");
					skip = !_getStyle(this.data, "filter"); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
				} else {
					t.filter = filters.replace(_alphaFilterExp, "");
					skip = true;
				}
			}
			if (!skip) {
				if (this.xn1) {
					t.filter = filters = filters || "alpha(opacity=" + val + ")"; //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
				}
				if (filters.indexOf("pacity") === -1) {
					//only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
					if (val !== 0 || !this.xn1) {
						//bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
						t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
					}
				} else {
					t.filter = filters.replace(_opacityExp, "opacity=" + val);
				}
			}
		};
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function (t, e, p, cssp, pt, plugin) {
				var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
				    style = t.style,
				    isAutoAlpha = p === "autoAlpha";
				if (typeof e === "string" && e.charAt(1) === "=") {
					e = (e.charAt(0) === "-" ? -1 : 1) * parseFloat(e.substr(2)) + b;
				}
				if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) {
					//if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
					b = 0;
				}
				if (_supportsOpacity) {
					pt = new CSSPropTween(style, "opacity", b, e - b, pt);
				} else {
					pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
					pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
					style.zoom = 1; //helps correct an IE issue.
					pt.type = 2;
					pt.b = "alpha(opacity=" + pt.s + ")";
					pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
					pt.data = t;
					pt.plugin = plugin;
					pt.setRatio = _setIEOpacityRatio;
				}
				if (isAutoAlpha) {
					//we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
					pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, b !== 0 ? "inherit" : "hidden", e === 0 ? "hidden" : "inherit");
					pt.xs0 = "inherit";
					cssp._overwriteProps.push(pt.n);
					cssp._overwriteProps.push(p);
				}
				return pt;
			} });

		var _removeProp = function (s, p) {
			if (p) {
				if (s.removeProperty) {
					if (p.substr(0, 2) === "ms" || p.substr(0, 6) === "webkit") {
						//Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
						p = "-" + p;
					}
					s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
				} else {
					//note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
					s.removeAttribute(p);
				}
			}
		},
		    _setClassNameRatio = function (v) {
			this.t._gsClassPT = this;
			if (v === 1 || v === 0) {
				this.t.setAttribute("class", v === 0 ? this.b : this.e);
				var mpt = this.data,
				    //first MiniPropTween
				s = this.t.style;
				while (mpt) {
					if (!mpt.v) {
						_removeProp(s, mpt.p);
					} else {
						s[mpt.p] = mpt.v;
					}
					mpt = mpt._next;
				}
				if (v === 1 && this.t._gsClassPT === this) {
					this.t._gsClassPT = null;
				}
			} else if (this.t.getAttribute("class") !== this.e) {
				this.t.setAttribute("class", this.e);
			}
		};
		_registerComplexSpecialProp("className", { parser: function (t, e, p, cssp, pt, plugin, vars) {
				var b = t.getAttribute("class") || "",
				    //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,
				    difData,
				    bs,
				    cnpt,
				    cnptLookup,
				    mpt;
				pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
				pt.setRatio = _setClassNameRatio;
				pt.pr = -11;
				_hasPriority = true;
				pt.b = b;
				bs = _getAllStyles(t, _cs);
				//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
				cnpt = t._gsClassPT;
				if (cnpt) {
					cnptLookup = {};
					mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
					while (mpt) {
						cnptLookup[mpt.p] = 1;
						mpt = mpt._next;
					}
					cnpt.setRatio(1);
				}
				t._gsClassPT = pt;
				pt.e = e.charAt(1) !== "=" ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + (e.charAt(0) === "+" ? " " + e.substr(2) : "");
				t.setAttribute("class", pt.e);
				difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
				t.setAttribute("class", b);
				pt.data = difData.firstMPT;
				t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
				pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
				return pt;
			} });

		var _setClearPropsRatio = function (v) {
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
				//this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,
				    transformParse = _specialProps.transform.parse,
				    a,
				    p,
				    i,
				    clearTransform,
				    transform;
				if (this.e === "all") {
					s.cssText = "";
					clearTransform = true;
				} else {
					a = this.e.split(" ").join("").split(",");
					i = a.length;
					while (--i > -1) {
						p = a[i];
						if (_specialProps[p]) {
							if (_specialProps[p].parse === transformParse) {
								clearTransform = true;
							} else {
								p = p === "transformOrigin" ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}
						}
						_removeProp(s, p);
					}
				}
				if (clearTransform) {
					_removeProp(s, _transformProp);
					transform = this.t._gsTransform;
					if (transform) {
						if (transform.svg) {
							this.t.removeAttribute("data-svg-origin");
							this.t.removeAttribute("transform");
						}
						delete this.t._gsTransform;
					}
				}
			}
		};
		_registerComplexSpecialProp("clearProps", { parser: function (t, e, p, cssp, pt) {
				pt = new CSSPropTween(t, p, 0, 0, pt, 2);
				pt.setRatio = _setClearPropsRatio;
				pt.e = e;
				pt.pr = -10;
				pt.data = cssp._tween;
				_hasPriority = true;
				return pt;
			} });

		p = "bezier,throwProps,physicsProps,physics2D".split(",");
		i = p.length;
		while (i--) {
			_registerPluginProp(p[i]);
		}

		p = CSSPlugin.prototype;
		p._firstPT = p._lastParsedTransform = p._transform = null;

		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
		p._onInitTween = function (target, vars, tween) {
			if (!target.nodeType) {
				//css is only for dom elements
				return false;
			}
			this._target = target;
			this._tween = tween;
			this._vars = vars;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, "");
			_overwriteProps = this._overwriteProps;
			var style = target.style,
			    v,
			    pt,
			    pt2,
			    first,
			    last,
			    next,
			    zIndex,
			    tpt,
			    threeD;
			if (_reqSafariFix) if (style.zIndex === "") {
				v = _getStyle(target, "zIndex", _cs);
				if (v === "auto" || v === "") {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);
				}
			}

			if (typeof vars === "string") {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + ";" + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity && _opacityValExp.test(vars)) {
					v.opacity = parseFloat(RegExp.$1);
				}
				vars = v;
				style.cssText = first;
			}

			if (vars.className) {
				//className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
				this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
			} else {
				this._firstPT = pt = this.parse(target, vars, null);
			}

			if (this._transformType) {
				threeD = this._transformType === 3;
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
					_reqSafariFix = true;
					//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
					if (style.zIndex === "") {
						zIndex = _getStyle(target, "zIndex", _cs);
						if (zIndex === "auto" || zIndex === "") {
							this._addLazySet(style, "zIndex", 0);
						}
					}
					//Setting WebkitBackfaceVisibility corrects 3 bugs:
					// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {
						this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
					}
				}
				pt2 = pt;
				while (pt2 && pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}

			if (_hasPriority) {
				//reorders the linked list in order of pr (priority)
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if (pt._prev = pt2 ? pt2._prev : last) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if (pt._next = pt2) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				this._firstPT = first;
			}
			return true;
		};

		p.parse = function (target, vars, pt, plugin) {
			var style = target.style,
			    p,
			    sp,
			    bn,
			    en,
			    bs,
			    es,
			    bsfx,
			    esfx,
			    isStr,
			    rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);
				} else {
					bs = _getStyle(target, p, _cs) + "";
					isStr = typeof es === "string";
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || isStr && _rgbhslExp.test(es)) {
						//Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")";
						}
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);
					} else if (isStr && _complexExp.test(es)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);
					} else {
						bn = parseFloat(bs);
						bsfx = bn || bn === 0 ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

						if (bs === "" || bs === "auto") {
							if (p === "width" || p === "height") {
								bn = _getDimension(target, p, _cs);
								bsfx = "px";
							} else if (p === "left" || p === "top") {
								bn = _calculateOffset(target, p, _cs);
								bsfx = "px";
							} else {
								bn = p !== "opacity" ? 0 : 1;
								bsfx = "";
							}
						}

						rel = isStr && es.charAt(1) === "=";
						if (rel) {
							en = parseInt(es.charAt(0) + "1", 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, "");
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, "") : "";
						}

						if (esfx === "") {
							esfx = p in _suffixMap ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}

						es = en || en === 0 ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.

						//if the beginning/ending suffixes don't match, normalize them...
						if (bsfx !== esfx) if (esfx !== "") if (en || en === 0) if (bn) {
							//note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === "%") {
								bn /= _convertToPixels(target, p, 100, "%") / 100;
								if (vars.strictUnits !== true) {
									//some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";
								}
							} else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
								bn /= _convertToPixels(target, p, 1, esfx);

								//otherwise convert to pixels.
							} else if (esfx !== "px") {
								en = _convertToPixels(target, p, en, esfx);
								esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
							}
							if (rel) if (en || en === 0) {
								es = en + bn + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) && (en || en === 0)) {
							//faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, _autoRound !== false && (esfx === "px" || p === "zIndex"), 0, bs, es);
							pt.xs0 = esfx;
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
							_log("invalid " + p + " tween value: " + vars[p]);
						} else {
							pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
							pt.xs0 = es === "none" && (p === "display" || p.indexOf("Style") !== -1) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
							//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
						}
					}
				}
				if (plugin) if (pt && !pt.plugin) {
					pt.plugin = plugin;
				}
			}
			return pt;
		};

		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function (v) {
			var pt = this._firstPT,
			    min = 0.000001,
			    val,
			    str,
			    i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						if (pt.r && pt.type !== -1) {
							val = Math.round(pt.s + pt.c);
							if (!pt.type) {
								pt.t[pt.p] = val + pt.xs0;
							} else if (pt.type === 1) {
								//complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
								i = pt.l;
								str = pt.xs0 + val + pt.xs1;
								for (i = 1; i < pt.l; i++) {
									str += pt["xn" + i] + pt["xs" + (i + 1)];
								}
								pt.t[pt.p] = str;
							}
						} else {
							pt.t[pt.p] = pt.e;
						}
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					} else if (val < min) if (val > -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) {
						//complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn" + i] + pt["xs" + (i + 1)];
							}
							pt.t[pt.p] = str;
						}
					} else if (pt.type === -1) {
						//non-tweening value
						pt.t[pt.p] = pt.xs0;
					} else if (pt.setRatio) {
						//custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

				//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.b;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			}
		};

		/**
   * @private
   * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
   * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
   * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
   * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
   * doesn't have any transform-related properties of its own. You can call this method as many times as you
   * want and it won't create duplicate CSSPropTweens.
   *
   * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
   */
		p._enableTransforms = function (threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = !(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3) ? 3 : 2;
		};

		var lazySet = function (v) {
			this.t[this.p] = this.e;
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};
		/** @private Gives us a way to set a value on the first render (and only the first render). **/
		p._addLazySet = function (t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		};

		/** @private **/
		p._linkCSSP = function (pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove && this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		};

		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function (lookup) {
			var copy = lookup,
			    pt,
			    p,
			    xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) {
					//copy the lookup so that we're not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className && (pt = this._classNamePT)) {
				//for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;
				if (xfirst && xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
					this._firstPT = pt._next;
				}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			return TweenPlugin.prototype._kill.call(this, copy);
		};

		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
		var _getChildStyles = function (e, props, targets) {
			var children, i, child, type;
			if (e.slice) {
				i = e.length;
				while (--i > -1) {
					_getChildStyles(e[i], props, targets);
				}
				return;
			}
			children = e.childNodes;
			i = children.length;
			while (--i > -1) {
				child = children[i];
				type = child.type;
				if (child.style) {
					props.push(_getAllStyles(child));
					if (targets) {
						targets.push(child);
					}
				}
				if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
					_getChildStyles(child, props, targets);
				}
			}
		};

		/**
   * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
   * and then compares the style properties of all the target's child elements at the tween's start and end, and
   * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
   * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
   * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
   * is because it creates entirely new tweens that may have completely different targets than the original tween,
   * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
   * and it would create other problems. For example:
   *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
   *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
   *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
   *
   * @param {Object} target object to be tweened
   * @param {number} Duration in seconds (or frames for frames-based tweens)
   * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
   * @return {Array} An array of TweenLite instances
   */
		CSSPlugin.cascadeTo = function (target, duration, vars) {
			var tween = TweenLite.to(target, duration, vars),
			    results = [tween],
			    b = [],
			    e = [],
			    targets = [],
			    _reservedProps = TweenLite._internals.reservedProps,
			    i,
			    difs,
			    p,
			    from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i > -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		};

		TweenPlugin.activate([CSSPlugin]);
		return CSSPlugin;
	}, true);

	/*
  * ----------------------------------------------------------------
  * RoundPropsPlugin
  * ----------------------------------------------------------------
  */
	(function () {

		var RoundPropsPlugin = _gsScope._gsDefine.plugin({
			propName: "roundProps",
			version: "1.5",
			priority: -1,
			API: 2,

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function (target, value, tween) {
				this._tween = tween;
				return true;
			}

		}),
		    _roundLinkedList = function (node) {
			while (node) {
				if (!node.f && !node.blob) {
					node.r = 1;
				}
				node = node._next;
			}
		},
		    p = RoundPropsPlugin.prototype;

		p._onInitAllProps = function () {
			var tween = this._tween,
			    rp = tween.vars.roundProps.join ? tween.vars.roundProps : tween.vars.roundProps.split(","),
			    i = rp.length,
			    lookup = {},
			    rpt = tween._propLookup.roundProps,
			    prop,
			    pt,
			    next;
			while (--i > -1) {
				lookup[rp[i]] = 1;
			}
			i = rp.length;
			while (--i > -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._roundProps(lookup, true);
					} else if (pt.n === prop) {
						if (pt.f === 2 && pt.t) {
							//a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
								next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = next;
							} else if (tween._firstPT === pt) {
								tween._firstPT = next;
							}
							pt._next = pt._prev = null;
							tween._propLookup[prop] = rpt;
						}
					}
					pt = next;
				}
			}
			return false;
		};

		p._add = function (target, p, s, c) {
			this._addTween(target, p, s, s + c, p, true);
			this._overwriteProps.push(p);
		};
	})();

	/*
  * ----------------------------------------------------------------
  * AttrPlugin
  * ----------------------------------------------------------------
  */

	(function () {

		_gsScope._gsDefine.plugin({
			propName: "attr",
			API: 2,
			version: "0.5.0",

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function (target, value, tween) {
				var p;
				if (typeof target.setAttribute !== "function") {
					return false;
				}
				for (p in value) {
					this._addTween(target, "setAttribute", target.getAttribute(p) + "", value[p] + "", p, false, p);
					this._overwriteProps.push(p);
				}
				return true;
			}

		});
	})();

	/*
  * ----------------------------------------------------------------
  * DirectionalRotationPlugin
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.2.1",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function (target, value, tween) {
			if (typeof value !== "object") {
				value = { rotation: value };
			}
			this.finals = {};
			var cap = value.useRadians === true ? Math.PI * 2 : 360,
			    min = 0.000001,
			    p,
			    v,
			    start,
			    end,
			    dif,
			    split;
			for (p in value) {
				if (p !== "useRadians") {
					split = (value[p] + "").split("_");
					v = split[0];
					start = parseFloat(typeof target[p] !== "function" ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]());
					end = this.finals[p] = typeof v === "string" && v.charAt(1) === "=" ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = dif < 0 ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function (ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;

	/*
  * ----------------------------------------------------------------
  * EasePack
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function (Ease) {

		var w = _gsScope.GreenSockGlobals || _gsScope,
		    gs = w.com.greensock,
		    _2PI = Math.PI * 2,
		    _HALF_PI = Math.PI / 2,
		    _class = gs._class,
		    _create = function (n, f) {
			var C = _class("easing." + n, function () {}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			return C;
		},
		    _easeReg = Ease.register || function () {},
		    //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
		_wrap = function (name, EaseOut, EaseIn, EaseInOut, aliases) {
			var C = _class("easing." + name, {
				easeOut: new EaseOut(),
				easeIn: new EaseIn(),
				easeInOut: new EaseInOut()
			}, true);
			_easeReg(C, name);
			return C;
		},
		    EasePoint = function (time, value, next) {
			this.t = time;
			this.v = value;
			if (next) {
				this.next = next;
				next.prev = this;
				this.c = next.v - value;
				this.gap = next.t - time;
			}
		},


		//Back
		_createBack = function (n, f) {
			var C = _class("easing." + n, function (overshoot) {
				this._p1 = overshoot || overshoot === 0 ? overshoot : 1.70158;
				this._p2 = this._p1 * 1.525;
			}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function (overshoot) {
				return new C(overshoot);
			};
			return C;
		},
		    Back = _wrap("Back", _createBack("BackOut", function (p) {
			return (p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1;
		}), _createBack("BackIn", function (p) {
			return p * p * ((this._p1 + 1) * p - this._p1);
		}), _createBack("BackInOut", function (p) {
			return (p *= 2) < 1 ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
		})),


		//SlowMo
		SlowMo = _class("easing.SlowMo", function (linearRatio, power, yoyoMode) {
			power = power || power === 0 ? power : 0.7;
			if (linearRatio == null) {
				linearRatio = 0.7;
			} else if (linearRatio > 1) {
				linearRatio = 1;
			}
			this._p = linearRatio !== 1 ? power : 0;
			this._p1 = (1 - linearRatio) / 2;
			this._p2 = linearRatio;
			this._p3 = this._p1 + this._p2;
			this._calcEnd = yoyoMode === true;
		}, true),
		    p = SlowMo.prototype = new Ease(),
		    SteppedEase,
		    RoughEase,
		    _createElastic;

		p.constructor = SlowMo;
		p.getRatio = function (p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - (p = 1 - p / this._p1) * p : r - (p = 1 - p / this._p1) * p * p * p * r;
			} else if (p > this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + (p - r) * (p = (p - this._p3) / this._p1) * p * p * p;
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);

		p.config = SlowMo.config = function (linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};

		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function (steps) {
			steps = steps || 1;
			this._p1 = 1 / steps;
			this._p2 = steps + 1;
		}, true);
		p = SteppedEase.prototype = new Ease();
		p.constructor = SteppedEase;
		p.getRatio = function (p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return (this._p2 * p >> 0) * this._p1;
		};
		p.config = SteppedEase.config = function (steps) {
			return new SteppedEase(steps);
		};

		//RoughEase
		RoughEase = _class("easing.RoughEase", function (vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
			    a = [],
			    cnt = 0,
			    points = (vars.points || 20) | 0,
			    i = points,
			    randomize = vars.randomize !== false,
			    clamp = vars.clamp === true,
			    template = vars.template instanceof Ease ? vars.template : null,
			    strength = typeof vars.strength === "number" ? vars.strength * 0.4 : 0.4,
			    x,
			    y,
			    bump,
			    invX,
			    obj,
			    pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : 1 / points * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {
					//"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {
					//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += Math.random() * bump - bump * 0.5;
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = { x: x, y: y };
			}
			a.sort(function (a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, pnt.t !== 0 ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function (p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;
		};
		p.config = function (vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();

		//Bounce
		_wrap("Bounce", _create("BounceOut", function (p) {
			if (p < 1 / 2.75) {
				return 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
			} else if (p < 2.5 / 2.75) {
				return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
			}
			return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
		}), _create("BounceIn", function (p) {
			if ((p = 1 - p) < 1 / 2.75) {
				return 1 - 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
			} else if (p < 2.5 / 2.75) {
				return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
			}
			return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
		}), _create("BounceInOut", function (p) {
			var invert = p < 0.5;
			if (invert) {
				p = 1 - p * 2;
			} else {
				p = p * 2 - 1;
			}
			if (p < 1 / 2.75) {
				p = 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
			} else if (p < 2.5 / 2.75) {
				p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
			} else {
				p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}
			return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
		}));

		//CIRC
		_wrap("Circ", _create("CircOut", function (p) {
			return Math.sqrt(1 - (p = p - 1) * p);
		}), _create("CircIn", function (p) {
			return -(Math.sqrt(1 - p * p) - 1);
		}), _create("CircInOut", function (p) {
			return (p *= 2) < 1 ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
		}));

		//Elastic
		_createElastic = function (n, f, def) {
			var C = _class("easing." + n, function (amplitude, period) {
				this._p1 = amplitude >= 1 ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
				this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
				this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
				this._p2 = _2PI / this._p2; //precalculate to optimize
			}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function (amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic", _createElastic("ElasticOut", function (p) {
			return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * this._p2) + 1;
		}, 0.3), _createElastic("ElasticIn", function (p) {
			return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2));
		}, 0.3), _createElastic("ElasticInOut", function (p) {
			return (p *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2) * 0.5 + 1;
		}, 0.45));

		//Expo
		_wrap("Expo", _create("ExpoOut", function (p) {
			return 1 - Math.pow(2, -10 * p);
		}), _create("ExpoIn", function (p) {
			return Math.pow(2, 10 * (p - 1)) - 0.001;
		}), _create("ExpoInOut", function (p) {
			return (p *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
		}));

		//Sine
		_wrap("Sine", _create("SineOut", function (p) {
			return Math.sin(p * _HALF_PI);
		}), _create("SineIn", function (p) {
			return -Math.cos(p * _HALF_PI) + 1;
		}), _create("SineInOut", function (p) {
			return -0.5 * (Math.cos(Math.PI * p) - 1);
		}));

		_class("easing.EaseLookup", {
			find: function (s) {
				return Ease.map[s];
			}
		}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");

		return Back;
	}, true);
});

if (_gsScope._gsDefine) {
	_gsScope._gsQueue.pop()();
} //necessary in case TweenLite was already loaded separately.


/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function (window, moduleName) {

	"use strict";

	var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
	if (_globals.TweenLite) {
		return; //in case the core set of classes is already loaded, don't instantiate twice.
	}
	var _namespace = function (ns) {
		var a = ns.split("."),
		    p = _globals,
		    i;
		for (i = 0; i < a.length; i++) {
			p[a[i]] = p = p[a[i]] || {};
		}
		return p;
	},
	    gs = _namespace("com.greensock"),
	    _tinyNum = 0.0000000001,
	    _slice = function (a) {
		//don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
		var b = [],
		    l = a.length,
		    i;
		for (i = 0; i !== l; b.push(a[i++])) {}
		return b;
	},
	    _emptyFunc = function () {},
	    _isArray = function () {
		//works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
		var toString = Object.prototype.toString,
		    array = toString.call([]);
		return function (obj) {
			return obj != null && (obj instanceof Array || typeof obj === "object" && !!obj.push && toString.call(obj) === array);
		};
	}(),
	    a,
	    i,
	    p,
	    _ticker,
	    _tickerActive,
	    _defLookup = {},


	/**
  * @constructor
  * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
  * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
  * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
  * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
  *
  * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
  * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
  * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
  * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
  * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
  * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
  * sandbox the banner one like:
  *
  * <script>
  *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
  * </script>
  * <script src="js/greensock/v1.7/TweenMax.js"></script>
  * <script>
  *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
  * </script>
  * <script src="js/greensock/v1.6/TweenMax.js"></script>
  * <script>
  *     gs.TweenLite.to(...); //would use v1.7
  *     TweenLite.to(...); //would use v1.6
  * </script>
  *
  * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
  * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
  * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
  * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
  */
	Definition = function (ns, dependencies, func, global) {
		this.sc = _defLookup[ns] ? _defLookup[ns].sc : []; //subclasses
		_defLookup[ns] = this;
		this.gsClass = null;
		this.func = func;
		var _classes = [];
		this.check = function (init) {
			var i = dependencies.length,
			    missing = i,
			    cur,
			    a,
			    n,
			    cl,
			    hasModule;
			while (--i > -1) {
				if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
					_classes[i] = cur.gsClass;
					missing--;
				} else if (init) {
					cur.sc.push(this);
				}
			}
			if (missing === 0 && func) {
				a = ("com.greensock." + ns).split(".");
				n = a.pop();
				cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

				//exports to multiple environments
				if (global) {
					_globals[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
					hasModule = typeof module !== "undefined" && module.exports;
					if (!hasModule && typeof define === "function" && define.amd) {
						//AMD
						define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function () {
							return cl;
						});
					} else if (ns === moduleName && hasModule) {
						//node
						module.exports = cl;
					}
				}
				for (i = 0; i < this.sc.length; i++) {
					this.sc[i].check();
				}
			}
		};
		this.check(true);
	},


	//used to create Definition instances (which basically registers a class that has dependencies).
	_gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
		return new Definition(ns, dependencies, func, global);
	},


	//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
	_class = gs._class = function (ns, func, global) {
		func = func || function () {};
		_gsDefine(ns, [], function () {
			return func;
		}, global);
		return func;
	};

	_gsDefine.globals = _globals;

	/*
  * ----------------------------------------------------------------
  * Ease
  * ----------------------------------------------------------------
  */
	var _baseParams = [0, 0, 1, 1],
	    _blankArray = [],
	    Ease = _class("easing.Ease", function (func, extraParams, type, power) {
		this._func = func;
		this._type = type || 0;
		this._power = power || 0;
		this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
	}, true),
	    _easeMap = Ease.map = {},
	    _easeReg = Ease.register = function (ease, names, types, create) {
		var na = names.split(","),
		    i = na.length,
		    ta = (types || "easeIn,easeOut,easeInOut").split(","),
		    e,
		    name,
		    j,
		    type;
		while (--i > -1) {
			name = na[i];
			e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
			j = ta.length;
			while (--j > -1) {
				type = ta[j];
				_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
			}
		}
	};

	p = Ease.prototype;
	p._calcEnd = false;
	p.getRatio = function (p) {
		if (this._func) {
			this._params[0] = p;
			return this._func.apply(null, this._params);
		}
		var t = this._type,
		    pw = this._power,
		    r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;
		if (pw === 1) {
			r *= r;
		} else if (pw === 2) {
			r *= r * r;
		} else if (pw === 3) {
			r *= r * r * r;
		} else if (pw === 4) {
			r *= r * r * r * r;
		}
		return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;
	};

	//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
	a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
	i = a.length;
	while (--i > -1) {
		p = a[i] + ",Power" + i;
		_easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
		_easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));
		_easeReg(new Ease(null, null, 3, i), p, "easeInOut");
	}
	_easeMap.linear = gs.easing.Linear.easeIn;
	_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


	/*
  * ----------------------------------------------------------------
  * EventDispatcher
  * ----------------------------------------------------------------
  */
	var EventDispatcher = _class("events.EventDispatcher", function (target) {
		this._listeners = {};
		this._eventTarget = target || this;
	});
	p = EventDispatcher.prototype;

	p.addEventListener = function (type, callback, scope, useParam, priority) {
		priority = priority || 0;
		var list = this._listeners[type],
		    index = 0,
		    listener,
		    i;
		if (list == null) {
			this._listeners[type] = list = [];
		}
		i = list.length;
		while (--i > -1) {
			listener = list[i];
			if (listener.c === callback && listener.s === scope) {
				list.splice(i, 1);
			} else if (index === 0 && listener.pr < priority) {
				index = i + 1;
			}
		}
		list.splice(index, 0, { c: callback, s: scope, up: useParam, pr: priority });
		if (this === _ticker && !_tickerActive) {
			_ticker.wake();
		}
	};

	p.removeEventListener = function (type, callback) {
		var list = this._listeners[type],
		    i;
		if (list) {
			i = list.length;
			while (--i > -1) {
				if (list[i].c === callback) {
					list.splice(i, 1);
					return;
				}
			}
		}
	};

	p.dispatchEvent = function (type) {
		var list = this._listeners[type],
		    i,
		    t,
		    listener;
		if (list) {
			i = list.length;
			t = this._eventTarget;
			while (--i > -1) {
				listener = list[i];
				if (listener) {
					if (listener.up) {
						listener.c.call(listener.s || t, { type: type, target: t });
					} else {
						listener.c.call(listener.s || t);
					}
				}
			}
		}
	};

	/*
  * ----------------------------------------------------------------
  * Ticker
  * ----------------------------------------------------------------
  */
	var _reqAnimFrame = window.requestAnimationFrame,
	    _cancelAnimFrame = window.cancelAnimationFrame,
	    _getTime = Date.now || function () {
		return new Date().getTime();
	},
	    _lastUpdate = _getTime();

	//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
	a = ["ms", "moz", "webkit", "o"];
	i = a.length;
	while (--i > -1 && !_reqAnimFrame) {
		_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
		_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
	}

	_class("Ticker", function (fps, useRAF) {
		var _self = this,
		    _startTime = _getTime(),
		    _useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
		    _lagThreshold = 500,
		    _adjustedLag = 33,
		    _tickWord = "tick",
		    //helps reduce gc burden
		_fps,
		    _req,
		    _id,
		    _gap,
		    _nextTime,
		    _tick = function (manual) {
			var elapsed = _getTime() - _lastUpdate,
			    overlap,
			    dispatch;
			if (elapsed > _lagThreshold) {
				_startTime += elapsed - _adjustedLag;
			}
			_lastUpdate += elapsed;
			_self.time = (_lastUpdate - _startTime) / 1000;
			overlap = _self.time - _nextTime;
			if (!_fps || overlap > 0 || manual === true) {
				_self.frame++;
				_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
				dispatch = true;
			}
			if (manual !== true) {
				//make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
				_id = _req(_tick);
			}
			if (dispatch) {
				_self.dispatchEvent(_tickWord);
			}
		};

		EventDispatcher.call(_self);
		_self.time = _self.frame = 0;
		_self.tick = function () {
			_tick(true);
		};

		_self.lagSmoothing = function (threshold, adjustedLag) {
			_lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited
			_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
		};

		_self.sleep = function () {
			if (_id == null) {
				return;
			}
			if (!_useRAF || !_cancelAnimFrame) {
				clearTimeout(_id);
			} else {
				_cancelAnimFrame(_id);
			}
			_req = _emptyFunc;
			_id = null;
			if (_self === _ticker) {
				_tickerActive = false;
			}
		};

		_self.wake = function (seamless) {
			if (_id !== null) {
				_self.sleep();
			} else if (seamless) {
				_startTime += -_lastUpdate + (_lastUpdate = _getTime());
			} else if (_self.frame > 10) {
				//don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
				_lastUpdate = _getTime() - _lagThreshold + 5;
			}
			_req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
				return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
			} : _reqAnimFrame;
			if (_self === _ticker) {
				_tickerActive = true;
			}
			_tick(2);
		};

		_self.fps = function (value) {
			if (!arguments.length) {
				return _fps;
			}
			_fps = value;
			_gap = 1 / (_fps || 60);
			_nextTime = this.time + _gap;
			_self.wake();
		};

		_self.useRAF = function (value) {
			if (!arguments.length) {
				return _useRAF;
			}
			_self.sleep();
			_useRAF = value;
			_self.fps(_fps);
		};
		_self.fps(fps);

		//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
		setTimeout(function () {
			if (_useRAF === "auto" && _self.frame < 5 && document.visibilityState !== "hidden") {
				_self.useRAF(false);
			}
		}, 1500);
	});

	p = gs.Ticker.prototype = new gs.events.EventDispatcher();
	p.constructor = gs.Ticker;

	/*
  * ----------------------------------------------------------------
  * Animation
  * ----------------------------------------------------------------
  */
	var Animation = _class("core.Animation", function (duration, vars) {
		this.vars = vars = vars || {};
		this._duration = this._totalDuration = duration || 0;
		this._delay = Number(vars.delay) || 0;
		this._timeScale = 1;
		this._active = vars.immediateRender === true;
		this.data = vars.data;
		this._reversed = vars.reversed === true;

		if (!_rootTimeline) {
			return;
		}
		if (!_tickerActive) {
			//some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
			_ticker.wake();
		}

		var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
		tl.add(this, tl._time);

		if (this.vars.paused) {
			this.paused(true);
		}
	});

	_ticker = Animation.ticker = new gs.Ticker();
	p = Animation.prototype;
	p._dirty = p._gc = p._initted = p._paused = false;
	p._totalTime = p._time = 0;
	p._rawPrevTime = -1;
	p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
	p._paused = false;

	//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
	var _checkTimeout = function () {
		if (_tickerActive && _getTime() - _lastUpdate > 2000) {
			_ticker.wake();
		}
		setTimeout(_checkTimeout, 2000);
	};
	_checkTimeout();

	p.play = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from, suppressEvents);
		}
		return this.reversed(false).paused(false);
	};

	p.pause = function (atTime, suppressEvents) {
		if (atTime != null) {
			this.seek(atTime, suppressEvents);
		}
		return this.paused(true);
	};

	p.resume = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from, suppressEvents);
		}
		return this.paused(false);
	};

	p.seek = function (time, suppressEvents) {
		return this.totalTime(Number(time), suppressEvents !== false);
	};

	p.restart = function (includeDelay, suppressEvents) {
		return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);
	};

	p.reverse = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from || this.totalDuration(), suppressEvents);
		}
		return this.reversed(true).paused(false);
	};

	p.render = function (time, suppressEvents, force) {
		//stub - we override this method in subclasses.
	};

	p.invalidate = function () {
		this._time = this._totalTime = 0;
		this._initted = this._gc = false;
		this._rawPrevTime = -1;
		if (this._gc || !this.timeline) {
			this._enabled(true);
		}
		return this;
	};

	p.isActive = function () {
		var tl = this._timeline,
		    //the 2 root timelines won't have a _timeline; they're always active.
		startTime = this._startTime,
		    rawTime;
		return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale;
	};

	p._enabled = function (enabled, ignoreTimeline) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		this._gc = !enabled;
		this._active = this.isActive();
		if (ignoreTimeline !== true) {
			if (enabled && !this.timeline) {
				this._timeline.add(this, this._startTime - this._delay);
			} else if (!enabled && this.timeline) {
				this._timeline._remove(this, true);
			}
		}
		return false;
	};

	p._kill = function (vars, target) {
		return this._enabled(false, false);
	};

	p.kill = function (vars, target) {
		this._kill(vars, target);
		return this;
	};

	p._uncache = function (includeSelf) {
		var tween = includeSelf ? this : this.timeline;
		while (tween) {
			tween._dirty = true;
			tween = tween.timeline;
		}
		return this;
	};

	p._swapSelfInParams = function (params) {
		var i = params.length,
		    copy = params.concat();
		while (--i > -1) {
			if (params[i] === "{self}") {
				copy[i] = this;
			}
		}
		return copy;
	};

	p._callback = function (type) {
		var v = this.vars;
		v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
	};

	//----Animation getters/setters --------------------------------------------------------

	p.eventCallback = function (type, callback, params, scope) {
		if ((type || "").substr(0, 2) === "on") {
			var v = this.vars;
			if (arguments.length === 1) {
				return v[type];
			}
			if (callback == null) {
				delete v[type];
			} else {
				v[type] = callback;
				v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
				v[type + "Scope"] = scope;
			}
			if (type === "onUpdate") {
				this._onUpdate = callback;
			}
		}
		return this;
	};

	p.delay = function (value) {
		if (!arguments.length) {
			return this._delay;
		}
		if (this._timeline.smoothChildTiming) {
			this.startTime(this._startTime + value - this._delay);
		}
		this._delay = value;
		return this;
	};

	p.duration = function (value) {
		if (!arguments.length) {
			this._dirty = false;
			return this._duration;
		}
		this._duration = this._totalDuration = value;
		this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
		if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
			this.totalTime(this._totalTime * (value / this._duration), true);
		}
		return this;
	};

	p.totalDuration = function (value) {
		this._dirty = false;
		return !arguments.length ? this._totalDuration : this.duration(value);
	};

	p.time = function (value, suppressEvents) {
		if (!arguments.length) {
			return this._time;
		}
		if (this._dirty) {
			this.totalDuration();
		}
		return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);
	};

	p.totalTime = function (time, suppressEvents, uncapped) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		if (!arguments.length) {
			return this._totalTime;
		}
		if (this._timeline) {
			if (time < 0 && !uncapped) {
				time += this.totalDuration();
			}
			if (this._timeline.smoothChildTiming) {
				if (this._dirty) {
					this.totalDuration();
				}
				var totalDuration = this._totalDuration,
				    tl = this._timeline;
				if (time > totalDuration && !uncapped) {
					time = totalDuration;
				}
				this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;
				if (!tl._dirty) {
					//for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
					this._uncache(false);
				}
				//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
				if (tl._timeline) {
					while (tl._timeline) {
						if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
							tl.totalTime(tl._totalTime, true);
						}
						tl = tl._timeline;
					}
				}
			}
			if (this._gc) {
				this._enabled(true, false);
			}
			if (this._totalTime !== time || this._duration === 0) {
				if (_lazyTweens.length) {
					_lazyRender();
				}
				this.render(time, suppressEvents, false);
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
					_lazyRender();
				}
			}
		}
		return this;
	};

	p.progress = p.totalProgress = function (value, suppressEvents) {
		var duration = this.duration();
		return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents);
	};

	p.startTime = function (value) {
		if (!arguments.length) {
			return this._startTime;
		}
		if (value !== this._startTime) {
			this._startTime = value;
			if (this.timeline) if (this.timeline._sortChildren) {
				this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
			}
		}
		return this;
	};

	p.endTime = function (includeRepeats) {
		return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale;
	};

	p.timeScale = function (value) {
		if (!arguments.length) {
			return this._timeScale;
		}
		value = value || _tinyNum; //can't allow zero because it'll throw the math off
		if (this._timeline && this._timeline.smoothChildTiming) {
			var pauseTime = this._pauseTime,
			    t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
			this._startTime = t - (t - this._startTime) * this._timeScale / value;
		}
		this._timeScale = value;
		return this._uncache(false);
	};

	p.reversed = function (value) {
		if (!arguments.length) {
			return this._reversed;
		}
		if (value != this._reversed) {
			this._reversed = value;
			this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true);
		}
		return this;
	};

	p.paused = function (value) {
		if (!arguments.length) {
			return this._paused;
		}
		var tl = this._timeline,
		    raw,
		    elapsed;
		if (value != this._paused) if (tl) {
			if (!_tickerActive && !value) {
				_ticker.wake();
			}
			raw = tl.rawTime();
			elapsed = raw - this._pauseTime;
			if (!value && tl.smoothChildTiming) {
				this._startTime += elapsed;
				this._uncache(false);
			}
			this._pauseTime = value ? raw : null;
			this._paused = value;
			this._active = this.isActive();
			if (!value && elapsed !== 0 && this._initted && this.duration()) {
				raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
				this.render(raw, raw === this._totalTime, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
			}
		}
		if (this._gc && !value) {
			this._enabled(true, false);
		}
		return this;
	};

	/*
  * ----------------------------------------------------------------
  * SimpleTimeline
  * ----------------------------------------------------------------
  */
	var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
		Animation.call(this, 0, vars);
		this.autoRemoveChildren = this.smoothChildTiming = true;
	});

	p = SimpleTimeline.prototype = new Animation();
	p.constructor = SimpleTimeline;
	p.kill()._gc = false;
	p._first = p._last = p._recent = null;
	p._sortChildren = false;

	p.add = p.insert = function (child, position, align, stagger) {
		var prevTween, st;
		child._startTime = Number(position || 0) + child._delay;
		if (child._paused) if (this !== child._timeline) {
			//we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
			child._pauseTime = child._startTime + (this.rawTime() - child._startTime) / child._timeScale;
		}
		if (child.timeline) {
			child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
		}
		child.timeline = child._timeline = this;
		if (child._gc) {
			child._enabled(true, true);
		}
		prevTween = this._last;
		if (this._sortChildren) {
			st = child._startTime;
			while (prevTween && prevTween._startTime > st) {
				prevTween = prevTween._prev;
			}
		}
		if (prevTween) {
			child._next = prevTween._next;
			prevTween._next = child;
		} else {
			child._next = this._first;
			this._first = child;
		}
		if (child._next) {
			child._next._prev = child;
		} else {
			this._last = child;
		}
		child._prev = prevTween;
		this._recent = child;
		if (this._timeline) {
			this._uncache(true);
		}
		return this;
	};

	p._remove = function (tween, skipDisable) {
		if (tween.timeline === this) {
			if (!skipDisable) {
				tween._enabled(false, true);
			}

			if (tween._prev) {
				tween._prev._next = tween._next;
			} else if (this._first === tween) {
				this._first = tween._next;
			}
			if (tween._next) {
				tween._next._prev = tween._prev;
			} else if (this._last === tween) {
				this._last = tween._prev;
			}
			tween._next = tween._prev = tween.timeline = null;
			if (tween === this._recent) {
				this._recent = this._last;
			}

			if (this._timeline) {
				this._uncache(true);
			}
		}
		return this;
	};

	p.render = function (time, suppressEvents, force) {
		var tween = this._first,
		    next;
		this._totalTime = this._time = this._rawPrevTime = time;
		while (tween) {
			next = tween._next; //record it here because the value could change after rendering...
			if (tween._active || time >= tween._startTime && !tween._paused) {
				if (!tween._reversed) {
					tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
				} else {
					tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
				}
			}
			tween = next;
		}
	};

	p.rawTime = function () {
		if (!_tickerActive) {
			_ticker.wake();
		}
		return this._totalTime;
	};

	/*
  * ----------------------------------------------------------------
  * TweenLite
  * ----------------------------------------------------------------
  */
	var TweenLite = _class("TweenLite", function (target, duration, vars) {
		Animation.call(this, duration, vars);
		this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

		if (target == null) {
			throw "Cannot tween a null target.";
		}

		this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;

		var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
		    overwrite = this.vars.overwrite,
		    i,
		    targ,
		    targets;

		this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];

		if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
			this._targets = targets = _slice(target); //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			this._propLookup = [];
			this._siblings = [];
			for (i = 0; i < targets.length; i++) {
				targ = targets[i];
				if (!targ) {
					targets.splice(i--, 1);
					continue;
				} else if (typeof targ === "string") {
					targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
					if (typeof targ === "string") {
						targets.splice(i + 1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
					}
					continue;
				} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
					//in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
					targets.splice(i--, 1);
					this._targets = targets = targets.concat(_slice(targ));
					continue;
				}
				this._siblings[i] = _register(targ, this, false);
				if (overwrite === 1) if (this._siblings[i].length > 1) {
					_applyOverwrite(targ, this, null, 1, this._siblings[i]);
				}
			}
		} else {
			this._propLookup = {};
			this._siblings = _register(target, this, false);
			if (overwrite === 1) if (this._siblings.length > 1) {
				_applyOverwrite(target, this, null, 1, this._siblings);
			}
		}
		if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
			this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
			this.render(Math.min(0, -this._delay)); //in case delay is negative
		}
	}, true),
	    _isSelector = function (v) {
		return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
	},
	    _autoCSS = function (vars, target) {
		var css = {},
		    p;
		for (p in vars) {
			if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
				//note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
				css[p] = vars[p];
				delete vars[p];
			}
		}
		vars.css = css;
	};

	p = TweenLite.prototype = new Animation();
	p.constructor = TweenLite;
	p.kill()._gc = false;

	//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

	p.ratio = 0;
	p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
	p._notifyPluginsOfEnabled = p._lazy = false;

	TweenLite.version = "1.18.4";
	TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
	TweenLite.defaultOverwrite = "auto";
	TweenLite.ticker = _ticker;
	TweenLite.autoSleep = 120;
	TweenLite.lagSmoothing = function (threshold, adjustedLag) {
		_ticker.lagSmoothing(threshold, adjustedLag);
	};

	TweenLite.selector = window.$ || window.jQuery || function (e) {
		var selector = window.$ || window.jQuery;
		if (selector) {
			TweenLite.selector = selector;
			return selector(e);
		}
		return typeof document === "undefined" ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById(e.charAt(0) === "#" ? e.substr(1) : e);
	};

	var _lazyTweens = [],
	    _lazyLookup = {},
	    _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,

	//_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
	_setRatio = function (v) {
		var pt = this._firstPT,
		    min = 0.000001,
		    val;
		while (pt) {
			val = !pt.blob ? pt.c * v + pt.s : v ? this.join("") : this.start;
			if (pt.r) {
				val = Math.round(val);
			} else if (val < min) if (val > -min) {
				//prevents issues with converting very small numbers to strings in the browser
				val = 0;
			}
			if (!pt.f) {
				pt.t[pt.p] = val;
			} else if (pt.fp) {
				pt.t[pt.p](pt.fp, val);
			} else {
				pt.t[pt.p](val);
			}
			pt = pt._next;
		}
	},

	//compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
	_blobDif = function (start, end, filter, pt) {
		var a = [start, end],
		    charIndex = 0,
		    s = "",
		    color = 0,
		    startNums,
		    endNums,
		    num,
		    i,
		    l,
		    nonNumbers,
		    currentNum;
		a.start = start;
		if (filter) {
			filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
			start = a[0];
			end = a[1];
		}
		a.length = 0;
		startNums = start.match(_numbersExp) || [];
		endNums = end.match(_numbersExp) || [];
		if (pt) {
			pt._next = null;
			pt.blob = 1;
			a._firstPT = pt; //apply last in the linked list (which means inserting it first)
		}
		l = endNums.length;
		for (i = 0; i < l; i++) {
			currentNum = endNums[i];
			nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
			s += nonNumbers || !i ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
			charIndex += nonNumbers.length;
			if (color) {
				//sense rgba() values and round them.
				color = (color + 1) % 5;
			} else if (nonNumbers.substr(-5) === "rgba(") {
				color = 1;
			}
			if (currentNum === startNums[i] || startNums.length <= i) {
				s += currentNum;
			} else {
				if (s) {
					a.push(s);
					s = "";
				}
				num = parseFloat(startNums[i]);
				a.push(num);
				a._firstPT = { _next: a._firstPT, t: a, p: a.length - 1, s: num, c: (currentNum.charAt(1) === "=" ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0, f: 0, r: color && color < 4 };
				//note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
			}
			charIndex += currentNum.length;
		}
		s += end.substr(charIndex);
		if (s) {
			a.push(s);
		}
		a.setRatio = _setRatio;
		return a;
	},

	//note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
	_addPropTween = function (target, prop, start, end, overwriteProp, round, funcParam, stringFilter) {
		var s = start === "get" ? target[prop] : start,
		    type = typeof target[prop],
		    isRelative = typeof end === "string" && end.charAt(1) === "=",
		    pt = { t: target, p: prop, s: s, f: type === "function", pg: 0, n: overwriteProp || prop, r: round, pr: 0, c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0 },
		    blob,
		    getterName;
		if (type !== "number") {
			if (type === "function" && start === "get") {
				getterName = prop.indexOf("set") || typeof target["get" + prop.substr(3)] !== "function" ? prop : "get" + prop.substr(3);
				pt.s = s = funcParam ? target[getterName](funcParam) : target[getterName]();
			}
			if (typeof s === "string" && (funcParam || isNaN(s))) {
				//a blob (string that has multiple numbers in it)
				pt.fp = funcParam;
				blob = _blobDif(s, end, stringFilter || TweenLite.defaultStringFilter, pt);
				pt = { t: blob, p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: overwriteProp || prop, pr: 0 }; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
			} else if (!isRelative) {
				pt.s = parseFloat(s);
				pt.c = parseFloat(end) - pt.s || 0;
			}
		}
		if (pt.c) {
			//only add it to the linked list if there's a change.
			if (pt._next = this._firstPT) {
				pt._next._prev = pt;
			}
			this._firstPT = pt;
			return pt;
		}
	},
	    _internals = TweenLite._internals = { isArray: _isArray, isSelector: _isSelector, lazyTweens: _lazyTweens, blobDif: _blobDif },
	    //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
	_plugins = TweenLite._plugins = {},
	    _tweenLookup = _internals.tweenLookup = {},
	    _tweenLookupNum = 0,
	    _reservedProps = _internals.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1, onOverwrite: 1, callbackScope: 1, stringFilter: 1 },
	    _overwriteLookup = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, "true": 1, "false": 0 },
	    _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
	    _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
	    _nextGCFrame = 30,
	    _lazyRender = _internals.lazyRender = function () {
		var i = _lazyTweens.length,
		    tween;
		_lazyLookup = {};
		while (--i > -1) {
			tween = _lazyTweens[i];
			if (tween && tween._lazy !== false) {
				tween.render(tween._lazy[0], tween._lazy[1], true);
				tween._lazy = false;
			}
		}
		_lazyTweens.length = 0;
	};

	_rootTimeline._startTime = _ticker.time;
	_rootFramesTimeline._startTime = _ticker.frame;
	_rootTimeline._active = _rootFramesTimeline._active = true;
	setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

	Animation._updateRoot = TweenLite.render = function () {
		var i, a, p;
		if (_lazyTweens.length) {
			//if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
			_lazyRender();
		}
		_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
		_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
		if (_lazyTweens.length) {
			_lazyRender();
		}
		if (_ticker.frame >= _nextGCFrame) {
			//dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
			_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
			for (p in _tweenLookup) {
				a = _tweenLookup[p].tweens;
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc) {
						a.splice(i, 1);
					}
				}
				if (a.length === 0) {
					delete _tweenLookup[p];
				}
			}
			//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
			p = _rootTimeline._first;
			if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
				while (p && p._paused) {
					p = p._next;
				}
				if (!p) {
					_ticker.sleep();
				}
			}
		}
	};

	_ticker.addEventListener("tick", Animation._updateRoot);

	var _register = function (target, tween, scrub) {
		var id = target._gsTweenID,
		    a,
		    i;
		if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
			_tweenLookup[id] = { target: target, tweens: [] };
		}
		if (tween) {
			a = _tweenLookup[id].tweens;
			a[i = a.length] = tween;
			if (scrub) {
				while (--i > -1) {
					if (a[i] === tween) {
						a.splice(i, 1);
					}
				}
			}
		}
		return _tweenLookup[id].tweens;
	},
	    _onOverwrite = function (overwrittenTween, overwritingTween, target, killedProps) {
		var func = overwrittenTween.vars.onOverwrite,
		    r1,
		    r2;
		if (func) {
			r1 = func(overwrittenTween, overwritingTween, target, killedProps);
		}
		func = TweenLite.onOverwrite;
		if (func) {
			r2 = func(overwrittenTween, overwritingTween, target, killedProps);
		}
		return r1 !== false && r2 !== false;
	},
	    _applyOverwrite = function (target, tween, props, mode, siblings) {
		var i, changed, curTween, l;
		if (mode === 1 || mode >= 4) {
			l = siblings.length;
			for (i = 0; i < l; i++) {
				if ((curTween = siblings[i]) !== tween) {
					if (!curTween._gc) {
						if (curTween._kill(null, target, tween)) {
							changed = true;
						}
					}
				} else if (mode === 5) {
					break;
				}
			}
			return changed;
		}
		//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
		var startTime = tween._startTime + _tinyNum,
		    overlaps = [],
		    oCount = 0,
		    zeroDur = tween._duration === 0,
		    globalStart;
		i = siblings.length;
		while (--i > -1) {
			if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
				//ignore
			} else if (curTween._timeline !== tween._timeline) {
				globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
				if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
					overlaps[oCount++] = curTween;
				}
			} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
				overlaps[oCount++] = curTween;
			}
		}

		i = oCount;
		while (--i > -1) {
			curTween = overlaps[i];
			if (mode === 2) if (curTween._kill(props, target, tween)) {
				changed = true;
			}
			if (mode !== 2 || !curTween._firstPT && curTween._initted) {
				if (mode !== 2 && !_onOverwrite(curTween, tween)) {
					continue;
				}
				if (curTween._enabled(false, false)) {
					//if all property tweens have been overwritten, kill the tween.
					changed = true;
				}
			}
		}
		return changed;
	},
	    _checkOverlap = function (tween, reference, zeroDur) {
		var tl = tween._timeline,
		    ts = tl._timeScale,
		    t = tween._startTime;
		while (tl._timeline) {
			t += tl._startTime;
			ts *= tl._timeScale;
			if (tl._paused) {
				return -100;
			}
			tl = tl._timeline;
		}
		t /= ts;
		return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
	};

	//---- TweenLite instance methods -----------------------------------------------------------------------------

	p._init = function () {
		var v = this.vars,
		    op = this._overwrittenProps,
		    dur = this._duration,
		    immediate = !!v.immediateRender,
		    ease = v.ease,
		    i,
		    initPlugins,
		    pt,
		    p,
		    startVars;
		if (v.startAt) {
			if (this._startAt) {
				this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
				this._startAt.kill();
			}
			startVars = {};
			for (p in v.startAt) {
				//copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
				startVars[p] = v.startAt[p];
			}
			startVars.overwrite = false;
			startVars.immediateRender = true;
			startVars.lazy = immediate && v.lazy !== false;
			startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
			this._startAt = TweenLite.to(this.target, 0, startVars);
			if (immediate) {
				if (this._time > 0) {
					this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
				} else if (dur !== 0) {
					return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
				}
			}
		} else if (v.runBackwards && dur !== 0) {
			//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
			if (this._startAt) {
				this._startAt.render(-1, true);
				this._startAt.kill();
				this._startAt = null;
			} else {
				if (this._time !== 0) {
					//in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
					immediate = false;
				}
				pt = {};
				for (p in v) {
					//copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
					if (!_reservedProps[p] || p === "autoCSS") {
						pt[p] = v[p];
					}
				}
				pt.overwrite = 0;
				pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
				pt.lazy = immediate && v.lazy !== false;
				pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
				this._startAt = TweenLite.to(this.target, 0, pt);
				if (!immediate) {
					this._startAt._init(); //ensures that the initial values are recorded
					this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
					if (this.vars.immediateRender) {
						this._startAt = null;
					}
				} else if (this._time === 0) {
					return;
				}
			}
		}
		this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
		if (v.easeParams instanceof Array && ease.config) {
			this._ease = ease.config.apply(ease, v.easeParams);
		}
		this._easeType = this._ease._type;
		this._easePower = this._ease._power;
		this._firstPT = null;

		if (this._targets) {
			i = this._targets.length;
			while (--i > -1) {
				if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null)) {
					initPlugins = true;
				}
			}
		} else {
			initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
		}

		if (initPlugins) {
			TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
		}
		if (op) if (!this._firstPT) if (typeof this.target !== "function") {
			//if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
			this._enabled(false, false);
		}
		if (v.runBackwards) {
			pt = this._firstPT;
			while (pt) {
				pt.s += pt.c;
				pt.c = -pt.c;
				pt = pt._next;
			}
		}
		this._onUpdate = v.onUpdate;
		this._initted = true;
	};

	p._initProps = function (target, propLookup, siblings, overwrittenProps) {
		var p, i, initPlugins, plugin, pt, v;
		if (target == null) {
			return false;
		}

		if (_lazyLookup[target._gsTweenID]) {
			_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
		}

		if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) {
			//it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
			_autoCSS(this.vars, target);
		}
		for (p in this.vars) {
			v = this.vars[p];
			if (_reservedProps[p]) {
				if (v) if (v instanceof Array || v.push && _isArray(v)) if (v.join("").indexOf("{self}") !== -1) {
					this.vars[p] = v = this._swapSelfInParams(v, this);
				}
			} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {

				//t - target 		[object]
				//p - property 		[string]
				//s - start			[number]
				//c - change		[number]
				//f - isFunction	[boolean]
				//n - name			[string]
				//pg - isPlugin 	[boolean]
				//pr - priority		[number]
				this._firstPT = pt = { _next: this._firstPT, t: plugin, p: "setRatio", s: 0, c: 1, f: 1, n: p, pg: 1, pr: plugin._priority };
				i = plugin._overwriteProps.length;
				while (--i > -1) {
					propLookup[plugin._overwriteProps[i]] = this._firstPT;
				}
				if (plugin._priority || plugin._onInitAllProps) {
					initPlugins = true;
				}
				if (plugin._onDisable || plugin._onEnable) {
					this._notifyPluginsOfEnabled = true;
				}
				if (pt._next) {
					pt._next._prev = pt;
				}
			} else {
				propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter);
			}
		}

		if (overwrittenProps) if (this._kill(overwrittenProps, target)) {
			//another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
			return this._initProps(target, propLookup, siblings, overwrittenProps);
		}
		if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
			this._kill(propLookup, target);
			return this._initProps(target, propLookup, siblings, overwrittenProps);
		}
		if (this._firstPT) if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
			//zero duration tweens don't lazy render by default; everything else does.
			_lazyLookup[target._gsTweenID] = true;
		}
		return initPlugins;
	};

	p.render = function (time, suppressEvents, force) {
		var prevTime = this._time,
		    duration = this._duration,
		    prevRawPrevTime = this._rawPrevTime,
		    isComplete,
		    callback,
		    pt,
		    rawPrevTime;
		if (time >= duration - 0.0000001) {
			//to work around occasional floating point math artifacts.
			this._totalTime = this._time = duration;
			this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
			if (!this._reversed) {
				isComplete = true;
				callback = "onComplete";
				force = force || this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
			}
			if (duration === 0) if (this._initted || !this.vars.lazy || force) {
				//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
				if (this._startTime === this._timeline._duration) {
					//if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
					time = 0;
				}
				if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause") if (prevRawPrevTime !== time) {
					//note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
					force = true;
					if (prevRawPrevTime > _tinyNum) {
						callback = "onReverseComplete";
					}
				}
				this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
			}
		} else if (time < 0.0000001) {
			//to work around occasional floating point math artifacts, round super small values to 0.
			this._totalTime = this._time = 0;
			this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
			if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
				callback = "onReverseComplete";
				isComplete = this._reversed;
			}
			if (time < 0) {
				this._active = false;
				if (duration === 0) if (this._initted || !this.vars.lazy || force) {
					//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
						force = true;
					}
					this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
			}
			if (!this._initted) {
				//if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
				force = true;
			}
		} else {
			this._totalTime = this._time = time;

			if (this._easeType) {
				var r = time / duration,
				    type = this._easeType,
				    pow = this._easePower;
				if (type === 1 || type === 3 && r >= 0.5) {
					r = 1 - r;
				}
				if (type === 3) {
					r *= 2;
				}
				if (pow === 1) {
					r *= r;
				} else if (pow === 2) {
					r *= r * r;
				} else if (pow === 3) {
					r *= r * r * r;
				} else if (pow === 4) {
					r *= r * r * r * r;
				}

				if (type === 1) {
					this.ratio = 1 - r;
				} else if (type === 2) {
					this.ratio = r;
				} else if (time / duration < 0.5) {
					this.ratio = r / 2;
				} else {
					this.ratio = 1 - r / 2;
				}
			} else {
				this.ratio = this._ease.getRatio(time / duration);
			}
		}

		if (this._time === prevTime && !force) {
			return;
		} else if (!this._initted) {
			this._init();
			if (!this._initted || this._gc) {
				//immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
				return;
			} else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
				this._time = this._totalTime = prevTime;
				this._rawPrevTime = prevRawPrevTime;
				_lazyTweens.push(this);
				this._lazy = [time, suppressEvents];
				return;
			}
			//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
			if (this._time && !isComplete) {
				this.ratio = this._ease.getRatio(this._time / duration);
			} else if (isComplete && this._ease._calcEnd) {
				this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
			}
		}
		if (this._lazy !== false) {
			//in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
			this._lazy = false;
		}
		if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
			this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
		}
		if (prevTime === 0) {
			if (this._startAt) {
				if (time >= 0) {
					this._startAt.render(time, suppressEvents, force);
				} else if (!callback) {
					callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
				}
			}
			if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
				this._callback("onStart");
			}
		}
		pt = this._firstPT;
		while (pt) {
			if (pt.f) {
				pt.t[pt.p](pt.c * this.ratio + pt.s);
			} else {
				pt.t[pt.p] = pt.c * this.ratio + pt.s;
			}
			pt = pt._next;
		}

		if (this._onUpdate) {
			if (time < 0) if (this._startAt && time !== -0.0001) {
				//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
				this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
			}
			if (!suppressEvents) if (this._time !== prevTime || isComplete || force) {
				this._callback("onUpdate");
			}
		}
		if (callback) if (!this._gc || force) {
			//check _gc because there's a chance that kill() could be called in an onUpdate
			if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) {
				//-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
				this._startAt.render(time, suppressEvents, force);
			}
			if (isComplete) {
				if (this._timeline.autoRemoveChildren) {
					this._enabled(false, false);
				}
				this._active = false;
			}
			if (!suppressEvents && this.vars[callback]) {
				this._callback(callback);
			}
			if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
				//the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
				this._rawPrevTime = 0;
			}
		}
	};

	p._kill = function (vars, target, overwritingTween) {
		if (vars === "all") {
			vars = null;
		}
		if (vars == null) if (target == null || target === this.target) {
			this._lazy = false;
			return this._enabled(false, false);
		}
		target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
		var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,
		    i,
		    overwrittenProps,
		    p,
		    pt,
		    propLookup,
		    changed,
		    killProps,
		    record,
		    killed;
		if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
			i = target.length;
			while (--i > -1) {
				if (this._kill(vars, target[i], overwritingTween)) {
					changed = true;
				}
			}
		} else {
			if (this._targets) {
				i = this._targets.length;
				while (--i > -1) {
					if (target === this._targets[i]) {
						propLookup = this._propLookup[i] || {};
						this._overwrittenProps = this._overwrittenProps || [];
						overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
						break;
					}
				}
			} else if (target !== this.target) {
				return false;
			} else {
				propLookup = this._propLookup;
				overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
			}

			if (propLookup) {
				killProps = vars || propLookup;
				record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof vars !== "object" || !vars._tempKill); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
				if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
					for (p in killProps) {
						if (propLookup[p]) {
							if (!killed) {
								killed = [];
							}
							killed.push(p);
						}
					}
					if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
						//if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
						return false;
					}
				}

				for (p in killProps) {
					if (pt = propLookup[p]) {
						if (simultaneousOverwrite) {
							//if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
							if (pt.f) {
								pt.t[pt.p](pt.s);
							} else {
								pt.t[pt.p] = pt.s;
							}
							changed = true;
						}
						if (pt.pg && pt.t._kill(killProps)) {
							changed = true; //some plugins need to be notified so they can perform cleanup tasks first
						}
						if (!pt.pg || pt.t._overwriteProps.length === 0) {
							if (pt._prev) {
								pt._prev._next = pt._next;
							} else if (pt === this._firstPT) {
								this._firstPT = pt._next;
							}
							if (pt._next) {
								pt._next._prev = pt._prev;
							}
							pt._next = pt._prev = null;
						}
						delete propLookup[p];
					}
					if (record) {
						overwrittenProps[p] = 1;
					}
				}
				if (!this._firstPT && this._initted) {
					//if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
					this._enabled(false, false);
				}
			}
		}
		return changed;
	};

	p.invalidate = function () {
		if (this._notifyPluginsOfEnabled) {
			TweenLite._onPluginEvent("_onDisable", this);
		}
		this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
		this._notifyPluginsOfEnabled = this._active = this._lazy = false;
		this._propLookup = this._targets ? {} : [];
		Animation.prototype.invalidate.call(this);
		if (this.vars.immediateRender) {
			this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
			this.render(Math.min(0, -this._delay)); //in case delay is negative.
		}
		return this;
	};

	p._enabled = function (enabled, ignoreTimeline) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		if (enabled && this._gc) {
			var targets = this._targets,
			    i;
			if (targets) {
				i = targets.length;
				while (--i > -1) {
					this._siblings[i] = _register(targets[i], this, true);
				}
			} else {
				this._siblings = _register(this.target, this, true);
			}
		}
		Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
		if (this._notifyPluginsOfEnabled) if (this._firstPT) {
			return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this);
		}
		return false;
	};

	//----TweenLite static methods -----------------------------------------------------

	TweenLite.to = function (target, duration, vars) {
		return new TweenLite(target, duration, vars);
	};

	TweenLite.from = function (target, duration, vars) {
		vars.runBackwards = true;
		vars.immediateRender = vars.immediateRender != false;
		return new TweenLite(target, duration, vars);
	};

	TweenLite.fromTo = function (target, duration, fromVars, toVars) {
		toVars.startAt = fromVars;
		toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
		return new TweenLite(target, duration, toVars);
	};

	TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
		return new TweenLite(callback, 0, { delay: delay, onComplete: callback, onCompleteParams: params, callbackScope: scope, onReverseComplete: callback, onReverseCompleteParams: params, immediateRender: false, lazy: false, useFrames: useFrames, overwrite: 0 });
	};

	TweenLite.set = function (target, vars) {
		return new TweenLite(target, 0, vars);
	};

	TweenLite.getTweensOf = function (target, onlyActive) {
		if (target == null) {
			return [];
		}
		target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
		var i, a, j, t;
		if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
			i = target.length;
			a = [];
			while (--i > -1) {
				a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
			}
			i = a.length;
			//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
			while (--i > -1) {
				t = a[i];
				j = i;
				while (--j > -1) {
					if (t === a[j]) {
						a.splice(i, 1);
					}
				}
			}
		} else {
			a = _register(target).concat();
			i = a.length;
			while (--i > -1) {
				if (a[i]._gc || onlyActive && !a[i].isActive()) {
					a.splice(i, 1);
				}
			}
		}
		return a;
	};

	TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
		if (typeof onlyActive === "object") {
			vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
			onlyActive = false;
		}
		var a = TweenLite.getTweensOf(target, onlyActive),
		    i = a.length;
		while (--i > -1) {
			a[i]._kill(vars, target);
		}
	};

	/*
  * ----------------------------------------------------------------
  * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
  * ----------------------------------------------------------------
  */
	var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
		this._overwriteProps = (props || "").split(",");
		this._propName = this._overwriteProps[0];
		this._priority = priority || 0;
		this._super = TweenPlugin.prototype;
	}, true);

	p = TweenPlugin.prototype;
	TweenPlugin.version = "1.18.0";
	TweenPlugin.API = 2;
	p._firstPT = null;
	p._addTween = _addPropTween;
	p.setRatio = _setRatio;

	p._kill = function (lookup) {
		var a = this._overwriteProps,
		    pt = this._firstPT,
		    i;
		if (lookup[this._propName] != null) {
			this._overwriteProps = [];
		} else {
			i = a.length;
			while (--i > -1) {
				if (lookup[a[i]] != null) {
					a.splice(i, 1);
				}
			}
		}
		while (pt) {
			if (lookup[pt.n] != null) {
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
					pt._prev = null;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
				}
			}
			pt = pt._next;
		}
		return false;
	};

	p._roundProps = function (lookup, value) {
		var pt = this._firstPT;
		while (pt) {
			if (lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")]) {
				//some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
				pt.r = value;
			}
			pt = pt._next;
		}
	};

	TweenLite._onPluginEvent = function (type, tween) {
		var pt = tween._firstPT,
		    changed,
		    pt2,
		    first,
		    last,
		    next;
		if (type === "_onInitAllProps") {
			//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
			while (pt) {
				next = pt._next;
				pt2 = first;
				while (pt2 && pt2.pr > pt.pr) {
					pt2 = pt2._next;
				}
				if (pt._prev = pt2 ? pt2._prev : last) {
					pt._prev._next = pt;
				} else {
					first = pt;
				}
				if (pt._next = pt2) {
					pt2._prev = pt;
				} else {
					last = pt;
				}
				pt = next;
			}
			pt = tween._firstPT = first;
		}
		while (pt) {
			if (pt.pg) if (typeof pt.t[type] === "function") if (pt.t[type]()) {
				changed = true;
			}
			pt = pt._next;
		}
		return changed;
	};

	TweenPlugin.activate = function (plugins) {
		var i = plugins.length;
		while (--i > -1) {
			if (plugins[i].API === TweenPlugin.API) {
				_plugins[new plugins[i]()._propName] = plugins[i];
			}
		}
		return true;
	};

	//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
	_gsDefine.plugin = function (config) {
		if (!config || !config.propName || !config.init || !config.API) {
			throw "illegal plugin definition.";
		}
		var propName = config.propName,
		    priority = config.priority || 0,
		    overwriteProps = config.overwriteProps,
		    map = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_roundProps", initAll: "_onInitAllProps" },
		    Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
			TweenPlugin.call(this, propName, priority);
			this._overwriteProps = overwriteProps || [];
		}, config.global === true),
		    p = Plugin.prototype = new TweenPlugin(propName),
		    prop;
		p.constructor = Plugin;
		Plugin.API = config.API;
		for (prop in map) {
			if (typeof config[prop] === "function") {
				p[map[prop]] = config[prop];
			}
		}
		Plugin.version = config.version;
		TweenPlugin.activate([Plugin]);
		return Plugin;
	};

	//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
	a = window._gsQueue;
	if (a) {
		for (i = 0; i < a.length; i++) {
			a[i]();
		}
		for (p in _defLookup) {
			if (!_defLookup[p].func) {
				window.console.log("GSAP encountered missing dependency: com.greensock." + p);
			}
		}
	}

	_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated
})(typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window, "TweenMax");
'use strict';

/*!
 * ScrollMagic v2.0.5 (2015-04-29)
 * The javascript library for magical scroll interactions.
 * (c) 2015 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.5
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic main library.
 */
/**
 * @namespace ScrollMagic
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		module.exports = factory();
	} else {
		// Browser global
		root.ScrollMagic = factory();
	}
})(this, function () {
	"use strict";

	var ScrollMagic = function () {
		_util.log(2, '(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use \'new ScrollMagic.Controller()\' to create a new controller instance. Use \'new ScrollMagic.Scene()\' to instance a scene.');
	};

	ScrollMagic.version = "2.0.5";

	// TODO: temporary workaround for chrome's scroll jitter bug
	window.addEventListener("mousewheel", function () {});

	// global const
	var PIN_SPACER_ATTRIBUTE = "data-scrollmagic-pin-spacer";

	/**
  * The main class that is needed once per scroll container.
  *
  * @class
  *
  * @example
  * // basic initialization
  * var controller = new ScrollMagic.Controller();
  *
  * // passing options
  * var controller = new ScrollMagic.Controller({container: "#myContainer", loglevel: 3});
  *
  * @param {object} [options] - An object containing one or more options for the controller.
  * @param {(string|object)} [options.container=window] - A selector, DOM object that references the main container for scrolling.
  * @param {boolean} [options.vertical=true] - Sets the scroll mode to vertical (`true`) or horizontal (`false`) scrolling.
  * @param {object} [options.globalSceneOptions={}] - These options will be passed to every Scene that is added to the controller using the addScene method. For more information on Scene options see {@link ScrollMagic.Scene}.
  * @param {number} [options.loglevel=2] Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
  ** `0` => silent
  ** `1` => errors
  ** `2` => errors, warnings
  ** `3` => errors, warnings, debuginfo
  * @param {boolean} [options.refreshInterval=100] - Some changes don't call events by default, like changing the container size or moving a scene trigger element.  
  This interval polls these parameters to fire the necessary events.  
  If you don't use custom containers, trigger elements or have static layouts, where the positions of the trigger elements don't change, you can set this to 0 disable interval checking and improve performance.
  *
  */
	ScrollMagic.Controller = function (options) {
		/*
  	 * ----------------------------------------------------------------
  	 * settings
  	 * ----------------------------------------------------------------
  	 */
		var NAMESPACE = 'ScrollMagic.Controller',
		    SCROLL_DIRECTION_FORWARD = 'FORWARD',
		    SCROLL_DIRECTION_REVERSE = 'REVERSE',
		    SCROLL_DIRECTION_PAUSED = 'PAUSED',
		    DEFAULT_OPTIONS = CONTROLLER_OPTIONS.defaults;

		/*
  	 * ----------------------------------------------------------------
  	 * private vars
  	 * ----------------------------------------------------------------
  	 */
		var Controller = this,
		    _options = _util.extend({}, DEFAULT_OPTIONS, options),
		    _sceneObjects = [],
		    _updateScenesOnNextCycle = false,

		// can be boolean (true => all scenes) or an array of scenes to be updated
		_scrollPos = 0,
		    _scrollDirection = SCROLL_DIRECTION_PAUSED,
		    _isDocument = true,
		    _viewPortSize = 0,
		    _enabled = true,
		    _updateTimeout,
		    _refreshTimeout;

		/*
  	 * ----------------------------------------------------------------
  	 * private functions
  	 * ----------------------------------------------------------------
  	 */

		/**
   * Internal constructor function of the ScrollMagic Controller
   * @private
   */
		var construct = function () {
			for (var key in _options) {
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			_options.container = _util.get.elements(_options.container)[0];
			// check ScrollContainer
			if (!_options.container) {
				log(1, "ERROR creating object " + NAMESPACE + ": No valid scroll container supplied");
				throw NAMESPACE + " init failed."; // cancel
			}
			_isDocument = _options.container === window || _options.container === document.body || !document.body.contains(_options.container);
			// normalize to window
			if (_isDocument) {
				_options.container = window;
			}
			// update container size immediately
			_viewPortSize = getViewportSize();
			// set event handlers
			_options.container.addEventListener("resize", onChange);
			_options.container.addEventListener("scroll", onChange);

			_options.refreshInterval = parseInt(_options.refreshInterval) || DEFAULT_OPTIONS.refreshInterval;
			scheduleRefresh();

			log(3, "added new " + NAMESPACE + " controller (v" + ScrollMagic.version + ")");
		};

		/**
   * Schedule the next execution of the refresh function
   * @private
   */
		var scheduleRefresh = function () {
			if (_options.refreshInterval > 0) {
				_refreshTimeout = window.setTimeout(refresh, _options.refreshInterval);
			}
		};

		/**
   * Default function to get scroll pos - overwriteable using `Controller.scrollPos(newFunction)`
   * @private
   */
		var getScrollPos = function () {
			return _options.vertical ? _util.get.scrollTop(_options.container) : _util.get.scrollLeft(_options.container);
		};

		/**
   * Returns the current viewport Size (width vor horizontal, height for vertical)
   * @private
   */
		var getViewportSize = function () {
			return _options.vertical ? _util.get.height(_options.container) : _util.get.width(_options.container);
		};

		/**
   * Default function to set scroll pos - overwriteable using `Controller.scrollTo(newFunction)`
   * Make available publicly for pinned mousewheel workaround.
   * @private
   */
		var setScrollPos = this._setScrollPos = function (pos) {
			if (_options.vertical) {
				if (_isDocument) {
					window.scrollTo(_util.get.scrollLeft(), pos);
				} else {
					_options.container.scrollTop = pos;
				}
			} else {
				if (_isDocument) {
					window.scrollTo(pos, _util.get.scrollTop());
				} else {
					_options.container.scrollLeft = pos;
				}
			}
		};

		/**
   * Handle updates in cycles instead of on scroll (performance)
   * @private
   */
		var updateScenes = function () {
			if (_enabled && _updateScenesOnNextCycle) {
				// determine scenes to update
				var scenesToUpdate = _util.type.Array(_updateScenesOnNextCycle) ? _updateScenesOnNextCycle : _sceneObjects.slice(0);
				// reset scenes
				_updateScenesOnNextCycle = false;
				var oldScrollPos = _scrollPos;
				// update scroll pos now instead of onChange, as it might have changed since scheduling (i.e. in-browser smooth scroll)
				_scrollPos = Controller.scrollPos();
				var deltaScroll = _scrollPos - oldScrollPos;
				if (deltaScroll !== 0) {
					// scroll position changed?
					_scrollDirection = deltaScroll > 0 ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_REVERSE;
				}
				// reverse order of scenes if scrolling reverse
				if (_scrollDirection === SCROLL_DIRECTION_REVERSE) {
					scenesToUpdate.reverse();
				}
				// update scenes
				scenesToUpdate.forEach(function (scene, index) {
					log(3, "updating Scene " + (index + 1) + "/" + scenesToUpdate.length + " (" + _sceneObjects.length + " total)");
					scene.update(true);
				});
				if (scenesToUpdate.length === 0 && _options.loglevel >= 3) {
					log(3, "updating 0 Scenes (nothing added to controller)");
				}
			}
		};

		/**
   * Initializes rAF callback
   * @private
   */
		var debounceUpdate = function () {
			_updateTimeout = _util.rAF(updateScenes);
		};

		/**
   * Handles Container changes
   * @private
   */
		var onChange = function (e) {
			log(3, "event fired causing an update:", e.type);
			if (e.type == "resize") {
				// resize
				_viewPortSize = getViewportSize();
				_scrollDirection = SCROLL_DIRECTION_PAUSED;
			}
			// schedule update
			if (_updateScenesOnNextCycle !== true) {
				_updateScenesOnNextCycle = true;
				debounceUpdate();
			}
		};

		var refresh = function () {
			if (!_isDocument) {
				// simulate resize event. Only works for viewport relevant param (performance)
				if (_viewPortSize != getViewportSize()) {
					var resizeEvent;
					try {
						resizeEvent = new Event('resize', {
							bubbles: false,
							cancelable: false
						});
					} catch (e) {
						// stupid IE
						resizeEvent = document.createEvent("Event");
						resizeEvent.initEvent("resize", false, false);
					}
					_options.container.dispatchEvent(resizeEvent);
				}
			}
			_sceneObjects.forEach(function (scene, index) {
				// refresh all scenes
				scene.refresh();
			});
			scheduleRefresh();
		};

		/**
   * Send a debug message to the console.
   * provided publicly with _log for plugins
   * @private
   *
   * @param {number} loglevel - The loglevel required to initiate output for the message.
   * @param {...mixed} output - One or more variables that should be passed to the console.
   */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};
		// for scenes we have getters for each option, but for the controller we don't, so we need to make it available externally for plugins
		this._options = _options;

		/**
   * Sort scenes in ascending order of their start offset.
   * @private
   *
   * @param {array} ScenesArray - an array of ScrollMagic Scenes that should be sorted
   * @return {array} The sorted array of Scenes.
   */
		var sortScenes = function (ScenesArray) {
			if (ScenesArray.length <= 1) {
				return ScenesArray;
			} else {
				var scenes = ScenesArray.slice(0);
				scenes.sort(function (a, b) {
					return a.scrollOffset() > b.scrollOffset() ? 1 : -1;
				});
				return scenes;
			}
		};

		/**
   * ----------------------------------------------------------------
   * public functions
   * ----------------------------------------------------------------
   */

		/**
   * Add one ore more scene(s) to the controller.  
   * This is the equivalent to `Scene.addTo(controller)`.
   * @public
   * @example
   * // with a previously defined scene
   * controller.addScene(scene);
   *
   * // with a newly created scene.
   * controller.addScene(new ScrollMagic.Scene({duration : 0}));
   *
   * // adding multiple scenes
   * controller.addScene([scene, scene2, new ScrollMagic.Scene({duration : 0})]);
   *
   * @param {(ScrollMagic.Scene|array)} newScene - ScrollMagic Scene or Array of Scenes to be added to the controller.
   * @return {Controller} Parent object for chaining.
   */
		this.addScene = function (newScene) {
			if (_util.type.Array(newScene)) {
				newScene.forEach(function (scene, index) {
					Controller.addScene(scene);
				});
			} else if (newScene instanceof ScrollMagic.Scene) {
				if (newScene.controller() !== Controller) {
					newScene.addTo(Controller);
				} else if (_sceneObjects.indexOf(newScene) < 0) {
					// new scene
					_sceneObjects.push(newScene); // add to array
					_sceneObjects = sortScenes(_sceneObjects); // sort
					newScene.on("shift.controller_sort", function () {
						// resort whenever scene moves
						_sceneObjects = sortScenes(_sceneObjects);
					});
					// insert Global defaults.
					for (var key in _options.globalSceneOptions) {
						if (newScene[key]) {
							newScene[key].call(newScene, _options.globalSceneOptions[key]);
						}
					}
					log(3, "adding Scene (now " + _sceneObjects.length + " total)");
				}
			} else {
				log(1, "ERROR: invalid argument supplied for '.addScene()'");
			}
			return Controller;
		};

		/**
   * Remove one ore more scene(s) from the controller.  
   * This is the equivalent to `Scene.remove()`.
   * @public
   * @example
   * // remove a scene from the controller
   * controller.removeScene(scene);
   *
   * // remove multiple scenes from the controller
   * controller.removeScene([scene, scene2, scene3]);
   *
   * @param {(ScrollMagic.Scene|array)} Scene - ScrollMagic Scene or Array of Scenes to be removed from the controller.
   * @returns {Controller} Parent object for chaining.
   */
		this.removeScene = function (Scene) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.removeScene(scene);
				});
			} else {
				var index = _sceneObjects.indexOf(Scene);
				if (index > -1) {
					Scene.off("shift.controller_sort");
					_sceneObjects.splice(index, 1);
					log(3, "removing Scene (now " + _sceneObjects.length + " left)");
					Scene.remove();
				}
			}
			return Controller;
		};

		/**
   * Update one ore more scene(s) according to the scroll position of the container.  
   * This is the equivalent to `Scene.update()`.  
   * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
   * It then updates the current scene state accordingly (or does nothing, if the state is already correct)  Pins will be set to their correct position and tweens will be updated to their correct progress.  
   * _**Note:** This method gets called constantly whenever Controller detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
   * @public
   * @example
   * // update a specific scene on next cycle
   * controller.updateScene(scene);
   *
   * // update a specific scene immediately
   * controller.updateScene(scene, true);
   *
   * // update multiple scenes scene on next cycle
   * controller.updateScene([scene1, scene2, scene3]);
   *
   * @param {ScrollMagic.Scene} Scene - ScrollMagic Scene or Array of Scenes that is/are supposed to be updated.
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle.  
   This is useful when changing multiple properties of the scene - this way it will only be updated once all new properties are set (updateScenes).
   * @return {Controller} Parent object for chaining.
   */
		this.updateScene = function (Scene, immediately) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.updateScene(scene, immediately);
				});
			} else {
				if (immediately) {
					Scene.update(true);
				} else if (_updateScenesOnNextCycle !== true && Scene instanceof ScrollMagic.Scene) {
					// if _updateScenesOnNextCycle is true, all connected scenes are already scheduled for update
					// prep array for next update cycle
					_updateScenesOnNextCycle = _updateScenesOnNextCycle || [];
					if (_updateScenesOnNextCycle.indexOf(Scene) == -1) {
						_updateScenesOnNextCycle.push(Scene);
					}
					_updateScenesOnNextCycle = sortScenes(_updateScenesOnNextCycle); // sort
					debounceUpdate();
				}
			}
			return Controller;
		};

		/**
   * Updates the controller params and calls updateScene on every scene, that is attached to the controller.  
   * See `Controller.updateScene()` for more information about what this means.  
   * In most cases you will not need this function, as it is called constantly, whenever ScrollMagic detects a state change event, like resize or scroll.  
   * The only application for this method is when ScrollMagic fails to detect these events.  
   * One application is with some external scroll libraries (like iScroll) that move an internal container to a negative offset instead of actually scrolling. In this case the update on the controller needs to be called whenever the child container's position changes.
   * For this case there will also be the need to provide a custom function to calculate the correct scroll position. See `Controller.scrollPos()` for details.
   * @public
   * @example
   * // update the controller on next cycle (saves performance due to elimination of redundant updates)
   * controller.update();
   *
   * // update the controller immediately
   * controller.update(true);
   *
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance)
   * @return {Controller} Parent object for chaining.
   */
		this.update = function (immediately) {
			onChange({
				type: "resize"
			}); // will update size and set _updateScenesOnNextCycle to true
			if (immediately) {
				updateScenes();
			}
			return Controller;
		};

		/**
   * Scroll to a numeric scroll offset, a DOM element, the start of a scene or provide an alternate method for scrolling.  
   * For vertical controllers it will change the top scroll offset and for horizontal applications it will change the left offset.
   * @public
   *
   * @since 1.1.0
   * @example
   * // scroll to an offset of 100
   * controller.scrollTo(100);
   *
   * // scroll to a DOM element
   * controller.scrollTo("#anchor");
   *
   * // scroll to the beginning of a scene
   * var scene = new ScrollMagic.Scene({offset: 200});
   * controller.scrollTo(scene);
   *
   * // define a new scroll position modification function (jQuery animate instead of jump)
   * controller.scrollTo(function (newScrollPos) {
   *	$("html, body").animate({scrollTop: newScrollPos});
   * });
   * controller.scrollTo(100); // call as usual, but the new function will be used instead
   *
   * // define a new scroll function with an additional parameter
   * controller.scrollTo(function (newScrollPos, message) {
   *  console.log(message);
   *	$(this).animate({scrollTop: newScrollPos});
   * });
   * // call as usual, but supply an extra parameter to the defined custom function
   * controller.scrollTo(100, "my message");
   *
   * // define a new scroll function with an additional parameter containing multiple variables
   * controller.scrollTo(function (newScrollPos, options) {
   *  someGlobalVar = options.a + options.b;
   *	$(this).animate({scrollTop: newScrollPos});
   * });
   * // call as usual, but supply an extra parameter containing multiple options
   * controller.scrollTo(100, {a: 1, b: 2});
   *
   * // define a new scroll function with a callback supplied as an additional parameter
   * controller.scrollTo(function (newScrollPos, callback) {
   *	$(this).animate({scrollTop: newScrollPos}, 400, "swing", callback);
   * });
   * // call as usual, but supply an extra parameter, which is used as a callback in the previously defined custom scroll function
   * controller.scrollTo(100, function() {
   *	console.log("scroll has finished.");
   * });
   *
   * @param {mixed} scrollTarget - The supplied argument can be one of these types:
   * 1. `number` -> The container will scroll to this new scroll offset.
   * 2. `string` or `object` -> Can be a selector or a DOM object.  
   *  The container will scroll to the position of this element.
   * 3. `ScrollMagic Scene` -> The container will scroll to the start of this scene.
   * 4. `function` -> This function will be used for future scroll position modifications.  
   *  This provides a way for you to change the behaviour of scrolling and adding new behaviour like animation. The function receives the new scroll position as a parameter and a reference to the container element using `this`.  
   *  It may also optionally receive an optional additional parameter (see below)  
   *  _**NOTE:**  
   *  All other options will still work as expected, using the new function to scroll._
   * @param {mixed} [additionalParameter] - If a custom scroll function was defined (see above 4.), you may want to supply additional parameters to it, when calling it. You can do this using this parameter  see examples for details. Please note, that this parameter will have no effect, if you use the default scrolling function.
   * @returns {Controller} Parent object for chaining.
   */
		this.scrollTo = function (scrollTarget, additionalParameter) {
			if (_util.type.Number(scrollTarget)) {
				// excecute
				setScrollPos.call(_options.container, scrollTarget, additionalParameter);
			} else if (scrollTarget instanceof ScrollMagic.Scene) {
				// scroll to scene
				if (scrollTarget.controller() === Controller) {
					// check if the controller is associated with this scene
					Controller.scrollTo(scrollTarget.scrollOffset(), additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", scrollTarget);
				}
			} else if (_util.type.Function(scrollTarget)) {
				// assign new scroll function
				setScrollPos = scrollTarget;
			} else {
				// scroll to element
				var elem = _util.get.elements(scrollTarget)[0];
				if (elem) {
					// if parent is pin spacer, use spacer position instead so correct start position is returned for pinned elements.
					while (elem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						elem = elem.parentNode;
					}

					var param = _options.vertical ? "top" : "left",

					// which param is of interest ?
					containerOffset = _util.get.offset(_options.container),

					// container position is needed because element offset is returned in relation to document, not in relation to container.
					elementOffset = _util.get.offset(elem);

					if (!_isDocument) {
						// container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
						containerOffset[param] -= Controller.scrollPos();
					}

					Controller.scrollTo(elementOffset[param] - containerOffset[param], additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", scrollTarget);
				}
			}
			return Controller;
		};

		/**
   * **Get** the current scrollPosition or **Set** a new method to calculate it.  
   * -> **GET**:
   * When used as a getter this function will return the current scroll position.  
   * To get a cached value use Controller.info("scrollPos"), which will be updated in the update cycle.  
   * For vertical controllers it will return the top scroll offset and for horizontal applications it will return the left offset.
   *
   * -> **SET**:
   * When used as a setter this method prodes a way to permanently overwrite the controller's scroll position calculation.  
   * A typical usecase is when the scroll position is not reflected by the containers scrollTop or scrollLeft values, but for example by the inner offset of a child container.  
   * Moving a child container inside a parent is a commonly used method for several scrolling frameworks, including iScroll.  
   * By providing an alternate calculation function you can make sure ScrollMagic receives the correct scroll position.  
   * Please also bear in mind that your function should return y values for vertical scrolls an x for horizontals.
   *
   * To change the current scroll position please use `Controller.scrollTo()`.
   * @public
   *
   * @example
   * // get the current scroll Position
   * var scrollPos = controller.scrollPos();
   *
   * // set a new scroll position calculation method
   * controller.scrollPos(function () {
   *	return this.info("vertical") ? -mychildcontainer.y : -mychildcontainer.x
   * });
   *
   * @param {function} [scrollPosMethod] - The function to be used for the scroll position calculation of the container.
   * @returns {(number|Controller)} Current scroll position or parent object for chaining.
   */
		this.scrollPos = function (scrollPosMethod) {
			if (!arguments.length) {
				// get
				return getScrollPos.call(Controller);
			} else {
				// set
				if (_util.type.Function(scrollPosMethod)) {
					getScrollPos = scrollPosMethod;
				} else {
					log(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'.");
				}
			}
			return Controller;
		};

		/**
   * **Get** all infos or one in particular about the controller.
   * @public
   * @example
   * // returns the current scroll position (number)
   * var scrollPos = controller.info("scrollPos");
   *
   * // returns all infos as an object
   * var infos = controller.info();
   *
   * @param {string} [about] - If passed only this info will be returned instead of an object containing all.  
   Valid options are:
   ** `"size"` => the current viewport size of the container
   ** `"vertical"` => true if vertical scrolling, otherwise false
   ** `"scrollPos"` => the current scroll position
   ** `"scrollDirection"` => the last known direction of the scroll
   ** `"container"` => the container element
   ** `"isDocument"` => true if container element is the document.
   * @returns {(mixed|object)} The requested info(s).
   */
		this.info = function (about) {
			var values = {
				size: _viewPortSize,
				// contains height or width (in regard to orientation);
				vertical: _options.vertical,
				scrollPos: _scrollPos,
				scrollDirection: _scrollDirection,
				container: _options.container,
				isDocument: _isDocument
			};
			if (!arguments.length) {
				// get all as an object
				return values;
			} else if (values[about] !== undefined) {
				return values[about];
			} else {
				log(1, "ERROR: option \"" + about + "\" is not available");
				return;
			}
		};

		/**
   * **Get** or **Set** the current loglevel option value.
   * @public
   *
   * @example
   * // get the current value
   * var loglevel = controller.loglevel();
   *
   * // set a new value
   * controller.loglevel(3);
   *
   * @param {number} [newLoglevel] - The new loglevel setting of the Controller. `[0-3]`
   * @returns {(number|Controller)} Current loglevel or parent object for chaining.
   */
		this.loglevel = function (newLoglevel) {
			if (!arguments.length) {
				// get
				return _options.loglevel;
			} else if (_options.loglevel != newLoglevel) {
				// set
				_options.loglevel = newLoglevel;
			}
			return Controller;
		};

		/**
   * **Get** or **Set** the current enabled state of the controller.  
   * This can be used to disable all Scenes connected to the controller without destroying or removing them.
   * @public
   *
   * @example
   * // get the current value
   * var enabled = controller.enabled();
   *
   * // disable the controller
   * controller.enabled(false);
   *
   * @param {boolean} [newState] - The new enabled state of the controller `true` or `false`.
   * @returns {(boolean|Controller)} Current enabled state or parent object for chaining.
   */
		this.enabled = function (newState) {
			if (!arguments.length) {
				// get
				return _enabled;
			} else if (_enabled != newState) {
				// set
				_enabled = !!newState;
				Controller.updateScene(_sceneObjects, true);
			}
			return Controller;
		};

		/**
   * Destroy the Controller, all Scenes and everything.
   * @public
   *
   * @example
   * // without resetting the scenes
   * controller = controller.destroy();
   *
   * // with scene reset
   * controller = controller.destroy(true);
   *
   * @param {boolean} [resetScenes=false] - If `true` the pins and tweens (if existent) of all scenes will be reset.
   * @returns {null} Null to unset handler variables.
   */
		this.destroy = function (resetScenes) {
			window.clearTimeout(_refreshTimeout);
			var i = _sceneObjects.length;
			while (i--) {
				_sceneObjects[i].destroy(resetScenes);
			}
			_options.container.removeEventListener("resize", onChange);
			_options.container.removeEventListener("scroll", onChange);
			_util.cAF(_updateTimeout);
			log(3, "destroyed " + NAMESPACE + " (reset: " + (resetScenes ? "true" : "false") + ")");
			return null;
		};

		// INIT
		construct();
		return Controller;
	};

	// store pagewide controller options
	var CONTROLLER_OPTIONS = {
		defaults: {
			container: window,
			vertical: true,
			globalSceneOptions: {},
			loglevel: 2,
			refreshInterval: 100
		}
	};
	/*
  * method used to add an option to ScrollMagic Scenes.
  */
	ScrollMagic.Controller.addOption = function (name, defaultValue) {
		CONTROLLER_OPTIONS.defaults[name] = defaultValue;
	};
	// instance extension function for plugins
	ScrollMagic.Controller.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Controller = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Controller, oldClass); // copy properties
		ScrollMagic.Controller.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Controller.prototype.constructor = ScrollMagic.Controller; // restore constructor
	};

	/**
  * A Scene defines where the controller should react and how.
  *
  * @class
  *
  * @example
  * // create a standard scene and add it to a controller
  * new ScrollMagic.Scene()
  *		.addTo(controller);
  *
  * // create a scene with custom options and assign a handler to it.
  * var scene = new ScrollMagic.Scene({
  * 		duration: 100,
  *		offset: 200,
  *		triggerHook: "onEnter",
  *		reverse: false
  * });
  *
  * @param {object} [options] - Options for the Scene. The options can be updated at any time.  
  Instead of setting the options for each scene individually you can also set them globally in the controller as the controllers `globalSceneOptions` option. The object accepts the same properties as the ones below.  
  When a scene is added to the controller the options defined using the Scene constructor will be overwritten by those set in `globalSceneOptions`.
  * @param {(number|function)} [options.duration=0] - The duration of the scene. 
  If `0` tweens will auto-play when reaching the scene start point, pins will be pinned indefinetly starting at the start position.  
  A function retuning the duration value is also supported. Please see `Scene.duration()` for details.
  * @param {number} [options.offset=0] - Offset Value for the Trigger Position. If no triggerElement is defined this will be the scroll distance from the start of the page, after which the scene will start.
  * @param {(string|object)} [options.triggerElement=null] - Selector or DOM object that defines the start of the scene. If undefined the scene will start right at the start of the page (unless an offset is set).
  * @param {(number|string)} [options.triggerHook="onCenter"] - Can be a number between 0 and 1 defining the position of the trigger Hook in relation to the viewport.  
  Can also be defined using a string:
  ** `"onEnter"` => `1`
  ** `"onCenter"` => `0.5`
  ** `"onLeave"` => `0`
  * @param {boolean} [options.reverse=true] - Should the scene reverse, when scrolling up?
  * @param {number} [options.loglevel=2] - Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
  ** `0` => silent
  ** `1` => errors
  ** `2` => errors, warnings
  ** `3` => errors, warnings, debuginfo
  * 
  */
	ScrollMagic.Scene = function (options) {

		/*
  	 * ----------------------------------------------------------------
  	 * settings
  	 * ----------------------------------------------------------------
  	 */

		var NAMESPACE = 'ScrollMagic.Scene',
		    SCENE_STATE_BEFORE = 'BEFORE',
		    SCENE_STATE_DURING = 'DURING',
		    SCENE_STATE_AFTER = 'AFTER',
		    DEFAULT_OPTIONS = SCENE_OPTIONS.defaults;

		/*
  	 * ----------------------------------------------------------------
  	 * private vars
  	 * ----------------------------------------------------------------
  	 */

		var Scene = this,
		    _options = _util.extend({}, DEFAULT_OPTIONS, options),
		    _state = SCENE_STATE_BEFORE,
		    _progress = 0,
		    _scrollOffset = {
			start: 0,
			end: 0
		},

		// reflects the controllers's scroll position for the start and end of the scene respectively
		_triggerPos = 0,
		    _enabled = true,
		    _durationUpdateMethod,
		    _controller;

		/**
   * Internal constructor function of the ScrollMagic Scene
   * @private
   */
		var construct = function () {
			for (var key in _options) {
				// check supplied options
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			// add getters/setters for all possible options
			for (var optionName in DEFAULT_OPTIONS) {
				addSceneOption(optionName);
			}
			// validate all options
			validateOption();
		};

		/*
   * ----------------------------------------------------------------
   * Event Management
   * ----------------------------------------------------------------
   */

		var _listeners = {};
		/**
   * Scene start event.  
   * Fires whenever the scroll position its the starting point of the scene.  
   * It will also fire when scrolling back up going over the start position of the scene. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#start
   *
   * @example
   * scene.on("start", function (event) {
   * 	console.log("Hit start point of scene.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"` or `"DURING"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene end event.  
   * Fires whenever the scroll position its the ending point of the scene.  
   * It will also fire when scrolling back up from after the scene and going over its end position. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#end
   *
   * @example
   * scene.on("end", function (event) {
   * 	console.log("Hit end point of scene.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"DURING"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene enter event.  
   * Fires whenever the scene enters the "DURING" state.  
   * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene enters its active scroll timeframe, regardless of the scroll-direction.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#enter
   *
   * @example
   * scene.on("enter", function (event) {
   * 	console.log("Scene entered.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene - always `"DURING"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene leave event.  
   * Fires whenever the scene's state goes from "DURING" to either "BEFORE" or "AFTER".  
   * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene leaves its active scroll timeframe, regardless of the scroll-direction.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#leave
   *
   * @example
   * scene.on("leave", function (event) {
   * 	console.log("Scene left.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene update event.  
   * Fires whenever the scene is updated (but not necessarily changes the progress).
   *
   * @event ScrollMagic.Scene#update
   *
   * @example
   * scene.on("update", function (event) {
   * 	console.log("Scene updated.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.startPos - The starting position of the scene (in relation to the conainer)
   * @property {number} event.endPos - The ending position of the scene (in relation to the conainer)
   * @property {number} event.scrollPos - The current scroll position of the container
   */
		/**
   * Scene progress event.  
   * Fires whenever the progress of the scene changes.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#progress
   *
   * @example
   * scene.on("progress", function (event) {
   * 	console.log("Scene progress changed to " + event.progress);
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"`, `"DURING"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene change event.  
   * Fires whenvever a property of the scene is changed.
   *
   * @event ScrollMagic.Scene#change
   *
   * @example
   * scene.on("change", function (event) {
   * 	console.log("Scene Property \"" + event.what + "\" changed to " + event.newval);
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {string} event.what - Indicates what value has been changed
   * @property {mixed} event.newval - The new value of the changed property
   */
		/**
   * Scene shift event.  
   * Fires whenvever the start or end **scroll offset** of the scene change.
   * This happens explicitely, when one of these values change: `offset`, `duration` or `triggerHook`.
   * It will fire implicitly when the `triggerElement` changes, if the new element has a different position (most cases).
   * It will also fire implicitly when the size of the container changes and the triggerHook is anything other than `onLeave`.
   *
   * @event ScrollMagic.Scene#shift
   * @since 1.1.0
   *
   * @example
   * scene.on("shift", function (event) {
   * 	console.log("Scene moved, because the " + event.reason + " has changed.)");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {string} event.reason - Indicates why the scene has shifted
   */
		/**
   * Scene destroy event.  
   * Fires whenvever the scene is destroyed.
   * This can be used to tidy up custom behaviour used in events.
   *
   * @event ScrollMagic.Scene#destroy
   * @since 1.1.0
   *
   * @example
   * scene.on("enter", function (event) {
   *        // add custom action
   *        $("#my-elem").left("200");
   *      })
   *      .on("destroy", function (event) {
   *        // reset my element to start position
   *        if (event.reset) {
   *          $("#my-elem").left("0");
   *        }
   *      });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {boolean} event.reset - Indicates if the destroy method was called with reset `true` or `false`.
   */
		/**
   * Scene add event.  
   * Fires when the scene is added to a controller.
   * This is mostly used by plugins to know that change might be due.
   *
   * @event ScrollMagic.Scene#add
   * @since 2.0.0
   *
   * @example
   * scene.on("add", function (event) {
   * 	console.log('Scene was added to a new controller.');
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {boolean} event.controller - The controller object the scene was added to.
   */
		/**
   * Scene remove event.  
   * Fires when the scene is removed from a controller.
   * This is mostly used by plugins to know that change might be due.
   *
   * @event ScrollMagic.Scene#remove
   * @since 2.0.0
   *
   * @example
   * scene.on("remove", function (event) {
   * 	console.log('Scene was removed from its controller.');
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   */

		/**
   * Add one ore more event listener.  
   * The callback function will be fired at the respective event, and an object containing relevant data will be passed to the callback.
   * @method ScrollMagic.Scene#on
   *
   * @example
   * function callback (event) {
   * 		console.log("Event fired! (" + event.type + ")");
   * }
   * // add listeners
   * scene.on("change update progress start end enter leave", callback);
   *
   * @param {string} names - The name or names of the event the callback should be attached to.
   * @param {function} callback - A function that should be executed, when the event is dispatched. An event object will be passed to the callback.
   * @returns {Scene} Parent object for chaining.
   */
		this.on = function (names, callback) {
			if (_util.type.Function(callback)) {
				names = names.trim().split(' ');
				names.forEach(function (fullname) {
					var nameparts = fullname.split('.'),
					    eventname = nameparts[0],
					    namespace = nameparts[1];
					if (eventname != "*") {
						// disallow wildcards
						if (!_listeners[eventname]) {
							_listeners[eventname] = [];
						}
						_listeners[eventname].push({
							namespace: namespace || '',
							callback: callback
						});
					}
				});
			} else {
				log(1, "ERROR when calling '.on()': Supplied callback for '" + names + "' is not a valid function!");
			}
			return Scene;
		};

		/**
   * Remove one or more event listener.
   * @method ScrollMagic.Scene#off
   *
   * @example
   * function callback (event) {
   * 		console.log("Event fired! (" + event.type + ")");
   * }
   * // add listeners
   * scene.on("change update", callback);
   * // remove listeners
   * scene.off("change update", callback);
   *
   * @param {string} names - The name or names of the event that should be removed.
   * @param {function} [callback] - A specific callback function that should be removed. If none is passed all callbacks to the event listener will be removed.
   * @returns {Scene} Parent object for chaining.
   */
		this.off = function (names, callback) {
			if (!names) {
				log(1, "ERROR: Invalid event name supplied.");
				return Scene;
			}
			names = names.trim().split(' ');
			names.forEach(function (fullname, key) {
				var nameparts = fullname.split('.'),
				    eventname = nameparts[0],
				    namespace = nameparts[1] || '',
				    removeList = eventname === '*' ? Object.keys(_listeners) : [eventname];
				removeList.forEach(function (remove) {
					var list = _listeners[remove] || [],
					    i = list.length;
					while (i--) {
						var listener = list[i];
						if (listener && (namespace === listener.namespace || namespace === '*') && (!callback || callback == listener.callback)) {
							list.splice(i, 1);
						}
					}
					if (!list.length) {
						delete _listeners[remove];
					}
				});
			});
			return Scene;
		};

		/**
   * Trigger an event.
   * @method ScrollMagic.Scene#trigger
   *
   * @example
   * this.trigger("change");
   *
   * @param {string} name - The name of the event that should be triggered.
   * @param {object} [vars] - An object containing info that should be passed to the callback.
   * @returns {Scene} Parent object for chaining.
   */
		this.trigger = function (name, vars) {
			if (name) {
				var nameparts = name.trim().split('.'),
				    eventname = nameparts[0],
				    namespace = nameparts[1],
				    listeners = _listeners[eventname];
				log(3, 'event fired:', eventname, vars ? "->" : '', vars || '');
				if (listeners) {
					listeners.forEach(function (listener, key) {
						if (!namespace || namespace === listener.namespace) {
							listener.callback.call(Scene, new ScrollMagic.Event(eventname, listener.namespace, Scene, vars));
						}
					});
				}
			} else {
				log(1, "ERROR: Invalid event name supplied.");
			}
			return Scene;
		};

		// set event listeners
		Scene.on("change.internal", function (e) {
			if (e.what !== "loglevel" && e.what !== "tweenChanges") {
				// no need for a scene update scene with these options...
				if (e.what === "triggerElement") {
					updateTriggerElementPosition();
				} else if (e.what === "reverse") {
					// the only property left that may have an impact on the current scene state. Everything else is handled by the shift event.
					Scene.update();
				}
			}
		}).on("shift.internal", function (e) {
			updateScrollOffset();
			Scene.update(); // update scene to reflect new position
		});

		/**
   * Send a debug message to the console.
   * @private
   * but provided publicly with _log for plugins
   *
   * @param {number} loglevel - The loglevel required to initiate output for the message.
   * @param {...mixed} output - One or more variables that should be passed to the console.
   */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};

		/**
   * Add the scene to a controller.  
   * This is the equivalent to `Controller.addScene(scene)`.
   * @method ScrollMagic.Scene#addTo
   *
   * @example
   * // add a scene to a ScrollMagic Controller
   * scene.addTo(controller);
   *
   * @param {ScrollMagic.Controller} controller - The controller to which the scene should be added.
   * @returns {Scene} Parent object for chaining.
   */
		this.addTo = function (controller) {
			if (!(controller instanceof ScrollMagic.Controller)) {
				log(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller");
			} else if (_controller != controller) {
				// new controller
				if (_controller) {
					// was associated to a different controller before, so remove it...
					_controller.removeScene(Scene);
				}
				_controller = controller;
				validateOption();
				updateDuration(true);
				updateTriggerElementPosition(true);
				updateScrollOffset();
				_controller.info("container").addEventListener('resize', onContainerResize);
				controller.addScene(Scene);
				Scene.trigger("add", {
					controller: _controller
				});
				log(3, "added " + NAMESPACE + " to controller");
				Scene.update();
			}
			return Scene;
		};

		/**
   * **Get** or **Set** the current enabled state of the scene.  
   * This can be used to disable this scene without removing or destroying it.
   * @method ScrollMagic.Scene#enabled
   *
   * @example
   * // get the current value
   * var enabled = scene.enabled();
   *
   * // disable the scene
   * scene.enabled(false);
   *
   * @param {boolean} [newState] - The new enabled state of the scene `true` or `false`.
   * @returns {(boolean|Scene)} Current enabled state or parent object for chaining.
   */
		this.enabled = function (newState) {
			if (!arguments.length) {
				// get
				return _enabled;
			} else if (_enabled != newState) {
				// set
				_enabled = !!newState;
				Scene.update(true);
			}
			return Scene;
		};

		/**
   * Remove the scene from the controller.  
   * This is the equivalent to `Controller.removeScene(scene)`.
   * The scene will not be updated anymore until you readd it to a controller.
   * To remove the pin or the tween you need to call removeTween() or removePin() respectively.
   * @method ScrollMagic.Scene#remove
   * @example
   * // remove the scene from its controller
   * scene.remove();
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.remove = function () {
			if (_controller) {
				_controller.info("container").removeEventListener('resize', onContainerResize);
				var tmpParent = _controller;
				_controller = undefined;
				tmpParent.removeScene(Scene);
				Scene.trigger("remove");
				log(3, "removed " + NAMESPACE + " from controller");
			}
			return Scene;
		};

		/**
   * Destroy the scene and everything.
   * @method ScrollMagic.Scene#destroy
   * @example
   * // destroy the scene without resetting the pin and tween to their initial positions
   * scene = scene.destroy();
   *
   * // destroy the scene and reset the pin and tween
   * scene = scene.destroy(true);
   *
   * @param {boolean} [reset=false] - If `true` the pin and tween (if existent) will be reset.
   * @returns {null} Null to unset handler variables.
   */
		this.destroy = function (reset) {
			Scene.trigger("destroy", {
				reset: reset
			});
			Scene.remove();
			Scene.off("*.*");
			log(3, "destroyed " + NAMESPACE + " (reset: " + (reset ? "true" : "false") + ")");
			return null;
		};

		/**
   * Updates the Scene to reflect the current state.  
   * This is the equivalent to `Controller.updateScene(scene, immediately)`.  
   * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
   * It then updates the current scene state accordingly (or does nothing, if the state is already correct)  Pins will be set to their correct position and tweens will be updated to their correct progress.
   * This means an update doesn't necessarily result in a progress change. The `progress` event will be fired if the progress has indeed changed between this update and the last.  
   * _**NOTE:** This method gets called constantly whenever ScrollMagic detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
   * @method ScrollMagic.Scene#update
   * @example
   * // update the scene on next tick
   * scene.update();
   *
   * // update the scene immediately
   * scene.update(true);
   *
   * @fires Scene.update
   *
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance).
   * @returns {Scene} Parent object for chaining.
   */
		this.update = function (immediately) {
			if (_controller) {
				if (immediately) {
					if (_controller.enabled() && _enabled) {
						var scrollPos = _controller.info("scrollPos"),
						    newProgress;

						if (_options.duration > 0) {
							newProgress = (scrollPos - _scrollOffset.start) / (_scrollOffset.end - _scrollOffset.start);
						} else {
							newProgress = scrollPos >= _scrollOffset.start ? 1 : 0;
						}

						Scene.trigger("update", {
							startPos: _scrollOffset.start,
							endPos: _scrollOffset.end,
							scrollPos: scrollPos
						});

						Scene.progress(newProgress);
					} else if (_pin && _state === SCENE_STATE_DURING) {
						updatePinState(true); // unpin in position
					}
				} else {
					_controller.updateScene(Scene, false);
				}
			}
			return Scene;
		};

		/**
   * Updates dynamic scene variables like the trigger element position or the duration.
   * This method is automatically called in regular intervals from the controller. See {@link ScrollMagic.Controller} option `refreshInterval`.
   * 
   * You can call it to minimize lag, for example when you intentionally change the position of the triggerElement.
   * If you don't it will simply be updated in the next refresh interval of the container, which is usually sufficient.
   *
   * @method ScrollMagic.Scene#refresh
   * @since 1.1.0
   * @example
   * scene = new ScrollMagic.Scene({triggerElement: "#trigger"});
   * 
   * // change the position of the trigger
   * $("#trigger").css("top", 500);
   * // immediately let the scene know of this change
   * scene.refresh();
   *
   * @fires {@link Scene.shift}, if the trigger element position or the duration changed
   * @fires {@link Scene.change}, if the duration changed
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.refresh = function () {
			updateDuration();
			updateTriggerElementPosition();
			// update trigger element position
			return Scene;
		};

		/**
   * **Get** or **Set** the scene's progress.  
   * Usually it shouldn't be necessary to use this as a setter, as it is set automatically by scene.update().  
   * The order in which the events are fired depends on the duration of the scene:
   *  1. Scenes with `duration == 0`:  
   *  Scenes that have no duration by definition have no ending. Thus the `end` event will never be fired.  
   *  When the trigger position of the scene is passed the events are always fired in this order:  
   *  `enter`, `start`, `progress` when scrolling forward  
   *  and  
   *  `progress`, `start`, `leave` when scrolling in reverse
   *  2. Scenes with `duration > 0`:  
   *  Scenes with a set duration have a defined start and end point.  
   *  When scrolling past the start position of the scene it will fire these events in this order:  
   *  `enter`, `start`, `progress`  
   *  When continuing to scroll and passing the end point it will fire these events:  
   *  `progress`, `end`, `leave`  
   *  When reversing through the end point these events are fired:  
   *  `enter`, `end`, `progress`  
   *  And when continuing to scroll past the start position in reverse it will fire:  
   *  `progress`, `start`, `leave`  
   *  In between start and end the `progress` event will be called constantly, whenever the progress changes.
   * 
   * In short:  
   * `enter` events will always trigger **before** the progress update and `leave` envents will trigger **after** the progress update.  
   * `start` and `end` will always trigger at their respective position.
   * 
   * Please review the event descriptions for details on the events and the event object that is passed to the callback.
   * 
   * @method ScrollMagic.Scene#progress
   * @example
   * // get the current scene progress
   * var progress = scene.progress();
   *
   * // set new scene progress
   * scene.progress(0.3);
   *
   * @fires {@link Scene.enter}, when used as setter
   * @fires {@link Scene.start}, when used as setter
   * @fires {@link Scene.progress}, when used as setter
   * @fires {@link Scene.end}, when used as setter
   * @fires {@link Scene.leave}, when used as setter
   *
   * @param {number} [progress] - The new progress value of the scene `[0-1]`.
   * @returns {number} `get` -  Current scene progress.
   * @returns {Scene} `set` -  Parent object for chaining.
   */
		this.progress = function (progress) {
			if (!arguments.length) {
				// get
				return _progress;
			} else {
				// set
				var doUpdate = false,
				    oldState = _state,
				    scrollDirection = _controller ? _controller.info("scrollDirection") : 'PAUSED',
				    reverseOrForward = _options.reverse || progress >= _progress;
				if (_options.duration === 0) {
					// zero duration scenes
					doUpdate = _progress != progress;
					_progress = progress < 1 && reverseOrForward ? 0 : 1;
					_state = _progress === 0 ? SCENE_STATE_BEFORE : SCENE_STATE_DURING;
				} else {
					// scenes with start and end
					if (progress < 0 && _state !== SCENE_STATE_BEFORE && reverseOrForward) {
						// go back to initial state
						_progress = 0;
						_state = SCENE_STATE_BEFORE;
						doUpdate = true;
					} else if (progress >= 0 && progress < 1 && reverseOrForward) {
						_progress = progress;
						_state = SCENE_STATE_DURING;
						doUpdate = true;
					} else if (progress >= 1 && _state !== SCENE_STATE_AFTER) {
						_progress = 1;
						_state = SCENE_STATE_AFTER;
						doUpdate = true;
					} else if (_state === SCENE_STATE_DURING && !reverseOrForward) {
						updatePinState(); // in case we scrolled backwards mid-scene and reverse is disabled => update the pin position, so it doesn't move back as well.
					}
				}
				if (doUpdate) {
					// fire events
					var eventVars = {
						progress: _progress,
						state: _state,
						scrollDirection: scrollDirection
					},
					    stateChanged = _state != oldState;

					var trigger = function (eventName) {
						// tmp helper to simplify code
						Scene.trigger(eventName, eventVars);
					};

					if (stateChanged) {
						// enter events
						if (oldState !== SCENE_STATE_DURING) {
							trigger("enter");
							trigger(oldState === SCENE_STATE_BEFORE ? "start" : "end");
						}
					}
					trigger("progress");
					if (stateChanged) {
						// leave events
						if (_state !== SCENE_STATE_DURING) {
							trigger(_state === SCENE_STATE_BEFORE ? "start" : "end");
							trigger("leave");
						}
					}
				}

				return Scene;
			}
		};

		/**
   * Update the start and end scrollOffset of the container.
   * The positions reflect what the controller's scroll position will be at the start and end respectively.
   * Is called, when:
   *   - Scene event "change" is called with: offset, triggerHook, duration 
   *   - scroll container event "resize" is called
   *   - the position of the triggerElement changes
   *   - the controller changes -> addTo()
   * @private
   */
		var updateScrollOffset = function () {
			_scrollOffset = {
				start: _triggerPos + _options.offset
			};
			if (_controller && _options.triggerElement) {
				// take away triggerHook portion to get relative to top
				_scrollOffset.start -= _controller.info("size") * _options.triggerHook;
			}
			_scrollOffset.end = _scrollOffset.start + _options.duration;
		};

		/**
   * Updates the duration if set to a dynamic function.
   * This method is called when the scene is added to a controller and in regular intervals from the controller through scene.refresh().
   * 
   * @fires {@link Scene.change}, if the duration changed
   * @fires {@link Scene.shift}, if the duration changed
   *
   * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
   * @private
   */
		var updateDuration = function (suppressEvents) {
			// update duration
			if (_durationUpdateMethod) {
				var varname = "duration";
				if (changeOption(varname, _durationUpdateMethod.call(Scene)) && !suppressEvents) {
					// set
					Scene.trigger("change", {
						what: varname,
						newval: _options[varname]
					});
					Scene.trigger("shift", {
						reason: varname
					});
				}
			}
		};

		/**
   * Updates the position of the triggerElement, if present.
   * This method is called ...
   *  - ... when the triggerElement is changed
   *  - ... when the scene is added to a (new) controller
   *  - ... in regular intervals from the controller through scene.refresh().
   * 
   * @fires {@link Scene.shift}, if the position changed
   *
   * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
   * @private
   */
		var updateTriggerElementPosition = function (suppressEvents) {
			var elementPos = 0,
			    telem = _options.triggerElement;
			if (_controller && telem) {
				var controllerInfo = _controller.info(),
				    containerOffset = _util.get.offset(controllerInfo.container),

				// container position is needed because element offset is returned in relation to document, not in relation to container.
				param = controllerInfo.vertical ? "top" : "left"; // which param is of interest ?
				// if parent is spacer, use spacer position instead so correct start position is returned for pinned elements.
				while (telem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
					telem = telem.parentNode;
				}

				var elementOffset = _util.get.offset(telem);

				if (!controllerInfo.isDocument) {
					// container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
					containerOffset[param] -= _controller.scrollPos();
				}

				elementPos = elementOffset[param] - containerOffset[param];
			}
			var changed = elementPos != _triggerPos;
			_triggerPos = elementPos;
			if (changed && !suppressEvents) {
				Scene.trigger("shift", {
					reason: "triggerElementPosition"
				});
			}
		};

		/**
   * Trigger a shift event, when the container is resized and the triggerHook is > 1.
   * @private
   */
		var onContainerResize = function (e) {
			if (_options.triggerHook > 0) {
				Scene.trigger("shift", {
					reason: "containerResize"
				});
			}
		};

		var _validate = _util.extend(SCENE_OPTIONS.validate, {
			// validation for duration handled internally for reference to private var _durationMethod
			duration: function (val) {
				if (_util.type.String(val) && val.match(/^(\.|\d)*\d+%$/)) {
					// percentage value
					var perc = parseFloat(val) / 100;
					val = function () {
						return _controller ? _controller.info("size") * perc : 0;
					};
				}
				if (_util.type.Function(val)) {
					// function
					_durationUpdateMethod = val;
					try {
						val = parseFloat(_durationUpdateMethod());
					} catch (e) {
						val = -1; // will cause error below
					}
				}
				// val has to be float
				val = parseFloat(val);
				if (!_util.type.Number(val) || val < 0) {
					if (_durationUpdateMethod) {
						_durationUpdateMethod = undefined;
						throw ["Invalid return value of supplied function for option \"duration\":", val];
					} else {
						throw ["Invalid value for option \"duration\":", val];
					}
				}
				return val;
			}
		});

		/**
   * Checks the validity of a specific or all options and reset to default if neccessary.
   * @private
   */
		var validateOption = function (check) {
			check = arguments.length ? [check] : Object.keys(_validate);
			check.forEach(function (optionName, key) {
				var value;
				if (_validate[optionName]) {
					// there is a validation method for this option
					try {
						// validate value
						value = _validate[optionName](_options[optionName]);
					} catch (e) {
						// validation failed -> reset to default
						value = DEFAULT_OPTIONS[optionName];
						var logMSG = _util.type.String(e) ? [e] : e;
						if (_util.type.Array(logMSG)) {
							logMSG[0] = "ERROR: " + logMSG[0];
							logMSG.unshift(1); // loglevel 1 for error msg
							log.apply(this, logMSG);
						} else {
							log(1, "ERROR: Problem executing validation callback for option '" + optionName + "':", e.message);
						}
					} finally {
						_options[optionName] = value;
					}
				}
			});
		};

		/**
   * Helper used by the setter/getters for scene options
   * @private
   */
		var changeOption = function (varname, newval) {
			var changed = false,
			    oldval = _options[varname];
			if (_options[varname] != newval) {
				_options[varname] = newval;
				validateOption(varname); // resets to default if necessary
				changed = oldval != _options[varname];
			}
			return changed;
		};

		// generate getters/setters for all options
		var addSceneOption = function (optionName) {
			if (!Scene[optionName]) {
				Scene[optionName] = function (newVal) {
					if (!arguments.length) {
						// get
						return _options[optionName];
					} else {
						if (optionName === "duration") {
							// new duration is set, so any previously set function must be unset
							_durationUpdateMethod = undefined;
						}
						if (changeOption(optionName, newVal)) {
							// set
							Scene.trigger("change", {
								what: optionName,
								newval: _options[optionName]
							});
							if (SCENE_OPTIONS.shifts.indexOf(optionName) > -1) {
								Scene.trigger("shift", {
									reason: optionName
								});
							}
						}
					}
					return Scene;
				};
			}
		};

		/**
   * **Get** or **Set** the duration option value.
   * As a setter it also accepts a function returning a numeric value.  
   * This is particularly useful for responsive setups.
   *
   * The duration is updated using the supplied function every time `Scene.refresh()` is called, which happens periodically from the controller (see ScrollMagic.Controller option `refreshInterval`).  
   * _**NOTE:** Be aware that it's an easy way to kill performance, if you supply a function that has high CPU demand.  
   * Even for size and position calculations it is recommended to use a variable to cache the value. (see example)  
   * This counts double if you use the same function for multiple scenes._
   *
   * @method ScrollMagic.Scene#duration
   * @example
   * // get the current duration value
   * var duration = scene.duration();
   *
   * // set a new duration
   * scene.duration(300);
   *
   * // use a function to automatically adjust the duration to the window height.
   * var durationValueCache;
   * function getDuration () {
   *   return durationValueCache;
   * }
   * function updateDuration (e) {
   *   durationValueCache = window.innerHeight;
   * }
   * $(window).on("resize", updateDuration); // update the duration when the window size changes
   * $(window).triggerHandler("resize"); // set to initial value
   * scene.duration(getDuration); // supply duration method
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {(number|function)} [newDuration] - The new duration of the scene.
   * @returns {number} `get` -  Current scene duration.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the offset option value.
   * @method ScrollMagic.Scene#offset
   * @example
   * // get the current offset
   * var offset = scene.offset();
   *
   * // set a new offset
   * scene.offset(100);
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {number} [newOffset] - The new offset of the scene.
   * @returns {number} `get` -  Current scene offset.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the triggerElement option value.
   * Does **not** fire `Scene.shift`, because changing the trigger Element doesn't necessarily mean the start position changes. This will be determined in `Scene.refresh()`, which is automatically triggered.
   * @method ScrollMagic.Scene#triggerElement
   * @example
   * // get the current triggerElement
   * var triggerElement = scene.triggerElement();
   *
   * // set a new triggerElement using a selector
   * scene.triggerElement("#trigger");
   * // set a new triggerElement using a DOM object
   * scene.triggerElement(document.getElementById("trigger"));
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {(string|object)} [newTriggerElement] - The new trigger element for the scene.
   * @returns {(string|object)} `get` -  Current triggerElement.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the triggerHook option value.
   * @method ScrollMagic.Scene#triggerHook
   * @example
   * // get the current triggerHook value
   * var triggerHook = scene.triggerHook();
   *
   * // set a new triggerHook using a string
   * scene.triggerHook("onLeave");
   * // set a new triggerHook using a number
   * scene.triggerHook(0.7);
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {(number|string)} [newTriggerHook] - The new triggerHook of the scene. See {@link Scene} parameter description for value options.
   * @returns {number} `get` -  Current triggerHook (ALWAYS numerical).
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the reverse option value.
   * @method ScrollMagic.Scene#reverse
   * @example
   * // get the current reverse option
   * var reverse = scene.reverse();
   *
   * // set new reverse option
   * scene.reverse(false);
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {boolean} [newReverse] - The new reverse setting of the scene.
   * @returns {boolean} `get` -  Current reverse option value.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the loglevel option value.
   * @method ScrollMagic.Scene#loglevel
   * @example
   * // get the current loglevel
   * var loglevel = scene.loglevel();
   *
   * // set new loglevel
   * scene.loglevel(3);
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {number} [newLoglevel] - The new loglevel setting of the scene. `[0-3]`
   * @returns {number} `get` -  Current loglevel.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** the associated controller.
   * @method ScrollMagic.Scene#controller
   * @example
   * // get the controller of a scene
   * var controller = scene.controller();
   *
   * @returns {ScrollMagic.Controller} Parent controller or `undefined`
   */
		this.controller = function () {
			return _controller;
		};

		/**
   * **Get** the current state.
   * @method ScrollMagic.Scene#state
   * @example
   * // get the current state
   * var state = scene.state();
   *
   * @returns {string} `"BEFORE"`, `"DURING"` or `"AFTER"`
   */
		this.state = function () {
			return _state;
		};

		/**
   * **Get** the current scroll offset for the start of the scene.  
   * Mind, that the scrollOffset is related to the size of the container, if `triggerHook` is bigger than `0` (or `"onLeave"`).  
   * This means, that resizing the container or changing the `triggerHook` will influence the scene's start offset.
   * @method ScrollMagic.Scene#scrollOffset
   * @example
   * // get the current scroll offset for the start and end of the scene.
   * var start = scene.scrollOffset();
   * var end = scene.scrollOffset() + scene.duration();
   * console.log("the scene starts at", start, "and ends at", end);
   *
   * @returns {number} The scroll offset (of the container) at which the scene will trigger. Y value for vertical and X value for horizontal scrolls.
   */
		this.scrollOffset = function () {
			return _scrollOffset.start;
		};

		/**
   * **Get** the trigger position of the scene (including the value of the `offset` option).  
   * @method ScrollMagic.Scene#triggerPosition
   * @example
   * // get the scene's trigger position
   * var triggerPosition = scene.triggerPosition();
   *
   * @returns {number} Start position of the scene. Top position value for vertical and left position value for horizontal scrolls.
   */
		this.triggerPosition = function () {
			var pos = _options.offset; // the offset is the basis
			if (_controller) {
				// get the trigger position
				if (_options.triggerElement) {
					// Element as trigger
					pos += _triggerPos;
				} else {
					// return the height of the triggerHook to start at the beginning
					pos += _controller.info("size") * Scene.triggerHook();
				}
			}
			return pos;
		};

		var _pin, _pinOptions;

		Scene.on("shift.internal", function (e) {
			var durationChanged = e.reason === "duration";
			if (_state === SCENE_STATE_AFTER && durationChanged || _state === SCENE_STATE_DURING && _options.duration === 0) {
				// if [duration changed after a scene (inside scene progress updates pin position)] or [duration is 0, we are in pin phase and some other value changed].
				updatePinState();
			}
			if (durationChanged) {
				updatePinDimensions();
			}
		}).on("progress.internal", function (e) {
			updatePinState();
		}).on("add.internal", function (e) {
			updatePinDimensions();
		}).on("destroy.internal", function (e) {
			Scene.removePin(e.reset);
		});
		/**
   * Update the pin state.
   * @private
   */
		var updatePinState = function (forceUnpin) {
			if (_pin && _controller) {
				var containerInfo = _controller.info(),
				    pinTarget = _pinOptions.spacer.firstChild; // may be pin element or another spacer, if cascading pins
				if (!forceUnpin && _state === SCENE_STATE_DURING) {
					// during scene or if duration is 0 and we are past the trigger
					// pinned state
					if (_util.css(pinTarget, "position") != "fixed") {
						// change state before updating pin spacer (position changes due to fixed collapsing might occur.)
						_util.css(pinTarget, {
							"position": "fixed"
						});
						// update pin spacer
						updatePinDimensions();
					}

					var fixedPos = _util.get.offset(_pinOptions.spacer, true),

					// get viewport position of spacer
					scrollDistance = _options.reverse || _options.duration === 0 ? containerInfo.scrollPos - _scrollOffset.start // quicker
					: Math.round(_progress * _options.duration * 10) / 10; // if no reverse and during pin the position needs to be recalculated using the progress
					// add scrollDistance
					fixedPos[containerInfo.vertical ? "top" : "left"] += scrollDistance;

					// set new values
					_util.css(_pinOptions.spacer.firstChild, {
						top: fixedPos.top,
						left: fixedPos.left
					});
				} else {
					// unpinned state
					var newCSS = {
						position: _pinOptions.inFlow ? "relative" : "absolute",
						top: 0,
						left: 0
					},
					    change = _util.css(pinTarget, "position") != newCSS.position;

					if (!_pinOptions.pushFollowers) {
						newCSS[containerInfo.vertical ? "top" : "left"] = _options.duration * _progress;
					} else if (_options.duration > 0) {
						// only concerns scenes with duration
						if (_state === SCENE_STATE_AFTER && parseFloat(_util.css(_pinOptions.spacer, "padding-top")) === 0) {
							change = true; // if in after state but havent updated spacer yet (jumped past pin)
						} else if (_state === SCENE_STATE_BEFORE && parseFloat(_util.css(_pinOptions.spacer, "padding-bottom")) === 0) {
							// before
							change = true; // jumped past fixed state upward direction
						}
					}
					// set new values
					_util.css(pinTarget, newCSS);
					if (change) {
						// update pin spacer if state changed
						updatePinDimensions();
					}
				}
			}
		};

		/**
   * Update the pin spacer and/or element size.
   * The size of the spacer needs to be updated whenever the duration of the scene changes, if it is to push down following elements.
   * @private
   */
		var updatePinDimensions = function () {
			if (_pin && _controller && _pinOptions.inFlow) {
				// no spacerresize, if original position is absolute
				var after = _state === SCENE_STATE_AFTER,
				    before = _state === SCENE_STATE_BEFORE,
				    during = _state === SCENE_STATE_DURING,
				    vertical = _controller.info("vertical"),
				    pinTarget = _pinOptions.spacer.firstChild,

				// usually the pined element but can also be another spacer (cascaded pins)
				marginCollapse = _util.isMarginCollapseType(_util.css(_pinOptions.spacer, "display")),
				    css = {};

				// set new size
				// if relsize: spacer -> pin | else: pin -> spacer
				if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
					if (during) {
						_util.css(_pin, {
							"width": _util.get.width(_pinOptions.spacer)
						});
					} else {
						_util.css(_pin, {
							"width": "100%"
						});
					}
				} else {
					// minwidth is needed for cascaded pins.
					css["min-width"] = _util.get.width(vertical ? _pin : pinTarget, true, true);
					css.width = during ? css["min-width"] : "auto";
				}
				if (_pinOptions.relSize.height) {
					if (during) {
						// the only padding the spacer should ever include is the duration (if pushFollowers = true), so we need to substract that.
						_util.css(_pin, {
							"height": _util.get.height(_pinOptions.spacer) - (_pinOptions.pushFollowers ? _options.duration : 0)
						});
					} else {
						_util.css(_pin, {
							"height": "100%"
						});
					}
				} else {
					// margin is only included if it's a cascaded pin to resolve an IE9 bug
					css["min-height"] = _util.get.height(vertical ? pinTarget : _pin, true, !marginCollapse); // needed for cascading pins
					css.height = during ? css["min-height"] : "auto";
				}

				// add space for duration if pushFollowers is true
				if (_pinOptions.pushFollowers) {
					css["padding" + (vertical ? "Top" : "Left")] = _options.duration * _progress;
					css["padding" + (vertical ? "Bottom" : "Right")] = _options.duration * (1 - _progress);
				}
				_util.css(_pinOptions.spacer, css);
			}
		};

		/**
   * Updates the Pin state (in certain scenarios)
   * If the controller container is not the document and we are mid-pin-phase scrolling or resizing the main document can result to wrong pin positions.
   * So this function is called on resize and scroll of the document.
   * @private
   */
		var updatePinInContainer = function () {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
				updatePinState();
			}
		};

		/**
   * Updates the Pin spacer size state (in certain scenarios)
   * If container is resized during pin and relatively sized the size of the pin might need to be updated...
   * So this function is called on resize of the container.
   * @private
   */
		var updateRelativePinSpacer = function () {
			if (_controller && _pin && // well, duh
			_state === SCENE_STATE_DURING && ( // element in pinned state?
			// is width or height relatively sized, but not in relation to body? then we need to recalc.
			(_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) && _util.get.width(window) != _util.get.width(_pinOptions.spacer.parentNode) || _pinOptions.relSize.height && _util.get.height(window) != _util.get.height(_pinOptions.spacer.parentNode))) {
				updatePinDimensions();
			}
		};

		/**
   * Is called, when the mousewhel is used while over a pinned element inside a div container.
   * If the scene is in fixed state scroll events would be counted towards the body. This forwards the event to the scroll container.
   * @private
   */
		var onMousewheelOverPin = function (e) {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
				// in pin state
				e.preventDefault();
				_controller._setScrollPos(_controller.info("scrollPos") - ((e.wheelDelta || e[_controller.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || -e.detail * 30));
			}
		};

		/**
   * Pin an element for the duration of the tween.  
   * If the scene duration is 0 the element will only be unpinned, if the user scrolls back past the start position.  
   * Make sure only one pin is applied to an element at the same time.
   * An element can be pinned multiple times, but only successively.
   * _**NOTE:** The option `pushFollowers` has no effect, when the scene duration is 0._
   * @method ScrollMagic.Scene#setPin
   * @example
   * // pin element and push all following elements down by the amount of the pin duration.
   * scene.setPin("#pin");
   *
   * // pin element and keeping all following elements in their place. The pinned element will move past them.
   * scene.setPin("#pin", {pushFollowers: false});
   *
   * @param {(string|object)} element - A Selector targeting an element or a DOM object that is supposed to be pinned.
   * @param {object} [settings] - settings for the pin
   * @param {boolean} [settings.pushFollowers=true] - If `true` following elements will be "pushed" down for the duration of the pin, if `false` the pinned element will just scroll past them.  
   Ignored, when duration is `0`.
   * @param {string} [settings.spacerClass="scrollmagic-pin-spacer"] - Classname of the pin spacer element, which is used to replace the element.
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.setPin = function (element, settings) {
			var defaultSettings = {
				pushFollowers: true,
				spacerClass: "scrollmagic-pin-spacer"
			};
			settings = _util.extend({}, defaultSettings, settings);

			// validate Element
			element = _util.get.elements(element)[0];
			if (!element) {
				log(1, "ERROR calling method 'setPin()': Invalid pin element supplied.");
				return Scene; // cancel
			} else if (_util.css(element, "position") === "fixed") {
				log(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'.");
				return Scene; // cancel
			}

			if (_pin) {
				// preexisting pin?
				if (_pin === element) {
					// same pin we already have -> do nothing
					return Scene; // cancel
				} else {
					// kill old pin
					Scene.removePin();
				}
			}
			_pin = element;

			var parentDisplay = _pin.parentNode.style.display,
			    boundsParams = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];

			_pin.parentNode.style.display = 'none'; // hack start to force css to return stylesheet values instead of calculated px values.
			var inFlow = _util.css(_pin, "position") != "absolute",
			    pinCSS = _util.css(_pin, boundsParams.concat(["display"])),
			    sizeCSS = _util.css(_pin, ["width", "height"]);
			_pin.parentNode.style.display = parentDisplay; // hack end.
			if (!inFlow && settings.pushFollowers) {
				log(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled.");
				settings.pushFollowers = false;
			}
			window.setTimeout(function () {
				// wait until all finished, because with responsive duration it will only be set after scene is added to controller
				if (_pin && _options.duration === 0 && settings.pushFollowers) {
					log(2, "WARNING: pushFollowers =", true, "has no effect, when scene duration is 0.");
				}
			}, 0);

			// create spacer and insert
			var spacer = _pin.parentNode.insertBefore(document.createElement('div'), _pin),
			    spacerCSS = _util.extend(pinCSS, {
				position: inFlow ? "relative" : "absolute",
				boxSizing: "content-box",
				mozBoxSizing: "content-box",
				webkitBoxSizing: "content-box"
			});

			if (!inFlow) {
				// copy size if positioned absolutely, to work for bottom/right positioned elements.
				_util.extend(spacerCSS, _util.css(_pin, ["width", "height"]));
			}

			_util.css(spacer, spacerCSS);
			spacer.setAttribute(PIN_SPACER_ATTRIBUTE, "");
			_util.addClass(spacer, settings.spacerClass);

			// set the pin Options
			_pinOptions = {
				spacer: spacer,
				relSize: { // save if size is defined using % values. if so, handle spacer resize differently...
					width: sizeCSS.width.slice(-1) === "%",
					height: sizeCSS.height.slice(-1) === "%",
					autoFullWidth: sizeCSS.width === "auto" && inFlow && _util.isMarginCollapseType(pinCSS.display)
				},
				pushFollowers: settings.pushFollowers,
				inFlow: inFlow
			};

			if (!_pin.___origStyle) {
				_pin.___origStyle = {};
				var pinInlineCSS = _pin.style,
				    copyStyles = boundsParams.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]);
				copyStyles.forEach(function (val) {
					_pin.___origStyle[val] = pinInlineCSS[val] || "";
				});
			}

			// if relative size, transfer it to spacer and make pin calculate it...
			if (_pinOptions.relSize.width) {
				_util.css(spacer, {
					width: sizeCSS.width
				});
			}
			if (_pinOptions.relSize.height) {
				_util.css(spacer, {
					height: sizeCSS.height
				});
			}

			// now place the pin element inside the spacer	
			spacer.appendChild(_pin);
			// and set new css
			_util.css(_pin, {
				position: inFlow ? "relative" : "absolute",
				margin: "auto",
				top: "auto",
				left: "auto",
				bottom: "auto",
				right: "auto"
			});

			if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
				_util.css(_pin, {
					boxSizing: "border-box",
					mozBoxSizing: "border-box",
					webkitBoxSizing: "border-box"
				});
			}

			// add listener to document to update pin position in case controller is not the document.
			window.addEventListener('scroll', updatePinInContainer);
			window.addEventListener('resize', updatePinInContainer);
			window.addEventListener('resize', updateRelativePinSpacer);
			// add mousewheel listener to catch scrolls over fixed elements
			_pin.addEventListener("mousewheel", onMousewheelOverPin);
			_pin.addEventListener("DOMMouseScroll", onMousewheelOverPin);

			log(3, "added pin");

			// finally update the pin to init
			updatePinState();

			return Scene;
		};

		/**
   * Remove the pin from the scene.
   * @method ScrollMagic.Scene#removePin
   * @example
   * // remove the pin from the scene without resetting it (the spacer is not removed)
   * scene.removePin();
   *
   * // remove the pin from the scene and reset the pin element to its initial position (spacer is removed)
   * scene.removePin(true);
   *
   * @param {boolean} [reset=false] - If `false` the spacer will not be removed and the element's position will not be reset.
   * @returns {Scene} Parent object for chaining.
   */
		this.removePin = function (reset) {
			if (_pin) {
				if (_state === SCENE_STATE_DURING) {
					updatePinState(true); // force unpin at position
				}
				if (reset || !_controller) {
					// if there's no controller no progress was made anyway...
					var pinTarget = _pinOptions.spacer.firstChild; // usually the pin element, but may be another spacer (cascaded pins)...
					if (pinTarget.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						// copy margins to child spacer
						var style = _pinOptions.spacer.style,
						    values = ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
						margins = {};
						values.forEach(function (val) {
							margins[val] = style[val] || "";
						});
						_util.css(pinTarget, margins);
					}
					_pinOptions.spacer.parentNode.insertBefore(pinTarget, _pinOptions.spacer);
					_pinOptions.spacer.parentNode.removeChild(_pinOptions.spacer);
					if (!_pin.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						// if it's the last pin for this element -> restore inline styles
						// TODO: only correctly set for first pin (when cascading) - how to fix?
						_util.css(_pin, _pin.___origStyle);
						delete _pin.___origStyle;
					}
				}
				window.removeEventListener('scroll', updatePinInContainer);
				window.removeEventListener('resize', updatePinInContainer);
				window.removeEventListener('resize', updateRelativePinSpacer);
				_pin.removeEventListener("mousewheel", onMousewheelOverPin);
				_pin.removeEventListener("DOMMouseScroll", onMousewheelOverPin);
				_pin = undefined;
				log(3, "removed pin (reset: " + (reset ? "true" : "false") + ")");
			}
			return Scene;
		};

		var _cssClasses,
		    _cssClassElems = [];

		Scene.on("destroy.internal", function (e) {
			Scene.removeClassToggle(e.reset);
		});
		/**
   * Define a css class modification while the scene is active.  
   * When the scene triggers the classes will be added to the supplied element and removed, when the scene is over.
   * If the scene duration is 0 the classes will only be removed if the user scrolls back past the start position.
   * @method ScrollMagic.Scene#setClassToggle
   * @example
   * // add the class 'myclass' to the element with the id 'my-elem' for the duration of the scene
   * scene.setClassToggle("#my-elem", "myclass");
   *
   * // add multiple classes to multiple elements defined by the selector '.classChange'
   * scene.setClassToggle(".classChange", "class1 class2 class3");
   *
   * @param {(string|object)} element - A Selector targeting one or more elements or a DOM object that is supposed to be modified.
   * @param {string} classes - One or more Classnames (separated by space) that should be added to the element during the scene.
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.setClassToggle = function (element, classes) {
			var elems = _util.get.elements(element);
			if (elems.length === 0 || !_util.type.String(classes)) {
				log(1, "ERROR calling method 'setClassToggle()': Invalid " + (elems.length === 0 ? "element" : "classes") + " supplied.");
				return Scene;
			}
			if (_cssClassElems.length > 0) {
				// remove old ones
				Scene.removeClassToggle();
			}
			_cssClasses = classes;
			_cssClassElems = elems;
			Scene.on("enter.internal_class leave.internal_class", function (e) {
				var toggle = e.type === "enter" ? _util.addClass : _util.removeClass;
				_cssClassElems.forEach(function (elem, key) {
					toggle(elem, _cssClasses);
				});
			});
			return Scene;
		};

		/**
   * Remove the class binding from the scene.
   * @method ScrollMagic.Scene#removeClassToggle
   * @example
   * // remove class binding from the scene without reset
   * scene.removeClassToggle();
   *
   * // remove class binding and remove the changes it caused
   * scene.removeClassToggle(true);
   *
   * @param {boolean} [reset=false] - If `false` and the classes are currently active, they will remain on the element. If `true` they will be removed.
   * @returns {Scene} Parent object for chaining.
   */
		this.removeClassToggle = function (reset) {
			if (reset) {
				_cssClassElems.forEach(function (elem, key) {
					_util.removeClass(elem, _cssClasses);
				});
			}
			Scene.off("start.internal_class end.internal_class");
			_cssClasses = undefined;
			_cssClassElems = [];
			return Scene;
		};

		// INIT
		construct();
		return Scene;
	};

	// store pagewide scene options
	var SCENE_OPTIONS = {
		defaults: {
			duration: 0,
			offset: 0,
			triggerElement: undefined,
			triggerHook: 0.5,
			reverse: true,
			loglevel: 2
		},
		validate: {
			offset: function (val) {
				val = parseFloat(val);
				if (!_util.type.Number(val)) {
					throw ["Invalid value for option \"offset\":", val];
				}
				return val;
			},
			triggerElement: function (val) {
				val = val || undefined;
				if (val) {
					var elem = _util.get.elements(val)[0];
					if (elem) {
						val = elem;
					} else {
						throw ["Element defined in option \"triggerElement\" was not found:", val];
					}
				}
				return val;
			},
			triggerHook: function (val) {
				var translate = {
					"onCenter": 0.5,
					"onEnter": 1,
					"onLeave": 0
				};
				if (_util.type.Number(val)) {
					val = Math.max(0, Math.min(parseFloat(val), 1)); //  make sure its betweeen 0 and 1
				} else if (val in translate) {
					val = translate[val];
				} else {
					throw ["Invalid value for option \"triggerHook\": ", val];
				}
				return val;
			},
			reverse: function (val) {
				return !!val; // force boolean
			},
			loglevel: function (val) {
				val = parseInt(val);
				if (!_util.type.Number(val) || val < 0 || val > 3) {
					throw ["Invalid value for option \"loglevel\":", val];
				}
				return val;
			}
		},
		// holder for  validation methods. duration validation is handled in 'getters-setters.js'
		shifts: ["duration", "offset", "triggerHook"]
	};
	/*
  * method used to add an option to ScrollMagic Scenes.
  * TODO: DOC (private for dev)
  */
	ScrollMagic.Scene.addOption = function (name, defaultValue, validationCallback, shifts) {
		if (!(name in SCENE_OPTIONS.defaults)) {
			SCENE_OPTIONS.defaults[name] = defaultValue;
			SCENE_OPTIONS.validate[name] = validationCallback;
			if (shifts) {
				SCENE_OPTIONS.shifts.push(name);
			}
		} else {
			ScrollMagic._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + name + "', because it already exists.");
		}
	};
	// instance extension function for plugins
	// TODO: DOC (private for dev)
	ScrollMagic.Scene.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Scene = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Scene, oldClass); // copy properties
		ScrollMagic.Scene.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Scene.prototype.constructor = ScrollMagic.Scene; // restore constructor
	};

	/**
  * TODO: DOCS (private for dev)
  * @class
  * @private
  */

	ScrollMagic.Event = function (type, namespace, target, vars) {
		vars = vars || {};
		for (var key in vars) {
			this[key] = vars[key];
		}
		this.type = type;
		this.target = this.currentTarget = target;
		this.namespace = namespace || '';
		this.timeStamp = this.timestamp = Date.now();
		return this;
	};

	/*
  * TODO: DOCS (private for dev)
  */

	var _util = ScrollMagic._util = function (window) {
		var U = {},
		    i;

		/**
   * ------------------------------
   * internal helpers
   * ------------------------------
   */

		// parse float and fall back to 0.
		var floatval = function (number) {
			return parseFloat(number) || 0;
		};
		// get current style IE safe (otherwise IE would return calculated values for 'auto')
		var _getComputedStyle = function (elem) {
			return elem.currentStyle ? elem.currentStyle : window.getComputedStyle(elem);
		};

		// get element dimension (width or height)
		var _dimension = function (which, elem, outer, includeMargin) {
			elem = elem === document ? window : elem;
			if (elem === window) {
				includeMargin = false;
			} else if (!_type.DomElement(elem)) {
				return 0;
			}
			which = which.charAt(0).toUpperCase() + which.substr(1).toLowerCase();
			var dimension = (outer ? elem['offset' + which] || elem['outer' + which] : elem['client' + which] || elem['inner' + which]) || 0;
			if (outer && includeMargin) {
				var style = _getComputedStyle(elem);
				dimension += which === 'Height' ? floatval(style.marginTop) + floatval(style.marginBottom) : floatval(style.marginLeft) + floatval(style.marginRight);
			}
			return dimension;
		};
		// converts 'margin-top' into 'marginTop'
		var _camelCase = function (str) {
			return str.replace(/^[^a-z]+([a-z])/g, '$1').replace(/-([a-z])/g, function (g) {
				return g[1].toUpperCase();
			});
		};

		/**
   * ------------------------------
   * external helpers
   * ------------------------------
   */

		// extend obj  same as jQuery.extend({}, objA, objB)
		U.extend = function (obj) {
			obj = obj || {};
			for (i = 1; i < arguments.length; i++) {
				if (!arguments[i]) {
					continue;
				}
				for (var key in arguments[i]) {
					if (arguments[i].hasOwnProperty(key)) {
						obj[key] = arguments[i][key];
					}
				}
			}
			return obj;
		};

		// check if a css display type results in margin-collapse or not
		U.isMarginCollapseType = function (str) {
			return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(str) > -1;
		};

		// implementation of requestAnimationFrame
		// based on https://gist.github.com/paulirish/1579671
		var lastTime = 0,
		    vendors = ['ms', 'moz', 'webkit', 'o'];
		var _requestAnimationFrame = window.requestAnimationFrame;
		var _cancelAnimationFrame = window.cancelAnimationFrame;
		// try vendor prefixes if the above doesn't work
		for (i = 0; !_requestAnimationFrame && i < vendors.length; ++i) {
			_requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
			_cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];
		}

		// fallbacks
		if (!_requestAnimationFrame) {
			_requestAnimationFrame = function (callback) {
				var currTime = new Date().getTime(),
				    timeToCall = Math.max(0, 16 - (currTime - lastTime)),
				    id = window.setTimeout(function () {
					callback(currTime + timeToCall);
				}, timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};
		}
		if (!_cancelAnimationFrame) {
			_cancelAnimationFrame = function (id) {
				window.clearTimeout(id);
			};
		}
		U.rAF = _requestAnimationFrame.bind(window);
		U.cAF = _cancelAnimationFrame.bind(window);

		var loglevels = ["error", "warn", "log"],
		    console = window.console || {};

		console.log = console.log || function () {}; // no console log, well - do nothing then...
		// make sure methods for all levels exist.
		for (i = 0; i < loglevels.length; i++) {
			var method = loglevels[i];
			if (!console[method]) {
				console[method] = console.log; // prefer .log over nothing
			}
		}
		U.log = function (loglevel) {
			if (loglevel > loglevels.length || loglevel <= 0) loglevel = loglevels.length;
			var now = new Date(),
			    time = ("0" + now.getHours()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2) + ":" + ("00" + now.getMilliseconds()).slice(-3),
			    method = loglevels[loglevel - 1],
			    args = Array.prototype.splice.call(arguments, 1),
			    func = Function.prototype.bind.call(console[method], console);
			args.unshift(time);
			func.apply(console, args);
		};

		/**
   * ------------------------------
   * type testing
   * ------------------------------
   */

		var _type = U.type = function (v) {
			return Object.prototype.toString.call(v).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
		};
		_type.String = function (v) {
			return _type(v) === 'string';
		};
		_type.Function = function (v) {
			return _type(v) === 'function';
		};
		_type.Array = function (v) {
			return Array.isArray(v);
		};
		_type.Number = function (v) {
			return !_type.Array(v) && v - parseFloat(v) + 1 >= 0;
		};
		_type.DomElement = function (o) {
			return typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
			o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
		};

		/**
   * ------------------------------
   * DOM Element info
   * ------------------------------
   */
		// always returns a list of matching DOM elements, from a selector, a DOM element or an list of elements or even an array of selectors
		var _get = U.get = {};
		_get.elements = function (selector) {
			var arr = [];
			if (_type.String(selector)) {
				try {
					selector = document.querySelectorAll(selector);
				} catch (e) {
					// invalid selector
					return arr;
				}
			}
			if (_type(selector) === 'nodelist' || _type.Array(selector)) {
				for (var i = 0, ref = arr.length = selector.length; i < ref; i++) {
					// list of elements
					var elem = selector[i];
					arr[i] = _type.DomElement(elem) ? elem : _get.elements(elem); // if not an element, try to resolve recursively
				}
			} else if (_type.DomElement(selector) || selector === document || selector === window) {
				arr = [selector]; // only the element
			}
			return arr;
		};
		// get scroll top value
		_get.scrollTop = function (elem) {
			return elem && typeof elem.scrollTop === 'number' ? elem.scrollTop : window.pageYOffset || 0;
		};
		// get scroll left value
		_get.scrollLeft = function (elem) {
			return elem && typeof elem.scrollLeft === 'number' ? elem.scrollLeft : window.pageXOffset || 0;
		};
		// get element height
		_get.width = function (elem, outer, includeMargin) {
			return _dimension('width', elem, outer, includeMargin);
		};
		// get element width
		_get.height = function (elem, outer, includeMargin) {
			return _dimension('height', elem, outer, includeMargin);
		};

		// get element position (optionally relative to viewport)
		_get.offset = function (elem, relativeToViewport) {
			var offset = {
				top: 0,
				left: 0
			};
			if (elem && elem.getBoundingClientRect) {
				// check if available
				var rect = elem.getBoundingClientRect();
				offset.top = rect.top;
				offset.left = rect.left;
				if (!relativeToViewport) {
					// clientRect is by default relative to viewport...
					offset.top += _get.scrollTop();
					offset.left += _get.scrollLeft();
				}
			}
			return offset;
		};

		/**
   * ------------------------------
   * DOM Element manipulation
   * ------------------------------
   */

		U.addClass = function (elem, classname) {
			if (classname) {
				if (elem.classList) elem.classList.add(classname);else elem.className += ' ' + classname;
			}
		};
		U.removeClass = function (elem, classname) {
			if (classname) {
				if (elem.classList) elem.classList.remove(classname);else elem.className = elem.className.replace(new RegExp('(^|\\b)' + classname.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
			}
		};
		// if options is string -> returns css value
		// if options is array -> returns object with css value pairs
		// if options is object -> set new css values
		U.css = function (elem, options) {
			if (_type.String(options)) {
				return _getComputedStyle(elem)[_camelCase(options)];
			} else if (_type.Array(options)) {
				var obj = {},
				    style = _getComputedStyle(elem);
				options.forEach(function (option, key) {
					obj[option] = style[_camelCase(option)];
				});
				return obj;
			} else {
				for (var option in options) {
					var val = options[option];
					if (val == parseFloat(val)) {
						// assume pixel for seemingly numerical values
						val += 'px';
					}
					elem.style[_camelCase(option)] = val;
				}
			}
		};

		return U;
	}(window || {});

	ScrollMagic.Scene.prototype.addIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	};
	ScrollMagic.Scene.prototype.setTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	};
	ScrollMagic.Scene.prototype.setVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	};

	return ScrollMagic;
});
'use strict';

/*!
 * ScrollMagic v2.0.5 (2015-04-29)
 * The javascript library for magical scroll interactions.
 * (c) 2015 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.5
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic GSAP Animation Plugin.
 *
 * requires: GSAP ~1.14
 * Powered by the Greensock Animation Platform (GSAP): http://www.greensock.com/js
 * Greensock License info at http://www.greensock.com/licensing/
 */
/**
 * This plugin is meant to be used in conjunction with the Greensock Animation Plattform.  
 * It offers an easy API to trigger Tweens or synchronize them to the scrollbar movement.
 *
 * Both the `lite` and the `max` versions of the GSAP library are supported.  
 * The most basic requirement is `TweenLite`.
 * 
 * To have access to this extension, please include `plugins/animation.gsap.js`.
 * @requires {@link http://greensock.com/gsap|GSAP ~1.14.x}
 * @mixin animation.GSAP
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['ScrollMagic', 'TweenMax', 'TimelineMax'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		// Loads whole gsap package onto global scope.
		require('gsap');
		factory(require('scrollmagic'), TweenMax, TimelineMax);
	} else {
		// Browser globals
		factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic, root.TweenMax || root.TweenLite, root.TimelineMax || root.TimelineLite);
	}
})(this, function (ScrollMagic, Tween, Timeline) {
	"use strict";

	var NAMESPACE = "animation.gsap";

	var console = window.console || {},
	    err = Function.prototype.bind.call(console.error || console.log || function () {}, console);
	if (!ScrollMagic) {
		err("(" + NAMESPACE + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs.");
	}
	if (!Tween) {
		err("(" + NAMESPACE + ") -> ERROR: TweenLite or TweenMax could not be found. Please make sure GSAP is loaded before ScrollMagic or use an asynchronous loader like requirejs.");
	}

	/*
 	 * ----------------------------------------------------------------
 	 * Extensions for Scene
 	 * ----------------------------------------------------------------
 	 */
	/**
  * Every instance of ScrollMagic.Scene now accepts an additional option.  
  * See {@link ScrollMagic.Scene} for a complete list of the standard options.
  * @memberof! animation.GSAP#
  * @method new ScrollMagic.Scene(options)
  * @example
  * var scene = new ScrollMagic.Scene({tweenChanges: true});
  *
  * @param {object} [options] - Options for the Scene. The options can be updated at any time.
  * @param {boolean} [options.tweenChanges=false] - Tweens Animation to the progress target instead of setting it.  
  Does not affect animations where duration is `0`.
  */
	/**
  * **Get** or **Set** the tweenChanges option value.  
  * This only affects scenes with a duration. If `tweenChanges` is `true`, the progress update when scrolling will not be immediate, but instead the animation will smoothly animate to the target state.  
  * For a better understanding, try enabling and disabling this option in the [Scene Manipulation Example](../examples/basic/scene_manipulation.html).
  * @memberof! animation.GSAP#
  * @method Scene.tweenChanges
  * 
  * @example
  * // get the current tweenChanges option
  * var tweenChanges = scene.tweenChanges();
  *
  * // set new tweenChanges option
  * scene.tweenChanges(true);
  *
  * @fires {@link Scene.change}, when used as setter
  * @param {boolean} [newTweenChanges] - The new tweenChanges setting of the scene.
  * @returns {boolean} `get` -  Current tweenChanges option value.
  * @returns {Scene} `set` -  Parent object for chaining.
  */
	// add option (TODO: DOC (private for dev))
	ScrollMagic.Scene.addOption("tweenChanges", // name
	false, // default


	function (val) {
		// validation callback
		return !!val;
	});
	// extend scene
	ScrollMagic.Scene.extend(function () {
		var Scene = this,
		    _tween;

		var log = function () {
			if (Scene._log) {
				// not available, when main source minified
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
				Scene._log.apply(this, arguments);
			}
		};

		// set listeners
		Scene.on("progress.plugin_gsap", function () {
			updateTweenProgress();
		});
		Scene.on("destroy.plugin_gsap", function (e) {
			Scene.removeTween(e.reset);
		});

		/**
   * Update the tween progress to current position.
   * @private
   */
		var updateTweenProgress = function () {
			if (_tween) {
				var progress = Scene.progress(),
				    state = Scene.state();
				if (_tween.repeat && _tween.repeat() === -1) {
					// infinite loop, so not in relation to progress
					if (state === 'DURING' && _tween.paused()) {
						_tween.play();
					} else if (state !== 'DURING' && !_tween.paused()) {
						_tween.pause();
					}
				} else if (progress != _tween.progress()) {
					// do we even need to update the progress?
					// no infinite loop - so should we just play or go to a specific point in time?
					if (Scene.duration() === 0) {
						// play the animation
						if (progress > 0) {
							// play from 0 to 1
							_tween.play();
						} else {
							// play from 1 to 0
							_tween.reverse();
						}
					} else {
						// go to a specific point in time
						if (Scene.tweenChanges() && _tween.tweenTo) {
							// go smooth
							_tween.tweenTo(progress * _tween.duration());
						} else {
							// just hard set it
							_tween.progress(progress).pause();
						}
					}
				}
			}
		};

		/**
   * Add a tween to the scene.  
   * If you want to add multiple tweens, add them into a GSAP Timeline object and supply it instead (see example below).  
   * 
   * If the scene has a duration, the tween's duration will be projected to the scroll distance of the scene, meaning its progress will be synced to scrollbar movement.  
   * For a scene with a duration of `0`, the tween will be triggered when scrolling forward past the scene's trigger position and reversed, when scrolling back.  
   * To gain better understanding, check out the [Simple Tweening example](../examples/basic/simple_tweening.html).
   *
   * Instead of supplying a tween this method can also be used as a shorthand for `TweenMax.to()` (see example below).
   * @memberof! animation.GSAP#
   *
   * @example
   * // add a single tween directly
   * scene.setTween(TweenMax.to("obj"), 1, {x: 100});
   *
   * // add a single tween via variable
   * var tween = TweenMax.to("obj"), 1, {x: 100};
   * scene.setTween(tween);
   *
   * // add multiple tweens, wrapped in a timeline.
   * var timeline = new TimelineMax();
   * var tween1 = TweenMax.from("obj1", 1, {x: 100});
   * var tween2 = TweenMax.to("obj2", 1, {y: 100});
   * timeline
   *		.add(tween1)
   *		.add(tween2);
   * scene.addTween(timeline);
   *
   * // short hand to add a TweenMax.to() tween
   * scene.setTween("obj3", 0.5, {y: 100});
   *
   * // short hand to add a TweenMax.to() tween for 1 second
   * // this is useful, when the scene has a duration and the tween duration isn't important anyway
   * scene.setTween("obj3", {y: 100});
   *
   * @param {(object|string)} TweenObject - A TweenMax, TweenLite, TimelineMax or TimelineLite object that should be animated in the scene. Can also be a Dom Element or Selector, when using direct tween definition (see examples).
   * @param {(number|object)} duration - A duration for the tween, or tween parameters. If an object containing parameters are supplied, a default duration of 1 will be used.
   * @param {object} params - The parameters for the tween
   * @returns {Scene} Parent object for chaining.
   */
		Scene.setTween = function (TweenObject, duration, params) {
			var newTween;
			if (arguments.length > 1) {
				if (arguments.length < 3) {
					params = duration;
					duration = 1;
				}
				TweenObject = Tween.to(TweenObject, duration, params);
			}
			try {
				// wrap Tween into a Timeline Object if available to include delay and repeats in the duration and standardize methods.
				if (Timeline) {
					newTween = new Timeline({
						smoothChildTiming: true
					}).add(TweenObject);
				} else {
					newTween = TweenObject;
				}
				newTween.pause();
			} catch (e) {
				log(1, "ERROR calling method 'setTween()': Supplied argument is not a valid TweenObject");
				return Scene;
			}
			if (_tween) {
				// kill old tween?
				Scene.removeTween();
			}
			_tween = newTween;

			// some properties need to be transferred it to the wrapper, otherwise they would get lost.
			if (TweenObject.repeat && TweenObject.repeat() === -1) {
				// TweenMax or TimelineMax Object?
				_tween.repeat(-1);
				_tween.yoyo(TweenObject.yoyo());
			}
			// Some tween validations and debugging helpers
			if (Scene.tweenChanges() && !_tween.tweenTo) {
				log(2, "WARNING: tweenChanges will only work if the TimelineMax object is available for ScrollMagic.");
			}

			// check if there are position tweens defined for the trigger and warn about it :)
			if (_tween && Scene.controller() && Scene.triggerElement() && Scene.loglevel() >= 2) {
				// controller is needed to know scroll direction.
				var triggerTweens = Tween.getTweensOf(Scene.triggerElement()),
				    vertical = Scene.controller().info("vertical");
				triggerTweens.forEach(function (value, index) {
					var tweenvars = value.vars.css || value.vars,
					    condition = vertical ? tweenvars.top !== undefined || tweenvars.bottom !== undefined : tweenvars.left !== undefined || tweenvars.right !== undefined;
					if (condition) {
						log(2, "WARNING: Tweening the position of the trigger element affects the scene timing and should be avoided!");
						return false;
					}
				});
			}

			// warn about tween overwrites, when an element is tweened multiple times
			if (parseFloat(TweenLite.version) >= 1.14) {
				// onOverwrite only present since GSAP v1.14.0
				var list = _tween.getChildren ? _tween.getChildren(true, true, false) : [_tween],

				// get all nested tween objects
				newCallback = function () {
					log(2, "WARNING: tween was overwritten by another. To learn how to avoid this issue see here: https://github.com/janpaepke/ScrollMagic/wiki/WARNING:-tween-was-overwritten-by-another");
				};
				for (var i = 0, thisTween, oldCallback; i < list.length; i++) {
					/*jshint loopfunc: true */
					thisTween = list[i];
					if (oldCallback !== newCallback) {
						// if tweens is added more than once
						oldCallback = thisTween.vars.onOverwrite;
						thisTween.vars.onOverwrite = function () {
							if (oldCallback) {
								oldCallback.apply(this, arguments);
							}
							newCallback.apply(this, arguments);
						};
					}
				}
			}
			log(3, "added tween");

			updateTweenProgress();
			return Scene;
		};

		/**
   * Remove the tween from the scene.  
   * This will terminate the control of the Scene over the tween.
   *
   * Using the reset option you can decide if the tween should remain in the current state or be rewound to set the target elements back to the state they were in before the tween was added to the scene.
   * @memberof! animation.GSAP#
   *
   * @example
   * // remove the tween from the scene without resetting it
   * scene.removeTween();
   *
   * // remove the tween from the scene and reset it to initial position
   * scene.removeTween(true);
   *
   * @param {boolean} [reset=false] - If `true` the tween will be reset to its initial values.
   * @returns {Scene} Parent object for chaining.
   */
		Scene.removeTween = function (reset) {
			if (_tween) {
				if (reset) {
					_tween.progress(0).pause();
				}
				_tween.kill();
				_tween = undefined;
				log(3, "removed tween (reset: " + (reset ? "true" : "false") + ")");
			}
			return Scene;
		};
	});
});
'use strict';

/*! Lazy Load XT v1.0.5 2014-06-05
 * http://ressio.github.io/lazy-load-xt
 * (C) 2014 RESS.io
 * Licensed under MIT */

(function ($, window, document, undefined) {
    // options
    var lazyLoadXT = 'lazyLoadXT',
        dataLazied = 'lazied',
        load_error = 'load error',
        classLazyHidden = 'lazy-hidden',
        docElement = document.documentElement || document.body,

    //  force load all images in Opera Mini and some mobile browsers without scroll event or getBoundingClientRect()
    forceLoad = window.onscroll === undefined || !!window.operamini || !docElement.getBoundingClientRect,
        options = {
        autoInit: true, // auto initialize in $.ready
        selector: 'img[data-src]', // selector for lazyloading elements
        blankImage: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
        throttle: 99, // interval (ms) for changes check
        forceLoad: forceLoad, // force auto load all images

        loadEvent: 'pageshow', // check AJAX-loaded content in jQueryMobile
        updateEvent: 'load orientationchange resize scroll touchmove focus', // page-modified events
        forceEvent: '', // force loading of all elements

        //onstart: null,
        oninit: { removeClass: 'lazy' }, // init handler
        onshow: { addClass: classLazyHidden }, // start loading handler
        onload: { removeClass: classLazyHidden, addClass: 'lazy-loaded' }, // load success handler
        onerror: { removeClass: classLazyHidden }, // error handler
        //oncomplete: null, // complete handler

        //scrollContainer: undefined,
        checkDuplicates: true
    },
        elementOptions = {
        srcAttr: 'data-src',
        edgeX: 0,
        edgeY: 0,
        visibleOnly: true
    },
        $window = $(window),
        $isFunction = $.isFunction,
        $extend = $.extend,
        $data = $.data || function (el, name) {
        return $(el).data(name);
    },

    // $.contains is not included into DOMtastic, so implement it there
    $contains = $.contains || function (parent, el) {
        while (el = el.parentNode) {
            if (el === parent) {
                return true;
            }
        }
        return false;
    },
        elements = [],
        topLazy = 0,

    /*
     waitingMode=0 : no setTimeout
     waitingMode=1 : setTimeout, no deferred events
     waitingMode=2 : setTimeout, deferred events
     */
    waitingMode = 0;

    $[lazyLoadXT] = $extend(options, elementOptions, $[lazyLoadXT]);

    /**
     * Return options.prop if obj.prop is undefined, otherwise return obj.prop
     * @param {*} obj
     * @param {*} prop
     * @returns *
     */
    function getOrDef(obj, prop) {
        return obj[prop] === undefined ? options[prop] : obj[prop];
    }

    /**
     * @returns {number}
     */
    function scrollTop() {
        var scroll = window.pageYOffset;
        return scroll === undefined ? docElement.scrollTop : scroll;
    }

    /**
     * Add new elements to lazy-load list:
     * $(elements).lazyLoadXT() or $(window).lazyLoadXT()
     *
     * @param {object} [overrides] override global options
     */
    $.fn[lazyLoadXT] = function (overrides) {
        overrides = overrides || {};

        var blankImage = getOrDef(overrides, 'blankImage'),
            checkDuplicates = getOrDef(overrides, 'checkDuplicates'),
            scrollContainer = getOrDef(overrides, 'scrollContainer'),
            elementOptionsOverrides = {},
            prop;

        // empty overrides.scrollContainer is supported by both jQuery and Zepto
        $(scrollContainer).on('scroll', queueCheckLazyElements);

        for (prop in elementOptions) {
            elementOptionsOverrides[prop] = getOrDef(overrides, prop);
        }

        return this.each(function (index, el) {
            if (el === window) {
                $(options.selector).lazyLoadXT(overrides);
            } else {
                // prevent duplicates
                if (checkDuplicates && $data(el, dataLazied)) {
                    return;
                }

                var $el = $(el).data(dataLazied, 1);

                if (blankImage && el.tagName === 'IMG' && !el.src) {
                    el.src = blankImage;
                }

                // clone elementOptionsOverrides object
                $el[lazyLoadXT] = $extend({}, elementOptionsOverrides);

                triggerEvent('init', $el);

                elements.push($el);
            }
        });
    };

    /**
     * Process function/object event handler
     * @param {string} event suffix
     * @param {jQuery} $el
     */
    function triggerEvent(event, $el) {
        var handler = options['on' + event];
        if (handler) {
            if ($isFunction(handler)) {
                handler.call($el[0]);
            } else {
                if (handler.addClass) {
                    $el.addClass(handler.addClass);
                }
                if (handler.removeClass) {
                    $el.removeClass(handler.removeClass);
                }
            }
        }

        $el.trigger('lazy' + event, [$el]);

        // queue next check as images may be resized after loading of actual file
        queueCheckLazyElements();
    }

    /**
     * Trigger onload/onerror handler
     * @param {Event} e
     */
    function triggerLoadOrError(e) {
        triggerEvent(e.type, $(this).off(load_error, triggerLoadOrError));
    }

    /**
     * Load visible elements
     * @param {bool} [force] loading of all elements
     */
    function checkLazyElements(force) {
        if (!elements.length) {
            return;
        }

        force = force || options.forceLoad;

        topLazy = Infinity;

        var viewportTop = scrollTop(),
            viewportHeight = window.innerHeight || docElement.clientHeight,
            viewportWidth = window.innerWidth || docElement.clientWidth,
            i,
            length;

        for (i = 0, length = elements.length; i < length; i++) {
            var $el = elements[i],
                el = $el[0],
                objData = $el[lazyLoadXT],
                removeNode = false,
                visible = force,
                topEdge;

            // remove items that are not in DOM
            if (!$contains(docElement, el)) {
                removeNode = true;
            } else if (force || !objData.visibleOnly || el.offsetWidth || el.offsetHeight) {

                if (!visible) {
                    var elPos = el.getBoundingClientRect(),
                        edgeX = objData.edgeX,
                        edgeY = objData.edgeY;

                    topEdge = elPos.top + viewportTop - edgeY - viewportHeight;

                    visible = topEdge <= viewportTop && elPos.bottom > -edgeY && elPos.left <= viewportWidth + edgeX && elPos.right > -edgeX;
                }

                if (visible) {
                    triggerEvent('show', $el);

                    var srcAttr = objData.srcAttr,
                        src = $isFunction(srcAttr) ? srcAttr($el) : el.getAttribute(srcAttr);
                    if (src) {
                        $el.on(load_error, triggerLoadOrError);
                        el.src = src;
                    }

                    removeNode = true;
                } else {
                    if (topEdge < topLazy) {
                        topLazy = topEdge;
                    }
                }
            }

            if (removeNode) {
                elements.splice(i--, 1);
                length--;
            }
        }

        if (!length) {
            triggerEvent('complete', $(docElement));
        }
    }

    /**
     * Run check of lazy elements after timeout
     */
    function timeoutLazyElements() {
        if (waitingMode > 1) {
            waitingMode = 1;
            checkLazyElements();
            setTimeout(timeoutLazyElements, options.throttle);
        } else {
            waitingMode = 0;
        }
    }

    /**
     * Queue check of lazy elements because of event e
     * @param {Event} [e]
     */
    function queueCheckLazyElements(e) {
        if (!elements.length) {
            return;
        }

        // fast check for scroll event without new visible elements
        if (e && e.type === 'scroll' && e.currentTarget === window) {
            if (topLazy >= scrollTop()) {
                return;
            }
        }

        if (!waitingMode) {
            setTimeout(timeoutLazyElements, 0);
        }
        waitingMode = 2;
    }

    /**
     * Initialize list of hidden elements
     */
    function initLazyElements() {
        $window.lazyLoadXT();
    }

    /**
     * Loading of all elements
     */
    function forceLoadAll() {
        checkLazyElements(true);
    }

    /**
     * Initialization
     */
    $(document).ready(function () {
        triggerEvent('start', $window);

        $window.on(options.loadEvent, initLazyElements).on(options.updateEvent, queueCheckLazyElements).on(options.forceEvent, forceLoadAll);

        $(document).on(options.updateEvent, queueCheckLazyElements);

        if (options.autoInit) {
            initLazyElements(); // standard initialization
        }
    });
})(window.jQuery || window.Zepto || window.$, window, document);
'use strict';

/*! Lazy Load XT v1.0.5 2014-06-05
 * http://ressio.github.io/lazy-load-xt
 * (C) 2014 RESS.io
 * Licensed under MIT */

(function ($) {
    var options = $.lazyLoadXT;

    options.forceEvent += ' lazyautoload';
    options.autoLoadTime = options.autoLoadTime || 50;

    $(document).ready(function () {
        setTimeout(function () {
            $(window).trigger('lazyautoload');
        }, options.autoLoadTime);
    });
})(window.jQuery || window.Zepto || window.$);
'use strict';

/*! Lazy Load XT v1.0.5 2014-06-05
 * http://ressio.github.io/lazy-load-xt
 * (C) 2014 RESS.io
 * Licensed under MIT */

(function ($) {
    var options = $.lazyLoadXT,
        bgAttr = options.bgAttr || 'data-bg';

    options.selector += ',[' + bgAttr + ']';

    $(document).on('lazyshow', function (e) {
        var $this = $(e.target);
        $this.css('background-image', "url('" + $this.attr(bgAttr) + "')").removeAttr(bgAttr);
    });
})(window.jQuery || window.Zepto || window.$);
!function ($) {

  "use strict";

  var FOUNDATION_VERSION = '6.2.1';

  // Global Foundation object
  // This is attached to the window, or used as a module for AMD/Browserify
  var Foundation = {
    version: FOUNDATION_VERSION,

    /**
     * Stores initialized plugins.
     */
    _plugins: {},

    /**
     * Stores generated unique ids for plugin instances
     */
    _uuids: [],

    /**
     * Returns a boolean for RTL support
     */
    rtl: function () {
      return $('html').attr('dir') === 'rtl';
    },
    /**
     * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.
     * @param {Object} plugin - The constructor of the plugin.
     */
    plugin: function (plugin, name) {
      // Object key to use when adding to global Foundation object
      // Examples: Foundation.Reveal, Foundation.OffCanvas
      var className = name || functionName(plugin);
      // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin
      // Examples: data-reveal, data-off-canvas
      var attrName = hyphenate(className);

      // Add to the Foundation object and the plugins list (for reflowing)
      this._plugins[attrName] = this[className] = plugin;
    },
    /**
     * @function
     * Populates the _uuids array with pointers to each individual plugin instance.
     * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.
     * Also fires the initialization event for each plugin, consolidating repeditive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @param {String} name - the name of the plugin, passed as a camelCased string.
     * @fires Plugin#init
     */
    registerPlugin: function (plugin, name) {
      var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();
      plugin.uuid = this.GetYoDigits(6, pluginName);

      if (!plugin.$element.attr('data-' + pluginName)) {
        plugin.$element.attr('data-' + pluginName, plugin.uuid);
      }
      if (!plugin.$element.data('zfPlugin')) {
        plugin.$element.data('zfPlugin', plugin);
      }
      /**
       * Fires when the plugin has initialized.
       * @event Plugin#init
       */
      plugin.$element.trigger('init.zf.' + pluginName);

      this._uuids.push(plugin.uuid);

      return;
    },
    /**
     * @function
     * Removes the plugins uuid from the _uuids array.
     * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.
     * Also fires the destroyed event for the plugin, consolidating repeditive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @fires Plugin#destroyed
     */
    unregisterPlugin: function (plugin) {
      var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));

      this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);
      plugin.$element.removeAttr('data-' + pluginName).removeData('zfPlugin')
      /**
       * Fires when the plugin has been destroyed.
       * @event Plugin#destroyed
       */
      .trigger('destroyed.zf.' + pluginName);
      for (var prop in plugin) {
        plugin[prop] = null; //clean up script to prep for garbage collection.
      }
      return;
    },

    /**
     * @function
     * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.
     * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`
     * @default If no argument is passed, reflow all currently active plugins.
     */
    reInit: function (plugins) {
      var isJQ = plugins instanceof $;
      try {
        if (isJQ) {
          plugins.each(function () {
            $(this).data('zfPlugin')._init();
          });
        } else {
          var type = typeof plugins,
              _this = this,
              fns = {
            'object': function (plgs) {
              plgs.forEach(function (p) {
                p = hyphenate(p);
                $('[data-' + p + ']').foundation('_init');
              });
            },
            'string': function () {
              plugins = hyphenate(plugins);
              $('[data-' + plugins + ']').foundation('_init');
            },
            'undefined': function () {
              this['object'](Object.keys(_this._plugins));
            }
          };
          fns[type](plugins);
        }
      } catch (err) {
        console.error(err);
      } finally {
        return plugins;
      }
    },

    /**
     * returns a random base-36 uid with namespacing
     * @function
     * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.
     * @param {String} namespace - name of plugin to be incorporated in uid, optional.
     * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.
     * @returns {String} - unique id
     */
    GetYoDigits: function (length, namespace) {
      length = length || 6;
      return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? '-' + namespace : '');
    },
    /**
     * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.
     * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.
     * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.
     */
    reflow: function (elem, plugins) {

      // If plugins is undefined, just grab everything
      if (typeof plugins === 'undefined') {
        plugins = Object.keys(this._plugins);
      }
      // If plugins is a string, convert it to an array with one item
      else if (typeof plugins === 'string') {
          plugins = [plugins];
        }

      var _this = this;

      // Iterate through each plugin
      $.each(plugins, function (i, name) {
        // Get the current plugin
        var plugin = _this._plugins[name];

        // Localize the search to all elements inside elem, as well as elem itself, unless elem === document
        var $elem = $(elem).find('[data-' + name + ']').addBack('[data-' + name + ']');

        // For each plugin found, initialize it
        $elem.each(function () {
          var $el = $(this),
              opts = {};
          // Don't double-dip on plugins
          if ($el.data('zfPlugin')) {
            console.warn("Tried to initialize " + name + " on an element that already has a Foundation plugin.");
            return;
          }

          if ($el.attr('data-options')) {
            var thing = $el.attr('data-options').split(';').forEach(function (e, i) {
              var opt = e.split(':').map(function (el) {
                return el.trim();
              });
              if (opt[0]) opts[opt[0]] = parseValue(opt[1]);
            });
          }
          try {
            $el.data('zfPlugin', new plugin($(this), opts));
          } catch (er) {
            console.error(er);
          } finally {
            return;
          }
        });
      });
    },
    getFnName: functionName,
    transitionend: function ($elem) {
      var transitions = {
        'transition': 'transitionend',
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'otransitionend'
      };
      var elem = document.createElement('div'),
          end;

      for (var t in transitions) {
        if (typeof elem.style[t] !== 'undefined') {
          end = transitions[t];
        }
      }
      if (end) {
        return end;
      } else {
        end = setTimeout(function () {
          $elem.triggerHandler('transitionend', [$elem]);
        }, 1);
        return 'transitionend';
      }
    }
  };

  Foundation.util = {
    /**
     * Function for applying a debounce effect to a function call.
     * @function
     * @param {Function} func - Function to be called at end of timeout.
     * @param {Number} delay - Time in ms to delay the call of `func`.
     * @returns function
     */
    throttle: function (func, delay) {
      var timer = null;

      return function () {
        var context = this,
            args = arguments;

        if (timer === null) {
          timer = setTimeout(function () {
            func.apply(context, args);
            timer = null;
          }, delay);
        }
      };
    }
  };

  // TODO: consider not making this a jQuery function
  // TODO: need way to reflow vs. re-initialize
  /**
   * The Foundation jQuery method.
   * @param {String|Array} method - An action to perform on the current jQuery object.
   */
  var foundation = function (method) {
    var type = typeof method,
        $meta = $('meta.foundation-mq'),
        $noJS = $('.no-js');

    if (!$meta.length) {
      $('<meta class="foundation-mq">').appendTo(document.head);
    }
    if ($noJS.length) {
      $noJS.removeClass('no-js');
    }

    if (type === 'undefined') {
      //needs to initialize the Foundation object, or an individual plugin.
      Foundation.MediaQuery._init();
      Foundation.reflow(this);
    } else if (type === 'string') {
      //an individual method to invoke on a plugin or group of plugins
      var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary
      var plugClass = this.data('zfPlugin'); //determine the class of plugin

      if (plugClass !== undefined && plugClass[method] !== undefined) {
        //make sure both the class and method exist
        if (this.length === 1) {
          //if there's only one, call it directly.
          plugClass[method].apply(plugClass, args);
        } else {
          this.each(function (i, el) {
            //otherwise loop through the jQuery collection and invoke the method on each
            plugClass[method].apply($(el).data('zfPlugin'), args);
          });
        }
      } else {
        //error for no class or no method
        throw new ReferenceError("We're sorry, '" + method + "' is not an available method for " + (plugClass ? functionName(plugClass) : 'this element') + '.');
      }
    } else {
      //error for invalid argument type
      throw new TypeError('We\'re sorry, ' + type + ' is not a valid parameter. You must use a string representing the method you wish to invoke.');
    }
    return this;
  };

  window.Foundation = Foundation;
  $.fn.foundation = foundation;

  // Polyfill for requestAnimationFrame
  (function () {
    if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {
      return new Date().getTime();
    };

    var vendors = ['webkit', 'moz'];
    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
      var vp = vendors[i];
      window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
    }
    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
      var lastTime = 0;
      window.requestAnimationFrame = function (callback) {
        var now = Date.now();
        var nextTime = Math.max(lastTime + 16, now);
        return setTimeout(function () {
          callback(lastTime = nextTime);
        }, nextTime - now);
      };
      window.cancelAnimationFrame = clearTimeout;
    }
    /**
     * Polyfill for performance.now, required by rAF
     */
    if (!window.performance || !window.performance.now) {
      window.performance = {
        start: Date.now(),
        now: function () {
          return Date.now() - this.start;
        }
      };
    }
  })();
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
      if (typeof this !== 'function') {
        // closest thing possible to the ECMAScript 5
        // internal IsCallable function
        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
      }

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
      };

      if (this.prototype) {
        // native functions don't have a prototype
        fNOP.prototype = this.prototype;
      }
      fBound.prototype = new fNOP();

      return fBound;
    };
  }
  // Polyfill to get the name of a function in IE9
  function functionName(fn) {
    if (Function.prototype.name === undefined) {
      var funcNameRegex = /function\s([^(]{1,})\(/;
      var results = funcNameRegex.exec(fn.toString());
      return results && results.length > 1 ? results[1].trim() : "";
    } else if (fn.prototype === undefined) {
      return fn.constructor.name;
    } else {
      return fn.prototype.constructor.name;
    }
  }
  function parseValue(str) {
    if (/true/.test(str)) return true;else if (/false/.test(str)) return false;else if (!isNaN(str * 1)) return parseFloat(str);
    return str;
  }
  // Convert PascalCase to kebab-case
  // Thank you: http://stackoverflow.com/a/8955580
  function hyphenate(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }
}(jQuery);
'use strict';

!function ($) {

  Foundation.Box = {
    ImNotTouchingYou: ImNotTouchingYou,
    GetDimensions: GetDimensions,
    GetOffsets: GetOffsets
  };

  /**
   * Compares the dimensions of an element to a container and determines collision events with container.
   * @function
   * @param {jQuery} element - jQuery object to test for collisions.
   * @param {jQuery} parent - jQuery object to use as bounding container.
   * @param {Boolean} lrOnly - set to true to check left and right values only.
   * @param {Boolean} tbOnly - set to true to check top and bottom values only.
   * @default if no parent object passed, detects collisions with `window`.
   * @returns {Boolean} - true if collision free, false if a collision in any direction.
   */
  function ImNotTouchingYou(element, parent, lrOnly, tbOnly) {
    var eleDims = GetDimensions(element),
        top,
        bottom,
        left,
        right;

    if (parent) {
      var parDims = GetDimensions(parent);

      bottom = eleDims.offset.top + eleDims.height <= parDims.height + parDims.offset.top;
      top = eleDims.offset.top >= parDims.offset.top;
      left = eleDims.offset.left >= parDims.offset.left;
      right = eleDims.offset.left + eleDims.width <= parDims.width;
    } else {
      bottom = eleDims.offset.top + eleDims.height <= eleDims.windowDims.height + eleDims.windowDims.offset.top;
      top = eleDims.offset.top >= eleDims.windowDims.offset.top;
      left = eleDims.offset.left >= eleDims.windowDims.offset.left;
      right = eleDims.offset.left + eleDims.width <= eleDims.windowDims.width;
    }

    var allDirs = [bottom, top, left, right];

    if (lrOnly) {
      return left === right === true;
    }

    if (tbOnly) {
      return top === bottom === true;
    }

    return allDirs.indexOf(false) === -1;
  };

  /**
   * Uses native methods to return an object of dimension values.
   * @function
   * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.
   * @returns {Object} - nested object of integer pixel values
   * TODO - if element is window, return only those values.
   */
  function GetDimensions(elem, test) {
    elem = elem.length ? elem[0] : elem;

    if (elem === window || elem === document) {
      throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");
    }

    var rect = elem.getBoundingClientRect(),
        parRect = elem.parentNode.getBoundingClientRect(),
        winRect = document.body.getBoundingClientRect(),
        winY = window.pageYOffset,
        winX = window.pageXOffset;

    return {
      width: rect.width,
      height: rect.height,
      offset: {
        top: rect.top + winY,
        left: rect.left + winX
      },
      parentDims: {
        width: parRect.width,
        height: parRect.height,
        offset: {
          top: parRect.top + winY,
          left: parRect.left + winX
        }
      },
      windowDims: {
        width: winRect.width,
        height: winRect.height,
        offset: {
          top: winY,
          left: winX
        }
      }
    };
  }

  /**
   * Returns an object of top and left integer pixel values for dynamically rendered elements,
   * such as: Tooltip, Reveal, and Dropdown
   * @function
   * @param {jQuery} element - jQuery object for the element being positioned.
   * @param {jQuery} anchor - jQuery object for the element's anchor point.
   * @param {String} position - a string relating to the desired position of the element, relative to it's anchor
   * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.
   * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.
   * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.
   * TODO alter/rewrite to work with `em` values as well/instead of pixels
   */
  function GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {
    var $eleDims = GetDimensions(element),
        $anchorDims = anchor ? GetDimensions(anchor) : null;

    switch (position) {
      case 'top':
        return {
          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top
        };
        break;
      case 'right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset,
          top: $anchorDims.offset.top
        };
        break;
      case 'center top':
        return {
          left: $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'center bottom':
        return {
          left: isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
        break;
      case 'center left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'center right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset + 1,
          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'center':
        return {
          left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2,
          top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'reveal':
        return {
          left: ($eleDims.windowDims.width - $eleDims.width) / 2,
          top: $eleDims.windowDims.offset.top + vOffset
        };
      case 'reveal full':
        return {
          left: $eleDims.windowDims.offset.left,
          top: $eleDims.windowDims.offset.top
        };
        break;
      case 'left bottom':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top + $anchorDims.height
        };
        break;
      case 'right bottom':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset - $eleDims.width,
          top: $anchorDims.offset.top + $anchorDims.height
        };
        break;
      default:
        return {
          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
    }
  }
}(jQuery);
/*******************************************
 *                                         *
 * This util was created by Marius Olbertz *
 * Please thank Marius on GitHub /owlbertz *
 * or the web http://www.mariusolbertz.de/ *
 *                                         *
 ******************************************/

'use strict';

!function ($) {

  var keyCodes = {
    9: 'TAB',
    13: 'ENTER',
    27: 'ESCAPE',
    32: 'SPACE',
    37: 'ARROW_LEFT',
    38: 'ARROW_UP',
    39: 'ARROW_RIGHT',
    40: 'ARROW_DOWN'
  };

  var commands = {};

  var Keyboard = {
    keys: getKeyCodes(keyCodes),

    /**
     * Parses the (keyboard) event and returns a String that represents its key
     * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
     * @param {Event} event - the event generated by the event handler
     * @return String key - String that represents the key pressed
     */
    parseKey: function (event) {
      var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();
      if (event.shiftKey) key = 'SHIFT_' + key;
      if (event.ctrlKey) key = 'CTRL_' + key;
      if (event.altKey) key = 'ALT_' + key;
      return key;
    },


    /**
     * Handles the given (keyboard) event
     * @param {Event} event - the event generated by the event handler
     * @param {String} component - Foundation component's name, e.g. Slider or Reveal
     * @param {Objects} functions - collection of functions that are to be executed
     */
    handleKey: function (event, component, functions) {
      var commandList = commands[component],
          keyCode = this.parseKey(event),
          cmds,
          command,
          fn;

      if (!commandList) return console.warn('Component not defined!');

      if (typeof commandList.ltr === 'undefined') {
        // this component does not differentiate between ltr and rtl
        cmds = commandList; // use plain list
      } else {
        // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa
        if (Foundation.rtl()) cmds = $.extend({}, commandList.ltr, commandList.rtl);else cmds = $.extend({}, commandList.rtl, commandList.ltr);
      }
      command = cmds[keyCode];

      fn = functions[command];
      if (fn && typeof fn === 'function') {
        // execute function  if exists
        fn.apply();
        if (functions.handled || typeof functions.handled === 'function') {
          // execute function when event was handled
          functions.handled.apply();
        }
      } else {
        if (functions.unhandled || typeof functions.unhandled === 'function') {
          // execute function when event was not handled
          functions.unhandled.apply();
        }
      }
    },


    /**
     * Finds all focusable elements within the given `$element`
     * @param {jQuery} $element - jQuery object to search within
     * @return {jQuery} $focusable - all focusable elements within `$element`
     */
    findFocusable: function ($element) {
      return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {
        if (!$(this).is(':visible') || $(this).attr('tabindex') < 0) {
          return false;
        } //only have visible elements and those that have a tabindex greater or equal 0
        return true;
      });
    },


    /**
     * Returns the component name name
     * @param {Object} component - Foundation component, e.g. Slider or Reveal
     * @return String componentName
     */

    register: function (componentName, cmds) {
      commands[componentName] = cmds;
    }
  };

  /*
   * Constants for easier comparing.
   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
   */
  function getKeyCodes(kcs) {
    var k = {};
    for (var kc in kcs) {
      k[kcs[kc]] = kcs[kc];
    }return k;
  }

  Foundation.Keyboard = Keyboard;
}(jQuery);
'use strict';

!function ($) {

  // Default set of media queries
  var defaultQueries = {
    'default': 'only screen',
    landscape: 'only screen and (orientation: landscape)',
    portrait: 'only screen and (orientation: portrait)',
    retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'
  };

  var MediaQuery = {
    queries: [],

    current: '',

    /**
     * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.
     * @function
     * @private
     */
    _init: function () {
      var self = this;
      var extractedStyles = $('.foundation-mq').css('font-family');
      var namedQueries;

      namedQueries = parseStyleToObject(extractedStyles);

      for (var key in namedQueries) {
        self.queries.push({
          name: key,
          value: 'only screen and (min-width: ' + namedQueries[key] + ')'
        });
      }

      this.current = this._getCurrentSize();

      this._watcher();
    },


    /**
     * Checks if the screen is at least as wide as a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to check.
     * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.
     */
    atLeast: function (size) {
      var query = this.get(size);

      if (query) {
        return window.matchMedia(query).matches;
      }

      return false;
    },


    /**
     * Gets the media query of a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to get.
     * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.
     */
    get: function (size) {
      for (var i in this.queries) {
        var query = this.queries[i];
        if (size === query.name) return query.value;
      }

      return null;
    },


    /**
     * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).
     * @function
     * @private
     * @returns {String} Name of the current breakpoint.
     */
    _getCurrentSize: function () {
      var matched;

      for (var i = 0; i < this.queries.length; i++) {
        var query = this.queries[i];

        if (window.matchMedia(query.value).matches) {
          matched = query;
        }
      }

      if (typeof matched === 'object') {
        return matched.name;
      } else {
        return matched;
      }
    },


    /**
     * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.
     * @function
     * @private
     */
    _watcher: function () {
      var _this = this;

      $(window).on('resize.zf.mediaquery', function () {
        var newSize = _this._getCurrentSize();

        if (newSize !== _this.current) {
          // Broadcast the media query change on the window
          $(window).trigger('changed.zf.mediaquery', [newSize, _this.current]);

          // Change the current media query
          _this.current = newSize;
        }
      });
    }
  };

  Foundation.MediaQuery = MediaQuery;

  // matchMedia() polyfill - Test a CSS media type/query in JS.
  // Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license
  window.matchMedia || (window.matchMedia = function () {
    'use strict';

    // For browsers that support matchMedium api such as IE 9 and webkit

    var styleMedia = window.styleMedia || window.media;

    // For those that don't support matchMedium
    if (!styleMedia) {
      var style = document.createElement('style'),
          script = document.getElementsByTagName('script')[0],
          info = null;

      style.type = 'text/css';
      style.id = 'matchmediajs-test';

      script.parentNode.insertBefore(style, script);

      // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
      info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;

      styleMedia = {
        matchMedium: function (media) {
          var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

          // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
          if (style.styleSheet) {
            style.styleSheet.cssText = text;
          } else {
            style.textContent = text;
          }

          // Test if media query is true or false
          return info.width === '1px';
        }
      };
    }

    return function (media) {
      return {
        matches: styleMedia.matchMedium(media || 'all'),
        media: media || 'all'
      };
    };
  }());

  // Thank you: https://github.com/sindresorhus/query-string
  function parseStyleToObject(str) {
    var styleObject = {};

    if (typeof str !== 'string') {
      return styleObject;
    }

    str = str.trim().slice(1, -1); // browsers re-quote string style values

    if (!str) {
      return styleObject;
    }

    styleObject = str.split('&').reduce(function (ret, param) {
      var parts = param.replace(/\+/g, ' ').split('=');
      var key = parts[0];
      var val = parts[1];
      key = decodeURIComponent(key);

      // missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
      val = val === undefined ? null : decodeURIComponent(val);

      if (!ret.hasOwnProperty(key)) {
        ret[key] = val;
      } else if (Array.isArray(ret[key])) {
        ret[key].push(val);
      } else {
        ret[key] = [ret[key], val];
      }
      return ret;
    }, {});

    return styleObject;
  }

  Foundation.MediaQuery = MediaQuery;
}(jQuery);
'use strict';

!function ($) {

  /**
   * Motion module.
   * @module foundation.motion
   */

  var initClasses = ['mui-enter', 'mui-leave'];
  var activeClasses = ['mui-enter-active', 'mui-leave-active'];

  var Motion = {
    animateIn: function (element, animation, cb) {
      animate(true, element, animation, cb);
    },

    animateOut: function (element, animation, cb) {
      animate(false, element, animation, cb);
    }
  };

  function Move(duration, elem, fn) {
    var anim,
        prog,
        start = null;
    // console.log('called');

    function move(ts) {
      if (!start) start = window.performance.now();
      // console.log(start, ts);
      prog = ts - start;
      fn.apply(elem);

      if (prog < duration) {
        anim = window.requestAnimationFrame(move, elem);
      } else {
        window.cancelAnimationFrame(anim);
        elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
      }
    }
    anim = window.requestAnimationFrame(move);
  }

  /**
   * Animates an element in or out using a CSS transition class.
   * @function
   * @private
   * @param {Boolean} isIn - Defines if the animation is in or out.
   * @param {Object} element - jQuery or HTML object to animate.
   * @param {String} animation - CSS class to use.
   * @param {Function} cb - Callback to run when animation is finished.
   */
  function animate(isIn, element, animation, cb) {
    element = $(element).eq(0);

    if (!element.length) return;

    var initClass = isIn ? initClasses[0] : initClasses[1];
    var activeClass = isIn ? activeClasses[0] : activeClasses[1];

    // Set up the animation
    reset();

    element.addClass(animation).css('transition', 'none');

    requestAnimationFrame(function () {
      element.addClass(initClass);
      if (isIn) element.show();
    });

    // Start the animation
    requestAnimationFrame(function () {
      element[0].offsetWidth;
      element.css('transition', '').addClass(activeClass);
    });

    // Clean up the animation when it finishes
    element.one(Foundation.transitionend(element), finish);

    // Hides the element (for out animations), resets the element, and runs a callback
    function finish() {
      if (!isIn) element.hide();
      reset();
      if (cb) cb.apply(element);
    }

    // Resets transitions and removes motion-specific classes
    function reset() {
      element[0].style.transitionDuration = 0;
      element.removeClass(initClass + ' ' + activeClass + ' ' + animation);
    }
  }

  Foundation.Move = Move;
  Foundation.Motion = Motion;
}(jQuery);
'use strict';

!function ($) {

  var Nest = {
    Feather: function (menu) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'zf';

      menu.attr('role', 'menubar');

      var items = menu.find('li').attr({ 'role': 'menuitem' }),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      menu.find('a:first').attr('tabindex', 0);

      items.each(function () {
        var $item = $(this),
            $sub = $item.children('ul');

        if ($sub.length) {
          $item.addClass(hasSubClass).attr({
            'aria-haspopup': true,
            'aria-expanded': false,
            'aria-label': $item.children('a:first').text()
          });

          $sub.addClass('submenu ' + subMenuClass).attr({
            'data-submenu': '',
            'aria-hidden': true,
            'role': 'menu'
          });
        }

        if ($item.parent('[data-submenu]').length) {
          $item.addClass('is-submenu-item ' + subItemClass);
        }
      });

      return;
    },
    Burn: function (menu, type) {
      var items = menu.find('li').removeAttr('tabindex'),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      menu.find('*').removeClass(subMenuClass + ' ' + subItemClass + ' ' + hasSubClass + ' is-submenu-item submenu is-active').removeAttr('data-submenu').css('display', '');

      // console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')
      //           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')
      //           .removeAttr('data-submenu'));
      // items.each(function(){
      //   var $item = $(this),
      //       $sub = $item.children('ul');
      //   if($item.parent('[data-submenu]').length){
      //     $item.removeClass('is-submenu-item ' + subItemClass);
      //   }
      //   if($sub.length){
      //     $item.removeClass('has-submenu');
      //     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');
      //   }
      // });
    }
  };

  Foundation.Nest = Nest;
}(jQuery);
'use strict';

!function ($) {

  function Timer(elem, options, cb) {
    var _this = this,
        duration = options.duration,
        //options is an object for easily adding features later.
    nameSpace = Object.keys(elem.data())[0] || 'timer',
        remain = -1,
        start,
        timer;

    this.isPaused = false;

    this.restart = function () {
      remain = -1;
      clearTimeout(timer);
      this.start();
    };

    this.start = function () {
      this.isPaused = false;
      // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      remain = remain <= 0 ? duration : remain;
      elem.data('paused', false);
      start = Date.now();
      timer = setTimeout(function () {
        if (options.infinite) {
          _this.restart(); //rerun the timer.
        }
        cb();
      }, remain);
      elem.trigger('timerstart.zf.' + nameSpace);
    };

    this.pause = function () {
      this.isPaused = true;
      //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      elem.data('paused', true);
      var end = Date.now();
      remain = remain - (end - start);
      elem.trigger('timerpaused.zf.' + nameSpace);
    };
  }

  /**
   * Runs a callback function when images are fully loaded.
   * @param {Object} images - Image(s) to check if loaded.
   * @param {Func} callback - Function to execute when image is fully loaded.
   */
  function onImagesLoaded(images, callback) {
    var self = this,
        unloaded = images.length;

    if (unloaded === 0) {
      callback();
    }

    images.each(function () {
      if (this.complete) {
        singleImageLoaded();
      } else if (typeof this.naturalWidth !== 'undefined' && this.naturalWidth > 0) {
        singleImageLoaded();
      } else {
        $(this).one('load', function () {
          singleImageLoaded();
        });
      }
    });

    function singleImageLoaded() {
      unloaded--;
      if (unloaded === 0) {
        callback();
      }
    }
  }

  Foundation.Timer = Timer;
  Foundation.onImagesLoaded = onImagesLoaded;
}(jQuery);
//**************************************************
//**Work inspired by multiple jquery swipe plugins**
//**Done by Yohai Ararat ***************************
//**************************************************
(function ($) {

	$.spotSwipe = {
		version: '1.0.0',
		enabled: 'ontouchstart' in document.documentElement,
		preventDefault: false,
		moveThreshold: 75,
		timeThreshold: 200
	};

	var startPosX,
	    startPosY,
	    startTime,
	    elapsedTime,
	    isMoving = false;

	function onTouchEnd() {
		//  alert(this);
		this.removeEventListener('touchmove', onTouchMove);
		this.removeEventListener('touchend', onTouchEnd);
		isMoving = false;
	}

	function onTouchMove(e) {
		if ($.spotSwipe.preventDefault) {
			e.preventDefault();
		}
		if (isMoving) {
			var x = e.touches[0].pageX;
			var y = e.touches[0].pageY;
			var dx = startPosX - x;
			var dy = startPosY - y;
			var dir;
			elapsedTime = new Date().getTime() - startTime;
			if (Math.abs(dx) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
				dir = dx > 0 ? 'left' : 'right';
			}
			// else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
			//   dir = dy > 0 ? 'down' : 'up';
			// }
			if (dir) {
				e.preventDefault();
				onTouchEnd.call(this);
				$(this).trigger('swipe', dir).trigger('swipe' + dir);
			}
		}
	}

	function onTouchStart(e) {
		if (e.touches.length == 1) {
			startPosX = e.touches[0].pageX;
			startPosY = e.touches[0].pageY;
			isMoving = true;
			startTime = new Date().getTime();
			this.addEventListener('touchmove', onTouchMove, false);
			this.addEventListener('touchend', onTouchEnd, false);
		}
	}

	function init() {
		this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);
	}

	function teardown() {
		this.removeEventListener('touchstart', onTouchStart);
	}

	$.event.special.swipe = { setup: init };

	$.each(['left', 'up', 'down', 'right'], function () {
		$.event.special['swipe' + this] = { setup: function () {
				$(this).on('swipe', $.noop);
			} };
	});
})(jQuery);
/****************************************************
 * Method for adding psuedo drag events to elements *
 ***************************************************/
!function ($) {
	$.fn.addTouch = function () {
		this.each(function (i, el) {
			$(el).bind('touchstart touchmove touchend touchcancel', function () {
				//we pass the original event object because the jQuery event
				//object is normalized to w3c specs and does not provide the TouchList
				handleTouch(event);
			});
		});

		var handleTouch = function (event) {
			var touches = event.changedTouches,
			    first = touches[0],
			    eventTypes = {
				touchstart: 'mousedown',
				touchmove: 'mousemove',
				touchend: 'mouseup'
			},
			    type = eventTypes[event.type],
			    simulatedEvent;

			if ('MouseEvent' in window && typeof window.MouseEvent === 'function') {
				simulatedEvent = window.MouseEvent(type, {
					'bubbles': true,
					'cancelable': true,
					'screenX': first.screenX,
					'screenY': first.screenY,
					'clientX': first.clientX,
					'clientY': first.clientY
				});
			} else {
				simulatedEvent = document.createEvent('MouseEvent');
				simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0 /*left*/, null);
			}
			first.target.dispatchEvent(simulatedEvent);
		};
	};
}(jQuery);

//**********************************
//**From the jQuery Mobile Library**
//**need to recreate functionality**
//**and try to improve if possible**
//**********************************

/* Removing the jQuery function ****
************************************

(function( $, window, undefined ) {

	var $document = $( document ),
		// supportTouch = $.mobile.support.touch,
		touchStartEvent = 'touchstart'//supportTouch ? "touchstart" : "mousedown",
		touchStopEvent = 'touchend'//supportTouch ? "touchend" : "mouseup",
		touchMoveEvent = 'touchmove'//supportTouch ? "touchmove" : "mousemove";

	// setup new event shortcuts
	$.each( ( "touchstart touchmove touchend " +
		"swipe swipeleft swiperight" ).split( " " ), function( i, name ) {

		$.fn[ name ] = function( fn ) {
			return fn ? this.bind( name, fn ) : this.trigger( name );
		};

		// jQuery < 1.8
		if ( $.attrFn ) {
			$.attrFn[ name ] = true;
		}
	});

	function triggerCustomEvent( obj, eventType, event, bubble ) {
		var originalType = event.type;
		event.type = eventType;
		if ( bubble ) {
			$.event.trigger( event, undefined, obj );
		} else {
			$.event.dispatch.call( obj, event );
		}
		event.type = originalType;
	}

	// also handles taphold

	// Also handles swipeleft, swiperight
	$.event.special.swipe = {

		// More than this horizontal displacement, and we will suppress scrolling.
		scrollSupressionThreshold: 30,

		// More time than this, and it isn't a swipe.
		durationThreshold: 1000,

		// Swipe horizontal displacement must be more than this.
		horizontalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		// Swipe vertical displacement must be less than this.
		verticalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		getLocation: function ( event ) {
			var winPageX = window.pageXOffset,
				winPageY = window.pageYOffset,
				x = event.clientX,
				y = event.clientY;

			if ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||
				event.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {

				// iOS4 clientX/clientY have the value that should have been
				// in pageX/pageY. While pageX/page/ have the value 0
				x = x - winPageX;
				y = y - winPageY;
			} else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {

				// Some Android browsers have totally bogus values for clientX/Y
				// when scrolling/zooming a page. Detectable since clientX/clientY
				// should never be smaller than pageX/pageY minus page scroll
				x = event.pageX - winPageX;
				y = event.pageY - winPageY;
			}

			return {
				x: x,
				y: y
			};
		},

		start: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ],
						origin: $( event.target )
					};
		},

		stop: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ]
					};
		},

		handleSwipe: function( start, stop, thisObject, origTarget ) {
			if ( stop.time - start.time < $.event.special.swipe.durationThreshold &&
				Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&
				Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {
				var direction = start.coords[0] > stop.coords[ 0 ] ? "swipeleft" : "swiperight";

				triggerCustomEvent( thisObject, "swipe", $.Event( "swipe", { target: origTarget, swipestart: start, swipestop: stop }), true );
				triggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );
				return true;
			}
			return false;

		},

		// This serves as a flag to ensure that at most one swipe event event is
		// in work at any given time
		eventInProgress: false,

		setup: function() {
			var events,
				thisObject = this,
				$this = $( thisObject ),
				context = {};

			// Retrieve the events data for this element and add the swipe context
			events = $.data( this, "mobile-events" );
			if ( !events ) {
				events = { length: 0 };
				$.data( this, "mobile-events", events );
			}
			events.length++;
			events.swipe = context;

			context.start = function( event ) {

				// Bail if we're already working on a swipe event
				if ( $.event.special.swipe.eventInProgress ) {
					return;
				}
				$.event.special.swipe.eventInProgress = true;

				var stop,
					start = $.event.special.swipe.start( event ),
					origTarget = event.target,
					emitted = false;

				context.move = function( event ) {
					if ( !start || event.isDefaultPrevented() ) {
						return;
					}

					stop = $.event.special.swipe.stop( event );
					if ( !emitted ) {
						emitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );
						if ( emitted ) {

							// Reset the context to make way for the next swipe event
							$.event.special.swipe.eventInProgress = false;
						}
					}
					// prevent scrolling
					if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {
						event.preventDefault();
					}
				};

				context.stop = function() {
						emitted = true;

						// Reset the context to make way for the next swipe event
						$.event.special.swipe.eventInProgress = false;
						$document.off( touchMoveEvent, context.move );
						context.move = null;
				};

				$document.on( touchMoveEvent, context.move )
					.one( touchStopEvent, context.stop );
			};
			$this.on( touchStartEvent, context.start );
		},

		teardown: function() {
			var events, context;

			events = $.data( this, "mobile-events" );
			if ( events ) {
				context = events.swipe;
				delete events.swipe;
				events.length--;
				if ( events.length === 0 ) {
					$.removeData( this, "mobile-events" );
				}
			}

			if ( context ) {
				if ( context.start ) {
					$( this ).off( touchStartEvent, context.start );
				}
				if ( context.move ) {
					$document.off( touchMoveEvent, context.move );
				}
				if ( context.stop ) {
					$document.off( touchStopEvent, context.stop );
				}
			}
		}
	};
	$.each({
		swipeleft: "swipe.left",
		swiperight: "swipe.right"
	}, function( event, sourceEvent ) {

		$.event.special[ event ] = {
			setup: function() {
				$( this ).bind( sourceEvent, $.noop );
			},
			teardown: function() {
				$( this ).unbind( sourceEvent );
			}
		};
	});
})( jQuery, this );
*/
'use strict';

!function ($) {

  var MutationObserver = function () {
    var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
    for (var i = 0; i < prefixes.length; i++) {
      if (prefixes[i] + 'MutationObserver' in window) {
        return window[prefixes[i] + 'MutationObserver'];
      }
    }
    return false;
  }();

  var triggers = function (el, type) {
    el.data(type).split(' ').forEach(function (id) {
      $('#' + id)[type === 'close' ? 'trigger' : 'triggerHandler'](type + '.zf.trigger', [el]);
    });
  };
  // Elements with [data-open] will reveal a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-open]', function () {
    triggers($(this), 'open');
  });

  // Elements with [data-close] will close a plugin that supports it when clicked.
  // If used without a value on [data-close], the event will bubble, allowing it to close a parent component.
  $(document).on('click.zf.trigger', '[data-close]', function () {
    var id = $(this).data('close');
    if (id) {
      triggers($(this), 'close');
    } else {
      $(this).trigger('close.zf.trigger');
    }
  });

  // Elements with [data-toggle] will toggle a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-toggle]', function () {
    triggers($(this), 'toggle');
  });

  // Elements with [data-closable] will respond to close.zf.trigger events.
  $(document).on('close.zf.trigger', '[data-closable]', function (e) {
    e.stopPropagation();
    var animation = $(this).data('closable');

    if (animation !== '') {
      Foundation.Motion.animateOut($(this), animation, function () {
        $(this).trigger('closed.zf');
      });
    } else {
      $(this).fadeOut().trigger('closed.zf');
    }
  });

  $(document).on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', function () {
    var id = $(this).data('toggle-focus');
    $('#' + id).triggerHandler('toggle.zf.trigger', [$(this)]);
  });

  /**
  * Fires once after all other scripts have loaded
  * @function
  * @private
  */
  $(window).load(function () {
    checkListeners();
  });

  function checkListeners() {
    eventsListener();
    resizeListener();
    scrollListener();
    closemeListener();
  }

  //******** only fires this function once on load, if there's something to watch ********
  function closemeListener(pluginName) {
    var yetiBoxes = $('[data-yeti-box]'),
        plugNames = ['dropdown', 'tooltip', 'reveal'];

    if (pluginName) {
      if (typeof pluginName === 'string') {
        plugNames.push(pluginName);
      } else if (typeof pluginName === 'object' && typeof pluginName[0] === 'string') {
        plugNames.concat(pluginName);
      } else {
        console.error('Plugin names must be strings');
      }
    }
    if (yetiBoxes.length) {
      var listeners = plugNames.map(function (name) {
        return 'closeme.zf.' + name;
      }).join(' ');

      $(window).off(listeners).on(listeners, function (e, pluginId) {
        var plugin = e.namespace.split('.')[0];
        var plugins = $('[data-' + plugin + ']').not('[data-yeti-box="' + pluginId + '"]');

        plugins.each(function () {
          var _this = $(this);

          _this.triggerHandler('close.zf.trigger', [_this]);
        });
      });
    }
  }

  function resizeListener(debounce) {
    var timer = void 0,
        $nodes = $('[data-resize]');
    if ($nodes.length) {
      $(window).off('resize.zf.trigger').on('resize.zf.trigger', function (e) {
        if (timer) {
          clearTimeout(timer);
        }

        timer = setTimeout(function () {

          if (!MutationObserver) {
            //fallback for IE 9
            $nodes.each(function () {
              $(this).triggerHandler('resizeme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a resize event
          $nodes.attr('data-events', "resize");
        }, debounce || 10); //default time to emit resize event
      });
    }
  }

  function scrollListener(debounce) {
    var timer = void 0,
        $nodes = $('[data-scroll]');
    if ($nodes.length) {
      $(window).off('scroll.zf.trigger').on('scroll.zf.trigger', function (e) {
        if (timer) {
          clearTimeout(timer);
        }

        timer = setTimeout(function () {

          if (!MutationObserver) {
            //fallback for IE 9
            $nodes.each(function () {
              $(this).triggerHandler('scrollme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a scroll event
          $nodes.attr('data-events', "scroll");
        }, debounce || 10); //default time to emit scroll event
      });
    }
  }

  function eventsListener() {
    if (!MutationObserver) {
      return false;
    }
    var nodes = document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');

    //element callback
    var listeningElementsMutation = function (mutationRecordsList) {
      var $target = $(mutationRecordsList[0].target);
      //trigger the event handler for the element depending on type
      switch ($target.attr("data-events")) {

        case "resize":
          $target.triggerHandler('resizeme.zf.trigger', [$target]);
          break;

        case "scroll":
          $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);
          break;

        // case "mutate" :
        // console.log('mutate', $target);
        // $target.triggerHandler('mutate.zf.trigger');
        //
        // //make sure we don't get stuck in an infinite loop from sloppy codeing
        // if ($target.index('[data-mutate]') == $("[data-mutate]").length-1) {
        //   domMutationObserver();
        // }
        // break;

        default:
          return false;
        //nothing
      }
    };

    if (nodes.length) {
      //for each element that needs to listen for resizing, scrolling, (or coming soon mutation) add a single observer
      for (var i = 0; i <= nodes.length - 1; i++) {
        var elementObserver = new MutationObserver(listeningElementsMutation);
        elementObserver.observe(nodes[i], { attributes: true, childList: false, characterData: false, subtree: false, attributeFilter: ["data-events"] });
      }
    }
  }

  // ------------------------------------

  // [PH]
  // Foundation.CheckWatchers = checkWatchers;
  Foundation.IHearYou = checkListeners;
  // Foundation.ISeeYou = scrollListener;
  // Foundation.IFeelYou = closemeListener;
}(jQuery);

// function domMutationObserver(debounce) {
//   // !!! This is coming soon and needs more work; not active  !!! //
//   var timer,
//   nodes = document.querySelectorAll('[data-mutate]');
//   //
//   if (nodes.length) {
//     // var MutationObserver = (function () {
//     //   var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
//     //   for (var i=0; i < prefixes.length; i++) {
//     //     if (prefixes[i] + 'MutationObserver' in window) {
//     //       return window[prefixes[i] + 'MutationObserver'];
//     //     }
//     //   }
//     //   return false;
//     // }());
//
//
//     //for the body, we need to listen for all changes effecting the style and class attributes
//     var bodyObserver = new MutationObserver(bodyMutation);
//     bodyObserver.observe(document.body, { attributes: true, childList: true, characterData: false, subtree:true, attributeFilter:["style", "class"]});
//
//
//     //body callback
//     function bodyMutation(mutate) {
//       //trigger all listening elements and signal a mutation event
//       if (timer) { clearTimeout(timer); }
//
//       timer = setTimeout(function() {
//         bodyObserver.disconnect();
//         $('[data-mutate]').attr('data-events',"mutate");
//       }, debounce || 150);
//     }
//   }
// }
'use strict';

/*!
 * Masonry PACKAGED v4.1.1
 * Cascading grid layout library
 * http://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */

/**
 * Bridget makes jQuery widgets
 * v2.0.1
 * MIT license
 */

/* jshint browser: true, strict: true, undef: true, unused: true */

(function (window, factory) {
  // universal module definition
  /*jshint strict: false */ /* globals define, module, require */
  if (typeof define == 'function' && define.amd) {
    // AMD
    define('jquery-bridget/jquery-bridget', ['jquery'], function (jQuery) {
      return factory(window, jQuery);
    });
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('jquery'));
  } else {
    // browser global
    window.jQueryBridget = factory(window, window.jQuery);
  }
})(window, function factory(window, jQuery) {
  'use strict';

  // ----- utils ----- //

  var arraySlice = Array.prototype.slice;

  // helper function for logging errors
  // $.error breaks jQuery chaining
  var console = window.console;
  var logError = typeof console == 'undefined' ? function () {} : function (message) {
    console.error(message);
  };

  // ----- jQueryBridget ----- //

  function jQueryBridget(namespace, PluginClass, $) {
    $ = $ || jQuery || window.jQuery;
    if (!$) {
      return;
    }

    // add option method -> $().plugin('option', {...})
    if (!PluginClass.prototype.option) {
      // option setter
      PluginClass.prototype.option = function (opts) {
        // bail out if not an object
        if (!$.isPlainObject(opts)) {
          return;
        }
        this.options = $.extend(true, this.options, opts);
      };
    }

    // make jQuery plugin
    $.fn[namespace] = function (arg0 /*, arg1 */) {
      if (typeof arg0 == 'string') {
        // method call $().plugin( 'methodName', { options } )
        // shift arguments by 1
        var args = arraySlice.call(arguments, 1);
        return methodCall(this, arg0, args);
      }
      // just $().plugin({ options })
      plainCall(this, arg0);
      return this;
    };

    // $().plugin('methodName')
    function methodCall($elems, methodName, args) {
      var returnValue;
      var pluginMethodStr = '$().' + namespace + '("' + methodName + '")';

      $elems.each(function (i, elem) {
        // get instance
        var instance = $.data(elem, namespace);
        if (!instance) {
          logError(namespace + ' not initialized. Cannot call methods, i.e. ' + pluginMethodStr);
          return;
        }

        var method = instance[methodName];
        if (!method || methodName.charAt(0) == '_') {
          logError(pluginMethodStr + ' is not a valid method');
          return;
        }

        // apply method, get return value
        var value = method.apply(instance, args);
        // set return value if value is returned, use only first value
        returnValue = returnValue === undefined ? value : returnValue;
      });

      return returnValue !== undefined ? returnValue : $elems;
    }

    function plainCall($elems, options) {
      $elems.each(function (i, elem) {
        var instance = $.data(elem, namespace);
        if (instance) {
          // set options & init
          instance.option(options);
          instance._init();
        } else {
          // initialize new instance
          instance = new PluginClass(elem, options);
          $.data(elem, namespace, instance);
        }
      });
    }

    updateJQuery($);
  }

  // ----- updateJQuery ----- //

  // set $.bridget for v1 backwards compatibility
  function updateJQuery($) {
    if (!$ || $ && $.bridget) {
      return;
    }
    $.bridget = jQueryBridget;
  }

  updateJQuery(jQuery || window.jQuery);

  // -----  ----- //

  return jQueryBridget;
});

/**
 * EvEmitter v1.0.3
 * Lil' event emitter
 * MIT License
 */

/* jshint unused: true, undef: true, strict: true */

(function (global, factory) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, window */
  if (typeof define == 'function' && define.amd) {
    // AMD - RequireJS
    define('ev-emitter/ev-emitter', factory);
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS - Browserify, Webpack
    module.exports = factory();
  } else {
    // Browser globals
    global.EvEmitter = factory();
  }
})(typeof window != 'undefined' ? window : this, function () {

  function EvEmitter() {}

  var proto = EvEmitter.prototype;

  proto.on = function (eventName, listener) {
    if (!eventName || !listener) {
      return;
    }
    // set events hash
    var events = this._events = this._events || {};
    // set listeners array
    var listeners = events[eventName] = events[eventName] || [];
    // only add once
    if (listeners.indexOf(listener) == -1) {
      listeners.push(listener);
    }

    return this;
  };

  proto.once = function (eventName, listener) {
    if (!eventName || !listener) {
      return;
    }
    // add event
    this.on(eventName, listener);
    // set once flag
    // set onceEvents hash
    var onceEvents = this._onceEvents = this._onceEvents || {};
    // set onceListeners object
    var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
    // set flag
    onceListeners[listener] = true;

    return this;
  };

  proto.off = function (eventName, listener) {
    var listeners = this._events && this._events[eventName];
    if (!listeners || !listeners.length) {
      return;
    }
    var index = listeners.indexOf(listener);
    if (index != -1) {
      listeners.splice(index, 1);
    }

    return this;
  };

  proto.emitEvent = function (eventName, args) {
    var listeners = this._events && this._events[eventName];
    if (!listeners || !listeners.length) {
      return;
    }
    var i = 0;
    var listener = listeners[i];
    args = args || [];
    // once stuff
    var onceListeners = this._onceEvents && this._onceEvents[eventName];

    while (listener) {
      var isOnce = onceListeners && onceListeners[listener];
      if (isOnce) {
        // remove listener
        // remove before trigger to prevent recursion
        this.off(eventName, listener);
        // unset once flag
        delete onceListeners[listener];
      }
      // trigger listener
      listener.apply(this, args);
      // get next listener
      i += isOnce ? 0 : 1;
      listener = listeners[i];
    }

    return this;
  };

  return EvEmitter;
});

/*!
 * getSize v2.0.2
 * measure size of elements
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false, module: false, console: false */

(function (window, factory) {
  'use strict';

  if (typeof define == 'function' && define.amd) {
    // AMD
    define('get-size/get-size', [], function () {
      return factory();
    });
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.getSize = factory();
  }
})(window, function factory() {
  'use strict';

  // -------------------------- helpers -------------------------- //

  // get a number from a string, not a percentage

  function getStyleSize(value) {
    var num = parseFloat(value);
    // not a percent like '100%', and a number
    var isValid = value.indexOf('%') == -1 && !isNaN(num);
    return isValid && num;
  }

  function noop() {}

  var logError = typeof console == 'undefined' ? noop : function (message) {
    console.error(message);
  };

  // -------------------------- measurements -------------------------- //

  var measurements = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth'];

  var measurementsLength = measurements.length;

  function getZeroSize() {
    var size = {
      width: 0,
      height: 0,
      innerWidth: 0,
      innerHeight: 0,
      outerWidth: 0,
      outerHeight: 0
    };
    for (var i = 0; i < measurementsLength; i++) {
      var measurement = measurements[i];
      size[measurement] = 0;
    }
    return size;
  }

  // -------------------------- getStyle -------------------------- //

  /**
   * getStyle, get style of element, check for Firefox bug
   * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
   */
  function getStyle(elem) {
    var style = getComputedStyle(elem);
    if (!style) {
      logError('Style returned ' + style + '. Are you running this code in a hidden iframe on Firefox? ' + 'See http://bit.ly/getsizebug1');
    }
    return style;
  }

  // -------------------------- setup -------------------------- //

  var isSetup = false;

  var isBoxSizeOuter;

  /**
   * setup
   * check isBoxSizerOuter
   * do on first getSize() rather than on page load for Firefox bug
   */
  function setup() {
    // setup once
    if (isSetup) {
      return;
    }
    isSetup = true;

    // -------------------------- box sizing -------------------------- //

    /**
     * WebKit measures the outer-width on style.width on border-box elems
     * IE & Firefox<29 measures the inner-width
     */
    var div = document.createElement('div');
    div.style.width = '200px';
    div.style.padding = '1px 2px 3px 4px';
    div.style.borderStyle = 'solid';
    div.style.borderWidth = '1px 2px 3px 4px';
    div.style.boxSizing = 'border-box';

    var body = document.body || document.documentElement;
    body.appendChild(div);
    var style = getStyle(div);

    getSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize(style.width) == 200;
    body.removeChild(div);
  }

  // -------------------------- getSize -------------------------- //

  function getSize(elem) {
    setup();

    // use querySeletor if elem is string
    if (typeof elem == 'string') {
      elem = document.querySelector(elem);
    }

    // do not proceed on non-objects
    if (!elem || typeof elem != 'object' || !elem.nodeType) {
      return;
    }

    var style = getStyle(elem);

    // if hidden, everything is 0
    if (style.display == 'none') {
      return getZeroSize();
    }

    var size = {};
    size.width = elem.offsetWidth;
    size.height = elem.offsetHeight;

    var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';

    // get all measurements
    for (var i = 0; i < measurementsLength; i++) {
      var measurement = measurements[i];
      var value = style[measurement];
      var num = parseFloat(value);
      // any 'auto', 'medium' value will be 0
      size[measurement] = !isNaN(num) ? num : 0;
    }

    var paddingWidth = size.paddingLeft + size.paddingRight;
    var paddingHeight = size.paddingTop + size.paddingBottom;
    var marginWidth = size.marginLeft + size.marginRight;
    var marginHeight = size.marginTop + size.marginBottom;
    var borderWidth = size.borderLeftWidth + size.borderRightWidth;
    var borderHeight = size.borderTopWidth + size.borderBottomWidth;

    var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

    // overwrite width and height if we can get it from style
    var styleWidth = getStyleSize(style.width);
    if (styleWidth !== false) {
      size.width = styleWidth + (
      // add padding and border unless it's already including it
      isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
    }

    var styleHeight = getStyleSize(style.height);
    if (styleHeight !== false) {
      size.height = styleHeight + (
      // add padding and border unless it's already including it
      isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
    }

    size.innerWidth = size.width - (paddingWidth + borderWidth);
    size.innerHeight = size.height - (paddingHeight + borderHeight);

    size.outerWidth = size.width + marginWidth;
    size.outerHeight = size.height + marginHeight;

    return size;
  }

  return getSize;
});

/**
 * matchesSelector v2.0.1
 * matchesSelector( element, '.selector' )
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */

(function (window, factory) {
  /*global define: false, module: false */
  'use strict';
  // universal module definition

  if (typeof define == 'function' && define.amd) {
    // AMD
    define('desandro-matches-selector/matches-selector', factory);
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.matchesSelector = factory();
  }
})(window, function factory() {
  'use strict';

  var matchesMethod = function () {
    var ElemProto = Element.prototype;
    // check for the standard method name first
    if (ElemProto.matches) {
      return 'matches';
    }
    // check un-prefixed
    if (ElemProto.matchesSelector) {
      return 'matchesSelector';
    }
    // check vendor prefixes
    var prefixes = ['webkit', 'moz', 'ms', 'o'];

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var method = prefix + 'MatchesSelector';
      if (ElemProto[method]) {
        return method;
      }
    }
  }();

  return function matchesSelector(elem, selector) {
    return elem[matchesMethod](selector);
  };
});

/**
 * Fizzy UI utils v2.0.2
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */

(function (window, factory) {
  // universal module definition
  /*jshint strict: false */ /*globals define, module, require */

  if (typeof define == 'function' && define.amd) {
    // AMD
    define('fizzy-ui-utils/utils', ['desandro-matches-selector/matches-selector'], function (matchesSelector) {
      return factory(window, matchesSelector);
    });
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('desandro-matches-selector'));
  } else {
    // browser global
    window.fizzyUIUtils = factory(window, window.matchesSelector);
  }
})(window, function factory(window, matchesSelector) {

  var utils = {};

  // ----- extend ----- //

  // extends objects
  utils.extend = function (a, b) {
    for (var prop in b) {
      a[prop] = b[prop];
    }
    return a;
  };

  // ----- modulo ----- //

  utils.modulo = function (num, div) {
    return (num % div + div) % div;
  };

  // ----- makeArray ----- //

  // turn element or nodeList into an array
  utils.makeArray = function (obj) {
    var ary = [];
    if (Array.isArray(obj)) {
      // use object if already an array
      ary = obj;
    } else if (obj && typeof obj.length == 'number') {
      // convert nodeList to array
      for (var i = 0; i < obj.length; i++) {
        ary.push(obj[i]);
      }
    } else {
      // array of single index
      ary.push(obj);
    }
    return ary;
  };

  // ----- removeFrom ----- //

  utils.removeFrom = function (ary, obj) {
    var index = ary.indexOf(obj);
    if (index != -1) {
      ary.splice(index, 1);
    }
  };

  // ----- getParent ----- //

  utils.getParent = function (elem, selector) {
    while (elem != document.body) {
      elem = elem.parentNode;
      if (matchesSelector(elem, selector)) {
        return elem;
      }
    }
  };

  // ----- getQueryElement ----- //

  // use element as selector string
  utils.getQueryElement = function (elem) {
    if (typeof elem == 'string') {
      return document.querySelector(elem);
    }
    return elem;
  };

  // ----- handleEvent ----- //

  // enable .ontype to trigger from .addEventListener( elem, 'type' )
  utils.handleEvent = function (event) {
    var method = 'on' + event.type;
    if (this[method]) {
      this[method](event);
    }
  };

  // ----- filterFindElements ----- //

  utils.filterFindElements = function (elems, selector) {
    // make array of elems
    elems = utils.makeArray(elems);
    var ffElems = [];

    elems.forEach(function (elem) {
      // check that elem is an actual element
      if (!(elem instanceof HTMLElement)) {
        return;
      }
      // add elem if no selector
      if (!selector) {
        ffElems.push(elem);
        return;
      }
      // filter & find items if we have a selector
      // filter
      if (matchesSelector(elem, selector)) {
        ffElems.push(elem);
      }
      // find children
      var childElems = elem.querySelectorAll(selector);
      // concat childElems to filterFound array
      for (var i = 0; i < childElems.length; i++) {
        ffElems.push(childElems[i]);
      }
    });

    return ffElems;
  };

  // ----- debounceMethod ----- //

  utils.debounceMethod = function (_class, methodName, threshold) {
    // original method
    var method = _class.prototype[methodName];
    var timeoutName = methodName + 'Timeout';

    _class.prototype[methodName] = function () {
      var timeout = this[timeoutName];
      if (timeout) {
        clearTimeout(timeout);
      }
      var args = arguments;

      var _this = this;
      this[timeoutName] = setTimeout(function () {
        method.apply(_this, args);
        delete _this[timeoutName];
      }, threshold || 100);
    };
  };

  // ----- docReady ----- //

  utils.docReady = function (callback) {
    var readyState = document.readyState;
    if (readyState == 'complete' || readyState == 'interactive') {
      callback();
    } else {
      document.addEventListener('DOMContentLoaded', callback);
    }
  };

  // ----- htmlInit ----- //

  // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
  utils.toDashed = function (str) {
    return str.replace(/(.)([A-Z])/g, function (match, $1, $2) {
      return $1 + '-' + $2;
    }).toLowerCase();
  };

  var console = window.console;
  /**
   * allow user to initialize classes via [data-namespace] or .js-namespace class
   * htmlInit( Widget, 'widgetName' )
   * options are parsed from data-namespace-options
   */
  utils.htmlInit = function (WidgetClass, namespace) {
    utils.docReady(function () {
      var dashedNamespace = utils.toDashed(namespace);
      var dataAttr = 'data-' + dashedNamespace;
      var dataAttrElems = document.querySelectorAll('[' + dataAttr + ']');
      var jsDashElems = document.querySelectorAll('.js-' + dashedNamespace);
      var elems = utils.makeArray(dataAttrElems).concat(utils.makeArray(jsDashElems));
      var dataOptionsAttr = dataAttr + '-options';
      var jQuery = window.jQuery;

      elems.forEach(function (elem) {
        var attr = elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);
        var options;
        try {
          options = attr && JSON.parse(attr);
        } catch (error) {
          // log error, do not initialize
          if (console) {
            console.error('Error parsing ' + dataAttr + ' on ' + elem.className + ': ' + error);
          }
          return;
        }
        // initialize
        var instance = new WidgetClass(elem, options);
        // make available via $().data('layoutname')
        if (jQuery) {
          jQuery.data(elem, namespace, instance);
        }
      });
    });
  };

  // -----  ----- //

  return utils;
});

/**
 * Outlayer Item
 */

(function (window, factory) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */
  if (typeof define == 'function' && define.amd) {
    // AMD - RequireJS
    define('outlayer/item', ['ev-emitter/ev-emitter', 'get-size/get-size'], factory);
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS - Browserify, Webpack
    module.exports = factory(require('ev-emitter'), require('get-size'));
  } else {
    // browser global
    window.Outlayer = {};
    window.Outlayer.Item = factory(window.EvEmitter, window.getSize);
  }
})(window, function factory(EvEmitter, getSize) {
  'use strict';

  // ----- helpers ----- //

  function isEmptyObj(obj) {
    for (var prop in obj) {
      return false;
    }
    prop = null;
    return true;
  }

  // -------------------------- CSS3 support -------------------------- //


  var docElemStyle = document.documentElement.style;

  var transitionProperty = typeof docElemStyle.transition == 'string' ? 'transition' : 'WebkitTransition';
  var transformProperty = typeof docElemStyle.transform == 'string' ? 'transform' : 'WebkitTransform';

  var transitionEndEvent = {
    WebkitTransition: 'webkitTransitionEnd',
    transition: 'transitionend'
  }[transitionProperty];

  // cache all vendor properties that could have vendor prefix
  var vendorProperties = {
    transform: transformProperty,
    transition: transitionProperty,
    transitionDuration: transitionProperty + 'Duration',
    transitionProperty: transitionProperty + 'Property',
    transitionDelay: transitionProperty + 'Delay'
  };

  // -------------------------- Item -------------------------- //

  function Item(element, layout) {
    if (!element) {
      return;
    }

    this.element = element;
    // parent layout class, i.e. Masonry, Isotope, or Packery
    this.layout = layout;
    this.position = {
      x: 0,
      y: 0
    };

    this._create();
  }

  // inherit EvEmitter
  var proto = Item.prototype = Object.create(EvEmitter.prototype);
  proto.constructor = Item;

  proto._create = function () {
    // transition objects
    this._transn = {
      ingProperties: {},
      clean: {},
      onEnd: {}
    };

    this.css({
      position: 'absolute'
    });
  };

  // trigger specified handler for event type
  proto.handleEvent = function (event) {
    var method = 'on' + event.type;
    if (this[method]) {
      this[method](event);
    }
  };

  proto.getSize = function () {
    this.size = getSize(this.element);
  };

  /**
   * apply CSS styles to element
   * @param {Object} style
   */
  proto.css = function (style) {
    var elemStyle = this.element.style;

    for (var prop in style) {
      // use vendor property if available
      var supportedProp = vendorProperties[prop] || prop;
      elemStyle[supportedProp] = style[prop];
    }
  };

  // measure position, and sets it
  proto.getPosition = function () {
    var style = getComputedStyle(this.element);
    var isOriginLeft = this.layout._getOption('originLeft');
    var isOriginTop = this.layout._getOption('originTop');
    var xValue = style[isOriginLeft ? 'left' : 'right'];
    var yValue = style[isOriginTop ? 'top' : 'bottom'];
    // convert percent to pixels
    var layoutSize = this.layout.size;
    var x = xValue.indexOf('%') != -1 ? parseFloat(xValue) / 100 * layoutSize.width : parseInt(xValue, 10);
    var y = yValue.indexOf('%') != -1 ? parseFloat(yValue) / 100 * layoutSize.height : parseInt(yValue, 10);

    // clean up 'auto' or other non-integer values
    x = isNaN(x) ? 0 : x;
    y = isNaN(y) ? 0 : y;
    // remove padding from measurement
    x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
    y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;

    this.position.x = x;
    this.position.y = y;
  };

  // set settled position, apply padding
  proto.layoutPosition = function () {
    var layoutSize = this.layout.size;
    var style = {};
    var isOriginLeft = this.layout._getOption('originLeft');
    var isOriginTop = this.layout._getOption('originTop');

    // x
    var xPadding = isOriginLeft ? 'paddingLeft' : 'paddingRight';
    var xProperty = isOriginLeft ? 'left' : 'right';
    var xResetProperty = isOriginLeft ? 'right' : 'left';

    var x = this.position.x + layoutSize[xPadding];
    // set in percentage or pixels
    style[xProperty] = this.getXValue(x);
    // reset other property
    style[xResetProperty] = '';

    // y
    var yPadding = isOriginTop ? 'paddingTop' : 'paddingBottom';
    var yProperty = isOriginTop ? 'top' : 'bottom';
    var yResetProperty = isOriginTop ? 'bottom' : 'top';

    var y = this.position.y + layoutSize[yPadding];
    // set in percentage or pixels
    style[yProperty] = this.getYValue(y);
    // reset other property
    style[yResetProperty] = '';

    this.css(style);
    this.emitEvent('layout', [this]);
  };

  proto.getXValue = function (x) {
    var isHorizontal = this.layout._getOption('horizontal');
    return this.layout.options.percentPosition && !isHorizontal ? x / this.layout.size.width * 100 + '%' : x + 'px';
  };

  proto.getYValue = function (y) {
    var isHorizontal = this.layout._getOption('horizontal');
    return this.layout.options.percentPosition && isHorizontal ? y / this.layout.size.height * 100 + '%' : y + 'px';
  };

  proto._transitionTo = function (x, y) {
    this.getPosition();
    // get current x & y from top/left
    var curX = this.position.x;
    var curY = this.position.y;

    var compareX = parseInt(x, 10);
    var compareY = parseInt(y, 10);
    var didNotMove = compareX === this.position.x && compareY === this.position.y;

    // save end position
    this.setPosition(x, y);

    // if did not move and not transitioning, just go to layout
    if (didNotMove && !this.isTransitioning) {
      this.layoutPosition();
      return;
    }

    var transX = x - curX;
    var transY = y - curY;
    var transitionStyle = {};
    transitionStyle.transform = this.getTranslate(transX, transY);

    this.transition({
      to: transitionStyle,
      onTransitionEnd: {
        transform: this.layoutPosition
      },
      isCleaning: true
    });
  };

  proto.getTranslate = function (x, y) {
    // flip cooridinates if origin on right or bottom
    var isOriginLeft = this.layout._getOption('originLeft');
    var isOriginTop = this.layout._getOption('originTop');
    x = isOriginLeft ? x : -x;
    y = isOriginTop ? y : -y;
    return 'translate3d(' + x + 'px, ' + y + 'px, 0)';
  };

  // non transition + transform support
  proto.goTo = function (x, y) {
    this.setPosition(x, y);
    this.layoutPosition();
  };

  proto.moveTo = proto._transitionTo;

  proto.setPosition = function (x, y) {
    this.position.x = parseInt(x, 10);
    this.position.y = parseInt(y, 10);
  };

  // ----- transition ----- //

  /**
   * @param {Object} style - CSS
   * @param {Function} onTransitionEnd
   */

  // non transition, just trigger callback
  proto._nonTransition = function (args) {
    this.css(args.to);
    if (args.isCleaning) {
      this._removeStyles(args.to);
    }
    for (var prop in args.onTransitionEnd) {
      args.onTransitionEnd[prop].call(this);
    }
  };

  /**
   * proper transition
   * @param {Object} args - arguments
   *   @param {Object} to - style to transition to
   *   @param {Object} from - style to start transition from
   *   @param {Boolean} isCleaning - removes transition styles after transition
   *   @param {Function} onTransitionEnd - callback
   */
  proto.transition = function (args) {
    // redirect to nonTransition if no transition duration
    if (!parseFloat(this.layout.options.transitionDuration)) {
      this._nonTransition(args);
      return;
    }

    var _transition = this._transn;
    // keep track of onTransitionEnd callback by css property
    for (var prop in args.onTransitionEnd) {
      _transition.onEnd[prop] = args.onTransitionEnd[prop];
    }
    // keep track of properties that are transitioning
    for (prop in args.to) {
      _transition.ingProperties[prop] = true;
      // keep track of properties to clean up when transition is done
      if (args.isCleaning) {
        _transition.clean[prop] = true;
      }
    }

    // set from styles
    if (args.from) {
      this.css(args.from);
      // force redraw. http://blog.alexmaccaw.com/css-transitions
      var h = this.element.offsetHeight;
      // hack for JSHint to hush about unused var
      h = null;
    }
    // enable transition
    this.enableTransition(args.to);
    // set styles that are transitioning
    this.css(args.to);

    this.isTransitioning = true;
  };

  // dash before all cap letters, including first for
  // WebkitTransform => -webkit-transform
  function toDashedAll(str) {
    return str.replace(/([A-Z])/g, function ($1) {
      return '-' + $1.toLowerCase();
    });
  }

  var transitionProps = 'opacity,' + toDashedAll(transformProperty);

  proto.enableTransition = function () /* style */{
    // HACK changing transitionProperty during a transition
    // will cause transition to jump
    if (this.isTransitioning) {
      return;
    }

    // make `transition: foo, bar, baz` from style object
    // HACK un-comment this when enableTransition can work
    // while a transition is happening
    // var transitionValues = [];
    // for ( var prop in style ) {
    //   // dash-ify camelCased properties like WebkitTransition
    //   prop = vendorProperties[ prop ] || prop;
    //   transitionValues.push( toDashedAll( prop ) );
    // }
    // munge number to millisecond, to match stagger
    var duration = this.layout.options.transitionDuration;
    duration = typeof duration == 'number' ? duration + 'ms' : duration;
    // enable transition styles
    this.css({
      transitionProperty: transitionProps,
      transitionDuration: duration,
      transitionDelay: this.staggerDelay || 0
    });
    // listen for transition end event
    this.element.addEventListener(transitionEndEvent, this, false);
  };

  // ----- events ----- //

  proto.onwebkitTransitionEnd = function (event) {
    this.ontransitionend(event);
  };

  proto.onotransitionend = function (event) {
    this.ontransitionend(event);
  };

  // properties that I munge to make my life easier
  var dashedVendorProperties = {
    '-webkit-transform': 'transform'
  };

  proto.ontransitionend = function (event) {
    // disregard bubbled events from children
    if (event.target !== this.element) {
      return;
    }
    var _transition = this._transn;
    // get property name of transitioned property, convert to prefix-free
    var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;

    // remove property that has completed transitioning
    delete _transition.ingProperties[propertyName];
    // check if any properties are still transitioning
    if (isEmptyObj(_transition.ingProperties)) {
      // all properties have completed transitioning
      this.disableTransition();
    }
    // clean style
    if (propertyName in _transition.clean) {
      // clean up style
      this.element.style[event.propertyName] = '';
      delete _transition.clean[propertyName];
    }
    // trigger onTransitionEnd callback
    if (propertyName in _transition.onEnd) {
      var onTransitionEnd = _transition.onEnd[propertyName];
      onTransitionEnd.call(this);
      delete _transition.onEnd[propertyName];
    }

    this.emitEvent('transitionEnd', [this]);
  };

  proto.disableTransition = function () {
    this.removeTransitionStyles();
    this.element.removeEventListener(transitionEndEvent, this, false);
    this.isTransitioning = false;
  };

  /**
   * removes style property from element
   * @param {Object} style
  **/
  proto._removeStyles = function (style) {
    // clean up transition styles
    var cleanStyle = {};
    for (var prop in style) {
      cleanStyle[prop] = '';
    }
    this.css(cleanStyle);
  };

  var cleanTransitionStyle = {
    transitionProperty: '',
    transitionDuration: '',
    transitionDelay: ''
  };

  proto.removeTransitionStyles = function () {
    // remove transition
    this.css(cleanTransitionStyle);
  };

  // ----- stagger ----- //

  proto.stagger = function (delay) {
    delay = isNaN(delay) ? 0 : delay;
    this.staggerDelay = delay + 'ms';
  };

  // ----- show/hide/remove ----- //

  // remove element from DOM
  proto.removeElem = function () {
    this.element.parentNode.removeChild(this.element);
    // remove display: none
    this.css({ display: '' });
    this.emitEvent('remove', [this]);
  };

  proto.remove = function () {
    // just remove element if no transition support or no transition
    if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {
      this.removeElem();
      return;
    }

    // start transition
    this.once('transitionEnd', function () {
      this.removeElem();
    });
    this.hide();
  };

  proto.reveal = function () {
    delete this.isHidden;
    // remove display: none
    this.css({ display: '' });

    var options = this.layout.options;

    var onTransitionEnd = {};
    var transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');
    onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;

    this.transition({
      from: options.hiddenStyle,
      to: options.visibleStyle,
      isCleaning: true,
      onTransitionEnd: onTransitionEnd
    });
  };

  proto.onRevealTransitionEnd = function () {
    // check if still visible
    // during transition, item may have been hidden
    if (!this.isHidden) {
      this.emitEvent('reveal');
    }
  };

  /**
   * get style property use for hide/reveal transition end
   * @param {String} styleProperty - hiddenStyle/visibleStyle
   * @returns {String}
   */
  proto.getHideRevealTransitionEndProperty = function (styleProperty) {
    var optionStyle = this.layout.options[styleProperty];
    // use opacity
    if (optionStyle.opacity) {
      return 'opacity';
    }
    // get first property
    for (var prop in optionStyle) {
      return prop;
    }
  };

  proto.hide = function () {
    // set flag
    this.isHidden = true;
    // remove display: none
    this.css({ display: '' });

    var options = this.layout.options;

    var onTransitionEnd = {};
    var transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');
    onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;

    this.transition({
      from: options.visibleStyle,
      to: options.hiddenStyle,
      // keep hidden stuff hidden
      isCleaning: true,
      onTransitionEnd: onTransitionEnd
    });
  };

  proto.onHideTransitionEnd = function () {
    // check if still hidden
    // during transition, item may have been un-hidden
    if (this.isHidden) {
      this.css({ display: 'none' });
      this.emitEvent('hide');
    }
  };

  proto.destroy = function () {
    this.css({
      position: '',
      left: '',
      right: '',
      top: '',
      bottom: '',
      transition: '',
      transform: ''
    });
  };

  return Item;
});

/*!
 * Outlayer v2.1.0
 * the brains and guts of a layout library
 * MIT license
 */

(function (window, factory) {
  'use strict';
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */

  if (typeof define == 'function' && define.amd) {
    // AMD - RequireJS
    define('outlayer/outlayer', ['ev-emitter/ev-emitter', 'get-size/get-size', 'fizzy-ui-utils/utils', './item'], function (EvEmitter, getSize, utils, Item) {
      return factory(window, EvEmitter, getSize, utils, Item);
    });
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS - Browserify, Webpack
    module.exports = factory(window, require('ev-emitter'), require('get-size'), require('fizzy-ui-utils'), require('./item'));
  } else {
    // browser global
    window.Outlayer = factory(window, window.EvEmitter, window.getSize, window.fizzyUIUtils, window.Outlayer.Item);
  }
})(window, function factory(window, EvEmitter, getSize, utils, Item) {
  'use strict';

  // ----- vars ----- //

  var console = window.console;
  var jQuery = window.jQuery;
  var noop = function () {};

  // -------------------------- Outlayer -------------------------- //

  // globally unique identifiers
  var GUID = 0;
  // internal store of all Outlayer intances
  var instances = {};

  /**
   * @param {Element, String} element
   * @param {Object} options
   * @constructor
   */
  function Outlayer(element, options) {
    var queryElement = utils.getQueryElement(element);
    if (!queryElement) {
      if (console) {
        console.error('Bad element for ' + this.constructor.namespace + ': ' + (queryElement || element));
      }
      return;
    }
    this.element = queryElement;
    // add jQuery
    if (jQuery) {
      this.$element = jQuery(this.element);
    }

    // options
    this.options = utils.extend({}, this.constructor.defaults);
    this.option(options);

    // add id for Outlayer.getFromElement
    var id = ++GUID;
    this.element.outlayerGUID = id; // expando
    instances[id] = this; // associate via id

    // kick it off
    this._create();

    var isInitLayout = this._getOption('initLayout');
    if (isInitLayout) {
      this.layout();
    }
  }

  // settings are for internal use only
  Outlayer.namespace = 'outlayer';
  Outlayer.Item = Item;

  // default options
  Outlayer.defaults = {
    containerStyle: {
      position: 'relative'
    },
    initLayout: true,
    originLeft: true,
    originTop: true,
    resize: true,
    resizeContainer: true,
    // item options
    transitionDuration: '0.4s',
    hiddenStyle: {
      opacity: 0,
      transform: 'scale(0.001)'
    },
    visibleStyle: {
      opacity: 1,
      transform: 'scale(1)'
    }
  };

  var proto = Outlayer.prototype;
  // inherit EvEmitter
  utils.extend(proto, EvEmitter.prototype);

  /**
   * set options
   * @param {Object} opts
   */
  proto.option = function (opts) {
    utils.extend(this.options, opts);
  };

  /**
   * get backwards compatible option value, check old name
   */
  proto._getOption = function (option) {
    var oldOption = this.constructor.compatOptions[option];
    return oldOption && this.options[oldOption] !== undefined ? this.options[oldOption] : this.options[option];
  };

  Outlayer.compatOptions = {
    // currentName: oldName
    initLayout: 'isInitLayout',
    horizontal: 'isHorizontal',
    layoutInstant: 'isLayoutInstant',
    originLeft: 'isOriginLeft',
    originTop: 'isOriginTop',
    resize: 'isResizeBound',
    resizeContainer: 'isResizingContainer'
  };

  proto._create = function () {
    // get items from children
    this.reloadItems();
    // elements that affect layout, but are not laid out
    this.stamps = [];
    this.stamp(this.options.stamp);
    // set container style
    utils.extend(this.element.style, this.options.containerStyle);

    // bind resize method
    var canBindResize = this._getOption('resize');
    if (canBindResize) {
      this.bindResize();
    }
  };

  // goes through all children again and gets bricks in proper order
  proto.reloadItems = function () {
    // collection of item elements
    this.items = this._itemize(this.element.children);
  };

  /**
   * turn elements into Outlayer.Items to be used in layout
   * @param {Array or NodeList or HTMLElement} elems
   * @returns {Array} items - collection of new Outlayer Items
   */
  proto._itemize = function (elems) {

    var itemElems = this._filterFindItemElements(elems);
    var Item = this.constructor.Item;

    // create new Outlayer Items for collection
    var items = [];
    for (var i = 0; i < itemElems.length; i++) {
      var elem = itemElems[i];
      var item = new Item(elem, this);
      items.push(item);
    }

    return items;
  };

  /**
   * get item elements to be used in layout
   * @param {Array or NodeList or HTMLElement} elems
   * @returns {Array} items - item elements
   */
  proto._filterFindItemElements = function (elems) {
    return utils.filterFindElements(elems, this.options.itemSelector);
  };

  /**
   * getter method for getting item elements
   * @returns {Array} elems - collection of item elements
   */
  proto.getItemElements = function () {
    return this.items.map(function (item) {
      return item.element;
    });
  };

  // ----- init & layout ----- //

  /**
   * lays out all items
   */
  proto.layout = function () {
    this._resetLayout();
    this._manageStamps();

    // don't animate first layout
    var layoutInstant = this._getOption('layoutInstant');
    var isInstant = layoutInstant !== undefined ? layoutInstant : !this._isLayoutInited;
    this.layoutItems(this.items, isInstant);

    // flag for initalized
    this._isLayoutInited = true;
  };

  // _init is alias for layout
  proto._init = proto.layout;

  /**
   * logic before any new layout
   */
  proto._resetLayout = function () {
    this.getSize();
  };

  proto.getSize = function () {
    this.size = getSize(this.element);
  };

  /**
   * get measurement from option, for columnWidth, rowHeight, gutter
   * if option is String -> get element from selector string, & get size of element
   * if option is Element -> get size of element
   * else use option as a number
   *
   * @param {String} measurement
   * @param {String} size - width or height
   * @private
   */
  proto._getMeasurement = function (measurement, size) {
    var option = this.options[measurement];
    var elem;
    if (!option) {
      // default to 0
      this[measurement] = 0;
    } else {
      // use option as an element
      if (typeof option == 'string') {
        elem = this.element.querySelector(option);
      } else if (option instanceof HTMLElement) {
        elem = option;
      }
      // use size of element, if element
      this[measurement] = elem ? getSize(elem)[size] : option;
    }
  };

  /**
   * layout a collection of item elements
   * @api public
   */
  proto.layoutItems = function (items, isInstant) {
    items = this._getItemsForLayout(items);

    this._layoutItems(items, isInstant);

    this._postLayout();
  };

  /**
   * get the items to be laid out
   * you may want to skip over some items
   * @param {Array} items
   * @returns {Array} items
   */
  proto._getItemsForLayout = function (items) {
    return items.filter(function (item) {
      return !item.isIgnored;
    });
  };

  /**
   * layout items
   * @param {Array} items
   * @param {Boolean} isInstant
   */
  proto._layoutItems = function (items, isInstant) {
    this._emitCompleteOnItems('layout', items);

    if (!items || !items.length) {
      // no items, emit event with empty array
      return;
    }

    var queue = [];

    items.forEach(function (item) {
      // get x/y object from method
      var position = this._getItemLayoutPosition(item);
      // enqueue
      position.item = item;
      position.isInstant = isInstant || item.isLayoutInstant;
      queue.push(position);
    }, this);

    this._processLayoutQueue(queue);
  };

  /**
   * get item layout position
   * @param {Outlayer.Item} item
   * @returns {Object} x and y position
   */
  proto._getItemLayoutPosition = function () /* item */{
    return {
      x: 0,
      y: 0
    };
  };

  /**
   * iterate over array and position each item
   * Reason being - separating this logic prevents 'layout invalidation'
   * thx @paul_irish
   * @param {Array} queue
   */
  proto._processLayoutQueue = function (queue) {
    this.updateStagger();
    queue.forEach(function (obj, i) {
      this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);
    }, this);
  };

  // set stagger from option in milliseconds number
  proto.updateStagger = function () {
    var stagger = this.options.stagger;
    if (stagger === null || stagger === undefined) {
      this.stagger = 0;
      return;
    }
    this.stagger = getMilliseconds(stagger);
    return this.stagger;
  };

  /**
   * Sets position of item in DOM
   * @param {Outlayer.Item} item
   * @param {Number} x - horizontal position
   * @param {Number} y - vertical position
   * @param {Boolean} isInstant - disables transitions
   */
  proto._positionItem = function (item, x, y, isInstant, i) {
    if (isInstant) {
      // if not transition, just set CSS
      item.goTo(x, y);
    } else {
      item.stagger(i * this.stagger);
      item.moveTo(x, y);
    }
  };

  /**
   * Any logic you want to do after each layout,
   * i.e. size the container
   */
  proto._postLayout = function () {
    this.resizeContainer();
  };

  proto.resizeContainer = function () {
    var isResizingContainer = this._getOption('resizeContainer');
    if (!isResizingContainer) {
      return;
    }
    var size = this._getContainerSize();
    if (size) {
      this._setContainerMeasure(size.width, true);
      this._setContainerMeasure(size.height, false);
    }
  };

  /**
   * Sets width or height of container if returned
   * @returns {Object} size
   *   @param {Number} width
   *   @param {Number} height
   */
  proto._getContainerSize = noop;

  /**
   * @param {Number} measure - size of width or height
   * @param {Boolean} isWidth
   */
  proto._setContainerMeasure = function (measure, isWidth) {
    if (measure === undefined) {
      return;
    }

    var elemSize = this.size;
    // add padding and border width if border box
    if (elemSize.isBorderBox) {
      measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth;
    }

    measure = Math.max(measure, 0);
    this.element.style[isWidth ? 'width' : 'height'] = measure + 'px';
  };

  /**
   * emit eventComplete on a collection of items events
   * @param {String} eventName
   * @param {Array} items - Outlayer.Items
   */
  proto._emitCompleteOnItems = function (eventName, items) {
    var _this = this;
    function onComplete() {
      _this.dispatchEvent(eventName + 'Complete', null, [items]);
    }

    var count = items.length;
    if (!items || !count) {
      onComplete();
      return;
    }

    var doneCount = 0;
    function tick() {
      doneCount++;
      if (doneCount == count) {
        onComplete();
      }
    }

    // bind callback
    items.forEach(function (item) {
      item.once(eventName, tick);
    });
  };

  /**
   * emits events via EvEmitter and jQuery events
   * @param {String} type - name of event
   * @param {Event} event - original event
   * @param {Array} args - extra arguments
   */
  proto.dispatchEvent = function (type, event, args) {
    // add original event to arguments
    var emitArgs = event ? [event].concat(args) : args;
    this.emitEvent(type, emitArgs);

    if (jQuery) {
      // set this.$element
      this.$element = this.$element || jQuery(this.element);
      if (event) {
        // create jQuery event
        var $event = jQuery.Event(event);
        $event.type = type;
        this.$element.trigger($event, args);
      } else {
        // just trigger with type if no event available
        this.$element.trigger(type, args);
      }
    }
  };

  // -------------------------- ignore & stamps -------------------------- //


  /**
   * keep item in collection, but do not lay it out
   * ignored items do not get skipped in layout
   * @param {Element} elem
   */
  proto.ignore = function (elem) {
    var item = this.getItem(elem);
    if (item) {
      item.isIgnored = true;
    }
  };

  /**
   * return item to layout collection
   * @param {Element} elem
   */
  proto.unignore = function (elem) {
    var item = this.getItem(elem);
    if (item) {
      delete item.isIgnored;
    }
  };

  /**
   * adds elements to stamps
   * @param {NodeList, Array, Element, or String} elems
   */
  proto.stamp = function (elems) {
    elems = this._find(elems);
    if (!elems) {
      return;
    }

    this.stamps = this.stamps.concat(elems);
    // ignore
    elems.forEach(this.ignore, this);
  };

  /**
   * removes elements to stamps
   * @param {NodeList, Array, or Element} elems
   */
  proto.unstamp = function (elems) {
    elems = this._find(elems);
    if (!elems) {
      return;
    }

    elems.forEach(function (elem) {
      // filter out removed stamp elements
      utils.removeFrom(this.stamps, elem);
      this.unignore(elem);
    }, this);
  };

  /**
   * finds child elements
   * @param {NodeList, Array, Element, or String} elems
   * @returns {Array} elems
   */
  proto._find = function (elems) {
    if (!elems) {
      return;
    }
    // if string, use argument as selector string
    if (typeof elems == 'string') {
      elems = this.element.querySelectorAll(elems);
    }
    elems = utils.makeArray(elems);
    return elems;
  };

  proto._manageStamps = function () {
    if (!this.stamps || !this.stamps.length) {
      return;
    }

    this._getBoundingRect();

    this.stamps.forEach(this._manageStamp, this);
  };

  // update boundingLeft / Top
  proto._getBoundingRect = function () {
    // get bounding rect for container element
    var boundingRect = this.element.getBoundingClientRect();
    var size = this.size;
    this._boundingRect = {
      left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
      top: boundingRect.top + size.paddingTop + size.borderTopWidth,
      right: boundingRect.right - (size.paddingRight + size.borderRightWidth),
      bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)
    };
  };

  /**
   * @param {Element} stamp
  **/
  proto._manageStamp = noop;

  /**
   * get x/y position of element relative to container element
   * @param {Element} elem
   * @returns {Object} offset - has left, top, right, bottom
   */
  proto._getElementOffset = function (elem) {
    var boundingRect = elem.getBoundingClientRect();
    var thisRect = this._boundingRect;
    var size = getSize(elem);
    var offset = {
      left: boundingRect.left - thisRect.left - size.marginLeft,
      top: boundingRect.top - thisRect.top - size.marginTop,
      right: thisRect.right - boundingRect.right - size.marginRight,
      bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
    };
    return offset;
  };

  // -------------------------- resize -------------------------- //

  // enable event handlers for listeners
  // i.e. resize -> onresize
  proto.handleEvent = utils.handleEvent;

  /**
   * Bind layout to window resizing
   */
  proto.bindResize = function () {
    window.addEventListener('resize', this);
    this.isResizeBound = true;
  };

  /**
   * Unbind layout to window resizing
   */
  proto.unbindResize = function () {
    window.removeEventListener('resize', this);
    this.isResizeBound = false;
  };

  proto.onresize = function () {
    this.resize();
  };

  utils.debounceMethod(Outlayer, 'onresize', 100);

  proto.resize = function () {
    // don't trigger if size did not change
    // or if resize was unbound. See #9
    if (!this.isResizeBound || !this.needsResizeLayout()) {
      return;
    }

    this.layout();
  };

  /**
   * check if layout is needed post layout
   * @returns Boolean
   */
  proto.needsResizeLayout = function () {
    var size = getSize(this.element);
    // check that this.size and size are there
    // IE8 triggers resize on body size change, so they might not be
    var hasSizes = this.size && size;
    return hasSizes && size.innerWidth !== this.size.innerWidth;
  };

  // -------------------------- methods -------------------------- //

  /**
   * add items to Outlayer instance
   * @param {Array or NodeList or Element} elems
   * @returns {Array} items - Outlayer.Items
  **/
  proto.addItems = function (elems) {
    var items = this._itemize(elems);
    // add items to collection
    if (items.length) {
      this.items = this.items.concat(items);
    }
    return items;
  };

  /**
   * Layout newly-appended item elements
   * @param {Array or NodeList or Element} elems
   */
  proto.appended = function (elems) {
    var items = this.addItems(elems);
    if (!items.length) {
      return;
    }
    // layout and reveal just the new items
    this.layoutItems(items, true);
    this.reveal(items);
  };

  /**
   * Layout prepended elements
   * @param {Array or NodeList or Element} elems
   */
  proto.prepended = function (elems) {
    var items = this._itemize(elems);
    if (!items.length) {
      return;
    }
    // add items to beginning of collection
    var previousItems = this.items.slice(0);
    this.items = items.concat(previousItems);
    // start new layout
    this._resetLayout();
    this._manageStamps();
    // layout new stuff without transition
    this.layoutItems(items, true);
    this.reveal(items);
    // layout previous items
    this.layoutItems(previousItems);
  };

  /**
   * reveal a collection of items
   * @param {Array of Outlayer.Items} items
   */
  proto.reveal = function (items) {
    this._emitCompleteOnItems('reveal', items);
    if (!items || !items.length) {
      return;
    }
    var stagger = this.updateStagger();
    items.forEach(function (item, i) {
      item.stagger(i * stagger);
      item.reveal();
    });
  };

  /**
   * hide a collection of items
   * @param {Array of Outlayer.Items} items
   */
  proto.hide = function (items) {
    this._emitCompleteOnItems('hide', items);
    if (!items || !items.length) {
      return;
    }
    var stagger = this.updateStagger();
    items.forEach(function (item, i) {
      item.stagger(i * stagger);
      item.hide();
    });
  };

  /**
   * reveal item elements
   * @param {Array}, {Element}, {NodeList} items
   */
  proto.revealItemElements = function (elems) {
    var items = this.getItems(elems);
    this.reveal(items);
  };

  /**
   * hide item elements
   * @param {Array}, {Element}, {NodeList} items
   */
  proto.hideItemElements = function (elems) {
    var items = this.getItems(elems);
    this.hide(items);
  };

  /**
   * get Outlayer.Item, given an Element
   * @param {Element} elem
   * @param {Function} callback
   * @returns {Outlayer.Item} item
   */
  proto.getItem = function (elem) {
    // loop through items to get the one that matches
    for (var i = 0; i < this.items.length; i++) {
      var item = this.items[i];
      if (item.element == elem) {
        // return item
        return item;
      }
    }
  };

  /**
   * get collection of Outlayer.Items, given Elements
   * @param {Array} elems
   * @returns {Array} items - Outlayer.Items
   */
  proto.getItems = function (elems) {
    elems = utils.makeArray(elems);
    var items = [];
    elems.forEach(function (elem) {
      var item = this.getItem(elem);
      if (item) {
        items.push(item);
      }
    }, this);

    return items;
  };

  /**
   * remove element(s) from instance and DOM
   * @param {Array or NodeList or Element} elems
   */
  proto.remove = function (elems) {
    var removeItems = this.getItems(elems);

    this._emitCompleteOnItems('remove', removeItems);

    // bail if no items to remove
    if (!removeItems || !removeItems.length) {
      return;
    }

    removeItems.forEach(function (item) {
      item.remove();
      // remove item from collection
      utils.removeFrom(this.items, item);
    }, this);
  };

  // ----- destroy ----- //

  // remove and disable Outlayer instance
  proto.destroy = function () {
    // clean up dynamic styles
    var style = this.element.style;
    style.height = '';
    style.position = '';
    style.width = '';
    // destroy items
    this.items.forEach(function (item) {
      item.destroy();
    });

    this.unbindResize();

    var id = this.element.outlayerGUID;
    delete instances[id]; // remove reference to instance by id
    delete this.element.outlayerGUID;
    // remove data for jQuery
    if (jQuery) {
      jQuery.removeData(this.element, this.constructor.namespace);
    }
  };

  // -------------------------- data -------------------------- //

  /**
   * get Outlayer instance from element
   * @param {Element} elem
   * @returns {Outlayer}
   */
  Outlayer.data = function (elem) {
    elem = utils.getQueryElement(elem);
    var id = elem && elem.outlayerGUID;
    return id && instances[id];
  };

  // -------------------------- create Outlayer class -------------------------- //

  /**
   * create a layout class
   * @param {String} namespace
   */
  Outlayer.create = function (namespace, options) {
    // sub-class Outlayer
    var Layout = subclass(Outlayer);
    // apply new options and compatOptions
    Layout.defaults = utils.extend({}, Outlayer.defaults);
    utils.extend(Layout.defaults, options);
    Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);

    Layout.namespace = namespace;

    Layout.data = Outlayer.data;

    // sub-class Item
    Layout.Item = subclass(Item);

    // -------------------------- declarative -------------------------- //

    utils.htmlInit(Layout, namespace);

    // -------------------------- jQuery bridge -------------------------- //

    // make into jQuery plugin
    if (jQuery && jQuery.bridget) {
      jQuery.bridget(namespace, Layout);
    }

    return Layout;
  };

  function subclass(Parent) {
    function SubClass() {
      Parent.apply(this, arguments);
    }

    SubClass.prototype = Object.create(Parent.prototype);
    SubClass.prototype.constructor = SubClass;

    return SubClass;
  }

  // ----- helpers ----- //

  // how many milliseconds are in each unit
  var msUnits = {
    ms: 1,
    s: 1000
  };

  // munge time-like parameter into millisecond number
  // '0.4s' -> 40
  function getMilliseconds(time) {
    if (typeof time == 'number') {
      return time;
    }
    var matches = time.match(/(^\d*\.?\d*)(\w*)/);
    var num = matches && matches[1];
    var unit = matches && matches[2];
    if (!num.length) {
      return 0;
    }
    num = parseFloat(num);
    var mult = msUnits[unit] || 1;
    return num * mult;
  }

  // ----- fin ----- //

  // back in global
  Outlayer.Item = Item;

  return Outlayer;
});

/*!
 * Masonry v4.1.1
 * Cascading grid layout library
 * http://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */

(function (window, factory) {
  // universal module definition
  /* jshint strict: false */ /*globals define, module, require */
  if (typeof define == 'function' && define.amd) {
    // AMD
    define(['outlayer/outlayer', 'get-size/get-size'], factory);
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(require('outlayer'), require('get-size'));
  } else {
    // browser global
    window.Masonry = factory(window.Outlayer, window.getSize);
  }
})(window, function factory(Outlayer, getSize) {

  // -------------------------- masonryDefinition -------------------------- //

  // create an Outlayer layout class
  var Masonry = Outlayer.create('masonry');
  // isFitWidth -> fitWidth
  Masonry.compatOptions.fitWidth = 'isFitWidth';

  Masonry.prototype._resetLayout = function () {
    this.getSize();
    this._getMeasurement('columnWidth', 'outerWidth');
    this._getMeasurement('gutter', 'outerWidth');
    this.measureColumns();

    // reset column Y
    this.colYs = [];
    for (var i = 0; i < this.cols; i++) {
      this.colYs.push(0);
    }

    this.maxY = 0;
  };

  Masonry.prototype.measureColumns = function () {
    this.getContainerWidth();
    // if columnWidth is 0, default to outerWidth of first item
    if (!this.columnWidth) {
      var firstItem = this.items[0];
      var firstItemElem = firstItem && firstItem.element;
      // columnWidth fall back to item of first element
      this.columnWidth = firstItemElem && getSize(firstItemElem).outerWidth ||
      // if first elem has no width, default to size of container
      this.containerWidth;
    }

    var columnWidth = this.columnWidth += this.gutter;

    // calculate columns
    var containerWidth = this.containerWidth + this.gutter;
    var cols = containerWidth / columnWidth;
    // fix rounding errors, typically with gutters
    var excess = columnWidth - containerWidth % columnWidth;
    // if overshoot is less than a pixel, round up, otherwise floor it
    var mathMethod = excess && excess < 1 ? 'round' : 'floor';
    cols = Math[mathMethod](cols);
    this.cols = Math.max(cols, 1);
  };

  Masonry.prototype.getContainerWidth = function () {
    // container is parent if fit width
    var isFitWidth = this._getOption('fitWidth');
    var container = isFitWidth ? this.element.parentNode : this.element;
    // check that this.size and size are there
    // IE8 triggers resize on body size change, so they might not be
    var size = getSize(container);
    this.containerWidth = size && size.innerWidth;
  };

  Masonry.prototype._getItemLayoutPosition = function (item) {
    item.getSize();
    // how many columns does this brick span
    var remainder = item.size.outerWidth % this.columnWidth;
    var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';
    // round if off by 1 pixel, otherwise use ceil
    var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);
    colSpan = Math.min(colSpan, this.cols);

    var colGroup = this._getColGroup(colSpan);
    // get the minimum Y value from the columns
    var minimumY = Math.min.apply(Math, colGroup);
    var shortColIndex = colGroup.indexOf(minimumY);

    // position the brick
    var position = {
      x: this.columnWidth * shortColIndex,
      y: minimumY
    };

    // apply setHeight to necessary columns
    var setHeight = minimumY + item.size.outerHeight;
    var setSpan = this.cols + 1 - colGroup.length;
    for (var i = 0; i < setSpan; i++) {
      this.colYs[shortColIndex + i] = setHeight;
    }

    return position;
  };

  /**
   * @param {Number} colSpan - number of columns the element spans
   * @returns {Array} colGroup
   */
  Masonry.prototype._getColGroup = function (colSpan) {
    if (colSpan < 2) {
      // if brick spans only one column, use all the column Ys
      return this.colYs;
    }

    var colGroup = [];
    // how many different places could this brick fit horizontally
    var groupCount = this.cols + 1 - colSpan;
    // for each group potential horizontal position
    for (var i = 0; i < groupCount; i++) {
      // make an array of colY values for that one group
      var groupColYs = this.colYs.slice(i, i + colSpan);
      // and get the max value of the array
      colGroup[i] = Math.max.apply(Math, groupColYs);
    }
    return colGroup;
  };

  Masonry.prototype._manageStamp = function (stamp) {
    var stampSize = getSize(stamp);
    var offset = this._getElementOffset(stamp);
    // get the columns that this stamp affects
    var isOriginLeft = this._getOption('originLeft');
    var firstX = isOriginLeft ? offset.left : offset.right;
    var lastX = firstX + stampSize.outerWidth;
    var firstCol = Math.floor(firstX / this.columnWidth);
    firstCol = Math.max(0, firstCol);
    var lastCol = Math.floor(lastX / this.columnWidth);
    // lastCol should not go over if multiple of columnWidth #425
    lastCol -= lastX % this.columnWidth ? 0 : 1;
    lastCol = Math.min(this.cols - 1, lastCol);
    // set colYs to bottom of the stamp

    var isOriginTop = this._getOption('originTop');
    var stampMaxY = (isOriginTop ? offset.top : offset.bottom) + stampSize.outerHeight;
    for (var i = firstCol; i <= lastCol; i++) {
      this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);
    }
  };

  Masonry.prototype._getContainerSize = function () {
    this.maxY = Math.max.apply(Math, this.colYs);
    var size = {
      height: this.maxY
    };

    if (this._getOption('fitWidth')) {
      size.width = this._getContainerFitWidth();
    }

    return size;
  };

  Masonry.prototype._getContainerFitWidth = function () {
    var unusedCols = 0;
    // count unused columns
    var i = this.cols;
    while (--i) {
      if (this.colYs[i] !== 0) {
        break;
      }
      unusedCols++;
    }
    // fit container to columns that have been used
    return (this.cols - unusedCols) * this.columnWidth - this.gutter;
  };

  Masonry.prototype.needsResizeLayout = function () {
    var previousWidth = this.containerWidth;
    this.getContainerWidth();
    return previousWidth != this.containerWidth;
  };

  return Masonry;
});
'use strict';

// $(document).foundation();

$(document).ready(function () {
	Site.init();
});

var Site = {
	init: function () {
		if ($(window).width() > 640) {
			Site.scrollmagic();
		}
		Site.grid();
	},
	scrollmagic: function () {
		// init controller
		var controller = new ScrollMagic.Controller();
		var images = $('.parallax');
		var windowHeight = $(window).height();

		$.each(images, function (index, image) {
			// var tween = new TweenMax.fromTo(image, 1, { transform: 'translateY(12em)' }, { transform: 'translateY(-8em)' })
			var tween = new TweenMax.fromTo(image, 1, { transform: 'translateY(-4em)' }, { transform: 'translateY(12em)' });

			var scene = new ScrollMagic.Scene({
				duration: windowHeight * 2,
				triggerElement: image,
				triggerHook: 1
			}).setTween(tween).addTo(controller);
		});
	}
};
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5qcyIsIlR3ZWVuTWF4LmpzIiwiU2Nyb2xsTWFnaWMuanMiLCJhbmltYXRpb24uZ3NhcC5qcyIsImpxdWVyeS5sYXp5bG9hZHh0LmpzIiwianF1ZXJ5Lmxhenlsb2FkeHQuYXV0b2xvYWQuanMiLCJqcXVlcnkubGF6eWxvYWR4dC5iZy5qcyIsImZvdW5kYXRpb24uY29yZS5qcyIsImZvdW5kYXRpb24udXRpbC5ib3guanMiLCJmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanMiLCJmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qcyIsImZvdW5kYXRpb24udXRpbC5tb3Rpb24uanMiLCJmb3VuZGF0aW9uLnV0aWwubmVzdC5qcyIsImZvdW5kYXRpb24udXRpbC50aW1lckFuZEltYWdlTG9hZGVyLmpzIiwiZm91bmRhdGlvbi51dGlsLnRvdWNoLmpzIiwiZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzIiwibWFzb25yeS5wa2dkLmpzIiwiYXBwLmpzIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiZG9jdW1lbnQiLCJ3IiwiRXJyb3IiLCJ3aW5kb3ciLCJub0dsb2JhbCIsImFyciIsInNsaWNlIiwiY29uY2F0IiwicHVzaCIsImluZGV4T2YiLCJjbGFzczJ0eXBlIiwidG9TdHJpbmciLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsInN1cHBvcnQiLCJ2ZXJzaW9uIiwialF1ZXJ5Iiwic2VsZWN0b3IiLCJjb250ZXh0IiwiZm4iLCJpbml0IiwicnRyaW0iLCJybXNQcmVmaXgiLCJyZGFzaEFscGhhIiwiZmNhbWVsQ2FzZSIsImFsbCIsImxldHRlciIsInRvVXBwZXJDYXNlIiwicHJvdG90eXBlIiwianF1ZXJ5IiwiY29uc3RydWN0b3IiLCJsZW5ndGgiLCJ0b0FycmF5IiwiY2FsbCIsImdldCIsIm51bSIsInB1c2hTdGFjayIsImVsZW1zIiwicmV0IiwibWVyZ2UiLCJwcmV2T2JqZWN0IiwiZWFjaCIsImNhbGxiYWNrIiwibWFwIiwiZWxlbSIsImkiLCJhcHBseSIsImFyZ3VtZW50cyIsImZpcnN0IiwiZXEiLCJsYXN0IiwibGVuIiwiaiIsImVuZCIsInNvcnQiLCJzcGxpY2UiLCJleHRlbmQiLCJvcHRpb25zIiwibmFtZSIsInNyYyIsImNvcHkiLCJjb3B5SXNBcnJheSIsImNsb25lIiwidGFyZ2V0IiwiZGVlcCIsImlzRnVuY3Rpb24iLCJpc1BsYWluT2JqZWN0IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImV4cGFuZG8iLCJNYXRoIiwicmFuZG9tIiwicmVwbGFjZSIsImlzUmVhZHkiLCJlcnJvciIsIm1zZyIsIm5vb3AiLCJvYmoiLCJ0eXBlIiwiQXJyYXkiLCJpc1dpbmRvdyIsImlzTnVtZXJpYyIsInJlYWxTdHJpbmdPYmoiLCJwYXJzZUZsb2F0Iiwia2V5Iiwibm9kZVR5cGUiLCJpc0VtcHR5T2JqZWN0IiwiZ2xvYmFsRXZhbCIsImNvZGUiLCJzY3JpcHQiLCJpbmRpcmVjdCIsImV2YWwiLCJ0cmltIiwiY3JlYXRlRWxlbWVudCIsInRleHQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjYW1lbENhc2UiLCJzdHJpbmciLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiaXNBcnJheUxpa2UiLCJtYWtlQXJyYXkiLCJyZXN1bHRzIiwiT2JqZWN0IiwiaW5BcnJheSIsInNlY29uZCIsImdyZXAiLCJpbnZlcnQiLCJjYWxsYmFja0ludmVyc2UiLCJtYXRjaGVzIiwiY2FsbGJhY2tFeHBlY3QiLCJhcmciLCJ2YWx1ZSIsImd1aWQiLCJwcm94eSIsInRtcCIsImFyZ3MiLCJub3ciLCJEYXRlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJzcGxpdCIsIlNpenpsZSIsIkV4cHIiLCJnZXRUZXh0IiwiaXNYTUwiLCJ0b2tlbml6ZSIsImNvbXBpbGUiLCJzZWxlY3QiLCJvdXRlcm1vc3RDb250ZXh0Iiwic29ydElucHV0IiwiaGFzRHVwbGljYXRlIiwic2V0RG9jdW1lbnQiLCJkb2NFbGVtIiwiZG9jdW1lbnRJc0hUTUwiLCJyYnVnZ3lRU0EiLCJyYnVnZ3lNYXRjaGVzIiwiY29udGFpbnMiLCJwcmVmZXJyZWREb2MiLCJkaXJydW5zIiwiZG9uZSIsImNsYXNzQ2FjaGUiLCJjcmVhdGVDYWNoZSIsInRva2VuQ2FjaGUiLCJjb21waWxlckNhY2hlIiwic29ydE9yZGVyIiwiYSIsImIiLCJNQVhfTkVHQVRJVkUiLCJwb3AiLCJwdXNoX25hdGl2ZSIsImxpc3QiLCJib29sZWFucyIsIndoaXRlc3BhY2UiLCJpZGVudGlmaWVyIiwiYXR0cmlidXRlcyIsInBzZXVkb3MiLCJyd2hpdGVzcGFjZSIsIlJlZ0V4cCIsInJjb21tYSIsInJjb21iaW5hdG9ycyIsInJhdHRyaWJ1dGVRdW90ZXMiLCJycHNldWRvIiwicmlkZW50aWZpZXIiLCJtYXRjaEV4cHIiLCJyaW5wdXRzIiwicmhlYWRlciIsInJuYXRpdmUiLCJycXVpY2tFeHByIiwicnNpYmxpbmciLCJyZXNjYXBlIiwicnVuZXNjYXBlIiwiZnVuZXNjYXBlIiwiXyIsImVzY2FwZWQiLCJlc2NhcGVkV2hpdGVzcGFjZSIsImhpZ2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ1bmxvYWRIYW5kbGVyIiwiY2hpbGROb2RlcyIsImUiLCJlbHMiLCJzZWVkIiwibSIsIm5pZCIsIm5pZHNlbGVjdCIsIm1hdGNoIiwiZ3JvdXBzIiwibmV3U2VsZWN0b3IiLCJuZXdDb250ZXh0Iiwib3duZXJEb2N1bWVudCIsImV4ZWMiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwicXNhIiwidGVzdCIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInRvU2VsZWN0b3IiLCJqb2luIiwidGVzdENvbnRleHQiLCJxdWVyeVNlbGVjdG9yQWxsIiwicXNhRXJyb3IiLCJyZW1vdmVBdHRyaWJ1dGUiLCJrZXlzIiwiY2FjaGUiLCJjYWNoZUxlbmd0aCIsInNoaWZ0IiwibWFya0Z1bmN0aW9uIiwiYXNzZXJ0IiwiZGl2IiwiYWRkSGFuZGxlIiwiYXR0cnMiLCJoYW5kbGVyIiwiYXR0ckhhbmRsZSIsInNpYmxpbmdDaGVjayIsImN1ciIsImRpZmYiLCJzb3VyY2VJbmRleCIsIm5leHRTaWJsaW5nIiwiY3JlYXRlSW5wdXRQc2V1ZG8iLCJjcmVhdGVCdXR0b25Qc2V1ZG8iLCJjcmVhdGVQb3NpdGlvbmFsUHNldWRvIiwiYXJndW1lbnQiLCJtYXRjaEluZGV4ZXMiLCJkb2N1bWVudEVsZW1lbnQiLCJub2RlIiwiaGFzQ29tcGFyZSIsInBhcmVudCIsImRvYyIsImRlZmF1bHRWaWV3IiwidG9wIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2xhc3NOYW1lIiwiY3JlYXRlQ29tbWVudCIsImdldEJ5SWQiLCJnZXRFbGVtZW50c0J5TmFtZSIsImZpbmQiLCJmaWx0ZXIiLCJhdHRySWQiLCJnZXRBdHRyaWJ1dGVOb2RlIiwidGFnIiwiaW5uZXJIVE1MIiwiaW5wdXQiLCJtYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJkaXNjb25uZWN0ZWRNYXRjaCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiYWRvd24iLCJidXAiLCJjb21wYXJlIiwic29ydERldGFjaGVkIiwiYXVwIiwiYXAiLCJicCIsInVuc2hpZnQiLCJleHByIiwiZWxlbWVudHMiLCJhdHRyIiwidmFsIiwic3BlY2lmaWVkIiwidW5pcXVlU29ydCIsImR1cGxpY2F0ZXMiLCJkZXRlY3REdXBsaWNhdGVzIiwic29ydFN0YWJsZSIsInRleHRDb250ZW50IiwiZmlyc3RDaGlsZCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsInJlbGF0aXZlIiwiZGlyIiwicHJlRmlsdGVyIiwiZXhjZXNzIiwidW5xdW90ZWQiLCJub2RlTmFtZVNlbGVjdG9yIiwicGF0dGVybiIsIm9wZXJhdG9yIiwiY2hlY2siLCJyZXN1bHQiLCJ3aGF0Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsInhtbCIsInVuaXF1ZUNhY2hlIiwib3V0ZXJDYWNoZSIsIm5vZGVJbmRleCIsInN0YXJ0IiwidXNlQ2FjaGUiLCJsYXN0Q2hpbGQiLCJ1bmlxdWVJRCIsInBzZXVkbyIsInNldEZpbHRlcnMiLCJpZHgiLCJtYXRjaGVkIiwibWF0Y2hlciIsInVubWF0Y2hlZCIsImlubmVyVGV4dCIsImxhbmciLCJlbGVtTGFuZyIsImhhc2giLCJsb2NhdGlvbiIsImFjdGl2ZUVsZW1lbnQiLCJoYXNGb2N1cyIsImhyZWYiLCJ0YWJJbmRleCIsImRpc2FibGVkIiwiY2hlY2tlZCIsInNlbGVjdGVkIiwic2VsZWN0ZWRJbmRleCIsInJhZGlvIiwiY2hlY2tib3giLCJmaWxlIiwicGFzc3dvcmQiLCJpbWFnZSIsInN1Ym1pdCIsInJlc2V0IiwiZmlsdGVycyIsInBhcnNlT25seSIsInRva2VucyIsInNvRmFyIiwicHJlRmlsdGVycyIsImNhY2hlZCIsImFkZENvbWJpbmF0b3IiLCJjb21iaW5hdG9yIiwiYmFzZSIsImNoZWNrTm9uRWxlbWVudHMiLCJkb25lTmFtZSIsIm9sZENhY2hlIiwibmV3Q2FjaGUiLCJlbGVtZW50TWF0Y2hlciIsIm1hdGNoZXJzIiwibXVsdGlwbGVDb250ZXh0cyIsImNvbnRleHRzIiwiY29uZGVuc2UiLCJuZXdVbm1hdGNoZWQiLCJtYXBwZWQiLCJzZXRNYXRjaGVyIiwicG9zdEZpbHRlciIsInBvc3RGaW5kZXIiLCJwb3N0U2VsZWN0b3IiLCJ0ZW1wIiwicHJlTWFwIiwicG9zdE1hcCIsInByZWV4aXN0aW5nIiwibWF0Y2hlckluIiwibWF0Y2hlck91dCIsIm1hdGNoZXJGcm9tVG9rZW5zIiwiY2hlY2tDb250ZXh0IiwibGVhZGluZ1JlbGF0aXZlIiwiaW1wbGljaXRSZWxhdGl2ZSIsIm1hdGNoQ29udGV4dCIsIm1hdGNoQW55Q29udGV4dCIsIm1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyIsImVsZW1lbnRNYXRjaGVycyIsInNldE1hdGNoZXJzIiwiYnlTZXQiLCJieUVsZW1lbnQiLCJzdXBlck1hdGNoZXIiLCJvdXRlcm1vc3QiLCJtYXRjaGVkQ291bnQiLCJzZXRNYXRjaGVkIiwiY29udGV4dEJhY2t1cCIsImRpcnJ1bnNVbmlxdWUiLCJ0b2tlbiIsImNvbXBpbGVkIiwiZGl2MSIsImRlZmF1bHRWYWx1ZSIsInVuaXF1ZSIsImlzWE1MRG9jIiwidW50aWwiLCJ0cnVuY2F0ZSIsImlzIiwic2libGluZ3MiLCJuIiwicm5lZWRzQ29udGV4dCIsIm5lZWRzQ29udGV4dCIsInJzaW5nbGVUYWciLCJyaXNTaW1wbGUiLCJ3aW5ub3ciLCJxdWFsaWZpZXIiLCJub3QiLCJzZWxmIiwicm9vdGpRdWVyeSIsInJvb3QiLCJwYXJzZUhUTUwiLCJyZWFkeSIsInJwYXJlbnRzcHJldiIsImd1YXJhbnRlZWRVbmlxdWUiLCJjaGlsZHJlbiIsImNvbnRlbnRzIiwibmV4dCIsInByZXYiLCJoYXMiLCJ0YXJnZXRzIiwibCIsImNsb3Nlc3QiLCJwb3MiLCJpbmRleCIsInByZXZBbGwiLCJhZGQiLCJhZGRCYWNrIiwic2libGluZyIsInBhcmVudHMiLCJwYXJlbnRzVW50aWwiLCJuZXh0QWxsIiwibmV4dFVudGlsIiwicHJldlVudGlsIiwiY29udGVudERvY3VtZW50IiwicmV2ZXJzZSIsInJub3R3aGl0ZSIsImNyZWF0ZU9wdGlvbnMiLCJvYmplY3QiLCJmbGFnIiwiQ2FsbGJhY2tzIiwiZmlyaW5nIiwibWVtb3J5IiwiZmlyZWQiLCJsb2NrZWQiLCJxdWV1ZSIsImZpcmluZ0luZGV4IiwiZmlyZSIsIm9uY2UiLCJzdG9wT25GYWxzZSIsInJlbW92ZSIsImVtcHR5IiwiZGlzYWJsZSIsImxvY2siLCJmaXJlV2l0aCIsIkRlZmVycmVkIiwiZnVuYyIsInR1cGxlcyIsInN0YXRlIiwicHJvbWlzZSIsImFsd2F5cyIsImRlZmVycmVkIiwiZmFpbCIsInRoZW4iLCJmbnMiLCJuZXdEZWZlciIsInR1cGxlIiwicmV0dXJuZWQiLCJwcm9ncmVzcyIsIm5vdGlmeSIsInJlc29sdmUiLCJyZWplY3QiLCJwaXBlIiwic3RhdGVTdHJpbmciLCJ3aGVuIiwic3Vib3JkaW5hdGUiLCJyZXNvbHZlVmFsdWVzIiwicmVtYWluaW5nIiwidXBkYXRlRnVuYyIsInZhbHVlcyIsInByb2dyZXNzVmFsdWVzIiwibm90aWZ5V2l0aCIsInJlc29sdmVXaXRoIiwicHJvZ3Jlc3NDb250ZXh0cyIsInJlc29sdmVDb250ZXh0cyIsInJlYWR5TGlzdCIsInJlYWR5V2FpdCIsImhvbGRSZWFkeSIsImhvbGQiLCJ3YWl0IiwidHJpZ2dlckhhbmRsZXIiLCJvZmYiLCJjb21wbGV0ZWQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVhZHlTdGF0ZSIsImRvU2Nyb2xsIiwic2V0VGltZW91dCIsImFjY2VzcyIsImNoYWluYWJsZSIsImVtcHR5R2V0IiwicmF3IiwiYnVsayIsImFjY2VwdERhdGEiLCJvd25lciIsIkRhdGEiLCJ1aWQiLCJyZWdpc3RlciIsImluaXRpYWwiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwic2V0IiwiZGF0YSIsInByb3AiLCJzdG9yZWQiLCJjYW1lbCIsImhhc0RhdGEiLCJkYXRhUHJpdiIsImRhdGFVc2VyIiwicmJyYWNlIiwicm11bHRpRGFzaCIsImRhdGFBdHRyIiwicGFyc2VKU09OIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJjYW1lbEtleSIsImRlcXVldWUiLCJzdGFydExlbmd0aCIsImhvb2tzIiwiX3F1ZXVlSG9va3MiLCJzdG9wIiwic2V0dGVyIiwiY2xlYXJRdWV1ZSIsImNvdW50IiwiZGVmZXIiLCJwbnVtIiwic291cmNlIiwicmNzc051bSIsImNzc0V4cGFuZCIsImlzSGlkZGVuIiwiZWwiLCJjc3MiLCJhZGp1c3RDU1MiLCJ2YWx1ZVBhcnRzIiwidHdlZW4iLCJhZGp1c3RlZCIsInNjYWxlIiwibWF4SXRlcmF0aW9ucyIsImN1cnJlbnRWYWx1ZSIsInVuaXQiLCJjc3NOdW1iZXIiLCJpbml0aWFsSW5Vbml0Iiwic3R5bGUiLCJyY2hlY2thYmxlVHlwZSIsInJ0YWdOYW1lIiwicnNjcmlwdFR5cGUiLCJ3cmFwTWFwIiwib3B0aW9uIiwidGhlYWQiLCJjb2wiLCJ0ciIsInRkIiwiX2RlZmF1bHQiLCJvcHRncm91cCIsInRib2R5IiwidGZvb3QiLCJjb2xncm91cCIsImNhcHRpb24iLCJ0aCIsImdldEFsbCIsInNldEdsb2JhbEV2YWwiLCJyZWZFbGVtZW50cyIsInJodG1sIiwiYnVpbGRGcmFnbWVudCIsInNjcmlwdHMiLCJzZWxlY3Rpb24iLCJpZ25vcmVkIiwid3JhcCIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIm5vZGVzIiwiY3JlYXRlVGV4dE5vZGUiLCJodG1sUHJlZmlsdGVyIiwiY2hlY2tDbG9uZSIsImNsb25lTm9kZSIsIm5vQ2xvbmVDaGVja2VkIiwicmtleUV2ZW50Iiwicm1vdXNlRXZlbnQiLCJydHlwZW5hbWVzcGFjZSIsInJldHVyblRydWUiLCJyZXR1cm5GYWxzZSIsInNhZmVBY3RpdmVFbGVtZW50IiwiZXJyIiwib24iLCJ0eXBlcyIsIm9uZSIsIm9yaWdGbiIsImV2ZW50IiwiaGFuZGxlT2JqSW4iLCJldmVudEhhbmRsZSIsImV2ZW50cyIsInQiLCJoYW5kbGVPYmoiLCJzcGVjaWFsIiwiaGFuZGxlcnMiLCJuYW1lc3BhY2VzIiwib3JpZ1R5cGUiLCJlbGVtRGF0YSIsImhhbmRsZSIsInRyaWdnZXJlZCIsImRpc3BhdGNoIiwiZGVsZWdhdGVUeXBlIiwiYmluZFR5cGUiLCJuYW1lc3BhY2UiLCJkZWxlZ2F0ZUNvdW50Iiwic2V0dXAiLCJtYXBwZWRUeXBlcyIsIm9yaWdDb3VudCIsInRlYXJkb3duIiwicmVtb3ZlRXZlbnQiLCJmaXgiLCJoYW5kbGVyUXVldWUiLCJkZWxlZ2F0ZVRhcmdldCIsInByZURpc3BhdGNoIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJjdXJyZW50VGFyZ2V0IiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJybmFtZXNwYWNlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwb3N0RGlzcGF0Y2giLCJzZWwiLCJpc05hTiIsImJ1dHRvbiIsInByb3BzIiwiZml4SG9va3MiLCJrZXlIb29rcyIsIm9yaWdpbmFsIiwid2hpY2giLCJjaGFyQ29kZSIsImtleUNvZGUiLCJtb3VzZUhvb2tzIiwiZXZlbnREb2MiLCJib2R5IiwicGFnZVgiLCJjbGllbnRYIiwic2Nyb2xsTGVmdCIsImNsaWVudExlZnQiLCJwYWdlWSIsImNsaWVudFkiLCJzY3JvbGxUb3AiLCJjbGllbnRUb3AiLCJvcmlnaW5hbEV2ZW50IiwiZml4SG9vayIsIkV2ZW50IiwibG9hZCIsIm5vQnViYmxlIiwiZm9jdXMiLCJ0cmlnZ2VyIiwiYmx1ciIsImNsaWNrIiwiYmVmb3JldW5sb2FkIiwicmV0dXJuVmFsdWUiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwidGltZVN0YW1wIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVybGVhdmUiLCJvcmlnIiwicmVsYXRlZCIsInJlbGF0ZWRUYXJnZXQiLCJyeGh0bWxUYWciLCJybm9Jbm5lcmh0bWwiLCJyY2hlY2tlZCIsInJzY3JpcHRUeXBlTWFza2VkIiwicmNsZWFuU2NyaXB0IiwibWFuaXB1bGF0aW9uVGFyZ2V0IiwiY29udGVudCIsImRpc2FibGVTY3JpcHQiLCJyZXN0b3JlU2NyaXB0IiwiY2xvbmVDb3B5RXZlbnQiLCJkZXN0IiwicGRhdGFPbGQiLCJwZGF0YUN1ciIsInVkYXRhT2xkIiwidWRhdGFDdXIiLCJmaXhJbnB1dCIsImRvbU1hbmlwIiwiY29sbGVjdGlvbiIsImhhc1NjcmlwdHMiLCJpTm9DbG9uZSIsImh0bWwiLCJfZXZhbFVybCIsImtlZXBEYXRhIiwiY2xlYW5EYXRhIiwiZGF0YUFuZEV2ZW50cyIsImRlZXBEYXRhQW5kRXZlbnRzIiwic3JjRWxlbWVudHMiLCJkZXN0RWxlbWVudHMiLCJpblBhZ2UiLCJkZXRhY2giLCJhcHBlbmQiLCJwcmVwZW5kIiwiaW5zZXJ0QmVmb3JlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyZXBsYWNlV2l0aCIsInJlcGxhY2VDaGlsZCIsImFwcGVuZFRvIiwicHJlcGVuZFRvIiwiaW5zZXJ0QWZ0ZXIiLCJyZXBsYWNlQWxsIiwiaW5zZXJ0IiwiaWZyYW1lIiwiZWxlbWRpc3BsYXkiLCJIVE1MIiwiQk9EWSIsImFjdHVhbERpc3BsYXkiLCJkaXNwbGF5IiwiZGVmYXVsdERpc3BsYXkiLCJ3cml0ZSIsImNsb3NlIiwicm1hcmdpbiIsInJudW1ub25weCIsImdldFN0eWxlcyIsInZpZXciLCJvcGVuZXIiLCJnZXRDb21wdXRlZFN0eWxlIiwic3dhcCIsIm9sZCIsInBpeGVsUG9zaXRpb25WYWwiLCJib3hTaXppbmdSZWxpYWJsZVZhbCIsInBpeGVsTWFyZ2luUmlnaHRWYWwiLCJyZWxpYWJsZU1hcmdpbkxlZnRWYWwiLCJjb250YWluZXIiLCJiYWNrZ3JvdW5kQ2xpcCIsImNsZWFyQ2xvbmVTdHlsZSIsImNzc1RleHQiLCJjb21wdXRlU3R5bGVUZXN0cyIsImRpdlN0eWxlIiwibWFyZ2luTGVmdCIsIndpZHRoIiwibWFyZ2luUmlnaHQiLCJwaXhlbFBvc2l0aW9uIiwiYm94U2l6aW5nUmVsaWFibGUiLCJwaXhlbE1hcmdpblJpZ2h0IiwicmVsaWFibGVNYXJnaW5MZWZ0IiwicmVsaWFibGVNYXJnaW5SaWdodCIsIm1hcmdpbkRpdiIsImN1ckNTUyIsImNvbXB1dGVkIiwibWluV2lkdGgiLCJtYXhXaWR0aCIsImdldFByb3BlcnR5VmFsdWUiLCJhZGRHZXRIb29rSWYiLCJjb25kaXRpb25GbiIsImhvb2tGbiIsInJkaXNwbGF5c3dhcCIsImNzc1Nob3ciLCJwb3NpdGlvbiIsInZpc2liaWxpdHkiLCJjc3NOb3JtYWxUcmFuc2Zvcm0iLCJsZXR0ZXJTcGFjaW5nIiwiZm9udFdlaWdodCIsImNzc1ByZWZpeGVzIiwiZW1wdHlTdHlsZSIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsInNldFBvc2l0aXZlTnVtYmVyIiwic3VidHJhY3QiLCJtYXgiLCJhdWdtZW50V2lkdGhPckhlaWdodCIsImV4dHJhIiwiaXNCb3JkZXJCb3giLCJzdHlsZXMiLCJnZXRXaWR0aE9ySGVpZ2h0IiwidmFsdWVJc0JvcmRlckJveCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwibXNGdWxsc2NyZWVuRWxlbWVudCIsImdldENsaWVudFJlY3RzIiwicm91bmQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzaG93SGlkZSIsInNob3ciLCJoaWRkZW4iLCJjc3NIb29rcyIsIm9wYWNpdHkiLCJjc3NQcm9wcyIsIm9yaWdOYW1lIiwiaXNGaW5pdGUiLCJsZWZ0IiwibWFyZ2luIiwicGFkZGluZyIsImJvcmRlciIsInByZWZpeCIsInN1ZmZpeCIsImV4cGFuZCIsImV4cGFuZGVkIiwicGFydHMiLCJoaWRlIiwidG9nZ2xlIiwiVHdlZW4iLCJlYXNpbmciLCJwcm9wSG9va3MiLCJydW4iLCJwZXJjZW50IiwiZWFzZWQiLCJkdXJhdGlvbiIsInN0ZXAiLCJmeCIsImxpbmVhciIsInAiLCJzd2luZyIsImNvcyIsIlBJIiwiZnhOb3ciLCJ0aW1lcklkIiwicmZ4dHlwZXMiLCJycnVuIiwiY3JlYXRlRnhOb3ciLCJnZW5GeCIsImluY2x1ZGVXaWR0aCIsImhlaWdodCIsImNyZWF0ZVR3ZWVuIiwiYW5pbWF0aW9uIiwiQW5pbWF0aW9uIiwidHdlZW5lcnMiLCJkZWZhdWx0UHJlZmlsdGVyIiwib3B0cyIsIm9sZGZpcmUiLCJjaGVja0Rpc3BsYXkiLCJhbmltIiwiZGF0YVNob3ciLCJ1bnF1ZXVlZCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwicHJvcEZpbHRlciIsInNwZWNpYWxFYXNpbmciLCJwcm9wZXJ0aWVzIiwic3RvcHBlZCIsInByZWZpbHRlcnMiLCJ0aWNrIiwiY3VycmVudFRpbWUiLCJzdGFydFRpbWUiLCJ0d2VlbnMiLCJvcmlnaW5hbFByb3BlcnRpZXMiLCJvcmlnaW5hbE9wdGlvbnMiLCJnb3RvRW5kIiwicmVqZWN0V2l0aCIsInRpbWVyIiwiY29tcGxldGUiLCJ0d2VlbmVyIiwicHJlZmlsdGVyIiwic3BlZWQiLCJvcHQiLCJzcGVlZHMiLCJmYWRlVG8iLCJ0byIsImFuaW1hdGUiLCJvcHRhbGwiLCJkb0FuaW1hdGlvbiIsImZpbmlzaCIsInN0b3BRdWV1ZSIsInRpbWVycyIsImNzc0ZuIiwic2xpZGVEb3duIiwic2xpZGVVcCIsInNsaWRlVG9nZ2xlIiwiZmFkZUluIiwiZmFkZU91dCIsImZhZGVUb2dnbGUiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInNsb3ciLCJmYXN0IiwiZGVsYXkiLCJ0aW1lIiwidGltZW91dCIsImNsZWFyVGltZW91dCIsImNoZWNrT24iLCJvcHRTZWxlY3RlZCIsIm9wdERpc2FibGVkIiwicmFkaW9WYWx1ZSIsImJvb2xIb29rIiwicmVtb3ZlQXR0ciIsIm5UeXBlIiwiYXR0ckhvb2tzIiwiYm9vbCIsInByb3BOYW1lIiwiYXR0ck5hbWVzIiwicHJvcEZpeCIsImdldHRlciIsInJmb2N1c2FibGUiLCJyY2xpY2thYmxlIiwicmVtb3ZlUHJvcCIsInRhYmluZGV4IiwicGFyc2VJbnQiLCJyY2xhc3MiLCJnZXRDbGFzcyIsImFkZENsYXNzIiwiY2xhc3NlcyIsImN1clZhbHVlIiwiY2xhenoiLCJmaW5hbFZhbHVlIiwicmVtb3ZlQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsInN0YXRlVmFsIiwiY2xhc3NOYW1lcyIsImhhc0NsYXNzIiwicnJldHVybiIsInJzcGFjZXMiLCJ2YWxIb29rcyIsIm9wdGlvblNldCIsInJmb2N1c01vcnBoIiwib25seUhhbmRsZXJzIiwiYnViYmxlVHlwZSIsIm9udHlwZSIsImV2ZW50UGF0aCIsImlzVHJpZ2dlciIsInBhcmVudFdpbmRvdyIsInNpbXVsYXRlIiwiaXNTaW11bGF0ZWQiLCJob3ZlciIsImZuT3ZlciIsImZuT3V0IiwiZm9jdXNpbiIsImF0dGFjaGVzIiwibm9uY2UiLCJycXVlcnkiLCJKU09OIiwicGFyc2UiLCJwYXJzZVhNTCIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsInJoYXNoIiwicnRzIiwicmhlYWRlcnMiLCJybG9jYWxQcm90b2NvbCIsInJub0NvbnRlbnQiLCJycHJvdG9jb2wiLCJ0cmFuc3BvcnRzIiwiYWxsVHlwZXMiLCJvcmlnaW5BbmNob3IiLCJhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJzdHJ1Y3R1cmUiLCJkYXRhVHlwZUV4cHJlc3Npb24iLCJkYXRhVHlwZSIsImRhdGFUeXBlcyIsImluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwianFYSFIiLCJpbnNwZWN0ZWQiLCJzZWVraW5nVHJhbnNwb3J0IiwiaW5zcGVjdCIsInByZWZpbHRlck9yRmFjdG9yeSIsImRhdGFUeXBlT3JUcmFuc3BvcnQiLCJhamF4RXh0ZW5kIiwiZmxhdE9wdGlvbnMiLCJhamF4U2V0dGluZ3MiLCJhamF4SGFuZGxlUmVzcG9uc2VzIiwicyIsInJlc3BvbnNlcyIsImN0IiwiZmluYWxEYXRhVHlwZSIsImZpcnN0RGF0YVR5cGUiLCJtaW1lVHlwZSIsImdldFJlc3BvbnNlSGVhZGVyIiwiY29udmVydGVycyIsImFqYXhDb252ZXJ0IiwicmVzcG9uc2UiLCJpc1N1Y2Nlc3MiLCJjb252MiIsImN1cnJlbnQiLCJjb252IiwicmVzcG9uc2VGaWVsZHMiLCJkYXRhRmlsdGVyIiwidGhyb3dzIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInVybCIsImlzTG9jYWwiLCJwcm90b2NvbCIsInByb2Nlc3NEYXRhIiwiYXN5bmMiLCJjb250ZW50VHlwZSIsImFjY2VwdHMiLCJqc29uIiwiYWpheFNldHVwIiwic2V0dGluZ3MiLCJhamF4UHJlZmlsdGVyIiwiYWpheFRyYW5zcG9ydCIsImFqYXgiLCJ0cmFuc3BvcnQiLCJjYWNoZVVSTCIsInJlc3BvbnNlSGVhZGVyc1N0cmluZyIsInJlc3BvbnNlSGVhZGVycyIsInRpbWVvdXRUaW1lciIsInVybEFuY2hvciIsImZpcmVHbG9iYWxzIiwiY2FsbGJhY2tDb250ZXh0IiwiZ2xvYmFsRXZlbnRDb250ZXh0IiwiY29tcGxldGVEZWZlcnJlZCIsInN0YXR1c0NvZGUiLCJyZXF1ZXN0SGVhZGVycyIsInJlcXVlc3RIZWFkZXJzTmFtZXMiLCJzdHJBYm9ydCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInNldFJlcXVlc3RIZWFkZXIiLCJsbmFtZSIsIm92ZXJyaWRlTWltZVR5cGUiLCJzdGF0dXMiLCJhYm9ydCIsInN0YXR1c1RleHQiLCJmaW5hbFRleHQiLCJzdWNjZXNzIiwibWV0aG9kIiwiY3Jvc3NEb21haW4iLCJob3N0IiwicGFyYW0iLCJ0cmFkaXRpb25hbCIsImhhc0NvbnRlbnQiLCJpZk1vZGlmaWVkIiwiaGVhZGVycyIsImJlZm9yZVNlbmQiLCJzZW5kIiwibmF0aXZlU3RhdHVzVGV4dCIsIm1vZGlmaWVkIiwiZ2V0SlNPTiIsImdldFNjcmlwdCIsIndyYXBBbGwiLCJmaXJzdEVsZW1lbnRDaGlsZCIsIndyYXBJbm5lciIsInVud3JhcCIsInZpc2libGUiLCJyMjAiLCJyYnJhY2tldCIsInJDUkxGIiwicnN1Ym1pdHRlclR5cGVzIiwicnN1Ym1pdHRhYmxlIiwiYnVpbGRQYXJhbXMiLCJ2IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2VyaWFsaXplIiwic2VyaWFsaXplQXJyYXkiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInhoclN1Y2Nlc3NTdGF0dXMiLCJ4aHJTdXBwb3J0ZWQiLCJjb3JzIiwiZXJyb3JDYWxsYmFjayIsIm9wZW4iLCJ1c2VybmFtZSIsInhockZpZWxkcyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJvbmFib3J0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VUZXh0IiwiYmluYXJ5IiwiY2hhcnNldCIsInNjcmlwdENoYXJzZXQiLCJldnQiLCJvbGRDYWxsYmFja3MiLCJyanNvbnAiLCJqc29ucCIsImpzb25wQ2FsbGJhY2siLCJvcmlnaW5hbFNldHRpbmdzIiwiY2FsbGJhY2tOYW1lIiwib3ZlcndyaXR0ZW4iLCJyZXNwb25zZUNvbnRhaW5lciIsImpzb25Qcm9wIiwia2VlcFNjcmlwdHMiLCJwYXJzZWQiLCJfbG9hZCIsInBhcmFtcyIsImFuaW1hdGVkIiwiZ2V0V2luZG93Iiwib2Zmc2V0Iiwic2V0T2Zmc2V0IiwiY3VyUG9zaXRpb24iLCJjdXJMZWZ0IiwiY3VyQ1NTVG9wIiwiY3VyVG9wIiwiY3VyT2Zmc2V0IiwiY3VyQ1NTTGVmdCIsImNhbGN1bGF0ZVBvc2l0aW9uIiwiY3VyRWxlbSIsInVzaW5nIiwid2luIiwiYm94IiwicGFnZVlPZmZzZXQiLCJwYWdlWE9mZnNldCIsIm9mZnNldFBhcmVudCIsInBhcmVudE9mZnNldCIsInNjcm9sbFRvIiwiSGVpZ2h0IiwiV2lkdGgiLCJkZWZhdWx0RXh0cmEiLCJmdW5jTmFtZSIsImJpbmQiLCJ1bmJpbmQiLCJkZWxlZ2F0ZSIsInVuZGVsZWdhdGUiLCJzaXplIiwiYW5kU2VsZiIsImRlZmluZSIsImFtZCIsIl9qUXVlcnkiLCJfJCIsIiQiLCJub0NvbmZsaWN0IiwiX2dzU2NvcGUiLCJfZ3NRdWV1ZSIsIl9nc0RlZmluZSIsIlNpbXBsZVRpbWVsaW5lIiwiVHdlZW5MaXRlIiwiX3NsaWNlIiwiX2FwcGx5Q3ljbGUiLCJ2YXJzIiwiYWx0IiwiY3ljbGUiLCJUd2Vlbk1heCIsIl9jeWNsZSIsIl95b3lvIiwieW95byIsIl9yZXBlYXQiLCJyZXBlYXQiLCJfcmVwZWF0RGVsYXkiLCJyZXBlYXREZWxheSIsIl9kaXJ0eSIsInJlbmRlciIsIl90aW55TnVtIiwiVHdlZW5MaXRlSW50ZXJuYWxzIiwiX2ludGVybmFscyIsIl9pc1NlbGVjdG9yIiwiaXNTZWxlY3RvciIsIl9pc0FycmF5IiwiX2JsYW5rQXJyYXkiLCJraWxsIiwiX2djIiwia2lsbFR3ZWVuc09mIiwia2lsbERlbGF5ZWRDYWxsc1RvIiwiZ2V0VHdlZW5zT2YiLCJsYWdTbW9vdGhpbmciLCJ0aWNrZXIiLCJpbnZhbGlkYXRlIiwiX3VuY2FjaGUiLCJ1cGRhdGVUbyIsInJlc2V0RHVyYXRpb24iLCJjdXJSYXRpbyIsInJhdGlvIiwiaW1tZWRpYXRlIiwiaW1tZWRpYXRlUmVuZGVyIiwiX3N0YXJ0VGltZSIsIl90aW1lbGluZSIsIl90aW1lIiwiX2VuYWJsZWQiLCJfZGVsYXkiLCJfaW5pdHRlZCIsIl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkIiwiX2ZpcnN0UFQiLCJfb25QbHVnaW5FdmVudCIsIl9kdXJhdGlvbiIsInByZXZUaW1lIiwiX3RvdGFsVGltZSIsIl9pbml0IiwiaW52IiwicHQiLCJlbmRWYWx1ZSIsImMiLCJfbmV4dCIsInN1cHByZXNzRXZlbnRzIiwiZm9yY2UiLCJ0b3RhbER1ciIsIl90b3RhbER1cmF0aW9uIiwidG90YWxEdXJhdGlvbiIsInByZXZUb3RhbFRpbWUiLCJwcmV2Q3ljbGUiLCJwcmV2UmF3UHJldlRpbWUiLCJfcmF3UHJldlRpbWUiLCJpc0NvbXBsZXRlIiwiY3ljbGVEdXJhdGlvbiIsInIiLCJwb3ciLCJyYXdQcmV2VGltZSIsIl9lYXNlIiwiX2NhbGNFbmQiLCJnZXRSYXRpbyIsIl9yZXZlcnNlZCIsImF1dG9SZW1vdmVDaGlsZHJlbiIsImxhenkiLCJfYWN0aXZlIiwiX2Vhc2VUeXBlIiwiX2Vhc2VQb3dlciIsIl9vblVwZGF0ZSIsIl9jYWxsYmFjayIsImxhenlUd2VlbnMiLCJfbGF6eSIsIl9wYXVzZWQiLCJfc3RhcnRBdCIsIm9uU3RhcnQiLCJmIiwib25SZXBlYXQiLCJmcm9tIiwicnVuQmFja3dhcmRzIiwiZnJvbVRvIiwiZnJvbVZhcnMiLCJ0b1ZhcnMiLCJzdGFydEF0Iiwic3RhZ2dlclRvIiwiYWxsVG8iLCJzdGFnZ2VyIiwib25Db21wbGV0ZUFsbCIsIm9uQ29tcGxldGVBbGxQYXJhbXMiLCJvbkNvbXBsZXRlQWxsU2NvcGUiLCJmaW5hbENvbXBsZXRlIiwib25Db21wbGV0ZSIsIm9uQ29tcGxldGVTY29wZSIsImNhbGxiYWNrU2NvcGUiLCJmcm9tQ3ljbGUiLCJzdGFnZ2VyRnJvbSIsImFsbEZyb20iLCJzdGFnZ2VyRnJvbVRvIiwiYWxsRnJvbVRvIiwiZGVsYXllZENhbGwiLCJzY29wZSIsInVzZUZyYW1lcyIsIm9uQ29tcGxldGVQYXJhbXMiLCJvblJldmVyc2VDb21wbGV0ZSIsIm9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zIiwib3ZlcndyaXRlIiwiaXNUd2VlbmluZyIsIl9nZXRDaGlsZHJlbk9mIiwidGltZWxpbmUiLCJpbmNsdWRlVGltZWxpbmVzIiwiY250IiwiX2ZpcnN0IiwiZ2V0QWxsVHdlZW5zIiwiX3Jvb3RUaW1lbGluZSIsIl9yb290RnJhbWVzVGltZWxpbmUiLCJraWxsQWxsIiwiZGVsYXllZENhbGxzIiwidGltZWxpbmVzIiwiYWxsVHJ1ZSIsImlzREMiLCJ0b3RhbFRpbWUiLCJraWxsQ2hpbGRUd2VlbnNPZiIsInRsIiwidHdlZW5Mb29rdXAiLCJjdXJQYXJlbnQiLCJfY2hhbmdlUGF1c2UiLCJwYXVzZSIsInBhdXNlZCIsInBhdXNlQWxsIiwicmVzdW1lQWxsIiwiZ2xvYmFsVGltZVNjYWxlIiwiX3RpbWVTY2FsZSIsImZyYW1lIiwidG90YWxQcm9ncmVzcyIsIlRpbWVsaW5lTGl0ZSIsIl9sYWJlbHMiLCJzbW9vdGhDaGlsZFRpbWluZyIsIl9zb3J0Q2hpbGRyZW4iLCJvblVwZGF0ZSIsIl9zd2FwU2VsZkluUGFyYW1zIiwiYWxpZ24iLCJfbGF6eVR3ZWVucyIsIl9sYXp5UmVuZGVyIiwibGF6eVJlbmRlciIsIl9nbG9iYWxzIiwiZ2xvYmFscyIsIl9jb3B5IiwiX3BhdXNlQ2FsbGJhY2siLCJwYXVzZUNhbGxiYWNrIiwiX2ZvcmNpbmdQbGF5aGVhZCIsIl9oYXNQYXVzZSIsIkVuZ2luZSIsIl9wYXJzZVRpbWVPckxhYmVsIiwiZXhwb3J0Um9vdCIsImlnbm9yZURlbGF5ZWRDYWxscyIsIl9yZW1vdmUiLCJjdXJUaW1lIiwiY2hpbGQiLCJiZWZvcmVSYXdUaW1lIiwiYWRkTGFiZWwiLCJyYXdUaW1lIiwiX3BhdXNlVGltZSIsInJlbW92ZUxhYmVsIiwic2tpcERpc2FibGUiLCJfbGFzdCIsIm9mZnNldE9yTGFiZWwiLCJpbnNlcnRNdWx0aXBsZSIsImFwcGVuZE11bHRpcGxlIiwibGFiZWwiLCJhZGRQYXVzZSIsImdldExhYmVsVGltZSIsInRpbWVPckxhYmVsIiwiYXBwZW5kSWZBYnNlbnQiLCJpZ25vcmUiLCJjaGFyQXQiLCJOdW1iZXIiLCJzdWJzdHIiLCJzZWVrIiwiZ290b0FuZFBsYXkiLCJwbGF5IiwiZ290b0FuZFN0b3AiLCJwcmV2U3RhcnQiLCJwcmV2VGltZVNjYWxlIiwicHJldlBhdXNlZCIsImludGVybmFsRm9yY2UiLCJwYXVzZVR3ZWVuIiwiX2hhc1BhdXNlZENoaWxkIiwiX3ByZXYiLCJlbmRUaW1lIiwiZ2V0Q2hpbGRyZW4iLCJuZXN0ZWQiLCJpZ25vcmVCZWZvcmVUaW1lIiwiX2NvbnRhaW5zIiwicmVjZW50IiwiX3JlY2VudCIsInNoaWZ0Q2hpbGRyZW4iLCJhbW91bnQiLCJhZGp1c3RMYWJlbHMiLCJsYWJlbHMiLCJfa2lsbCIsImNoYW5nZWQiLCJjbGVhciIsImVuYWJsZWQiLCJpZ25vcmVUaW1lbGluZSIsInVuY2FwcGVkIiwidGltZVNjYWxlIiwidXNlc0ZyYW1lcyIsIkVhc2UiLCJUaW1lbGluZU1heCIsIl9lYXNlTm9uZSIsImFkZENhbGxiYWNrIiwicmVtb3ZlQ2FsbGJhY2siLCJyZW1vdmVQYXVzZSIsInR3ZWVuVG8iLCJlYXNlIiwiYWJzIiwidHdlZW5Gcm9tVG8iLCJmcm9tUG9zaXRpb24iLCJ0b1Bvc2l0aW9uIiwiZHVyIiwiX2xvY2tlZCIsImJhY2t3YXJkcyIsInJlY1RvdGFsVGltZSIsInJlY0N5Y2xlIiwicmVjUmF3UHJldlRpbWUiLCJyZWNUaW1lIiwiZ2V0QWN0aXZlIiwiaXNBY3RpdmUiLCJnZXRMYWJlbEFmdGVyIiwiZ2V0TGFiZWxzQXJyYXkiLCJnZXRMYWJlbEJlZm9yZSIsImN1cnJlbnRMYWJlbCIsIl9SQUQyREVHIiwiX3IxIiwiX3IyIiwiX3IzIiwiX2NvclByb3BzIiwiU2VnbWVudCIsImQiLCJkYSIsImNhIiwiYmEiLCJfY29ycmVsYXRlIiwiY3ViaWNUb1F1YWRyYXRpYyIsInExIiwicTIiLCJxMyIsInE0IiwibWFiIiwibWJjIiwibWNkIiwibWFiYyIsIm1iY2QiLCJtOCIsIl9jYWxjdWxhdGVDb250cm9sUG9pbnRzIiwiY3VydmluZXNzIiwicXVhZCIsImJhc2ljIiwiY29ycmVsYXRlIiwiaWkiLCJjcDEiLCJwMSIsInAyIiwicDMiLCJzZWciLCJtMSIsIm0yIiwibW0iLCJjcDIiLCJxYiIsInIxIiwicjIiLCJfcGFyc2VBbmNob3JzIiwiYmV6aWVyVGhyb3VnaCIsInF1YWRyYXRpYyIsInNlYW1sZXNzIiwic3FydCIsIl9wYXJzZUJlemllckRhdGEiLCJpbmMiLCJzb2Z0IiwiX2FkZEN1YmljTGVuZ3RocyIsInN0ZXBzIiwicmVzb2x1dGlvbiIsImQxIiwiYmV6IiwiX3BhcnNlTGVuZ3RoRGF0YSIsImxlbmd0aHMiLCJ0b3RhbCIsInRocmVzaG9sZCIsInNlZ21lbnRzIiwiY3VyTFMiLCJCZXppZXJQbHVnaW4iLCJwbHVnaW4iLCJwcmlvcml0eSIsIkFQSSIsIl90YXJnZXQiLCJfZnVuYyIsIl9yb3VuZCIsIl9wcm9wcyIsIl90aW1lUmVzIiwidGltZVJlc29sdXRpb24iLCJhdXRvUm90YXRlIiwib3JpZW50VG9CZXppZXIiLCJpc0Z1bmMiLCJfYXV0b1JvdGF0ZSIsIl9vdmVyd3JpdGVQcm9wcyIsIl9iZXppZXJzIiwiX3NlZ0NvdW50IiwibGQiLCJfbGVuZ3RoIiwiX2xlbmd0aHMiLCJfc2VnbWVudHMiLCJfbDEiLCJfbGkiLCJfczEiLCJfc2kiLCJfbDIiLCJfY3VyU2VnIiwiX3MyIiwiX3ByZWMiLCJfaW5pdGlhbFJvdGF0aW9ucyIsIl9zdGFydFJhdGlvIiwibm90U3RhcnQiLCJjdXJJbmRleCIsImN1clNlZyIsImFyIiwiYjIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImF0YW4yIiwiX2F1dG9DU1MiLCJxdWFkcmF0aWNUb0N1YmljIiwiX2Nzc1JlZ2lzdGVyIiwiQ1NTUGx1Z2luIiwiX3BhcnNlVG9Qcm94eSIsIl9zZXRQbHVnaW5SYXRpbyIsIkNTU1Byb3BUd2VlbiIsIl9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcCIsInBhcnNlciIsImNzc3AiLCJwbHVnaW5WYWx1ZXMiLCJzZXRSYXRpbyIsIngiLCJfdHJhbnNmb3JtIiwiX2VuYWJsZVRyYW5zZm9ybXMiLCJfZ3NUcmFuc2Zvcm0iLCJfb25Jbml0VHdlZW4iLCJfdHdlZW4iLCJfcm91bmRQcm9wcyIsImxvb2t1cCIsIm9wIiwiYmV6aWVyIiwiX3N1cGVyIiwiVHdlZW5QbHVnaW4iLCJfaGFzUHJpb3JpdHkiLCJfc3VmZml4TWFwIiwiX2NzIiwiX3NwZWNpYWxQcm9wcyIsImRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSIsImRlZmF1bHRTa2V3VHlwZSIsImRlZmF1bHRTbW9vdGhPcmlnaW4iLCJzdWZmaXhNYXAiLCJyaWdodCIsImJvdHRvbSIsImZvbnRTaXplIiwicGVyc3BlY3RpdmUiLCJsaW5lSGVpZ2h0IiwiX251bUV4cCIsIl9yZWxOdW1FeHAiLCJfdmFsdWVzRXhwIiwiX05hTkV4cCIsIl9zdWZmaXhFeHAiLCJfb3BhY2l0eUV4cCIsIl9vcGFjaXR5VmFsRXhwIiwiX2FscGhhRmlsdGVyRXhwIiwiX3JnYmhzbEV4cCIsIl9jYXBzRXhwIiwiX2NhbWVsRXhwIiwiX3VybEV4cCIsIl9jYW1lbEZ1bmMiLCJnIiwiX2hvcml6RXhwIiwiX2llR2V0TWF0cml4RXhwIiwiX2llU2V0TWF0cml4RXhwIiwiX2NvbW1hc091dHNpZGVQYXJlbkV4cCIsIl9jb21wbGV4RXhwIiwiX0RFRzJSQUQiLCJfZm9yY2VQVCIsIl9kb2MiLCJfY3JlYXRlRWxlbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsIl90ZW1wRGl2IiwiX3RlbXBJbWciLCJfYWdlbnQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJfYXV0b1JvdW5kIiwiX3JlcVNhZmFyaUZpeCIsIl9pc1NhZmFyaSIsIl9pc0ZpcmVmb3giLCJfaXNTYWZhcmlMVDYiLCJfaWVWZXJzIiwiX3N1cHBvcnRzT3BhY2l0eSIsIiQxIiwiX2dldElFT3BhY2l0eSIsImN1cnJlbnRTdHlsZSIsIl9sb2ciLCJjb25zb2xlIiwibG9nIiwiX3ByZWZpeENTUyIsIl9wcmVmaXgiLCJfY2hlY2tQcm9wUHJlZml4IiwiX2dldENvbXB1dGVkU3R5bGUiLCJfZ2V0U3R5bGUiLCJnZXRTdHlsZSIsImNzIiwiY2FsYyIsImRmbHQiLCJydiIsIl9jb252ZXJ0VG9QaXhlbHMiLCJjb252ZXJ0VG9QaXhlbHMiLCJzZngiLCJyZWN1cnNlIiwiaG9yaXoiLCJuZWciLCJwaXgiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIl9nc0NhY2hlIiwiY2FjaGVXaWR0aHMiLCJfY2FsY3VsYXRlT2Zmc2V0IiwiY2FsY3VsYXRlT2Zmc2V0IiwiZGltIiwiX2dldEFsbFN0eWxlcyIsIl90cmFuc2Zvcm1Qcm9wQ1NTIiwiX3RyYW5zZm9ybVByb3AiLCJfZ2V0VHJhbnNmb3JtIiwicm90YXRpb24iLCJza2V3WCIsInNjYWxlWCIsInNjYWxlWSIsInkiLCJfc3VwcG9ydHMzRCIsInoiLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJzY2FsZVoiLCJfY3NzRGlmIiwiczEiLCJzMiIsImZvcmNlTG9va3VwIiwiZGlmcyIsIm1wdCIsIk1pbmlQcm9wVHdlZW4iLCJmaXJzdE1QVCIsIl9kaW1lbnNpb25zIiwiX21hcmdpbnMiLCJfZ2V0RGltZW5zaW9uIiwiZ2V0QkJveCIsIl9pc1NWRyIsIl9wYXJzZVBvc2l0aW9uIiwicmVjT2JqIiwib3hwIiwib3lwIiwib3hyIiwib3lyIiwib3giLCJveSIsIl9wYXJzZUNoYW5nZSIsIl9wYXJzZVZhbCIsIl9wYXJzZUFuZ2xlIiwiZGlyZWN0aW9uYWxFbmQiLCJtaW4iLCJjYXAiLCJkaWYiLCJpc1JlbGF0aXZlIiwiX2NvbG9yTG9va3VwIiwiYXF1YSIsImxpbWUiLCJzaWx2ZXIiLCJibGFjayIsIm1hcm9vbiIsInRlYWwiLCJibHVlIiwibmF2eSIsIndoaXRlIiwiZnVjaHNpYSIsIm9saXZlIiwieWVsbG93Iiwib3JhbmdlIiwiZ3JheSIsInB1cnBsZSIsImdyZWVuIiwicmVkIiwicGluayIsImN5YW4iLCJ0cmFuc3BhcmVudCIsIl9odWUiLCJoIiwiX3BhcnNlQ29sb3IiLCJwYXJzZUNvbG9yIiwidG9IU0wiLCJ3YXNIU0wiLCJfZm9ybWF0Q29sb3JzIiwiY29sb3JzIiwiX2NvbG9yRXhwIiwiY2hhckluZGV4IiwiY29sb3IiLCJjb2xvclN0cmluZ0ZpbHRlciIsImNvbWJpbmVkIiwibGFzdEluZGV4IiwiZGVmYXVsdFN0cmluZ0ZpbHRlciIsIl9nZXRGb3JtYXR0ZXIiLCJjbHIiLCJjb2xsYXBzaWJsZSIsIm11bHRpIiwiZENvbG9yIiwiZFZhbHMiLCJwZngiLCJkZWxpbSIsIm51bVZhbHMiLCJkU2Z4IiwiZm9ybWF0dGVyIiwidmFscyIsIl9nZXRFZGdlUGFyc2VyIiwic3RyIiwieHMwIiwieHMxIiwic2hhbGxvdyIsImJwdCIsInRyYW5zZm9ybSIsIm9sZEZvcmNlIiwieHAiLCJmaXJzdFBUIiwicnhwIiwicHIiLCJfYWRkTm9uVHdlZW5pbmdOdW1lcmljUFQiLCJvdmVyd3JpdGVQcm9wIiwiX3BhcnNlQ29tcGxleCIsInBhcnNlQ29tcGxleCIsImNscnMiLCJlYSIsImF1dG9Sb3VuZCIsInhpIiwibmkiLCJidiIsImV2IiwiYm51bXMiLCJlbnVtcyIsImJuIiwiaGFzQWxwaGEiLCJjdiIsInVzZUhTTCIsImFwcGVuZFh0cmEiLCJ4Zmlyc3QiLCJwYWQiLCJTcGVjaWFsUHJvcCIsImZvcm1hdCIsImtleXdvcmQiLCJkZWZhdWx0cyIsIl9yZWdpc3RlclBsdWdpblByb3AiLCJwbHVnaW5OYW1lIiwicGx1Z2luQ2xhc3MiLCJjb20iLCJncmVlbnNvY2siLCJwbHVnaW5zIiwia3dkIiwiYmkiLCJlaSIsInJlZ2lzdGVyU3BlY2lhbFByb3AiLCJvbkluaXRUd2VlbiIsInVzZVNWR1RyYW5zZm9ybUF0dHIiLCJfdHJhbnNmb3JtUHJvcHMiLCJfdHJhbnNmb3JtT3JpZ2luUHJvcCIsIlRyYW5zZm9ybSIsImZvcmNlM0QiLCJkZWZhdWx0Rm9yY2UzRCIsIl9TVkdFbGVtZW50IiwiU1ZHRWxlbWVudCIsIl91c2VTVkdUcmFuc2Zvcm1BdHRyIiwiX2NyZWF0ZVNWRyIsImVsZW1lbnQiLCJyZWciLCJzZXRBdHRyaWJ1dGVOUyIsIl9kb2NFbGVtZW50IiwiX2ZvcmNlU1ZHVHJhbnNmb3JtQXR0ciIsImNocm9tZSIsInN2ZyIsInJlY3QiLCJfcGFyc2VTVkdPcmlnaW4iLCJsb2NhbCIsImRlY29yYXRlZSIsImFic29sdXRlIiwic21vb3RoT3JpZ2luIiwic2tpcFJlY29yZCIsInRtIiwiX2dldE1hdHJpeCIsInhPcmlnaW4iLCJ5T3JpZ2luIiwidHgiLCJ0eSIsImRldGVybWluYW50IiwieE9yaWdpbk9sZCIsInlPcmlnaW5PbGQiLCJfaWRlbnRpdHkyRE1hdHJpeCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiX2NhbkdldEJCb3giLCJnZXRDVE0iLCJmb3JjZTJEIiwicm5kIiwiaXNEZWZhdWx0IiwiZGVjIiwiZ2V0VHJhbnNmb3JtIiwicmVjIiwiaW52WCIsInpPcmlnaW4iLCJhMTEiLCJhMjEiLCJhMzEiLCJhNDEiLCJhMTIiLCJhMjIiLCJhMzIiLCJhNDIiLCJhMTMiLCJhMjMiLCJhMzMiLCJhMTQiLCJhMjQiLCJhMzQiLCJhNDMiLCJhbmdsZSIsInQxIiwidDIiLCJ0MyIsInQ0Iiwic2luIiwiayIsIl9yZW1vdmVQcm9wIiwiX3NldElFVHJhbnNmb3JtUmF0aW8iLCJhbmciLCJza2V3IiwiY2xpcCIsInhQZXJjZW50IiwieVBlcmNlbnQiLCJkeCIsImR5IiwibXVsdCIsIm1hcmciLCJpZU9mZnNldFgiLCJpZU9mZnNldFkiLCJfc2V0VHJhbnNmb3JtUmF0aW8iLCJzZXQzRFRyYW5zZm9ybVJhdGlvIiwic2V0VHJhbnNmb3JtUmF0aW8iLCJzeCIsInN5Iiwic3oiLCJpc1NWRyIsImNvbW1hIiwiemVybyIsInNrZXdUeXBlIiwidGFuIiwic2tld1kiLCJfbGFzdFBhcnNlZFRyYW5zZm9ybSIsIm9yaWdpbmFsR1NUcmFuc2Zvcm0iLCJlbmRSb3RhdGlvbnMiLCJ0cmFuc2Zvcm1PcmlnaW5TdHJpbmciLCJoYXMzRCIsImhhc0NoYW5nZSIsImRyIiwibWF0cml4IiwicGFyc2VUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1PcmlnaW4iLCJzdmdPcmlnaW4iLCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZSIsImRpcmVjdGlvbmFsUm90YXRpb24iLCJzaG9ydFJvdGF0aW9uIiwicm90YXRpb25aIiwic2hvcnRSb3RhdGlvblgiLCJzaG9ydFJvdGF0aW9uWSIsIl90cmFuc2Zvcm1UeXBlIiwiZWExIiwiZXMyIiwiYnMyIiwiYnMiLCJlcyIsImVuIiwiZXNmeCIsImJzZngiLCJyZWwiLCJobiIsInZuIiwiZW0iLCJiYWNrZ3JvdW5kUG9zaXRpb25YIiwiYmFja2dyb3VuZFBvc2l0aW9uWSIsInBjdCIsIm92ZXJsYXAiLCJjbGlwVG9wIiwiY2xpcFJpZ2h0IiwiY2xpcEJvdHRvbSIsImNsaXBMZWZ0IiwiX3NldElFT3BhY2l0eVJhdGlvIiwic2tpcCIsInhuMSIsImlzQXV0b0FscGhhIiwiem9vbSIsInJlbW92ZVByb3BlcnR5IiwiX3NldENsYXNzTmFtZVJhdGlvIiwiX2dzQ2xhc3NQVCIsImRpZkRhdGEiLCJjbnB0IiwiY25wdExvb2t1cCIsIl9jbGFzc05hbWVQVCIsIl9zZXRDbGVhclByb3BzUmF0aW8iLCJ0cmFuc2Zvcm1QYXJzZSIsImNsZWFyVHJhbnNmb3JtIiwiX3ZhcnMiLCJwdDIiLCJ6SW5kZXgiLCJ0cHQiLCJ0aHJlZUQiLCJfYWRkTGF6eVNldCIsIldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSIsIl9saW5rQ1NTUCIsInNwIiwiaXNTdHIiLCJzdHJpY3RVbml0cyIsInhzMiIsInhuMiIsInhzMyIsInhuMyIsInhzNCIsInhuNCIsInhzNSIsImxhenlTZXQiLCJhdXRvQWxwaGEiLCJhbHBoYSIsIl9nZXRDaGlsZFN0eWxlcyIsImNhc2NhZGVUbyIsIl9yZXNlcnZlZFByb3BzIiwicmVzZXJ2ZWRQcm9wcyIsIl90YXJnZXRzIiwiYWN0aXZhdGUiLCJSb3VuZFByb3BzUGx1Z2luIiwiX3JvdW5kTGlua2VkTGlzdCIsImJsb2IiLCJfb25Jbml0QWxsUHJvcHMiLCJycCIsInJvdW5kUHJvcHMiLCJycHQiLCJfcHJvcExvb2t1cCIsInBnIiwiX2FkZCIsIl9hZGRUd2VlbiIsImZpbmFscyIsInVzZVJhZGlhbnMiLCJHcmVlblNvY2tHbG9iYWxzIiwiZ3MiLCJfMlBJIiwiX0hBTEZfUEkiLCJfY2xhc3MiLCJfY3JlYXRlIiwiQyIsIl9lYXNlUmVnIiwiX3dyYXAiLCJFYXNlT3V0IiwiRWFzZUluIiwiRWFzZUluT3V0IiwiYWxpYXNlcyIsImVhc2VPdXQiLCJlYXNlSW4iLCJlYXNlSW5PdXQiLCJFYXNlUG9pbnQiLCJnYXAiLCJfY3JlYXRlQmFjayIsIm92ZXJzaG9vdCIsIl9wMSIsIl9wMiIsImNvbmZpZyIsIkJhY2siLCJTbG93TW8iLCJsaW5lYXJSYXRpbyIsInBvd2VyIiwieW95b01vZGUiLCJfcCIsIl9wMyIsIlN0ZXBwZWRFYXNlIiwiUm91Z2hFYXNlIiwiX2NyZWF0ZUVsYXN0aWMiLCJ0YXBlciIsInBvaW50cyIsInJhbmRvbWl6ZSIsImNsYW1wIiwidGVtcGxhdGUiLCJzdHJlbmd0aCIsImJ1bXAiLCJwbnQiLCJkZWYiLCJhbXBsaXR1ZGUiLCJwZXJpb2QiLCJhc2luIiwibW9kdWxlTmFtZSIsIl9uYW1lc3BhY2UiLCJucyIsIl9lbXB0eUZ1bmMiLCJhcnJheSIsIl90aWNrZXIiLCJfdGlja2VyQWN0aXZlIiwiX2RlZkxvb2t1cCIsIkRlZmluaXRpb24iLCJkZXBlbmRlbmNpZXMiLCJzYyIsImdzQ2xhc3MiLCJfY2xhc3NlcyIsIm1pc3NpbmciLCJjbCIsImhhc01vZHVsZSIsIkdyZWVuU29ja0FNRFBhdGgiLCJfYmFzZVBhcmFtcyIsImV4dHJhUGFyYW1zIiwiX3R5cGUiLCJfcG93ZXIiLCJfcGFyYW1zIiwiX2Vhc2VNYXAiLCJuYW1lcyIsImNyZWF0ZSIsIm5hIiwidGEiLCJwdyIsIkxpbmVhciIsIlF1YWQiLCJFdmVudERpc3BhdGNoZXIiLCJfbGlzdGVuZXJzIiwiX2V2ZW50VGFyZ2V0IiwidXNlUGFyYW0iLCJsaXN0ZW5lciIsInVwIiwid2FrZSIsImRpc3BhdGNoRXZlbnQiLCJfcmVxQW5pbUZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX2NhbmNlbEFuaW1GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiX2dldFRpbWUiLCJnZXRUaW1lIiwiX2xhc3RVcGRhdGUiLCJmcHMiLCJ1c2VSQUYiLCJfc2VsZiIsIl91c2VSQUYiLCJfbGFnVGhyZXNob2xkIiwiX2FkanVzdGVkTGFnIiwiX3RpY2tXb3JkIiwiX2ZwcyIsIl9yZXEiLCJfaWQiLCJfZ2FwIiwiX25leHRUaW1lIiwiX3RpY2siLCJtYW51YWwiLCJlbGFwc2VkIiwiYWRqdXN0ZWRMYWciLCJzbGVlcCIsInZpc2liaWxpdHlTdGF0ZSIsIlRpY2tlciIsInJldmVyc2VkIiwiX2NoZWNrVGltZW91dCIsImF0VGltZSIsInJlc3VtZSIsInJlc3RhcnQiLCJpbmNsdWRlRGVsYXkiLCJpbmNsdWRlU2VsZiIsImV2ZW50Q2FsbGJhY2siLCJpbmNsdWRlUmVwZWF0cyIsInBhdXNlVGltZSIsInByZXZUd2VlbiIsInN0IiwidGFyZyIsIl9vdmVyd3JpdGUiLCJfb3ZlcndyaXRlTG9va3VwIiwiZGVmYXVsdE92ZXJ3cml0ZSIsIl9zaWJsaW5ncyIsIl9yZWdpc3RlciIsIl9hcHBseU92ZXJ3cml0ZSIsIl9wbHVnaW5zIiwiX292ZXJ3cml0dGVuUHJvcHMiLCJkZWZhdWx0RWFzZSIsImF1dG9TbGVlcCIsIl9sYXp5TG9va3VwIiwiX251bWJlcnNFeHAiLCJfc2V0UmF0aW8iLCJmcCIsIl9ibG9iRGlmIiwic3RhcnROdW1zIiwiZW5kTnVtcyIsIm5vbk51bWJlcnMiLCJjdXJyZW50TnVtIiwiX2FkZFByb3BUd2VlbiIsImZ1bmNQYXJhbSIsInN0cmluZ0ZpbHRlciIsImdldHRlck5hbWUiLCJibG9iRGlmIiwiX3R3ZWVuTG9va3VwIiwiX3R3ZWVuTG9va3VwTnVtIiwib25VcGRhdGVQYXJhbXMiLCJvblVwZGF0ZVNjb3BlIiwib25TdGFydFBhcmFtcyIsIm9uU3RhcnRTY29wZSIsIm9uUmV2ZXJzZUNvbXBsZXRlU2NvcGUiLCJvblJlcGVhdFBhcmFtcyIsIm9uUmVwZWF0U2NvcGUiLCJlYXNlUGFyYW1zIiwiYXV0b0NTUyIsIm9uT3ZlcndyaXRlIiwibm9uZSIsImF1dG8iLCJjb25jdXJyZW50IiwiYWxsT25TdGFydCIsIl9uZXh0R0NGcmFtZSIsIl91cGRhdGVSb290Iiwic2NydWIiLCJfZ3NUd2VlbklEIiwiX29uT3ZlcndyaXRlIiwib3ZlcndyaXR0ZW5Ud2VlbiIsIm92ZXJ3cml0aW5nVHdlZW4iLCJraWxsZWRQcm9wcyIsIm1vZGUiLCJjdXJUd2VlbiIsIm92ZXJsYXBzIiwib0NvdW50IiwiemVyb0R1ciIsImdsb2JhbFN0YXJ0IiwiX2NoZWNrT3ZlcmxhcCIsInJlZmVyZW5jZSIsInRzIiwiaW5pdFBsdWdpbnMiLCJzdGFydFZhcnMiLCJfaW5pdFByb3BzIiwicHJvcExvb2t1cCIsIm92ZXJ3cml0dGVuUHJvcHMiLCJfcHJpb3JpdHkiLCJfb25EaXNhYmxlIiwiX29uRW5hYmxlIiwic2ltdWx0YW5lb3VzT3ZlcndyaXRlIiwia2lsbFByb3BzIiwicmVjb3JkIiwia2lsbGVkIiwiX3RlbXBLaWxsIiwib25seUFjdGl2ZSIsIl9wcm9wTmFtZSIsIm92ZXJ3cml0ZVByb3BzIiwiaW5pdEFsbCIsIlBsdWdpbiIsIlNjcm9sbE1hZ2ljIiwiX3V0aWwiLCJQSU5fU1BBQ0VSX0FUVFJJQlVURSIsIkNvbnRyb2xsZXIiLCJOQU1FU1BBQ0UiLCJTQ1JPTExfRElSRUNUSU9OX0ZPUldBUkQiLCJTQ1JPTExfRElSRUNUSU9OX1JFVkVSU0UiLCJTQ1JPTExfRElSRUNUSU9OX1BBVVNFRCIsIkRFRkFVTFRfT1BUSU9OUyIsIkNPTlRST0xMRVJfT1BUSU9OUyIsIl9vcHRpb25zIiwiX3NjZW5lT2JqZWN0cyIsIl91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSIsIl9zY3JvbGxQb3MiLCJfc2Nyb2xsRGlyZWN0aW9uIiwiX2lzRG9jdW1lbnQiLCJfdmlld1BvcnRTaXplIiwiX3VwZGF0ZVRpbWVvdXQiLCJfcmVmcmVzaFRpbWVvdXQiLCJjb25zdHJ1Y3QiLCJnZXRWaWV3cG9ydFNpemUiLCJvbkNoYW5nZSIsInJlZnJlc2hJbnRlcnZhbCIsInNjaGVkdWxlUmVmcmVzaCIsInJlZnJlc2giLCJnZXRTY3JvbGxQb3MiLCJ2ZXJ0aWNhbCIsInNldFNjcm9sbFBvcyIsIl9zZXRTY3JvbGxQb3MiLCJ1cGRhdGVTY2VuZXMiLCJzY2VuZXNUb1VwZGF0ZSIsIm9sZFNjcm9sbFBvcyIsInNjcm9sbFBvcyIsImRlbHRhU2Nyb2xsIiwiZm9yRWFjaCIsInNjZW5lIiwidXBkYXRlIiwibG9nbGV2ZWwiLCJkZWJvdW5jZVVwZGF0ZSIsInJBRiIsInJlc2l6ZUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsIm91dHB1dCIsInNvcnRTY2VuZXMiLCJTY2VuZXNBcnJheSIsInNjZW5lcyIsInNjcm9sbE9mZnNldCIsImFkZFNjZW5lIiwibmV3U2NlbmUiLCJTY2VuZSIsImNvbnRyb2xsZXIiLCJhZGRUbyIsImdsb2JhbFNjZW5lT3B0aW9ucyIsInJlbW92ZVNjZW5lIiwidXBkYXRlU2NlbmUiLCJpbW1lZGlhdGVseSIsInNjcm9sbFRhcmdldCIsImFkZGl0aW9uYWxQYXJhbWV0ZXIiLCJGdW5jdGlvbiIsImhhc0F0dHJpYnV0ZSIsImNvbnRhaW5lck9mZnNldCIsImVsZW1lbnRPZmZzZXQiLCJzY3JvbGxQb3NNZXRob2QiLCJpbmZvIiwiYWJvdXQiLCJzY3JvbGxEaXJlY3Rpb24iLCJpc0RvY3VtZW50IiwibmV3TG9nbGV2ZWwiLCJuZXdTdGF0ZSIsImRlc3Ryb3kiLCJyZXNldFNjZW5lcyIsImNBRiIsImFkZE9wdGlvbiIsImV4dGVuc2lvbiIsIm9sZENsYXNzIiwiJHN1cGVyIiwiU0NFTkVfU1RBVEVfQkVGT1JFIiwiU0NFTkVfU1RBVEVfRFVSSU5HIiwiU0NFTkVfU1RBVEVfQUZURVIiLCJTQ0VORV9PUFRJT05TIiwiX3N0YXRlIiwiX3Byb2dyZXNzIiwiX3Njcm9sbE9mZnNldCIsIl90cmlnZ2VyUG9zIiwiX2R1cmF0aW9uVXBkYXRlTWV0aG9kIiwiX2NvbnRyb2xsZXIiLCJvcHRpb25OYW1lIiwiYWRkU2NlbmVPcHRpb24iLCJ2YWxpZGF0ZU9wdGlvbiIsImZ1bGxuYW1lIiwibmFtZXBhcnRzIiwiZXZlbnRuYW1lIiwicmVtb3ZlTGlzdCIsImxpc3RlbmVycyIsInVwZGF0ZVRyaWdnZXJFbGVtZW50UG9zaXRpb24iLCJ1cGRhdGVTY3JvbGxPZmZzZXQiLCJ1cGRhdGVEdXJhdGlvbiIsIm9uQ29udGFpbmVyUmVzaXplIiwidG1wUGFyZW50IiwibmV3UHJvZ3Jlc3MiLCJzdGFydFBvcyIsImVuZFBvcyIsIl9waW4iLCJ1cGRhdGVQaW5TdGF0ZSIsImRvVXBkYXRlIiwib2xkU3RhdGUiLCJyZXZlcnNlT3JGb3J3YXJkIiwiZXZlbnRWYXJzIiwic3RhdGVDaGFuZ2VkIiwiZXZlbnROYW1lIiwidHJpZ2dlckVsZW1lbnQiLCJ0cmlnZ2VySG9vayIsInZhcm5hbWUiLCJjaGFuZ2VPcHRpb24iLCJuZXd2YWwiLCJyZWFzb24iLCJlbGVtZW50UG9zIiwidGVsZW0iLCJjb250cm9sbGVySW5mbyIsIl92YWxpZGF0ZSIsInZhbGlkYXRlIiwicGVyYyIsImxvZ01TRyIsIm1lc3NhZ2UiLCJvbGR2YWwiLCJuZXdWYWwiLCJzaGlmdHMiLCJ0cmlnZ2VyUG9zaXRpb24iLCJfcGluT3B0aW9ucyIsImR1cmF0aW9uQ2hhbmdlZCIsInVwZGF0ZVBpbkRpbWVuc2lvbnMiLCJyZW1vdmVQaW4iLCJmb3JjZVVucGluIiwiY29udGFpbmVySW5mbyIsInBpblRhcmdldCIsInNwYWNlciIsImZpeGVkUG9zIiwic2Nyb2xsRGlzdGFuY2UiLCJuZXdDU1MiLCJpbkZsb3ciLCJjaGFuZ2UiLCJwdXNoRm9sbG93ZXJzIiwiZHVyaW5nIiwibWFyZ2luQ29sbGFwc2UiLCJpc01hcmdpbkNvbGxhcHNlVHlwZSIsInJlbFNpemUiLCJhdXRvRnVsbFdpZHRoIiwidXBkYXRlUGluSW5Db250YWluZXIiLCJ1cGRhdGVSZWxhdGl2ZVBpblNwYWNlciIsIm9uTW91c2V3aGVlbE92ZXJQaW4iLCJ3aGVlbERlbHRhIiwiZGV0YWlsIiwic2V0UGluIiwiZGVmYXVsdFNldHRpbmdzIiwic3BhY2VyQ2xhc3MiLCJwYXJlbnREaXNwbGF5IiwiYm91bmRzUGFyYW1zIiwicGluQ1NTIiwic2l6ZUNTUyIsInNwYWNlckNTUyIsImJveFNpemluZyIsIm1vekJveFNpemluZyIsIndlYmtpdEJveFNpemluZyIsIl9fX29yaWdTdHlsZSIsInBpbklubGluZUNTUyIsImNvcHlTdHlsZXMiLCJtYXJnaW5zIiwiX2Nzc0NsYXNzZXMiLCJfY3NzQ2xhc3NFbGVtcyIsInJlbW92ZUNsYXNzVG9nZ2xlIiwic2V0Q2xhc3NUb2dnbGUiLCJ0cmFuc2xhdGUiLCJ2YWxpZGF0aW9uQ2FsbGJhY2siLCJ0aW1lc3RhbXAiLCJVIiwiZmxvYXR2YWwiLCJudW1iZXIiLCJfZGltZW5zaW9uIiwib3V0ZXIiLCJpbmNsdWRlTWFyZ2luIiwiRG9tRWxlbWVudCIsImRpbWVuc2lvbiIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsIl9jYW1lbENhc2UiLCJsYXN0VGltZSIsInZlbmRvcnMiLCJfcmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX2NhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY3VyclRpbWUiLCJ0aW1lVG9DYWxsIiwibG9nbGV2ZWxzIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsIm8iLCJIVE1MRWxlbWVudCIsIl9nZXQiLCJyZWYiLCJyZWxhdGl2ZVRvVmlld3BvcnQiLCJjbGFzc25hbWUiLCJjbGFzc0xpc3QiLCJhZGRJbmRpY2F0b3JzIiwicmVtb3ZlSW5kaWNhdG9ycyIsInNldFR3ZWVuIiwicmVtb3ZlVHdlZW4iLCJzZXRWZWxvY2l0eSIsInJlbW92ZVZlbG9jaXR5IiwicmVxdWlyZSIsIlRpbWVsaW5lIiwidXBkYXRlVHdlZW5Qcm9ncmVzcyIsInR3ZWVuQ2hhbmdlcyIsIlR3ZWVuT2JqZWN0IiwibmV3VHdlZW4iLCJ0cmlnZ2VyVHdlZW5zIiwidHdlZW52YXJzIiwiY29uZGl0aW9uIiwibmV3Q2FsbGJhY2siLCJ0aGlzVHdlZW4iLCJvbGRDYWxsYmFjayIsImxhenlMb2FkWFQiLCJkYXRhTGF6aWVkIiwibG9hZF9lcnJvciIsImNsYXNzTGF6eUhpZGRlbiIsImRvY0VsZW1lbnQiLCJmb3JjZUxvYWQiLCJvbnNjcm9sbCIsIm9wZXJhbWluaSIsImF1dG9Jbml0IiwiYmxhbmtJbWFnZSIsInRocm90dGxlIiwibG9hZEV2ZW50IiwidXBkYXRlRXZlbnQiLCJmb3JjZUV2ZW50Iiwib25pbml0Iiwib25zaG93IiwiY2hlY2tEdXBsaWNhdGVzIiwiZWxlbWVudE9wdGlvbnMiLCJzcmNBdHRyIiwiZWRnZVgiLCJlZGdlWSIsInZpc2libGVPbmx5IiwiJHdpbmRvdyIsIiRpc0Z1bmN0aW9uIiwiJGV4dGVuZCIsIiRkYXRhIiwiJGNvbnRhaW5zIiwidG9wTGF6eSIsIndhaXRpbmdNb2RlIiwiZ2V0T3JEZWYiLCJzY3JvbGwiLCJvdmVycmlkZXMiLCJzY3JvbGxDb250YWluZXIiLCJlbGVtZW50T3B0aW9uc092ZXJyaWRlcyIsInF1ZXVlQ2hlY2tMYXp5RWxlbWVudHMiLCIkZWwiLCJ0YWdOYW1lIiwidHJpZ2dlckV2ZW50IiwidHJpZ2dlckxvYWRPckVycm9yIiwiY2hlY2tMYXp5RWxlbWVudHMiLCJJbmZpbml0eSIsInZpZXdwb3J0VG9wIiwidmlld3BvcnRIZWlnaHQiLCJpbm5lckhlaWdodCIsInZpZXdwb3J0V2lkdGgiLCJpbm5lcldpZHRoIiwib2JqRGF0YSIsInJlbW92ZU5vZGUiLCJ0b3BFZGdlIiwiZWxQb3MiLCJ0aW1lb3V0TGF6eUVsZW1lbnRzIiwiaW5pdExhenlFbGVtZW50cyIsImZvcmNlTG9hZEFsbCIsIlplcHRvIiwiYXV0b0xvYWRUaW1lIiwiYmdBdHRyIiwiJHRoaXMiLCJGT1VOREFUSU9OX1ZFUlNJT04iLCJGb3VuZGF0aW9uIiwiX3V1aWRzIiwicnRsIiwiZnVuY3Rpb25OYW1lIiwiYXR0ck5hbWUiLCJoeXBoZW5hdGUiLCJyZWdpc3RlclBsdWdpbiIsInV1aWQiLCJHZXRZb0RpZ2l0cyIsIiRlbGVtZW50IiwidW5yZWdpc3RlclBsdWdpbiIsInJlSW5pdCIsImlzSlEiLCJfdGhpcyIsInBsZ3MiLCJmb3VuZGF0aW9uIiwicmVmbG93IiwiJGVsZW0iLCJ3YXJuIiwidGhpbmciLCJwYXJzZVZhbHVlIiwiZXIiLCJnZXRGbk5hbWUiLCJ0cmFuc2l0aW9uZW5kIiwidHJhbnNpdGlvbnMiLCJ1dGlsIiwiJG1ldGEiLCIkbm9KUyIsIk1lZGlhUXVlcnkiLCJwbHVnQ2xhc3MiLCJSZWZlcmVuY2VFcnJvciIsIlR5cGVFcnJvciIsInZwIiwibmV4dFRpbWUiLCJwZXJmb3JtYW5jZSIsIm9UaGlzIiwiYUFyZ3MiLCJmVG9CaW5kIiwiZk5PUCIsImZCb3VuZCIsImZ1bmNOYW1lUmVnZXgiLCJCb3giLCJJbU5vdFRvdWNoaW5nWW91IiwiR2V0RGltZW5zaW9ucyIsIkdldE9mZnNldHMiLCJsck9ubHkiLCJ0Yk9ubHkiLCJlbGVEaW1zIiwicGFyRGltcyIsIndpbmRvd0RpbXMiLCJhbGxEaXJzIiwicGFyUmVjdCIsIndpblJlY3QiLCJ3aW5ZIiwid2luWCIsInBhcmVudERpbXMiLCJhbmNob3IiLCJ2T2Zmc2V0IiwiaE9mZnNldCIsImlzT3ZlcmZsb3ciLCIkZWxlRGltcyIsIiRhbmNob3JEaW1zIiwia2V5Q29kZXMiLCJjb21tYW5kcyIsIktleWJvYXJkIiwiZ2V0S2V5Q29kZXMiLCJwYXJzZUtleSIsInNoaWZ0S2V5IiwiY3RybEtleSIsImFsdEtleSIsImhhbmRsZUtleSIsImNvbXBvbmVudCIsImZ1bmN0aW9ucyIsImNvbW1hbmRMaXN0IiwiY21kcyIsImNvbW1hbmQiLCJsdHIiLCJoYW5kbGVkIiwidW5oYW5kbGVkIiwiZmluZEZvY3VzYWJsZSIsImNvbXBvbmVudE5hbWUiLCJrY3MiLCJrYyIsImRlZmF1bHRRdWVyaWVzIiwibGFuZHNjYXBlIiwicG9ydHJhaXQiLCJyZXRpbmEiLCJxdWVyaWVzIiwiZXh0cmFjdGVkU3R5bGVzIiwibmFtZWRRdWVyaWVzIiwicGFyc2VTdHlsZVRvT2JqZWN0IiwiX2dldEN1cnJlbnRTaXplIiwiX3dhdGNoZXIiLCJhdExlYXN0IiwicXVlcnkiLCJtYXRjaE1lZGlhIiwibmV3U2l6ZSIsInN0eWxlTWVkaWEiLCJtZWRpYSIsIm1hdGNoTWVkaXVtIiwic3R5bGVTaGVldCIsInN0eWxlT2JqZWN0IiwicmVkdWNlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaW5pdENsYXNzZXMiLCJhY3RpdmVDbGFzc2VzIiwiTW90aW9uIiwiYW5pbWF0ZUluIiwiY2IiLCJhbmltYXRlT3V0IiwiTW92ZSIsInByb2ciLCJtb3ZlIiwiaXNJbiIsImluaXRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiTmVzdCIsIkZlYXRoZXIiLCJtZW51IiwiaXRlbXMiLCJzdWJNZW51Q2xhc3MiLCJzdWJJdGVtQ2xhc3MiLCJoYXNTdWJDbGFzcyIsIiRpdGVtIiwiJHN1YiIsIkJ1cm4iLCJUaW1lciIsIm5hbWVTcGFjZSIsInJlbWFpbiIsImlzUGF1c2VkIiwiaW5maW5pdGUiLCJvbkltYWdlc0xvYWRlZCIsImltYWdlcyIsInVubG9hZGVkIiwic2luZ2xlSW1hZ2VMb2FkZWQiLCJuYXR1cmFsV2lkdGgiLCJzcG90U3dpcGUiLCJtb3ZlVGhyZXNob2xkIiwidGltZVRocmVzaG9sZCIsInN0YXJ0UG9zWCIsInN0YXJ0UG9zWSIsImVsYXBzZWRUaW1lIiwiaXNNb3ZpbmciLCJvblRvdWNoRW5kIiwib25Ub3VjaE1vdmUiLCJ0b3VjaGVzIiwib25Ub3VjaFN0YXJ0Iiwic3dpcGUiLCJhZGRUb3VjaCIsImhhbmRsZVRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJldmVudFR5cGVzIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwic2ltdWxhdGVkRXZlbnQiLCJNb3VzZUV2ZW50Iiwic2NyZWVuWCIsInNjcmVlblkiLCJpbml0TW91c2VFdmVudCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJwcmVmaXhlcyIsInRyaWdnZXJzIiwiY2hlY2tMaXN0ZW5lcnMiLCJldmVudHNMaXN0ZW5lciIsInJlc2l6ZUxpc3RlbmVyIiwic2Nyb2xsTGlzdGVuZXIiLCJjbG9zZW1lTGlzdGVuZXIiLCJ5ZXRpQm94ZXMiLCJwbHVnTmFtZXMiLCJwbHVnaW5JZCIsImRlYm91bmNlIiwiJG5vZGVzIiwibGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbiIsIm11dGF0aW9uUmVjb3Jkc0xpc3QiLCIkdGFyZ2V0IiwiZWxlbWVudE9ic2VydmVyIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJzdWJ0cmVlIiwiYXR0cmlidXRlRmlsdGVyIiwiSUhlYXJZb3UiLCJqUXVlcnlCcmlkZ2V0IiwiYXJyYXlTbGljZSIsImxvZ0Vycm9yIiwiUGx1Z2luQ2xhc3MiLCJhcmcwIiwibWV0aG9kQ2FsbCIsInBsYWluQ2FsbCIsIiRlbGVtcyIsIm1ldGhvZE5hbWUiLCJwbHVnaW5NZXRob2RTdHIiLCJpbnN0YW5jZSIsInVwZGF0ZUpRdWVyeSIsImJyaWRnZXQiLCJFdkVtaXR0ZXIiLCJwcm90byIsIl9ldmVudHMiLCJvbmNlRXZlbnRzIiwiX29uY2VFdmVudHMiLCJvbmNlTGlzdGVuZXJzIiwiZW1pdEV2ZW50IiwiaXNPbmNlIiwiZ2V0U2l6ZSIsImdldFN0eWxlU2l6ZSIsImlzVmFsaWQiLCJtZWFzdXJlbWVudHMiLCJtZWFzdXJlbWVudHNMZW5ndGgiLCJnZXRaZXJvU2l6ZSIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsIm1lYXN1cmVtZW50IiwiaXNTZXR1cCIsImlzQm94U2l6ZU91dGVyIiwiYm9yZGVyU3R5bGUiLCJib3JkZXJXaWR0aCIsInF1ZXJ5U2VsZWN0b3IiLCJwYWRkaW5nV2lkdGgiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdIZWlnaHQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsIm1hcmdpbldpZHRoIiwibWFyZ2luSGVpZ2h0IiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlckhlaWdodCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJpc0JvcmRlckJveFNpemVPdXRlciIsInN0eWxlV2lkdGgiLCJzdHlsZUhlaWdodCIsIm1hdGNoZXNNZXRob2QiLCJFbGVtUHJvdG8iLCJFbGVtZW50IiwiZml6enlVSVV0aWxzIiwidXRpbHMiLCJtb2R1bG8iLCJhcnkiLCJyZW1vdmVGcm9tIiwiZ2V0UGFyZW50IiwiZ2V0UXVlcnlFbGVtZW50IiwiaGFuZGxlRXZlbnQiLCJmaWx0ZXJGaW5kRWxlbWVudHMiLCJmZkVsZW1zIiwiY2hpbGRFbGVtcyIsImRlYm91bmNlTWV0aG9kIiwidGltZW91dE5hbWUiLCJkb2NSZWFkeSIsInRvRGFzaGVkIiwiJDIiLCJodG1sSW5pdCIsIldpZGdldENsYXNzIiwiZGFzaGVkTmFtZXNwYWNlIiwiZGF0YUF0dHJFbGVtcyIsImpzRGFzaEVsZW1zIiwiZGF0YU9wdGlvbnNBdHRyIiwiT3V0bGF5ZXIiLCJJdGVtIiwiaXNFbXB0eU9iaiIsImRvY0VsZW1TdHlsZSIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb24iLCJ0cmFuc2Zvcm1Qcm9wZXJ0eSIsInRyYW5zaXRpb25FbmRFdmVudCIsIldlYmtpdFRyYW5zaXRpb24iLCJ2ZW5kb3JQcm9wZXJ0aWVzIiwidHJhbnNpdGlvbkRlbGF5IiwibGF5b3V0IiwiX3RyYW5zbiIsImluZ1Byb3BlcnRpZXMiLCJjbGVhbiIsIm9uRW5kIiwiZWxlbVN0eWxlIiwic3VwcG9ydGVkUHJvcCIsImdldFBvc2l0aW9uIiwiaXNPcmlnaW5MZWZ0IiwiX2dldE9wdGlvbiIsImlzT3JpZ2luVG9wIiwieFZhbHVlIiwieVZhbHVlIiwibGF5b3V0U2l6ZSIsImxheW91dFBvc2l0aW9uIiwieFBhZGRpbmciLCJ4UHJvcGVydHkiLCJ4UmVzZXRQcm9wZXJ0eSIsImdldFhWYWx1ZSIsInlQYWRkaW5nIiwieVByb3BlcnR5IiwieVJlc2V0UHJvcGVydHkiLCJnZXRZVmFsdWUiLCJpc0hvcml6b250YWwiLCJwZXJjZW50UG9zaXRpb24iLCJfdHJhbnNpdGlvblRvIiwiY3VyWCIsImN1clkiLCJjb21wYXJlWCIsImNvbXBhcmVZIiwiZGlkTm90TW92ZSIsInNldFBvc2l0aW9uIiwiaXNUcmFuc2l0aW9uaW5nIiwidHJhbnNYIiwidHJhbnNZIiwidHJhbnNpdGlvblN0eWxlIiwiZ2V0VHJhbnNsYXRlIiwib25UcmFuc2l0aW9uRW5kIiwiaXNDbGVhbmluZyIsImdvVG8iLCJtb3ZlVG8iLCJfbm9uVHJhbnNpdGlvbiIsIl9yZW1vdmVTdHlsZXMiLCJfdHJhbnNpdGlvbiIsImVuYWJsZVRyYW5zaXRpb24iLCJ0b0Rhc2hlZEFsbCIsInRyYW5zaXRpb25Qcm9wcyIsInN0YWdnZXJEZWxheSIsIm9ud2Via2l0VHJhbnNpdGlvbkVuZCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ub3RyYW5zaXRpb25lbmQiLCJkYXNoZWRWZW5kb3JQcm9wZXJ0aWVzIiwicHJvcGVydHlOYW1lIiwiZGlzYWJsZVRyYW5zaXRpb24iLCJyZW1vdmVUcmFuc2l0aW9uU3R5bGVzIiwiY2xlYW5TdHlsZSIsImNsZWFuVHJhbnNpdGlvblN0eWxlIiwicmVtb3ZlRWxlbSIsInJldmVhbCIsInRyYW5zaXRpb25FbmRQcm9wZXJ0eSIsImdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkiLCJvblJldmVhbFRyYW5zaXRpb25FbmQiLCJoaWRkZW5TdHlsZSIsInZpc2libGVTdHlsZSIsInN0eWxlUHJvcGVydHkiLCJvcHRpb25TdHlsZSIsIm9uSGlkZVRyYW5zaXRpb25FbmQiLCJHVUlEIiwiaW5zdGFuY2VzIiwicXVlcnlFbGVtZW50Iiwib3V0bGF5ZXJHVUlEIiwiaXNJbml0TGF5b3V0IiwiY29udGFpbmVyU3R5bGUiLCJpbml0TGF5b3V0Iiwib3JpZ2luTGVmdCIsIm9yaWdpblRvcCIsInJlc2l6ZSIsInJlc2l6ZUNvbnRhaW5lciIsIm9sZE9wdGlvbiIsImNvbXBhdE9wdGlvbnMiLCJob3Jpem9udGFsIiwibGF5b3V0SW5zdGFudCIsInJlbG9hZEl0ZW1zIiwic3RhbXBzIiwic3RhbXAiLCJjYW5CaW5kUmVzaXplIiwiYmluZFJlc2l6ZSIsIl9pdGVtaXplIiwiaXRlbUVsZW1zIiwiX2ZpbHRlckZpbmRJdGVtRWxlbWVudHMiLCJpdGVtIiwiaXRlbVNlbGVjdG9yIiwiZ2V0SXRlbUVsZW1lbnRzIiwiX3Jlc2V0TGF5b3V0IiwiX21hbmFnZVN0YW1wcyIsImlzSW5zdGFudCIsIl9pc0xheW91dEluaXRlZCIsImxheW91dEl0ZW1zIiwiX2dldE1lYXN1cmVtZW50IiwiX2dldEl0ZW1zRm9yTGF5b3V0IiwiX2xheW91dEl0ZW1zIiwiX3Bvc3RMYXlvdXQiLCJpc0lnbm9yZWQiLCJfZW1pdENvbXBsZXRlT25JdGVtcyIsIl9nZXRJdGVtTGF5b3V0UG9zaXRpb24iLCJpc0xheW91dEluc3RhbnQiLCJfcHJvY2Vzc0xheW91dFF1ZXVlIiwidXBkYXRlU3RhZ2dlciIsIl9wb3NpdGlvbkl0ZW0iLCJpc1Jlc2l6aW5nQ29udGFpbmVyIiwiX2dldENvbnRhaW5lclNpemUiLCJfc2V0Q29udGFpbmVyTWVhc3VyZSIsIm1lYXN1cmUiLCJpc1dpZHRoIiwiZWxlbVNpemUiLCJkb25lQ291bnQiLCJlbWl0QXJncyIsIiRldmVudCIsImdldEl0ZW0iLCJ1bmlnbm9yZSIsIl9maW5kIiwidW5zdGFtcCIsIl9nZXRCb3VuZGluZ1JlY3QiLCJfbWFuYWdlU3RhbXAiLCJib3VuZGluZ1JlY3QiLCJfYm91bmRpbmdSZWN0IiwiX2dldEVsZW1lbnRPZmZzZXQiLCJ0aGlzUmVjdCIsImlzUmVzaXplQm91bmQiLCJ1bmJpbmRSZXNpemUiLCJvbnJlc2l6ZSIsIm5lZWRzUmVzaXplTGF5b3V0IiwiaGFzU2l6ZXMiLCJhZGRJdGVtcyIsImFwcGVuZGVkIiwicHJlcGVuZGVkIiwicHJldmlvdXNJdGVtcyIsInJldmVhbEl0ZW1FbGVtZW50cyIsImdldEl0ZW1zIiwiaGlkZUl0ZW1FbGVtZW50cyIsInJlbW92ZUl0ZW1zIiwiTGF5b3V0Iiwic3ViY2xhc3MiLCJQYXJlbnQiLCJTdWJDbGFzcyIsIm1zVW5pdHMiLCJtcyIsIk1hc29ucnkiLCJmaXRXaWR0aCIsIm1lYXN1cmVDb2x1bW5zIiwiY29sWXMiLCJjb2xzIiwibWF4WSIsImdldENvbnRhaW5lcldpZHRoIiwiY29sdW1uV2lkdGgiLCJmaXJzdEl0ZW0iLCJmaXJzdEl0ZW1FbGVtIiwiY29udGFpbmVyV2lkdGgiLCJndXR0ZXIiLCJtYXRoTWV0aG9kIiwiaXNGaXRXaWR0aCIsInJlbWFpbmRlciIsImNvbFNwYW4iLCJjb2xHcm91cCIsIl9nZXRDb2xHcm91cCIsIm1pbmltdW1ZIiwic2hvcnRDb2xJbmRleCIsInNldEhlaWdodCIsInNldFNwYW4iLCJncm91cENvdW50IiwiZ3JvdXBDb2xZcyIsInN0YW1wU2l6ZSIsImZpcnN0WCIsImxhc3RYIiwiZmlyc3RDb2wiLCJmbG9vciIsImxhc3RDb2wiLCJzdGFtcE1heFkiLCJfZ2V0Q29udGFpbmVyRml0V2lkdGgiLCJ1bnVzZWRDb2xzIiwicHJldmlvdXNXaWR0aCIsIlNpdGUiLCJzY3JvbGxtYWdpYyIsImdyaWQiLCJ3aW5kb3dIZWlnaHQiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7O0FBY0MsV0FBVUEsTUFBVixFQUFrQkMsT0FBbEIsRUFBNEI7O0FBRTVCLEtBQUssT0FBT0MsTUFBUCxLQUFrQixRQUFsQixJQUE4QixPQUFPQSxPQUFPQyxPQUFkLEtBQTBCLFFBQTdELEVBQXdFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FELFNBQU9DLE9BQVAsR0FBaUJILE9BQU9JLFFBQVAs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LElBQUw7QUFDQSxDQUZEOztBQUlBLElBQUlvdUYsT0FBTztBQUNWcHVGLE9BQU0sWUFBVztBQUNoQixNQUFLMGpDLEVBQUUza0MsTUFBRixFQUFVdXRCLEtBQVYsS0FBb0IsR0FBekIsRUFBK0I7QUFDOUI4aEUsUUFBS0MsV0FBTDtBQUNBO0FBQ0RELE9BQUtFLElBQUw7QUFDQSxFQU5TO0FBT1ZELGNBQWEsWUFBVztBQUN2QjtBQUNBLE1BQUkxcUIsYUFBYSxJQUFJckQsWUFBWUcsVUFBaEIsRUFBakI7QUFDQSxNQUFJNFosU0FBUzMyQyxFQUFFLFdBQUYsQ0FBYjtBQUNBLE1BQUk2cUQsZUFBZTdxRCxFQUFFM2tDLE1BQUYsRUFBVXl5QixNQUFWLEVBQW5COztBQUVBa1MsSUFBRXJpQyxJQUFGLENBQU9nNUUsTUFBUCxFQUFlLFVBQVNoaUUsS0FBVCxFQUFnQnBGLEtBQWhCLEVBQXNCO0FBQ3BDO0FBQ0EsT0FBSTZNLFFBQVEsSUFBSXdrQixTQUFTb0YsTUFBYixDQUFvQnoyQixLQUFwQixFQUEyQixDQUEzQixFQUE4QixFQUFFNnlDLFdBQVcsa0JBQWIsRUFBOUIsRUFBaUUsRUFBRUEsV0FBVyxrQkFBYixFQUFqRSxDQUFaOztBQUVBLE9BQUkyYyxRQUFRLElBQUluQyxZQUFZb0QsS0FBaEIsQ0FBc0I7QUFDaENqekMsY0FBVTg5RCxlQUFhLENBRFM7QUFFaENobkIsb0JBQWdCdDBELEtBRmdCO0FBR2hDdTBELGlCQUFhO0FBSG1CLElBQXRCLEVBT1Y4RixRQVBVLENBT0F4dEQsS0FQQSxFQVFWOGpELEtBUlUsQ0FRSkQsVUFSSSxDQUFaO0FBU0EsR0FiRDtBQWNBO0FBM0JTLENBQVgiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYyLjIuM1xuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA0LTA1VDE5OjI2WlxuICovXG5cbihmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXG4vLyBDYW4ndCBiZSBpbiBzdHJpY3QgbW9kZSwgc2V2ZXJhbCBsaWJzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXG4vLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcbi8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCBcInVzZSBzdHJpY3RcIiBjYWxsIGNoYWlucy4gKCMxMzMzNSlcbi8vXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMi4yLjNcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjFcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIlwiLFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblx0XHRyZXR1cm4gbnVtICE9IG51bGwgP1xuXG5cdFx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0XHQoIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF0gKSA6XG5cblx0XHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRcdHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cdFx0cmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdC8vIGFkZGluZyAxIGNvcnJlY3RzIGxvc3Mgb2YgcHJlY2lzaW9uIGZyb20gcGFyc2VGbG9hdCAoIzE1MTAwKVxuXHRcdHZhciByZWFsU3RyaW5nT2JqID0gb2JqICYmIG9iai50b1N0cmluZygpO1xuXHRcdHJldHVybiAhalF1ZXJ5LmlzQXJyYXkoIG9iaiApICYmICggcmVhbFN0cmluZ09iaiAtIHBhcnNlRmxvYXQoIHJlYWxTdHJpbmdPYmogKSArIDEgKSA+PSAwO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxuXHRcdC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFwiW29iamVjdCBPYmplY3RdXCJcblx0XHQvLyAtIERPTSBub2Rlc1xuXHRcdC8vIC0gd2luZG93XG5cdFx0aWYgKCBqUXVlcnkudHlwZSggb2JqICkgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRcdGlmICggb2JqLmNvbnN0cnVjdG9yICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbCggb2JqLCBcImNvbnN0cnVjdG9yXCIgKSAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwoIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwge30sIFwiaXNQcm90b3R5cGVPZlwiICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG5cdFx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd25cblx0XHRmb3IgKCBrZXkgaW4gb2JqICkge31cblxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMCwgaU9TPDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0dmFyIHNjcmlwdCxcblx0XHRcdGluZGlyZWN0ID0gZXZhbDtcblxuXHRcdGNvZGUgPSBqUXVlcnkudHJpbSggY29kZSApO1xuXG5cdFx0aWYgKCBjb2RlICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxuXHRcdFx0Ly8gc3RyaWN0IG1vZGUgcHJhZ21hLCBleGVjdXRlIGNvZGUgYnkgaW5qZWN0aW5nIGFcblx0XHRcdC8vIHNjcmlwdCB0YWcgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpZiAoIGNvZGUuaW5kZXhPZiggXCJ1c2Ugc3RyaWN0XCIgKSA9PT0gMSApIHtcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXHRcdFx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGF2b2lkIHRoZSBET00gbm9kZSBjcmVhdGlvbiwgaW5zZXJ0aW9uXG5cdFx0XHRcdC8vIGFuZCByZW1vdmFsIGJ5IHVzaW5nIGFuIGluZGlyZWN0IGdsb2JhbCBldmFsXG5cblx0XHRcdFx0aW5kaXJlY3QoIGNvZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbi8vIEpTSGludCB3b3VsZCBlcnJvciBvbiB0aGlzIGNvZGUgZHVlIHRvIHRoZSBTeW1ib2wgbm90IGJlaW5nIGRlZmluZWQgaW4gRVM1LlxuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmpzaGludHJjIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8ganVzdCBkaXNhYmxlIEpTSGludCBmb3IgdGhlc2Vcbi8vIHRocmVlIGxpbmVzLlxuLyoganNoaW50IGlnbm9yZTogc3RhcnQgKi9cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cbi8qIGpzaGludCBpZ25vcmU6IGVuZCAqL1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDguMiAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjFcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTUtMTAtMTdcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXHRyZXNjYXBlID0gLyd8XFxcXC9nLFxuXG5cdC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBuaWRzZWxlY3QsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdG5pZHNlbGVjdCA9IHJpZGVudGlmaWVyLnRlc3QoIG5pZCApID8gXCIjXCIgKyBuaWQgOiBcIltpZD0nXCIgKyBuaWQgKyBcIiddXCI7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBuaWRzZWxlY3QgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGRpdiApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZGl2LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZGl2ICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgcGFyZW50LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCAocGFyZW50ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHBhcmVudC50b3AgIT09IHBhcmVudCApIHtcblx0XHQvLyBTdXBwb3J0OiBJRSAxMVxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZGl2LmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gbSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRkaXYucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGRpdiwgXCJkaXZcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGRpdiwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGRpciBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFtcXHctXSspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQmxhY2tiZXJyeSA0LjZcblx0XHRcdFx0XHQvLyBnRUJJRCByZXR1cm5zIG5vZGVzIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKCM2OTYzKVxuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCBwb3MgP1xuXHRcdFx0XHRcdHBvcy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3R3aGl0ZSA9ICggL1xcUysvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCBcInJlamVjdGVkXCIgXSxcblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgaSBdICkgJiYgZm5zWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzID09PSBwcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8XG5cdFx0XHRcdCggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC5cblx0XHRcdC8vIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LlxuXHRcdFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzXG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGksIGNvbnRleHRzLCB2YWx1ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0Y29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG5cblx0XHQvLyBBZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuXHRcdGlmICggIXJlbWFpbmluZyApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoIGZuICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0aWYgKCBqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIgKSB7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlckhhbmRsZXIoIFwicmVhZHlcIiApO1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcblx0XHQvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyBTdXBwb3J0OiBJRTktMTAgb25seVxuXHRcdC8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdFx0XHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHRcdFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHQvKiBqc2hpbnQgLVcwMTggKi9cblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdHJlZ2lzdGVyOiBmdW5jdGlvbiggb3duZXIsIGluaXRpYWwgKSB7XG5cdFx0dmFyIHZhbHVlID0gaW5pdGlhbCB8fCB7fTtcblxuXHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlIHByb3BlcnR5XG5cdFx0Ly8gY29uZmlndXJhYmlsaXR5IG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHQvLyBkZWxldGVkIHdpdGggdGhlIGRlbGV0ZSBvcGVyYXRvclxuXHRcdH0gZWxzZSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdH0sXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdGlmICggIWFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBwcm9wIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBrZXkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHN0b3JlZDtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0c3RvcmVkID0gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblxuXHRcdFx0cmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0c3RvcmVkIDogdGhpcy5nZXQoIG93bmVyLCBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSwgbmFtZSwgY2FtZWwsXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5yZWdpc3Rlciggb3duZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0ga2V5LmNvbmNhdCgga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIFRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdGlmICgga2V5IGluIGNhY2hlICkge1xuXHRcdFx0XHRcdG5hbWUgPSBbIGtleSwgY2FtZWwgXTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbDtcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PSAzNS00NStcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3XG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMStcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhLCBjYW1lbEtleTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApIHx8XG5cblx0XHRcdFx0XHQvLyBUcnkgdG8gZmluZCBkYXNoZWQga2V5IGlmIGl0IGV4aXN0cyAoZ2gtMjc3OSlcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGZvciAyLjIueCBvbmx5XG5cdFx0XHRcdFx0ZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCkgKTtcblxuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxuXHRcdFx0XHQvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YVVzZXIuZ2V0KCB0aGlzLCBjYW1lbEtleSApO1xuXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cblx0XHRcdFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cblx0XHRcdFx0Ly8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywgY2FtZWxLZXksIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gKi4uLiBJbiB0aGUgY2FzZSBvZiBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgX2FjdHVhbGx5X1xuXHRcdFx0XHQvLyBoYXZlIGRhc2hlcywgd2UgbmVlZCB0byBhbHNvIHN0b3JlIGEgY29weSBvZiB0aGF0XG5cdFx0XHRcdC8vIHVuY2hhbmdlZCBwcm9wZXJ0eS5cblx0XHRcdFx0aWYgKCBrZXkuaW5kZXhPZiggXCItXCIgKSA+IC0xICYmIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHQhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHdlZW4uY3VyKCk7IH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7IH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFtcXHc6LV0rKS8gKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMC00LjMsIFNhZmFyaTw9NS4xXG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMSwgQW5kcm9pZDw0LjJcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUU5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gU3VwcG9ydCAoYXQgbGVhc3QpOiBDaHJvbWUsIElFOVxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDw9NDIrXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgaW4gRkYgYnV0IGRvbid0IGJsb2NrIElFIHJhZGlvIGV2ZW50cyAoIzM4NjEsIGdoLTIzNDMpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJlxuXHRcdFx0KCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgfHwgaXNOYU4oIGV2ZW50LmJ1dHRvbiApIHx8IGV2ZW50LmJ1dHRvbiA8IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAoIGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHQvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuXHRwcm9wczogKCBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGRldGFpbCBldmVudFBoYXNlIFwiICtcblx0XHRcIm1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIiApLnNwbGl0KCBcIiBcIiApLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdCggXCIgXCIgKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0bW91c2VIb29rczoge1xuXHRcdHByb3BzOiAoIFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBcIiArXG5cdFx0XHRcInNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b247XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcblx0XHRcdFx0ZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcblx0XHQvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3Rcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lPDI4XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6LV0rKVtePl0qKVxcLz4vZ2ksXG5cblx0Ly8gU3VwcG9ydDogSUUgMTAtMTEsIEVkZ2UgMTAyNDArXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gTWFuaXB1bGF0aW5nIHRhYmxlcyByZXF1aXJlcyBhIHRib2R5XG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0alF1ZXJ5Lm5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApID9cblxuXHRcdGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGJvZHlcIiApWyAwIF0gfHxcblx0XHRcdGVsZW0uYXBwZW5kQ2hpbGQoIGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRib2R5XCIgKSApIDpcblx0XHRlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PSAzNS00NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIEtlZXAgZG9tTWFuaXAgZXhwb3NlZCB1bnRpbCAzLjAgKGdoLTIyMjUpXG5cdGRvbU1hbmlwOiBkb21NYW5pcCxcblxuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdFxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG5cblxudmFyIGlmcmFtZSxcblx0ZWxlbWRpc3BsYXkgPSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94XG5cdFx0Ly8gV2UgaGF2ZSB0byBwcmUtZGVmaW5lIHRoZXNlIHZhbHVlcyBmb3IgRkYgKCMxMDIyNylcblx0XHRIVE1MOiBcImJsb2NrXCIsXG5cdFx0Qk9EWTogXCJibG9ja1wiXG5cdH07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFjdHVhbCBkaXNwbGF5IG9mIGEgZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbm9kZU5hbWUgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgRG9jdW1lbnQgb2JqZWN0XG4gKi9cblxuLy8gQ2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gZGVmYXVsdERpc3BsYXlcbmZ1bmN0aW9uIGFjdHVhbERpc3BsYXkoIG5hbWUsIGRvYyApIHtcblx0dmFyIGVsZW0gPSBqUXVlcnkoIGRvYy5jcmVhdGVFbGVtZW50KCBuYW1lICkgKS5hcHBlbmRUbyggZG9jLmJvZHkgKSxcblxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtWyAwIF0sIFwiZGlzcGxheVwiICk7XG5cblx0Ly8gV2UgZG9uJ3QgaGF2ZSBhbnkgZGF0YSBzdG9yZWQgb24gdGhlIGVsZW1lbnQsXG5cdC8vIHNvIHVzZSBcImRldGFjaFwiIG1ldGhvZCBhcyBmYXN0IHdheSB0byBnZXQgcmlkIG9mIHRoZSBlbGVtZW50XG5cdGVsZW0uZGV0YWNoKCk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbi8qKlxuICogVHJ5IHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBkaXNwbGF5IHZhbHVlIG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0RGlzcGxheSggbm9kZU5hbWUgKSB7XG5cdHZhciBkb2MgPSBkb2N1bWVudCxcblx0XHRkaXNwbGF5ID0gZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF07XG5cblx0aWYgKCAhZGlzcGxheSApIHtcblx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXG5cdFx0Ly8gSWYgdGhlIHNpbXBsZSB3YXkgZmFpbHMsIHJlYWQgZnJvbSBpbnNpZGUgYW4gaWZyYW1lXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiB8fCAhZGlzcGxheSApIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgaWZyYW1lIGlmIHBvc3NpYmxlXG5cdFx0XHRpZnJhbWUgPSAoIGlmcmFtZSB8fCBqUXVlcnkoIFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiICkgKVxuXHRcdFx0XHQuYXBwZW5kVG8oIGRvYy5kb2N1bWVudEVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gQWx3YXlzIHdyaXRlIGEgbmV3IEhUTUwgc2tlbGV0b24gc28gV2Via2l0IGFuZCBGaXJlZm94IGRvbid0IGNob2tlIG9uIHJldXNlXG5cdFx0XHRkb2MgPSBpZnJhbWVbIDAgXS5jb250ZW50RG9jdW1lbnQ7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0XHRkb2Mud3JpdGUoKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXG5cdFx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXHRcdFx0aWZyYW1lLmRldGFjaCgpO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHRoZSBjb3JyZWN0IGRlZmF1bHQgZGlzcGxheVxuXHRcdGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdID0gZGlzcGxheTtcblx0fVxuXG5cdHJldHVybiBkaXNwbGF5O1xufVxudmFyIHJtYXJnaW4gPSAoIC9ebWFyZ2luLyApO1xuXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFPD0xMSssIEZpcmVmb3g8PTMwKyAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHBpeGVsTWFyZ2luUmlnaHRWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O1wiICtcblx0XHRcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ0b3A6MSU7d2lkdGg6NTAlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gZGl2U3R5bGUubWFyZ2luTGVmdCA9PT0gXCIycHhcIjtcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNTAlXCI7XG5cdFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9IGRpdlN0eWxlLm1hcmdpblJpZ2h0ID09PSBcIjRweFwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0fVxuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gVGhpcyB0ZXN0IGlzIGV4ZWN1dGVkIG9ubHkgb25jZSBidXQgd2Ugc3RpbGwgZG8gbWVtb2l6aW5nXG5cdFx0XHQvLyBzaW5jZSB3ZSBjYW4gdXNlIHRoZSBib3hTaXppbmdSZWxpYWJsZSBwcmUtY29tcHV0aW5nLlxuXHRcdFx0Ly8gTm8gbmVlZCB0byBjaGVjayBpZiB0aGUgdGVzdCB3YXMgYWxyZWFkeSBwZXJmb3JtZWQsIHRob3VnaC5cblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMC00LjNcblx0XHRcdC8vIFdlJ3JlIGNoZWNraW5nIGZvciBib3hTaXppbmdSZWxpYWJsZVZhbCBoZXJlIGluc3RlYWQgb2YgcGl4ZWxNYXJnaW5SaWdodFZhbFxuXHRcdFx0Ly8gc2luY2UgdGhhdCBjb21wcmVzc2VzIGJldHRlciBhbmQgdGhleSdyZSBjb21wdXRlZCB0b2dldGhlciBhbnl3YXkuXG5cdFx0XHRpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGl4ZWxNYXJnaW5SaWdodFZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCBvbmx5LCBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDM3XG5cdFx0XHRpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHQvLyBDaGVjayBpZiBkaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XG5cdFx0XHQvLyBnZXRzIGNvbXB1dGVkIG1hcmdpbi1yaWdodCBiYXNlZCBvbiB3aWR0aCBvZiBjb250YWluZXIuICgjMzMzMylcblx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0Ly8gVGhpcyBzdXBwb3J0IGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgb25jZSBzbyBubyBtZW1vaXppbmcgaXMgbmVlZGVkLlxuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0bWFyZ2luRGl2ID0gZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0Ly8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlcjsgcGFkZGluZ1xuXHRcdFx0bWFyZ2luRGl2LnN0eWxlLmNzc1RleHQgPSBkaXYuc3R5bGUuY3NzVGV4dCA9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7XCIgK1xuXHRcdFx0XHRcImRpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXCI7XG5cdFx0XHRtYXJnaW5EaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBtYXJnaW5EaXYuc3R5bGUud2lkdGggPSBcIjBcIjtcblx0XHRcdGRpdi5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XG5cdFx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0XHRyZXQgPSAhcGFyc2VGbG9hdCggd2luZG93LmdldENvbXB1dGVkU3R5bGUoIG1hcmdpbkRpdiApLm1hcmdpblJpZ2h0ICk7XG5cblx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdFx0XHRkaXYucmVtb3ZlQ2hpbGQoIG1hcmdpbkRpdiApO1xuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblx0cmV0ID0gY29tcHV0ZWQgPyBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXSA6IHVuZGVmaW5lZDtcblxuXHQvLyBTdXBwb3J0OiBPcGVyYSAxMi4xeCBvbmx5XG5cdC8vIEZhbGwgYmFjayB0byBzdHlsZSBldmVuIHdpdGhvdXQgY29tcHV0ZWRcblx0Ly8gY29tcHV0ZWQgaXMgdW5kZWZpbmVkIGZvciBlbGVtcyBvbiBkb2N1bWVudCBmcmFnbWVudHNcblx0aWYgKCAoIHJldCA9PT0gXCJcIiB8fCByZXQgPT09IHVuZGVmaW5lZCApICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJPXCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cblx0XHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0XHQ0IDpcblxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHR2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFMTEgb25seVxuXHQvLyBJbiBJRSAxMSBmdWxsc2NyZWVuIGVsZW1lbnRzIGluc2lkZSBvZiBhbiBpZnJhbWUgaGF2ZVxuXHQvLyAxMDB4IHRvbyBzbWFsbCBkaW1lbnNpb25zIChnaC0xNzY0KS5cblx0aWYgKCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50ICYmIHdpbmRvdy50b3AgIT09IHdpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFMTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0aWYgKCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0dmFsID0gTWF0aC5yb3VuZCggZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVsgbmFtZSBdICogMTAwICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuXHRcdFx0Ly8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG5cdFx0XHQvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xuXHRcdFx0Ly8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW4oIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuYWNjZXNzKFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XCJvbGRkaXNwbGF5XCIsXG5cdFx0XHRcdFx0ZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG5cdFx0XHRcdGRhdGFQcml2LnNldChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFwib2xkZGlzcGxheVwiLFxuXHRcdFx0XHRcdGhpZGRlbiA/IGRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3Bcblx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzWyBpbmRleCBdIHx8IFwiXCIgOiBcIm5vbmVcIjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXHRcdFx0XHRcdGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiBzd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXG5cdFx0XHRcdGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0LyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBjaGVja0Rpc3BsYXksXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBIYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXG5cdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiaGVpZ2h0XCIgaW4gcHJvcHMgfHwgXCJ3aWR0aFwiIGluIHByb3BzICkgKSB7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcblxuXHRcdGlmICggY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gc2hvdy9oaWRlIHBhc3Ncblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy5leGVjKCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBkYXRhU2hvdyBsZWZ0IG92ZXIgZnJvbSBhIHN0b3BwZWQgaGlkZSBvciBzaG93XG5cdFx0XHRcdC8vIGFuZCB3ZSBhcmUgZ29pbmcgdG8gcHJvY2VlZCB3aXRoIHNob3csIHdlIHNob3VsZCBwcmV0ZW5kIHRvIGJlIGhpZGRlblxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblxuXHRcdC8vIEFueSBub24tZnggdmFsdWUgc3RvcHMgdXMgZnJvbSByZXN0b3JpbmcgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzcGxheSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxuXHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHR9XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0dHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblxuXHRcdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdFx0dHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8vIElmIHRoaXMgaXMgYSBub29wIGxpa2UgLmhpZGUoKS5oaWRlKCksIHJlc3RvcmUgYW4gb3ZlcndyaXR0ZW4gZGlzcGxheSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCAoIGRpc3BsYXkgPT09IFwibm9uZVwiID8gZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXkgKSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/XG5cdFx0b3B0LmR1cmF0aW9uIDogb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgP1xuXHRcdFx0alF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBpT1M8PTUuMSwgQW5kcm9pZDw9NC4yK1xuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8PTIuM1xuXHQvLyBPcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZSBpbmNvcnJlY3RseSBtYXJrZWQgYXMgZGlzYWJsZWRcblx0c2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcblx0c3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsIHByb3BOYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0XHRcdC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlXG5cdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGFiaW5kZXggP1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG52YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIFwiIFwiICsgY3VyVmFsdWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBnZXRDbGFzcyggZWxlbSApICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZyxcblx0cnNwYWNlcyA9IC9bXFx4MjBcXHRcXHJcXG5cXGZdKy9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApIDpcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTEwLTExK1xuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0alF1ZXJ5LnRyaW0oIGpRdWVyeS50ZXh0KCBlbGVtICkgKS5yZXBsYWNlKCByc3BhY2VzLCBcIiBcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/XG5cdFx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09PSBudWxsICkgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXG5cdFx0XHRcdC8vIFByZXZpb3VzbHksIGBvcmlnaW5hbEV2ZW50OiB7fWAgd2FzIHNldCBoZXJlLCBzbyBzdG9wUHJvcGFnYXRpb24gY2FsbFxuXHRcdFx0XHQvLyB3b3VsZCBub3QgYmUgdHJpZ2dlcmVkIG9uIGRvbm9yIGV2ZW50LCBzaW5jZSBpbiBvdXIgb3duXG5cdFx0XHRcdC8vIGpRdWVyeS5ldmVudC5zdG9wUHJvcGFnYXRpb24gZnVuY3Rpb24gd2UgaGFkIGEgY2hlY2sgZm9yIGV4aXN0ZW5jZSBvZlxuXHRcdFx0XHQvLyBvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbiBtZXRob2QsIHNvLCBjb25zZXF1ZW50bHkgaXQgd291bGQgYmUgYSBub29wLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBCdXQgbm93LCB0aGlzIFwic2ltdWxhdGVcIiBmdW5jdGlvbiBpcyB1c2VkIG9ubHkgZm9yIGV2ZW50c1xuXHRcdFx0XHQvLyBmb3Igd2hpY2ggc3RvcFByb3BhZ2F0aW9uKCkgaXMgbm9vcCwgc28gdGhlcmUgaXMgbm8gbmVlZCBmb3IgdGhhdCBhbnltb3JlLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBGb3IgdGhlIDEueCBicmFuY2ggdGhvdWdoLCBndWFyZCBmb3IgXCJjbGlja1wiIGFuZCBcInN1Ym1pdFwiXG5cdFx0XHRcdC8vIGV2ZW50cyBpcyBzdGlsbCB1c2VkLCBidXQgd2FzIG1vdmVkIHRvIGpRdWVyeS5ldmVudC5zdG9wUHJvcGFnYXRpb24gZnVuY3Rpb25cblx0XHRcdFx0Ly8gYmVjYXVzZSBgb3JpZ2luYWxFdmVudGAgc2hvdWxkIHBvaW50IHRvIHRoZSBvcmlnaW5hbCBldmVudCBmb3IgdGhlIGNvbnN0YW5jeVxuXHRcdFx0XHQvLyB3aXRoIG90aGVyIGV2ZW50cyBhbmQgZm9yIG1vcmUgZm9jdXNlZCBsb2dpY1xuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXG5cdFx0aWYgKCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3hcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lLCBTYWZhcmlcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbi8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0XG5qUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICsgXCJcIiApO1xufTtcblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyaGFzaCA9IC8jLiokLyxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogalF1ZXJ5LnBhcnNlSlNPTixcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gVGhlIGpxWEhSIHN0YXRlXG5cdFx0XHRzdGF0ZSA9IDAsXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGUgPT09IDIgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgbG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2sgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApLmNvbXBsZXRlID0gY29tcGxldGVEZWZlcnJlZC5hZGQ7XG5cdFx0anFYSFIuc3VjY2VzcyA9IGpxWEhSLmRvbmU7XG5cdFx0anFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xuXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggY2hhcmFjdGVyICgjNzUzMTogYW5kIHN0cmluZyBwcm9tb3Rpb24pXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApLnJlcGxhY2UoIHJoYXNoLCBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0galF1ZXJ5LnRyaW0oIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LTExK1xuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBpZiB1cmwgaXMgbWFsZm9ybWVkLCBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFOC0xMStcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHRjYWNoZVVSTCA9IHMudXJsO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9ICggcy51cmwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YSApO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGFudGktY2FjaGUgaW4gdXJsIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0cy51cmwgPSBydHMudGVzdCggY2FjaGVVUkwgKSA/XG5cblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ18nIHBhcmFtZXRlciwgc2V0IGl0cyB2YWx1ZVxuXHRcdFx0XHRcdGNhY2hlVVJMLnJlcGxhY2UoIHJ0cywgXCIkMV89XCIgKyBub25jZSsrICkgOlxuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFkZCBvbmUgdG8gdGhlIGVuZFxuXHRcdFx0XHRcdGNhY2hlVVJMICsgKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArIG5vbmNlKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IHN0YXRlID09PSAyICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRmb3IgKCBpIGluIHsgc3VjY2VzczogMSwgZXJyb3I6IDEsIGNvbXBsZXRlOiAxIH0gKSB7XG5cdFx0XHRqcVhIUlsgaSBdKCBzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c3RhdGUgPSAxO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBleGNlcHRpb24gYXMgZXJyb3IgaWYgbm90IGRvbmVcblx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblxuXHRcdFx0XHQvLyBTaW1wbHkgcmV0aHJvdyBvdGhlcndpc2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gQ2FsbGVkIG9uY2Vcblx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdGUgaXMgXCJkb25lXCIgbm93XG5cdFx0XHRzdGF0ZSA9IDI7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiYm9keVwiICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHRcdH1cblx0XHR9ICkuZW5kKCk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDw9IDEyLjEyXG5cdC8vIE9wZXJhIHJlcG9ydHMgb2Zmc2V0V2lkdGhzIGFuZCBvZmZzZXRIZWlnaHRzIGxlc3MgdGhhbiB6ZXJvIG9uIHNvbWUgZWxlbWVudHNcblx0Ly8gVXNlIE9SIGluc3RlYWQgb2YgQU5EIGFzIHRoZSBlbGVtZW50IGlzIG5vdCB2aXNpYmxlIGlmIGVpdGhlciBpcyB0cnVlXG5cdC8vIFNlZSB0aWNrZXRzICMxMDQwNiBhbmQgIzEzMTMyXG5cdHJldHVybiBlbGVtLm9mZnNldFdpZHRoID4gMCB8fCBlbGVtLm9mZnNldEhlaWdodCA+IDAgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDA7XG59O1xuXG5cblxuXG52YXIgcjIwID0gLyUyMC9nLFxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG5cdFx0XHR2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6ICggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIFNldCB0cmFkaXRpb25hbCB0byB0cnVlIGZvciBqUXVlcnkgPD0gMS4zLjIgYmVoYXZpb3IuXG5cdGlmICggdHJhZGl0aW9uYWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0cmV0dXJuIHZhbCA9PSBudWxsID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vLyBLZWVwIGEgY29weSBvZiB0aGUgb2xkIGxvYWQgbWV0aG9kXG52YXIgX2xvYWQgPSBqUXVlcnkuZm4ubG9hZDtcblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0aWYgKCB0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiICYmIF9sb2FkICkge1xuXHRcdHJldHVybiBfbG9hZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH1cblxuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBqUXVlcnkudHJpbSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGJveCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH0sXG5cdFx0XHRkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuXHRcdGlmICggIWRvYyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuXHRcdGlmICggIWpRdWVyeS5jb250YWlucyggZG9jRWxlbSwgZWxlbSApICkge1xuXHRcdFx0cmV0dXJuIGJveDtcblx0XHR9XG5cblx0XHRib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogYm94LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0bGVmdDogYm94LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LFxuXHRcdC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmk8Ny04KywgQ2hyb21lPDM3LTQ0K1xuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MjgwXG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlLCBudWxsICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cdHNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cbnJldHVybiBqUXVlcnk7XG59KSk7XG4iLCIvKiFcbiAqIFZFUlNJT046IDEuMTguNFxuICogREFURTogMjAxNi0wNC0yNlxuICogVVBEQVRFUyBBTkQgRE9DUyBBVDogaHR0cDovL2dyZWVuc29jay5jb21cbiAqIFxuICogSW5jbHVkZXMgYWxsIG9mIHRoZSBmb2xsb3dpbmc6IFR3ZWVuTGl0ZSwgVHdlZW5NYXgsIFRpbWVsaW5lTGl0ZSwgVGltZWxpbmVNYXgsIEVhc2VQYWNrLCBDU1NQbHVnaW4sIFJvdW5kUHJvcHNQbHVnaW4sIEJlemllclBsdWdpbiwgQXR0clBsdWdpbiwgRGlyZWN0aW9uYWxSb3RhdGlvblBsdWdpblxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE2LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICogXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqKi9cbnZhciBfZ3NTY29wZSA9ICh0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YoZ2xvYmFsKSAhPT0gXCJ1bmRlZmluZWRcIikgPyBnbG9iYWwgOiB0aGlzIHx8IHdpbmRvdzsgLy9oZWxwcyBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIEFNRC9SZXF1aXJlSlMgYW5kIENvbW1vbkpTL05vZGVcbihfZ3NTY29wZS5fZ3NRdWV1ZSB8fCAoX2dzU2NvcGUuX2dzUXVldWUgPSBbXSkpLnB1c2goIGZ1bmN0aW9uKCkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcIlR3ZWVuTWF4XCIsIFtcImNvcmUuQW5pbWF0aW9uXCIsXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsXCJUd2VlbkxpdGVcIl0sIGZ1bmN0aW9uKEFuaW1hdGlvbiwgU2ltcGxlVGltZWxpbmUsIFR3ZWVuTGl0ZSkge1xuXG5cdFx0dmFyIF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgW10uc2xpY2UgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0dmFyIGIgPSBbXSxcblx0XHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSAhPT0gbDsgYi5wdXNoKGFbaSsrXSkpO1xuXHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdH0sXG5cdFx0XHRfYXBwbHlDeWNsZSA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldHMsIGkpIHtcblx0XHRcdFx0dmFyIGFsdCA9IHZhcnMuY3ljbGUsXG5cdFx0XHRcdFx0cCwgdmFsO1xuXHRcdFx0XHRmb3IgKHAgaW4gYWx0KSB7XG5cdFx0XHRcdFx0dmFsID0gYWx0W3BdO1xuXHRcdFx0XHRcdHZhcnNbcF0gPSAodHlwZW9mKHZhbCkgPT09IFwiZnVuY3Rpb25cIikgPyB2YWwuY2FsbCh0YXJnZXRzW2ldLCBpKSA6IHZhbFtpICUgdmFsLmxlbmd0aF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIHZhcnMuY3ljbGU7XG5cdFx0XHR9LFxuXHRcdFx0VHdlZW5NYXggPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5jYWxsKHRoaXMsIHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLl9yZXBlYXQgPSB0aGlzLnZhcnMucmVwZWF0IHx8IDA7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdGhpcy52YXJzLnJlcGVhdERlbGF5IHx8IDA7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTsgLy9lbnN1cmVzIHRoYXQgaWYgdGhlcmUgaXMgYW55IHJlcGVhdCwgdGhlIHRvdGFsRHVyYXRpb24gd2lsbCBnZXQgcmVjYWxjdWxhdGVkIHRvIGFjY3VyYXRlbHkgcmVwb3J0IGl0LlxuXHRcdFx0XHR0aGlzLnJlbmRlciA9IFR3ZWVuTWF4LnByb3RvdHlwZS5yZW5kZXI7IC8vc3BlZWQgb3B0aW1pemF0aW9uIChhdm9pZCBwcm90b3R5cGUgbG9va3VwIG9uIHRoaXMgXCJob3RcIiBtZXRob2QpXG5cdFx0XHR9LFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyxcblx0XHRcdF9pc1NlbGVjdG9yID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzU2VsZWN0b3IsXG5cdFx0XHRfaXNBcnJheSA9IFR3ZWVuTGl0ZUludGVybmFscy5pc0FycmF5LFxuXHRcdFx0cCA9IFR3ZWVuTWF4LnByb3RvdHlwZSA9IFR3ZWVuTGl0ZS50byh7fSwgMC4xLCB7fSksXG5cdFx0XHRfYmxhbmtBcnJheSA9IFtdO1xuXG5cdFx0VHdlZW5NYXgudmVyc2lvbiA9IFwiMS4xOC40XCI7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFR3ZWVuTWF4O1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXHRcdFR3ZWVuTWF4LmtpbGxUd2VlbnNPZiA9IFR3ZWVuTWF4LmtpbGxEZWxheWVkQ2FsbHNUbyA9IFR3ZWVuTGl0ZS5raWxsVHdlZW5zT2Y7XG5cdFx0VHdlZW5NYXguZ2V0VHdlZW5zT2YgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2Y7XG5cdFx0VHdlZW5NYXgubGFnU21vb3RoaW5nID0gVHdlZW5MaXRlLmxhZ1Ntb290aGluZztcblx0XHRUd2Vlbk1heC50aWNrZXIgPSBUd2VlbkxpdGUudGlja2VyO1xuXHRcdFR3ZWVuTWF4LnJlbmRlciA9IFR3ZWVuTGl0ZS5yZW5kZXI7XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRyZXR1cm4gVHdlZW5MaXRlLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnVwZGF0ZVRvID0gZnVuY3Rpb24odmFycywgcmVzZXREdXJhdGlvbikge1xuXHRcdFx0dmFyIGN1clJhdGlvID0gdGhpcy5yYXRpbyxcblx0XHRcdFx0aW1tZWRpYXRlID0gdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciB8fCB2YXJzLmltbWVkaWF0ZVJlbmRlcixcblx0XHRcdFx0cDtcblx0XHRcdGlmIChyZXNldER1cmF0aW9uICYmIHRoaXMuX3N0YXJ0VGltZSA8IHRoaXMuX3RpbWVsaW5lLl90aW1lKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuX3RpbWVsaW5lLl90aW1lO1xuXHRcdFx0XHR0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuaW5zZXJ0KHRoaXMsIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX2RlbGF5KTsgLy9lbnN1cmVzIHRoYXQgYW55IG5lY2Vzc2FyeSByZS1zZXF1ZW5jaW5nIG9mIEFuaW1hdGlvbnMgaW4gdGhlIHRpbWVsaW5lIG9jY3VycyB0byBtYWtlIHN1cmUgdGhlIHJlbmRlcmluZyBvcmRlciBpcyBjb3JyZWN0LlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHR0aGlzLnZhcnNbcF0gPSB2YXJzW3BdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2luaXR0ZWQgfHwgaW1tZWRpYXRlKSB7XG5cdFx0XHRcdGlmIChyZXNldER1cmF0aW9uKSB7XG5cdFx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCAmJiB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsIHRoaXMpOyAvL2luIGNhc2UgYSBwbHVnaW4gbGlrZSBNb3Rpb25CbHVyIG11c3QgcGVyZm9ybSBzb21lIGNsZWFudXAgdGFza3Ncblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgLyB0aGlzLl9kdXJhdGlvbiA+IDAuOTk4KSB7IC8vaWYgdGhlIHR3ZWVuIGhhcyBmaW5pc2hlZCAob3IgY29tZSBleHRyZW1lbHkgY2xvc2UgdG8gZmluaXNoaW5nKSwgd2UganVzdCBuZWVkIHRvIHJld2luZCBpdCB0byAwIGFuZCB0aGVuIHJlbmRlciBpdCBhZ2FpbiBhdCB0aGUgZW5kIHdoaWNoIGZvcmNlcyBpdCB0byByZS1pbml0aWFsaXplIChwYXJzaW5nIHRoZSBuZXcgdmFycykuIFdlIGFsbG93IHR3ZWVucyB0aGF0IGFyZSBjbG9zZSB0byBmaW5pc2hpbmcgKGJ1dCBoYXZlbid0IHF1aXRlIGZpbmlzaGVkKSB0byB3b3JrIHRoaXMgd2F5IHRvbyBiZWNhdXNlIG90aGVyd2lzZSwgdGhlIHZhbHVlcyBhcmUgc28gc21hbGwgd2hlbiBkZXRlcm1pbmluZyB3aGVyZSB0byBwcm9qZWN0IHRoZSBzdGFydGluZyB2YWx1ZXMgdGhhdCBiaW5hcnkgbWF0aCBpc3N1ZXMgY3JlZXAgaW4gYW5kIGNhbiBtYWtlIHRoZSB0d2VlbiBhcHBlYXIgdG8gcmVuZGVyIGluY29ycmVjdGx5IHdoZW4gcnVuIGJhY2t3YXJkcy4gXG5cdFx0XHRcdFx0XHR2YXIgcHJldlRpbWUgPSB0aGlzLl90b3RhbFRpbWU7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlcigwLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0dGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0dGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IDAgfHwgaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBpbnYgPSAxIC8gKDEgLSBjdXJSYXRpbyksXG5cdFx0XHRcdFx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBULCBlbmRWYWx1ZTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBwdC5zICsgcHQuYztcblx0XHRcdFx0XHRcdFx0XHRwdC5jICo9IGludjtcblx0XHRcdFx0XHRcdFx0XHRwdC5zID0gZW5kVmFsdWUgLSBwdC5jO1xuXHRcdFx0XHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XHRcdFxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIGlmICh0aGlzLl9kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLnZhcnMucmVwZWF0KSB7IC8vemVybyBkdXJhdGlvbiB0d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgaGF2ZSByZW5kZXIoKSBjYWxsZWQgZnJvbSBUd2VlbkxpdGUncyBjb25zdHJ1Y3RvciwgYmVmb3JlIFR3ZWVuTWF4J3MgY29uc3RydWN0b3IgaGFzIGZpbmlzaGVkIHNldHRpbmcgX3JlcGVhdCwgX3JlcGVhdERlbGF5LCBhbmQgX3lveW8gd2hpY2ggYXJlIGNyaXRpY2FsIGluIGRldGVybWluaW5nIHRvdGFsRHVyYXRpb24oKSBzbyB3ZSBuZWVkIHRvIGNhbGwgaW52YWxpZGF0ZSgpIHdoaWNoIGlzIGEgbG93LWtiIHdheSB0byBnZXQgdGhvc2Ugc2V0IHByb3Blcmx5LlxuXHRcdFx0XHR0aGlzLmludmFsaWRhdGUoKTtcblx0XHRcdH1cblx0XHRcdHZhciB0b3RhbER1ciA9ICghdGhpcy5fZGlydHkpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMudG90YWxEdXJhdGlvbigpLFxuXHRcdFx0XHRwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHByZXZUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsIFxuXHRcdFx0XHRwcmV2Q3ljbGUgPSB0aGlzLl9jeWNsZSxcblx0XHRcdFx0ZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdGlzQ29tcGxldGUsIGNhbGxiYWNrLCBwdCwgY3ljbGVEdXJhdGlvbiwgciwgdHlwZSwgcG93LCByYXdQcmV2VGltZTtcblx0XHRcdGlmICh0aW1lID49IHRvdGFsRHVyIC0gMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cy5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdG90YWxEdXI7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gdGhpcy5fcmVwZWF0O1xuXHRcdFx0XHRpZiAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygwKSA6IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cmF0aW9uO1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygxKSA6IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0Zm9yY2UgPSAoZm9yY2UgfHwgdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKTsgLy9vdGhlcndpc2UsIGlmIHRoZSBhbmltYXRpb24gaXMgdW5wYXVzZWQvYWN0aXZhdGVkIGFmdGVyIGl0J3MgYWxyZWFkeSBmaW5pc2hlZCwgaXQgZG9lc24ndCBnZXQgcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgdGltZWxpbmUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRpZiAodGhpcy5fc3RhcnRUaW1lID09PSB0aGlzLl90aW1lbGluZS5fZHVyYXRpb24pIHsgLy9pZiBhIHplcm8tZHVyYXRpb24gdHdlZW4gaXMgYXQgdGhlIFZFUlkgZW5kIG9mIGEgdGltZWxpbmUgYW5kIHRoYXQgdGltZWxpbmUgcmVuZGVycyBhdCBpdHMgZW5kLCBpdCB3aWxsIHR5cGljYWxseSBhZGQgYSB0aW55IGJpdCBvZiBjdXNoaW9uIHRvIHRoZSByZW5kZXIgdGltZSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9ycyBmcm9tIGdldHRpbmcgaW4gdGhlIHdheSBvZiB0d2VlbnMgcmVuZGVyaW5nIHRoZWlyIFZFUlkgZW5kLiBJZiB3ZSB0aGVuIHJldmVyc2UoKSB0aGF0IHRpbWVsaW5lLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiB3aWxsIHRyaWdnZXIgaXRzIG9uUmV2ZXJzZUNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5IHRoZSBwbGF5aGVhZCBkaWRuJ3QgcGFzcyBvdmVyIGl0IGFnYWluLiBJdCdzIGEgdmVyeSBzcGVjaWZpYyBlZGdlIGNhc2Ugd2UgbXVzdCBhY2NvbW1vZGF0ZS5cblx0XHRcdFx0XHRcdHRpbWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lIDwgMCB8fCAodGltZSA8PSAwICYmIHRpbWUgPj0gLTAuMDAwMDAwMSkgfHwgKHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgdGhpcy5kYXRhICE9PSBcImlzUGF1c2VcIikpIGlmIChwcmV2UmF3UHJldlRpbWUgIT09IHRpbWUpIHsgLy9ub3RlOiB3aGVuIHRoaXMuZGF0YSBpcyBcImlzUGF1c2VcIiwgaXQncyBhIGNhbGxiYWNrIGFkZGVkIGJ5IGFkZFBhdXNlKCkgb24gYSB0aW1lbGluZSB0aGF0IHdlIHNob3VsZCBub3QgYmUgdHJpZ2dlcmVkIHdoZW4gTEVBVklORyBpdHMgZXhhY3Qgc3RhcnQgdGltZS4gSW4gb3RoZXIgd29yZHMsIHRsLmFkZFBhdXNlKDEpLnBsYXkoMSkgc2hvdWxkbid0IHBhdXNlLlxuXHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLCByb3VuZCBzdXBlciBzbWFsbCB2YWx1ZXMgdG8gMC5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRoaXMuX2N5Y2xlID0gMDtcblx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDApIDogMDtcblx0XHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgIT09IDAgfHwgKGR1cmF0aW9uID09PSAwICYmIHByZXZSYXdQcmV2VGltZSA+IDApKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID49IDApIHtcblx0XHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHsgLy9pZiB3ZSByZW5kZXIgdGhlIHZlcnkgYmVnaW5uaW5nICh0aW1lID09IDApIG9mIGEgZnJvbVRvKCksIHdlIG11c3QgZm9yY2UgdGhlIHJlbmRlciAobm9ybWFsIHR3ZWVucyB3b3VsZG4ndCBuZWVkIHRvIHJlbmRlciBhdCBhIHRpbWUgb2YgMCB3aGVuIHRoZSBwcmV2VGltZSB3YXMgYWxzbyAwKS4gVGhpcyBpcyBhbHNvIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgb3ZlcndyaXRpbmcga2lja3MgaW4gaW1tZWRpYXRlbHkuXG5cdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGltZTtcblx0XHRcdFx0aWYgKHRoaXMuX3JlcGVhdCAhPT0gMCkge1xuXHRcdFx0XHRcdGN5Y2xlRHVyYXRpb24gPSBkdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5O1xuXHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gKHRoaXMuX3RvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24pID4+IDA7IC8vb3JpZ2luYWxseSBfdG90YWxUaW1lICUgY3ljbGVEdXJhdGlvbiBidXQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIGNhdXNlZCBwcm9ibGVtcywgc28gSSBub3JtYWxpemVkIGl0LiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgc29tZSBicm93c2VycyByZXBvcnQgaXQgYXMgMC43OTk5OTk5OSEpXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2N5Y2xlICE9PSAwKSBpZiAodGhpcy5fY3ljbGUgPT09IHRoaXMuX3RvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24gJiYgcHJldlRvdGFsVGltZSA8PSB0aW1lKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9jeWNsZS0tOyAvL290aGVyd2lzZSB3aGVuIHJlbmRlcmVkIGV4YWN0bHkgYXQgdGhlIGVuZCB0aW1lLCBpdCB3aWxsIGFjdCBhcyB0aG91Z2ggaXQgaXMgcmVwZWF0aW5nIChhdCB0aGUgYmVnaW5uaW5nKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lIC0gKHRoaXMuX2N5Y2xlICogY3ljbGVEdXJhdGlvbik7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3lveW8pIGlmICgodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cmF0aW9uIC0gdGhpcy5fdGltZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgPiBkdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cmF0aW9uO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSA8IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl9lYXNlVHlwZSkge1xuXHRcdFx0XHRcdHIgPSB0aGlzLl90aW1lIC8gZHVyYXRpb247XG5cdFx0XHRcdFx0dHlwZSA9IHRoaXMuX2Vhc2VUeXBlO1xuXHRcdFx0XHRcdHBvdyA9IHRoaXMuX2Vhc2VQb3dlcjtcblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSB8fCAodHlwZSA9PT0gMyAmJiByID49IDAuNSkpIHtcblx0XHRcdFx0XHRcdHIgPSAxIC0gcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBvdyA9PT0gMSkge1xuXHRcdFx0XHRcdFx0ciAqPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAyKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gNCkge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHIgKiByO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAyKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgLyBkdXJhdGlvbiA8IDAuNSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHIgLyAyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIChyIC8gMik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRpZiAocHJldlRpbWUgPT09IHRoaXMuX3RpbWUgJiYgIWZvcmNlICYmIHByZXZDeWNsZSA9PT0gdGhpcy5fY3ljbGUpIHtcblx0XHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgIT09IHRoaXMuX3RvdGFsVGltZSkgaWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7IC8vc28gdGhhdCBvblVwZGF0ZSBmaXJlcyBldmVuIGR1cmluZyB0aGUgcmVwZWF0RGVsYXkgLSBhcyBsb25nIGFzIHRoZSB0b3RhbFRpbWUgY2hhbmdlZCwgd2Ugc2hvdWxkIHRyaWdnZXIgb25VcGRhdGUuXG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXQoKTtcblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkIHx8IHRoaXMuX2djKSB7IC8vaW1tZWRpYXRlUmVuZGVyIHR3ZWVucyB0eXBpY2FsbHkgd29uJ3QgaW5pdGlhbGl6ZSB1bnRpbCB0aGUgcGxheWhlYWQgYWR2YW5jZXMgKF90aW1lIGlzIGdyZWF0ZXIgdGhhbiAwKSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBvdmVyd3JpdGluZyBvY2N1cnMgcHJvcGVybHkuIEFsc28sIGlmIGFsbCBvZiB0aGUgdHdlZW5pbmcgcHJvcGVydGllcyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4gKHdoaWNoIHdvdWxkIGNhdXNlIF9nYyB0byBiZSB0cnVlLCBhcyBzZXQgaW4gX2luaXQoKSksIHdlIHNob3VsZG4ndCBjb250aW51ZSBvdGhlcndpc2UgYW4gb25TdGFydCBjYWxsYmFjayBjb3VsZCBiZSBjYWxsZWQgZm9yIGV4YW1wbGUuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFmb3JjZSAmJiB0aGlzLl9maXJzdFBUICYmICgodGhpcy52YXJzLmxhenkgIT09IGZhbHNlICYmIHRoaXMuX2R1cmF0aW9uKSB8fCAodGhpcy52YXJzLmxhenkgJiYgIXRoaXMuX2R1cmF0aW9uKSkpIHsgLy93ZSBzdGljayBpdCBpbiB0aGUgcXVldWUgZm9yIHJlbmRlcmluZyBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIHRpY2sgLSB0aGlzIGlzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIGJlY2F1c2UgYnJvd3NlcnMgaW52YWxpZGF0ZSBzdHlsZXMgYW5kIGZvcmNlIGEgcmVjYWxjdWxhdGlvbiBpZiB5b3UgcmVhZCwgd3JpdGUsIGFuZCB0aGVuIHJlYWQgc3R5bGUgZGF0YSAoc28gaXQncyBiZXR0ZXIgdG8gcmVhZC9yZWFkL3JlYWQvd3JpdGUvd3JpdGUvd3JpdGUgdGhhbiByZWFkL3dyaXRlL3JlYWQvd3JpdGUvcmVhZC93cml0ZSkuIFRoZSBkb3duIHNpZGUsIG9mIGNvdXJzZSwgaXMgdGhhdCB1c3VhbGx5IHlvdSBXQU5UIHRoaW5ncyB0byByZW5kZXIgaW1tZWRpYXRlbHkgYmVjYXVzZSB5b3UgbWF5IGhhdmUgY29kZSBydW5uaW5nIHJpZ2h0IGFmdGVyIHRoYXQgd2hpY2ggZGVwZW5kcyBvbiB0aGUgY2hhbmdlLiBMaWtlIGltYWdpbmUgcnVubmluZyBUd2VlbkxpdGUuc2V0KC4uLikgYW5kIHRoZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhhdCwgY3JlYXRpbmcgYSBub3RoZXIgdHdlZW4gdGhhdCBhbmltYXRlcyB0aGUgc2FtZSBwcm9wZXJ0eSB0byBhbm90aGVyIHZhbHVlOyB0aGUgc3RhcnRpbmcgdmFsdWVzIG9mIHRoYXQgMm5kIHR3ZWVuIHdvdWxkbid0IGJlIGFjY3VyYXRlIGlmIGxhenkgaXMgdHJ1ZS5cblx0XHRcdFx0XHR0aGlzLl90aW1lID0gcHJldlRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gcHJldlRvdGFsVGltZTtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHByZXZSYXdQcmV2VGltZTtcblx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9IHByZXZDeWNsZTtcblx0XHRcdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVR3ZWVucy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdHRoaXMuX2xhenkgPSBbdGltZSwgc3VwcHJlc3NFdmVudHNdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL19lYXNlIGlzIGluaXRpYWxseSBzZXQgdG8gZGVmYXVsdEVhc2UsIHNvIG5vdyB0aGF0IGluaXQoKSBoYXMgcnVuLCBfZWFzZSBpcyBzZXQgcHJvcGVybHkgYW5kIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhlIHJhdGlvLiBPdmVyYWxsIHRoaXMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY29uZGl0aW9uYWwgbG9naWMgZWFybGllciBpbiB0aGUgbWV0aG9kIHRvIGF2b2lkIGhhdmluZyB0byBzZXQgcmF0aW8gdHdpY2UgYmVjYXVzZSB3ZSBvbmx5IGluaXQoKSBvbmNlIGJ1dCByZW5kZXJUaW1lKCkgZ2V0cyBjYWxsZWQgVkVSWSBmcmVxdWVudGx5LlxuXHRcdFx0XHRpZiAodGhpcy5fdGltZSAmJiAhaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNDb21wbGV0ZSAmJiB0aGlzLl9lYXNlLl9jYWxjRW5kKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oKHRoaXMuX3RpbWUgPT09IDApID8gMCA6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fbGF6eSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdGltZSAhPT0gcHJldlRpbWUgJiYgdGltZSA+PSAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7IC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGEgdHdlZW4gKGFzIG9wcG9zZWQgdG8gdGhlIHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIHRoZSB0aW1lbGluZSBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0d2VlbiBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZS5cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VG90YWxUaW1lID09PSAwKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9pbml0dGVkID09PSAyICYmIHRpbWUgPiAwKSB7XG5cdFx0XHRcdFx0Ly90aGlzLmludmFsaWRhdGUoKTtcblx0XHRcdFx0XHR0aGlzLl9pbml0KCk7IC8vd2lsbCBqdXN0IGFwcGx5IG92ZXJ3cml0aW5nIHNpbmNlIF9pbml0dGVkIG9mICgyKSBtZWFucyBpdCB3YXMgYSBmcm9tKCkgdHdlZW4gdGhhdCBoYWQgaW1tZWRpYXRlUmVuZGVyOnRydWVcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJfZHVtbXlHU1wiOyAvL2lmIG5vIGNhbGxiYWNrIGlzIGRlZmluZWQsIHVzZSBhIGR1bW15IHZhbHVlIGp1c3Qgc28gdGhhdCB0aGUgY29uZGl0aW9uIGF0IHRoZSBlbmQgZXZhbHVhdGVzIGFzIHRydWUgYmVjYXVzZSBfc3RhcnRBdCBzaG91bGQgcmVuZGVyIEFGVEVSIHRoZSBub3JtYWwgcmVuZGVyIGxvb3Agd2hlbiB0aGUgdGltZSBpcyBuZWdhdGl2ZS4gV2UgY291bGQgaGFuZGxlIHRoaXMgaW4gYSBtb3JlIGludHVpdGl2ZSB3YXksIG9mIGNvdXJzZSwgYnV0IHRoZSByZW5kZXIgbG9vcCBpcyB0aGUgTU9TVCBpbXBvcnRhbnQgdGhpbmcgdG8gb3B0aW1pemUsIHNvIHRoaXMgdGVjaG5pcXVlIGFsbG93cyB1cyB0byBhdm9pZCBhZGRpbmcgZXh0cmEgY29uZGl0aW9uYWwgbG9naWMgaW4gYSBoaWdoLWZyZXF1ZW5jeSBhcmVhLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90b3RhbFRpbWUgIT09IDAgfHwgZHVyYXRpb24gPT09IDApIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXShwdC5jICogdGhpcy5yYXRpbyArIHB0LnMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC5jICogdGhpcy5yYXRpbyArIHB0LnM7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlKSB7XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkgaWYgKHRoaXMuX3N0YXJ0QXQgJiYgdGhpcy5fc3RhcnRUaW1lKSB7IC8vaWYgdGhlIHR3ZWVuIGlzIHBvc2l0aW9uZWQgYXQgdGhlIFZFUlkgYmVnaW5uaW5nIChfc3RhcnRUaW1lIDApIG9mIGl0cyBwYXJlbnQgdGltZWxpbmUsIGl0J3MgaWxsZWdhbCBmb3IgdGhlIHBsYXloZWFkIHRvIGdvIGJhY2sgZnVydGhlciwgc28gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlIHJlY29yZGVkIHN0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7IC8vbm90ZTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIHR1Y2sgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgbGVzcyB0cmF2ZWxlZCBhcmVhcyAobW9zdCB0d2VlbnMgZG9uJ3QgaGF2ZSBhbiBvblVwZGF0ZSkuIFdlJ2QganVzdCBoYXZlIGl0IGF0IHRoZSBlbmQgYmVmb3JlIHRoZSBvbkNvbXBsZXRlLCBidXQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCBiZWZvcmUgYW55IG9uVXBkYXRlIGlzIGNhbGxlZCwgc28gd2UgQUxTTyBwdXQgaXQgaGVyZSBhbmQgdGhlbiBpZiBpdCdzIG5vdCBjYWxsZWQsIHdlIGRvIHNvIGxhdGVyIG5lYXIgdGhlIG9uQ29tcGxldGUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gcHJldlRvdGFsVGltZSB8fCBjYWxsYmFjaykge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9jeWNsZSAhPT0gcHJldkN5Y2xlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAoIXRoaXMuX2djKSBpZiAodGhpcy52YXJzLm9uUmVwZWF0KSB7XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25SZXBlYXRcIik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fZ2MgfHwgZm9yY2UpIHsgLy9jaGVjayBnYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmICh0aW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aGlzLl9zdGFydFRpbWUpIHsgLy9pZiB0aGUgdHdlZW4gaXMgcG9zaXRpb25lZCBhdCB0aGUgVkVSWSBiZWdpbm5pbmcgKF9zdGFydFRpbWUgMCkgb2YgaXRzIHBhcmVudCB0aW1lbGluZSwgaXQncyBpbGxlZ2FsIGZvciB0aGUgcGxheWhlYWQgdG8gZ28gYmFjayBmdXJ0aGVyLCBzbyB3ZSBzaG91bGQgbm90IHJlbmRlciB0aGUgcmVjb3JkZWQgc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgcmF3UHJldlRpbWUgIT09IF90aW55TnVtKSB7IC8vdGhlIG9uQ29tcGxldGUgb3Igb25SZXZlcnNlQ29tcGxldGUgY291bGQgdHJpZ2dlciBtb3ZlbWVudCBvZiB0aGUgcGxheWhlYWQgYW5kIGZvciB6ZXJvLWR1cmF0aW9uIHR3ZWVucyAod2hpY2ggbXVzdCBkaXNjZXJuIGRpcmVjdGlvbikgdGhhdCBsYW5kIGRpcmVjdGx5IGJhY2sgb24gdGhlaXIgc3RhcnQgdGltZSwgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGFnYWluIG9uIHRoZSBuZXh0IHJlbmRlci4gVGhpbmsgb2Ygc2V2ZXJhbCBhZGRQYXVzZSgpJ3MgaW4gYSB0aW1lbGluZSB0aGF0IGZvcmNlcyB0aGUgcGxheWhlYWQgdG8gYSBjZXJ0YWluIHNwb3QsIGJ1dCB3aGF0IGlmIGl0J3MgYWxyZWFkeSBwYXVzZWQgYW5kIGFub3RoZXIgdHdlZW4gaXMgdHdlZW5pbmcgdGhlIFwidGltZVwiIG9mIHRoZSB0aW1lbGluZT8gRWFjaCB0aW1lIGl0IG1vdmVzIFtmb3J3YXJkXSBwYXN0IHRoYXQgc3BvdCwgaXQgd291bGQgbW92ZSBiYWNrLCBhbmQgc2luY2Ugc3VwcHJlc3NFdmVudHMgaXMgdHJ1ZSwgaXQnZCByZXNldCBfcmF3UHJldlRpbWUgdG8gX3RpbnlOdW0gc28gdGhhdCB3aGVuIGl0IGJlZ2lucyBhZ2FpbiwgdGhlIGNhbGxiYWNrIHdvdWxkIGZpcmUgKHNvIHVsdGltYXRlbHkgaXQgY291bGQgYm91bmNlIGJhY2sgYW5kIGZvcnRoIGR1cmluZyB0aGF0IHR3ZWVuKS4gQWdhaW4sIHRoaXMgaXMgYSB2ZXJ5IHVuY29tbW9uIHNjZW5hcmlvLCBidXQgcG9zc2libGUgbm9uZXRoZWxlc3MuXG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcbi8vLS0tLSBTVEFUSUMgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XG5cdFx0VHdlZW5NYXgudG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguZnJvbSA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5mcm9tVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgZHVyYXRpb24sIHRvVmFycyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5zdGFnZ2VyVG8gPSBUd2Vlbk1heC5hbGxUbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHR2YXIgZGVsYXkgPSAwLFxuXHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdGZpbmFsQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAodmFycy5vbkNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHR2YXJzLm9uQ29tcGxldGUuYXBwbHkodmFycy5vbkNvbXBsZXRlU2NvcGUgfHwgdGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b25Db21wbGV0ZUFsbC5hcHBseShvbkNvbXBsZXRlQWxsU2NvcGUgfHwgdmFycy5jYWxsYmFja1Njb3BlIHx8IHRoaXMsIG9uQ29tcGxldGVBbGxQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjeWNsZSA9IHZhcnMuY3ljbGUsXG5cdFx0XHRcdGZyb21DeWNsZSA9ICh2YXJzLnN0YXJ0QXQgJiYgdmFycy5zdGFydEF0LmN5Y2xlKSxcblx0XHRcdFx0bCwgY29weSwgaSwgcDtcblx0XHRcdGlmICghX2lzQXJyYXkodGFyZ2V0cykpIHtcblx0XHRcdFx0aWYgKHR5cGVvZih0YXJnZXRzKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdHRhcmdldHMgPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0cykgfHwgdGFyZ2V0cztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2lzU2VsZWN0b3IodGFyZ2V0cykpIHtcblx0XHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRzID0gdGFyZ2V0cyB8fCBbXTtcblx0XHRcdGlmIChzdGFnZ2VyIDwgMCkge1xuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR0YXJnZXRzLnJldmVyc2UoKTtcblx0XHRcdFx0c3RhZ2dlciAqPSAtMTtcblx0XHRcdH1cblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aCAtIDE7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDw9IGw7IGkrKykge1xuXHRcdFx0XHRjb3B5ID0ge307XG5cdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0Y29weVtwXSA9IHZhcnNbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGN5Y2xlKSB7XG5cdFx0XHRcdFx0X2FwcGx5Q3ljbGUoY29weSwgdGFyZ2V0cywgaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGZyb21DeWNsZSkge1xuXHRcdFx0XHRcdGZyb21DeWNsZSA9IGNvcHkuc3RhcnRBdCA9IHt9O1xuXHRcdFx0XHRcdGZvciAocCBpbiB2YXJzLnN0YXJ0QXQpIHtcblx0XHRcdFx0XHRcdGZyb21DeWNsZVtwXSA9IHZhcnMuc3RhcnRBdFtwXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X2FwcGx5Q3ljbGUoY29weS5zdGFydEF0LCB0YXJnZXRzLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb3B5LmRlbGF5ID0gZGVsYXkgKyAoY29weS5kZWxheSB8fCAwKTtcblx0XHRcdFx0aWYgKGkgPT09IGwgJiYgb25Db21wbGV0ZUFsbCkge1xuXHRcdFx0XHRcdGNvcHkub25Db21wbGV0ZSA9IGZpbmFsQ29tcGxldGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtpXSA9IG5ldyBUd2Vlbk1heCh0YXJnZXRzW2ldLCBkdXJhdGlvbiwgY29weSk7XG5cdFx0XHRcdGRlbGF5ICs9IHN0YWdnZXI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnN0YWdnZXJGcm9tID0gVHdlZW5NYXguYWxsRnJvbSA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBUd2Vlbk1heC5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5zdGFnZ2VyRnJvbVRvID0gVHdlZW5NYXguYWxsRnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIFR3ZWVuTWF4LnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpO1xuXHRcdH07XG5cdFx0XHRcdFxuXHRcdFR3ZWVuTWF4LmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24oZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlLCB1c2VGcmFtZXMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgoY2FsbGJhY2ssIDAsIHtkZWxheTpkZWxheSwgb25Db21wbGV0ZTpjYWxsYmFjaywgb25Db21wbGV0ZVBhcmFtczpwYXJhbXMsIGNhbGxiYWNrU2NvcGU6c2NvcGUsIG9uUmV2ZXJzZUNvbXBsZXRlOmNhbGxiYWNrLCBvblJldmVyc2VDb21wbGV0ZVBhcmFtczpwYXJhbXMsIGltbWVkaWF0ZVJlbmRlcjpmYWxzZSwgdXNlRnJhbWVzOnVzZUZyYW1lcywgb3ZlcndyaXRlOjB9KTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIDAsIHZhcnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguaXNUd2VlbmluZyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIChUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0LCB0cnVlKS5sZW5ndGggPiAwKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBfZ2V0Q2hpbGRyZW5PZiA9IGZ1bmN0aW9uKHRpbWVsaW5lLCBpbmNsdWRlVGltZWxpbmVzKSB7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0XHR0d2VlbiA9IHRpbWVsaW5lLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0aWYgKHR3ZWVuIGluc3RhbmNlb2YgVHdlZW5MaXRlKSB7XG5cdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5jbHVkZVRpbWVsaW5lcykge1xuXHRcdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YSA9IGEuY29uY2F0KF9nZXRDaGlsZHJlbk9mKHR3ZWVuLCBpbmNsdWRlVGltZWxpbmVzKSk7XG5cdFx0XHRcdFx0XHRjbnQgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sIFxuXHRcdFx0Z2V0QWxsVHdlZW5zID0gVHdlZW5NYXguZ2V0QWxsVHdlZW5zID0gZnVuY3Rpb24oaW5jbHVkZVRpbWVsaW5lcykge1xuXHRcdFx0XHRyZXR1cm4gX2dldENoaWxkcmVuT2YoQW5pbWF0aW9uLl9yb290VGltZWxpbmUsIGluY2x1ZGVUaW1lbGluZXMpLmNvbmNhdCggX2dldENoaWxkcmVuT2YoQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmUsIGluY2x1ZGVUaW1lbGluZXMpICk7XG5cdFx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmtpbGxBbGwgPSBmdW5jdGlvbihjb21wbGV0ZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcykge1xuXHRcdFx0aWYgKHR3ZWVucyA9PSBudWxsKSB7XG5cdFx0XHRcdHR3ZWVucyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGVsYXllZENhbGxzID09IG51bGwpIHtcblx0XHRcdFx0ZGVsYXllZENhbGxzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHZhciBhID0gZ2V0QWxsVHdlZW5zKCh0aW1lbGluZXMgIT0gZmFsc2UpKSxcblx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRhbGxUcnVlID0gKHR3ZWVucyAmJiBkZWxheWVkQ2FsbHMgJiYgdGltZWxpbmVzKSxcblx0XHRcdFx0aXNEQywgdHdlZW4sIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHR3ZWVuID0gYVtpXTtcblx0XHRcdFx0aWYgKGFsbFRydWUgfHwgKHR3ZWVuIGluc3RhbmNlb2YgU2ltcGxlVGltZWxpbmUpIHx8ICgoaXNEQyA9ICh0d2Vlbi50YXJnZXQgPT09IHR3ZWVuLnZhcnMub25Db21wbGV0ZSkpICYmIGRlbGF5ZWRDYWxscykgfHwgKHR3ZWVucyAmJiAhaXNEQykpIHtcblx0XHRcdFx0XHRpZiAoY29tcGxldGUpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnRvdGFsVGltZSh0d2Vlbi5fcmV2ZXJzZWQgPyAwIDogdHdlZW4udG90YWxEdXJhdGlvbigpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHdlZW4uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmtpbGxDaGlsZFR3ZWVuc09mID0gZnVuY3Rpb24ocGFyZW50LCBjb21wbGV0ZSkge1xuXHRcdFx0aWYgKHBhcmVudCA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciB0bCA9IFR3ZWVuTGl0ZUludGVybmFscy50d2Vlbkxvb2t1cCxcblx0XHRcdFx0YSwgY3VyUGFyZW50LCBwLCBpLCBsO1xuXHRcdFx0aWYgKHR5cGVvZihwYXJlbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHBhcmVudCA9IFR3ZWVuTGl0ZS5zZWxlY3RvcihwYXJlbnQpIHx8IHBhcmVudDtcblx0XHRcdH1cblx0XHRcdGlmIChfaXNTZWxlY3RvcihwYXJlbnQpKSB7XG5cdFx0XHRcdHBhcmVudCA9IF9zbGljZShwYXJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9pc0FycmF5KHBhcmVudCkpIHtcblx0XHRcdFx0aSA9IHBhcmVudC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFR3ZWVuTWF4LmtpbGxDaGlsZFR3ZWVuc09mKHBhcmVudFtpXSwgY29tcGxldGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGEgPSBbXTtcblx0XHRcdGZvciAocCBpbiB0bCkge1xuXHRcdFx0XHRjdXJQYXJlbnQgPSB0bFtwXS50YXJnZXQucGFyZW50Tm9kZTtcblx0XHRcdFx0d2hpbGUgKGN1clBhcmVudCkge1xuXHRcdFx0XHRcdGlmIChjdXJQYXJlbnQgPT09IHBhcmVudCkge1xuXHRcdFx0XHRcdFx0YSA9IGEuY29uY2F0KHRsW3BdLnR3ZWVucyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1clBhcmVudCA9IGN1clBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsID0gYS5sZW5ndGg7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChjb21wbGV0ZSkge1xuXHRcdFx0XHRcdGFbaV0udG90YWxUaW1lKGFbaV0udG90YWxEdXJhdGlvbigpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhW2ldLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBfY2hhbmdlUGF1c2UgPSBmdW5jdGlvbihwYXVzZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcykge1xuXHRcdFx0dHdlZW5zID0gKHR3ZWVucyAhPT0gZmFsc2UpO1xuXHRcdFx0ZGVsYXllZENhbGxzID0gKGRlbGF5ZWRDYWxscyAhPT0gZmFsc2UpO1xuXHRcdFx0dGltZWxpbmVzID0gKHRpbWVsaW5lcyAhPT0gZmFsc2UpO1xuXHRcdFx0dmFyIGEgPSBnZXRBbGxUd2VlbnModGltZWxpbmVzKSxcblx0XHRcdFx0YWxsVHJ1ZSA9ICh0d2VlbnMgJiYgZGVsYXllZENhbGxzICYmIHRpbWVsaW5lcyksXG5cdFx0XHRcdGkgPSBhLmxlbmd0aCxcblx0XHRcdFx0aXNEQywgdHdlZW47XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0dHdlZW4gPSBhW2ldO1xuXHRcdFx0XHRpZiAoYWxsVHJ1ZSB8fCAodHdlZW4gaW5zdGFuY2VvZiBTaW1wbGVUaW1lbGluZSkgfHwgKChpc0RDID0gKHR3ZWVuLnRhcmdldCA9PT0gdHdlZW4udmFycy5vbkNvbXBsZXRlKSkgJiYgZGVsYXllZENhbGxzKSB8fCAodHdlZW5zICYmICFpc0RDKSkge1xuXHRcdFx0XHRcdHR3ZWVuLnBhdXNlZChwYXVzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnBhdXNlQWxsID0gZnVuY3Rpb24odHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcykge1xuXHRcdFx0X2NoYW5nZVBhdXNlKHRydWUsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXgucmVzdW1lQWxsID0gZnVuY3Rpb24odHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcykge1xuXHRcdFx0X2NoYW5nZVBhdXNlKGZhbHNlLCB0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5NYXguZ2xvYmFsVGltZVNjYWxlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciB0bCA9IEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lLFxuXHRcdFx0XHR0ID0gVHdlZW5MaXRlLnRpY2tlci50aW1lO1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0bC5fdGltZVNjYWxlO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBfdGlueU51bTsgLy9jYW4ndCBhbGxvdyB6ZXJvIGJlY2F1c2UgaXQnbGwgdGhyb3cgdGhlIG1hdGggb2ZmXG5cdFx0XHR0bC5fc3RhcnRUaW1lID0gdCAtICgodCAtIHRsLl9zdGFydFRpbWUpICogdGwuX3RpbWVTY2FsZSAvIHZhbHVlKTtcblx0XHRcdHRsID0gQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmU7XG5cdFx0XHR0ID0gVHdlZW5MaXRlLnRpY2tlci5mcmFtZTtcblx0XHRcdHRsLl9zdGFydFRpbWUgPSB0IC0gKCh0IC0gdGwuX3N0YXJ0VGltZSkgKiB0bC5fdGltZVNjYWxlIC8gdmFsdWUpO1xuXHRcdFx0dGwuX3RpbWVTY2FsZSA9IEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lLl90aW1lU2NhbGUgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXHRcdFxuXHRcbi8vLS0tLSBHRVRURVJTIC8gU0VUVEVSUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XG5cdFx0cC5wcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUoIHRoaXMuZHVyYXRpb24oKSAqICgodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdG90YWxUaW1lIC8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLnRvdGFsVGltZSggdGhpcy50b3RhbER1cmF0aW9uKCkgKiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC50aW1lID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgPiB0aGlzLl9kdXJhdGlvbikge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgPSAodGhpcy5fZHVyYXRpb24gLSB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgKz0gdGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUodmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2R1cmF0aW9uOyAvL2Rvbid0IHNldCBfZGlydHkgPSBmYWxzZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIHJlcGVhdHMgdGhhdCBoYXZlbid0IGJlZW4gZmFjdG9yZWQgaW50byB0aGUgX3RvdGFsRHVyYXRpb24geWV0LiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgYSByZXBlYXRlZCBUd2Vlbk1heCBhbmQgdGhlbiBpbW1lZGlhdGVseSBjaGVjayBpdHMgZHVyYXRpb24oKSwgaXQgd291bGQgY2FjaGUgdGhlIHZhbHVlIGFuZCB0aGUgdG90YWxEdXJhdGlvbiB3b3VsZCBub3QgYmUgY29ycmVjdCwgdGh1cyByZXBlYXRzIHdvdWxkbid0IHRha2UgZWZmZWN0LlxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEFuaW1hdGlvbi5wcm90b3R5cGUuZHVyYXRpb24uY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0Ly9pbnN0ZWFkIG9mIEluZmluaXR5LCB3ZSB1c2UgOTk5OTk5OTk5OTk5IHNvIHRoYXQgd2UgY2FuIGFjY29tbW9kYXRlIHJldmVyc2VzXG5cdFx0XHRcdFx0dGhpcy5fdG90YWxEdXJhdGlvbiA9ICh0aGlzLl9yZXBlYXQgPT09IC0xKSA/IDk5OTk5OTk5OTk5OSA6IHRoaXMuX2R1cmF0aW9uICogKHRoaXMuX3JlcGVhdCArIDEpICsgKHRoaXMuX3JlcGVhdERlbGF5ICogdGhpcy5fcmVwZWF0KTtcblx0XHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0aGlzLl9yZXBlYXQgPT09IC0xKSA/IHRoaXMgOiB0aGlzLmR1cmF0aW9uKCAodmFsdWUgLSAodGhpcy5fcmVwZWF0ICogdGhpcy5fcmVwZWF0RGVsYXkpKSAvICh0aGlzLl9yZXBlYXQgKyAxKSApO1xuXHRcdH07XG5cdFx0XG5cdFx0cC5yZXBlYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC5yZXBlYXREZWxheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcGVhdERlbGF5O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC55b3lvID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5feW95bztcblx0XHRcdH1cblx0XHRcdHRoaXMuX3lveW8gPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0cmV0dXJuIFR3ZWVuTWF4O1xuXHRcdFxuXHR9LCB0cnVlKTtcblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVGltZWxpbmVMaXRlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwiVGltZWxpbmVMaXRlXCIsIFtcImNvcmUuQW5pbWF0aW9uXCIsXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsXCJUd2VlbkxpdGVcIl0sIGZ1bmN0aW9uKEFuaW1hdGlvbiwgU2ltcGxlVGltZWxpbmUsIFR3ZWVuTGl0ZSkge1xuXG5cdFx0dmFyIFRpbWVsaW5lTGl0ZSA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0U2ltcGxlVGltZWxpbmUuY2FsbCh0aGlzLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5fbGFiZWxzID0ge307XG5cdFx0XHRcdHRoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gKHRoaXMudmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLnNtb290aENoaWxkVGltaW5nID0gKHRoaXMudmFycy5zbW9vdGhDaGlsZFRpbWluZyA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX3NvcnRDaGlsZHJlbiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlID0gdGhpcy52YXJzLm9uVXBkYXRlO1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFycyxcblx0XHRcdFx0XHR2YWwsIHA7XG5cdFx0XHRcdGZvciAocCBpbiB2KSB7XG5cdFx0XHRcdFx0dmFsID0gdltwXTtcblx0XHRcdFx0XHRpZiAoX2lzQXJyYXkodmFsKSkgaWYgKHZhbC5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHR2W3BdID0gdGhpcy5fc3dhcFNlbGZJblBhcmFtcyh2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2lzQXJyYXkodi50d2VlbnMpKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGQodi50d2VlbnMsIDAsIHYuYWxpZ24sIHYuc3RhZ2dlcik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdFR3ZWVuTGl0ZUludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLFxuXHRcdFx0X2ludGVybmFscyA9IFRpbWVsaW5lTGl0ZS5faW50ZXJuYWxzID0ge30sXG5cdFx0XHRfaXNTZWxlY3RvciA9IFR3ZWVuTGl0ZUludGVybmFscy5pc1NlbGVjdG9yLFxuXHRcdFx0X2lzQXJyYXkgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNBcnJheSxcblx0XHRcdF9sYXp5VHdlZW5zID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlUd2VlbnMsXG5cdFx0XHRfbGF6eVJlbmRlciA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5UmVuZGVyLFxuXHRcdFx0X2dsb2JhbHMgPSBfZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxcblx0XHRcdF9jb3B5ID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0XHR2YXIgY29weSA9IHt9LCBwO1xuXHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdGNvcHlbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb3B5O1xuXHRcdFx0fSxcblx0XHRcdF9hcHBseUN5Y2xlID0gZnVuY3Rpb24odmFycywgdGFyZ2V0cywgaSkge1xuXHRcdFx0XHR2YXIgYWx0ID0gdmFycy5jeWNsZSxcblx0XHRcdFx0XHRwLCB2YWw7XG5cdFx0XHRcdGZvciAocCBpbiBhbHQpIHtcblx0XHRcdFx0XHR2YWwgPSBhbHRbcF07XG5cdFx0XHRcdFx0dmFyc1twXSA9ICh0eXBlb2YodmFsKSA9PT0gXCJmdW5jdGlvblwiKSA/IHZhbC5jYWxsKHRhcmdldHNbaV0sIGkpIDogdmFsW2kgJSB2YWwubGVuZ3RoXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgdmFycy5jeWNsZTtcblx0XHRcdH0sXG5cdFx0XHRfcGF1c2VDYWxsYmFjayA9IF9pbnRlcm5hbHMucGF1c2VDYWxsYmFjayA9IGZ1bmN0aW9uKCkge30sXG5cdFx0XHRfc2xpY2UgPSBmdW5jdGlvbihhKSB7IC8vZG9uJ3QgdXNlIFtdLnNsaWNlIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdHZhciBiID0gW10sXG5cdFx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgIT09IGw7IGIucHVzaChhW2krK10pKTtcblx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHR9LFxuXHRcdFx0cCA9IFRpbWVsaW5lTGl0ZS5wcm90b3R5cGUgPSBuZXcgU2ltcGxlVGltZWxpbmUoKTtcblxuXHRcdFRpbWVsaW5lTGl0ZS52ZXJzaW9uID0gXCIxLjE4LjRcIjtcblx0XHRwLmNvbnN0cnVjdG9yID0gVGltZWxpbmVMaXRlO1xuXHRcdHAua2lsbCgpLl9nYyA9IHAuX2ZvcmNpbmdQbGF5aGVhZCA9IHAuX2hhc1BhdXNlID0gZmFsc2U7XG5cblx0XHQvKiBtaWdodCB1c2UgbGF0ZXIuLi5cblx0XHQvL3RyYW5zbGF0ZXMgYSBsb2NhbCB0aW1lIGluc2lkZSBhbiBhbmltYXRpb24gdG8gdGhlIGNvcnJlc3BvbmRpbmcgdGltZSBvbiB0aGUgcm9vdC9nbG9iYWwgdGltZWxpbmUsIGZhY3RvcmluZyBpbiBhbGwgbmVzdGluZyBhbmQgdGltZVNjYWxlcy5cblx0XHRmdW5jdGlvbiBsb2NhbFRvR2xvYmFsKHRpbWUsIGFuaW1hdGlvbikge1xuXHRcdFx0d2hpbGUgKGFuaW1hdGlvbikge1xuXHRcdFx0XHR0aW1lID0gKHRpbWUgLyBhbmltYXRpb24uX3RpbWVTY2FsZSkgKyBhbmltYXRpb24uX3N0YXJ0VGltZTtcblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRpbWU7XG5cdFx0fVxuXG5cdFx0Ly90cmFuc2xhdGVzIHRoZSBzdXBwbGllZCB0aW1lIG9uIHRoZSByb290L2dsb2JhbCB0aW1lbGluZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGxvY2FsIHRpbWUgaW5zaWRlIGEgcGFydGljdWxhciBhbmltYXRpb24sIGZhY3RvcmluZyBpbiBhbGwgbmVzdGluZyBhbmQgdGltZVNjYWxlc1xuXHRcdGZ1bmN0aW9uIGdsb2JhbFRvTG9jYWwodGltZSwgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgc2NhbGUgPSAxO1xuXHRcdFx0dGltZSAtPSBsb2NhbFRvR2xvYmFsKDAsIGFuaW1hdGlvbik7XG5cdFx0XHR3aGlsZSAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHNjYWxlICo9IGFuaW1hdGlvbi5fdGltZVNjYWxlO1xuXHRcdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGltZSAqIHNjYWxlO1xuXHRcdH1cblx0XHQqL1xuXG5cdFx0cC50byA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgRW5naW5lID0gKHZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGU7XG5cdFx0XHRyZXR1cm4gZHVyYXRpb24gPyB0aGlzLmFkZCggbmV3IEVuZ2luZSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSwgcG9zaXRpb24pIDogdGhpcy5zZXQodGFyZ2V0LCB2YXJzLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuZnJvbSA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoICgodmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZSkuZnJvbSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLmZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgRW5naW5lID0gKHRvVmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZTtcblx0XHRcdHJldHVybiBkdXJhdGlvbiA/IHRoaXMuYWRkKCBFbmdpbmUuZnJvbVRvKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMpLCBwb3NpdGlvbikgOiB0aGlzLnNldCh0YXJnZXQsIHRvVmFycywgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnN0YWdnZXJUbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR2YXIgdGwgPSBuZXcgVGltZWxpbmVMaXRlKHtvbkNvbXBsZXRlOm9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVQYXJhbXM6b25Db21wbGV0ZUFsbFBhcmFtcywgY2FsbGJhY2tTY29wZTpvbkNvbXBsZXRlQWxsU2NvcGUsIHNtb290aENoaWxkVGltaW5nOnRoaXMuc21vb3RoQ2hpbGRUaW1pbmd9KSxcblx0XHRcdFx0Y3ljbGUgPSB2YXJzLmN5Y2xlLFxuXHRcdFx0XHRjb3B5LCBpO1xuXHRcdFx0aWYgKHR5cGVvZih0YXJnZXRzKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHR0YXJnZXRzID0gVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldHMpIHx8IHRhcmdldHM7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRzID0gdGFyZ2V0cyB8fCBbXTtcblx0XHRcdGlmIChfaXNTZWxlY3Rvcih0YXJnZXRzKSkgeyAvL3NlbnNlcyBpZiB0aGUgdGFyZ2V0cyBvYmplY3QgaXMgYSBzZWxlY3Rvci4gSWYgaXQgaXMsIHdlIHNob3VsZCB0cmFuc2xhdGUgaXQgaW50byBhbiBhcnJheS5cblx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdH1cblx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHRpZiAoc3RhZ2dlciA8IDApIHtcblx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdFx0dGFyZ2V0cy5yZXZlcnNlKCk7XG5cdFx0XHRcdHN0YWdnZXIgKj0gLTE7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb3B5ID0gX2NvcHkodmFycyk7XG5cdFx0XHRcdGlmIChjb3B5LnN0YXJ0QXQpIHtcblx0XHRcdFx0XHRjb3B5LnN0YXJ0QXQgPSBfY29weShjb3B5LnN0YXJ0QXQpO1xuXHRcdFx0XHRcdGlmIChjb3B5LnN0YXJ0QXQuY3ljbGUpIHtcblx0XHRcdFx0XHRcdF9hcHBseUN5Y2xlKGNvcHkuc3RhcnRBdCwgdGFyZ2V0cywgaSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjeWNsZSkge1xuXHRcdFx0XHRcdF9hcHBseUN5Y2xlKGNvcHksIHRhcmdldHMsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRsLnRvKHRhcmdldHNbaV0sIGR1cmF0aW9uLCBjb3B5LCBpICogc3RhZ2dlcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodGwsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFnZ2VyRnJvbSA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpO1xuXHRcdH07XG5cblx0XHRwLnN0YWdnZXJGcm9tVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpO1xuXHRcdH07XG5cblx0XHRwLmNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaywgcGFyYW1zLCBzY29wZSwgcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbiwgMCwgdHJ1ZSk7XG5cdFx0XHRpZiAodmFycy5pbW1lZGlhdGVSZW5kZXIgPT0gbnVsbCkge1xuXHRcdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9IChwb3NpdGlvbiA9PT0gdGhpcy5fdGltZSAmJiAhdGhpcy5fcGF1c2VkKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmFkZCggbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIDAsIHZhcnMpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdFRpbWVsaW5lTGl0ZS5leHBvcnRSb290ID0gZnVuY3Rpb24odmFycywgaWdub3JlRGVsYXllZENhbGxzKSB7XG5cdFx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdGlmICh2YXJzLnNtb290aENoaWxkVGltaW5nID09IG51bGwpIHtcblx0XHRcdFx0dmFycy5zbW9vdGhDaGlsZFRpbWluZyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGwgPSBuZXcgVGltZWxpbmVMaXRlKHZhcnMpLFxuXHRcdFx0XHRyb290ID0gdGwuX3RpbWVsaW5lLFxuXHRcdFx0XHR0d2VlbiwgbmV4dDtcblx0XHRcdGlmIChpZ25vcmVEZWxheWVkQ2FsbHMgPT0gbnVsbCkge1xuXHRcdFx0XHRpZ25vcmVEZWxheWVkQ2FsbHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cm9vdC5fcmVtb3ZlKHRsLCB0cnVlKTtcblx0XHRcdHRsLl9zdGFydFRpbWUgPSAwO1xuXHRcdFx0dGwuX3Jhd1ByZXZUaW1lID0gdGwuX3RpbWUgPSB0bC5fdG90YWxUaW1lID0gcm9vdC5fdGltZTtcblx0XHRcdHR3ZWVuID0gcm9vdC5fZmlyc3Q7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRpZiAoIWlnbm9yZURlbGF5ZWRDYWxscyB8fCAhKHR3ZWVuIGluc3RhbmNlb2YgVHdlZW5MaXRlICYmIHR3ZWVuLnRhcmdldCA9PT0gdHdlZW4udmFycy5vbkNvbXBsZXRlKSkge1xuXHRcdFx0XHRcdHRsLmFkZCh0d2VlbiwgdHdlZW4uX3N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0fVxuXHRcdFx0cm9vdC5hZGQodGwsIDApO1xuXHRcdFx0cmV0dXJuIHRsO1xuXHRcdH07XG5cblx0XHRwLmFkZCA9IGZ1bmN0aW9uKHZhbHVlLCBwb3NpdGlvbiwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHZhciBjdXJUaW1lLCBsLCBpLCBjaGlsZCwgdGwsIGJlZm9yZVJhd1RpbWU7XG5cdFx0XHRpZiAodHlwZW9mKHBvc2l0aW9uKSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24sIDAsIHRydWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdGlmICghKHZhbHVlIGluc3RhbmNlb2YgQW5pbWF0aW9uKSkge1xuXHRcdFx0XHRpZiAoKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHx8ICh2YWx1ZSAmJiB2YWx1ZS5wdXNoICYmIF9pc0FycmF5KHZhbHVlKSkpIHtcblx0XHRcdFx0XHRhbGlnbiA9IGFsaWduIHx8IFwibm9ybWFsXCI7XG5cdFx0XHRcdFx0c3RhZ2dlciA9IHN0YWdnZXIgfHwgMDtcblx0XHRcdFx0XHRjdXJUaW1lID0gcG9zaXRpb247XG5cdFx0XHRcdFx0bCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoX2lzQXJyYXkoY2hpbGQgPSB2YWx1ZVtpXSkpIHtcblx0XHRcdFx0XHRcdFx0Y2hpbGQgPSBuZXcgVGltZWxpbmVMaXRlKHt0d2VlbnM6Y2hpbGR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuYWRkKGNoaWxkLCBjdXJUaW1lKTtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoY2hpbGQpICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZihjaGlsZCkgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0XHRpZiAoYWxpZ24gPT09IFwic2VxdWVuY2VcIikge1xuXHRcdFx0XHRcdFx0XHRcdGN1clRpbWUgPSBjaGlsZC5fc3RhcnRUaW1lICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIGNoaWxkLl90aW1lU2NhbGUpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGFsaWduID09PSBcInN0YXJ0XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRjaGlsZC5fc3RhcnRUaW1lIC09IGNoaWxkLmRlbGF5KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN1clRpbWUgKz0gc3RhZ2dlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFkZExhYmVsKHZhbHVlLCBwb3NpdGlvbik7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgdmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93KFwiQ2Fubm90IGFkZCBcIiArIHZhbHVlICsgXCIgaW50byB0aGUgdGltZWxpbmU7IGl0IGlzIG5vdCBhIHR3ZWVuLCB0aW1lbGluZSwgZnVuY3Rpb24sIG9yIHN0cmluZy5cIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0U2ltcGxlVGltZWxpbmUucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIHZhbHVlLCBwb3NpdGlvbik7XG5cblx0XHRcdC8vaWYgdGhlIHRpbWVsaW5lIGhhcyBhbHJlYWR5IGVuZGVkIGJ1dCB0aGUgaW5zZXJ0ZWQgdHdlZW4vdGltZWxpbmUgZXh0ZW5kcyB0aGUgZHVyYXRpb24sIHdlIHNob3VsZCBlbmFibGUgdGhpcyB0aW1lbGluZSBhZ2FpbiBzbyB0aGF0IGl0IHJlbmRlcnMgcHJvcGVybHkuIFdlIHNob3VsZCBhbHNvIGFsaWduIHRoZSBwbGF5aGVhZCB3aXRoIHRoZSBwYXJlbnQgdGltZWxpbmUncyB3aGVuIGFwcHJvcHJpYXRlLlxuXHRcdFx0aWYgKHRoaXMuX2djIHx8IHRoaXMuX3RpbWUgPT09IHRoaXMuX2R1cmF0aW9uKSBpZiAoIXRoaXMuX3BhdXNlZCkgaWYgKHRoaXMuX2R1cmF0aW9uIDwgdGhpcy5kdXJhdGlvbigpKSB7XG5cdFx0XHRcdC8vaW4gY2FzZSBhbnkgb2YgdGhlIGFuY2VzdG9ycyBoYWQgY29tcGxldGVkIGJ1dCBzaG91bGQgbm93IGJlIGVuYWJsZWQuLi5cblx0XHRcdFx0dGwgPSB0aGlzO1xuXHRcdFx0XHRiZWZvcmVSYXdUaW1lID0gKHRsLnJhd1RpbWUoKSA+IHZhbHVlLl9zdGFydFRpbWUpOyAvL2lmIHRoZSB0d2VlbiBpcyBwbGFjZWQgb24gdGhlIHRpbWVsaW5lIHNvIHRoYXQgaXQgc3RhcnRzIEJFRk9SRSB0aGUgY3VycmVudCByYXdUaW1lLCB3ZSBzaG91bGQgYWxpZ24gdGhlIHBsYXloZWFkIChtb3ZlIHRoZSB0aW1lbGluZSkuIFRoaXMgaXMgYmVjYXVzZSBzb21ldGltZXMgdXNlcnMgd2lsbCBjcmVhdGUgYSB0aW1lbGluZSwgbGV0IGl0IGZpbmlzaCwgYW5kIG11Y2ggbGF0ZXIgYXBwZW5kIGEgdHdlZW4gYW5kIGV4cGVjdCBpdCB0byBydW4gaW5zdGVhZCBvZiBqdW1waW5nIHRvIGl0cyBlbmQgc3RhdGUuIFdoaWxlIHRlY2huaWNhbGx5IG9uZSBjb3VsZCBhcmd1ZSB0aGF0IGl0IHNob3VsZCBqdW1wIHRvIGl0cyBlbmQgc3RhdGUsIHRoYXQncyBub3Qgd2hhdCB1c2VycyBpbnR1aXRpdmVseSBleHBlY3QuXG5cdFx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRpZiAoYmVmb3JlUmF3VGltZSAmJiB0bC5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHRcdHRsLnRvdGFsVGltZSh0bC5fdG90YWxUaW1lLCB0cnVlKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0bC5fZ2MpIHtcblx0XHRcdFx0XHRcdHRsLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFuaW1hdGlvbikge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmUodmFsdWUsIGZhbHNlKTtcblx0XHRcdFx0dmFyIHRsID0gdmFsdWUuX3RpbWVsaW5lID0gdmFsdWUudmFycy51c2VGcmFtZXMgPyBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSA6IEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lOyAvL25vdyB0aGF0IGl0J3MgcmVtb3ZlZCwgZGVmYXVsdCBpdCB0byB0aGUgcm9vdCB0aW1lbGluZSBzbyB0aGF0IGlmIGl0IGdldHMgcGxheWVkIGFnYWluLCBpdCBkb2Vzbid0IGp1bXAgYmFjayBpbnRvIHRoaXMgdGltZWxpbmUuXG5cdFx0XHRcdHZhbHVlLl9zdGFydFRpbWUgPSAodmFsdWUuX3BhdXNlZCA/IHZhbHVlLl9wYXVzZVRpbWUgOiB0bC5fdGltZSkgLSAoKCF2YWx1ZS5fcmV2ZXJzZWQgPyB2YWx1ZS5fdG90YWxUaW1lIDogdmFsdWUudG90YWxEdXJhdGlvbigpIC0gdmFsdWUuX3RvdGFsVGltZSkgLyB2YWx1ZS5fdGltZVNjYWxlKTsgLy9lbnN1cmUgdGhhdCBpZiBpdCBnZXRzIHBsYXllZCBhZ2FpbiwgdGhlIHRpbWluZyBpcyBjb3JyZWN0LlxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSB8fCAodmFsdWUgJiYgdmFsdWUucHVzaCAmJiBfaXNBcnJheSh2YWx1ZSkpKSB7XG5cdFx0XHRcdHZhciBpID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZSh2YWx1ZVtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlTGFiZWwodmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMua2lsbChudWxsLCB2YWx1ZSk7XG5cdFx0fTtcblxuXHRcdHAuX3JlbW92ZSA9IGZ1bmN0aW9uKHR3ZWVuLCBza2lwRGlzYWJsZSkge1xuXHRcdFx0U2ltcGxlVGltZWxpbmUucHJvdG90eXBlLl9yZW1vdmUuY2FsbCh0aGlzLCB0d2Vlbiwgc2tpcERpc2FibGUpO1xuXHRcdFx0dmFyIGxhc3QgPSB0aGlzLl9sYXN0O1xuXHRcdFx0aWYgKCFsYXN0KSB7XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSAwO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lID4gbGFzdC5fc3RhcnRUaW1lICsgbGFzdC5fdG90YWxEdXJhdGlvbiAvIGxhc3QuX3RpbWVTY2FsZSkge1xuXHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuYXBwZW5kID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldE9yTGFiZWwpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh2YWx1ZSwgdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLCBvZmZzZXRPckxhYmVsLCB0cnVlLCB2YWx1ZSkpO1xuXHRcdH07XG5cblx0XHRwLmluc2VydCA9IHAuaW5zZXJ0TXVsdGlwbGUgPSBmdW5jdGlvbih2YWx1ZSwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodmFsdWUsIHBvc2l0aW9uIHx8IDAsIGFsaWduLCBzdGFnZ2VyKTtcblx0XHR9O1xuXG5cdFx0cC5hcHBlbmRNdWx0aXBsZSA9IGZ1bmN0aW9uKHR3ZWVucywgb2Zmc2V0T3JMYWJlbCwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh0d2VlbnMsIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwobnVsbCwgb2Zmc2V0T3JMYWJlbCwgdHJ1ZSwgdHdlZW5zKSwgYWxpZ24sIHN0YWdnZXIpO1xuXHRcdH07XG5cblx0XHRwLmFkZExhYmVsID0gZnVuY3Rpb24obGFiZWwsIHBvc2l0aW9uKSB7XG5cdFx0XHR0aGlzLl9sYWJlbHNbbGFiZWxdID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5hZGRQYXVzZSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0dmFyIHQgPSBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgX3BhdXNlQ2FsbGJhY2ssIHBhcmFtcywgc2NvcGUgfHwgdGhpcyk7XG5cdFx0XHR0LnZhcnMub25Db21wbGV0ZSA9IHQudmFycy5vblJldmVyc2VDb21wbGV0ZSA9IGNhbGxiYWNrO1xuXHRcdFx0dC5kYXRhID0gXCJpc1BhdXNlXCI7XG5cdFx0XHR0aGlzLl9oYXNQYXVzZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodCwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZUxhYmVsID0gZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sYWJlbHNbbGFiZWxdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZ2V0TGFiZWxUaW1lID0gZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdHJldHVybiAodGhpcy5fbGFiZWxzW2xhYmVsXSAhPSBudWxsKSA/IHRoaXMuX2xhYmVsc1tsYWJlbF0gOiAtMTtcblx0XHR9O1xuXG5cdFx0cC5fcGFyc2VUaW1lT3JMYWJlbCA9IGZ1bmN0aW9uKHRpbWVPckxhYmVsLCBvZmZzZXRPckxhYmVsLCBhcHBlbmRJZkFic2VudCwgaWdub3JlKSB7XG5cdFx0XHR2YXIgaTtcblx0XHRcdC8vaWYgd2UncmUgYWJvdXQgdG8gYWRkIGEgdHdlZW4vdGltZWxpbmUgKG9yIGFuIGFycmF5IG9mIHRoZW0pIHRoYXQncyBhbHJlYWR5IGEgY2hpbGQgb2YgdGhpcyB0aW1lbGluZSwgd2Ugc2hvdWxkIHJlbW92ZSBpdCBmaXJzdCBzbyB0aGF0IGl0IGRvZXNuJ3QgY29udGFtaW5hdGUgdGhlIGR1cmF0aW9uKCkuXG5cdFx0XHRpZiAoaWdub3JlIGluc3RhbmNlb2YgQW5pbWF0aW9uICYmIGlnbm9yZS50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHR0aGlzLnJlbW92ZShpZ25vcmUpO1xuXHRcdFx0fSBlbHNlIGlmIChpZ25vcmUgJiYgKChpZ25vcmUgaW5zdGFuY2VvZiBBcnJheSkgfHwgKGlnbm9yZS5wdXNoICYmIF9pc0FycmF5KGlnbm9yZSkpKSkge1xuXHRcdFx0XHRpID0gaWdub3JlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGlnbm9yZVtpXSBpbnN0YW5jZW9mIEFuaW1hdGlvbiAmJiBpZ25vcmVbaV0udGltZWxpbmUgPT09IHRoaXMpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlKGlnbm9yZVtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mKG9mZnNldE9yTGFiZWwpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG9mZnNldE9yTGFiZWwsIChhcHBlbmRJZkFic2VudCAmJiB0eXBlb2YodGltZU9yTGFiZWwpID09PSBcIm51bWJlclwiICYmIHRoaXMuX2xhYmVsc1tvZmZzZXRPckxhYmVsXSA9PSBudWxsKSA/IHRpbWVPckxhYmVsIC0gdGhpcy5kdXJhdGlvbigpIDogMCwgYXBwZW5kSWZBYnNlbnQpO1xuXHRcdFx0fVxuXHRcdFx0b2Zmc2V0T3JMYWJlbCA9IG9mZnNldE9yTGFiZWwgfHwgMDtcblx0XHRcdGlmICh0eXBlb2YodGltZU9yTGFiZWwpID09PSBcInN0cmluZ1wiICYmIChpc05hTih0aW1lT3JMYWJlbCkgfHwgdGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSAhPSBudWxsKSkgeyAvL2lmIHRoZSBzdHJpbmcgaXMgYSBudW1iZXIgbGlrZSBcIjFcIiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBsYWJlbCB3aXRoIHRoYXQgbmFtZSwgb3RoZXJ3aXNlIGludGVycHJldCBpdCBhcyBhIG51bWJlciAoYWJzb2x1dGUgdmFsdWUpLlxuXHRcdFx0XHRpID0gdGltZU9yTGFiZWwuaW5kZXhPZihcIj1cIik7XG5cdFx0XHRcdGlmIChpID09PSAtMSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdID09IG51bGwpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhcHBlbmRJZkFic2VudCA/ICh0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdID0gdGhpcy5kdXJhdGlvbigpICsgb2Zmc2V0T3JMYWJlbCkgOiBvZmZzZXRPckxhYmVsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSArIG9mZnNldE9yTGFiZWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2Zmc2V0T3JMYWJlbCA9IHBhcnNlSW50KHRpbWVPckxhYmVsLmNoYXJBdChpLTEpICsgXCIxXCIsIDEwKSAqIE51bWJlcih0aW1lT3JMYWJlbC5zdWJzdHIoaSsxKSk7XG5cdFx0XHRcdHRpbWVPckxhYmVsID0gKGkgPiAxKSA/IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwodGltZU9yTGFiZWwuc3Vic3RyKDAsIGktMSksIDAsIGFwcGVuZElmQWJzZW50KSA6IHRoaXMuZHVyYXRpb24oKTtcblx0XHRcdH0gZWxzZSBpZiAodGltZU9yTGFiZWwgPT0gbnVsbCkge1xuXHRcdFx0XHR0aW1lT3JMYWJlbCA9IHRoaXMuZHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBOdW1iZXIodGltZU9yTGFiZWwpICsgb2Zmc2V0T3JMYWJlbDtcblx0XHR9O1xuXG5cdFx0cC5zZWVrID0gZnVuY3Rpb24ocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoKHR5cGVvZihwb3NpdGlvbikgPT09IFwibnVtYmVyXCIpID8gcG9zaXRpb24gOiB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKSwgKHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSkpO1xuXHRcdH07XG5cblx0XHRwLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZCh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMucGxheShwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLmdvdG9BbmRTdG9wID0gZnVuY3Rpb24ocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZShwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0cHJldlN0YXJ0ID0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdFx0XHRwcmV2VGltZVNjYWxlID0gdGhpcy5fdGltZVNjYWxlLFxuXHRcdFx0XHRwcmV2UGF1c2VkID0gdGhpcy5fcGF1c2VkLFxuXHRcdFx0XHR0d2VlbiwgaXNDb21wbGV0ZSwgbmV4dCwgY2FsbGJhY2ssIGludGVybmFsRm9yY2UsIHBhdXNlVHdlZW4sIGN1clRpbWU7XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1ciAtIDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0b3RhbER1cjtcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXZlcnNlZCkgaWYgKCF0aGlzLl9oYXNQYXVzZWRDaGlsZCgpKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gISF0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW47IC8vb3RoZXJ3aXNlLCBpZiB0aGUgYW5pbWF0aW9uIGlzIHVucGF1c2VkL2FjdGl2YXRlZCBhZnRlciBpdCdzIGFscmVhZHkgZmluaXNoZWQsIGl0IGRvZXNuJ3QgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHRpbWVsaW5lLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9kdXJhdGlvbiA9PT0gMCkgaWYgKCh0aW1lIDw9IDAgJiYgdGltZSA+PSAtMC4wMDAwMDAxKSB8fCB0aGlzLl9yYXdQcmV2VGltZSA8IDAgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IF90aW55TnVtKSBpZiAodGhpcy5fcmF3UHJldlRpbWUgIT09IHRpbWUgJiYgdGhpcy5fZmlyc3QpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3Jhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0dGltZSA9IHRvdGFsRHVyICsgMC4wMDAxOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIC0gc29tZXRpbWVzIGNoaWxkIHR3ZWVucy90aW1lbGluZXMgd2VyZSBub3QgYmVpbmcgZnVsbHkgY29tcGxldGVkICh0aGVpciBwcm9ncmVzcyBtaWdodCBiZSAwLjk5OTk5OTk5OTk5OTk5OCBpbnN0ZWFkIG9mIDEgYmVjYXVzZSB3aGVuIF90aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSBpcyBwZXJmb3JtZWQsIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3b3VsZCByZXR1cm4gYSB2YWx1ZSB0aGF0IHdhcyBTTElHSFRMWSBvZmYpLiBUcnkgKDk5OTk5OTk5OTk5OS43IC0gOTk5OTk5OTk5OTk5KSAqIDEgPSAwLjY5OTk1MTE3MTg3NSBpbnN0ZWFkIG9mIDAuNy5cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKHRoaXMuX2R1cmF0aW9uID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lICE9PSBfdGlueU51bSAmJiAodGhpcy5fcmF3UHJldlRpbWUgPiAwIHx8ICh0aW1lIDwgMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA+PSAwKSkpKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgdGhpcy5fcmV2ZXJzZWQpIHsgLy9lbnN1cmVzIHByb3BlciBHQyBpZiBhIHRpbWVsaW5lIGlzIHJlc3VtZWQgYWZ0ZXIgaXQncyBmaW5pc2hlZCByZXZlcnNpbmcuXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gaXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3Jhd1ByZXZUaW1lID49IDAgJiYgdGhpcy5fZmlyc3QpIHsgLy93aGVuIGdvaW5nIGJhY2sgYmV5b25kIHRoZSBzdGFydCwgZm9yY2UgYSByZW5kZXIgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyB0aGF0IHNpdCBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgcmVuZGVyIHRoZWlyIHN0YXJ0IHZhbHVlcyBwcm9wZXJseS4gT3RoZXJ3aXNlLCBpZiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgbGFuZHMgZXhhY3RseSBhdCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lLCBhbmQgdGhlbiBtb3ZlcyBiYWNrd2FyZHMsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgYmVnaW5uaW5nIHdvdWxkIHN0aWxsIGJlIGF0IHRoZWlyIGVuZCBzdGF0ZS5cblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAodGhpcy5fZHVyYXRpb24gfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdGlmICh0aW1lID09PSAwICYmIGlzQ29tcGxldGUpIHsgLy9pZiB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgYSB0aW1lbGluZSBhbmQgdGhlIHBsYXloZWFkIGxhbmRzIEVYQUNUTFkgYXQgdGltZSAwLCB0aGF0IHR3ZWVuIHdpbGwgY29ycmVjdGx5IHJlbmRlciBpdHMgZW5kIHZhbHVlcywgYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgdGltZWxpbmUgYWxpdmUgZm9yIG9uZSBtb3JlIHJlbmRlciBzbyB0aGF0IHRoZSBiZWdpbm5pbmcgdmFsdWVzIHJlbmRlciBwcm9wZXJseSBhcyB0aGUgcGFyZW50J3MgcGxheWhlYWQga2VlcHMgbW92aW5nIGJleW9uZCB0aGUgYmVnaW5pbmcuIEltYWdpbmUgb2JqLnggc3RhcnRzIGF0IDAgYW5kIHRoZW4gd2UgZG8gdGwuc2V0KG9iaiwge3g6MTAwfSkudG8ob2JqLCAxLCB7eDoyMDB9KSBhbmQgdGhlbiBsYXRlciB3ZSB0bC5yZXZlcnNlKCkuLi50aGUgZ29hbCBpcyB0byBoYXZlIG9iai54IHJldmVydCB0byAwLiBJZiB0aGUgcGxheWhlYWQgaGFwcGVucyB0byBsYW5kIG9uIGV4YWN0bHkgMCwgd2l0aG91dCB0aGlzIGNodW5rIG9mIGNvZGUsIGl0J2QgY29tcGxldGUgdGhlIHRpbWVsaW5lIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcmVuZGVyaW5nIHF1ZXVlIChub3QgZ29vZCkuXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRpc0NvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZSA9IDA7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgKGNvdWxkIGNhdXNlIHByb2JsZW1zIGVzcGVjaWFsbHkgd2l0aCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lKVxuXHRcdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2hhc1BhdXNlICYmICF0aGlzLl9mb3JjaW5nUGxheWhlYWQgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gcHJldlRpbWUpIHtcblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA8PSB0aW1lICYmICFwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSBpZiAodHdlZW4uZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgIXR3ZWVuLnJhdGlvICYmICEodHdlZW4uX3N0YXJ0VGltZSA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA9PT0gMCkpIHtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gdHdlZW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPj0gdGltZSAmJiAhcGF1c2VUd2Vlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikgaWYgKHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIHR3ZWVuLl9yYXdQcmV2VGltZSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gdHdlZW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lID0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGltZSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl90b3RhbER1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCh0aGlzLl90aW1lID09PSBwcmV2VGltZSB8fCAhdGhpcy5fZmlyc3QpICYmICFmb3JjZSAmJiAhaW50ZXJuYWxGb3JjZSAmJiAhcGF1c2VUd2Vlbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdGltZSAhPT0gcHJldlRpbWUgJiYgdGltZSA+IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgIC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIHRoZSB0aW1lbGluZSAoYXMgb3Bwb3NlZCB0byB0aGUgcGFyZW50IHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIGl0IGlzIGZvcmNlZCB0byByZS1yZW5kZXIgYW5kIGFsaWduIGl0IHdpdGggdGhlIHByb3BlciB0aW1lL2ZyYW1lIG9uIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZS4gTWF5YmUgdGhlIHRpbWVsaW5lIGFscmVhZHkgZmluaXNoZWQgYnV0IHRoZSB1c2VyIG1hbnVhbGx5IHJlLXJlbmRlcnMgaXQgYXMgaGFsZndheSBkb25lLCBmb3IgZXhhbXBsZS5cblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZXZUaW1lID09PSAwKSBpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90aW1lICE9PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25TdGFydFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Y3VyVGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRpZiAoY3VyVGltZSA+PSBwcmV2VGltZSkge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmIChjdXJUaW1lICE9PSB0aGlzLl90aW1lIHx8ICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSBjdXJUaW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAocGF1c2VUd2VlbiA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAoY3VyVGltZSAhPT0gdGhpcy5fdGltZSB8fCAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHR3ZWVuLl9zdGFydFRpbWUgPD0gcHJldlRpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gdHdlZW4uX3ByZXY7IC8vdGhlIGxpbmtlZCBsaXN0IGlzIG9yZ2FuaXplZCBieSBfc3RhcnRUaW1lLCB0aHVzIGl0J3MgcG9zc2libGUgdGhhdCBhIHR3ZWVuIGNvdWxkIHN0YXJ0IEJFRk9SRSB0aGUgcGF1c2UgYW5kIGVuZCBhZnRlciBpdCwgaW4gd2hpY2ggY2FzZSBpdCB3b3VsZCBiZSBwb3NpdGlvbmVkIGJlZm9yZSB0aGUgcGF1c2UgdHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0LCBidXQgd2Ugc2hvdWxkIHJlbmRlciBpdCBiZWZvcmUgd2UgcGF1c2UoKSB0aGUgdGltZWxpbmUgYW5kIGNlYXNlIHJlbmRlcmluZy4gVGhpcyBpcyBvbmx5IGEgY29uY2VybiB3aGVuIGdvaW5nIGluIHJldmVyc2UuXG5cdFx0XHRcdFx0XHRcdHdoaWxlIChwYXVzZVR3ZWVuICYmIHBhdXNlVHdlZW4uZW5kVGltZSgpID4gdGhpcy5fdGltZSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4ucmVuZGVyKCAocGF1c2VUd2Vlbi5fcmV2ZXJzZWQgPyBwYXVzZVR3ZWVuLnRvdGFsRHVyYXRpb24oKSAtICgodGltZSAtIHBhdXNlVHdlZW4uX3N0YXJ0VGltZSkgKiBwYXVzZVR3ZWVuLl90aW1lU2NhbGUpIDogKHRpbWUgLSBwYXVzZVR3ZWVuLl9zdGFydFRpbWUpICogcGF1c2VUd2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gcGF1c2VUd2Vlbi5fcHJldjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fZ2MpIGlmIChwcmV2U3RhcnQgPT09IHRoaXMuX3N0YXJ0VGltZSB8fCBwcmV2VGltZVNjYWxlICE9PSB0aGlzLl90aW1lU2NhbGUpIGlmICh0aGlzLl90aW1lID09PSAwIHx8IHRvdGFsRHVyID49IHRoaXMudG90YWxEdXJhdGlvbigpKSB7IC8vaWYgb25lIG9mIHRoZSB0d2VlbnMgdGhhdCB3YXMgcmVuZGVyZWQgYWx0ZXJlZCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lIChsaWtlIGlmIGFuIG9uQ29tcGxldGUgcmV2ZXJzZWQgdGhlIHRpbWVsaW5lKSwgaXQgcHJvYmFibHkgaXNuJ3QgY29tcGxldGUuIElmIGl0IGlzLCBkb24ndCB3b3JyeSwgYmVjYXVzZSB3aGF0ZXZlciBjYWxsIGFsdGVyZWQgdGhlIHN0YXJ0VGltZSB3b3VsZCBjb21wbGV0ZSBpZiBpdCB3YXMgbmVjZXNzYXJ5IGF0IHRoZSBuZXcgdGltZS4gVGhlIG9ubHkgZXhjZXB0aW9uIGlzIHRoZSB0aW1lU2NhbGUgcHJvcGVydHkuIEFsc28gY2hlY2sgX2djIGJlY2F1c2UgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGtpbGwoKSBjb3VsZCBiZSBjYWxsZWQgaW4gYW4gb25VcGRhdGVcblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25Db21wbGV0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKGNhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLl9oYXNQYXVzZWRDaGlsZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0aWYgKHR3ZWVuLl9wYXVzZWQgfHwgKCh0d2VlbiBpbnN0YW5jZW9mIFRpbWVsaW5lTGl0ZSkgJiYgdHdlZW4uX2hhc1BhdXNlZENoaWxkKCkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdGlnbm9yZUJlZm9yZVRpbWUgPSBpZ25vcmVCZWZvcmVUaW1lIHx8IC05OTk5OTk5OTk5O1xuXHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0Y250ID0gMDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA8IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0XHQvL2RvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIGlmICh0d2VlbiBpbnN0YW5jZW9mIFR3ZWVuTGl0ZSkge1xuXHRcdFx0XHRcdGlmICh0d2VlbnMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGltZWxpbmVzICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG5lc3RlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGEgPSBhLmNvbmNhdCh0d2Vlbi5nZXRDaGlsZHJlbih0cnVlLCB0d2VlbnMsIHRpbWVsaW5lcykpO1xuXHRcdFx0XHRcdFx0Y250ID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cdFx0cC5nZXRUd2VlbnNPZiA9IGZ1bmN0aW9uKHRhcmdldCwgbmVzdGVkKSB7XG5cdFx0XHR2YXIgZGlzYWJsZWQgPSB0aGlzLl9nYyxcblx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHR0d2VlbnMsIGk7XG5cdFx0XHRpZiAoZGlzYWJsZWQpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCB0cnVlKTsgLy9nZXRUd2VlbnNPZigpIGZpbHRlcnMgb3V0IGRpc2FibGVkIHR3ZWVucywgYW5kIHdlIGhhdmUgdG8gbWFyayB0aGVtIGFzIF9nYyA9IHRydWUgd2hlbiB0aGUgdGltZWxpbmUgY29tcGxldGVzIGluIG9yZGVyIHRvIGFsbG93IGNsZWFuIGdhcmJhZ2UgY29sbGVjdGlvbiwgc28gdGVtcG9yYXJpbHkgcmUtZW5hYmxlIHRoZSB0aW1lbGluZSBoZXJlLlxuXHRcdFx0fVxuXHRcdFx0dHdlZW5zID0gVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldCk7XG5cdFx0XHRpID0gdHdlZW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAodHdlZW5zW2ldLnRpbWVsaW5lID09PSB0aGlzIHx8IChuZXN0ZWQgJiYgdGhpcy5fY29udGFpbnModHdlZW5zW2ldKSkpIHtcblx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRpc2FibGVkKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdHAucmVjZW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVjZW50O1xuXHRcdH07XG5cblx0XHRwLl9jb250YWlucyA9IGZ1bmN0aW9uKHR3ZWVuKSB7XG5cdFx0XHR2YXIgdGwgPSB0d2Vlbi50aW1lbGluZTtcblx0XHRcdHdoaWxlICh0bCkge1xuXHRcdFx0XHRpZiAodGwgPT09IHRoaXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bCA9IHRsLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLnNoaWZ0Q2hpbGRyZW4gPSBmdW5jdGlvbihhbW91bnQsIGFkanVzdExhYmVscywgaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0aWdub3JlQmVmb3JlVGltZSA9IGlnbm9yZUJlZm9yZVRpbWUgfHwgMDtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRsYWJlbHMgPSB0aGlzLl9sYWJlbHMsXG5cdFx0XHRcdHA7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdHR3ZWVuLl9zdGFydFRpbWUgKz0gYW1vdW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWRqdXN0TGFiZWxzKSB7XG5cdFx0XHRcdGZvciAocCBpbiBsYWJlbHMpIHtcblx0XHRcdFx0XHRpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0XHRcdGxhYmVsc1twXSArPSBhbW91bnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0aWYgKCF2YXJzICYmICF0YXJnZXQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHZhciB0d2VlbnMgPSAoIXRhcmdldCkgPyB0aGlzLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKSA6IHRoaXMuZ2V0VHdlZW5zT2YodGFyZ2V0KSxcblx0XHRcdFx0aSA9IHR3ZWVucy5sZW5ndGgsXG5cdFx0XHRcdGNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAodHdlZW5zW2ldLl9raWxsKHZhcnMsIHRhcmdldCkpIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdHAuY2xlYXIgPSBmdW5jdGlvbihsYWJlbHMpIHtcblx0XHRcdHZhciB0d2VlbnMgPSB0aGlzLmdldENoaWxkcmVuKGZhbHNlLCB0cnVlLCB0cnVlKSxcblx0XHRcdFx0aSA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lID0gMDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHR0d2VlbnNbaV0uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmIChsYWJlbHMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX2xhYmVscyA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0dHdlZW4uaW52YWxpZGF0ZSgpO1xuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEFuaW1hdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpOztcblx0XHR9O1xuXG5cdFx0cC5fZW5hYmxlZCA9IGZ1bmN0aW9uKGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKSB7XG5cdFx0XHRpZiAoZW5hYmxlZCA9PT0gdGhpcy5fZ2MpIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdHR3ZWVuLl9lbmFibGVkKGVuYWJsZWQsIHRydWUpO1xuXHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuX2VuYWJsZWQuY2FsbCh0aGlzLCBlbmFibGVkLCBpZ25vcmVUaW1lbGluZSk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxUaW1lID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIHVuY2FwcGVkKSB7XG5cdFx0XHR0aGlzLl9mb3JjaW5nUGxheWhlYWQgPSB0cnVlO1xuXHRcdFx0dmFyIHZhbCA9IEFuaW1hdGlvbi5wcm90b3R5cGUudG90YWxUaW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLl9mb3JjaW5nUGxheWhlYWQgPSBmYWxzZTtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fTtcblxuXHRcdHAuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpOyAvL2p1c3QgdHJpZ2dlcnMgcmVjYWxjdWxhdGlvblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmR1cmF0aW9uKCkgIT09IDAgJiYgdmFsdWUgIT09IDApIHtcblx0XHRcdFx0dGhpcy50aW1lU2NhbGUodGhpcy5fZHVyYXRpb24gLyB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHR2YXIgbWF4ID0gMCxcblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdCxcblx0XHRcdFx0XHRcdHByZXZTdGFydCA9IDk5OTk5OTk5OTk5OSxcblx0XHRcdFx0XHRcdHByZXYsIGVuZDtcblx0XHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRcdHByZXYgPSB0d2Vlbi5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBpbiBjYXNlIHRoZSB0d2VlbiBjaGFuZ2VzIHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZS4uLlxuXHRcdFx0XHRcdFx0aWYgKHR3ZWVuLl9kaXJ0eSkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi50b3RhbER1cmF0aW9uKCk7IC8vY291bGQgY2hhbmdlIHRoZSB0d2Vlbi5fc3RhcnRUaW1lLCBzbyBtYWtlIHN1cmUgdGhlIHR3ZWVuJ3MgY2FjaGUgaXMgY2xlYW4gYmVmb3JlIGFuYWx5emluZyBpdC5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID4gcHJldlN0YXJ0ICYmIHRoaXMuX3NvcnRDaGlsZHJlbiAmJiAhdHdlZW4uX3BhdXNlZCkgeyAvL2luIGNhc2Ugb25lIG9mIHRoZSB0d2VlbnMgc2hpZnRlZCBvdXQgb2Ygb3JkZXIsIGl0IG5lZWRzIHRvIGJlIHJlLWluc2VydGVkIGludG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlXG5cdFx0XHRcdFx0XHRcdHRoaXMuYWRkKHR3ZWVuLCB0d2Vlbi5fc3RhcnRUaW1lIC0gdHdlZW4uX2RlbGF5KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHByZXZTdGFydCA9IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA8IDAgJiYgIXR3ZWVuLl9wYXVzZWQpIHsgLy9jaGlsZHJlbiBhcmVuJ3QgYWxsb3dlZCB0byBoYXZlIG5lZ2F0aXZlIHN0YXJ0VGltZXMgdW5sZXNzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHNvIGFkanVzdCBoZXJlIGlmIG9uZSBpcyBmb3VuZC5cblx0XHRcdFx0XHRcdFx0bWF4IC09IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSArPSB0d2Vlbi5fc3RhcnRUaW1lIC8gdGhpcy5fdGltZVNjYWxlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hpZnRDaGlsZHJlbigtdHdlZW4uX3N0YXJ0VGltZSwgZmFsc2UsIC05OTk5OTk5OTk5KTtcblx0XHRcdFx0XHRcdFx0cHJldlN0YXJ0ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVuZCA9IHR3ZWVuLl9zdGFydFRpbWUgKyAodHdlZW4uX3RvdGFsRHVyYXRpb24gLyB0d2Vlbi5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRcdGlmIChlbmQgPiBtYXgpIHtcblx0XHRcdFx0XHRcdFx0bWF4ID0gZW5kO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHdlZW4gPSBwcmV2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSBtYXg7XG5cdFx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodmFsdWUgJiYgdGhpcy50b3RhbER1cmF0aW9uKCkpID8gdGhpcy50aW1lU2NhbGUodGhpcy5fdG90YWxEdXJhdGlvbiAvIHZhbHVlKSA6IHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghdmFsdWUpIHsgLy9pZiB0aGVyZSdzIGEgcGF1c2UgZGlyZWN0bHkgYXQgdGhlIHNwb3QgZnJvbSB3aGVyZSB3ZSdyZSB1bnBhdXNpbmcsIHNraXAgaXQuXG5cdFx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA9PT0gdGltZSAmJiB0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIikge1xuXHRcdFx0XHRcdFx0dHdlZW4uX3Jhd1ByZXZUaW1lID0gMDsgLy9yZW1lbWJlciwgX3Jhd1ByZXZUaW1lIGlzIGhvdyB6ZXJvLWR1cmF0aW9uIHR3ZWVucy9jYWxsYmFja3Mgc2Vuc2UgZGlyZWN0aW9uYWxpdHkgYW5kIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBmaXJlLiBJZiBfcmF3UHJldlRpbWUgaXMgdGhlIHNhbWUgYXMgX3N0YXJ0VGltZSBvbiB0aGUgbmV4dCByZW5kZXIsIGl0IHdvbid0IGZpcmUuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBBbmltYXRpb24ucHJvdG90eXBlLnBhdXNlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHRwLnVzZXNGcmFtZXMgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0bCA9IHRoaXMuX3RpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodGwgPT09IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lKTtcblx0XHR9O1xuXG5cdFx0cC5yYXdUaW1lID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkID8gdGhpcy5fdG90YWxUaW1lIDogKHRoaXMuX3RpbWVsaW5lLnJhd1RpbWUoKSAtIHRoaXMuX3N0YXJ0VGltZSkgKiB0aGlzLl90aW1lU2NhbGU7XG5cdFx0fTtcblxuXHRcdHJldHVybiBUaW1lbGluZUxpdGU7XG5cblx0fSwgdHJ1ZSk7XG5cblxuXG5cblxuXG5cblxuXHRcblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVGltZWxpbmVNYXhcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUaW1lbGluZU1heFwiLCBbXCJUaW1lbGluZUxpdGVcIixcIlR3ZWVuTGl0ZVwiLFwiZWFzaW5nLkVhc2VcIl0sIGZ1bmN0aW9uKFRpbWVsaW5lTGl0ZSwgVHdlZW5MaXRlLCBFYXNlKSB7XG5cblx0XHR2YXIgVGltZWxpbmVNYXggPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRcdFRpbWVsaW5lTGl0ZS5jYWxsKHRoaXMsIHZhcnMpO1xuXHRcdFx0XHR0aGlzLl9yZXBlYXQgPSB0aGlzLnZhcnMucmVwZWF0IHx8IDA7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdGhpcy52YXJzLnJlcGVhdERlbGF5IHx8IDA7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gMDtcblx0XHRcdFx0dGhpcy5feW95byA9ICh0aGlzLnZhcnMueW95byA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdFR3ZWVuTGl0ZUludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLFxuXHRcdFx0X2xhenlUd2VlbnMgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVR3ZWVucyxcblx0XHRcdF9sYXp5UmVuZGVyID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlSZW5kZXIsXG5cdFx0XHRfZWFzZU5vbmUgPSBuZXcgRWFzZShudWxsLCBudWxsLCAxLCAwKSxcblx0XHRcdHAgPSBUaW1lbGluZU1heC5wcm90b3R5cGUgPSBuZXcgVGltZWxpbmVMaXRlKCk7XG5cblx0XHRwLmNvbnN0cnVjdG9yID0gVGltZWxpbmVNYXg7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cdFx0VGltZWxpbmVNYXgudmVyc2lvbiA9IFwiMS4xOC40XCI7XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRyZXR1cm4gVGltZWxpbmVMaXRlLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0fTtcblxuXHRcdHAuYWRkQ2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgcG9zaXRpb24sIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZUNhbGxiYWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBvc2l0aW9uKSB7XG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0aWYgKHBvc2l0aW9uID09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLl9raWxsKG51bGwsIGNhbGxiYWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgYSA9IHRoaXMuZ2V0VHdlZW5zT2YoY2FsbGJhY2ssIGZhbHNlKSxcblx0XHRcdFx0XHRcdGkgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRcdHRpbWUgPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChhW2ldLl9zdGFydFRpbWUgPT09IHRpbWUpIHtcblx0XHRcdFx0XHRcdFx0YVtpXS5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlUGF1c2UgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlQ2FsbGJhY2soVGltZWxpbmVMaXRlLl9pbnRlcm5hbHMucGF1c2VDYWxsYmFjaywgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnR3ZWVuVG8gPSBmdW5jdGlvbihwb3NpdGlvbiwgdmFycykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHR2YXIgY29weSA9IHtlYXNlOl9lYXNlTm9uZSwgdXNlRnJhbWVzOnRoaXMudXNlc0ZyYW1lcygpLCBpbW1lZGlhdGVSZW5kZXI6ZmFsc2V9LFxuXHRcdFx0XHRkdXJhdGlvbiwgcCwgdDtcblx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdGNvcHlbcF0gPSB2YXJzW3BdO1xuXHRcdFx0fVxuXHRcdFx0Y29weS50aW1lID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbik7XG5cdFx0XHRkdXJhdGlvbiA9IChNYXRoLmFicyhOdW1iZXIoY29weS50aW1lKSAtIHRoaXMuX3RpbWUpIC8gdGhpcy5fdGltZVNjYWxlKSB8fCAwLjAwMTtcblx0XHRcdHQgPSBuZXcgVHdlZW5MaXRlKHRoaXMsIGR1cmF0aW9uLCBjb3B5KTtcblx0XHRcdGNvcHkub25TdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0LnRhcmdldC5wYXVzZWQodHJ1ZSk7XG5cdFx0XHRcdGlmICh0LnZhcnMudGltZSAhPT0gdC50YXJnZXQudGltZSgpICYmIGR1cmF0aW9uID09PSB0LmR1cmF0aW9uKCkpIHsgLy9kb24ndCBtYWtlIHRoZSBkdXJhdGlvbiB6ZXJvIC0gaWYgaXQncyBzdXBwb3NlZCB0byBiZSB6ZXJvLCBkb24ndCB3b3JyeSBiZWNhdXNlIGl0J3MgYWxyZWFkeSBpbml0dGluZyB0aGUgdHdlZW4gYW5kIHdpbGwgY29tcGxldGUgaW1tZWRpYXRlbHksIGVmZmVjdGl2ZWx5IG1ha2luZyB0aGUgZHVyYXRpb24gemVybyBhbnl3YXkuIElmIHdlIG1ha2UgZHVyYXRpb24gemVybywgdGhlIHR3ZWVuIHdvbid0IHJ1biBhdCBhbGwuXG5cdFx0XHRcdFx0dC5kdXJhdGlvbiggTWF0aC5hYnMoIHQudmFycy50aW1lIC0gdC50YXJnZXQudGltZSgpKSAvIHQudGFyZ2V0Ll90aW1lU2NhbGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFycy5vblN0YXJ0KSB7IC8vaW4gY2FzZSB0aGUgdXNlciBoYWQgYW4gb25TdGFydCBpbiB0aGUgdmFycyAtIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIGl0LlxuXHRcdFx0XHRcdHQuX2NhbGxiYWNrKFwib25TdGFydFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0O1xuXHRcdH07XG5cblx0XHRwLnR3ZWVuRnJvbVRvID0gZnVuY3Rpb24oZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdGZyb21Qb3NpdGlvbiA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwoZnJvbVBvc2l0aW9uKTtcblx0XHRcdHZhcnMuc3RhcnRBdCA9IHtvbkNvbXBsZXRlOnRoaXMuc2Vlaywgb25Db21wbGV0ZVBhcmFtczpbZnJvbVBvc2l0aW9uXSwgY2FsbGJhY2tTY29wZTp0aGlzfTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSk7XG5cdFx0XHR2YXIgdCA9IHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCB2YXJzKTtcblx0XHRcdHJldHVybiB0LmR1cmF0aW9uKChNYXRoLmFicyggdC52YXJzLnRpbWUgLSBmcm9tUG9zaXRpb24pIC8gdGhpcy5fdGltZVNjYWxlKSB8fCAwLjAwMSk7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG90YWxEdXIgPSAoIXRoaXMuX2RpcnR5KSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLnRvdGFsRHVyYXRpb24oKSxcblx0XHRcdFx0ZHVyID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0cHJldlRvdGFsVGltZSA9IHRoaXMuX3RvdGFsVGltZSxcblx0XHRcdFx0cHJldlN0YXJ0ID0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdFx0XHRwcmV2VGltZVNjYWxlID0gdGhpcy5fdGltZVNjYWxlLFxuXHRcdFx0XHRwcmV2UmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0cHJldlBhdXNlZCA9IHRoaXMuX3BhdXNlZCxcblx0XHRcdFx0cHJldkN5Y2xlID0gdGhpcy5fY3ljbGUsXG5cdFx0XHRcdHR3ZWVuLCBpc0NvbXBsZXRlLCBuZXh0LCBjYWxsYmFjaywgaW50ZXJuYWxGb3JjZSwgY3ljbGVEdXJhdGlvbiwgcGF1c2VUd2VlbiwgY3VyVGltZTtcblx0XHRcdGlmICh0aW1lID49IHRvdGFsRHVyIC0gMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cy5cblx0XHRcdFx0aWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0b3RhbER1cjtcblx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9IHRoaXMuX3JlcGVhdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkKSBpZiAoIXRoaXMuX2hhc1BhdXNlZENoaWxkKCkpIHtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25Db21wbGV0ZVwiO1xuXHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSAhIXRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbjsgLy9vdGhlcndpc2UsIGlmIHRoZSBhbmltYXRpb24gaXMgdW5wYXVzZWQvYWN0aXZhdGVkIGFmdGVyIGl0J3MgYWxyZWFkeSBmaW5pc2hlZCwgaXQgZG9lc24ndCBnZXQgcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgdGltZWxpbmUuXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2R1cmF0aW9uID09PSAwKSBpZiAoKHRpbWUgPD0gMCAmJiB0aW1lID49IC0wLjAwMDAwMDEpIHx8IHByZXZSYXdQcmV2VGltZSA8IDAgfHwgcHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSkgaWYgKHByZXZSYXdQcmV2VGltZSAhPT0gdGltZSAmJiB0aGlzLl9maXJzdCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGltZSA9IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cjtcblx0XHRcdFx0XHR0aW1lID0gZHVyICsgMC4wMDAxOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIC0gc29tZXRpbWVzIGNoaWxkIHR3ZWVucy90aW1lbGluZXMgd2VyZSBub3QgYmVpbmcgZnVsbHkgY29tcGxldGVkICh0aGVpciBwcm9ncmVzcyBtaWdodCBiZSAwLjk5OTk5OTk5OTk5OTk5OCBpbnN0ZWFkIG9mIDEgYmVjYXVzZSB3aGVuIF90aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSBpcyBwZXJmb3JtZWQsIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3b3VsZCByZXR1cm4gYSB2YWx1ZSB0aGF0IHdhcyBTTElHSFRMWSBvZmYpLiBUcnkgKDk5OTk5OTk5OTk5OS43IC0gOTk5OTk5OTk5OTk5KSAqIDEgPSAwLjY5OTk1MTE3MTg3NSBpbnN0ZWFkIG9mIDAuNy4gV2UgY2Fubm90IGRvIGxlc3MgdGhlbiAwLjAwMDEgYmVjYXVzZSB0aGUgc2FtZSBpc3N1ZSBjYW4gb2NjdXIgd2hlbiB0aGUgZHVyYXRpb24gaXMgZXh0cmVtZWx5IGxhcmdlIGxpa2UgOTk5OTk5OTk5OTk5IGluIHdoaWNoIGNhc2UgYWRkaW5nIDAuMDAwMDAwMDEsIGZvciBleGFtcGxlLCBjYXVzZXMgaXQgdG8gYWN0IGxpa2Ugbm90aGluZyB3YXMgYWRkZWQuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKGR1ciA9PT0gMCAmJiBwcmV2UmF3UHJldlRpbWUgIT09IF90aW55TnVtICYmIChwcmV2UmF3UHJldlRpbWUgPiAwIHx8ICh0aW1lIDwgMCAmJiBwcmV2UmF3UHJldlRpbWUgPj0gMCkpICYmICF0aGlzLl9sb2NrZWQpKSB7IC8vZWRnZSBjYXNlIGZvciBjaGVja2luZyB0aW1lIDwgMCAmJiBwcmV2UmF3UHJldlRpbWUgPj0gMDogYSB6ZXJvLWR1cmF0aW9uIGZyb21UbygpIHR3ZWVuIGluc2lkZSBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgKHllYWgsIHZlcnkgcmFyZSlcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiAmJiB0aGlzLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwcmV2UmF3UHJldlRpbWUgPj0gMCAmJiB0aGlzLl9maXJzdCkgeyAvL3doZW4gZ29pbmcgYmFjayBiZXlvbmQgdGhlIHN0YXJ0LCBmb3JjZSBhIHJlbmRlciBzbyB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIHRoYXQgc2l0IGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyByZW5kZXIgdGhlaXIgc3RhcnQgdmFsdWVzIHByb3Blcmx5LiBPdGhlcndpc2UsIGlmIHRoZSBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBsYW5kcyBleGFjdGx5IGF0IHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUsIGFuZCB0aGVuIG1vdmVzIGJhY2t3YXJkcywgdGhlIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSBiZWdpbm5pbmcgd291bGQgc3RpbGwgYmUgYXQgdGhlaXIgZW5kIHN0YXRlLlxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IChkdXIgfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdGlmICh0aW1lID09PSAwICYmIGlzQ29tcGxldGUpIHsgLy9pZiB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgYSB0aW1lbGluZSBhbmQgdGhlIHBsYXloZWFkIGxhbmRzIEVYQUNUTFkgYXQgdGltZSAwLCB0aGF0IHR3ZWVuIHdpbGwgY29ycmVjdGx5IHJlbmRlciBpdHMgZW5kIHZhbHVlcywgYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgdGltZWxpbmUgYWxpdmUgZm9yIG9uZSBtb3JlIHJlbmRlciBzbyB0aGF0IHRoZSBiZWdpbm5pbmcgdmFsdWVzIHJlbmRlciBwcm9wZXJseSBhcyB0aGUgcGFyZW50J3MgcGxheWhlYWQga2VlcHMgbW92aW5nIGJleW9uZCB0aGUgYmVnaW5pbmcuIEltYWdpbmUgb2JqLnggc3RhcnRzIGF0IDAgYW5kIHRoZW4gd2UgZG8gdGwuc2V0KG9iaiwge3g6MTAwfSkudG8ob2JqLCAxLCB7eDoyMDB9KSBhbmQgdGhlbiBsYXRlciB3ZSB0bC5yZXZlcnNlKCkuLi50aGUgZ29hbCBpcyB0byBoYXZlIG9iai54IHJldmVydCB0byAwLiBJZiB0aGUgcGxheWhlYWQgaGFwcGVucyB0byBsYW5kIG9uIGV4YWN0bHkgMCwgd2l0aG91dCB0aGlzIGNodW5rIG9mIGNvZGUsIGl0J2QgY29tcGxldGUgdGhlIHRpbWVsaW5lIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcmVuZGVyaW5nIHF1ZXVlIChub3QgZ29vZCkuXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRpc0NvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZSA9IDA7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgKGNvdWxkIGNhdXNlIHByb2JsZW1zIGVzcGVjaWFsbHkgd2l0aCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lKVxuXHRcdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChkdXIgPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lIDwgMCkgeyAvL3dpdGhvdXQgdGhpcywgemVyby1kdXJhdGlvbiByZXBlYXRpbmcgdGltZWxpbmVzIChsaWtlIHdpdGggYSBzaW1wbGUgY2FsbGJhY2sgbmVzdGVkIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBhbmQgYSByZXBlYXREZWxheSkgd291bGRuJ3QgcmVuZGVyIHRoZSBmaXJzdCB0aW1lIHRocm91Z2guXG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdFx0aWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aW1lO1xuXHRcdFx0XHRcdGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0XHRcdGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gKHRoaXMuX3RvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24pID4+IDA7IC8vb3JpZ2luYWxseSBfdG90YWxUaW1lICUgY3ljbGVEdXJhdGlvbiBidXQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIGNhdXNlZCBwcm9ibGVtcywgc28gSSBub3JtYWxpemVkIGl0LiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgaXQgZ2V0cyByZXBvcnRlZCBhcyAwLjc5OTk5OTk5ISlcblx0XHRcdFx0XHRcdGlmICh0aGlzLl9jeWNsZSAhPT0gMCkgaWYgKHRoaXMuX2N5Y2xlID09PSB0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uICYmIHByZXZUb3RhbFRpbWUgPD0gdGltZSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9jeWNsZS0tOyAvL290aGVyd2lzZSB3aGVuIHJlbmRlcmVkIGV4YWN0bHkgYXQgdGhlIGVuZCB0aW1lLCBpdCB3aWxsIGFjdCBhcyB0aG91Z2ggaXQgaXMgcmVwZWF0aW5nIChhdCB0aGUgYmVnaW5uaW5nKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSAtICh0aGlzLl9jeWNsZSAqIGN5Y2xlRHVyYXRpb24pO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3lveW8pIGlmICgodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyIC0gdGhpcy5fdGltZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gZHVyKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXI7XG5cdFx0XHRcdFx0XHRcdHRpbWUgPSBkdXIgKyAwLjAwMDE7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lIDwgMCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGltZSA9IDA7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5faGFzUGF1c2UgJiYgIXRoaXMuX2ZvcmNpbmdQbGF5aGVhZCAmJiAhc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdFx0XHRpZiAodGltZSA+PSBwcmV2VGltZSkge1xuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lIDw9IHRpbWUgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIGlmICh0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIiAmJiAhdHdlZW4ucmF0aW8gJiYgISh0d2Vlbi5fc3RhcnRUaW1lID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID09PSAwKSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA+PSB0aW1lICYmICFwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSBpZiAodHdlZW4uZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgdHdlZW4uX3Jhd1ByZXZUaW1lID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGF1c2VUd2Vlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRpbWUgPSBwYXVzZVR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aW1lICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX3RvdGFsRHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9jeWNsZSAhPT0gcHJldkN5Y2xlKSBpZiAoIXRoaXMuX2xvY2tlZCkge1xuXHRcdFx0XHQvKlxuXHRcdFx0XHRtYWtlIHN1cmUgY2hpbGRyZW4gYXQgdGhlIGVuZC9iZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lIGFyZSByZW5kZXJlZCBwcm9wZXJseS4gSWYsIGZvciBleGFtcGxlLFxuXHRcdFx0XHRhIDMtc2Vjb25kIGxvbmcgdGltZWxpbmUgcmVuZGVyZWQgYXQgMi45IHNlY29uZHMgcHJldmlvdXNseSwgYW5kIG5vdyByZW5kZXJzIGF0IDMuMiBzZWNvbmRzICh3aGljaFxuXHRcdFx0XHR3b3VsZCBnZXQgdHJhbnNhdGVkIHRvIDIuOCBzZWNvbmRzIGlmIHRoZSB0aW1lbGluZSB5b3lvcyBvciAwLjIgc2Vjb25kcyBpZiBpdCBqdXN0IHJlcGVhdHMpLCB0aGVyZVxuXHRcdFx0XHRjb3VsZCBiZSBhIGNhbGxiYWNrIG9yIGEgc2hvcnQgdHdlZW4gdGhhdCdzIGF0IDIuOTUgb3IgMyBzZWNvbmRzIGluIHdoaWNoIHdvdWxkbid0IHJlbmRlci4gU29cblx0XHRcdFx0d2UgbmVlZCB0byBwdXNoIHRoZSB0aW1lbGluZSB0byB0aGUgZW5kIChhbmQvb3IgYmVnaW5uaW5nIGRlcGVuZGluZyBvbiBpdHMgeW95byB2YWx1ZSkuIEFsc28gd2UgbXVzdFxuXHRcdFx0XHRlbnN1cmUgdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb3IgZW5kIG9mIHRoZSBUaW1lbGluZU1heCB3b3JrLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHR2YXIgYmFja3dhcmRzID0gKHRoaXMuX3lveW8gJiYgKHByZXZDeWNsZSAmIDEpICE9PSAwKSxcblx0XHRcdFx0XHR3cmFwID0gKGJhY2t3YXJkcyA9PT0gKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApKSxcblx0XHRcdFx0XHRyZWNUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsXG5cdFx0XHRcdFx0cmVjQ3ljbGUgPSB0aGlzLl9jeWNsZSxcblx0XHRcdFx0XHRyZWNSYXdQcmV2VGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lLFxuXHRcdFx0XHRcdHJlY1RpbWUgPSB0aGlzLl90aW1lO1xuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHByZXZDeWNsZSAqIGR1cjtcblx0XHRcdFx0aWYgKHRoaXMuX2N5Y2xlIDwgcHJldkN5Y2xlKSB7XG5cdFx0XHRcdFx0YmFja3dhcmRzID0gIWJhY2t3YXJkcztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgKz0gZHVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSBwcmV2VGltZTsgLy90ZW1wb3JhcmlseSByZXZlcnQgX3RpbWUgc28gdGhhdCByZW5kZXIoKSByZW5kZXJzIHRoZSBjaGlsZHJlbiBpbiB0aGUgY29ycmVjdCBvcmRlci4gV2l0aG91dCB0aGlzLCB0d2VlbnMgd29uJ3QgcmV3aW5kIGNvcnJlY3RseS4gV2UgY291bGQgYXJoaWN0ZWN0IHRoaW5ncyBpbiBhIFwiY2xlYW5lclwiIHdheSBieSBzcGxpdHRpbmcgb3V0IHRoZSByZW5kZXJpbmcgcXVldWUgaW50byBhIHNlcGFyYXRlIG1ldGhvZCBidXQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGtlcHQgaXQgYWxsIGluc2lkZSB0aGlzIG1ldGhvZC5cblxuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IChkdXIgPT09IDApID8gcHJldlJhd1ByZXZUaW1lIC0gMC4wMDAxIDogcHJldlJhd1ByZXZUaW1lO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IHByZXZDeWNsZTtcblx0XHRcdFx0dGhpcy5fbG9ja2VkID0gdHJ1ZTsgLy9wcmV2ZW50cyBjaGFuZ2VzIHRvIHRvdGFsVGltZSBhbmQgc2tpcHMgcmVwZWF0L3lveW8gYmVoYXZpb3Igd2hlbiB3ZSByZWN1cnNpdmVseSBjYWxsIHJlbmRlcigpXG5cdFx0XHRcdHByZXZUaW1lID0gKGJhY2t3YXJkcykgPyAwIDogZHVyO1xuXHRcdFx0XHR0aGlzLnJlbmRlcihwcmV2VGltZSwgc3VwcHJlc3NFdmVudHMsIChkdXIgPT09IDApKTtcblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKCF0aGlzLl9nYykge1xuXHRcdFx0XHRcdGlmICh0aGlzLnZhcnMub25SZXBlYXQpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25SZXBlYXRcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcmV2VGltZSAhPT0gdGhpcy5fdGltZSkgeyAvL2luIGNhc2UgdGhlcmUncyBhIGNhbGxiYWNrIGxpa2Ugb25Db21wbGV0ZSBpbiBhIG5lc3RlZCB0d2Vlbi90aW1lbGluZSB0aGF0IGNoYW5nZXMgdGhlIHBsYXloZWFkIHBvc2l0aW9uLCBsaWtlIHZpYSBzZWVrKCksIHdlIHNob3VsZCBqdXN0IGFib3J0LlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAod3JhcCkge1xuXHRcdFx0XHRcdHByZXZUaW1lID0gKGJhY2t3YXJkcykgPyBkdXIgKyAwLjAwMDEgOiAtMC4wMDAxO1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyKHByZXZUaW1lLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fbG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdGlmICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpIHsgLy9pZiB0aGUgcmVuZGVyKCkgdHJpZ2dlcmVkIGNhbGxiYWNrIHRoYXQgcGF1c2VkIHRoaXMgdGltZWxpbmUsIHdlIHNob3VsZCBhYm9ydCAodmVyeSByYXJlLCBidXQgcG9zc2libGUpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSByZWNUaW1lO1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSByZWNUb3RhbFRpbWU7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gcmVjQ3ljbGU7XG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmVjUmF3UHJldlRpbWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgodGhpcy5fdGltZSA9PT0gcHJldlRpbWUgfHwgIXRoaXMuX2ZpcnN0KSAmJiAhZm9yY2UgJiYgIWludGVybmFsRm9yY2UgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgIT09IHRoaXMuX3RvdGFsVGltZSkgaWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7IC8vc28gdGhhdCBvblVwZGF0ZSBmaXJlcyBldmVuIGR1cmluZyB0aGUgcmVwZWF0RGVsYXkgLSBhcyBsb25nIGFzIHRoZSB0b3RhbFRpbWUgY2hhbmdlZCwgd2Ugc2hvdWxkIHRyaWdnZXIgb25VcGRhdGUuXG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdG90YWxUaW1lICE9PSBwcmV2VG90YWxUaW1lICYmIHRpbWUgPiAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7ICAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyB0aGUgdGltZWxpbmUgKGFzIG9wcG9zZWQgdG8gdGhlIHBhcmVudCB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCBpdCBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0aW1lbGluZSBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZSwgZm9yIGV4YW1wbGUuXG5cdFx0XHR9XG5cblx0XHRcdGlmIChwcmV2VG90YWxUaW1lID09PSAwKSBpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90b3RhbFRpbWUgIT09IDApIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdXJUaW1lID0gdGhpcy5fdGltZTtcblx0XHRcdGlmIChjdXJUaW1lID49IHByZXZUaW1lKSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKGN1clRpbWUgIT09IHRoaXMuX3RpbWUgfHwgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IHRoaXMuX3RpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmIChjdXJUaW1lICE9PSB0aGlzLl90aW1lIHx8ICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSBwcmV2VGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4gPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbi5fcHJldjsgLy90aGUgbGlua2VkIGxpc3QgaXMgb3JnYW5pemVkIGJ5IF9zdGFydFRpbWUsIHRodXMgaXQncyBwb3NzaWJsZSB0aGF0IGEgdHdlZW4gY291bGQgc3RhcnQgQkVGT1JFIHRoZSBwYXVzZSBhbmQgZW5kIGFmdGVyIGl0LCBpbiB3aGljaCBjYXNlIGl0IHdvdWxkIGJlIHBvc2l0aW9uZWQgYmVmb3JlIHRoZSBwYXVzZSB0d2VlbiBpbiB0aGUgbGlua2VkIGxpc3QsIGJ1dCB3ZSBzaG91bGQgcmVuZGVyIGl0IGJlZm9yZSB3ZSBwYXVzZSgpIHRoZSB0aW1lbGluZSBhbmQgY2Vhc2UgcmVuZGVyaW5nLiBUaGlzIGlzIG9ubHkgYSBjb25jZXJuIHdoZW4gZ29pbmcgaW4gcmV2ZXJzZS5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKHBhdXNlVHdlZW4gJiYgcGF1c2VUd2Vlbi5lbmRUaW1lKCkgPiB0aGlzLl90aW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2Vlbi5yZW5kZXIoIChwYXVzZVR3ZWVuLl9yZXZlcnNlZCA/IHBhdXNlVHdlZW4udG90YWxEdXJhdGlvbigpIC0gKCh0aW1lIC0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lKSAqIHBhdXNlVHdlZW4uX3RpbWVTY2FsZSkgOiAodGltZSAtIHBhdXNlVHdlZW4uX3N0YXJ0VGltZSkgKiBwYXVzZVR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSBwYXVzZVR3ZWVuLl9wcmV2O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uVXBkYXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fbG9ja2VkKSBpZiAoIXRoaXMuX2djKSBpZiAocHJldlN0YXJ0ID09PSB0aGlzLl9zdGFydFRpbWUgfHwgcHJldlRpbWVTY2FsZSAhPT0gdGhpcy5fdGltZVNjYWxlKSBpZiAodGhpcy5fdGltZSA9PT0gMCB8fCB0b3RhbER1ciA+PSB0aGlzLnRvdGFsRHVyYXRpb24oKSkgeyAvL2lmIG9uZSBvZiB0aGUgdHdlZW5zIHRoYXQgd2FzIHJlbmRlcmVkIGFsdGVyZWQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSAobGlrZSBpZiBhbiBvbkNvbXBsZXRlIHJldmVyc2VkIHRoZSB0aW1lbGluZSksIGl0IHByb2JhYmx5IGlzbid0IGNvbXBsZXRlLiBJZiBpdCBpcywgZG9uJ3Qgd29ycnksIGJlY2F1c2Ugd2hhdGV2ZXIgY2FsbCBhbHRlcmVkIHRoZSBzdGFydFRpbWUgd291bGQgY29tcGxldGUgaWYgaXQgd2FzIG5lY2Vzc2FyeSBhdCB0aGUgbmV3IHRpbWUuIFRoZSBvbmx5IGV4Y2VwdGlvbiBpcyB0aGUgdGltZVNjYWxlIHByb3BlcnR5LiBBbHNvIGNoZWNrIF9nYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmIChpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uQ29tcGxldGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXHRcdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzICYmIHRoaXMudmFyc1tjYWxsYmFja10pIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5nZXRBY3RpdmUgPSBmdW5jdGlvbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzKSB7XG5cdFx0XHRpZiAobmVzdGVkID09IG51bGwpIHtcblx0XHRcdFx0bmVzdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICh0d2VlbnMgPT0gbnVsbCkge1xuXHRcdFx0XHR0d2VlbnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRpbWVsaW5lcyA9PSBudWxsKSB7XG5cdFx0XHRcdHRpbWVsaW5lcyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0YWxsID0gdGhpcy5nZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzKSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0bCA9IGFsbC5sZW5ndGgsXG5cdFx0XHRcdGksIHR3ZWVuO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0d2VlbiA9IGFsbFtpXTtcblx0XHRcdFx0aWYgKHR3ZWVuLmlzQWN0aXZlKCkpIHtcblx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cblx0XHRwLmdldExhYmVsQWZ0ZXIgPSBmdW5jdGlvbih0aW1lKSB7XG5cdFx0XHRpZiAoIXRpbWUpIGlmICh0aW1lICE9PSAwKSB7IC8vZmFzdGVyIHRoYW4gaXNOYW4oKVxuXHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVsc0FycmF5KCksXG5cdFx0XHRcdGwgPSBsYWJlbHMubGVuZ3RoLFxuXHRcdFx0XHRpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldLnRpbWUgPiB0aW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhYmVsc1tpXS5uYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXG5cdFx0cC5nZXRMYWJlbEJlZm9yZSA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRcdGlmICh0aW1lID09IG51bGwpIHtcblx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHNBcnJheSgpLFxuXHRcdFx0XHRpID0gbGFiZWxzLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldLnRpbWUgPCB0aW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhYmVsc1tpXS5uYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXG5cdFx0cC5nZXRMYWJlbHNBcnJheSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0cDtcblx0XHRcdGZvciAocCBpbiB0aGlzLl9sYWJlbHMpIHtcblx0XHRcdFx0YVtjbnQrK10gPSB7dGltZTp0aGlzLl9sYWJlbHNbcF0sIG5hbWU6cH07XG5cdFx0XHR9XG5cdFx0XHRhLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG5cdFx0XHRcdHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblxuLy8tLS0tIEdFVFRFUlMgLyBTRVRURVJTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAucHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdGltZSAvIHRoaXMuZHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLmR1cmF0aW9uKCkgKiAoKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApID8gMSAtIHZhbHVlIDogdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdG90YWxUaW1lIC8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLnRvdGFsVGltZSggdGhpcy50b3RhbER1cmF0aW9uKCkgKiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdFRpbWVsaW5lTGl0ZS5wcm90b3R5cGUudG90YWxEdXJhdGlvbi5jYWxsKHRoaXMpOyAvL2p1c3QgZm9yY2VzIHJlZnJlc2hcblx0XHRcdFx0XHQvL0luc3RlYWQgb2YgSW5maW5pdHksIHdlIHVzZSA5OTk5OTk5OTk5OTkgc28gdGhhdCB3ZSBjYW4gYWNjb21tb2RhdGUgcmV2ZXJzZXMuXG5cdFx0XHRcdFx0dGhpcy5fdG90YWxEdXJhdGlvbiA9ICh0aGlzLl9yZXBlYXQgPT09IC0xKSA/IDk5OTk5OTk5OTk5OSA6IHRoaXMuX2R1cmF0aW9uICogKHRoaXMuX3JlcGVhdCArIDEpICsgKHRoaXMuX3JlcGVhdERlbGF5ICogdGhpcy5fcmVwZWF0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodGhpcy5fcmVwZWF0ID09PSAtMSB8fCAhdmFsdWUpID8gdGhpcyA6IHRoaXMudGltZVNjYWxlKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAvIHZhbHVlICk7XG5cdFx0fTtcblxuXHRcdHAudGltZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlID4gdGhpcy5fZHVyYXRpb24pIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlID0gKHRoaXMuX2R1cmF0aW9uIC0gdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlICs9IHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAucmVwZWF0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXBlYXREZWxheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcGVhdERlbGF5O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnlveW8gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl95b3lvO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5feW95byA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuY3VycmVudExhYmVsID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbEJlZm9yZSh0aGlzLl90aW1lICsgMC4wMDAwMDAwMSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5zZWVrKHZhbHVlLCB0cnVlKTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFRpbWVsaW5lTWF4O1xuXG5cdH0sIHRydWUpO1xuXHRcblxuXG5cblxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCZXppZXJQbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHQoZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuXHRcdFx0X3IxID0gW10sXG5cdFx0XHRfcjIgPSBbXSxcblx0XHRcdF9yMyA9IFtdLFxuXHRcdFx0X2NvclByb3BzID0ge30sXG5cdFx0XHRfZ2xvYmFscyA9IF9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLFxuXHRcdFx0U2VnbWVudCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcblx0XHRcdFx0dGhpcy5hID0gYTtcblx0XHRcdFx0dGhpcy5iID0gYjtcblx0XHRcdFx0dGhpcy5jID0gYztcblx0XHRcdFx0dGhpcy5kID0gZDtcblx0XHRcdFx0dGhpcy5kYSA9IGQgLSBhO1xuXHRcdFx0XHR0aGlzLmNhID0gYyAtIGE7XG5cdFx0XHRcdHRoaXMuYmEgPSBiIC0gYTtcblx0XHRcdH0sXG5cdFx0XHRfY29ycmVsYXRlID0gXCIseCx5LHosbGVmdCx0b3AscmlnaHQsYm90dG9tLG1hcmdpblRvcCxtYXJnaW5MZWZ0LG1hcmdpblJpZ2h0LG1hcmdpbkJvdHRvbSxwYWRkaW5nTGVmdCxwYWRkaW5nVG9wLHBhZGRpbmdSaWdodCxwYWRkaW5nQm90dG9tLGJhY2tncm91bmRQb3NpdGlvbixiYWNrZ3JvdW5kUG9zaXRpb25feSxcIixcblx0XHRcdGN1YmljVG9RdWFkcmF0aWMgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG5cdFx0XHRcdHZhciBxMSA9IHthOmF9LFxuXHRcdFx0XHRcdHEyID0ge30sXG5cdFx0XHRcdFx0cTMgPSB7fSxcblx0XHRcdFx0XHRxNCA9IHtjOmR9LFxuXHRcdFx0XHRcdG1hYiA9IChhICsgYikgLyAyLFxuXHRcdFx0XHRcdG1iYyA9IChiICsgYykgLyAyLFxuXHRcdFx0XHRcdG1jZCA9IChjICsgZCkgLyAyLFxuXHRcdFx0XHRcdG1hYmMgPSAobWFiICsgbWJjKSAvIDIsXG5cdFx0XHRcdFx0bWJjZCA9IChtYmMgKyBtY2QpIC8gMixcblx0XHRcdFx0XHRtOCA9IChtYmNkIC0gbWFiYykgLyA4O1xuXHRcdFx0XHRxMS5iID0gbWFiICsgKGEgLSBtYWIpIC8gNDtcblx0XHRcdFx0cTIuYiA9IG1hYmMgKyBtODtcblx0XHRcdFx0cTEuYyA9IHEyLmEgPSAocTEuYiArIHEyLmIpIC8gMjtcblx0XHRcdFx0cTIuYyA9IHEzLmEgPSAobWFiYyArIG1iY2QpIC8gMjtcblx0XHRcdFx0cTMuYiA9IG1iY2QgLSBtODtcblx0XHRcdFx0cTQuYiA9IG1jZCArIChkIC0gbWNkKSAvIDQ7XG5cdFx0XHRcdHEzLmMgPSBxNC5hID0gKHEzLmIgKyBxNC5iKSAvIDI7XG5cdFx0XHRcdHJldHVybiBbcTEsIHEyLCBxMywgcTRdO1xuXHRcdFx0fSxcblx0XHRcdF9jYWxjdWxhdGVDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oYSwgY3VydmluZXNzLCBxdWFkLCBiYXNpYywgY29ycmVsYXRlKSB7XG5cdFx0XHRcdHZhciBsID0gYS5sZW5ndGggLSAxLFxuXHRcdFx0XHRcdGlpID0gMCxcblx0XHRcdFx0XHRjcDEgPSBhWzBdLmEsXG5cdFx0XHRcdFx0aSwgcDEsIHAyLCBwMywgc2VnLCBtMSwgbTIsIG1tLCBjcDIsIHFiLCByMSwgcjIsIHRsO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0c2VnID0gYVtpaV07XG5cdFx0XHRcdFx0cDEgPSBzZWcuYTtcblx0XHRcdFx0XHRwMiA9IHNlZy5kO1xuXHRcdFx0XHRcdHAzID0gYVtpaSsxXS5kO1xuXG5cdFx0XHRcdFx0aWYgKGNvcnJlbGF0ZSkge1xuXHRcdFx0XHRcdFx0cjEgPSBfcjFbaV07XG5cdFx0XHRcdFx0XHRyMiA9IF9yMltpXTtcblx0XHRcdFx0XHRcdHRsID0gKChyMiArIHIxKSAqIGN1cnZpbmVzcyAqIDAuMjUpIC8gKGJhc2ljID8gMC41IDogX3IzW2ldIHx8IDAuNSk7XG5cdFx0XHRcdFx0XHRtMSA9IHAyIC0gKHAyIC0gcDEpICogKGJhc2ljID8gY3VydmluZXNzICogMC41IDogKHIxICE9PSAwID8gdGwgLyByMSA6IDApKTtcblx0XHRcdFx0XHRcdG0yID0gcDIgKyAocDMgLSBwMikgKiAoYmFzaWMgPyBjdXJ2aW5lc3MgKiAwLjUgOiAocjIgIT09IDAgPyB0bCAvIHIyIDogMCkpO1xuXHRcdFx0XHRcdFx0bW0gPSBwMiAtIChtMSArICgoKG0yIC0gbTEpICogKChyMSAqIDMgLyAocjEgKyByMikpICsgMC41KSAvIDQpIHx8IDApKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bTEgPSBwMiAtIChwMiAtIHAxKSAqIGN1cnZpbmVzcyAqIDAuNTtcblx0XHRcdFx0XHRcdG0yID0gcDIgKyAocDMgLSBwMikgKiBjdXJ2aW5lc3MgKiAwLjU7XG5cdFx0XHRcdFx0XHRtbSA9IHAyIC0gKG0xICsgbTIpIC8gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bTEgKz0gbW07XG5cdFx0XHRcdFx0bTIgKz0gbW07XG5cblx0XHRcdFx0XHRzZWcuYyA9IGNwMiA9IG0xO1xuXHRcdFx0XHRcdGlmIChpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRzZWcuYiA9IGNwMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VnLmIgPSBjcDEgPSBzZWcuYSArIChzZWcuYyAtIHNlZy5hKSAqIDAuNjsgLy9pbnN0ZWFkIG9mIHBsYWNpbmcgYiBvbiBhIGV4YWN0bHksIHdlIG1vdmUgaXQgaW5saW5lIHdpdGggYyBzbyB0aGF0IGlmIHRoZSB1c2VyIHNwZWNpZmllcyBhbiBlYXNlIGxpa2UgQmFjay5lYXNlSW4gb3IgRWxhc3RpYy5lYXNlSW4gd2hpY2ggZ29lcyBCRVlPTkQgdGhlIGJlZ2lubmluZywgaXQgd2lsbCBkbyBzbyBzbW9vdGhseS5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzZWcuZGEgPSBwMiAtIHAxO1xuXHRcdFx0XHRcdHNlZy5jYSA9IGNwMiAtIHAxO1xuXHRcdFx0XHRcdHNlZy5iYSA9IGNwMSAtIHAxO1xuXG5cdFx0XHRcdFx0aWYgKHF1YWQpIHtcblx0XHRcdFx0XHRcdHFiID0gY3ViaWNUb1F1YWRyYXRpYyhwMSwgY3AxLCBjcDIsIHAyKTtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGlpLCAxLCBxYlswXSwgcWJbMV0sIHFiWzJdLCBxYlszXSk7XG5cdFx0XHRcdFx0XHRpaSArPSA0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpaSsrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNwMSA9IG0yO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlZyA9IGFbaWldO1xuXHRcdFx0XHRzZWcuYiA9IGNwMTtcblx0XHRcdFx0c2VnLmMgPSBjcDEgKyAoc2VnLmQgLSBjcDEpICogMC40OyAvL2luc3RlYWQgb2YgcGxhY2luZyBjIG9uIGQgZXhhY3RseSwgd2UgbW92ZSBpdCBpbmxpbmUgd2l0aCBiIHNvIHRoYXQgaWYgdGhlIHVzZXIgc3BlY2lmaWVzIGFuIGVhc2UgbGlrZSBCYWNrLmVhc2VPdXQgb3IgRWxhc3RpYy5lYXNlT3V0IHdoaWNoIGdvZXMgQkVZT05EIHRoZSBlbmQsIGl0IHdpbGwgZG8gc28gc21vb3RobHkuXG5cdFx0XHRcdHNlZy5kYSA9IHNlZy5kIC0gc2VnLmE7XG5cdFx0XHRcdHNlZy5jYSA9IHNlZy5jIC0gc2VnLmE7XG5cdFx0XHRcdHNlZy5iYSA9IGNwMSAtIHNlZy5hO1xuXHRcdFx0XHRpZiAocXVhZCkge1xuXHRcdFx0XHRcdHFiID0gY3ViaWNUb1F1YWRyYXRpYyhzZWcuYSwgY3AxLCBzZWcuYywgc2VnLmQpO1xuXHRcdFx0XHRcdGEuc3BsaWNlKGlpLCAxLCBxYlswXSwgcWJbMV0sIHFiWzJdLCBxYlszXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VBbmNob3JzID0gZnVuY3Rpb24odmFsdWVzLCBwLCBjb3JyZWxhdGUsIHByZXBlbmQpIHtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRsLCBpLCBwMSwgcDIsIHAzLCB0bXA7XG5cdFx0XHRcdGlmIChwcmVwZW5kKSB7XG5cdFx0XHRcdFx0dmFsdWVzID0gW3ByZXBlbmRdLmNvbmNhdCh2YWx1ZXMpO1xuXHRcdFx0XHRcdGkgPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiggKHRtcCA9IHZhbHVlc1tpXVtwXSkgKSA9PT0gXCJzdHJpbmdcIikgaWYgKHRtcC5jaGFyQXQoMSkgPT09IFwiPVwiKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1tpXVtwXSA9IHByZXBlbmRbcF0gKyBOdW1iZXIodG1wLmNoYXJBdCgwKSArIHRtcC5zdWJzdHIoMikpOyAvL2FjY29tbW9kYXRlIHJlbGF0aXZlIHZhbHVlcy4gRG8gaXQgaW5saW5lIGluc3RlYWQgb2YgYnJlYWtpbmcgaXQgb3V0IGludG8gYSBmdW5jdGlvbiBmb3Igc3BlZWQgcmVhc29uc1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsID0gdmFsdWVzLmxlbmd0aCAtIDI7XG5cdFx0XHRcdGlmIChsIDwgMCkge1xuXHRcdFx0XHRcdGFbMF0gPSBuZXcgU2VnbWVudCh2YWx1ZXNbMF1bcF0sIDAsIDAsIHZhbHVlc1sobCA8IC0xKSA/IDAgOiAxXVtwXSk7XG5cdFx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHAxID0gdmFsdWVzW2ldW3BdO1xuXHRcdFx0XHRcdHAyID0gdmFsdWVzW2krMV1bcF07XG5cdFx0XHRcdFx0YVtpXSA9IG5ldyBTZWdtZW50KHAxLCAwLCAwLCBwMik7XG5cdFx0XHRcdFx0aWYgKGNvcnJlbGF0ZSkge1xuXHRcdFx0XHRcdFx0cDMgPSB2YWx1ZXNbaSsyXVtwXTtcblx0XHRcdFx0XHRcdF9yMVtpXSA9IChfcjFbaV0gfHwgMCkgKyAocDIgLSBwMSkgKiAocDIgLSBwMSk7XG5cdFx0XHRcdFx0XHRfcjJbaV0gPSAoX3IyW2ldIHx8IDApICsgKHAzIC0gcDIpICogKHAzIC0gcDIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhW2ldID0gbmV3IFNlZ21lbnQodmFsdWVzW2ldW3BdLCAwLCAwLCB2YWx1ZXNbaSsxXVtwXSk7XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fSxcblx0XHRcdGJlemllclRocm91Z2ggPSBmdW5jdGlvbih2YWx1ZXMsIGN1cnZpbmVzcywgcXVhZHJhdGljLCBiYXNpYywgY29ycmVsYXRlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHZhciBvYmogPSB7fSxcblx0XHRcdFx0XHRwcm9wcyA9IFtdLFxuXHRcdFx0XHRcdGZpcnN0ID0gcHJlcGVuZCB8fCB2YWx1ZXNbMF0sXG5cdFx0XHRcdFx0aSwgcCwgYSwgaiwgciwgbCwgc2VhbWxlc3MsIGxhc3Q7XG5cdFx0XHRcdGNvcnJlbGF0ZSA9ICh0eXBlb2YoY29ycmVsYXRlKSA9PT0gXCJzdHJpbmdcIikgPyBcIixcIitjb3JyZWxhdGUrXCIsXCIgOiBfY29ycmVsYXRlO1xuXHRcdFx0XHRpZiAoY3VydmluZXNzID09IG51bGwpIHtcblx0XHRcdFx0XHRjdXJ2aW5lc3MgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocCBpbiB2YWx1ZXNbMF0pIHtcblx0XHRcdFx0XHRwcm9wcy5wdXNoKHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vY2hlY2sgdG8gc2VlIGlmIHRoZSBsYXN0IGFuZCBmaXJzdCB2YWx1ZXMgYXJlIGlkZW50aWNhbCAod2VsbCwgd2l0aGluIDAuMDUpLiBJZiBzbywgbWFrZSBzZWFtbGVzcyBieSBhcHBlbmRpbmcgdGhlIHNlY29uZCBlbGVtZW50IHRvIHRoZSB2ZXJ5IGVuZCBvZiB0aGUgdmFsdWVzIGFycmF5IGFuZCB0aGUgMm5kLXRvLWxhc3QgZWxlbWVudCB0byB0aGUgdmVyeSBiZWdpbm5pbmcgKHdlJ2xsIHJlbW92ZSB0aG9zZSBzZWdtZW50cyBsYXRlcilcblx0XHRcdFx0aWYgKHZhbHVlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0bGFzdCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0c2VhbWxlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoZmlyc3RbcF0gLSBsYXN0W3BdKSA+IDAuMDUpIHsgLy9idWlsZCBpbiBhIHRvbGVyYW5jZSBvZiArLy0wLjA1IHRvIGFjY29tbW9kYXRlIHJvdW5kaW5nIGVycm9ycy5cblx0XHRcdFx0XHRcdFx0c2VhbWxlc3MgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZWFtbGVzcykge1xuXHRcdFx0XHRcdFx0dmFsdWVzID0gdmFsdWVzLmNvbmNhdCgpOyAvL2R1cGxpY2F0ZSB0aGUgYXJyYXkgdG8gYXZvaWQgY29udGFtaW5hdGluZyB0aGUgb3JpZ2luYWwgd2hpY2ggdGhlIHVzZXIgbWF5IGJlIHJldXNpbmcgZm9yIG90aGVyIHR3ZWVuc1xuXHRcdFx0XHRcdFx0aWYgKHByZXBlbmQpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzLnVuc2hpZnQocHJlcGVuZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCh2YWx1ZXNbMV0pO1xuXHRcdFx0XHRcdFx0cHJlcGVuZCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gM107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdF9yMS5sZW5ndGggPSBfcjIubGVuZ3RoID0gX3IzLmxlbmd0aCA9IDA7XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRfY29yUHJvcHNbcF0gPSAoY29ycmVsYXRlLmluZGV4T2YoXCIsXCIrcCtcIixcIikgIT09IC0xKTtcblx0XHRcdFx0XHRvYmpbcF0gPSBfcGFyc2VBbmNob3JzKHZhbHVlcywgcCwgX2NvclByb3BzW3BdLCBwcmVwZW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gX3IxLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0X3IxW2ldID0gTWF0aC5zcXJ0KF9yMVtpXSk7XG5cdFx0XHRcdFx0X3IyW2ldID0gTWF0aC5zcXJ0KF9yMltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFiYXNpYykge1xuXHRcdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoX2NvclByb3BzW3BdKSB7XG5cdFx0XHRcdFx0XHRcdGEgPSBvYmpbcHJvcHNbaV1dO1xuXHRcdFx0XHRcdFx0XHRsID0gYS5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0ciA9IChhW2orMV0uZGEgLyBfcjJbal0gKyBhW2pdLmRhIC8gX3IxW2pdKSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdF9yM1tqXSA9IChfcjNbal0gfHwgMCkgKyByICogcjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpID0gX3IzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdF9yM1tpXSA9IE1hdGguc3FydChfcjNbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRqID0gcXVhZHJhdGljID8gNCA6IDE7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRhID0gb2JqW3BdO1xuXHRcdFx0XHRcdF9jYWxjdWxhdGVDb250cm9sUG9pbnRzKGEsIGN1cnZpbmVzcywgcXVhZHJhdGljLCBiYXNpYywgX2NvclByb3BzW3BdKTsgLy90aGlzIG1ldGhvZCByZXF1aXJlcyB0aGF0IF9wYXJzZUFuY2hvcnMoKSBhbmQgX3NldFNlZ21lbnRSYXRpb3MoKSByYW4gZmlyc3Qgc28gdGhhdCBfcjEsIF9yMiwgYW5kIF9yMyB2YWx1ZXMgYXJlIHBvcHVsYXRlZCBmb3IgYWxsIHByb3BlcnRpZXNcblx0XHRcdFx0XHRpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKDAsIGopO1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoYS5sZW5ndGggLSBqLCBqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VCZXppZXJEYXRhID0gZnVuY3Rpb24odmFsdWVzLCB0eXBlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHR5cGUgPSB0eXBlIHx8IFwic29mdFwiO1xuXHRcdFx0XHR2YXIgb2JqID0ge30sXG5cdFx0XHRcdFx0aW5jID0gKHR5cGUgPT09IFwiY3ViaWNcIikgPyAzIDogMixcblx0XHRcdFx0XHRzb2Z0ID0gKHR5cGUgPT09IFwic29mdFwiKSxcblx0XHRcdFx0XHRwcm9wcyA9IFtdLFxuXHRcdFx0XHRcdGEsIGIsIGMsIGQsIGN1ciwgaSwgaiwgbCwgcCwgY250LCB0bXA7XG5cdFx0XHRcdGlmIChzb2Z0ICYmIHByZXBlbmQpIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSBbcHJlcGVuZF0uY29uY2F0KHZhbHVlcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhbHVlcyA9PSBudWxsIHx8IHZhbHVlcy5sZW5ndGggPCBpbmMgKyAxKSB7IHRocm93IFwiaW52YWxpZCBCZXppZXIgZGF0YVwiOyB9XG5cdFx0XHRcdGZvciAocCBpbiB2YWx1ZXNbMF0pIHtcblx0XHRcdFx0XHRwcm9wcy5wdXNoKHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRvYmpbcF0gPSBjdXIgPSBbXTtcblx0XHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdGEgPSAocHJlcGVuZCA9PSBudWxsKSA/IHZhbHVlc1tqXVtwXSA6ICh0eXBlb2YoICh0bXAgPSB2YWx1ZXNbal1bcF0pICkgPT09IFwic3RyaW5nXCIgJiYgdG1wLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcHJlcGVuZFtwXSArIE51bWJlcih0bXAuY2hhckF0KDApICsgdG1wLnN1YnN0cigyKSkgOiBOdW1iZXIodG1wKTtcblx0XHRcdFx0XHRcdGlmIChzb2Z0KSBpZiAoaiA+IDEpIGlmIChqIDwgbCAtIDEpIHtcblx0XHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IChhICsgY3VyW2NudC0yXSkgLyAyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGwgPSBjbnQgLSBpbmMgKyAxO1xuXHRcdFx0XHRcdGNudCA9IDA7XG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGogKz0gaW5jKSB7XG5cdFx0XHRcdFx0XHRhID0gY3VyW2pdO1xuXHRcdFx0XHRcdFx0YiA9IGN1cltqKzFdO1xuXHRcdFx0XHRcdFx0YyA9IGN1cltqKzJdO1xuXHRcdFx0XHRcdFx0ZCA9IChpbmMgPT09IDIpID8gMCA6IGN1cltqKzNdO1xuXHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IHRtcCA9IChpbmMgPT09IDMpID8gbmV3IFNlZ21lbnQoYSwgYiwgYywgZCkgOiBuZXcgU2VnbWVudChhLCAoMiAqIGIgKyBhKSAvIDMsICgyICogYiArIGMpIC8gMywgYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1ci5sZW5ndGggPSBjbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cdFx0XHRfYWRkQ3ViaWNMZW5ndGhzID0gZnVuY3Rpb24oYSwgc3RlcHMsIHJlc29sdXRpb24pIHtcblx0XHRcdFx0dmFyIGluYyA9IDEgLyByZXNvbHV0aW9uLFxuXHRcdFx0XHRcdGogPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRkLCBkMSwgcywgZGEsIGNhLCBiYSwgcCwgaSwgaW52LCBiZXosIGluZGV4O1xuXHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRiZXogPSBhW2pdO1xuXHRcdFx0XHRcdHMgPSBiZXouYTtcblx0XHRcdFx0XHRkYSA9IGJlei5kIC0gcztcblx0XHRcdFx0XHRjYSA9IGJlei5jIC0gcztcblx0XHRcdFx0XHRiYSA9IGJlei5iIC0gcztcblx0XHRcdFx0XHRkID0gZDEgPSAwO1xuXHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPD0gcmVzb2x1dGlvbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRwID0gaW5jICogaTtcblx0XHRcdFx0XHRcdGludiA9IDEgLSBwO1xuXHRcdFx0XHRcdFx0ZCA9IGQxIC0gKGQxID0gKHAgKiBwICogZGEgKyAzICogaW52ICogKHAgKiBjYSArIGludiAqIGJhKSkgKiBwKTtcblx0XHRcdFx0XHRcdGluZGV4ID0gaiAqIHJlc29sdXRpb24gKyBpIC0gMTtcblx0XHRcdFx0XHRcdHN0ZXBzW2luZGV4XSA9IChzdGVwc1tpbmRleF0gfHwgMCkgKyBkICogZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VMZW5ndGhEYXRhID0gZnVuY3Rpb24ob2JqLCByZXNvbHV0aW9uKSB7XG5cdFx0XHRcdHJlc29sdXRpb24gPSByZXNvbHV0aW9uID4+IDAgfHwgNjtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRsZW5ndGhzID0gW10sXG5cdFx0XHRcdFx0ZCA9IDAsXG5cdFx0XHRcdFx0dG90YWwgPSAwLFxuXHRcdFx0XHRcdHRocmVzaG9sZCA9IHJlc29sdXRpb24gLSAxLFxuXHRcdFx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRcdFx0Y3VyTFMgPSBbXSwgLy9jdXJyZW50IGxlbmd0aCBzZWdtZW50cyBhcnJheVxuXHRcdFx0XHRcdHAsIGksIGwsIGluZGV4O1xuXHRcdFx0XHRmb3IgKHAgaW4gb2JqKSB7XG5cdFx0XHRcdFx0X2FkZEN1YmljTGVuZ3RocyhvYmpbcF0sIGEsIHJlc29sdXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGwgPSBhLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGQgKz0gTWF0aC5zcXJ0KGFbaV0pO1xuXHRcdFx0XHRcdGluZGV4ID0gaSAlIHJlc29sdXRpb247XG5cdFx0XHRcdFx0Y3VyTFNbaW5kZXhdID0gZDtcblx0XHRcdFx0XHRpZiAoaW5kZXggPT09IHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0dG90YWwgKz0gZDtcblx0XHRcdFx0XHRcdGluZGV4ID0gKGkgLyByZXNvbHV0aW9uKSA+PiAwO1xuXHRcdFx0XHRcdFx0c2VnbWVudHNbaW5kZXhdID0gY3VyTFM7XG5cdFx0XHRcdFx0XHRsZW5ndGhzW2luZGV4XSA9IHRvdGFsO1xuXHRcdFx0XHRcdFx0ZCA9IDA7XG5cdFx0XHRcdFx0XHRjdXJMUyA9IFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge2xlbmd0aDp0b3RhbCwgbGVuZ3RoczpsZW5ndGhzLCBzZWdtZW50czpzZWdtZW50c307XG5cdFx0XHR9LFxuXG5cblxuXHRcdFx0QmV6aWVyUGx1Z2luID0gX2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0XHRcdFx0cHJvcE5hbWU6IFwiYmV6aWVyXCIsXG5cdFx0XHRcdFx0cHJpb3JpdHk6IC0xLFxuXHRcdFx0XHRcdHZlcnNpb246IFwiMS4zLjVcIixcblx0XHRcdFx0XHRBUEk6IDIsXG5cdFx0XHRcdFx0Z2xvYmFsOnRydWUsXG5cblx0XHRcdFx0XHQvL2dldHMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0XHRcdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0XHRcdFx0aWYgKHZhcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdFx0XHR2YXJzID0ge3ZhbHVlczp2YXJzfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX2Z1bmMgPSB7fTtcblx0XHRcdFx0XHRcdHRoaXMuX3JvdW5kID0ge307XG5cdFx0XHRcdFx0XHR0aGlzLl9wcm9wcyA9IFtdO1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZVJlcyA9ICh2YXJzLnRpbWVSZXNvbHV0aW9uID09IG51bGwpID8gNiA6IHBhcnNlSW50KHZhcnMudGltZVJlc29sdXRpb24sIDEwKTtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB2YXJzLnZhbHVlcyB8fCBbXSxcblx0XHRcdFx0XHRcdFx0Zmlyc3QgPSB7fSxcblx0XHRcdFx0XHRcdFx0c2Vjb25kID0gdmFsdWVzWzBdLFxuXHRcdFx0XHRcdFx0XHRhdXRvUm90YXRlID0gdmFycy5hdXRvUm90YXRlIHx8IHR3ZWVuLnZhcnMub3JpZW50VG9CZXppZXIsXG5cdFx0XHRcdFx0XHRcdHAsIGlzRnVuYywgaSwgaiwgcHJlcGVuZDtcblxuXHRcdFx0XHRcdFx0dGhpcy5fYXV0b1JvdGF0ZSA9IGF1dG9Sb3RhdGUgPyAoYXV0b1JvdGF0ZSBpbnN0YW5jZW9mIEFycmF5KSA/IGF1dG9Sb3RhdGUgOiBbW1wieFwiLFwieVwiLFwicm90YXRpb25cIiwoKGF1dG9Sb3RhdGUgPT09IHRydWUpID8gMCA6IE51bWJlcihhdXRvUm90YXRlKSB8fCAwKV1dIDogbnVsbDtcblx0XHRcdFx0XHRcdGZvciAocCBpbiBzZWNvbmQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fcHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aSA9IHRoaXMuX3Byb3BzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRwID0gdGhpcy5fcHJvcHNbaV07XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHRcdFx0aXNGdW5jID0gdGhpcy5fZnVuY1twXSA9ICh0eXBlb2YodGFyZ2V0W3BdKSA9PT0gXCJmdW5jdGlvblwiKTtcblx0XHRcdFx0XHRcdFx0Zmlyc3RbcF0gPSAoIWlzRnVuYykgPyBwYXJzZUZsb2F0KHRhcmdldFtwXSkgOiB0YXJnZXRbICgocC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHAuc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdKCk7XG5cdFx0XHRcdFx0XHRcdGlmICghcHJlcGVuZCkgaWYgKGZpcnN0W3BdICE9PSB2YWx1ZXNbMF1bcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRwcmVwZW5kID0gZmlyc3Q7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX2JlemllcnMgPSAodmFycy50eXBlICE9PSBcImN1YmljXCIgJiYgdmFycy50eXBlICE9PSBcInF1YWRyYXRpY1wiICYmIHZhcnMudHlwZSAhPT0gXCJzb2Z0XCIpID8gYmV6aWVyVGhyb3VnaCh2YWx1ZXMsIGlzTmFOKHZhcnMuY3VydmluZXNzKSA/IDEgOiB2YXJzLmN1cnZpbmVzcywgZmFsc2UsICh2YXJzLnR5cGUgPT09IFwidGhydUJhc2ljXCIpLCB2YXJzLmNvcnJlbGF0ZSwgcHJlcGVuZCkgOiBfcGFyc2VCZXppZXJEYXRhKHZhbHVlcywgdmFycy50eXBlLCBmaXJzdCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdDb3VudCA9IHRoaXMuX2JlemllcnNbcF0ubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZVJlcykge1xuXHRcdFx0XHRcdFx0XHR2YXIgbGQgPSBfcGFyc2VMZW5ndGhEYXRhKHRoaXMuX2JlemllcnMsIHRoaXMuX3RpbWVSZXMpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sZW5ndGggPSBsZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xlbmd0aHMgPSBsZC5sZW5ndGhzO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50cyA9IGxkLnNlZ21lbnRzO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IHRoaXMuX2xpID0gdGhpcy5fczEgPSB0aGlzLl9zaSA9IDA7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2wyID0gdGhpcy5fbGVuZ3Roc1swXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY3VyU2VnID0gdGhpcy5fc2VnbWVudHNbMF07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gdGhpcy5fY3VyU2VnWzBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9wcmVjID0gMSAvIHRoaXMuX2N1clNlZy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICgoYXV0b1JvdGF0ZSA9IHRoaXMuX2F1dG9Sb3RhdGUpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2luaXRpYWxSb3RhdGlvbnMgPSBbXTtcblx0XHRcdFx0XHRcdFx0aWYgKCEoYXV0b1JvdGF0ZVswXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2F1dG9Sb3RhdGUgPSBhdXRvUm90YXRlID0gW2F1dG9Sb3RhdGVdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGkgPSBhdXRvUm90YXRlLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IDM7IGorKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cCA9IGF1dG9Sb3RhdGVbaV1bal07XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9mdW5jW3BdID0gKHR5cGVvZih0YXJnZXRbcF0pID09PSBcImZ1bmN0aW9uXCIpID8gdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSA6IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRwID0gYXV0b1JvdGF0ZVtpXVsyXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9pbml0aWFsUm90YXRpb25zW2ldID0gKHRoaXMuX2Z1bmNbcF0gPyB0aGlzLl9mdW5jW3BdLmNhbGwodGhpcy5fdGFyZ2V0KSA6IHRoaXMuX3RhcmdldFtwXSkgfHwgMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRSYXRpbyA9IHR3ZWVuLnZhcnMucnVuQmFja3dhcmRzID8gMSA6IDA7IC8vd2UgZGV0ZXJtaW5lIHRoZSBzdGFydGluZyByYXRpbyB3aGVuIHRoZSB0d2VlbiBpbml0cyB3aGljaCBpcyBhbHdheXMgMCB1bmxlc3MgdGhlIHR3ZWVuIGhhcyBydW5CYWNrd2FyZHM6dHJ1ZSAoaW5kaWNhdGluZyBpdCdzIGEgZnJvbSgpIHR3ZWVuKSBpbiB3aGljaCBjYXNlIGl0J3MgMS5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvL2NhbGxlZCBlYWNoIHRpbWUgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCwgYW5kIHRoZSByYXRpbyBnZXRzIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXIgKHR5cGljYWxseSBpdCdzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgaXQgY2FuIGV4Y2VlZCB0aG9zZSB3aGVuIHVzaW5nIGFuIGVhc2UgbGlrZSBFbGFzdGljLmVhc2VPdXQgb3IgQmFjay5lYXNlT3V0LCBldGMuKVxuXHRcdFx0XHRcdHNldDogZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnQ291bnQsXG5cdFx0XHRcdFx0XHRcdGZ1bmMgPSB0aGlzLl9mdW5jLFxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXQsXG5cdFx0XHRcdFx0XHRcdG5vdFN0YXJ0ID0gKHYgIT09IHRoaXMuX3N0YXJ0UmF0aW8pLFxuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCwgaW52LCBpLCBwLCBiLCB0LCB2YWwsIGwsIGxlbmd0aHMsIGN1clNlZztcblx0XHRcdFx0XHRcdGlmICghdGhpcy5fdGltZVJlcykge1xuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCA9ICh2IDwgMCkgPyAwIDogKHYgPj0gMSkgPyBzZWdtZW50cyAtIDEgOiAoc2VnbWVudHMgKiB2KSA+PiAwO1xuXHRcdFx0XHRcdFx0XHR0ID0gKHYgLSAoY3VySW5kZXggKiAoMSAvIHNlZ21lbnRzKSkpICogc2VnbWVudHM7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsZW5ndGhzID0gdGhpcy5fbGVuZ3Rocztcblx0XHRcdFx0XHRcdFx0Y3VyU2VnID0gdGhpcy5fY3VyU2VnO1xuXHRcdFx0XHRcdFx0XHR2ICo9IHRoaXMuX2xlbmd0aDtcblx0XHRcdFx0XHRcdFx0aSA9IHRoaXMuX2xpO1xuXHRcdFx0XHRcdFx0XHQvL2ZpbmQgdGhlIGFwcHJvcHJpYXRlIHNlZ21lbnQgKGlmIHRoZSBjdXJyZW50bHkgY2FjaGVkIG9uZSBpc24ndCBjb3JyZWN0KVxuXHRcdFx0XHRcdFx0XHRpZiAodiA+IHRoaXMuX2wyICYmIGkgPCBzZWdtZW50cyAtIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRsID0gc2VnbWVudHMgLSAxO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpIDwgbCAmJiAodGhpcy5fbDIgPSBsZW5ndGhzWysraV0pIDw9IHYpIHtcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IGxlbmd0aHNbaS0xXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9saSA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY3VyU2VnID0gY3VyU2VnID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbKHRoaXMuX3MxID0gdGhpcy5fc2kgPSAwKV07XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodiA8IHRoaXMuX2wxICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPiAwICYmICh0aGlzLl9sMSA9IGxlbmd0aHNbLS1pXSkgPj0gdikgeyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDAgJiYgdiA8IHRoaXMuX2wxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbDIgPSBsZW5ndGhzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2xpID0gaTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJTZWcgPSBjdXJTZWcgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IGN1clNlZ1sodGhpcy5fc2kgPSBjdXJTZWcubGVuZ3RoIC0gMSkgLSAxXSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gY3VyU2VnW3RoaXMuX3NpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdC8vbm93IGZpbmQgdGhlIGFwcHJvcHJpYXRlIHN1Yi1zZWdtZW50ICh3ZSBzcGxpdCBpdCBpbnRvIHRoZSBudW1iZXIgb2YgcGllY2VzIHRoYXQgd2FzIGRlZmluZWQgYnkgXCJwcmVjaXNpb25cIiBhbmQgbWVhc3VyZWQgZWFjaCBvbmUpXG5cdFx0XHRcdFx0XHRcdHYgLT0gdGhpcy5fbDE7XG5cdFx0XHRcdFx0XHRcdGkgPSB0aGlzLl9zaTtcblx0XHRcdFx0XHRcdFx0aWYgKHYgPiB0aGlzLl9zMiAmJiBpIDwgY3VyU2VnLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRsID0gY3VyU2VnLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBsICYmICh0aGlzLl9zMiA9IGN1clNlZ1srK2ldKSA8PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczEgPSBjdXJTZWdbaS0xXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaSA9IGk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodiA8IHRoaXMuX3MxICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPiAwICYmICh0aGlzLl9zMSA9IGN1clNlZ1stLWldKSA+PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDAgJiYgdiA8IHRoaXMuX3MxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2kgPSBpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHQgPSAoKGkgKyAodiAtIHRoaXMuX3MxKSAvICh0aGlzLl9zMiAtIHRoaXMuX3MxKSkgKiB0aGlzLl9wcmVjKSB8fCAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aW52ID0gMSAtIHQ7XG5cblx0XHRcdFx0XHRcdGkgPSB0aGlzLl9wcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuX3Byb3BzW2ldO1xuXHRcdFx0XHRcdFx0XHRiID0gdGhpcy5fYmV6aWVyc1twXVtjdXJJbmRleF07XG5cdFx0XHRcdFx0XHRcdHZhbCA9ICh0ICogdCAqIGIuZGEgKyAzICogaW52ICogKHQgKiBiLmNhICsgaW52ICogYi5iYSkpICogdCArIGIuYTtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuX3JvdW5kW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChmdW5jW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdKHZhbCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdID0gdmFsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLl9hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhciA9IHRoaXMuX2F1dG9Sb3RhdGUsXG5cdFx0XHRcdFx0XHRcdFx0YjIsIHgxLCB5MSwgeDIsIHkyLCBhZGQsIGNvbnY7XG5cdFx0XHRcdFx0XHRcdGkgPSBhci5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdHAgPSBhcltpXVsyXTtcblx0XHRcdFx0XHRcdFx0XHRhZGQgPSBhcltpXVszXSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnYgPSAoYXJbaV1bNF0gPT09IHRydWUpID8gMSA6IF9SQUQyREVHO1xuXHRcdFx0XHRcdFx0XHRcdGIgPSB0aGlzLl9iZXppZXJzW2FyW2ldWzBdXTtcblx0XHRcdFx0XHRcdFx0XHRiMiA9IHRoaXMuX2JlemllcnNbYXJbaV1bMV1dO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGIgJiYgYjIpIHsgLy9pbiBjYXNlIG9uZSBvZiB0aGUgcHJvcGVydGllcyBnb3Qgb3ZlcndyaXR0ZW4uXG5cdFx0XHRcdFx0XHRcdFx0XHRiID0gYltjdXJJbmRleF07XG5cdFx0XHRcdFx0XHRcdFx0XHRiMiA9IGIyW2N1ckluZGV4XTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0eDEgPSBiLmEgKyAoYi5iIC0gYi5hKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR4MiA9IGIuYiArIChiLmMgLSBiLmIpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgxICs9ICh4MiAtIHgxKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR4MiArPSAoKGIuYyArIChiLmQgLSBiLmMpICogdCkgLSB4MikgKiB0O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR5MSA9IGIyLmEgKyAoYjIuYiAtIGIyLmEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHkyID0gYjIuYiArIChiMi5jIC0gYjIuYikgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTEgKz0gKHkyIC0geTEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHkyICs9ICgoYjIuYyArIChiMi5kIC0gYjIuYykgKiB0KSAtIHkyKSAqIHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhbCA9IG5vdFN0YXJ0ID8gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIGNvbnYgKyBhZGQgOiB0aGlzLl9pbml0aWFsUm90YXRpb25zW2ldO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZnVuY1twXSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0odmFsKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSA9IHZhbDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHR9KSxcblx0XHRcdHAgPSBCZXppZXJQbHVnaW4ucHJvdG90eXBlO1xuXG5cblx0XHRCZXppZXJQbHVnaW4uYmV6aWVyVGhyb3VnaCA9IGJlemllclRocm91Z2g7XG5cdFx0QmV6aWVyUGx1Z2luLmN1YmljVG9RdWFkcmF0aWMgPSBjdWJpY1RvUXVhZHJhdGljO1xuXHRcdEJlemllclBsdWdpbi5fYXV0b0NTUyA9IHRydWU7IC8vaW5kaWNhdGVzIHRoYXQgdGhpcyBwbHVnaW4gY2FuIGJlIGluc2VydGVkIGludG8gdGhlIFwiY3NzXCIgb2JqZWN0IHVzaW5nIHRoZSBhdXRvQ1NTIGZlYXR1cmUgb2YgVHdlZW5MaXRlXG5cdFx0QmV6aWVyUGx1Z2luLnF1YWRyYXRpY1RvQ3ViaWMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNlZ21lbnQoYSwgKDIgKiBiICsgYSkgLyAzLCAoMiAqIGIgKyBjKSAvIDMsIGMpO1xuXHRcdH07XG5cblx0XHRCZXppZXJQbHVnaW4uX2Nzc1JlZ2lzdGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgQ1NTUGx1Z2luID0gX2dsb2JhbHMuQ1NTUGx1Z2luO1xuXHRcdFx0aWYgKCFDU1NQbHVnaW4pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIF9pbnRlcm5hbHMgPSBDU1NQbHVnaW4uX2ludGVybmFscyxcblx0XHRcdFx0X3BhcnNlVG9Qcm94eSA9IF9pbnRlcm5hbHMuX3BhcnNlVG9Qcm94eSxcblx0XHRcdFx0X3NldFBsdWdpblJhdGlvID0gX2ludGVybmFscy5fc2V0UGx1Z2luUmF0aW8sXG5cdFx0XHRcdENTU1Byb3BUd2VlbiA9IF9pbnRlcm5hbHMuQ1NTUHJvcFR3ZWVuO1xuXHRcdFx0X2ludGVybmFscy5fcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiZXppZXJcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwcm9wLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHRcdGlmIChlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0XHRlID0ge3ZhbHVlczplfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwbHVnaW4gPSBuZXcgQmV6aWVyUGx1Z2luKCk7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBlLnZhbHVlcyxcblx0XHRcdFx0XHRsID0gdmFsdWVzLmxlbmd0aCAtIDEsXG5cdFx0XHRcdFx0cGx1Z2luVmFsdWVzID0gW10sXG5cdFx0XHRcdFx0diA9IHt9LFxuXHRcdFx0XHRcdGksIHAsIGRhdGE7XG5cdFx0XHRcdGlmIChsIDwgMCkge1xuXHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDw9IGw7IGkrKykge1xuXHRcdFx0XHRcdGRhdGEgPSBfcGFyc2VUb1Byb3h5KHQsIHZhbHVlc1tpXSwgY3NzcCwgcHQsIHBsdWdpbiwgKGwgIT09IGkpKTtcblx0XHRcdFx0XHRwbHVnaW5WYWx1ZXNbaV0gPSBkYXRhLmVuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHAgaW4gZSkge1xuXHRcdFx0XHRcdHZbcF0gPSBlW3BdOyAvL2R1cGxpY2F0ZSB0aGUgdmFycyBvYmplY3QgYmVjYXVzZSB3ZSBuZWVkIHRvIGFsdGVyIHNvbWUgdGhpbmdzIHdoaWNoIHdvdWxkIGNhdXNlIHByb2JsZW1zIGlmIHRoZSB1c2VyIHBsYW5zIHRvIHJldXNlIHRoZSBzYW1lIHZhcnMgb2JqZWN0IGZvciBhbm90aGVyIHR3ZWVuLlxuXHRcdFx0XHR9XG5cdFx0XHRcdHYudmFsdWVzID0gcGx1Z2luVmFsdWVzO1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgXCJiZXppZXJcIiwgMCwgMCwgZGF0YS5wdCwgMik7XG5cdFx0XHRcdHB0LmRhdGEgPSBkYXRhO1xuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gX3NldFBsdWdpblJhdGlvO1xuXHRcdFx0XHRpZiAodi5hdXRvUm90YXRlID09PSAwKSB7XG5cdFx0XHRcdFx0di5hdXRvUm90YXRlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi5hdXRvUm90YXRlICYmICEodi5hdXRvUm90YXRlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHRcdFx0aSA9ICh2LmF1dG9Sb3RhdGUgPT09IHRydWUpID8gMCA6IE51bWJlcih2LmF1dG9Sb3RhdGUpO1xuXHRcdFx0XHRcdHYuYXV0b1JvdGF0ZSA9IChkYXRhLmVuZC5sZWZ0ICE9IG51bGwpID8gW1tcImxlZnRcIixcInRvcFwiLFwicm90YXRpb25cIixpLGZhbHNlXV0gOiAoZGF0YS5lbmQueCAhPSBudWxsKSA/IFtbXCJ4XCIsXCJ5XCIsXCJyb3RhdGlvblwiLGksZmFsc2VdXSA6IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LmF1dG9Sb3RhdGUpIHtcblx0XHRcdFx0XHRpZiAoIWNzc3AuX3RyYW5zZm9ybSkge1xuXHRcdFx0XHRcdFx0Y3NzcC5fZW5hYmxlVHJhbnNmb3JtcyhmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGEuYXV0b1JvdGF0ZSA9IGNzc3AuX3RhcmdldC5fZ3NUcmFuc2Zvcm07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGx1Z2luLl9vbkluaXRUd2VlbihkYXRhLnByb3h5LCB2LCBjc3NwLl90d2Vlbik7XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH19KTtcblx0XHR9O1xuXG5cdFx0cC5fcm91bmRQcm9wcyA9IGZ1bmN0aW9uKGxvb2t1cCwgdmFsdWUpIHtcblx0XHRcdHZhciBvcCA9IHRoaXMuX292ZXJ3cml0ZVByb3BzLFxuXHRcdFx0XHRpID0gb3AubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChsb29rdXBbb3BbaV1dIHx8IGxvb2t1cC5iZXppZXIgfHwgbG9va3VwLmJlemllclRocm91Z2gpIHtcblx0XHRcdFx0XHR0aGlzLl9yb3VuZFtvcFtpXV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgYSA9IHRoaXMuX3Byb3BzLFxuXHRcdFx0XHRwLCBpO1xuXHRcdFx0Zm9yIChwIGluIHRoaXMuX2JlemllcnMpIHtcblx0XHRcdFx0aWYgKHAgaW4gbG9va3VwKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2JlemllcnNbcF07XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2Z1bmNbcF07XG5cdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKGFbaV0gPT09IHApIHtcblx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3VwZXIuX2tpbGwuY2FsbCh0aGlzLCBsb29rdXApO1xuXHRcdH07XG5cblx0fSgpKTtcblxuXG5cblxuXG5cblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENTU1BsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcInBsdWdpbnMuQ1NTUGx1Z2luXCIsIFtcInBsdWdpbnMuVHdlZW5QbHVnaW5cIixcIlR3ZWVuTGl0ZVwiXSwgZnVuY3Rpb24oVHdlZW5QbHVnaW4sIFR3ZWVuTGl0ZSkge1xuXG5cdFx0LyoqIEBjb25zdHJ1Y3RvciAqKi9cblx0XHR2YXIgQ1NTUGx1Z2luID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFR3ZWVuUGx1Z2luLmNhbGwodGhpcywgXCJjc3NcIik7XG5cdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLmxlbmd0aCA9IDA7XG5cdFx0XHRcdHRoaXMuc2V0UmF0aW8gPSBDU1NQbHVnaW4ucHJvdG90eXBlLnNldFJhdGlvOyAvL3NwZWVkIG9wdGltaXphdGlvbiAoYXZvaWQgcHJvdG90eXBlIGxvb2t1cCBvbiB0aGlzIFwiaG90XCIgbWV0aG9kKVxuXHRcdFx0fSxcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRfaGFzUHJpb3JpdHksIC8vdHVybnMgdHJ1ZSB3aGVuZXZlciBhIENTU1Byb3BUd2VlbiBpbnN0YW5jZSBpcyBjcmVhdGVkIHRoYXQgaGFzIGEgcHJpb3JpdHkgb3RoZXIgdGhhbiAwLiBUaGlzIGhlbHBzIHVzIGRpc2Nlcm4gd2hldGhlciBvciBub3Qgd2Ugc2hvdWxkIHNwZW5kIHRoZSB0aW1lIG9yZ2FuaXppbmcgdGhlIGxpbmtlZCBsaXN0IG9yIG5vdCBhZnRlciBhIENTU1BsdWdpbidzIF9vbkluaXRUd2VlbigpIG1ldGhvZCBpcyBjYWxsZWQuXG5cdFx0XHRfc3VmZml4TWFwLCAvL3dlIHNldCB0aGlzIGluIF9vbkluaXRUd2VlbigpIGVhY2ggdGltZSBhcyBhIHdheSB0byBoYXZlIGEgcGVyc2lzdGVudCB2YXJpYWJsZSB3ZSBjYW4gdXNlIGluIG90aGVyIG1ldGhvZHMgbGlrZSBfcGFyc2UoKSB3aXRob3V0IGhhdmluZyB0byBwYXNzIGl0IGFyb3VuZCBhcyBhIHBhcmFtZXRlciBhbmQgd2Uga2VlcCBfcGFyc2UoKSBkZWNvdXBsZWQgZnJvbSBhIHBhcnRpY3VsYXIgQ1NTUGx1Z2luIGluc3RhbmNlXG5cdFx0XHRfY3MsIC8vY29tcHV0ZWQgc3R5bGUgKHdlIHN0b3JlIHRoaXMgaW4gYSBzaGFyZWQgdmFyaWFibGUgdG8gY29uc2VydmUgbWVtb3J5IGFuZCBtYWtlIG1pbmlmaWNhdGlvbiB0aWdodGVyXG5cdFx0XHRfb3ZlcndyaXRlUHJvcHMsIC8vYWxpYXMgdG8gdGhlIGN1cnJlbnRseSBpbnN0YW50aWF0aW5nIENTU1BsdWdpbidzIF9vdmVyd3JpdGVQcm9wcyBhcnJheS4gV2UgdXNlIHRoaXMgY2xvc3VyZSBpbiBvcmRlciB0byBhdm9pZCBoYXZpbmcgdG8gcGFzcyBhIHJlZmVyZW5jZSBhcm91bmQgZnJvbSBtZXRob2QgdG8gbWV0aG9kIGFuZCBhaWQgaW4gbWluaWZpY2F0aW9uLlxuXHRcdFx0X3NwZWNpYWxQcm9wcyA9IHt9LFxuXHRcdFx0cCA9IENTU1BsdWdpbi5wcm90b3R5cGUgPSBuZXcgVHdlZW5QbHVnaW4oXCJjc3NcIik7XG5cblx0XHRwLmNvbnN0cnVjdG9yID0gQ1NTUGx1Z2luO1xuXHRcdENTU1BsdWdpbi52ZXJzaW9uID0gXCIxLjE4LjRcIjtcblx0XHRDU1NQbHVnaW4uQVBJID0gMjtcblx0XHRDU1NQbHVnaW4uZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlID0gMDtcblx0XHRDU1NQbHVnaW4uZGVmYXVsdFNrZXdUeXBlID0gXCJjb21wZW5zYXRlZFwiO1xuXHRcdENTU1BsdWdpbi5kZWZhdWx0U21vb3RoT3JpZ2luID0gdHJ1ZTtcblx0XHRwID0gXCJweFwiOyAvL3dlJ2xsIHJldXNlIHRoZSBcInBcIiB2YXJpYWJsZSB0byBrZWVwIGZpbGUgc2l6ZSBkb3duXG5cdFx0Q1NTUGx1Z2luLnN1ZmZpeE1hcCA9IHt0b3A6cCwgcmlnaHQ6cCwgYm90dG9tOnAsIGxlZnQ6cCwgd2lkdGg6cCwgaGVpZ2h0OnAsIGZvbnRTaXplOnAsIHBhZGRpbmc6cCwgbWFyZ2luOnAsIHBlcnNwZWN0aXZlOnAsIGxpbmVIZWlnaHQ6XCJcIn07XG5cblxuXHRcdHZhciBfbnVtRXhwID0gLyg/OlxcLXxcXC58XFxiKShcXGR8XFwufGVcXC0pKy9nLFxuXHRcdFx0X3JlbE51bUV4cCA9IC8oPzpcXGR8XFwtXFxkfFxcLlxcZHxcXC1cXC5cXGR8XFwrPVxcZHxcXC09XFxkfFxcKz0uXFxkfFxcLT1cXC5cXGQpKy9nLFxuXHRcdFx0X3ZhbHVlc0V4cCA9IC8oPzpcXCs9fFxcLT18XFwtfFxcYilbXFxkXFwtXFwuXStbYS16QS1aMC05XSooPzolfFxcYikvZ2ksIC8vZmluZHMgYWxsIHRoZSB2YWx1ZXMgdGhhdCBiZWdpbiB3aXRoIG51bWJlcnMgb3IgKz0gb3IgLT0gYW5kIHRoZW4gYSBudW1iZXIuIEluY2x1ZGVzIHN1ZmZpeGVzLiBXZSB1c2UgdGhpcyB0byBzcGxpdCBjb21wbGV4IHZhbHVlcyBhcGFydCBsaWtlIFwiMXB4IDVweCAyMHB4IHJnYigyNTUsMTAyLDUxKVwiXG5cdFx0XHRfTmFORXhwID0gLyg/IVsrLV0/XFxkKlxcLj9cXGQrfFsrLV18ZVsrLV1cXGQrKVteMC05XS9nLCAvL2Fsc28gYWxsb3dzIHNjaWVudGlmaWMgbm90YXRpb24gYW5kIGRvZXNuJ3Qga2lsbCB0aGUgbGVhZGluZyAtLysgaW4gLT0gYW5kICs9XG5cdFx0XHRfc3VmZml4RXhwID0gLyg/OlxcZHxcXC18XFwrfD18I3xcXC4pKi9nLFxuXHRcdFx0X29wYWNpdHlFeHAgPSAvb3BhY2l0eSAqPSAqKFteKV0qKS9pLFxuXHRcdFx0X29wYWNpdHlWYWxFeHAgPSAvb3BhY2l0eTooW147XSopL2ksXG5cdFx0XHRfYWxwaGFGaWx0ZXJFeHAgPSAvYWxwaGFcXChvcGFjaXR5ICo9Lis/XFwpL2ksXG5cdFx0XHRfcmdiaHNsRXhwID0gL14ocmdifGhzbCkvLFxuXHRcdFx0X2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxuXHRcdFx0X2NhbWVsRXhwID0gLy0oW2Etel0pL2dpLFxuXHRcdFx0X3VybEV4cCA9IC8oXig/OnVybFxcKFxcXCJ8dXJsXFwoKSl8KD86KFxcXCJcXCkpJHxcXCkkKS9naSwgLy9mb3IgcHVsbGluZyBvdXQgdXJscyBmcm9tIHVybCguLi4pIG9yIHVybChcIi4uLlwiKSBzdHJpbmdzIChzb21lIGJyb3dzZXJzIHdyYXAgdXJscyBpbiBxdW90ZXMsIHNvbWUgZG9uJ3Qgd2hlbiByZXBvcnRpbmcgdGhpbmdzIGxpa2UgYmFja2dyb3VuZEltYWdlKVxuXHRcdFx0X2NhbWVsRnVuYyA9IGZ1bmN0aW9uKHMsIGcpIHsgcmV0dXJuIGcudG9VcHBlckNhc2UoKTsgfSxcblx0XHRcdF9ob3JpekV4cCA9IC8oPzpMZWZ0fFJpZ2h0fFdpZHRoKS9pLFxuXHRcdFx0X2llR2V0TWF0cml4RXhwID0gLyhNMTF8TTEyfE0yMXxNMjIpPVtcXGRcXC1cXC5lXSsvZ2ksXG5cdFx0XHRfaWVTZXRNYXRyaXhFeHAgPSAvcHJvZ2lkXFw6RFhJbWFnZVRyYW5zZm9ybVxcLk1pY3Jvc29mdFxcLk1hdHJpeFxcKC4rP1xcKS9pLFxuXHRcdFx0X2NvbW1hc091dHNpZGVQYXJlbkV4cCA9IC8sKD89W15cXCldKig/OlxcKHwkKSkvZ2ksIC8vZmluZHMgYW55IGNvbW1hcyB0aGF0IGFyZSBub3Qgd2l0aGluIHBhcmVudGhlc2lzXG5cdFx0XHRfY29tcGxleEV4cCA9IC9bXFxzLFxcKF0vaSwgLy9mb3IgdGVzdGluZyBhIHN0cmluZyB0byBmaW5kIGlmIGl0IGhhcyBhIHNwYWNlLCBjb21tYSwgb3Igb3BlbiBwYXJlbnRoZXNpcyAoY2x1ZXMgdGhhdCBpdCdzIGEgY29tcGxleCB2YWx1ZSlcblx0XHRcdF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcblx0XHRcdF9mb3JjZVBUID0ge30sXG5cdFx0XHRfZG9jID0gZG9jdW1lbnQsXG5cdFx0XHRfY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpO1xuXHRcdFx0fSxcblx0XHRcdF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHRfdGVtcEltZyA9IF9jcmVhdGVFbGVtZW50KFwiaW1nXCIpLFxuXHRcdFx0X2ludGVybmFscyA9IENTU1BsdWdpbi5faW50ZXJuYWxzID0ge19zcGVjaWFsUHJvcHM6X3NwZWNpYWxQcm9wc30sIC8vcHJvdmlkZXMgYSBob29rIHRvIGEgZmV3IGludGVybmFsIG1ldGhvZHMgdGhhdCB3ZSBuZWVkIHRvIGFjY2VzcyBmcm9tIGluc2lkZSBvdGhlciBwbHVnaW5zXG5cdFx0XHRfYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuXHRcdFx0X2F1dG9Sb3VuZCxcblx0XHRcdF9yZXFTYWZhcmlGaXgsIC8vd2Ugd29uJ3QgYXBwbHkgdGhlIFNhZmFyaSB0cmFuc2Zvcm0gZml4IHVudGlsIHdlIGFjdHVhbGx5IGNvbWUgYWNyb3NzIGEgdHdlZW4gdGhhdCBhZmZlY3RzIGEgdHJhbnNmb3JtIHByb3BlcnR5ICh0byBtYWludGFpbiBiZXN0IHBlcmZvcm1hbmNlKS5cblxuXHRcdFx0X2lzU2FmYXJpLFxuXHRcdFx0X2lzRmlyZWZveCwgLy9GaXJlZm94IGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyAzRCB0cmFuc2Zvcm1lZCBlbGVtZW50cyB0byByYW5kb21seSBkaXNhcHBlYXIgdW5sZXNzIGEgcmVwYWludCBpcyBmb3JjZWQgYWZ0ZXIgZWFjaCB1cGRhdGUgb24gZWFjaCBlbGVtZW50LlxuXHRcdFx0X2lzU2FmYXJpTFQ2LCAvL1NhZmFyaSAoYW5kIEFuZHJvaWQgNCB3aGljaCB1c2VzIGEgZmxhdm9yIG9mIFNhZmFyaSkgaGFzIGEgYnVnIHRoYXQgcHJldmVudHMgY2hhbmdlcyB0byBcInRvcFwiIGFuZCBcImxlZnRcIiBwcm9wZXJ0aWVzIGZyb20gcmVuZGVyaW5nIHByb3Blcmx5IGlmIGNoYW5nZWQgb24gdGhlIHNhbWUgZnJhbWUgYXMgYSB0cmFuc2Zvcm0gVU5MRVNTIHdlIHNldCB0aGUgZWxlbWVudCdzIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSB0byBoaWRkZW4gKHdlaXJkLCBJIGtub3cpLiBEb2luZyB0aGlzIGZvciBBbmRyb2lkIDMgYW5kIGVhcmxpZXIgc2VlbXMgdG8gYWN0dWFsbHkgY2F1c2Ugb3RoZXIgcHJvYmxlbXMsIHRob3VnaCAoZnVuISlcblx0XHRcdF9pZVZlcnMsXG5cdFx0XHRfc3VwcG9ydHNPcGFjaXR5ID0gKGZ1bmN0aW9uKCkgeyAvL3dlIHNldCBfaXNTYWZhcmksIF9pZVZlcnMsIF9pc0ZpcmVmb3gsIGFuZCBfc3VwcG9ydHNPcGFjaXR5IGFsbCBpbiBvbmUgZnVuY3Rpb24gaGVyZSB0byByZWR1Y2UgZmlsZSBzaXplIHNsaWdodGx5LCBlc3BlY2lhbGx5IGluIHRoZSBtaW5pZmllZCB2ZXJzaW9uLlxuXHRcdFx0XHR2YXIgaSA9IF9hZ2VudC5pbmRleE9mKFwiQW5kcm9pZFwiKSxcblx0XHRcdFx0XHRhID0gX2NyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdFx0XHRfaXNTYWZhcmkgPSAoX2FnZW50LmluZGV4T2YoXCJTYWZhcmlcIikgIT09IC0xICYmIF9hZ2VudC5pbmRleE9mKFwiQ2hyb21lXCIpID09PSAtMSAmJiAoaSA9PT0gLTEgfHwgTnVtYmVyKF9hZ2VudC5zdWJzdHIoaSs4LCAxKSkgPiAzKSk7XG5cdFx0XHRcdF9pc1NhZmFyaUxUNiA9IChfaXNTYWZhcmkgJiYgKE51bWJlcihfYWdlbnQuc3Vic3RyKF9hZ2VudC5pbmRleE9mKFwiVmVyc2lvbi9cIikrOCwgMSkpIDwgNikpO1xuXHRcdFx0XHRfaXNGaXJlZm94ID0gKF9hZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSAhPT0gLTEpO1xuXHRcdFx0XHRpZiAoKC9NU0lFIChbMC05XXsxLH1bXFwuMC05XXswLH0pLykuZXhlYyhfYWdlbnQpIHx8ICgvVHJpZGVudFxcLy4qcnY6KFswLTldezEsfVtcXC4wLTldezAsfSkvKS5leGVjKF9hZ2VudCkpIHtcblx0XHRcdFx0XHRfaWVWZXJzID0gcGFyc2VGbG9hdCggUmVnRXhwLiQxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFhKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGEuc3R5bGUuY3NzVGV4dCA9IFwidG9wOjFweDtvcGFjaXR5Oi41NTtcIjtcblx0XHRcdFx0cmV0dXJuIC9eMC41NS8udGVzdChhLnN0eWxlLm9wYWNpdHkpO1xuXHRcdFx0fSgpKSxcblx0XHRcdF9nZXRJRU9wYWNpdHkgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHJldHVybiAoX29wYWNpdHlFeHAudGVzdCggKCh0eXBlb2YodikgPT09IFwic3RyaW5nXCIpID8gdiA6ICh2LmN1cnJlbnRTdHlsZSA/IHYuY3VycmVudFN0eWxlLmZpbHRlciA6IHYuc3R5bGUuZmlsdGVyKSB8fCBcIlwiKSApID8gKCBwYXJzZUZsb2F0KCBSZWdFeHAuJDEgKSAvIDEwMCApIDogMSk7XG5cdFx0XHR9LFxuXHRcdFx0X2xvZyA9IGZ1bmN0aW9uKHMpIHsvL2ZvciBsb2dnaW5nIG1lc3NhZ2VzLCBidXQgaW4gYSB3YXkgdGhhdCB3b24ndCB0aHJvdyBlcnJvcnMgaW4gb2xkIHZlcnNpb25zIG9mIElFLlxuXHRcdFx0XHRpZiAod2luZG93LmNvbnNvbGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3ByZWZpeENTUyA9IFwiXCIsIC8vdGhlIG5vbi1jYW1lbENhc2UgdmVuZG9yIHByZWZpeCBsaWtlIFwiLW8tXCIsIFwiLW1vei1cIiwgXCItbXMtXCIsIG9yIFwiLXdlYmtpdC1cIlxuXHRcdFx0X3ByZWZpeCA9IFwiXCIsIC8vY2FtZWxDYXNlIHZlbmRvciBwcmVmaXggbGlrZSBcIk9cIiwgXCJtc1wiLCBcIldlYmtpdFwiLCBvciBcIk1velwiLlxuXG5cdFx0XHQvLyBAcHJpdmF0ZSBmZWVkIGluIGEgY2FtZWxDYXNlIHByb3BlcnR5IG5hbWUgbGlrZSBcInRyYW5zZm9ybVwiIGFuZCBpdCB3aWxsIGNoZWNrIHRvIHNlZSBpZiBpdCBpcyB2YWxpZCBhcy1pcyBvciBpZiBpdCBuZWVkcyBhIHZlbmRvciBwcmVmaXguIEl0IHJldHVybnMgdGhlIGNvcnJlY3RlZCBjYW1lbENhc2UgcHJvcGVydHkgbmFtZSAoaS5lLiBcIldlYmtpdFRyYW5zZm9ybVwiIG9yIFwiTW96VHJhbnNmb3JtXCIgb3IgXCJ0cmFuc2Zvcm1cIiBvciBudWxsIGlmIG5vIHN1Y2ggcHJvcGVydHkgaXMgZm91bmQsIGxpa2UgaWYgdGhlIGJyb3dzZXIgaXMgSUU4IG9yIGJlZm9yZSwgXCJ0cmFuc2Zvcm1cIiB3b24ndCBiZSBmb3VuZCBhdCBhbGwpXG5cdFx0XHRfY2hlY2tQcm9wUHJlZml4ID0gZnVuY3Rpb24ocCwgZSkge1xuXHRcdFx0XHRlID0gZSB8fCBfdGVtcERpdjtcblx0XHRcdFx0dmFyIHMgPSBlLnN0eWxlLFxuXHRcdFx0XHRcdGEsIGk7XG5cdFx0XHRcdGlmIChzW3BdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwID0gcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHAuc3Vic3RyKDEpO1xuXHRcdFx0XHRhID0gW1wiT1wiLFwiTW96XCIsXCJtc1wiLFwiTXNcIixcIldlYmtpdFwiXTtcblx0XHRcdFx0aSA9IDU7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSAmJiBzW2FbaV0rcF0gPT09IHVuZGVmaW5lZCkgeyB9XG5cdFx0XHRcdGlmIChpID49IDApIHtcblx0XHRcdFx0XHRfcHJlZml4ID0gKGkgPT09IDMpID8gXCJtc1wiIDogYVtpXTtcblx0XHRcdFx0XHRfcHJlZml4Q1NTID0gXCItXCIgKyBfcHJlZml4LnRvTG93ZXJDYXNlKCkgKyBcIi1cIjtcblx0XHRcdFx0XHRyZXR1cm4gX3ByZWZpeCArIHA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZ2V0Q29tcHV0ZWRTdHlsZSA9IF9kb2MuZGVmYXVsdFZpZXcgPyBfZG9jLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUgOiBmdW5jdGlvbigpIHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFJldHVybnMgdGhlIGNzcyBzdHlsZSBmb3IgYSBwYXJ0aWN1bGFyIHByb3BlcnR5IG9mIGFuIGVsZW1lbnQuIEZvciBleGFtcGxlLCB0byBnZXQgd2hhdGV2ZXIgdGhlIGN1cnJlbnQgXCJsZWZ0XCIgY3NzIHZhbHVlIGZvciBhbiBlbGVtZW50IHdpdGggYW4gSUQgb2YgXCJteUVsZW1lbnRcIiwgeW91IGNvdWxkIGRvOlxuXHRcdFx0ICogdmFyIGN1cnJlbnRMZWZ0ID0gQ1NTUGx1Z2luLmdldFN0eWxlKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15RWxlbWVudFwiKSwgXCJsZWZ0XCIpO1xuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudCB3aG9zZSBzdHlsZSBwcm9wZXJ0eSB5b3Ugd2FudCB0byBxdWVyeVxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKGxpa2UgXCJsZWZ0XCIgb3IgXCJ0b3BcIiBvciBcIm1hcmdpblRvcFwiLCBldGMuKVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBDb21wdXRlZCBzdHlsZSBvYmplY3QuIFRoaXMganVzdCBwcm92aWRlcyBhIHdheSB0byBzcGVlZCBwcm9jZXNzaW5nIGlmIHlvdSdyZSBnb2luZyB0byBnZXQgc2V2ZXJhbCBwcm9wZXJ0aWVzIG9uIHRoZSBzYW1lIGVsZW1lbnQgaW4gcXVpY2sgc3VjY2Vzc2lvbiAtIHlvdSBjYW4gcmV1c2UgdGhlIHJlc3VsdCBvZiB0aGUgZ2V0Q29tcHV0ZWRTdHlsZSgpIGNhbGwuXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBjYWxjIElmIHRydWUsIHRoZSB2YWx1ZSB3aWxsIG5vdCBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGVsZW1lbnQncyBcInN0eWxlXCIgcHJvcGVydHkgKGlmIGl0IGV4aXN0cyB0aGVyZSksIGJ1dCBpbnN0ZWFkIHRoZSBnZXRDb21wdXRlZFN0eWxlKCkgcmVzdWx0IHdpbGwgYmUgdXNlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgdGhlIGJyb3dzZXIgaXRzZWxmIGlzIGludGVycHJldGluZyB0aGUgdmFsdWUuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IGRmbHQgRGVmYXVsdCB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZXR1cm5lZCBpbiB0aGUgcGxhY2Ugb2YgbnVsbCwgXCJub25lXCIsIFwiYXV0b1wiIG9yIFwiYXV0byBhdXRvXCIuXG5cdFx0XHQgKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgY3VycmVudCBwcm9wZXJ0eSB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0U3R5bGUgPSBDU1NQbHVnaW4uZ2V0U3R5bGUgPSBmdW5jdGlvbih0LCBwLCBjcywgY2FsYywgZGZsdCkge1xuXHRcdFx0XHR2YXIgcnY7XG5cdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkgaWYgKHAgPT09IFwib3BhY2l0eVwiKSB7IC8vc2V2ZXJhbCB2ZXJzaW9ucyBvZiBJRSBkb24ndCB1c2UgdGhlIHN0YW5kYXJkIFwib3BhY2l0eVwiIHByb3BlcnR5IC0gdGhleSB1c2UgdGhpbmdzIGxpa2UgZmlsdGVyOmFscGhhKG9wYWNpdHk9NTApLCBzbyB3ZSBwYXJzZSB0aGF0IGhlcmUuXG5cdFx0XHRcdFx0cmV0dXJuIF9nZXRJRU9wYWNpdHkodCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFjYWxjICYmIHQuc3R5bGVbcF0pIHtcblx0XHRcdFx0XHRydiA9IHQuc3R5bGVbcF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGNzID0gY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCkpKSB7XG5cdFx0XHRcdFx0cnYgPSBjc1twXSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHApIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocC5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0LmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0XHRcdHJ2ID0gdC5jdXJyZW50U3R5bGVbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIChkZmx0ICE9IG51bGwgJiYgKCFydiB8fCBydiA9PT0gXCJub25lXCIgfHwgcnYgPT09IFwiYXV0b1wiIHx8IHJ2ID09PSBcImF1dG8gYXV0b1wiKSkgPyBkZmx0IDogcnY7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFBhc3MgdGhlIHRhcmdldCBlbGVtZW50LCB0aGUgcHJvcGVydHkgbmFtZSwgdGhlIG51bWVyaWMgdmFsdWUsIGFuZCB0aGUgc3VmZml4IChsaWtlIFwiJVwiLCBcImVtXCIsIFwicHhcIiwgZXRjLikgYW5kIGl0IHdpbGwgc3BpdCBiYWNrIHRoZSBlcXVpdmFsZW50IHBpeGVsIG51bWJlci5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKGxpa2UgXCJsZWZ0XCIsIFwidG9wXCIsIFwibWFyZ2luTGVmdFwiLCBldGMuKVxuXHRcdFx0ICogQHBhcmFtIHshbnVtYmVyfSB2IFZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHNmeCBTdWZmaXggKGxpa2UgXCJweFwiIG9yIFwiJVwiIG9yIFwiZW1cIilcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlY3Vyc2UgSWYgdHJ1ZSwgdGhlIGNhbGwgaXMgYSByZWN1cnNpdmUgb25lLiBJbiBzb21lIGJyb3dzZXJzIChsaWtlIElFNy84KSwgb2NjYXNpb25hbGx5IHRoZSB2YWx1ZSBpc24ndCBhY2N1cmF0ZWx5IHJlcG9ydGVkIGluaXRpYWxseSwgYnV0IGlmIHdlIHJ1biB0aGUgZnVuY3Rpb24gYWdhaW4gaXQgd2lsbCB0YWtlIGVmZmVjdC5cblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gdmFsdWUgaW4gcGl4ZWxzXG5cdFx0XHQgKi9cblx0XHRcdF9jb252ZXJ0VG9QaXhlbHMgPSBfaW50ZXJuYWxzLmNvbnZlcnRUb1BpeGVscyA9IGZ1bmN0aW9uKHQsIHAsIHYsIHNmeCwgcmVjdXJzZSkge1xuXHRcdFx0XHRpZiAoc2Z4ID09PSBcInB4XCIgfHwgIXNmeCkgeyByZXR1cm4gdjsgfVxuXHRcdFx0XHRpZiAoc2Z4ID09PSBcImF1dG9cIiB8fCAhdikgeyByZXR1cm4gMDsgfVxuXHRcdFx0XHR2YXIgaG9yaXogPSBfaG9yaXpFeHAudGVzdChwKSxcblx0XHRcdFx0XHRub2RlID0gdCxcblx0XHRcdFx0XHRzdHlsZSA9IF90ZW1wRGl2LnN0eWxlLFxuXHRcdFx0XHRcdG5lZyA9ICh2IDwgMCksXG5cdFx0XHRcdFx0cGl4LCBjYWNoZSwgdGltZTtcblx0XHRcdFx0aWYgKG5lZykge1xuXHRcdFx0XHRcdHYgPSAtdjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc2Z4ID09PSBcIiVcIiAmJiBwLmluZGV4T2YoXCJib3JkZXJcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0cGl4ID0gKHYgLyAxMDApICogKGhvcml6ID8gdC5jbGllbnRXaWR0aCA6IHQuY2xpZW50SGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MCBzb2xpZCByZWQ7cG9zaXRpb246XCIgKyBfZ2V0U3R5bGUodCwgXCJwb3NpdGlvblwiKSArIFwiO2xpbmUtaGVpZ2h0OjA7XCI7XG5cdFx0XHRcdFx0aWYgKHNmeCA9PT0gXCIlXCIgfHwgIW5vZGUuYXBwZW5kQ2hpbGQgfHwgc2Z4LmNoYXJBdCgwKSA9PT0gXCJ2XCIgfHwgc2Z4ID09PSBcInJlbVwiKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gdC5wYXJlbnROb2RlIHx8IF9kb2MuYm9keTtcblx0XHRcdFx0XHRcdGNhY2hlID0gbm9kZS5fZ3NDYWNoZTtcblx0XHRcdFx0XHRcdHRpbWUgPSBUd2VlbkxpdGUudGlja2VyLmZyYW1lO1xuXHRcdFx0XHRcdFx0aWYgKGNhY2hlICYmIGhvcml6ICYmIGNhY2hlLnRpbWUgPT09IHRpbWUpIHsgLy9wZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IHdlIHJlY29yZCB0aGUgd2lkdGggb2YgZWxlbWVudHMgYWxvbmcgd2l0aCB0aGUgdGlja2VyIGZyYW1lIHNvIHRoYXQgd2UgY2FuIHF1aWNrbHkgZ2V0IGl0IGFnYWluIG9uIHRoZSBzYW1lIHRpY2sgKHNlZW1zIHJlbGF0aXZlbHkgc2FmZSB0byBhc3N1bWUgaXQgd291bGRuJ3QgY2hhbmdlIG9uIHRoZSBzYW1lIHRpY2spXG5cdFx0XHRcdFx0XHRcdHJldHVybiBjYWNoZS53aWR0aCAqIHYgLyAxMDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzdHlsZVsoaG9yaXogPyBcIndpZHRoXCIgOiBcImhlaWdodFwiKV0gPSB2ICsgc2Z4O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZVsoaG9yaXogPyBcImJvcmRlckxlZnRXaWR0aFwiIDogXCJib3JkZXJUb3BXaWR0aFwiKV0gPSB2ICsgc2Z4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKF90ZW1wRGl2KTtcblx0XHRcdFx0XHRwaXggPSBwYXJzZUZsb2F0KF90ZW1wRGl2Wyhob3JpeiA/IFwib2Zmc2V0V2lkdGhcIiA6IFwib2Zmc2V0SGVpZ2h0XCIpXSk7XG5cdFx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChfdGVtcERpdik7XG5cdFx0XHRcdFx0aWYgKGhvcml6ICYmIHNmeCA9PT0gXCIlXCIgJiYgQ1NTUGx1Z2luLmNhY2hlV2lkdGhzICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0Y2FjaGUgPSBub2RlLl9nc0NhY2hlID0gbm9kZS5fZ3NDYWNoZSB8fCB7fTtcblx0XHRcdFx0XHRcdGNhY2hlLnRpbWUgPSB0aW1lO1xuXHRcdFx0XHRcdFx0Y2FjaGUud2lkdGggPSBwaXggLyB2ICogMTAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGl4ID09PSAwICYmICFyZWN1cnNlKSB7XG5cdFx0XHRcdFx0XHRwaXggPSBfY29udmVydFRvUGl4ZWxzKHQsIHAsIHYsIHNmeCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBuZWcgPyAtcGl4IDogcGl4O1xuXHRcdFx0fSxcblx0XHRcdF9jYWxjdWxhdGVPZmZzZXQgPSBfaW50ZXJuYWxzLmNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uKHQsIHAsIGNzKSB7IC8vZm9yIGZpZ3VyaW5nIG91dCBcInRvcFwiIG9yIFwibGVmdFwiIGluIHB4IHdoZW4gaXQncyBcImF1dG9cIi4gV2UgbmVlZCB0byBmYWN0b3IgaW4gbWFyZ2luIHdpdGggdGhlIG9mZnNldExlZnQvb2Zmc2V0VG9wXG5cdFx0XHRcdGlmIChfZ2V0U3R5bGUodCwgXCJwb3NpdGlvblwiLCBjcykgIT09IFwiYWJzb2x1dGVcIikgeyByZXR1cm4gMDsgfVxuXHRcdFx0XHR2YXIgZGltID0gKChwID09PSBcImxlZnRcIikgPyBcIkxlZnRcIiA6IFwiVG9wXCIpLFxuXHRcdFx0XHRcdHYgPSBfZ2V0U3R5bGUodCwgXCJtYXJnaW5cIiArIGRpbSwgY3MpO1xuXHRcdFx0XHRyZXR1cm4gdFtcIm9mZnNldFwiICsgZGltXSAtIChfY29udmVydFRvUGl4ZWxzKHQsIHAsIHBhcnNlRmxvYXQodiksIHYucmVwbGFjZShfc3VmZml4RXhwLCBcIlwiKSkgfHwgMCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSByZXR1cm5zIGF0IG9iamVjdCBjb250YWluaW5nIEFMTCBvZiB0aGUgc3R5bGUgcHJvcGVydGllcyBpbiBjYW1lbENhc2UgYW5kIHRoZWlyIGFzc29jaWF0ZWQgdmFsdWVzLlxuXHRcdFx0X2dldEFsbFN0eWxlcyA9IGZ1bmN0aW9uKHQsIGNzKSB7XG5cdFx0XHRcdHZhciBzID0ge30sXG5cdFx0XHRcdFx0aSwgdHIsIHA7XG5cdFx0XHRcdGlmICgoY3MgPSBjcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0LCBudWxsKSkpIHtcblx0XHRcdFx0XHRpZiAoKGkgPSBjcy5sZW5ndGgpKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IGNzW2ldO1xuXHRcdFx0XHRcdFx0XHRpZiAocC5pbmRleE9mKFwiLXRyYW5zZm9ybVwiKSA9PT0gLTEgfHwgX3RyYW5zZm9ybVByb3BDU1MgPT09IHApIHsgLy9Tb21lIHdlYmtpdCBicm93c2VycyBkdXBsaWNhdGUgdHJhbnNmb3JtIHZhbHVlcywgb25lIG5vbi1wcmVmaXhlZCBhbmQgb25lIHByZWZpeGVkIChcInRyYW5zZm9ybVwiIGFuZCBcIldlYmtpdFRyYW5zZm9ybVwiKSwgc28gd2UgbXVzdCB3ZWVkIG91dCB0aGUgZXh0cmEgb25lIGhlcmUuXG5cdFx0XHRcdFx0XHRcdFx0c1twLnJlcGxhY2UoX2NhbWVsRXhwLCBfY2FtZWxGdW5jKV0gPSBjcy5nZXRQcm9wZXJ0eVZhbHVlKHApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHsgLy9zb21lIGJyb3dzZXJzIGJlaGF2ZSBkaWZmZXJlbnRseSAtIGNzLmxlbmd0aCBpcyBhbHdheXMgMCwgc28gd2UgbXVzdCBkbyBhIGZvci4uLmluIGxvb3AuXG5cdFx0XHRcdFx0XHRmb3IgKGkgaW4gY3MpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGkuaW5kZXhPZihcIlRyYW5zZm9ybVwiKSA9PT0gLTEgfHwgX3RyYW5zZm9ybVByb3AgPT09IGkpIHsgLy9Tb21lIHdlYmtpdCBicm93c2VycyBkdXBsaWNhdGUgdHJhbnNmb3JtIHZhbHVlcywgb25lIG5vbi1wcmVmaXhlZCBhbmQgb25lIHByZWZpeGVkIChcInRyYW5zZm9ybVwiIGFuZCBcIldlYmtpdFRyYW5zZm9ybVwiKSwgc28gd2UgbXVzdCB3ZWVkIG91dCB0aGUgZXh0cmEgb25lIGhlcmUuXG5cdFx0XHRcdFx0XHRcdFx0c1tpXSA9IGNzW2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKChjcyA9IHQuY3VycmVudFN0eWxlIHx8IHQuc3R5bGUpKSB7XG5cdFx0XHRcdFx0Zm9yIChpIGluIGNzKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGkpID09PSBcInN0cmluZ1wiICYmIHNbaV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRzW2kucmVwbGFjZShfY2FtZWxFeHAsIF9jYW1lbEZ1bmMpXSA9IGNzW2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkpIHtcblx0XHRcdFx0XHRzLm9wYWNpdHkgPSBfZ2V0SUVPcGFjaXR5KHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyID0gX2dldFRyYW5zZm9ybSh0LCBjcywgZmFsc2UpO1xuXHRcdFx0XHRzLnJvdGF0aW9uID0gdHIucm90YXRpb247XG5cdFx0XHRcdHMuc2tld1ggPSB0ci5za2V3WDtcblx0XHRcdFx0cy5zY2FsZVggPSB0ci5zY2FsZVg7XG5cdFx0XHRcdHMuc2NhbGVZID0gdHIuc2NhbGVZO1xuXHRcdFx0XHRzLnggPSB0ci54O1xuXHRcdFx0XHRzLnkgPSB0ci55O1xuXHRcdFx0XHRpZiAoX3N1cHBvcnRzM0QpIHtcblx0XHRcdFx0XHRzLnogPSB0ci56O1xuXHRcdFx0XHRcdHMucm90YXRpb25YID0gdHIucm90YXRpb25YO1xuXHRcdFx0XHRcdHMucm90YXRpb25ZID0gdHIucm90YXRpb25ZO1xuXHRcdFx0XHRcdHMuc2NhbGVaID0gdHIuc2NhbGVaO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzLmZpbHRlcnMpIHtcblx0XHRcdFx0XHRkZWxldGUgcy5maWx0ZXJzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgYW5hbHl6ZXMgdHdvIHN0eWxlIG9iamVjdHMgKGFzIHJldHVybmVkIGJ5IF9nZXRBbGxTdHlsZXMoKSkgYW5kIG9ubHkgbG9va3MgZm9yIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlbSB0aGF0IGNvbnRhaW4gdHdlZW5hYmxlIHZhbHVlcyAobGlrZSBhIG51bWJlciBvciBjb2xvcikuIEl0IHJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBcImRpZnNcIiBwcm9wZXJ0eSB3aGljaCByZWZlcnMgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSB0aG9zZSBpc29sYXRlZCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgZm9yIHR3ZWVuaW5nLCBhbmQgYSBcImZpcnN0TVBUXCIgcHJvcGVydHkgd2hpY2ggcmVmZXJzIHRvIHRoZSBmaXJzdCBNaW5pUHJvcFR3ZWVuIGluc3RhbmNlIGluIGEgbGlua2VkIGxpc3QgdGhhdCByZWNvcmRlZCBhbGwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBvZiB0aGUgZGlmZmVyZW50IHByb3BlcnRpZXMgc28gdGhhdCB3ZSBjYW4gcmV2ZXJ0IHRvIHRoZW0gYXQgdGhlIGVuZCBvciBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIC0gd2UgZG9uJ3Qgd2FudCB0aGUgY2FzY2FkaW5nIHRvIGdldCBtZXNzZWQgdXAuIFRoZSBmb3JjZUxvb2t1cCBwYXJhbWV0ZXIgaXMgYW4gb3B0aW9uYWwgZ2VuZXJpYyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGZvcmNlZCBpbnRvIHRoZSByZXN1bHRzIC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNsYXNzTmFtZSB0d2VlbnMgdGhhdCBhcmUgb3ZlcndyaXRpbmcgb3RoZXJzIGJlY2F1c2UgaW1hZ2luZSBhIHNjZW5hcmlvIHdoZXJlIGEgcm9sbG92ZXIvcm9sbG91dCBhZGRzL3JlbW92ZXMgYSBjbGFzcyBhbmQgdGhlIHVzZXIgc3dpcGVzIHRoZSBtb3VzZSBvdmVyIHRoZSB0YXJnZXQgU1VQRVIgZmFzdCwgdGh1cyBub3RoaW5nIGFjdHVhbGx5IGNoYW5nZWQgeWV0IGFuZCB0aGUgc3Vic2VxdWVudCBjb21wYXJpc29uIG9mIHRoZSBwcm9wZXJ0aWVzIHdvdWxkIGluZGljYXRlIHRoZXkgbWF0Y2ggKGVzcGVjaWFsbHkgd2hlbiBweCByb3VuZGluZyBpcyB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24pLCB0aHVzIG5vIHR3ZWVuaW5nIGlzIG5lY2Vzc2FyeSBldmVuIHRob3VnaCBpdCBTSE9VTEQgdHdlZW4gYW5kIHJlbW92ZSB0aG9zZSBwcm9wZXJ0aWVzIGFmdGVyIHRoZSB0d2VlbiAob3RoZXJ3aXNlIHRoZSBpbmxpbmUgc3R5bGVzIHdpbGwgY29udGFtaW5hdGUgdGhpbmdzKS4gU2VlIHRoZSBjbGFzc05hbWUgU3BlY2lhbFByb3AgY29kZSBmb3IgZGV0YWlscy5cblx0XHRcdF9jc3NEaWYgPSBmdW5jdGlvbih0LCBzMSwgczIsIHZhcnMsIGZvcmNlTG9va3VwKSB7XG5cdFx0XHRcdHZhciBkaWZzID0ge30sXG5cdFx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRcdHZhbCwgcCwgbXB0O1xuXHRcdFx0XHRmb3IgKHAgaW4gczIpIHtcblx0XHRcdFx0XHRpZiAocCAhPT0gXCJjc3NUZXh0XCIpIGlmIChwICE9PSBcImxlbmd0aFwiKSBpZiAoaXNOYU4ocCkpIGlmIChzMVtwXSAhPT0gKHZhbCA9IHMyW3BdKSB8fCAoZm9yY2VMb29rdXAgJiYgZm9yY2VMb29rdXBbcF0pKSBpZiAocC5pbmRleE9mKFwiT3JpZ2luXCIpID09PSAtMSkgaWYgKHR5cGVvZih2YWwpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZih2YWwpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRkaWZzW3BdID0gKHZhbCA9PT0gXCJhdXRvXCIgJiYgKHAgPT09IFwibGVmdFwiIHx8IHAgPT09IFwidG9wXCIpKSA/IF9jYWxjdWxhdGVPZmZzZXQodCwgcCkgOiAoKHZhbCA9PT0gXCJcIiB8fCB2YWwgPT09IFwiYXV0b1wiIHx8IHZhbCA9PT0gXCJub25lXCIpICYmIHR5cGVvZihzMVtwXSkgPT09IFwic3RyaW5nXCIgJiYgczFbcF0ucmVwbGFjZShfTmFORXhwLCBcIlwiKSAhPT0gXCJcIikgPyAwIDogdmFsOyAvL2lmIHRoZSBlbmRpbmcgdmFsdWUgaXMgZGVmYXVsdGluZyAoXCJcIiBvciBcImF1dG9cIiksIHdlIGNoZWNrIHRoZSBzdGFydGluZyB2YWx1ZSBhbmQgaWYgaXQgY2FuIGJlIHBhcnNlZCBpbnRvIGEgbnVtYmVyIChhIHN0cmluZyB3aGljaCBjb3VsZCBoYXZlIGEgc3VmZml4IHRvbywgbGlrZSA3MDBweCksIHRoZW4gd2Ugc3dhcCBpbiAwIGZvciBcIlwiIG9yIFwiYXV0b1wiIHNvIHRoYXQgdGhpbmdzIGFjdHVhbGx5IHR3ZWVuLlxuXHRcdFx0XHRcdFx0aWYgKHN0eWxlW3BdICE9PSB1bmRlZmluZWQpIHsgLy9mb3IgY2xhc3NOYW1lIHR3ZWVucywgd2UgbXVzdCByZW1lbWJlciB3aGljaCBwcm9wZXJ0aWVzIGFscmVhZHkgZXhpc3RlZCBpbmxpbmUgLSB0aGUgb25lcyB0aGF0IGRpZG4ndCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHRoZSB0d2VlbiBpc24ndCBpbiBwcm9ncmVzcyBiZWNhdXNlIHRoZXkgd2VyZSBvbmx5IGludHJvZHVjZWQgdG8gZmFjaWxpdGF0ZSB0aGUgdHJhbnNpdGlvbiBiZXR3ZWVuIGNsYXNzZXMuXG5cdFx0XHRcdFx0XHRcdG1wdCA9IG5ldyBNaW5pUHJvcFR3ZWVuKHN0eWxlLCBwLCBzdHlsZVtwXSwgbXB0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhcnMpIHtcblx0XHRcdFx0XHRmb3IgKHAgaW4gdmFycykgeyAvL2NvcHkgcHJvcGVydGllcyAoZXhjZXB0IGNsYXNzTmFtZSlcblx0XHRcdFx0XHRcdGlmIChwICE9PSBcImNsYXNzTmFtZVwiKSB7XG5cdFx0XHRcdFx0XHRcdGRpZnNbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge2RpZnM6ZGlmcywgZmlyc3RNUFQ6bXB0fTtcblx0XHRcdH0sXG5cdFx0XHRfZGltZW5zaW9ucyA9IHt3aWR0aDpbXCJMZWZ0XCIsXCJSaWdodFwiXSwgaGVpZ2h0OltcIlRvcFwiLFwiQm90dG9tXCJdfSxcblx0XHRcdF9tYXJnaW5zID0gW1wibWFyZ2luTGVmdFwiLFwibWFyZ2luUmlnaHRcIixcIm1hcmdpblRvcFwiLFwibWFyZ2luQm90dG9tXCJdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIEdldHMgdGhlIHdpZHRoIG9yIGhlaWdodCBvZiBhbiBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lIChcIndpZHRoXCIgb3IgXCJoZWlnaHRcIilcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gY3MgQ29tcHV0ZWQgc3R5bGUgb2JqZWN0IChpZiBvbmUgZXhpc3RzKS4gSnVzdCBhIHNwZWVkIG9wdGltaXphdGlvbi5cblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gRGltZW5zaW9uIChpbiBwaXhlbHMpXG5cdFx0XHQgKi9cblx0XHRcdF9nZXREaW1lbnNpb24gPSBmdW5jdGlvbih0LCBwLCBjcykge1xuXHRcdFx0XHRpZiAoKHQubm9kZU5hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiKSB7IC8vQ2hyb21lIG5vIGxvbmdlciBzdXBwb3J0cyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgb24gU1ZHIGVsZW1lbnRzLlxuXHRcdFx0XHRcdHJldHVybiAoY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCkpW3BdIHx8IDA7XG5cdFx0XHRcdH0gZWxzZSBpZiAodC5nZXRCQm94ICYmIF9pc1NWRyh0KSkge1xuXHRcdFx0XHRcdHJldHVybiB0LmdldEJCb3goKVtwXSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB2ID0gcGFyc2VGbG9hdCgocCA9PT0gXCJ3aWR0aFwiKSA/IHQub2Zmc2V0V2lkdGggOiB0Lm9mZnNldEhlaWdodCksXG5cdFx0XHRcdFx0YSA9IF9kaW1lbnNpb25zW3BdLFxuXHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0Y3MgPSBjcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0LCBudWxsKTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0diAtPSBwYXJzZUZsb2F0KCBfZ2V0U3R5bGUodCwgXCJwYWRkaW5nXCIgKyBhW2ldLCBjcywgdHJ1ZSkgKSB8fCAwO1xuXHRcdFx0XHRcdHYgLT0gcGFyc2VGbG9hdCggX2dldFN0eWxlKHQsIFwiYm9yZGVyXCIgKyBhW2ldICsgXCJXaWR0aFwiLCBjcywgdHJ1ZSkgKSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgUGFyc2VzIHBvc2l0aW9uLXJlbGF0ZWQgY29tcGxleCBzdHJpbmdzIGxpa2UgXCJ0b3AgbGVmdFwiIG9yIFwiNTBweCAxMHB4XCIgb3IgXCI3MCUgMjAlXCIsIGV0Yy4gd2hpY2ggYXJlIHVzZWQgZm9yIHRoaW5ncyBsaWtlIHRyYW5zZm9ybU9yaWdpbiBvciBiYWNrZ3JvdW5kUG9zaXRpb24uIE9wdGlvbmFsbHkgZGVjb3JhdGVzIGEgc3VwcGxpZWQgb2JqZWN0IChyZWNPYmopIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiBcIm94XCIgKG9mZnNldFgpLCBcIm95XCIgKG9mZnNldFkpLCBcIm94cFwiIChpZiB0cnVlLCBcIm94XCIgaXMgYSBwZXJjZW50YWdlIG5vdCBhIHBpeGVsIHZhbHVlKSwgYW5kIFwib3h5XCIgKGlmIHRydWUsIFwib3lcIiBpcyBhIHBlcmNlbnRhZ2Ugbm90IGEgcGl4ZWwgdmFsdWUpXG5cdFx0XHRfcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uKHYsIHJlY09iaikge1xuXHRcdFx0XHRpZiAodiA9PT0gXCJjb250YWluXCIgfHwgdiA9PT0gXCJhdXRvXCIgfHwgdiA9PT0gXCJhdXRvIGF1dG9cIikge1xuXHRcdFx0XHRcdHJldHVybiB2ICsgXCIgXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYgPT0gbnVsbCB8fCB2ID09PSBcIlwiKSB7IC8vbm90ZTogRmlyZWZveCB1c2VzIFwiYXV0byBhdXRvXCIgYXMgZGVmYXVsdCB3aGVyZWFzIENocm9tZSB1c2VzIFwiYXV0b1wiLlxuXHRcdFx0XHRcdHYgPSBcIjAgMFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBhID0gdi5zcGxpdChcIiBcIiksXG5cdFx0XHRcdFx0eCA9ICh2LmluZGV4T2YoXCJsZWZ0XCIpICE9PSAtMSkgPyBcIjAlXCIgOiAodi5pbmRleE9mKFwicmlnaHRcIikgIT09IC0xKSA/IFwiMTAwJVwiIDogYVswXSxcblx0XHRcdFx0XHR5ID0gKHYuaW5kZXhPZihcInRvcFwiKSAhPT0gLTEpID8gXCIwJVwiIDogKHYuaW5kZXhPZihcImJvdHRvbVwiKSAhPT0gLTEpID8gXCIxMDAlXCIgOiBhWzFdLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGlmIChhLmxlbmd0aCA+IDMgJiYgIXJlY09iaikgeyAvL211bHRpcGxlIHBvc2l0aW9uc1xuXHRcdFx0XHRcdGEgPSB2LnNwbGl0KFwiLCBcIikuam9pbihcIixcIikuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdHYgPSBbXTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0di5wdXNoKF9wYXJzZVBvc2l0aW9uKGFbaV0pKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHYuam9pbihcIixcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHkgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHkgPSAoeCA9PT0gXCJjZW50ZXJcIikgPyBcIjUwJVwiIDogXCIwXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoeSA9PT0gXCJjZW50ZXJcIikge1xuXHRcdFx0XHRcdHkgPSBcIjUwJVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh4ID09PSBcImNlbnRlclwiIHx8IChpc05hTihwYXJzZUZsb2F0KHgpKSAmJiAoeCArIFwiXCIpLmluZGV4T2YoXCI9XCIpID09PSAtMSkpIHsgLy9yZW1lbWJlciwgdGhlIHVzZXIgY291bGQgZmxpcC1mbG9wIHRoZSB2YWx1ZXMgYW5kIHNheSBcImJvdHRvbSBjZW50ZXJcIiBvciBcImNlbnRlciBib3R0b21cIiwgZXRjLiBcImNlbnRlclwiIGlzIGFtYmlndW91cyBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWQgdG8gZGVzY3JpYmUgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCwgaGVuY2UgdGhlIGlzTmFOKCkuIElmIHRoZXJlJ3MgYW4gXCI9XCIgc2lnbiBpbiB0aGUgdmFsdWUsIGl0J3MgcmVsYXRpdmUuXG5cdFx0XHRcdFx0eCA9IFwiNTAlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0diA9IHggKyBcIiBcIiArIHkgKyAoKGEubGVuZ3RoID4gMikgPyBcIiBcIiArIGFbMl0gOiBcIlwiKTtcblx0XHRcdFx0aWYgKHJlY09iaikge1xuXHRcdFx0XHRcdHJlY09iai5veHAgPSAoeC5pbmRleE9mKFwiJVwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdHJlY09iai5veXAgPSAoeS5pbmRleE9mKFwiJVwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdHJlY09iai5veHIgPSAoeC5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0XHRyZWNPYmoub3lyID0gKHkuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0cmVjT2JqLm94ID0gcGFyc2VGbG9hdCh4LnJlcGxhY2UoX05hTkV4cCwgXCJcIikpO1xuXHRcdFx0XHRcdHJlY09iai5veSA9IHBhcnNlRmxvYXQoeS5yZXBsYWNlKF9OYU5FeHAsIFwiXCIpKTtcblx0XHRcdFx0XHRyZWNPYmoudiA9IHY7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlY09iaiB8fCB2O1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBUYWtlcyBhbiBlbmRpbmcgdmFsdWUgKHR5cGljYWxseSBhIHN0cmluZywgYnV0IGNhbiBiZSBhIG51bWJlcikgYW5kIGEgc3RhcnRpbmcgdmFsdWUgYW5kIHJldHVybnMgdGhlIGNoYW5nZSBiZXR3ZWVuIHRoZSB0d28sIGxvb2tpbmcgZm9yIHJlbGF0aXZlIHZhbHVlIGluZGljYXRvcnMgbGlrZSArPSBhbmQgLT0gYW5kIGl0IGFsc28gaWdub3JlcyBzdWZmaXhlcyAoYnV0IG1ha2Ugc3VyZSB0aGUgZW5kaW5nIHZhbHVlIHN0YXJ0cyB3aXRoIGEgbnVtYmVyIG9yICs9Ly09IGFuZCB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZSBpcyBhIE5VTUJFUiEpXG5cdFx0XHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gZSBFbmQgdmFsdWUgd2hpY2ggaXMgdHlwaWNhbGx5IGEgc3RyaW5nLCBidXQgY291bGQgYmUgYSBudW1iZXJcblx0XHRcdCAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBiIEJlZ2lubmluZyB2YWx1ZSB3aGljaCBpcyB0eXBpY2FsbHkgYSBzdHJpbmcgYnV0IGNvdWxkIGJlIGEgbnVtYmVyXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IEFtb3VudCBvZiBjaGFuZ2UgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIChyZWxhdGl2ZSB2YWx1ZXMgdGhhdCBoYXZlIGEgXCIrPVwiIG9yIFwiLT1cIiBhcmUgcmVjb2duaXplZClcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlQ2hhbmdlID0gZnVuY3Rpb24oZSwgYikge1xuXHRcdFx0XHRyZXR1cm4gKHR5cGVvZihlKSA9PT0gXCJzdHJpbmdcIiAmJiBlLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcGFyc2VJbnQoZS5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChlLnN1YnN0cigyKSkgOiAocGFyc2VGbG9hdChlKSAtIHBhcnNlRmxvYXQoYikpIHx8IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFRha2VzIGEgdmFsdWUgYW5kIGEgZGVmYXVsdCBudW1iZXIsIGNoZWNrcyBpZiB0aGUgdmFsdWUgaXMgcmVsYXRpdmUsIG51bGwsIG9yIG51bWVyaWMgYW5kIHNwaXRzIGJhY2sgYSBub3JtYWxpemVkIG51bWJlciBhY2NvcmRpbmdseS4gUHJpbWFyaWx5IHVzZWQgaW4gdGhlIF9wYXJzZVRyYW5zZm9ybSgpIGZ1bmN0aW9uLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHYgVmFsdWUgdG8gYmUgcGFyc2VkXG5cdFx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IGQgRGVmYXVsdCB2YWx1ZSAod2hpY2ggaXMgYWxzbyB1c2VkIGZvciByZWxhdGl2ZSBjYWxjdWxhdGlvbnMgaWYgXCIrPVwiIG9yIFwiLT1cIiBpcyBmb3VuZCBpbiB0aGUgZmlyc3QgcGFyYW1ldGVyKVxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBQYXJzZWQgdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlVmFsID0gZnVuY3Rpb24odiwgZCkge1xuXHRcdFx0XHRyZXR1cm4gKHYgPT0gbnVsbCkgPyBkIDogKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIiAmJiB2LmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdCh2LnN1YnN0cigyKSkgKyBkIDogcGFyc2VGbG9hdCh2KSB8fCAwO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBUcmFuc2xhdGVzIHN0cmluZ3MgbGlrZSBcIjQwZGVnXCIgb3IgXCI0MFwiIG9yIDQwcmFkXCIgb3IgXCIrPTQwZGVnXCIgb3IgXCIyNzBfc2hvcnRcIiBvciBcIi05MF9jd1wiIG9yIFwiKz00NV9jY3dcIiB0byBhIG51bWVyaWMgcmFkaWFuIGFuZ2xlLiBPZiBjb3Vyc2UgYSBzdGFydGluZy9kZWZhdWx0IHZhbHVlIG11c3QgYmUgZmVkIGluIHRvbyBzbyB0aGF0IHJlbGF0aXZlIHZhbHVlcyBjYW4gYmUgY2FsY3VsYXRlZCBwcm9wZXJseS5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2IFZhbHVlIHRvIGJlIHBhcnNlZFxuXHRcdFx0ICogQHBhcmFtIHshbnVtYmVyfSBkIERlZmF1bHQgdmFsdWUgKHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgcmVsYXRpdmUgY2FsY3VsYXRpb25zIGlmIFwiKz1cIiBvciBcIi09XCIgaXMgZm91bmQgaW4gdGhlIGZpcnN0IHBhcmFtZXRlcilcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gcCBwcm9wZXJ0eSBuYW1lIGZvciBkaXJlY3Rpb25hbEVuZCAob3B0aW9uYWwgLSBvbmx5IHVzZWQgd2hlbiB0aGUgcGFyc2VkIHZhbHVlIGlzIGRpcmVjdGlvbmFsIChcIl9zaG9ydFwiLCBcIl9jd1wiLCBvciBcIl9jY3dcIiBzdWZmaXgpLiBXZSBuZWVkIGEgd2F5IHRvIHN0b3JlIHRoZSB1bmNvbXBlbnNhdGVkIHZhbHVlIHNvIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4sIHdlIHNldCBpdCB0byBleGFjdGx5IHdoYXQgd2FzIHJlcXVlc3RlZCB3aXRoIG5vIGRpcmVjdGlvbmFsIGNvbXBlbnNhdGlvbikuIFByb3BlcnR5IG5hbWUgd291bGQgYmUgXCJyb3RhdGlvblwiLCBcInJvdGF0aW9uWFwiLCBvciBcInJvdGF0aW9uWVwiXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGRpcmVjdGlvbmFsRW5kIEFuIG9iamVjdCB0aGF0IHdpbGwgc3RvcmUgdGhlIHJhdyBlbmQgdmFsdWVzIGZvciBkaXJlY3Rpb25hbCBhbmdsZXMgKFwiX3Nob3J0XCIsIFwiX2N3XCIsIG9yIFwiX2Njd1wiIHN1ZmZpeCkuIFdlIG5lZWQgYSB3YXkgdG8gc3RvcmUgdGhlIHVuY29tcGVuc2F0ZWQgdmFsdWUgc28gdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSB0d2Vlbiwgd2Ugc2V0IGl0IHRvIGV4YWN0bHkgd2hhdCB3YXMgcmVxdWVzdGVkIHdpdGggbm8gZGlyZWN0aW9uYWwgY29tcGVuc2F0aW9uLlxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBwYXJzZWQgYW5nbGUgaW4gcmFkaWFuc1xuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VBbmdsZSA9IGZ1bmN0aW9uKHYsIGQsIHAsIGRpcmVjdGlvbmFsRW5kKSB7XG5cdFx0XHRcdHZhciBtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0XHRjYXAsIHNwbGl0LCBkaWYsIHJlc3VsdCwgaXNSZWxhdGl2ZTtcblx0XHRcdFx0aWYgKHYgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gdjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYXAgPSAzNjA7XG5cdFx0XHRcdFx0c3BsaXQgPSB2LnNwbGl0KFwiX1wiKTtcblx0XHRcdFx0XHRpc1JlbGF0aXZlID0gKHYuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0ZGlmID0gKGlzUmVsYXRpdmUgPyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KHNwbGl0WzBdLnN1YnN0cigyKSkgOiBwYXJzZUZsb2F0KHNwbGl0WzBdKSkgKiAoKHYuaW5kZXhPZihcInJhZFwiKSA9PT0gLTEpID8gMSA6IF9SQUQyREVHKSAtIChpc1JlbGF0aXZlID8gMCA6IGQpO1xuXHRcdFx0XHRcdGlmIChzcGxpdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChkaXJlY3Rpb25hbEVuZCkge1xuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25hbEVuZFtwXSA9IGQgKyBkaWY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwic2hvcnRcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IGRpZiAlIGNhcDtcblx0XHRcdFx0XHRcdFx0aWYgKGRpZiAhPT0gZGlmICUgKGNhcCAvIDIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlmID0gKGRpZiA8IDApID8gZGlmICsgY2FwIDogZGlmIC0gY2FwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwiX2N3XCIpICE9PSAtMSAmJiBkaWYgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmICsgY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuaW5kZXhPZihcImNjd1wiKSAhPT0gLTEgJiYgZGlmID4gMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiAtIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgPSBkICsgZGlmO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXN1bHQgPCBtaW4gJiYgcmVzdWx0ID4gLW1pbikge1xuXHRcdFx0XHRcdHJlc3VsdCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sXG5cblx0XHRcdF9jb2xvckxvb2t1cCA9IHthcXVhOlswLDI1NSwyNTVdLFxuXHRcdFx0XHRsaW1lOlswLDI1NSwwXSxcblx0XHRcdFx0c2lsdmVyOlsxOTIsMTkyLDE5Ml0sXG5cdFx0XHRcdGJsYWNrOlswLDAsMF0sXG5cdFx0XHRcdG1hcm9vbjpbMTI4LDAsMF0sXG5cdFx0XHRcdHRlYWw6WzAsMTI4LDEyOF0sXG5cdFx0XHRcdGJsdWU6WzAsMCwyNTVdLFxuXHRcdFx0XHRuYXZ5OlswLDAsMTI4XSxcblx0XHRcdFx0d2hpdGU6WzI1NSwyNTUsMjU1XSxcblx0XHRcdFx0ZnVjaHNpYTpbMjU1LDAsMjU1XSxcblx0XHRcdFx0b2xpdmU6WzEyOCwxMjgsMF0sXG5cdFx0XHRcdHllbGxvdzpbMjU1LDI1NSwwXSxcblx0XHRcdFx0b3JhbmdlOlsyNTUsMTY1LDBdLFxuXHRcdFx0XHRncmF5OlsxMjgsMTI4LDEyOF0sXG5cdFx0XHRcdHB1cnBsZTpbMTI4LDAsMTI4XSxcblx0XHRcdFx0Z3JlZW46WzAsMTI4LDBdLFxuXHRcdFx0XHRyZWQ6WzI1NSwwLDBdLFxuXHRcdFx0XHRwaW5rOlsyNTUsMTkyLDIwM10sXG5cdFx0XHRcdGN5YW46WzAsMjU1LDI1NV0sXG5cdFx0XHRcdHRyYW5zcGFyZW50OlsyNTUsMjU1LDI1NSwwXX0sXG5cblx0XHRcdF9odWUgPSBmdW5jdGlvbihoLCBtMSwgbTIpIHtcblx0XHRcdFx0aCA9IChoIDwgMCkgPyBoICsgMSA6IChoID4gMSkgPyBoIC0gMSA6IGg7XG5cdFx0XHRcdHJldHVybiAoKCgoaCAqIDYgPCAxKSA/IG0xICsgKG0yIC0gbTEpICogaCAqIDYgOiAoaCA8IDAuNSkgPyBtMiA6IChoICogMyA8IDIpID8gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDYgOiBtMSkgKiAyNTUpICsgMC41KSB8IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFBhcnNlcyBhIGNvbG9yIChsaWtlICM5RjAsICNGRjk5MDAsIHJnYigyNTUsNTEsMTUzKSBvciBoc2woMTA4LCA1MCUsIDEwJSkpIGludG8gYW4gYXJyYXkgd2l0aCAzIGVsZW1lbnRzIGZvciByZWQsIGdyZWVuLCBhbmQgYmx1ZSBvciBpZiB0b0hTTCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgaXQgd2lsbCBwb3B1bGF0ZSB0aGUgYXJyYXkgd2l0aCBodWUsIHNhdHVyYXRpb24sIGFuZCBsaWdodG5lc3MgdmFsdWVzLiBJZiBhIHJlbGF0aXZlIHZhbHVlIGlzIGZvdW5kIGluIGFuIGhzbCgpIG9yIGhzbGEoKSBzdHJpbmcsIGl0IHdpbGwgcHJlc2VydmUgdGhvc2UgcmVsYXRpdmUgcHJlZml4ZXMgYW5kIGFsbCB0aGUgdmFsdWVzIGluIHRoZSBhcnJheSB3aWxsIGJlIHN0cmluZ3MgaW5zdGVhZCBvZiBudW1iZXJzIChpbiBhbGwgb3RoZXIgY2FzZXMgaXQgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBudW1iZXJzKS5cblx0XHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpfSB2IFRoZSB2YWx1ZSB0aGUgc2hvdWxkIGJlIHBhcnNlZCB3aGljaCBjb3VsZCBiZSBhIHN0cmluZyBsaWtlICM5RjAgb3IgcmdiKDI1NSwxMDIsNTEpIG9yIHJnYmEoMjU1LDAsMCwwLjUpIG9yIGl0IGNvdWxkIGJlIGEgbnVtYmVyIGxpa2UgMHhGRjAwQ0Mgb3IgZXZlbiBhIG5hbWVkIGNvbG9yIGxpa2UgcmVkLCBibHVlLCBwdXJwbGUsIGV0Yy5cblx0XHRcdCAqIEBwYXJhbSB7KGJvb2xlYW4pfSB0b0hTTCBJZiB0cnVlLCBhbiBoc2woKSBvciBoc2xhKCkgdmFsdWUgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIHJnYigpIG9yIHJnYmEoKVxuXHRcdFx0ICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IEFuIGFycmF5IGNvbnRhaW5pbmcgcmVkLCBncmVlbiwgYW5kIGJsdWUgKGFuZCBvcHRpb25hbGx5IGFscGhhKSBpbiB0aGF0IG9yZGVyLCBvciBpZiB0aGUgdG9IU0wgcGFyYW1ldGVyIHdhcyB0cnVlLCB0aGUgYXJyYXkgd2lsbCBjb250YWluIGh1ZSwgc2F0dXJhdGlvbiBhbmQgbGlnaHRuZXNzIChhbmQgb3B0aW9uYWxseSBhbHBoYSkgaW4gdGhhdCBvcmRlci4gQWx3YXlzIG51bWJlcnMgdW5sZXNzIHRoZXJlJ3MgYSByZWxhdGl2ZSBwcmVmaXggZm91bmQgaW4gYW4gaHNsKCkgb3IgaHNsYSgpIHN0cmluZyBhbmQgdG9IU0wgaXMgdHJ1ZS5cblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlQ29sb3IgPSBDU1NQbHVnaW4ucGFyc2VDb2xvciA9IGZ1bmN0aW9uKHYsIHRvSFNMKSB7XG5cdFx0XHRcdHZhciBhLCByLCBnLCBiLCBoLCBzLCBsLCBtYXgsIG1pbiwgZCwgd2FzSFNMO1xuXHRcdFx0XHRpZiAoIXYpIHtcblx0XHRcdFx0XHRhID0gX2NvbG9yTG9va3VwLmJsYWNrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdGEgPSBbdiA+PiAxNiwgKHYgPj4gOCkgJiAyNTUsIHYgJiAyNTVdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh2LmNoYXJBdCh2Lmxlbmd0aCAtIDEpID09PSBcIixcIikgeyAvL3NvbWV0aW1lcyBhIHRyYWlsaW5nIGNvbW1hIGlzIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY2hvcCBpdCBvZmYgKHR5cGljYWxseSBmcm9tIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzIGxpa2UgYSB0ZXh0U2hhZG93OlwiMnB4IDJweCAycHggYmx1ZSwgNXB4IDVweCA1cHggcmdiKDI1NSwwLDApXCIgLSBpbiB0aGlzIGV4YW1wbGUgXCJibHVlLFwiIGhhcyBhIHRyYWlsaW5nIGNvbW1hLiBXZSBjb3VsZCBzdHJpcCBpdCBvdXQgaW5zaWRlIHBhcnNlQ29tcGxleCgpIGJ1dCB3ZSdkIG5lZWQgdG8gZG8gaXQgdG8gdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBwbHVzIGl0IHdvdWxkbid0IHByb3ZpZGUgcHJvdGVjdGlvbiBmcm9tIG90aGVyIHBvdGVudGlhbCBzY2VuYXJpb3MgbGlrZSBpZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBzaW1pbGFyIHZhbHVlLlxuXHRcdFx0XHRcdFx0diA9IHYuc3Vic3RyKDAsIHYubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChfY29sb3JMb29rdXBbdl0pIHtcblx0XHRcdFx0XHRcdGEgPSBfY29sb3JMb29rdXBbdl07XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcblx0XHRcdFx0XHRcdGlmICh2Lmxlbmd0aCA9PT0gNCkgeyAvL2ZvciBzaG9ydGhhbmQgbGlrZSAjOUYwXG5cdFx0XHRcdFx0XHRcdHIgPSB2LmNoYXJBdCgxKTtcblx0XHRcdFx0XHRcdFx0ZyA9IHYuY2hhckF0KDIpO1xuXHRcdFx0XHRcdFx0XHRiID0gdi5jaGFyQXQoMyk7XG5cdFx0XHRcdFx0XHRcdHYgPSBcIiNcIiArIHIgKyByICsgZyArIGcgKyBiICsgYjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHYgPSBwYXJzZUludCh2LnN1YnN0cigxKSwgMTYpO1xuXHRcdFx0XHRcdFx0YSA9IFt2ID4+IDE2LCAodiA+PiA4KSAmIDI1NSwgdiAmIDI1NV07XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2LnN1YnN0cigwLCAzKSA9PT0gXCJoc2xcIikge1xuXHRcdFx0XHRcdFx0YSA9IHdhc0hTTCA9IHYubWF0Y2goX251bUV4cCk7XG5cdFx0XHRcdFx0XHRpZiAoIXRvSFNMKSB7XG5cdFx0XHRcdFx0XHRcdGggPSAoTnVtYmVyKGFbMF0pICUgMzYwKSAvIDM2MDtcblx0XHRcdFx0XHRcdFx0cyA9IE51bWJlcihhWzFdKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0bCA9IE51bWJlcihhWzJdKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0ZyA9IChsIDw9IDAuNSkgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG5cdFx0XHRcdFx0XHRcdHIgPSBsICogMiAtIGc7XG5cdFx0XHRcdFx0XHRcdGlmIChhLmxlbmd0aCA+IDMpIHtcblx0XHRcdFx0XHRcdFx0XHRhWzNdID0gTnVtYmVyKHZbM10pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGFbMF0gPSBfaHVlKGggKyAxIC8gMywgciwgZyk7XG5cdFx0XHRcdFx0XHRcdGFbMV0gPSBfaHVlKGgsIHIsIGcpO1xuXHRcdFx0XHRcdFx0XHRhWzJdID0gX2h1ZShoIC0gMSAvIDMsIHIsIGcpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2LmluZGV4T2YoXCI9XCIpICE9PSAtMSkgeyAvL2lmIHJlbGF0aXZlIHZhbHVlcyBhcmUgZm91bmQsIGp1c3QgcmV0dXJuIHRoZSByYXcgc3RyaW5ncyB3aXRoIHRoZSByZWxhdGl2ZSBwcmVmaXhlcyBpbiBwbGFjZS5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHYubWF0Y2goX3JlbE51bUV4cCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGEgPSB2Lm1hdGNoKF9udW1FeHApIHx8IF9jb2xvckxvb2t1cC50cmFuc3BhcmVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YVswXSA9IE51bWJlcihhWzBdKTtcblx0XHRcdFx0XHRhWzFdID0gTnVtYmVyKGFbMV0pO1xuXHRcdFx0XHRcdGFbMl0gPSBOdW1iZXIoYVsyXSk7XG5cdFx0XHRcdFx0aWYgKGEubGVuZ3RoID4gMykge1xuXHRcdFx0XHRcdFx0YVszXSA9IE51bWJlcihhWzNdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRvSFNMICYmICF3YXNIU0wpIHtcblx0XHRcdFx0XHRyID0gYVswXSAvIDI1NTtcblx0XHRcdFx0XHRnID0gYVsxXSAvIDI1NTtcblx0XHRcdFx0XHRiID0gYVsyXSAvIDI1NTtcblx0XHRcdFx0XHRtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblx0XHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcblx0XHRcdFx0XHRsID0gKG1heCArIG1pbikgLyAyO1xuXHRcdFx0XHRcdGlmIChtYXggPT09IG1pbikge1xuXHRcdFx0XHRcdFx0aCA9IHMgPSAwO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkID0gbWF4IC0gbWluO1xuXHRcdFx0XHRcdFx0cyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuXHRcdFx0XHRcdFx0aCA9IChtYXggPT09IHIpID8gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCkgOiAobWF4ID09PSBnKSA/IChiIC0gcikgLyBkICsgMiA6IChyIC0gZykgLyBkICsgNDtcblx0XHRcdFx0XHRcdGggKj0gNjA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGFbMF0gPSAoaCArIDAuNSkgfCAwO1xuXHRcdFx0XHRcdGFbMV0gPSAocyAqIDEwMCArIDAuNSkgfCAwO1xuXHRcdFx0XHRcdGFbMl0gPSAobCAqIDEwMCArIDAuNSkgfCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fSxcblx0XHRcdF9mb3JtYXRDb2xvcnMgPSBmdW5jdGlvbihzLCB0b0hTTCkge1xuXHRcdFx0XHR2YXIgY29sb3JzID0gcy5tYXRjaChfY29sb3JFeHApIHx8IFtdLFxuXHRcdFx0XHRcdGNoYXJJbmRleCA9IDAsXG5cdFx0XHRcdFx0cGFyc2VkID0gY29sb3JzLmxlbmd0aCA/IFwiXCIgOiBzLFxuXHRcdFx0XHRcdGksIGNvbG9yLCB0ZW1wO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbaV07XG5cdFx0XHRcdFx0dGVtcCA9IHMuc3Vic3RyKGNoYXJJbmRleCwgcy5pbmRleE9mKGNvbG9yLCBjaGFySW5kZXgpLWNoYXJJbmRleCk7XG5cdFx0XHRcdFx0Y2hhckluZGV4ICs9IHRlbXAubGVuZ3RoICsgY29sb3IubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbG9yID0gX3BhcnNlQ29sb3IoY29sb3IsIHRvSFNMKTtcblx0XHRcdFx0XHRpZiAoY29sb3IubGVuZ3RoID09PSAzKSB7XG5cdFx0XHRcdFx0XHRjb2xvci5wdXNoKDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJzZWQgKz0gdGVtcCArICh0b0hTTCA/IFwiaHNsYShcIiArIGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiJSxcIiArIGNvbG9yWzJdICsgXCIlLFwiICsgY29sb3JbM10gOiBcInJnYmEoXCIgKyBjb2xvci5qb2luKFwiLFwiKSkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcGFyc2VkICsgcy5zdWJzdHIoY2hhckluZGV4KTtcblx0XHRcdH0sXG5cdFx0XHRfY29sb3JFeHAgPSBcIig/OlxcXFxiKD86KD86cmdifHJnYmF8aHNsfGhzbGEpXFxcXCguKz9cXFxcKSl8XFxcXEIjKD86WzAtOWEtZl17M30pezEsMn1cXFxcYlwiOyAvL3dlJ2xsIGR5bmFtaWNhbGx5IGJ1aWxkIHRoaXMgUmVndWxhciBFeHByZXNzaW9uIHRvIGNvbnNlcnZlIGZpbGUgc2l6ZS4gQWZ0ZXIgYnVpbGRpbmcgaXQsIGl0IHdpbGwgYmUgYWJsZSB0byBmaW5kIHJnYigpLCByZ2JhKCksICMgKGhleGFkZWNpbWFsKSwgYW5kIG5hbWVkIGNvbG9yIHZhbHVlcyBsaWtlIHJlZCwgYmx1ZSwgcHVycGxlLCBldGMuXG5cblx0XHRmb3IgKHAgaW4gX2NvbG9yTG9va3VwKSB7XG5cdFx0XHRfY29sb3JFeHAgKz0gXCJ8XCIgKyBwICsgXCJcXFxcYlwiO1xuXHRcdH1cblx0XHRfY29sb3JFeHAgPSBuZXcgUmVnRXhwKF9jb2xvckV4cCtcIilcIiwgXCJnaVwiKTtcblxuXHRcdENTU1BsdWdpbi5jb2xvclN0cmluZ0ZpbHRlciA9IGZ1bmN0aW9uKGEpIHtcblx0XHRcdHZhciBjb21iaW5lZCA9IGFbMF0gKyBhWzFdLFxuXHRcdFx0XHR0b0hTTDtcblx0XHRcdGlmIChfY29sb3JFeHAudGVzdChjb21iaW5lZCkpIHtcblx0XHRcdFx0dG9IU0wgPSAoY29tYmluZWQuaW5kZXhPZihcImhzbChcIikgIT09IC0xIHx8IGNvbWJpbmVkLmluZGV4T2YoXCJoc2xhKFwiKSAhPT0gLTEpO1xuXHRcdFx0XHRhWzBdID0gX2Zvcm1hdENvbG9ycyhhWzBdLCB0b0hTTCk7XG5cdFx0XHRcdGFbMV0gPSBfZm9ybWF0Q29sb3JzKGFbMV0sIHRvSFNMKTtcblx0XHRcdH1cblx0XHRcdF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXHRcdH07XG5cblx0XHRpZiAoIVR3ZWVuTGl0ZS5kZWZhdWx0U3RyaW5nRmlsdGVyKSB7XG5cdFx0XHRUd2VlbkxpdGUuZGVmYXVsdFN0cmluZ0ZpbHRlciA9IENTU1BsdWdpbi5jb2xvclN0cmluZ0ZpbHRlcjtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZSBSZXR1cm5zIGEgZm9ybWF0dGVyIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0YWtpbmcgYSBzdHJpbmcgKG9yIG51bWJlciBpbiBzb21lIGNhc2VzKSBhbmQgcmV0dXJuaW5nIGEgY29uc2lzdGVudGx5IGZvcm1hdHRlZCBvbmUgaW4gdGVybXMgb2YgZGVsaW1pdGVycywgcXVhbnRpdHkgb2YgdmFsdWVzLCBldGMuIEZvciBleGFtcGxlLCB3ZSBtYXkgZ2V0IGJveFNoYWRvdyB2YWx1ZXMgZGVmaW5lZCBhcyBcIjBweCByZWRcIiBvciBcIjBweCAwcHggMTBweCByZ2IoMjU1LDAsMClcIiBvciBcIjBweCAwcHggMjBweCAyMHB4ICNGMDBcIiBhbmQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB3aGF0IHdlIGdldCBiYWNrIGlzIGRlc2NyaWJlZCB3aXRoIDQgbnVtYmVycyBhbmQgYSBjb2xvci4gVGhpcyBhbGxvd3MgdXMgdG8gZmVlZCBpdCBpbnRvIHRoZSBfcGFyc2VDb21wbGV4KCkgbWV0aG9kIGFuZCBzcGxpdCB0aGUgdmFsdWVzIHVwIGFwcHJvcHJpYXRlbHkuIFRoZSBuZWF0IHRoaW5nIGFib3V0IHRoaXMgX2dldEZvcm1hdHRlcigpIGZ1bmN0aW9uIGlzIHRoYXQgdGhlIGRmbHQgZGVmaW5lcyBhIHBhdHRlcm4gYXMgd2VsbCBhcyBhIGRlZmF1bHQsIHNvIGZvciBleGFtcGxlLCBfZ2V0Rm9ybWF0dGVyKFwiMHB4IDBweCAwcHggMHB4ICM3NzdcIiwgdHJ1ZSkgbm90IG9ubHkgc2V0cyB0aGUgZGVmYXVsdCBhcyAwcHggZm9yIGFsbCBkaXN0YW5jZXMgYW5kICM3NzcgZm9yIHRoZSBjb2xvciwgYnV0IGFsc28gc2V0cyB0aGUgcGF0dGVybiBzdWNoIHRoYXQgNCBudW1iZXJzIGFuZCBhIGNvbG9yIHdpbGwgYWx3YXlzIGdldCByZXR1cm5lZC5cblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IGRmbHQgVGhlIGRlZmF1bHQgdmFsdWUgYW5kIHBhdHRlcm4gdG8gZm9sbG93LiBTbyBcIjBweCAwcHggMHB4IDBweCAjNzc3XCIgd2lsbCBlbnN1cmUgdGhhdCA0IG51bWJlcnMgYW5kIGEgY29sb3Igd2lsbCBhbHdheXMgZ2V0IHJldHVybmVkLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGNsciBJZiB0cnVlLCB0aGUgdmFsdWVzIHNob3VsZCBiZSBzZWFyY2hlZCBmb3IgY29sb3ItcmVsYXRlZCBkYXRhLiBGb3IgZXhhbXBsZSwgYm94U2hhZG93IHZhbHVlcyB0eXBpY2FsbHkgY29udGFpbiBhIGNvbG9yIHdoZXJlYXMgYm9yZGVyUmFkaXVzIGRvbid0LlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGNvbGxhcHNpYmxlIElmIHRydWUsIHRoZSB2YWx1ZSBpcyBhIHRvcC9sZWZ0L3JpZ2h0L2JvdHRvbSBzdHlsZSBvbmUgdGhhdCBhY3RzIGxpa2UgbWFyZ2luIG9yIHBhZGRpbmcsIHdoZXJlIGlmIG9ubHkgb25lIHZhbHVlIGlzIHJlY2VpdmVkLCBpdCdzIHVzZWQgZm9yIGFsbCA0OyBpZiAyIGFyZSByZWNlaXZlZCwgdGhlIGZpcnN0IGlzIGR1cGxpY2F0ZWQgZm9yIDNyZCAoYm90dG9tKSBhbmQgdGhlIDJuZCBpcyBkdXBsaWNhdGVkIGZvciB0aGUgNHRoIHNwb3QgKGxlZnQpLCBldGMuXG5cdFx0ICogQHJldHVybiB7RnVuY3Rpb259IGZvcm1hdHRlciBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdHZhciBfZ2V0Rm9ybWF0dGVyID0gZnVuY3Rpb24oZGZsdCwgY2xyLCBjb2xsYXBzaWJsZSwgbXVsdGkpIHtcblx0XHRcdFx0aWYgKGRmbHQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbih2KSB7cmV0dXJuIHY7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZENvbG9yID0gY2xyID8gKGRmbHQubWF0Y2goX2NvbG9yRXhwKSB8fCBbXCJcIl0pWzBdIDogXCJcIixcblx0XHRcdFx0XHRkVmFscyA9IGRmbHQuc3BsaXQoZENvbG9yKS5qb2luKFwiXCIpLm1hdGNoKF92YWx1ZXNFeHApIHx8IFtdLFxuXHRcdFx0XHRcdHBmeCA9IGRmbHQuc3Vic3RyKDAsIGRmbHQuaW5kZXhPZihkVmFsc1swXSkpLFxuXHRcdFx0XHRcdHNmeCA9IChkZmx0LmNoYXJBdChkZmx0Lmxlbmd0aCAtIDEpID09PSBcIilcIikgPyBcIilcIiA6IFwiXCIsXG5cdFx0XHRcdFx0ZGVsaW0gPSAoZGZsdC5pbmRleE9mKFwiIFwiKSAhPT0gLTEpID8gXCIgXCIgOiBcIixcIixcblx0XHRcdFx0XHRudW1WYWxzID0gZFZhbHMubGVuZ3RoLFxuXHRcdFx0XHRcdGRTZnggPSAobnVtVmFscyA+IDApID8gZFZhbHNbMF0ucmVwbGFjZShfbnVtRXhwLCBcIlwiKSA6IFwiXCIsXG5cdFx0XHRcdFx0Zm9ybWF0dGVyO1xuXHRcdFx0XHRpZiAoIW51bVZhbHMpIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odikge3JldHVybiB2O307XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNscikge1xuXHRcdFx0XHRcdGZvcm1hdHRlciA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHRcdHZhciBjb2xvciwgdmFscywgaSwgYTtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YodikgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRcdFx0diArPSBkU2Z4O1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChtdWx0aSAmJiBfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QodikpIHtcblx0XHRcdFx0XHRcdFx0YSA9IHYucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGFbaV0gPSBmb3JtYXR0ZXIoYVtpXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGEuam9pbihcIixcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb2xvciA9ICh2Lm1hdGNoKF9jb2xvckV4cCkgfHwgW2RDb2xvcl0pWzBdO1xuXHRcdFx0XHRcdFx0dmFscyA9IHYuc3BsaXQoY29sb3IpLmpvaW4oXCJcIikubWF0Y2goX3ZhbHVlc0V4cCkgfHwgW107XG5cdFx0XHRcdFx0XHRpID0gdmFscy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRpZiAobnVtVmFscyA+IGktLSkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoKytpIDwgbnVtVmFscykge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHNbaV0gPSBjb2xsYXBzaWJsZSA/IHZhbHNbKCgoaSAtIDEpIC8gMikgfCAwKV0gOiBkVmFsc1tpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHBmeCArIHZhbHMuam9pbihkZWxpbSkgKyBkZWxpbSArIGNvbG9yICsgc2Z4ICsgKHYuaW5kZXhPZihcImluc2V0XCIpICE9PSAtMSA/IFwiIGluc2V0XCIgOiBcIlwiKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJldHVybiBmb3JtYXR0ZXI7XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3JtYXR0ZXIgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdFx0dmFyIHZhbHMsIGEsIGk7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0diArPSBkU2Z4O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobXVsdGkgJiYgX2NvbW1hc091dHNpZGVQYXJlbkV4cC50ZXN0KHYpKSB7XG5cdFx0XHRcdFx0XHRhID0gdi5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwifFwiKS5zcGxpdChcInxcIik7XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRhW2ldID0gZm9ybWF0dGVyKGFbaV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGEuam9pbihcIixcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhbHMgPSB2Lm1hdGNoKF92YWx1ZXNFeHApIHx8IFtdO1xuXHRcdFx0XHRcdGkgPSB2YWxzLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAobnVtVmFscyA+IGktLSkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCsraSA8IG51bVZhbHMpIHtcblx0XHRcdFx0XHRcdFx0dmFsc1tpXSA9IGNvbGxhcHNpYmxlID8gdmFsc1soKChpIC0gMSkgLyAyKSB8IDApXSA6IGRWYWxzW2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcGZ4ICsgdmFscy5qb2luKGRlbGltKSArIHNmeDtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIGZvcm1hdHRlcjtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgcmV0dXJucyBhIGZvcm1hdHRlciBmdW5jdGlvbiB0aGF0J3MgdXNlZCBmb3IgZWRnZS1yZWxhdGVkIHZhbHVlcyBsaWtlIG1hcmdpblRvcCwgbWFyZ2luTGVmdCwgcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0LCBldGMuIEp1c3QgcGFzcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIHJlbGF0ZWQgdG8gdGhlIGVkZ2VzLlxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwcm9wcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIGluIG9yZGVyIGZyb20gdG9wIHRvIGxlZnQsIGxpa2UgXCJtYXJnaW5Ub3AsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLG1hcmdpbkxlZnRcIlxuXHRcdFx0ICogQHJldHVybiB7RnVuY3Rpb259IGEgZm9ybWF0dGVyIGZ1bmN0aW9uXG5cdFx0XHQgKi9cblx0XHRcdF9nZXRFZGdlUGFyc2VyID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRcdFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcIixcIik7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRcdFx0dmFyIGEgPSAoZSArIFwiXCIpLnNwbGl0KFwiIFwiKSxcblx0XHRcdFx0XHRcdGk7XG5cdFx0XHRcdFx0dmFycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0XHRcdHZhcnNbcHJvcHNbaV1dID0gYVtpXSA9IGFbaV0gfHwgYVsoKChpIC0gMSkgLyAyKSA+PiAwKV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBjc3NwLnBhcnNlKHQsIHZhcnMsIHB0LCBwbHVnaW4pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgdXNlZCB3aGVuIG90aGVyIHBsdWdpbnMgbXVzdCB0d2VlbiB2YWx1ZXMgZmlyc3QsIGxpa2UgQmV6aWVyUGx1Z2luIG9yIFRocm93UHJvcHNQbHVnaW4sIGV0Yy4gVGhhdCBwbHVnaW4ncyBzZXRSYXRpbygpIGdldHMgY2FsbGVkIGZpcnN0IHNvIHRoYXQgdGhlIHZhbHVlcyBhcmUgdXBkYXRlZCwgYW5kIHRoZW4gd2UgbG9vcCB0aHJvdWdoIHRoZSBNaW5pUHJvcFR3ZWVucyAgd2hpY2ggaGFuZGxlIGNvcHlpbmcgdGhlIHZhbHVlcyBpbnRvIHRoZWlyIGFwcHJvcHJpYXRlIHNsb3RzIHNvIHRoYXQgdGhleSBjYW4gdGhlbiBiZSBhcHBsaWVkIGNvcnJlY3RseSBpbiB0aGUgbWFpbiBDU1NQbHVnaW4gc2V0UmF0aW8oKSBtZXRob2QuIFJlbWVtYmVyLCB3ZSB0eXBpY2FsbHkgY3JlYXRlIGEgcHJveHkgb2JqZWN0IHRoYXQgaGFzIGEgYnVuY2ggb2YgdW5pcXVlbHktbmFtZWQgcHJvcGVydGllcyB0aGF0IHdlIGZlZWQgdG8gdGhlIHN1Yi1wbHVnaW4gYW5kIGl0IGRvZXMgaXRzIG1hZ2ljIG5vcm1hbGx5LCBhbmQgdGhlbiB3ZSBtdXN0IGludGVycHJldCB0aG9zZSB2YWx1ZXMgYW5kIGFwcGx5IHRoZW0gdG8gdGhlIGNzcyBiZWNhdXNlIG9mdGVuIG51bWJlcnMgbXVzdCBnZXQgY29tYmluZWQvY29uY2F0ZW5hdGVkLCBzdWZmaXhlcyBhZGRlZCwgZXRjLiB0byB3b3JrIHdpdGggY3NzLCBsaWtlIGJveFNoYWRvdyBjb3VsZCBoYXZlIDQgdmFsdWVzIHBsdXMgYSBjb2xvci5cblx0XHRcdF9zZXRQbHVnaW5SYXRpbyA9IF9pbnRlcm5hbHMuX3NldFBsdWdpblJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXRSYXRpbyh2KTtcblx0XHRcdFx0dmFyIGQgPSB0aGlzLmRhdGEsXG5cdFx0XHRcdFx0cHJveHkgPSBkLnByb3h5LFxuXHRcdFx0XHRcdG1wdCA9IGQuZmlyc3RNUFQsXG5cdFx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdFx0dmFsLCBwdCwgaSwgc3RyLCBwO1xuXHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0dmFsID0gcHJveHlbbXB0LnZdO1xuXHRcdFx0XHRcdGlmIChtcHQucikge1xuXHRcdFx0XHRcdFx0dmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsIDwgbWluICYmIHZhbCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHZhbCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1wdC50W21wdC5wXSA9IHZhbDtcblx0XHRcdFx0XHRtcHQgPSBtcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGQuYXV0b1JvdGF0ZSkge1xuXHRcdFx0XHRcdGQuYXV0b1JvdGF0ZS5yb3RhdGlvbiA9IHByb3h5LnJvdGF0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vYXQgdGhlIGVuZCwgd2UgbXVzdCBzZXQgdGhlIENTU1Byb3BUd2VlbidzIFwiZVwiIChlbmQpIHZhbHVlIGR5bmFtaWNhbGx5IGhlcmUgYmVjYXVzZSB0aGF0J3Mgd2hhdCBpcyB1c2VkIGluIHRoZSBmaW5hbCBzZXRSYXRpbygpIG1ldGhvZC4gU2FtZSBmb3IgXCJiXCIgYXQgdGhlIGJlZ2lubmluZy5cblx0XHRcdFx0aWYgKHYgPT09IDEgfHwgdiA9PT0gMCkge1xuXHRcdFx0XHRcdG1wdCA9IGQuZmlyc3RNUFQ7XG5cdFx0XHRcdFx0cCA9ICh2ID09PSAxKSA/IFwiZVwiIDogXCJiXCI7XG5cdFx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdFx0cHQgPSBtcHQudDtcblx0XHRcdFx0XHRcdGlmICghcHQudHlwZSkge1xuXHRcdFx0XHRcdFx0XHRwdFtwXSA9IHB0LnMgKyBwdC54czA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0c3RyID0gcHQueHMwICsgcHQucyArIHB0LnhzMTtcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhuXCIraV0gKyBwdFtcInhzXCIrKGkrMSldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHB0W3BdID0gc3RyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBAY29uc3RydWN0b3IgVXNlZCBieSBhIGZldyBTcGVjaWFsUHJvcHMgdG8gaG9sZCBpbXBvcnRhbnQgdmFsdWVzIGZvciBwcm94aWVzLiBGb3IgZXhhbXBsZSwgX3BhcnNlVG9Qcm94eSgpIGNyZWF0ZXMgYSBNaW5pUHJvcFR3ZWVuIGluc3RhbmNlIGZvciBlYWNoIHByb3BlcnR5IHRoYXQgbXVzdCBnZXQgdHdlZW5lZCBvbiB0aGUgcHJveHksIGFuZCB3ZSByZWNvcmQgdGhlIG9yaWdpbmFsIHByb3BlcnR5IG5hbWUgYXMgd2VsbCBhcyB0aGUgdW5pcXVlIG9uZSB3ZSBjcmVhdGUgZm9yIHRoZSBwcm94eSwgcGx1cyB3aGV0aGVyIG9yIG5vdCB0aGUgdmFsdWUgbmVlZHMgdG8gYmUgcm91bmRlZCBwbHVzIHRoZSBvcmlnaW5hbCB2YWx1ZS5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnR5IHdlJ3JlIHR3ZWVuaW5nIChvZnRlbiBhIENTU1Byb3BUd2Vlbilcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBwcm9wZXJ0eSBuYW1lXG5cdFx0XHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nfG9iamVjdCl9IHYgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7TWluaVByb3BUd2Vlbj19IG5leHQgbmV4dCBNaW5pUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gciBpZiB0cnVlLCB0aGUgdHdlZW5lZCB2YWx1ZSBzaG91bGQgYmUgcm91bmRlZCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyXG5cdFx0XHQgKi9cblx0XHRcdE1pbmlQcm9wVHdlZW4gPSBmdW5jdGlvbih0LCBwLCB2LCBuZXh0LCByKSB7XG5cdFx0XHRcdHRoaXMudCA9IHQ7XG5cdFx0XHRcdHRoaXMucCA9IHA7XG5cdFx0XHRcdHRoaXMudiA9IHY7XG5cdFx0XHRcdHRoaXMuciA9IHI7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0bmV4dC5fcHJldiA9IHRoaXM7XG5cdFx0XHRcdFx0dGhpcy5fbmV4dCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgTW9zdCBvdGhlciBwbHVnaW5zIChsaWtlIEJlemllclBsdWdpbiBhbmQgVGhyb3dQcm9wc1BsdWdpbiBhbmQgb3RoZXJzKSBjYW4gb25seSB0d2VlbiBudW1lcmljIHZhbHVlcywgYnV0IENTU1BsdWdpbiBtdXN0IGFjY29tbW9kYXRlIHNwZWNpYWwgdmFsdWVzIHRoYXQgaGF2ZSBhIGJ1bmNoIG9mIGV4dHJhIGRhdGEgKGxpa2UgYSBzdWZmaXggb3Igc3RyaW5ncyBiZXR3ZWVuIG51bWVyaWMgdmFsdWVzLCBldGMuKS4gRm9yIGV4YW1wbGUsIGJveFNoYWRvdyBoYXMgdmFsdWVzIGxpa2UgXCIxMHB4IDEwcHggMjBweCAzMHB4IHJnYigyNTUsMCwwKVwiIHdoaWNoIHdvdWxkIHV0dGVybHkgY29uZnVzZSBvdGhlciBwbHVnaW5zLiBUaGlzIG1ldGhvZCBhbGxvd3MgdXMgdG8gc3BsaXQgdGhhdCBkYXRhIGFwYXJ0IGFuZCBncmFiIG9ubHkgdGhlIG51bWVyaWMgZGF0YSBhbmQgYXR0YWNoIGl0IHRvIHVuaXF1ZWx5LW5hbWVkIHByb3BlcnRpZXMgb2YgYSBnZW5lcmljIHByb3h5IG9iamVjdCAoe30pIHNvIHRoYXQgd2UgY2FuIGZlZWQgdGhhdCB0byB2aXJ0dWFsbHkgYW55IHBsdWdpbiB0byBoYXZlIHRoZSBudW1iZXJzIHR3ZWVuZWQuIEhvd2V2ZXIsIHdlIG11c3QgYWxzbyBrZWVwIHRyYWNrIG9mIHdoaWNoIHByb3BlcnRpZXMgZnJvbSB0aGUgcHJveHkgZ28gd2l0aCB3aGljaCBDU1NQcm9wVHdlZW4gdmFsdWVzIGFuZCBpbnN0YW5jZXMuIFNvIHdlIGNyZWF0ZSBhIGxpbmtlZCBsaXN0IG9mIE1pbmlQcm9wVHdlZW5zLiBFYWNoIG9uZSByZWNvcmRzIGEgdGFyZ2V0ICh0aGUgb3JpZ2luYWwgQ1NTUHJvcFR3ZWVuKSwgcHJvcGVydHkgKGxpa2UgXCJzXCIgb3IgXCJ4bjFcIiBvciBcInhuMlwiKSB0aGF0IHdlJ3JlIHR3ZWVuaW5nIGFuZCB0aGUgdW5pcXVlIHByb3BlcnR5IG5hbWUgdGhhdCB3YXMgdXNlZCBmb3IgdGhlIHByb3h5IChsaWtlIFwiYm94U2hhZG93X3huMVwiIGFuZCBcImJveFNoYWRvd194bjJcIikgYW5kIHdoZXRoZXIgb3Igbm90IHRoZXkgbmVlZCB0byBiZSByb3VuZGVkLiBUaGF0IHdheSwgaW4gdGhlIF9zZXRQbHVnaW5SYXRpbygpIG1ldGhvZCB3ZSBjYW4gc2ltcGx5IGNvcHkgdGhlIHZhbHVlcyBvdmVyIGZyb20gdGhlIHByb3h5IHRvIHRoZSBDU1NQcm9wVHdlZW4gaW5zdGFuY2UocykuIFRoZW4sIHdoZW4gdGhlIG1haW4gQ1NTUGx1Z2luIHNldFJhdGlvKCkgbWV0aG9kIHJ1bnMgYW5kIGFwcGxpZXMgdGhlIENTU1Byb3BUd2VlbiB2YWx1ZXMgYWNjb3JkaW5nbHksIHRoZXkncmUgdXBkYXRlZCBuaWNlbHkuIFNvIHRoZSBleHRlcm5hbCBwbHVnaW4gdHdlZW5zIHRoZSBudW1iZXJzLCBfc2V0UGx1Z2luUmF0aW8oKSBjb3BpZXMgdGhlbSBvdmVyLCBhbmQgc2V0UmF0aW8oKSBhY3RzIG5vcm1hbGx5LCBhcHBseWluZyBjc3Mtc3BlY2lmaWMgdmFsdWVzIHRvIHRoZSBlbGVtZW50LlxuXHRcdFx0ICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHRcdFx0ICogIC0gcHJveHk6IGEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyB0aGUgc3RhcnRpbmcgdmFsdWVzIGZvciBhbGwgdGhlIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHR3ZWVuZWQgYnkgdGhlIGV4dGVybmFsIHBsdWdpbi4gIFRoaXMgaXMgd2hhdCB3ZSBmZWVkIHRvIHRoZSBleHRlcm5hbCBfb25Jbml0VHdlZW4oKSBhcyB0aGUgdGFyZ2V0XG5cdFx0XHQgKiAgLSBlbmQ6IGEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyB0aGUgZW5kaW5nIHZhbHVlcyBmb3IgYWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSB0d2VlbmVkIGJ5IHRoZSBleHRlcm5hbCBwbHVnaW4uIFRoaXMgaXMgd2hhdCB3ZSBmZWVkIHRvIHRoZSBleHRlcm5hbCBwbHVnaW4ncyBfb25Jbml0VHdlZW4oKSBhcyB0aGUgZGVzdGluYXRpb24gdmFsdWVzXG5cdFx0XHQgKiAgLSBmaXJzdE1QVDogdGhlIGZpcnN0IE1pbmlQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0XHQgKiAgLSBwdDogdGhlIGZpcnN0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3QgdGhhdCB3YXMgY3JlYXRlZCB3aGVuIHBhcnNpbmcuIElmIHNoYWxsb3cgaXMgdHJ1ZSwgdGhpcyBsaW5rZWQgbGlzdCB3aWxsIE5PVCBhdHRhY2ggdG8gdGhlIG9uZSBwYXNzZWQgaW50byB0aGUgX3BhcnNlVG9Qcm94eSgpIGFzIHRoZSBcInB0XCIgKDR0aCkgcGFyYW1ldGVyLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBvYmplY3QgdG8gYmUgdHdlZW5lZFxuXHRcdFx0ICogQHBhcmFtIHshKE9iamVjdHxzdHJpbmcpfSB2YXJzIHRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHR3ZWVuaW5nIHZhbHVlcyAodHlwaWNhbGx5IHRoZSBlbmQvZGVzdGluYXRpb24gdmFsdWVzKSB0aGF0IHNob3VsZCBiZSBwYXJzZWRcblx0XHRcdCAqIEBwYXJhbSB7IUNTU1BsdWdpbn0gY3NzcCBUaGUgQ1NTUGx1Z2luIGluc3RhbmNlXG5cdFx0XHQgKiBAcGFyYW0ge0NTU1Byb3BUd2Vlbj19IHB0IHRoZSBuZXh0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHRcdCAqIEBwYXJhbSB7VHdlZW5QbHVnaW49fSBwbHVnaW4gdGhlIGV4dGVybmFsIFR3ZWVuUGx1Z2luIGluc3RhbmNlIHRoYXQgd2lsbCBiZSBoYW5kbGluZyB0d2VlbmluZyB0aGUgbnVtZXJpYyB2YWx1ZXNcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHNoYWxsb3cgaWYgdHJ1ZSwgdGhlIHJlc3VsdGluZyBsaW5rZWQgbGlzdCBmcm9tIHRoZSBwYXJzZSB3aWxsIE5PVCBiZSBhdHRhY2hlZCB0byB0aGUgQ1NTUHJvcFR3ZWVuIHRoYXQgd2FzIHBhc3NlZCBpbiBhcyB0aGUgXCJwdFwiICg0dGgpIHBhcmFtZXRlci5cblx0XHRcdCAqIEByZXR1cm4gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiBwcm94eSwgZW5kLCBmaXJzdE1QVCwgYW5kIHB0IChzZWUgYWJvdmUgZm9yIGRlc2NyaXB0aW9ucylcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlVG9Qcm94eSA9IF9pbnRlcm5hbHMuX3BhcnNlVG9Qcm94eSA9IGZ1bmN0aW9uKHQsIHZhcnMsIGNzc3AsIHB0LCBwbHVnaW4sIHNoYWxsb3cpIHtcblx0XHRcdFx0dmFyIGJwdCA9IHB0LFxuXHRcdFx0XHRcdHN0YXJ0ID0ge30sXG5cdFx0XHRcdFx0ZW5kID0ge30sXG5cdFx0XHRcdFx0dHJhbnNmb3JtID0gY3NzcC5fdHJhbnNmb3JtLFxuXHRcdFx0XHRcdG9sZEZvcmNlID0gX2ZvcmNlUFQsXG5cdFx0XHRcdFx0aSwgcCwgeHAsIG1wdCwgZmlyc3RQVDtcblx0XHRcdFx0Y3NzcC5fdHJhbnNmb3JtID0gbnVsbDtcblx0XHRcdFx0X2ZvcmNlUFQgPSB2YXJzO1xuXHRcdFx0XHRwdCA9IGZpcnN0UFQgPSBjc3NwLnBhcnNlKHQsIHZhcnMsIHB0LCBwbHVnaW4pO1xuXHRcdFx0XHRfZm9yY2VQVCA9IG9sZEZvcmNlO1xuXHRcdFx0XHQvL2JyZWFrIG9mZiBmcm9tIHRoZSBsaW5rZWQgbGlzdCBzbyB0aGUgbmV3IG9uZXMgYXJlIGlzb2xhdGVkLlxuXHRcdFx0XHRpZiAoc2hhbGxvdykge1xuXHRcdFx0XHRcdGNzc3AuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblx0XHRcdFx0XHRpZiAoYnB0KSB7XG5cdFx0XHRcdFx0XHRicHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKGJwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRicHQuX3ByZXYuX25leHQgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAocHQgJiYgcHQgIT09IGJwdCkge1xuXHRcdFx0XHRcdGlmIChwdC50eXBlIDw9IDEpIHtcblx0XHRcdFx0XHRcdHAgPSBwdC5wO1xuXHRcdFx0XHRcdFx0ZW5kW3BdID0gcHQucyArIHB0LmM7XG5cdFx0XHRcdFx0XHRzdGFydFtwXSA9IHB0LnM7XG5cdFx0XHRcdFx0XHRpZiAoIXNoYWxsb3cpIHtcblx0XHRcdFx0XHRcdFx0bXB0ID0gbmV3IE1pbmlQcm9wVHdlZW4ocHQsIFwic1wiLCBwLCBtcHQsIHB0LnIpO1xuXHRcdFx0XHRcdFx0XHRwdC5jID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChwdC50eXBlID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdGkgPSBwdC5sO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHhwID0gXCJ4blwiICsgaTtcblx0XHRcdFx0XHRcdFx0XHRwID0gcHQucCArIFwiX1wiICsgeHA7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kW3BdID0gcHQuZGF0YVt4cF07XG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRbcF0gPSBwdFt4cF07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFzaGFsbG93KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtcHQgPSBuZXcgTWluaVByb3BUd2VlbihwdCwgeHAsIHAsIG1wdCwgcHQucnhwW3hwXSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtwcm94eTpzdGFydCwgZW5kOmVuZCwgZmlyc3RNUFQ6bXB0LCBwdDpmaXJzdFBUfTtcblx0XHRcdH0sXG5cblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBjb25zdHJ1Y3RvciBFYWNoIHByb3BlcnR5IHRoYXQgaXMgdHdlZW5lZCBoYXMgYXQgbGVhc3Qgb25lIENTU1Byb3BUd2VlbiBhc3NvY2lhdGVkIHdpdGggaXQuIFRoZXNlIGluc3RhbmNlcyBzdG9yZSBpbXBvcnRhbnQgaW5mb3JtYXRpb24gbGlrZSB0aGUgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnRpbmcgdmFsdWUsIGFtb3VudCBvZiBjaGFuZ2UsIGV0Yy4gVGhleSBjYW4gYWxzbyBvcHRpb25hbGx5IGhhdmUgYSBudW1iZXIgb2YgXCJleHRyYVwiIHN0cmluZ3MgYW5kIG51bWVyaWMgdmFsdWVzIG5hbWVkIHhzMSwgeG4xLCB4czIsIHhuMiwgeHMzLCB4bjMsIGV0Yy4gd2hlcmUgXCJzXCIgaW5kaWNhdGVzIHN0cmluZyBhbmQgXCJuXCIgaW5kaWNhdGVzIG51bWJlci4gVGhlc2UgY2FuIGJlIHBpZWNlZCB0b2dldGhlciBpbiBhIGNvbXBsZXgtdmFsdWUgdHdlZW4gKHR5cGU6MSkgdGhhdCBoYXMgYWx0ZXJuYXRpbmcgdHlwZXMgb2YgZGF0YSBsaWtlIGEgc3RyaW5nLCBudW1iZXIsIHN0cmluZywgbnVtYmVyLCBldGMuIEZvciBleGFtcGxlLCBib3hTaGFkb3cgY291bGQgYmUgXCI1cHggNXB4IDhweCByZ2IoMTAyLCAxMDIsIDUxKVwiLiBJbiB0aGF0IHZhbHVlLCB0aGVyZSBhcmUgNiBudW1iZXJzIHRoYXQgbWF5IG5lZWQgdG8gdHdlZW4gYW5kIHRoZW4gcGllY2VkIGJhY2sgdG9nZXRoZXIgaW50byBhIHN0cmluZyBhZ2FpbiB3aXRoIHNwYWNlcywgc3VmZml4ZXMsIGV0Yy4geHMwIGlzIHNwZWNpYWwgaW4gdGhhdCBpdCBzdG9yZXMgdGhlIHN1ZmZpeCBmb3Igc3RhbmRhcmQgKHR5cGU6MCkgdHdlZW5zLCAtT1ItIHRoZSBmaXJzdCBzdHJpbmcgKHByZWZpeCkgaW4gYSBjb21wbGV4LXZhbHVlICh0eXBlOjEpIENTU1Byb3BUd2VlbiAtT1ItIGl0IGNhbiBiZSB0aGUgbm9uLXR3ZWVuaW5nIHZhbHVlIGluIGEgdHlwZTotMSBDU1NQcm9wVHdlZW4uIFdlIGRvIHRoaXMgdG8gY29uc2VydmUgbWVtb3J5LlxuXHRcdFx0ICogQ1NTUHJvcFR3ZWVucyBoYXZlIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyBhcyB3ZWxsIChub3QgZGVmaW5lZCB0aHJvdWdoIHRoZSBjb25zdHJ1Y3Rvcik6XG5cdFx0XHQgKiAgLSBsOiBMZW5ndGggaW4gdGVybXMgb2YgdGhlIG51bWJlciBvZiBleHRyYSBwcm9wZXJ0aWVzIHRoYXQgdGhlIENTU1Byb3BUd2VlbiBoYXMgKGRlZmF1bHQ6IDApLiBGb3IgZXhhbXBsZSwgZm9yIGEgYm94U2hhZG93IHdlIG1heSBuZWVkIHRvIHR3ZWVuIDUgbnVtYmVycyBpbiB3aGljaCBjYXNlIGwgd291bGQgYmUgNTsgS2VlcCBpbiBtaW5kIHRoYXQgdGhlIHN0YXJ0L2VuZCB2YWx1ZXMgZm9yIHRoZSBmaXJzdCBudW1iZXIgdGhhdCdzIHR3ZWVuZWQgYXJlIGFsd2F5cyBzdG9yZWQgaW4gdGhlIHMgYW5kIGMgcHJvcGVydGllcyB0byBjb25zZXJ2ZSBtZW1vcnkuIEFsbCBhZGRpdGlvbmFsIHZhbHVlcyB0aGVyZWFmdGVyIGFyZSBzdG9yZWQgaW4geG4xLCB4bjIsIGV0Yy5cblx0XHRcdCAqICAtIHhmaXJzdDogVGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBzdWItQ1NTUHJvcFR3ZWVucyB0aGF0IGFyZSB0d2VlbmluZyBwcm9wZXJ0aWVzIG9mIHRoaXMgaW5zdGFuY2UuIEZvciBleGFtcGxlLCB3ZSBtYXkgc3BsaXQgdXAgYSBib3hTaGFkb3cgdHdlZW4gc28gdGhhdCB0aGVyZSdzIGEgbWFpbiBDU1NQcm9wVHdlZW4gb2YgdHlwZToxIHRoYXQgaGFzIHZhcmlvdXMgeHMqIGFuZCB4biogdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgaC1zaGFkb3csIHYtc2hhZG93LCBibHVyLCBjb2xvciwgZXRjLiBUaGVuIHdlIHNwYXduIGEgQ1NTUHJvcFR3ZWVuIGZvciBlYWNoIG9mIHRob3NlIHRoYXQgaGFzIGEgaGlnaGVyIHByaW9yaXR5IGFuZCBydW5zIEJFRk9SRSB0aGUgbWFpbiBDU1NQcm9wVHdlZW4gc28gdGhhdCB0aGUgdmFsdWVzIGFyZSBhbGwgc2V0IGJ5IHRoZSB0aW1lIGl0IG5lZWRzIHRvIHJlLWFzc2VtYmxlIHRoZW0uIFRoZSB4Zmlyc3QgZ2l2ZXMgdXMgYW4gZWFzeSB3YXkgdG8gaWRlbnRpZnkgdGhlIGZpcnN0IG9uZSBpbiB0aGF0IGNoYWluIHdoaWNoIHR5cGljYWxseSBlbmRzIGF0IHRoZSBtYWluIG9uZSAoYmVjYXVzZSB0aGV5J3JlIGFsbCBwcmVwZW5kZSB0byB0aGUgbGlua2VkIGxpc3QpXG5cdFx0XHQgKiAgLSBwbHVnaW46IFRoZSBUd2VlblBsdWdpbiBpbnN0YW5jZSB0aGF0IHdpbGwgaGFuZGxlIHRoZSB0d2VlbmluZyBvZiBhbnkgY29tcGxleCB2YWx1ZXMuIEZvciBleGFtcGxlLCBzb21ldGltZXMgd2UgZG9uJ3Qgd2FudCB0byB1c2Ugbm9ybWFsIHN1YnR3ZWVucyAobGlrZSB4Zmlyc3QgcmVmZXJzIHRvKSB0byB0d2VlbiB0aGUgdmFsdWVzIC0gd2UgbWlnaHQgd2FudCBUaHJvd1Byb3BzUGx1Z2luIG9yIEJlemllclBsdWdpbiBzb21lIG90aGVyIHBsdWdpbiB0byBkbyB0aGUgYWN0dWFsIHR3ZWVuaW5nLCBzbyB3ZSBjcmVhdGUgYSBwbHVnaW4gaW5zdGFuY2UgYW5kIHN0b3JlIGEgcmVmZXJlbmNlIGhlcmUuIFdlIG5lZWQgdGhpcyByZWZlcmVuY2Ugc28gdGhhdCBpZiB3ZSBnZXQgYSByZXF1ZXN0IHRvIHJvdW5kIHZhbHVlcyBvciBkaXNhYmxlIGEgdHdlZW4sIHdlIGNhbiBwYXNzIGFsb25nIHRoYXQgcmVxdWVzdC5cblx0XHRcdCAqICAtIGRhdGE6IEFyYml0cmFyeSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgc3RvcmVkIHdpdGggdGhlIENTU1Byb3BUd2Vlbi4gVHlwaWNhbGx5IGlmIHdlJ3JlIGdvaW5nIHRvIGhhdmUgYSBwbHVnaW4gaGFuZGxlIHRoZSB0d2VlbmluZyBvZiBhIGNvbXBsZXgtdmFsdWUgdHdlZW4sIHdlIGNyZWF0ZSBhIGdlbmVyaWMgb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBFTkQgdmFsdWVzIHRoYXQgd2UncmUgdHdlZW5pbmcgdG8gYW5kIHRoZSBDU1NQcm9wVHdlZW4ncyB4czEsIHhzMiwgZXRjLiBoYXZlIHRoZSBzdGFydGluZyB2YWx1ZXMuIFdlIHN0b3JlIHRoYXQgb2JqZWN0IGFzIGRhdGEuIFRoYXQgd2F5LCB3ZSBjYW4gc2ltcGx5IHBhc3MgdGhhdCBvYmplY3QgdG8gdGhlIHBsdWdpbiBhbmQgdXNlIHRoZSBDU1NQcm9wVHdlZW4gYXMgdGhlIHRhcmdldC5cblx0XHRcdCAqICAtIHNldFJhdGlvOiBPbmx5IHVzZWQgZm9yIHR5cGU6MiB0d2VlbnMgdGhhdCByZXF1aXJlIGN1c3RvbSBmdW5jdGlvbmFsaXR5LiBJbiB0aGlzIGNhc2UsIHdlIGNhbGwgdGhlIENTU1Byb3BUd2VlbidzIHNldFJhdGlvKCkgbWV0aG9kIGFuZCBwYXNzIHRoZSByYXRpbyBlYWNoIHRpbWUgdGhlIHR3ZWVuIHVwZGF0ZXMuIFRoaXMgaXNuJ3QgcXVpdGUgYXMgZWZmaWNpZW50IGFzIGRvaW5nIHRoaW5ncyBkaXJlY3RseSBpbiB0aGUgQ1NTUGx1Z2luJ3Mgc2V0UmF0aW8oKSBtZXRob2QsIGJ1dCBpdCdzIHZlcnkgY29udmVuaWVudCBhbmQgZmxleGlibGUuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSB3aWxsIGJlIHR3ZWVuZWQuIE9mdGVuIGEgRE9NIGVsZW1lbnQsIGJ1dCBub3QgYWx3YXlzLiBJdCBjb3VsZCBiZSBhbnl0aGluZy5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwIFByb3BlcnR5IHRvIHR3ZWVuIChuYW1lKS4gRm9yIGV4YW1wbGUsIHRvIHR3ZWVuIGVsZW1lbnQud2lkdGgsIHAgd291bGQgYmUgXCJ3aWR0aFwiLlxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXJ9IHMgU3RhcnRpbmcgbnVtZXJpYyB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXJ9IGMgQ2hhbmdlIGluIG51bWVyaWMgdmFsdWUgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBlbnRpcmUgdHdlZW4uIEZvciBleGFtcGxlLCBpZiBlbGVtZW50LndpZHRoIHN0YXJ0cyBhdCA1IGFuZCBzaG91bGQgZW5kIGF0IDEwMCwgYyB3b3VsZCBiZSA5NS5cblx0XHRcdCAqIEBwYXJhbSB7Q1NTUHJvcFR3ZWVuPX0gbmV4dCBUaGUgbmV4dCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0LiBJZiBvbmUgaXMgZGVmaW5lZCwgd2Ugd2lsbCBkZWZpbmUgaXRzIF9wcmV2IGFzIHRoZSBuZXcgaW5zdGFuY2UsIGFuZCB0aGUgbmV3IGluc3RhbmNlJ3MgX25leHQgd2lsbCBiZSBwb2ludGVkIGF0IGl0LlxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXI9fSB0eXBlIFRoZSB0eXBlIG9mIENTU1Byb3BUd2VlbiB3aGVyZSAtMSA9IGEgbm9uLXR3ZWVuaW5nIHZhbHVlLCAwID0gYSBzdGFuZGFyZCBzaW1wbGUgdHdlZW4sIDEgPSBhIGNvbXBsZXggdmFsdWUgKGxpa2Ugb25lIHRoYXQgaGFzIG11bHRpcGxlIG51bWJlcnMgaW4gYSBjb21tYS0gb3Igc3BhY2UtZGVsaW1pdGVkIHN0cmluZyBsaWtlIGJvcmRlcjpcIjFweCBzb2xpZCByZWRcIiksIGFuZCAyID0gb25lIHRoYXQgdXNlcyBhIGN1c3RvbSBzZXRSYXRpbyBmdW5jdGlvbiB0aGF0IGRvZXMgYWxsIG9mIHRoZSB3b3JrIG9mIGFwcGx5aW5nIHRoZSB2YWx1ZXMgb24gZWFjaCB1cGRhdGUuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IG4gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3Igb3ZlcndyaXRpbmcgcHVycG9zZXMgd2hpY2ggaXMgdHlwaWNhbGx5IHRoZSBzYW1lIGFzIHAgYnV0IG5vdCBhbHdheXMuIEZvciBleGFtcGxlLCB3ZSBtYXkgbmVlZCB0byBjcmVhdGUgYSBzdWJ0d2VlbiBmb3IgdGhlIDJuZCBwYXJ0IG9mIGEgXCJjbGlwOnJlY3QoLi4uKVwiIHR3ZWVuIGluIHdoaWNoIGNhc2UgXCJwXCIgbWlnaHQgYmUgeHMxIGJ1dCBcIm5cIiBpcyBzdGlsbCBcImNsaXBcIlxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gciBJZiB0cnVlLCB0aGUgdmFsdWUocykgc2hvdWxkIGJlIHJvdW5kZWRcblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gcHIgUHJpb3JpdHkgaW4gdGhlIGxpbmtlZCBsaXN0IG9yZGVyLiBIaWdoZXIgcHJpb3JpdHkgQ1NTUHJvcFR3ZWVucyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuIFRoZSBkZWZhdWx0IHByaW9yaXR5IGlzIDAuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IGIgQmVnaW5uaW5nIHZhbHVlLiBXZSBzdG9yZSB0aGlzIHRvIGVuc3VyZSB0aGF0IGl0IGlzIEVYQUNUTFkgd2hhdCBpdCB3YXMgd2hlbiB0aGUgdHdlZW4gYmVnYW4gd2l0aG91dCBhbnkgcmlzayBvZiBpbnRlcnByZXRhdGlvbiBpc3N1ZXMuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IGUgRW5kaW5nIHZhbHVlLiBXZSBzdG9yZSB0aGlzIHRvIGVuc3VyZSB0aGF0IGl0IGlzIEVYQUNUTFkgd2hhdCB0aGUgdXNlciBkZWZpbmVkIGF0IHRoZSBlbmQgb2YgdGhlIHR3ZWVuIHdpdGhvdXQgYW55IHJpc2sgb2YgaW50ZXJwcmV0YXRpb24gaXNzdWVzLlxuXHRcdFx0ICovXG5cdFx0XHRDU1NQcm9wVHdlZW4gPSBfaW50ZXJuYWxzLkNTU1Byb3BUd2VlbiA9IGZ1bmN0aW9uKHQsIHAsIHMsIGMsIG5leHQsIHR5cGUsIG4sIHIsIHByLCBiLCBlKSB7XG5cdFx0XHRcdHRoaXMudCA9IHQ7IC8vdGFyZ2V0XG5cdFx0XHRcdHRoaXMucCA9IHA7IC8vcHJvcGVydHlcblx0XHRcdFx0dGhpcy5zID0gczsgLy9zdGFydGluZyB2YWx1ZVxuXHRcdFx0XHR0aGlzLmMgPSBjOyAvL2NoYW5nZSB2YWx1ZVxuXHRcdFx0XHR0aGlzLm4gPSBuIHx8IHA7IC8vbmFtZSB0aGF0IHRoaXMgQ1NTUHJvcFR3ZWVuIHNob3VsZCBiZSBhc3NvY2lhdGVkIHRvICh1c3VhbGx5IHRoZSBzYW1lIGFzIHAsIGJ1dCBub3QgYWx3YXlzIC0gbiBpcyB3aGF0IG92ZXJ3cml0aW5nIGxvb2tzIGF0KVxuXHRcdFx0XHRpZiAoISh0IGluc3RhbmNlb2YgQ1NTUHJvcFR3ZWVuKSkge1xuXHRcdFx0XHRcdF9vdmVyd3JpdGVQcm9wcy5wdXNoKHRoaXMubik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yID0gcjsgLy9yb3VuZCAoYm9vbGVhbilcblx0XHRcdFx0dGhpcy50eXBlID0gdHlwZSB8fCAwOyAvLzAgPSBub3JtYWwgdHdlZW4sIC0xID0gbm9uLXR3ZWVuaW5nIChpbiB3aGljaCBjYXNlIHhzMCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHRhcmdldCdzIHByb3BlcnR5LCBsaWtlIHRwLnRbdHAucF0gPSB0cC54czApLCAxID0gY29tcGxleC12YWx1ZSBTcGVjaWFsUHJvcCwgMiA9IGN1c3RvbSBzZXRSYXRpbygpIHRoYXQgZG9lcyBhbGwgdGhlIHdvcmtcblx0XHRcdFx0aWYgKHByKSB7XG5cdFx0XHRcdFx0dGhpcy5wciA9IHByO1xuXHRcdFx0XHRcdF9oYXNQcmlvcml0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5iID0gKGIgPT09IHVuZGVmaW5lZCkgPyBzIDogYjtcblx0XHRcdFx0dGhpcy5lID0gKGUgPT09IHVuZGVmaW5lZCkgPyBzICsgYyA6IGU7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0dGhpcy5fbmV4dCA9IG5leHQ7XG5cdFx0XHRcdFx0bmV4dC5fcHJldiA9IHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9hZGROb25Ud2VlbmluZ051bWVyaWNQVCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgbmV4dCwgb3ZlcndyaXRlUHJvcCkgeyAvL2NsZWFucyB1cCBzb21lIGNvZGUgcmVkdW5kYW5jaWVzIGFuZCBoZWxwcyBtaW5pZmljYXRpb24uIEp1c3QgYSBmYXN0IHdheSB0byBhZGQgYSBOVU1FUklDIG5vbi10d2VlbmluZyBDU1NQcm9wVHdlZW5cblx0XHRcdFx0dmFyIHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQgLSBzdGFydCwgbmV4dCwgLTEsIG92ZXJ3cml0ZVByb3ApO1xuXHRcdFx0XHRwdC5iID0gc3RhcnQ7XG5cdFx0XHRcdHB0LmUgPSBwdC54czAgPSBlbmQ7XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGFrZXMgYSB0YXJnZXQsIHRoZSBiZWdpbm5pbmcgdmFsdWUgYW5kIGVuZGluZyB2YWx1ZSAoYXMgc3RyaW5ncykgYW5kIHBhcnNlcyB0aGVtIGludG8gYSBDU1NQcm9wVHdlZW4gKHBvc3NpYmx5IHdpdGggY2hpbGQgQ1NTUHJvcFR3ZWVucykgdGhhdCBhY2NvbW1vZGF0ZXMgbXVsdGlwbGUgbnVtYmVycywgY29sb3JzLCBjb21tYS1kZWxpbWl0ZWQgdmFsdWVzLCBldGMuIEZvciBleGFtcGxlOlxuXHRcdFx0ICogc3AucGFyc2VDb21wbGV4KGVsZW1lbnQsIFwiYm94U2hhZG93XCIsIFwiNXB4IDEwcHggMjBweCByZ2IoMjU1LDEwMiw1MSlcIiwgXCIwcHggMHB4IDBweCByZWRcIiwgdHJ1ZSwgXCIwcHggMHB4IDBweCByZ2IoMCwwLDAsMClcIiwgcHQpO1xuXHRcdFx0ICogSXQgd2lsbCB3YWxrIHRocm91Z2ggdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyAod2hpY2ggc2hvdWxkIGJlIGluIHRoZSBzYW1lIGZvcm1hdCB3aXRoIHRoZSBzYW1lIG51bWJlciBhbmQgdHlwZSBvZiB2YWx1ZXMpIGFuZCBmaWd1cmUgb3V0IHdoaWNoIHBhcnRzIGFyZSBudW1iZXJzLCB3aGF0IHN0cmluZ3Mgc2VwYXJhdGUgdGhlIG51bWVyaWMvdHdlZW5hYmxlIHZhbHVlcywgYW5kIHRoZW4gY3JlYXRlIHRoZSBDU1NQcm9wVHdlZW5zIGFjY29yZGluZ2x5LiBJZiBhIHBsdWdpbiBpcyBkZWZpbmVkLCBubyBjaGlsZCBDU1NQcm9wVHdlZW5zIHdpbGwgYmUgY3JlYXRlZC4gSW5zdGVhZCwgdGhlIGVuZGluZyB2YWx1ZXMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIFwiZGF0YVwiIHByb3BlcnR5IG9mIHRoZSByZXR1cm5lZCBDU1NQcm9wVHdlZW4gbGlrZToge3M6LTUsIHhuMTotMTAsIHhuMjotMjAsIHhuMzoyNTUsIHhuNDowLCB4bjU6MH0gc28gdGhhdCBpdCBjYW4gYmUgZmVkIHRvIGFueSBvdGhlciBwbHVnaW4gYW5kIGl0J2xsIGJlIHBsYWluIG51bWVyaWMgdHdlZW5zIGJ1dCB0aGUgcmVjb21wb3NpdGlvbiBvZiB0aGUgY29tcGxleCB2YWx1ZSB3aWxsIGJlIGhhbmRsZWQgaW5zaWRlIENTU1BsdWdpbidzIHNldFJhdGlvKCkuXG5cdFx0XHQgKiBJZiBhIHNldFJhdGlvIGlzIGRlZmluZWQsIHRoZSB0eXBlIG9mIHRoZSBDU1NQcm9wVHdlZW4gd2lsbCBiZSBzZXQgdG8gMiBhbmQgcmVjb21wb3NpdGlvbiBvZiB0aGUgdmFsdWVzIHdpbGwgYmUgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoYXQgbWV0aG9kLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgd2hvc2UgcHJvcGVydHkgd2lsbCBiZSB0d2VlbmVkXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgdGhhdCB3aWxsIGJlIHR3ZWVuZWQgKGl0cyBuYW1lLCBsaWtlIFwibGVmdFwiIG9yIFwiYmFja2dyb3VuZENvbG9yXCIgb3IgXCJib3hTaGFkb3dcIilcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBiIEJlZ2lubmluZyB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGUgRW5kaW5nIHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNscnMgSWYgdHJ1ZSwgdGhlIHZhbHVlIGNvdWxkIGNvbnRhaW4gYSBjb2xvciB2YWx1ZSBsaWtlIFwicmdiKDI1NSwwLDApXCIgb3IgXCIjRjAwXCIgb3IgXCJyZWRcIi4gVGhlIGRlZmF1bHQgaXMgZmFsc2UsIHNvIG5vIGNvbG9ycyB3aWxsIGJlIHJlY29nbml6ZWQgKGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuXHRcdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxPYmplY3QpfSBkZmx0IFRoZSBkZWZhdWx0IGJlZ2lubmluZyB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGlmIG5vIHZhbGlkIGJlZ2lubmluZyB2YWx1ZSBpcyBkZWZpbmVkIG9yIGlmIHRoZSBudW1iZXIgb2YgdmFsdWVzIGluc2lkZSB0aGUgY29tcGxleCBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgZG9uJ3QgbWF0Y2hcblx0XHRcdCAqIEBwYXJhbSB7P0NTU1Byb3BUd2Vlbn0gcHQgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlIHRoYXQgaXMgdGhlIGN1cnJlbnQgaGVhZCBvZiB0aGUgbGlua2VkIGxpc3QgKHdlJ2xsIHByZXBlbmQgdG8gdGhpcykuXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcj19IHByIFByaW9yaXR5IGluIHRoZSBsaW5rZWQgbGlzdCBvcmRlci4gSGlnaGVyIHByaW9yaXR5IHByb3BlcnRpZXMgd2lsbCBiZSB1cGRhdGVkIGJlZm9yZSBsb3dlciBwcmlvcml0eSBvbmVzLiBUaGUgZGVmYXVsdCBwcmlvcml0eSBpcyAwLlxuXHRcdFx0ICogQHBhcmFtIHtUd2VlblBsdWdpbj19IHBsdWdpbiBJZiBhIHBsdWdpbiBzaG91bGQgaGFuZGxlIHRoZSB0d2VlbmluZyBvZiBleHRyYSBwcm9wZXJ0aWVzLCBwYXNzIHRoZSBwbHVnaW4gaW5zdGFuY2UgaGVyZS4gSWYgb25lIGlzIGRlZmluZWQsIHRoZW4gTk8gc3VidHdlZW5zIHdpbGwgYmUgY3JlYXRlZCBmb3IgYW55IGV4dHJhIHByb3BlcnRpZXMgKHRoZSBwcm9wZXJ0aWVzIHdpbGwgYmUgY3JlYXRlZCAtIGp1c3Qgbm90IGFkZGl0aW9uYWwgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlcyB0byB0d2VlbiB0aGVtKSBiZWNhdXNlIHRoZSBwbHVnaW4gaXMgZXhwZWN0ZWQgdG8gZG8gc28uIEhvd2V2ZXIsIHRoZSBlbmQgdmFsdWVzIFdJTEwgYmUgcG9wdWxhdGVkIGluIHRoZSBcImRhdGFcIiBwcm9wZXJ0eSwgbGlrZSB7czoxMDAsIHhuMTo1MCwgeG4yOjMwMH1cblx0XHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKT19IHNldFJhdGlvIElmIHZhbHVlcyBzaG91bGQgYmUgc2V0IGluIGEgY3VzdG9tIGZ1bmN0aW9uIGluc3RlYWQgb2YgYmVpbmcgcGllY2VkIHRvZ2V0aGVyIGluIGEgdHlwZToxIChjb21wbGV4LXZhbHVlKSBDU1NQcm9wVHdlZW4sIGRlZmluZSB0aGF0IGN1c3RvbSBmdW5jdGlvbiBoZXJlLlxuXHRcdFx0ICogQHJldHVybiB7Q1NTUHJvcFR3ZWVufSBUaGUgZmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCB3aGljaCBpbmNsdWRlcyB0aGUgbmV3IG9uZShzKSBhZGRlZCBieSB0aGUgcGFyc2VDb21wbGV4KCkgY2FsbC5cblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlQ29tcGxleCA9IENTU1BsdWdpbi5wYXJzZUNvbXBsZXggPSBmdW5jdGlvbih0LCBwLCBiLCBlLCBjbHJzLCBkZmx0LCBwdCwgcHIsIHBsdWdpbiwgc2V0UmF0aW8pIHtcblx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcInBhcnNlQ29tcGxleDogXCIrcCtcIiwgYjogXCIrYitcIiwgZTogXCIrZSk7XG5cdFx0XHRcdGIgPSBiIHx8IGRmbHQgfHwgXCJcIjtcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAoc2V0UmF0aW8gPyAyIDogMSksIG51bGwsIGZhbHNlLCBwciwgYiwgZSk7XG5cdFx0XHRcdGUgKz0gXCJcIjsgLy9lbnN1cmVzIGl0J3MgYSBzdHJpbmdcblx0XHRcdFx0aWYgKGNscnMgJiYgX2NvbG9yRXhwLnRlc3QoZSArIGIpKSB7IC8vaWYgY29sb3JzIGFyZSBmb3VuZCwgbm9ybWFsaXplIHRoZSBmb3JtYXR0aW5nIHRvIHJnYmEoKSBvciBoc2xhKCkuXG5cdFx0XHRcdFx0ZSA9IFtiLCBlXTtcblx0XHRcdFx0XHRDU1NQbHVnaW4uY29sb3JTdHJpbmdGaWx0ZXIoZSk7XG5cdFx0XHRcdFx0YiA9IGVbMF07XG5cdFx0XHRcdFx0ZSA9IGVbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGJhID0gYi5zcGxpdChcIiwgXCIpLmpvaW4oXCIsXCIpLnNwbGl0KFwiIFwiKSwgLy9iZWdpbm5pbmcgYXJyYXlcblx0XHRcdFx0XHRlYSA9IGUuc3BsaXQoXCIsIFwiKS5qb2luKFwiLFwiKS5zcGxpdChcIiBcIiksIC8vZW5kaW5nIGFycmF5XG5cdFx0XHRcdFx0bCA9IGJhLmxlbmd0aCxcblx0XHRcdFx0XHRhdXRvUm91bmQgPSAoX2F1dG9Sb3VuZCAhPT0gZmFsc2UpLFxuXHRcdFx0XHRcdGksIHhpLCBuaSwgYnYsIGV2LCBibnVtcywgZW51bXMsIGJuLCBoYXNBbHBoYSwgdGVtcCwgY3YsIHN0ciwgdXNlSFNMO1xuXHRcdFx0XHRpZiAoZS5pbmRleE9mKFwiLFwiKSAhPT0gLTEgfHwgYi5pbmRleE9mKFwiLFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRiYSA9IGJhLmpvaW4oXCIgXCIpLnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCIsIFwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0ZWEgPSBlYS5qb2luKFwiIFwiKS5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwiLCBcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGwgPSBiYS5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGwgIT09IGVhLmxlbmd0aCkge1xuXHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJtaXNtYXRjaGVkIGZvcm1hdHRpbmcgZGV0ZWN0ZWQgb24gXCIgKyBwICsgXCIgKFwiICsgYiArIFwiIHZzIFwiICsgZSArIFwiKVwiKTtcblx0XHRcdFx0XHRiYSA9IChkZmx0IHx8IFwiXCIpLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRsID0gYmEubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0cHQuc2V0UmF0aW8gPSBzZXRSYXRpbztcblx0XHRcdFx0X2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRidiA9IGJhW2ldO1xuXHRcdFx0XHRcdGV2ID0gZWFbaV07XG5cdFx0XHRcdFx0Ym4gPSBwYXJzZUZsb2F0KGJ2KTtcblx0XHRcdFx0XHQvL2lmIHRoZSB2YWx1ZSBiZWdpbnMgd2l0aCBhIG51bWJlciAobW9zdCBjb21tb24pLiBJdCdzIGZpbmUgaWYgaXQgaGFzIGEgc3VmZml4IGxpa2UgcHhcblx0XHRcdFx0XHRpZiAoYm4gfHwgYm4gPT09IDApIHtcblx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoXCJcIiwgYm4sIF9wYXJzZUNoYW5nZShldiwgYm4pLCBldi5yZXBsYWNlKF9yZWxOdW1FeHAsIFwiXCIpLCAoYXV0b1JvdW5kICYmIGV2LmluZGV4T2YoXCJweFwiKSAhPT0gLTEpLCB0cnVlKTtcblxuXHRcdFx0XHRcdC8vaWYgdGhlIHZhbHVlIGlzIGEgY29sb3Jcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNscnMgJiYgX2NvbG9yRXhwLnRlc3QoYnYpKSB7XG5cdFx0XHRcdFx0XHRzdHIgPSBldi5pbmRleE9mKFwiKVwiKSArIDE7XG5cdFx0XHRcdFx0XHRzdHIgPSBcIilcIiArIChzdHIgPyBldi5zdWJzdHIoc3RyKSA6IFwiXCIpOyAvL2lmIHRoZXJlJ3MgYSBjb21tYSBvciApIGF0IHRoZSBlbmQsIHJldGFpbiBpdC5cblx0XHRcdFx0XHRcdHVzZUhTTCA9IChldi5pbmRleE9mKFwiaHNsXCIpICE9PSAtMSAmJiBfc3VwcG9ydHNPcGFjaXR5KTtcblx0XHRcdFx0XHRcdGJ2ID0gX3BhcnNlQ29sb3IoYnYsIHVzZUhTTCk7XG5cdFx0XHRcdFx0XHRldiA9IF9wYXJzZUNvbG9yKGV2LCB1c2VIU0wpO1xuXHRcdFx0XHRcdFx0aGFzQWxwaGEgPSAoYnYubGVuZ3RoICsgZXYubGVuZ3RoID4gNik7XG5cdFx0XHRcdFx0XHRpZiAoaGFzQWxwaGEgJiYgIV9zdXBwb3J0c09wYWNpdHkgJiYgZXZbM10gPT09IDApIHsgLy9vbGRlciB2ZXJzaW9ucyBvZiBJRSBkb24ndCBzdXBwb3J0IHJnYmEoKSwgc28gaWYgdGhlIGRlc3RpbmF0aW9uIGFscGhhIGlzIDAsIGp1c3QgdXNlIFwidHJhbnNwYXJlbnRcIiBmb3IgdGhlIGVuZCBjb2xvclxuXHRcdFx0XHRcdFx0XHRwdFtcInhzXCIgKyBwdC5sXSArPSBwdC5sID8gXCIgdHJhbnNwYXJlbnRcIiA6IFwidHJhbnNwYXJlbnRcIjtcblx0XHRcdFx0XHRcdFx0cHQuZSA9IHB0LmUuc3BsaXQoZWFbaV0pLmpvaW4oXCJ0cmFuc3BhcmVudFwiKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkgeyAvL29sZCB2ZXJzaW9ucyBvZiBJRSBkb24ndCBzdXBwb3J0IHJnYmEoKS5cblx0XHRcdFx0XHRcdFx0XHRoYXNBbHBoYSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICh1c2VIU0wpIHtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKChoYXNBbHBoYSA/IFwiaHNsYShcIiA6IFwiaHNsKFwiKSwgYnZbMF0sIF9wYXJzZUNoYW5nZShldlswXSwgYnZbMF0pLCBcIixcIiwgZmFsc2UsIHRydWUpXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kWHRyYShcIlwiLCBidlsxXSwgX3BhcnNlQ2hhbmdlKGV2WzFdLCBidlsxXSksIFwiJSxcIiwgZmFsc2UpXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kWHRyYShcIlwiLCBidlsyXSwgX3BhcnNlQ2hhbmdlKGV2WzJdLCBidlsyXSksIChoYXNBbHBoYSA/IFwiJSxcIiA6IFwiJVwiICsgc3RyKSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoKGhhc0FscGhhID8gXCJyZ2JhKFwiIDogXCJyZ2IoXCIpLCBidlswXSwgZXZbMF0gLSBidlswXSwgXCIsXCIsIHRydWUsIHRydWUpXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kWHRyYShcIlwiLCBidlsxXSwgZXZbMV0gLSBidlsxXSwgXCIsXCIsIHRydWUpXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kWHRyYShcIlwiLCBidlsyXSwgZXZbMl0gLSBidlsyXSwgKGhhc0FscGhhID8gXCIsXCIgOiBzdHIpLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChoYXNBbHBoYSkge1xuXHRcdFx0XHRcdFx0XHRcdGJ2ID0gKGJ2Lmxlbmd0aCA8IDQpID8gMSA6IGJ2WzNdO1xuXHRcdFx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoXCJcIiwgYnYsICgoZXYubGVuZ3RoIDwgNCkgPyAxIDogZXZbM10pIC0gYnYsIHN0ciwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRfY29sb3JFeHAubGFzdEluZGV4ID0gMDsgLy9vdGhlcndpc2UgdGhlIHRlc3QoKSBvbiB0aGUgUmVnRXhwIGNvdWxkIG1vdmUgdGhlIGxhc3RJbmRleCBhbmQgdGFpbnQgZnV0dXJlIHJlc3VsdHMuXG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ym51bXMgPSBidi5tYXRjaChfbnVtRXhwKTsgLy9nZXRzIGVhY2ggZ3JvdXAgb2YgbnVtYmVycyBpbiB0aGUgYmVnaW5uaW5nIHZhbHVlIHN0cmluZyBhbmQgZHJvcHMgdGhlbSBpbnRvIGFuIGFycmF5XG5cblx0XHRcdFx0XHRcdC8vaWYgbm8gbnVtYmVyIGlzIGZvdW5kLCB0cmVhdCBpdCBhcyBhIG5vbi10d2VlbmluZyB2YWx1ZSBhbmQganVzdCBhcHBlbmQgdGhlIHN0cmluZyB0byB0aGUgY3VycmVudCB4cy5cblx0XHRcdFx0XHRcdGlmICghYm51bXMpIHtcblx0XHRcdFx0XHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gKz0gKHB0LmwgfHwgcHRbXCJ4c1wiICsgcHQubF0pID8gXCIgXCIgKyBldiA6IGV2O1xuXG5cdFx0XHRcdFx0XHQvL2xvb3AgdGhyb3VnaCBhbGwgdGhlIG51bWJlcnMgdGhhdCBhcmUgZm91bmQgYW5kIGNvbnN0cnVjdCB0aGUgZXh0cmEgdmFsdWVzIG9uIHRoZSBwdC5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGVudW1zID0gZXYubWF0Y2goX3JlbE51bUV4cCk7IC8vZ2V0IGVhY2ggZ3JvdXAgb2YgbnVtYmVycyBpbiB0aGUgZW5kIHZhbHVlIHN0cmluZyBhbmQgZHJvcCB0aGVtIGludG8gYW4gYXJyYXkuIFdlIGFsbG93IHJlbGF0aXZlIHZhbHVlcyB0b28sIGxpa2UgKz01MCBvciAtPS41XG5cdFx0XHRcdFx0XHRcdGlmICghZW51bXMgfHwgZW51bXMubGVuZ3RoICE9PSBibnVtcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwibWlzbWF0Y2hlZCBmb3JtYXR0aW5nIGRldGVjdGVkIG9uIFwiICsgcCArIFwiIChcIiArIGIgKyBcIiB2cyBcIiArIGUgKyBcIilcIik7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdG5pID0gMDtcblx0XHRcdFx0XHRcdFx0Zm9yICh4aSA9IDA7IHhpIDwgYm51bXMubGVuZ3RoOyB4aSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3YgPSBibnVtc1t4aV07XG5cdFx0XHRcdFx0XHRcdFx0dGVtcCA9IGJ2LmluZGV4T2YoY3YsIG5pKTtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKGJ2LnN1YnN0cihuaSwgdGVtcCAtIG5pKSwgTnVtYmVyKGN2KSwgX3BhcnNlQ2hhbmdlKGVudW1zW3hpXSwgY3YpLCBcIlwiLCAoYXV0b1JvdW5kICYmIGJ2LnN1YnN0cih0ZW1wICsgY3YubGVuZ3RoLCAyKSA9PT0gXCJweFwiKSwgKHhpID09PSAwKSk7XG5cdFx0XHRcdFx0XHRcdFx0bmkgPSB0ZW1wICsgY3YubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHB0W1wieHNcIiArIHB0LmxdICs9IGJ2LnN1YnN0cihuaSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vaWYgdGhlcmUgYXJlIHJlbGF0aXZlIHZhbHVlcyAoXCIrPVwiIG9yIFwiLT1cIiBwcmVmaXgpLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgZW5kaW5nIHZhbHVlIHRvIGVsaW1pbmF0ZSB0aGUgcHJlZml4ZXMgYW5kIGNvbWJpbmUgdGhlIHZhbHVlcyBwcm9wZXJseS5cblx0XHRcdFx0aWYgKGUuaW5kZXhPZihcIj1cIikgIT09IC0xKSBpZiAocHQuZGF0YSkge1xuXHRcdFx0XHRcdHN0ciA9IHB0LnhzMCArIHB0LmRhdGEucztcblx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgcHQubDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRzdHIgKz0gcHRbXCJ4c1wiICsgaV0gKyBwdC5kYXRhW1wieG5cIiArIGldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdC5lID0gc3RyICsgcHRbXCJ4c1wiICsgaV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFwdC5sKSB7XG5cdFx0XHRcdFx0cHQudHlwZSA9IC0xO1xuXHRcdFx0XHRcdHB0LnhzMCA9IHB0LmU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHB0LnhmaXJzdCB8fCBwdDtcblx0XHRcdH0sXG5cdFx0XHRpID0gOTtcblxuXG5cdFx0cCA9IENTU1Byb3BUd2Vlbi5wcm90b3R5cGU7XG5cdFx0cC5sID0gcC5wciA9IDA7IC8vbGVuZ3RoIChudW1iZXIgb2YgZXh0cmEgcHJvcGVydGllcyBsaWtlIHhuMSwgeG4yLCB4bjMsIGV0Yy5cblx0XHR3aGlsZSAoLS1pID4gMCkge1xuXHRcdFx0cFtcInhuXCIgKyBpXSA9IDA7XG5cdFx0XHRwW1wieHNcIiArIGldID0gXCJcIjtcblx0XHR9XG5cdFx0cC54czAgPSBcIlwiO1xuXHRcdHAuX25leHQgPSBwLl9wcmV2ID0gcC54Zmlyc3QgPSBwLmRhdGEgPSBwLnBsdWdpbiA9IHAuc2V0UmF0aW8gPSBwLnJ4cCA9IG51bGw7XG5cblxuXHRcdC8qKlxuXHRcdCAqIEFwcGVuZHMgYW5kIGV4dHJhIHR3ZWVuaW5nIHZhbHVlIHRvIGEgQ1NTUHJvcFR3ZWVuIGFuZCBhdXRvbWF0aWNhbGx5IG1hbmFnZXMgYW55IHByZWZpeCBhbmQgc3VmZml4IHN0cmluZ3MuIFRoZSBmaXJzdCBleHRyYSB2YWx1ZSBpcyBzdG9yZWQgaW4gdGhlIHMgYW5kIGMgb2YgdGhlIG1haW4gQ1NTUHJvcFR3ZWVuIGluc3RhbmNlLCBidXQgdGhlcmVhZnRlciBhbnkgZXh0cmFzIGFyZSBzdG9yZWQgaW4gdGhlIHhuMSwgeG4yLCB4bjMsIGV0Yy4gVGhlIHByZWZpeGVzIGFuZCBzdWZmaXhlcyBhcmUgc3RvcmVkIGluIHRoZSB4czAsIHhzMSwgeHMyLCBldGMuIHByb3BlcnRpZXMuIEZvciBleGFtcGxlLCBpZiBJIHdhbGsgdGhyb3VnaCBhIGNsaXAgdmFsdWUgbGlrZSBcInJlY3QoMTBweCwgNXB4LCAwcHgsIDIwcHgpXCIsIHRoZSB2YWx1ZXMgd291bGQgYmUgc3RvcmVkIGxpa2UgdGhpczpcblx0XHQgKiB4czA6XCJyZWN0KFwiLCBzOjEwLCB4czE6XCJweCwgXCIsIHhuMTo1LCB4czI6XCJweCwgXCIsIHhuMjowLCB4czM6XCJweCwgXCIsIHhuMzoyMCwgeG40OlwicHgpXCJcblx0XHQgKiBBbmQgdGhleSdkIGFsbCBnZXQgam9pbmVkIHRvZ2V0aGVyIHdoZW4gdGhlIENTU1BsdWdpbiByZW5kZXJzIChpbiB0aGUgc2V0UmF0aW8oKSBtZXRob2QpLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gcGZ4IFByZWZpeCAoaWYgYW55KVxuXHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gcyBTdGFydGluZyB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gYyBDaGFuZ2UgaW4gbnVtZXJpYyB2YWx1ZSBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIGVudGlyZSB0d2Vlbi4gRm9yIGV4YW1wbGUsIGlmIHRoZSBzdGFydCBpcyA1IGFuZCB0aGUgZW5kIGlzIDEwMCwgdGhlIGNoYW5nZSB3b3VsZCBiZSA5NS5cblx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHNmeCBTdWZmaXggKGlmIGFueSlcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByIFJvdW5kIChpZiB0cnVlKS5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBwYWQgSWYgdHJ1ZSwgdGhpcyBleHRyYSB2YWx1ZSBzaG91bGQgYmUgc2VwYXJhdGVkIGJ5IHRoZSBwcmV2aW91cyBvbmUgYnkgYSBzcGFjZS4gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgZXh0cmEgYW5kIHBhZCBpcyB0cnVlLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgZHJvcCB0aGUgc3BhY2UuXG5cdFx0ICogQHJldHVybiB7Q1NTUHJvcFR3ZWVufSByZXR1cm5zIGl0c2VsZiBzbyB0aGF0IG11bHRpcGxlIG1ldGhvZHMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuXG5cdFx0ICovXG5cdFx0cC5hcHBlbmRYdHJhID0gZnVuY3Rpb24ocGZ4LCBzLCBjLCBzZngsIHIsIHBhZCkge1xuXHRcdFx0dmFyIHB0ID0gdGhpcyxcblx0XHRcdFx0bCA9IHB0Lmw7XG5cdFx0XHRwdFtcInhzXCIgKyBsXSArPSAocGFkICYmIChsIHx8IHB0W1wieHNcIiArIGxdKSkgPyBcIiBcIiArIHBmeCA6IHBmeCB8fCBcIlwiO1xuXHRcdFx0aWYgKCFjKSBpZiAobCAhPT0gMCAmJiAhcHQucGx1Z2luKSB7IC8vdHlwaWNhbGx5IHdlJ2xsIGNvbWJpbmUgbm9uLWNoYW5naW5nIHZhbHVlcyByaWdodCBpbnRvIHRoZSB4cyB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSwgYnV0IHdlIGRvbid0IGNvbWJpbmUgdGhlbSB3aGVuIHRoZXJlJ3MgYSBwbHVnaW4gdGhhdCB3aWxsIGJlIHR3ZWVuaW5nIHRoZSB2YWx1ZXMgYmVjYXVzZSBpdCBtYXkgZGVwZW5kIG9uIHRoZSB2YWx1ZXMgYmVpbmcgc3BsaXQgYXBhcnQsIGxpa2UgZm9yIGEgYmV6aWVyLCBpZiBhIHZhbHVlIGRvZXNuJ3QgY2hhbmdlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgaXRlcmF0aW9uIGJ1dCB0aGVuIGl0IGRvZXMgb24gdGhlIDNyZCwgd2UnbGwgcnVuIGludG8gdHJvdWJsZSBiZWNhdXNlIHRoZXJlJ3Mgbm8geG4gc2xvdCBmb3IgdGhhdCB2YWx1ZSFcblx0XHRcdFx0cHRbXCJ4c1wiICsgbF0gKz0gcyArIChzZnggfHwgXCJcIik7XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH1cblx0XHRcdHB0LmwrKztcblx0XHRcdHB0LnR5cGUgPSBwdC5zZXRSYXRpbyA/IDIgOiAxO1xuXHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gPSBzZnggfHwgXCJcIjtcblx0XHRcdGlmIChsID4gMCkge1xuXHRcdFx0XHRwdC5kYXRhW1wieG5cIiArIGxdID0gcyArIGM7XG5cdFx0XHRcdHB0LnJ4cFtcInhuXCIgKyBsXSA9IHI7IC8vcm91bmQgZXh0cmEgcHJvcGVydHkgKHdlIG5lZWQgdG8gdGFwIGludG8gdGhpcyBpbiB0aGUgX3BhcnNlVG9Qcm94eSgpIG1ldGhvZClcblx0XHRcdFx0cHRbXCJ4blwiICsgbF0gPSBzO1xuXHRcdFx0XHRpZiAoIXB0LnBsdWdpbikge1xuXHRcdFx0XHRcdHB0LnhmaXJzdCA9IG5ldyBDU1NQcm9wVHdlZW4ocHQsIFwieG5cIiArIGwsIHMsIGMsIHB0LnhmaXJzdCB8fCBwdCwgMCwgcHQubiwgciwgcHQucHIpO1xuXHRcdFx0XHRcdHB0LnhmaXJzdC54czAgPSAwOyAvL2p1c3QgdG8gZW5zdXJlIHRoYXQgdGhlIHByb3BlcnR5IHN0YXlzIG51bWVyaWMgd2hpY2ggaGVscHMgbW9kZXJuIGJyb3dzZXJzIHNwZWVkIHVwIHByb2Nlc3NpbmcuIFJlbWVtYmVyLCBpbiB0aGUgc2V0UmF0aW8oKSBtZXRob2QsIHdlIGRvIHB0LnRbcHQucF0gPSB2YWwgKyBwdC54czAgc28gaWYgcHQueHMwIGlzIFwiXCIgKHRoZSBkZWZhdWx0KSwgaXQnbGwgY2FzdCB0aGUgZW5kIHZhbHVlIGFzIGEgc3RyaW5nLiBXaGVuIGEgcHJvcGVydHkgaXMgYSBudW1iZXIgc29tZXRpbWVzIGFuZCBhIHN0cmluZyBzb21ldGltZXMsIGl0IHByZXZlbnRzIHRoZSBjb21waWxlciBmcm9tIGxvY2tpbmcgaW4gdGhlIGRhdGEgdHlwZSwgc2xvd2luZyB0aGluZ3MgZG93biBzbGlnaHRseS5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9XG5cdFx0XHRwdC5kYXRhID0ge3M6cyArIGN9O1xuXHRcdFx0cHQucnhwID0ge307XG5cdFx0XHRwdC5zID0gcztcblx0XHRcdHB0LmMgPSBjO1xuXHRcdFx0cHQuciA9IHI7XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEBjb25zdHJ1Y3RvciBBIFNwZWNpYWxQcm9wIGlzIGJhc2ljYWxseSBhIGNzcyBwcm9wZXJ0eSB0aGF0IG5lZWRzIHRvIGJlIHRyZWF0ZWQgaW4gYSBub24tc3RhbmRhcmQgd2F5LCBsaWtlIGlmIGl0IG1heSBjb250YWluIGEgY29tcGxleCB2YWx1ZSBsaWtlIGJveFNoYWRvdzpcIjVweCAxMHB4IDE1cHggcmdiKDI1NSwgMTAyLCA1MSlcIiBvciBpZiBpdCBpcyBhc3NvY2lhdGVkIHdpdGggYW5vdGhlciBwbHVnaW4gbGlrZSBUaHJvd1Byb3BzUGx1Z2luIG9yIEJlemllclBsdWdpbi4gRXZlcnkgU3BlY2lhbFByb3AgaXMgYXNzb2NpYXRlZCB3aXRoIGEgcGFydGljdWxhciBwcm9wZXJ0eSBuYW1lIGxpa2UgXCJib3hTaGFkb3dcIiBvciBcInRocm93UHJvcHNcIiBvciBcImJlemllclwiIGFuZCBpdCB3aWxsIGludGVyY2VwdCB0aG9zZSB2YWx1ZXMgaW4gdGhlIHZhcnMgb2JqZWN0IHRoYXQncyBwYXNzZWQgdG8gdGhlIENTU1BsdWdpbiBhbmQgaGFuZGxlIHRoZW0gYWNjb3JkaW5nbHkuXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKGxpa2UgXCJib3hTaGFkb3dcIiBvciBcInRocm93UHJvcHNcIilcblx0XHQgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYW55IG9mIHRoZSBmb2xsb3dpbmcgY29uZmlndXJhdGlvbiBvcHRpb25zOlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gZGVmYXVsdFZhbHVlOiB0aGUgZGVmYXVsdCB2YWx1ZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gcGFyc2VyOiBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IG5hbWUgaXMgZm91bmQgaW4gdGhlIHZhcnMuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIENTU1Byb3BUd2VlbiBpbnN0YW5jZSBhbmQgaXQgc2hvdWxkIGVuc3VyZSB0aGF0IGl0IGlzIHByb3Blcmx5IGluc2VydGVkIGludG8gdGhlIGxpbmtlZCBsaXN0LiBJdCB3aWxsIHJlY2VpdmUgNCBwYXJhbXRlcnM6IDEpIFRoZSB0YXJnZXQsIDIpIFRoZSB2YWx1ZSBkZWZpbmVkIGluIHRoZSB2YXJzLCAzKSBUaGUgQ1NTUGx1Z2luIGluc3RhbmNlICh3aG9zZSBfZmlyc3RQVCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGxpbmtlZCBsaXN0KSwgYW5kIDQpIEEgY29tcHV0ZWQgc3R5bGUgb2JqZWN0IGlmIG9uZSB3YXMgY2FsY3VsYXRlZCAodGhpcyBpcyBhIHNwZWVkIG9wdGltaXphdGlvbiB0aGF0IGFsbG93cyByZXRyaWV2YWwgb2Ygc3RhcnRpbmcgdmFsdWVzIHF1aWNrZXIpXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBmb3JtYXR0ZXI6IGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGFueSB2YWx1ZSByZWNlaXZlZCBmb3IgdGhpcyBzcGVjaWFsIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgYm94U2hhZG93IGNvdWxkIHRha2UgXCI1cHggNXB4IHJlZFwiIGFuZCBmb3JtYXQgaXQgdG8gXCI1cHggNXB4IDBweCAwcHggcmVkXCIgc28gdGhhdCBib3RoIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgaGF2ZSBhIGNvbW1vbiBvcmRlciBhbmQgcXVhbnRpdHkgb2YgdmFsdWVzLilcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIHByZWZpeDogaWYgdHJ1ZSwgd2UnbGwgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoaXMgcHJvcGVydHkgcmVxdWlyZXMgYSB2ZW5kb3IgcHJlZml4IChsaWtlIFdlYmtpdCBvciBNb3ogb3IgbXMgb3IgTylcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGNvbG9yOiBzZXQgdGhpcyB0byB0cnVlIGlmIHRoZSB2YWx1ZSBmb3IgdGhpcyBTcGVjaWFsUHJvcCBtYXkgY29udGFpbiBjb2xvci1yZWxhdGVkIHZhbHVlcyBsaWtlIHJnYigpLCByZ2JhKCksIGV0Yy5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIHByaW9yaXR5OiBwcmlvcml0eSBpbiB0aGUgbGlua2VkIGxpc3Qgb3JkZXIuIEhpZ2hlciBwcmlvcml0eSBTcGVjaWFsUHJvcHMgd2lsbCBiZSB1cGRhdGVkIGJlZm9yZSBsb3dlciBwcmlvcml0eSBvbmVzLiBUaGUgZGVmYXVsdCBwcmlvcml0eSBpcyAwLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gbXVsdGk6IGlmIHRydWUsIHRoZSBmb3JtYXR0ZXIgc2hvdWxkIGFjY29tbW9kYXRlIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzLCBsaWtlIGJveFNoYWRvdyBjb3VsZCBoYXZlIG11bHRpcGxlIGJveFNoYWRvd3MgbGlzdGVkIG91dC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGNvbGxhcHNpYmxlOiBpZiB0cnVlLCB0aGUgZm9ybWF0dGVyIHNob3VsZCB0cmVhdCB0aGUgdmFsdWUgbGlrZSBpdCdzIGEgdG9wL3JpZ2h0L2JvdHRvbS9sZWZ0IHZhbHVlIHRoYXQgY291bGQgYmUgY29sbGFwc2VkLCBsaWtlIFwiNXB4XCIgd291bGQgYXBwbHkgdG8gYWxsLCBcIjVweCwgMTBweFwiIHdvdWxkIHVzZSA1cHggZm9yIHRvcC9ib3R0b20gYW5kIDEwcHggZm9yIHJpZ2h0L2xlZnQsIGV0Yy5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGtleXdvcmQ6IGEgc3BlY2lhbCBrZXl3b3JkIHRoYXQgY2FuIFtvcHRpb25hbGx5XSBiZSBmb3VuZCBpbnNpZGUgdGhlIHZhbHVlIChsaWtlIFwiaW5zZXRcIiBmb3IgYm94U2hhZG93KS4gVGhpcyBhbGxvd3MgdXMgdG8gdmFsaWRhdGUgYmVnaW5uaW5nL2VuZGluZyB2YWx1ZXMgdG8gbWFrZSBzdXJlIHRoZXkgbWF0Y2ggKGlmIHRoZSBrZXl3b3JkIGlzIGZvdW5kIGluIG9uZSwgaXQnbGwgYmUgYWRkZWQgdG8gdGhlIG90aGVyIGZvciBjb25zaXN0ZW5jeSBieSBkZWZhdWx0KS5cblx0XHQgKi9cblx0XHR2YXIgU3BlY2lhbFByb3AgPSBmdW5jdGlvbihwLCBvcHRpb25zKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0XHR0aGlzLnAgPSBvcHRpb25zLnByZWZpeCA/IF9jaGVja1Byb3BQcmVmaXgocCkgfHwgcCA6IHA7XG5cdFx0XHRcdF9zcGVjaWFsUHJvcHNbcF0gPSBfc3BlY2lhbFByb3BzW3RoaXMucF0gPSB0aGlzO1xuXHRcdFx0XHR0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IF9nZXRGb3JtYXR0ZXIob3B0aW9ucy5kZWZhdWx0VmFsdWUsIG9wdGlvbnMuY29sb3IsIG9wdGlvbnMuY29sbGFwc2libGUsIG9wdGlvbnMubXVsdGkpO1xuXHRcdFx0XHRpZiAob3B0aW9ucy5wYXJzZXIpIHtcblx0XHRcdFx0XHR0aGlzLnBhcnNlID0gb3B0aW9ucy5wYXJzZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jbHJzID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdFx0dGhpcy5tdWx0aSA9IG9wdGlvbnMubXVsdGk7XG5cdFx0XHRcdHRoaXMua2V5d29yZCA9IG9wdGlvbnMua2V5d29yZDtcblx0XHRcdFx0dGhpcy5kZmx0ID0gb3B0aW9ucy5kZWZhdWx0VmFsdWU7XG5cdFx0XHRcdHRoaXMucHIgPSBvcHRpb25zLnByaW9yaXR5IHx8IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL3Nob3J0Y3V0IGZvciBjcmVhdGluZyBhIG5ldyBTcGVjaWFsUHJvcCB0aGF0IGNhbiBhY2NlcHQgbXVsdGlwbGUgcHJvcGVydGllcyBhcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IChoZWxwcyBtaW5pZmljYXRpb24pLiBkZmx0IGNhbiBiZSBhbiBhcnJheSBmb3IgbXVsdGlwbGUgdmFsdWVzICh3ZSBkb24ndCBkbyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IGJlY2F1c2UgdGhlIGRlZmF1bHQgdmFsdWUgbWF5IGNvbnRhaW4gY29tbWFzLCBsaWtlIHJlY3QoMHB4LDBweCwwcHgsMHB4KSkuIFdlIGF0dGFjaCB0aGlzIG1ldGhvZCB0byB0aGUgU3BlY2lhbFByb3AgY2xhc3Mvb2JqZWN0IGluc3RlYWQgb2YgdXNpbmcgYSBwcml2YXRlIF9jcmVhdGVTcGVjaWFsUHJvcCgpIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiB0YXAgaW50byBpdCBleHRlcm5hbGx5IGlmIG5lY2Vzc2FyeSwgbGlrZSBmcm9tIGFub3RoZXIgcGx1Z2luLlxuXHRcdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wID0gX2ludGVybmFscy5fcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AgPSBmdW5jdGlvbihwLCBvcHRpb25zLCBkZWZhdWx0cykge1xuXHRcdFx0XHRpZiAodHlwZW9mKG9wdGlvbnMpICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0b3B0aW9ucyA9IHtwYXJzZXI6ZGVmYXVsdHN9OyAvL3RvIG1ha2UgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBCZXppZXJQbHVnaW4gYW5kIFRocm93UHJvcHNQbHVnaW5cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgYSA9IHAuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRcdGQgPSBvcHRpb25zLmRlZmF1bHRWYWx1ZSxcblx0XHRcdFx0XHRpLCB0ZW1wO1xuXHRcdFx0XHRkZWZhdWx0cyA9IGRlZmF1bHRzIHx8IFtkXTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvcHRpb25zLnByZWZpeCA9IChpID09PSAwICYmIG9wdGlvbnMucHJlZml4KTtcblx0XHRcdFx0XHRvcHRpb25zLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRzW2ldIHx8IGQ7XG5cdFx0XHRcdFx0dGVtcCA9IG5ldyBTcGVjaWFsUHJvcChhW2ldLCBvcHRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly9jcmVhdGVzIGEgcGxhY2Vob2xkZXIgc3BlY2lhbCBwcm9wIGZvciBhIHBsdWdpbiBzbyB0aGF0IHRoZSBwcm9wZXJ0eSBnZXRzIGNhdWdodCB0aGUgZmlyc3QgdGltZSBhIHR3ZWVuIG9mIGl0IGlzIGF0dGVtcHRlZCwgYW5kIGF0IHRoYXQgdGltZSBpdCBtYWtlcyB0aGUgcGx1Z2luIHJlZ2lzdGVyIGl0c2VsZiwgdGh1cyB0YWtpbmcgb3ZlciBmb3IgYWxsIGZ1dHVyZSB0d2VlbnMgb2YgdGhhdCBwcm9wZXJ0eS4gVGhpcyBhbGxvd3MgdXMgdG8gbm90IG1hbmRhdGUgdGhhdCB0aGluZ3MgbG9hZCBpbiBhIHBhcnRpY3VsYXIgb3JkZXIgYW5kIGl0IGFsc28gYWxsb3dzIHVzIHRvIGxvZygpIGFuIGVycm9yIHRoYXQgaW5mb3JtcyB0aGUgdXNlciB3aGVuIHRoZXkgYXR0ZW1wdCB0byB0d2VlbiBhbiBleHRlcm5hbCBwbHVnaW4tcmVsYXRlZCBwcm9wZXJ0eSB3aXRob3V0IGxvYWRpbmcgaXRzIC5qcyBmaWxlLlxuXHRcdFx0X3JlZ2lzdGVyUGx1Z2luUHJvcCA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKCFfc3BlY2lhbFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0dmFyIHBsdWdpbk5hbWUgPSBwLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcC5zdWJzdHIoMSkgKyBcIlBsdWdpblwiO1xuXHRcdFx0XHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChwLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdFx0XHRcdHZhciBwbHVnaW5DbGFzcyA9IF9nbG9iYWxzLmNvbS5ncmVlbnNvY2sucGx1Z2luc1twbHVnaW5OYW1lXTtcblx0XHRcdFx0XHRcdGlmICghcGx1Z2luQ2xhc3MpIHtcblx0XHRcdFx0XHRcdFx0X2xvZyhcIkVycm9yOiBcIiArIHBsdWdpbk5hbWUgKyBcIiBqcyBmaWxlIG5vdCBsb2FkZWQuXCIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwbHVnaW5DbGFzcy5fY3NzUmVnaXN0ZXIoKTtcblx0XHRcdFx0XHRcdHJldHVybiBfc3BlY2lhbFByb3BzW3BdLnBhcnNlKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpO1xuXHRcdFx0XHRcdH19KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXG5cdFx0cCA9IFNwZWNpYWxQcm9wLnByb3RvdHlwZTtcblxuXHRcdC8qKlxuXHRcdCAqIEFsaWFzIGZvciBfcGFyc2VDb21wbGV4KCkgdGhhdCBhdXRvbWF0aWNhbGx5IHBsdWdzIGluIGNlcnRhaW4gdmFsdWVzIGZvciB0aGlzIFNwZWNpYWxQcm9wLCBsaWtlIGl0cyBwcm9wZXJ0eSBuYW1lLCB3aGV0aGVyIG9yIG5vdCBjb2xvcnMgc2hvdWxkIGJlIHNlbnNlZCwgdGhlIGRlZmF1bHQgdmFsdWUsIGFuZCBwcmlvcml0eS4gSXQgYWxzbyBsb29rcyBmb3IgYW55IGtleXdvcmQgdGhhdCB0aGUgU3BlY2lhbFByb3AgZGVmaW5lcyAobGlrZSBcImluc2V0XCIgZm9yIGJveFNoYWRvdykgYW5kIGVuc3VyZXMgdGhhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHZhbHVlcyBmb3IgU3BlY2lhbFByb3BzIHdoZXJlIG11bHRpIGlzIHRydWUgKGxpa2UgYm94U2hhZG93IGFuZCB0ZXh0U2hhZG93IGNhbiBoYXZlIGEgY29tbWEtZGVsaW1pdGVkIGxpc3QpXG5cdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBlbGVtZW50XG5cdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxvYmplY3QpfSBiIGJlZ2lubmluZyB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXJ8b2JqZWN0KX0gZSBlbmRpbmcgKGRlc3RpbmF0aW9uKSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7Q1NTUHJvcFR3ZWVuPX0gcHQgbmV4dCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0ICogQHBhcmFtIHtUd2VlblBsdWdpbj19IHBsdWdpbiBJZiBhbm90aGVyIHBsdWdpbiB3aWxsIGJlIHR3ZWVuaW5nIHRoZSBjb21wbGV4IHZhbHVlLCB0aGF0IFR3ZWVuUGx1Z2luIGluc3RhbmNlIGdvZXMgaGVyZS5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gc2V0UmF0aW8gSWYgYSBjdXN0b20gc2V0UmF0aW8oKSBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gaGFuZGxlIHRoaXMgY29tcGxleCB2YWx1ZSwgdGhhdCBnb2VzIGhlcmUuXG5cdFx0ICogQHJldHVybiB7Q1NTUHJvcFR3ZWVuPX0gRmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdCAqL1xuXHRcdHAucGFyc2VDb21wbGV4ID0gZnVuY3Rpb24odCwgYiwgZSwgcHQsIHBsdWdpbiwgc2V0UmF0aW8pIHtcblx0XHRcdHZhciBrd2QgPSB0aGlzLmtleXdvcmQsXG5cdFx0XHRcdGksIGJhLCBlYSwgbCwgYmksIGVpO1xuXHRcdFx0Ly9pZiB0aGlzIFNwZWNpYWxQcm9wJ3MgdmFsdWUgY2FuIGNvbnRhaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgKGxpa2UgYm94U2hhZG93IG9yIHRleHRTaGFkb3cpLCB3ZSBtdXN0IHBhcnNlIHRoZW0gaW4gYSBzcGVjaWFsIHdheSwgYW5kIGxvb2sgZm9yIGEga2V5d29yZCAobGlrZSBcImluc2V0XCIgZm9yIGJveFNoYWRvdykgYW5kIGVuc3VyZSB0aGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBCT1RIIGhhdmUgaXQgaWYgdGhlIGVuZCBkZWZpbmVzIGl0IGFzIHN1Y2guIFdlIGFsc28gbXVzdCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgYW4gZXF1YWwgbnVtYmVyIG9mIHZhbHVlcyBzcGVjaWZpZWQgKHdlIGNhbid0IHR3ZWVuIDEgYm94U2hhZG93IHRvIDMgZm9yIGV4YW1wbGUpXG5cdFx0XHRpZiAodGhpcy5tdWx0aSkgaWYgKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdChlKSB8fCBfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QoYikpIHtcblx0XHRcdFx0YmEgPSBiLnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdFx0ZWEgPSBlLnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdH0gZWxzZSBpZiAoa3dkKSB7XG5cdFx0XHRcdGJhID0gW2JdO1xuXHRcdFx0XHRlYSA9IFtlXTtcblx0XHRcdH1cblx0XHRcdGlmIChlYSkge1xuXHRcdFx0XHRsID0gKGVhLmxlbmd0aCA+IGJhLmxlbmd0aCkgPyBlYS5sZW5ndGggOiBiYS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRiID0gYmFbaV0gPSBiYVtpXSB8fCB0aGlzLmRmbHQ7XG5cdFx0XHRcdFx0ZSA9IGVhW2ldID0gZWFbaV0gfHwgdGhpcy5kZmx0O1xuXHRcdFx0XHRcdGlmIChrd2QpIHtcblx0XHRcdFx0XHRcdGJpID0gYi5pbmRleE9mKGt3ZCk7XG5cdFx0XHRcdFx0XHRlaSA9IGUuaW5kZXhPZihrd2QpO1xuXHRcdFx0XHRcdFx0aWYgKGJpICE9PSBlaSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoZWkgPT09IC0xKSB7IC8vaWYgdGhlIGtleXdvcmQgaXNuJ3QgaW4gdGhlIGVuZCB2YWx1ZSwgcmVtb3ZlIGl0IGZyb20gdGhlIGJlZ2lubmluZyBvbmUuXG5cdFx0XHRcdFx0XHRcdFx0YmFbaV0gPSBiYVtpXS5zcGxpdChrd2QpLmpvaW4oXCJcIik7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYmkgPT09IC0xKSB7IC8vaWYgdGhlIGtleXdvcmQgaXNuJ3QgaW4gdGhlIGJlZ2lubmluZywgYWRkIGl0LlxuXHRcdFx0XHRcdFx0XHRcdGJhW2ldICs9IFwiIFwiICsga3dkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGIgPSBiYS5qb2luKFwiLCBcIik7XG5cdFx0XHRcdGUgPSBlYS5qb2luKFwiLCBcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gX3BhcnNlQ29tcGxleCh0LCB0aGlzLnAsIGIsIGUsIHRoaXMuY2xycywgdGhpcy5kZmx0LCBwdCwgdGhpcy5wciwgcGx1Z2luLCBzZXRSYXRpbyk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFjY2VwdHMgYSB0YXJnZXQgYW5kIGVuZCB2YWx1ZSBhbmQgc3BpdHMgYmFjayBhIENTU1Byb3BUd2VlbiB0aGF0IGhhcyBiZWVuIGluc2VydGVkIGludG8gdGhlIENTU1BsdWdpbidzIGxpbmtlZCBsaXN0IGFuZCBjb25mb3JtcyB3aXRoIGFsbCB0aGUgY29udmVudGlvbnMgd2UgdXNlIGludGVybmFsbHksIGxpa2UgdHlwZTotMSwgMCwgMSwgb3IgMiwgc2V0dGluZyB1cCBhbnkgZXh0cmEgcHJvcGVydHkgdHdlZW5zLCBwcmlvcml0eSwgZXRjLiBGb3IgZXhhbXBsZSwgaWYgd2UgaGF2ZSBhIGJveFNoYWRvdyBTcGVjaWFsUHJvcCBhbmQgY2FsbDpcblx0XHQgKiB0aGlzLl9maXJzdFBUID0gc3AucGFyc2UoZWxlbWVudCwgXCI1cHggMTBweCAyMHB4IHJnYigyNTUwLDEwMiw1MSlcIiwgXCJib3hTaGFkb3dcIiwgdGhpcyk7XG5cdFx0ICogSXQgc2hvdWxkIGZpZ3VyZSBvdXQgdGhlIHN0YXJ0aW5nIHZhbHVlIG9mIHRoZSBlbGVtZW50J3MgYm94U2hhZG93LCBjb21wYXJlIGl0IHRvIHRoZSBwcm92aWRlZCBlbmQgdmFsdWUgYW5kIGNyZWF0ZSBhbGwgdGhlIG5lY2Vzc2FyeSBDU1NQcm9wVHdlZW5zIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlcyB0byB0d2VlbiB0aGUgYm94U2hhZG93LiBUaGUgQ1NTUHJvcFR3ZWVuIHRoYXQgZ2V0cyBzcGl0IGJhY2sgc2hvdWxkIGFscmVhZHkgYmUgaW5zZXJ0ZWQgaW50byB0aGUgbGlua2VkIGxpc3QgKHRoZSA0dGggcGFyYW1ldGVyIGlzIHRoZSBjdXJyZW50IGhlYWQsIHNvIHByZXBlbmQgdG8gdGhhdCkuXG5cdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgaXMgYmVpbmcgdHdlZW5lZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlIEVuZCB2YWx1ZSBhcyBwcm92aWRlZCBpbiB0aGUgdmFycyBvYmplY3QgKHR5cGljYWxseSBhIHN0cmluZywgYnV0IG5vdCBhbHdheXMgLSBsaWtlIGEgdGhyb3dQcm9wcyB3b3VsZCBiZSBhbiBvYmplY3QpLlxuXHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lXG5cdFx0ICogQHBhcmFtIHshQ1NTUGx1Z2lufSBjc3NwIFRoZSBDU1NQbHVnaW4gaW5zdGFuY2UgdGhhdCBzaG91bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdHdlZW4uXG5cdFx0ICogQHBhcmFtIHs/Q1NTUHJvcFR3ZWVufSBwdCBUaGUgQ1NTUHJvcFR3ZWVuIHRoYXQgaXMgdGhlIGN1cnJlbnQgaGVhZCBvZiB0aGUgbGlua2VkIGxpc3QgKHdlJ2xsIHByZXBlbmQgdG8gaXQpXG5cdFx0ICogQHBhcmFtIHtUd2VlblBsdWdpbj19IHBsdWdpbiBJZiBhIHBsdWdpbiB3aWxsIGJlIHVzZWQgdG8gdHdlZW4gdGhlIHBhcnNlZCB2YWx1ZSwgdGhpcyBpcyB0aGUgcGx1Z2luIGluc3RhbmNlLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gdmFycyBPcmlnaW5hbCB2YXJzIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIGZvciBwYXJzaW5nLlxuXHRcdCAqIEByZXR1cm4ge0NTU1Byb3BUd2Vlbn0gVGhlIGZpcnN0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Qgd2hpY2ggaW5jbHVkZXMgdGhlIG5ldyBvbmUocykgYWRkZWQgYnkgdGhlIHBhcnNlKCkgY2FsbC5cblx0XHQgKi9cblx0XHRwLnBhcnNlID0gZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIHRoaXMuZm9ybWF0KF9nZXRTdHlsZSh0LCB0aGlzLnAsIF9jcywgZmFsc2UsIHRoaXMuZGZsdCkpLCB0aGlzLmZvcm1hdChlKSwgcHQsIHBsdWdpbik7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVycyBhIHNwZWNpYWwgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgaW50ZXJjZXB0ZWQgZnJvbSBhbnkgXCJjc3NcIiBvYmplY3RzIGRlZmluZWQgaW4gdHdlZW5zLiBUaGlzIGFsbG93cyB5b3UgdG8gaGFuZGxlIHRoZW0gaG93ZXZlciB5b3Ugd2FudCB3aXRob3V0IENTU1BsdWdpbiBkb2luZyBpdCBmb3IgeW91LiBUaGUgMm5kIHBhcmFtZXRlciBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgMyBwYXJhbWV0ZXJzOlxuXHRcdCAqICAxKSBUYXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnR5IHNob3VsZCBiZSB0d2VlbmVkICh0eXBpY2FsbHkgYSBET00gZWxlbWVudClcblx0XHQgKiAgMikgVGhlIGVuZC9kZXN0aW5hdGlvbiB2YWx1ZSAoY291bGQgYmUgYSBzdHJpbmcsIG51bWJlciwgb2JqZWN0LCBvciB3aGF0ZXZlciB5b3Ugd2FudClcblx0XHQgKiAgMykgVGhlIHR3ZWVuIGluc3RhbmNlICh5b3UgcHJvYmFibHkgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGlzLCBidXQgaXQgY2FuIGJlIHVzZWZ1bCBmb3IgbG9va2luZyB1cCBpbmZvcm1hdGlvbiBsaWtlIHRoZSBkdXJhdGlvbilcblx0XHQgKlxuXHRcdCAqIFRoZW4sIHlvdXIgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGVhY2ggdGltZSB0aGUgdHdlZW4gZ2V0cyByZW5kZXJlZCwgcGFzc2luZyBhIG51bWVyaWMgXCJyYXRpb1wiIHBhcmFtZXRlciB0byB5b3VyIGZ1bmN0aW9uIHRoYXQgaW5kaWNhdGVzIHRoZSBjaGFuZ2UgZmFjdG9yICh1c3VhbGx5IGJldHdlZW4gMCBhbmQgMSkuIEZvciBleGFtcGxlOlxuXHRcdCAqXG5cdFx0ICogQ1NTUGx1Z2luLnJlZ2lzdGVyU3BlY2lhbFByb3AoXCJteUN1c3RvbVByb3BcIiwgZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4pIHtcblx0XHQgKiAgICAgIHZhciBzdGFydCA9IHRhcmdldC5zdHlsZS53aWR0aDtcblx0XHQgKiAgICAgIHJldHVybiBmdW5jdGlvbihyYXRpbykge1xuXHRcdCAqICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUud2lkdGggPSAoc3RhcnQgKyB2YWx1ZSAqIHJhdGlvKSArIFwicHhcIjtcblx0XHQgKiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzZXQgd2lkdGggdG8gXCIgKyB0YXJnZXQuc3R5bGUud2lkdGgpO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiB9LCAwKTtcblx0XHQgKlxuXHRcdCAqIFRoZW4sIHdoZW4gSSBkbyB0aGlzIHR3ZWVuLCBpdCB3aWxsIHRyaWdnZXIgbXkgc3BlY2lhbCBwcm9wZXJ0eTpcblx0XHQgKlxuXHRcdCAqIFR3ZWVuTGl0ZS50byhlbGVtZW50LCAxLCB7Y3NzOntteUN1c3RvbVByb3A6MTAwfX0pO1xuXHRcdCAqXG5cdFx0ICogSW4gdGhlIGV4YW1wbGUsIG9mIGNvdXJzZSwgd2UncmUganVzdCBjaGFuZ2luZyB0aGUgd2lkdGgsIGJ1dCB5b3UgY2FuIGRvIGFueXRoaW5nIHlvdSB3YW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFByb3BlcnR5IG5hbWUgKG9yIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzKSB0aGF0IHNob3VsZCBiZSBpbnRlcmNlcHRlZCBhbmQgaGFuZGxlZCBieSB5b3VyIGZ1bmN0aW9uLiBGb3IgZXhhbXBsZSwgaWYgSSBkZWZpbmUgXCJteUN1c3RvbVByb3BcIiwgdGhlbiBpdCB3b3VsZCBoYW5kbGUgdGhhdCBwb3J0aW9uIG9mIHRoZSBmb2xsb3dpbmcgdHdlZW46IFR3ZWVuTGl0ZS50byhlbGVtZW50LCAxLCB7Y3NzOntteUN1c3RvbVByb3A6MTAwfX0pXG5cdFx0ICogQHBhcmFtIHshZnVuY3Rpb24oT2JqZWN0LCBPYmplY3QsIE9iamVjdCwgc3RyaW5nKTpmdW5jdGlvbihudW1iZXIpfSBvbkluaXRUd2VlbiBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgdHdlZW4gb2YgdGhpcyBzcGVjaWFsIHByb3BlcnR5IGlzIHBlcmZvcm1lZC4gVGhlIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSA0IHBhcmFtZXRlcnM6IDEpIFRhcmdldCBvYmplY3QgdGhhdCBzaG91bGQgYmUgdHdlZW5lZCwgMikgVmFsdWUgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSB0d2VlbiwgMykgVGhlIHR3ZWVuIGluc3RhbmNlIGl0c2VsZiAocmFyZWx5IHVzZWQpLCBhbmQgNCkgVGhlIHByb3BlcnR5IG5hbWUgdGhhdCdzIGJlaW5nIHR3ZWVuZWQuIFlvdXIgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCBvbiBldmVyeSB1cGRhdGUgb2YgdGhlIHR3ZWVuLiBUaGF0IGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBhIHNpbmdsZSBwYXJhbWV0ZXIgdGhhdCBpcyBhIFwiY2hhbmdlIGZhY3RvclwiIHZhbHVlICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBpbmRpY2F0aW5nIHRoZSBhbW91bnQgb2YgY2hhbmdlIGFzIGEgcmF0aW8uIFlvdSBjYW4gdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhlIHZhbHVlcyBhcHByb3ByaWF0ZWx5IGluIHlvdXIgZnVuY3Rpb24uXG5cdFx0ICogQHBhcmFtIHtudW1iZXI9fSBwcmlvcml0eSBQcmlvcml0eSB0aGF0IGhlbHBzIHRoZSBlbmdpbmUgZGV0ZXJtaW5lIHRoZSBvcmRlciBpbiB3aGljaCB0byBzZXQgdGhlIHByb3BlcnRpZXMgKGRlZmF1bHQ6IDApLiBIaWdoZXIgcHJpb3JpdHkgcHJvcGVydGllcyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuXG5cdFx0ICovXG5cdFx0Q1NTUGx1Z2luLnJlZ2lzdGVyU3BlY2lhbFByb3AgPSBmdW5jdGlvbihuYW1lLCBvbkluaXRUd2VlbiwgcHJpb3JpdHkpIHtcblx0XHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChuYW1lLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdFx0dmFyIHJ2ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgMiwgcCwgZmFsc2UsIHByaW9yaXR5KTtcblx0XHRcdFx0cnYucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRydi5zZXRSYXRpbyA9IG9uSW5pdFR3ZWVuKHQsIGUsIGNzc3AuX3R3ZWVuLCBwKTtcblx0XHRcdFx0cmV0dXJuIHJ2O1xuXHRcdFx0fSwgcHJpb3JpdHk6cHJpb3JpdHl9KTtcblx0XHR9O1xuXG5cblxuXG5cblxuXHRcdC8vdHJhbnNmb3JtLXJlbGF0ZWQgbWV0aG9kcyBhbmQgcHJvcGVydGllc1xuXHRcdENTU1BsdWdpbi51c2VTVkdUcmFuc2Zvcm1BdHRyID0gX2lzU2FmYXJpIHx8IF9pc0ZpcmVmb3g7IC8vU2FmYXJpIGFuZCBGaXJlZm94IGJvdGggaGF2ZSBzb21lIHJlbmRlcmluZyBidWdzIHdoZW4gYXBwbHlpbmcgQ1NTIHRyYW5zZm9ybXMgdG8gU1ZHIGVsZW1lbnRzLCBzbyBkZWZhdWx0IHRvIHVzaW5nIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSBpbnN0ZWFkICh1c2VycyBjYW4gb3ZlcnJpZGUgdGhpcykuXG5cdFx0dmFyIF90cmFuc2Zvcm1Qcm9wcyA9IChcInNjYWxlWCxzY2FsZVksc2NhbGVaLHgseSx6LHNrZXdYLHNrZXdZLHJvdGF0aW9uLHJvdGF0aW9uWCxyb3RhdGlvblkscGVyc3BlY3RpdmUseFBlcmNlbnQseVBlcmNlbnRcIikuc3BsaXQoXCIsXCIpLFxuXHRcdFx0X3RyYW5zZm9ybVByb3AgPSBfY2hlY2tQcm9wUHJlZml4KFwidHJhbnNmb3JtXCIpLCAvL3RoZSBKYXZhc2NyaXB0IChjYW1lbENhc2UpIHRyYW5zZm9ybSBwcm9wZXJ0eSwgbGlrZSBtc1RyYW5zZm9ybSwgV2Via2l0VHJhbnNmb3JtLCBNb3pUcmFuc2Zvcm0sIG9yIE9UcmFuc2Zvcm0uXG5cdFx0XHRfdHJhbnNmb3JtUHJvcENTUyA9IF9wcmVmaXhDU1MgKyBcInRyYW5zZm9ybVwiLFxuXHRcdFx0X3RyYW5zZm9ybU9yaWdpblByb3AgPSBfY2hlY2tQcm9wUHJlZml4KFwidHJhbnNmb3JtT3JpZ2luXCIpLFxuXHRcdFx0X3N1cHBvcnRzM0QgPSAoX2NoZWNrUHJvcFByZWZpeChcInBlcnNwZWN0aXZlXCIpICE9PSBudWxsKSxcblx0XHRcdFRyYW5zZm9ybSA9IF9pbnRlcm5hbHMuVHJhbnNmb3JtID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGVyc3BlY3RpdmUgPSBwYXJzZUZsb2F0KENTU1BsdWdpbi5kZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmUpIHx8IDA7XG5cdFx0XHRcdHRoaXMuZm9yY2UzRCA9IChDU1NQbHVnaW4uZGVmYXVsdEZvcmNlM0QgPT09IGZhbHNlIHx8ICFfc3VwcG9ydHMzRCkgPyBmYWxzZSA6IENTU1BsdWdpbi5kZWZhdWx0Rm9yY2UzRCB8fCBcImF1dG9cIjtcblx0XHRcdH0sXG5cdFx0XHRfU1ZHRWxlbWVudCA9IHdpbmRvdy5TVkdFbGVtZW50LFxuXHRcdFx0X3VzZVNWR1RyYW5zZm9ybUF0dHIsXG5cdFx0XHQvL1NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCBhbmQgSUUpIGRvbid0IGhvbm9yIHRyYW5zZm9ybS1vcmlnaW4gcHJvcGVybHkgaW4gU1ZHIGVsZW1lbnRzLCBzbyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGFkanVzdCB0aGUgbWF0cml4IGFjY29yZGluZ2x5LiBXZSBmZWF0dXJlIGRldGVjdCBoZXJlIHJhdGhlciB0aGFuIGFsd2F5cyBkb2luZyB0aGUgY29udmVyc2lvbiBmb3IgY2VydGFpbiBicm93c2VycyBiZWNhdXNlIHRoZXkgbWF5IGZpeCB0aGUgcHJvYmxlbSBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUuXG5cblx0XHRcdF9jcmVhdGVTVkcgPSBmdW5jdGlvbih0eXBlLCBjb250YWluZXIsIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHR5cGUpLFxuXHRcdFx0XHRcdHJlZyA9IC8oW2Etel0pKFtBLVpdKS9nLFxuXHRcdFx0XHRcdHA7XG5cdFx0XHRcdGZvciAocCBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBwLnJlcGxhY2UocmVnLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCksIGF0dHJpYnV0ZXNbcF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0XHR9LFxuXHRcdFx0X2RvY0VsZW1lbnQgPSBfZG9jLmRvY3VtZW50RWxlbWVudCxcblx0XHRcdF9mb3JjZVNWR1RyYW5zZm9ybUF0dHIgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vSUUgYW5kIEFuZHJvaWQgc3RvY2sgZG9uJ3Qgc3VwcG9ydCBDU1MgdHJhbnNmb3JtcyBvbiBTVkcgZWxlbWVudHMsIHNvIHdlIG11c3Qgd3JpdGUgdGhlbSB0byB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUuIFdlIHBvcHVsYXRlIHRoaXMgdmFyaWFibGUgaW4gdGhlIF9wYXJzZVRyYW5zZm9ybSgpIG1ldGhvZCwgYW5kIG9ubHkgaWYvd2hlbiB3ZSBjb21lIGFjcm9zcyBhbiBTVkcgZWxlbWVudFxuXHRcdFx0XHR2YXIgZm9yY2UgPSBfaWVWZXJzIHx8ICgvQW5kcm9pZC9pLnRlc3QoX2FnZW50KSAmJiAhd2luZG93LmNocm9tZSksXG5cdFx0XHRcdFx0c3ZnLCByZWN0LCB3aWR0aDtcblx0XHRcdFx0aWYgKF9kb2MuY3JlYXRlRWxlbWVudE5TICYmICFmb3JjZSkgeyAvL0lFOCBhbmQgZWFybGllciBkb2Vzbid0IHN1cHBvcnQgU1ZHIGFueXdheVxuXHRcdFx0XHRcdHN2ZyA9IF9jcmVhdGVTVkcoXCJzdmdcIiwgX2RvY0VsZW1lbnQpO1xuXHRcdFx0XHRcdHJlY3QgPSBfY3JlYXRlU1ZHKFwicmVjdFwiLCBzdmcsIHt3aWR0aDoxMDAsIGhlaWdodDo1MCwgeDoxMDB9KTtcblx0XHRcdFx0XHR3aWR0aCA9IHJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cdFx0XHRcdFx0cmVjdC5zdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBcIjUwJSA1MCVcIjtcblx0XHRcdFx0XHRyZWN0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IFwic2NhbGVYKDAuNSlcIjtcblx0XHRcdFx0XHRmb3JjZSA9ICh3aWR0aCA9PT0gcmVjdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAmJiAhKF9pc0ZpcmVmb3ggJiYgX3N1cHBvcnRzM0QpKTsgLy9ub3RlOiBGaXJlZm94IGZhaWxzIHRoZSB0ZXN0IGV2ZW4gdGhvdWdoIGl0IGRvZXMgc3VwcG9ydCBDU1MgdHJhbnNmb3JtcyBpbiAzRC4gU2luY2Ugd2UgY2FuJ3QgcHVzaCAzRCBzdHVmZiBpbnRvIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlLCB3ZSBmb3JjZSBGaXJlZm94IHRvIHBhc3MgdGhlIHRlc3QgaGVyZSAoYXMgbG9uZyBhcyBpdCBkb2VzIHRydWx5IHN1cHBvcnQgM0QpLlxuXHRcdFx0XHRcdF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZvcmNlO1xuXHRcdFx0fSkoKSxcblx0XHRcdF9wYXJzZVNWR09yaWdpbiA9IGZ1bmN0aW9uKGUsIGxvY2FsLCBkZWNvcmF0ZWUsIGFic29sdXRlLCBzbW9vdGhPcmlnaW4sIHNraXBSZWNvcmQpIHtcblx0XHRcdFx0dmFyIHRtID0gZS5fZ3NUcmFuc2Zvcm0sXG5cdFx0XHRcdFx0bSA9IF9nZXRNYXRyaXgoZSwgdHJ1ZSksXG5cdFx0XHRcdFx0diwgeCwgeSwgeE9yaWdpbiwgeU9yaWdpbiwgYSwgYiwgYywgZCwgdHgsIHR5LCBkZXRlcm1pbmFudCwgeE9yaWdpbk9sZCwgeU9yaWdpbk9sZDtcblx0XHRcdFx0aWYgKHRtKSB7XG5cdFx0XHRcdFx0eE9yaWdpbk9sZCA9IHRtLnhPcmlnaW47IC8vcmVjb3JkIHRoZSBvcmlnaW5hbCB2YWx1ZXMgYmVmb3JlIHdlIGFsdGVyIHRoZW0uXG5cdFx0XHRcdFx0eU9yaWdpbk9sZCA9IHRtLnlPcmlnaW47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFhYnNvbHV0ZSB8fCAodiA9IGFic29sdXRlLnNwbGl0KFwiIFwiKSkubGVuZ3RoIDwgMikge1xuXHRcdFx0XHRcdGIgPSBlLmdldEJCb3goKTtcblx0XHRcdFx0XHRsb2NhbCA9IF9wYXJzZVBvc2l0aW9uKGxvY2FsKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0diA9IFsobG9jYWxbMF0uaW5kZXhPZihcIiVcIikgIT09IC0xID8gcGFyc2VGbG9hdChsb2NhbFswXSkgLyAxMDAgKiBiLndpZHRoIDogcGFyc2VGbG9hdChsb2NhbFswXSkpICsgYi54LFxuXHRcdFx0XHRcdFx0IChsb2NhbFsxXS5pbmRleE9mKFwiJVwiKSAhPT0gLTEgPyBwYXJzZUZsb2F0KGxvY2FsWzFdKSAvIDEwMCAqIGIuaGVpZ2h0IDogcGFyc2VGbG9hdChsb2NhbFsxXSkpICsgYi55XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWNvcmF0ZWUueE9yaWdpbiA9IHhPcmlnaW4gPSBwYXJzZUZsb2F0KHZbMF0pO1xuXHRcdFx0XHRkZWNvcmF0ZWUueU9yaWdpbiA9IHlPcmlnaW4gPSBwYXJzZUZsb2F0KHZbMV0pO1xuXHRcdFx0XHRpZiAoYWJzb2x1dGUgJiYgbSAhPT0gX2lkZW50aXR5MkRNYXRyaXgpIHsgLy9pZiBzdmdPcmlnaW4gaXMgYmVpbmcgc2V0LCB3ZSBtdXN0IGludmVydCB0aGUgbWF0cml4IGFuZCBkZXRlcm1pbmUgd2hlcmUgdGhlIGFic29sdXRlIHBvaW50IGlzLCBmYWN0b3JpbmcgaW4gdGhlIGN1cnJlbnQgdHJhbnNmb3Jtcy4gT3RoZXJ3aXNlLCB0aGUgc3ZnT3JpZ2luIHdvdWxkIGJlIGJhc2VkIG9uIHRoZSBlbGVtZW50J3Mgbm9uLXRyYW5zZm9ybWVkIHBvc2l0aW9uIG9uIHRoZSBjYW52YXMuXG5cdFx0XHRcdFx0YSA9IG1bMF07XG5cdFx0XHRcdFx0YiA9IG1bMV07XG5cdFx0XHRcdFx0YyA9IG1bMl07XG5cdFx0XHRcdFx0ZCA9IG1bM107XG5cdFx0XHRcdFx0dHggPSBtWzRdO1xuXHRcdFx0XHRcdHR5ID0gbVs1XTtcblx0XHRcdFx0XHRkZXRlcm1pbmFudCA9IChhICogZCAtIGIgKiBjKTtcblx0XHRcdFx0XHR4ID0geE9yaWdpbiAqIChkIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqICgtYyAvIGRldGVybWluYW50KSArICgoYyAqIHR5IC0gZCAqIHR4KSAvIGRldGVybWluYW50KTtcblx0XHRcdFx0XHR5ID0geE9yaWdpbiAqICgtYiAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoYSAvIGRldGVybWluYW50KSAtICgoYSAqIHR5IC0gYiAqIHR4KSAvIGRldGVybWluYW50KTtcblx0XHRcdFx0XHR4T3JpZ2luID0gZGVjb3JhdGVlLnhPcmlnaW4gPSB2WzBdID0geDtcblx0XHRcdFx0XHR5T3JpZ2luID0gZGVjb3JhdGVlLnlPcmlnaW4gPSB2WzFdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodG0pIHsgLy9hdm9pZCBqdW1wIHdoZW4gdHJhbnNmb3JtT3JpZ2luIGlzIGNoYW5nZWQgLSBhZGp1c3QgdGhlIHgveSB2YWx1ZXMgYWNjb3JkaW5nbHlcblx0XHRcdFx0XHRpZiAoc2tpcFJlY29yZCkge1xuXHRcdFx0XHRcdFx0ZGVjb3JhdGVlLnhPZmZzZXQgPSB0bS54T2Zmc2V0O1xuXHRcdFx0XHRcdFx0ZGVjb3JhdGVlLnlPZmZzZXQgPSB0bS55T2Zmc2V0O1xuXHRcdFx0XHRcdFx0dG0gPSBkZWNvcmF0ZWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzbW9vdGhPcmlnaW4gfHwgKHNtb290aE9yaWdpbiAhPT0gZmFsc2UgJiYgQ1NTUGx1Z2luLmRlZmF1bHRTbW9vdGhPcmlnaW4gIT09IGZhbHNlKSkge1xuXHRcdFx0XHRcdFx0eCA9IHhPcmlnaW4gLSB4T3JpZ2luT2xkO1xuXHRcdFx0XHRcdFx0eSA9IHlPcmlnaW4gLSB5T3JpZ2luT2xkO1xuXHRcdFx0XHRcdFx0Ly9vcmlnaW5hbGx5LCB3ZSBzaW1wbHkgYWRqdXN0ZWQgdGhlIHggYW5kIHkgdmFsdWVzLCBidXQgdGhhdCB3b3VsZCBjYXVzZSBwcm9ibGVtcyBpZiwgZm9yIGV4YW1wbGUsIHlvdSBjcmVhdGVkIGEgcm90YXRpb25hbCB0d2VlbiBwYXJ0LXdheSB0aHJvdWdoIGFuIHgveSB0d2Vlbi4gTWFuYWdpbmcgdGhlIG9mZnNldCBpbiBhIHNlcGFyYXRlIHZhcmlhYmxlIGdpdmVzIHVzIHVsdGltYXRlIGZsZXhpYmlsaXR5LlxuXHRcdFx0XHRcdFx0Ly90bS54IC09IHggLSAoeCAqIG1bMF0gKyB5ICogbVsyXSk7XG5cdFx0XHRcdFx0XHQvL3RtLnkgLT0geSAtICh4ICogbVsxXSArIHkgKiBtWzNdKTtcblx0XHRcdFx0XHRcdHRtLnhPZmZzZXQgKz0gKHggKiBtWzBdICsgeSAqIG1bMl0pIC0geDtcblx0XHRcdFx0XHRcdHRtLnlPZmZzZXQgKz0gKHggKiBtWzFdICsgeSAqIG1bM10pIC0geTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dG0ueE9mZnNldCA9IHRtLnlPZmZzZXQgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXNraXBSZWNvcmQpIHtcblx0XHRcdFx0XHRlLnNldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiLCB2LmpvaW4oXCIgXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9jYW5HZXRCQm94ID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBlLmdldEJCb3goKTsgLy9GaXJlZm94IHRocm93cyBlcnJvcnMgaWYgeW91IHRyeSBjYWxsaW5nIGdldEJCb3goKSBvbiBhbiBTVkcgZWxlbWVudCB0aGF0J3Mgbm90IHJlbmRlcmVkIChsaWtlIGluIGEgPHN5bWJvbD4gb3IgPGRlZnM+KS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjEyMTE4XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHR9LFxuXHRcdFx0X2lzU1ZHID0gZnVuY3Rpb24oZSkgeyAvL3JlcG9ydHMgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHIG9uIHdoaWNoIGdldEJCb3goKSBhY3R1YWxseSB3b3Jrc1xuXHRcdFx0XHRyZXR1cm4gISEoX1NWR0VsZW1lbnQgJiYgZS5nZXRCQm94ICYmIGUuZ2V0Q1RNICYmIF9jYW5HZXRCQm94KGUpICYmICghZS5wYXJlbnROb2RlIHx8IChlLnBhcmVudE5vZGUuZ2V0QkJveCAmJiBlLnBhcmVudE5vZGUuZ2V0Q1RNKSkpO1xuXHRcdFx0fSxcblx0XHRcdF9pZGVudGl0eTJETWF0cml4ID0gWzEsMCwwLDEsMCwwXSxcblx0XHRcdF9nZXRNYXRyaXggPSBmdW5jdGlvbihlLCBmb3JjZTJEKSB7XG5cdFx0XHRcdHZhciB0bSA9IGUuX2dzVHJhbnNmb3JtIHx8IG5ldyBUcmFuc2Zvcm0oKSxcblx0XHRcdFx0XHRybmQgPSAxMDAwMDAsXG5cdFx0XHRcdFx0aXNEZWZhdWx0LCBzLCBtLCBuLCBkZWM7XG5cdFx0XHRcdGlmIChfdHJhbnNmb3JtUHJvcCkge1xuXHRcdFx0XHRcdHMgPSBfZ2V0U3R5bGUoZSwgX3RyYW5zZm9ybVByb3BDU1MsIG51bGwsIHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGUuY3VycmVudFN0eWxlKSB7XG5cdFx0XHRcdFx0Ly9mb3Igb2xkZXIgdmVyc2lvbnMgb2YgSUUsIHdlIG5lZWQgdG8gaW50ZXJwcmV0IHRoZSBmaWx0ZXIgcG9ydGlvbiB0aGF0IGlzIGluIHRoZSBmb3JtYXQ6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTYuMTIzMjMzOTk1NzM2NzY2ZS0xNywgTTEyPS0xLCBNMjE9MSwgTTIyPTYuMTIzMjMzOTk1NzM2NzY2ZS0xNywgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpIE5vdGljZSB0aGF0IHdlIG5lZWQgdG8gc3dhcCBiIGFuZCBjIGNvbXBhcmVkIHRvIGEgbm9ybWFsIG1hdHJpeC5cblx0XHRcdFx0XHRzID0gZS5jdXJyZW50U3R5bGUuZmlsdGVyLm1hdGNoKF9pZUdldE1hdHJpeEV4cCk7XG5cdFx0XHRcdFx0cyA9IChzICYmIHMubGVuZ3RoID09PSA0KSA/IFtzWzBdLnN1YnN0cig0KSwgTnVtYmVyKHNbMl0uc3Vic3RyKDQpKSwgTnVtYmVyKHNbMV0uc3Vic3RyKDQpKSwgc1szXS5zdWJzdHIoNCksICh0bS54IHx8IDApLCAodG0ueSB8fCAwKV0uam9pbihcIixcIikgOiBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlzRGVmYXVsdCA9ICghcyB8fCBzID09PSBcIm5vbmVcIiB8fCBzID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiKTtcblx0XHRcdFx0aWYgKHRtLnN2ZyB8fCAoZS5nZXRCQm94ICYmIF9pc1NWRyhlKSkpIHtcblx0XHRcdFx0XHRpZiAoaXNEZWZhdWx0ICYmIChlLnN0eWxlW190cmFuc2Zvcm1Qcm9wXSArIFwiXCIpLmluZGV4T2YoXCJtYXRyaXhcIikgIT09IC0xKSB7IC8vc29tZSBicm93c2VycyAobGlrZSBDaHJvbWUgNDApIGRvbid0IGNvcnJlY3RseSByZXBvcnQgdHJhbnNmb3JtcyB0aGF0IGFyZSBhcHBsaWVkIGlubGluZSBvbiBhbiBTVkcgZWxlbWVudCAodGhleSBkb24ndCBnZXQgaW5jbHVkZWQgaW4gdGhlIGNvbXB1dGVkIHN0eWxlKSwgc28gd2UgZG91YmxlLWNoZWNrIGhlcmUgYW5kIGFjY2VwdCBtYXRyaXggdmFsdWVzXG5cdFx0XHRcdFx0XHRzID0gZS5zdHlsZVtfdHJhbnNmb3JtUHJvcF07XG5cdFx0XHRcdFx0XHRpc0RlZmF1bHQgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtID0gZS5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0aWYgKGlzRGVmYXVsdCAmJiBtKSB7XG5cdFx0XHRcdFx0XHRpZiAobS5pbmRleE9mKFwibWF0cml4XCIpICE9PSAtMSkgeyAvL2p1c3QgaW4gY2FzZSB0aGVyZSdzIGEgXCJ0cmFuc2Zvcm1cIiB2YWx1ZSBzcGVjaWZpZWQgYXMgYW4gYXR0cmlidXRlIGluc3RlYWQgb2YgQ1NTIHN0eWxlLiBBY2NlcHQgZWl0aGVyIGEgbWF0cml4KCkgb3Igc2ltcGxlIHRyYW5zbGF0ZSgpIHZhbHVlIHRob3VnaC5cblx0XHRcdFx0XHRcdFx0cyA9IG07XG5cdFx0XHRcdFx0XHRcdGlzRGVmYXVsdCA9IDA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG0uaW5kZXhPZihcInRyYW5zbGF0ZVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0cyA9IFwibWF0cml4KDEsMCwwLDEsXCIgKyBtLm1hdGNoKC8oPzpcXC18XFxiKVtcXGRcXC1cXC5lXStcXGIvZ2kpLmpvaW4oXCIsXCIpICsgXCIpXCI7XG5cdFx0XHRcdFx0XHRcdGlzRGVmYXVsdCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc0RlZmF1bHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2lkZW50aXR5MkRNYXRyaXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9zcGxpdCB0aGUgbWF0cml4IHZhbHVlcyBvdXQgaW50byBhbiBhcnJheSAobSBmb3IgbWF0cml4KVxuXHRcdFx0XHRtID0gKHMgfHwgXCJcIikubWF0Y2goX251bUV4cCkgfHwgW107XG5cdFx0XHRcdGkgPSBtLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0biA9IE51bWJlcihtW2ldKTtcblx0XHRcdFx0XHRtW2ldID0gKGRlYyA9IG4gLSAobiB8PSAwKSkgPyAoKGRlYyAqIHJuZCArIChkZWMgPCAwID8gLTAuNSA6IDAuNSkpIHwgMCkgLyBybmQgKyBuIDogbjsgLy9jb252ZXJ0IHN0cmluZ3MgdG8gTnVtYmVycyBhbmQgcm91bmQgdG8gNSBkZWNpbWFsIHBsYWNlcyB0byBhdm9pZCBpc3N1ZXMgd2l0aCB0aW55IG51bWJlcnMuIFJvdWdobHkgMjB4IGZhc3RlciB0aGFuIE51bWJlci50b0ZpeGVkKCkuIFdlIGFsc28gbXVzdCBtYWtlIHN1cmUgdG8gcm91bmQgYmVmb3JlIGRpdmlkaW5nIHNvIHRoYXQgdmFsdWVzIGxpa2UgMC45OTk5OTk5OTk5IGJlY29tZSAxIHRvIGF2b2lkIGdsaXRjaGVzIGluIGJyb3dzZXIgcmVuZGVyaW5nIGFuZCBpbnRlcnByZXRhdGlvbiBvZiBmbGlwcGVkL3JvdGF0ZWQgM0QgbWF0cmljZXMuIEFuZCBkb24ndCBqdXN0IG11bHRpcGx5IHRoZSBudW1iZXIgYnkgcm5kLCBmbG9vciBpdCwgYW5kIHRoZW4gZGl2aWRlIGJ5IHJuZCBiZWNhdXNlIHRoZSBiaXR3aXNlIG9wZXJhdGlvbnMgbWF4IG91dCBhdCBhIDMyLWJpdCBzaWduZWQgaW50ZWdlciwgdGh1cyBpdCBjb3VsZCBnZXQgY2xpcHBlZCBhdCBhIHJlbGF0aXZlbHkgbG93IHZhbHVlIChsaWtlIDIyLDAwMC4wMDAwMCBmb3IgZXhhbXBsZSkuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIChmb3JjZTJEICYmIG0ubGVuZ3RoID4gNikgPyBbbVswXSwgbVsxXSwgbVs0XSwgbVs1XSwgbVsxMl0sIG1bMTNdXSA6IG07XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFBhcnNlcyB0aGUgdHJhbnNmb3JtIHZhbHVlcyBmb3IgYW4gZWxlbWVudCwgcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIHgsIHksIHosIHNjYWxlWCwgc2NhbGVZLCBzY2FsZVosIHJvdGF0aW9uLCByb3RhdGlvblgsIHJvdGF0aW9uWSwgc2tld1gsIGFuZCBza2V3WSBwcm9wZXJ0aWVzLiBOb3RlOiBieSBkZWZhdWx0IChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyksIGFsbCBza2V3aW5nIGlzIGNvbWJpbmVkIGludG8gc2tld1ggYW5kIHJvdGF0aW9uIGJ1dCBza2V3WSBzdGlsbCBoYXMgYSBwbGFjZSBpbiB0aGUgdHJhbnNmb3JtIG9iamVjdCBzbyB0aGF0IHdlIGNhbiByZWNvcmQgaG93IG11Y2ggb2YgdGhlIHNrZXcgaXMgYXR0cmlidXRlZCB0byBza2V3WCB2cyBza2V3WS4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBhbmQgc2tld1ggb2YgLTEwLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGNzIGNvbXB1dGVkIHN0eWxlIG9iamVjdCAob3B0aW9uYWwpXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWMgaWYgdHJ1ZSwgdGhlIHRyYW5zZm9ybSB2YWx1ZXMgd2lsbCBiZSByZWNvcmRlZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0LCBsaWtlIHRhcmdldC5fZ3NUcmFuc2Zvcm0gPSB7eDowLCB5OjAsIHo6MCwgc2NhbGVYOjEuLi59XG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBwYXJzZSBpZiB0cnVlLCB3ZSdsbCBpZ25vcmUgYW55IF9nc1RyYW5zZm9ybSB2YWx1ZXMgdGhhdCBhbHJlYWR5IGV4aXN0IG9uIHRoZSBlbGVtZW50LCBhbmQgZm9yY2UgYSByZXBhcnNpbmcgb2YgdGhlIGNzcyAoY2FsY3VsYXRlZCBzdHlsZSlcblx0XHRcdCAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcy92YWx1ZXMgbGlrZSB7eDowLCB5OjAsIHo6MCwgc2NhbGVYOjEuLi59XG5cdFx0XHQgKi9cblx0XHRcdF9nZXRUcmFuc2Zvcm0gPSBfaW50ZXJuYWxzLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHQsIGNzLCByZWMsIHBhcnNlKSB7XG5cdFx0XHRcdGlmICh0Ll9nc1RyYW5zZm9ybSAmJiByZWMgJiYgIXBhcnNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHQuX2dzVHJhbnNmb3JtOyAvL2lmIHRoZSBlbGVtZW50IGFscmVhZHkgaGFzIGEgX2dzVHJhbnNmb3JtLCB1c2UgdGhhdC4gTm90ZTogc29tZSBicm93c2VycyBkb24ndCBhY2N1cmF0ZWx5IHJldHVybiB0aGUgY2FsY3VsYXRlZCBzdHlsZSBmb3IgdGhlIHRyYW5zZm9ybSAocGFydGljdWxhcmx5IGZvciBTVkcpLCBzbyBpdCdzIGFsbW9zdCBhbHdheXMgc2FmZXN0IHRvIGp1c3QgdXNlIHRoZSB2YWx1ZXMgd2UndmUgYWxyZWFkeSBhcHBsaWVkIHJhdGhlciB0aGFuIHJlLXBhcnNpbmcgdGhpbmdzLlxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB0bSA9IHJlYyA/IHQuX2dzVHJhbnNmb3JtIHx8IG5ldyBUcmFuc2Zvcm0oKSA6IG5ldyBUcmFuc2Zvcm0oKSxcblx0XHRcdFx0XHRpbnZYID0gKHRtLnNjYWxlWCA8IDApLCAvL2luIG9yZGVyIHRvIGludGVycHJldCB0aGluZ3MgcHJvcGVybHksIHdlIG5lZWQgdG8ga25vdyBpZiB0aGUgdXNlciBhcHBsaWVkIGEgbmVnYXRpdmUgc2NhbGVYIHByZXZpb3VzbHkgc28gdGhhdCB3ZSBjYW4gYWRqdXN0IHRoZSByb3RhdGlvbiBhbmQgc2tld1ggYWNjb3JkaW5nbHkuIE90aGVyd2lzZSwgaWYgd2UgYWx3YXlzIGludGVycHJldCBhIGZsaXBwZWQgbWF0cml4IGFzIGFmZmVjdGluZyBzY2FsZVkgYW5kIHRoZSB1c2VyIG9ubHkgd2FudHMgdG8gdHdlZW4gdGhlIHNjYWxlWCBvbiBtdWx0aXBsZSBzZXF1ZW50aWFsIHR3ZWVucywgaXQgd291bGQga2VlcCB0aGUgbmVnYXRpdmUgc2NhbGVZIHdpdGhvdXQgdGhhdCBiZWluZyB0aGUgdXNlcidzIGludGVudC5cblx0XHRcdFx0XHRtaW4gPSAwLjAwMDAyLFxuXHRcdFx0XHRcdHJuZCA9IDEwMDAwMCxcblx0XHRcdFx0XHR6T3JpZ2luID0gX3N1cHBvcnRzM0QgPyBwYXJzZUZsb2F0KF9nZXRTdHlsZSh0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCwgY3MsIGZhbHNlLCBcIjAgMCAwXCIpLnNwbGl0KFwiIFwiKVsyXSkgfHwgdG0uek9yaWdpbiAgfHwgMCA6IDAsXG5cdFx0XHRcdFx0ZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlID0gcGFyc2VGbG9hdChDU1NQbHVnaW4uZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlKSB8fCAwLFxuXHRcdFx0XHRcdG0sIGksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1g7XG5cblx0XHRcdFx0dG0uc3ZnID0gISEodC5nZXRCQm94ICYmIF9pc1NWRyh0KSk7XG5cdFx0XHRcdGlmICh0bS5zdmcpIHtcblx0XHRcdFx0XHRfcGFyc2VTVkdPcmlnaW4odCwgX2dldFN0eWxlKHQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wLCBfY3MsIGZhbHNlLCBcIjUwJSA1MCVcIikgKyBcIlwiLCB0bSwgdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIikpO1xuXHRcdFx0XHRcdF91c2VTVkdUcmFuc2Zvcm1BdHRyID0gQ1NTUGx1Z2luLnVzZVNWR1RyYW5zZm9ybUF0dHIgfHwgX2ZvcmNlU1ZHVHJhbnNmb3JtQXR0cjtcblx0XHRcdFx0fVxuXHRcdFx0XHRtID0gX2dldE1hdHJpeCh0KTtcblx0XHRcdFx0aWYgKG0gIT09IF9pZGVudGl0eTJETWF0cml4KSB7XG5cblx0XHRcdFx0XHRpZiAobS5sZW5ndGggPT09IDE2KSB7XG5cdFx0XHRcdFx0XHQvL3dlJ2xsIG9ubHkgbG9vayBhdCB0aGVzZSBwb3NpdGlvbi1yZWxhdGVkIDYgdmFyaWFibGVzIGZpcnN0IGJlY2F1c2UgaWYgeC95L3ogYWxsIG1hdGNoLCBpdCdzIHJlbGF0aXZlbHkgc2FmZSB0byBhc3N1bWUgd2UgZG9uJ3QgbmVlZCB0byByZS1wYXJzZSBldmVyeXRoaW5nIHdoaWNoIHJpc2tzIGxvc2luZyBpbXBvcnRhbnQgcm90YXRpb25hbCBpbmZvcm1hdGlvbiAobGlrZSByb3RhdGlvblg6MTgwIHBsdXMgcm90YXRpb25ZOjE4MCB3b3VsZCBsb29rIHRoZSBzYW1lIGFzIHJvdGF0aW9uOjE4MCAtIHRoZXJlJ3Mgbm8gd2F5IHRvIGtub3cgZm9yIHN1cmUgd2hpY2ggZGlyZWN0aW9uIHdhcyB0YWtlbiBiYXNlZCBzb2xlbHkgb24gdGhlIG1hdHJpeDNkKCkgdmFsdWVzKVxuXHRcdFx0XHRcdFx0dmFyIGExMSA9IG1bMF0sIGEyMSA9IG1bMV0sIGEzMSA9IG1bMl0sIGE0MSA9IG1bM10sXG5cdFx0XHRcdFx0XHRcdGExMiA9IG1bNF0sIGEyMiA9IG1bNV0sIGEzMiA9IG1bNl0sIGE0MiA9IG1bN10sXG5cdFx0XHRcdFx0XHRcdGExMyA9IG1bOF0sIGEyMyA9IG1bOV0sIGEzMyA9IG1bMTBdLFxuXHRcdFx0XHRcdFx0XHRhMTQgPSBtWzEyXSwgYTI0ID0gbVsxM10sIGEzNCA9IG1bMTRdLFxuXHRcdFx0XHRcdFx0XHRhNDMgPSBtWzExXSxcblx0XHRcdFx0XHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKGEzMiwgYTMzKSxcblx0XHRcdFx0XHRcdFx0dDEsIHQyLCB0MywgdDQsIGNvcywgc2luO1xuXG5cdFx0XHRcdFx0XHQvL3dlIG1hbnVhbGx5IGNvbXBlbnNhdGUgZm9yIG5vbi16ZXJvIHogY29tcG9uZW50IG9mIHRyYW5zZm9ybU9yaWdpbiB0byB3b3JrIGFyb3VuZCBidWdzIGluIFNhZmFyaVxuXHRcdFx0XHRcdFx0aWYgKHRtLnpPcmlnaW4pIHtcblx0XHRcdFx0XHRcdFx0YTM0ID0gLXRtLnpPcmlnaW47XG5cdFx0XHRcdFx0XHRcdGExNCA9IGExMyphMzQtbVsxMl07XG5cdFx0XHRcdFx0XHRcdGEyNCA9IGEyMyphMzQtbVsxM107XG5cdFx0XHRcdFx0XHRcdGEzNCA9IGEzMyphMzQrdG0uek9yaWdpbi1tWzE0XTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWCA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHQvL3JvdGF0aW9uWFxuXHRcdFx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHQxID0gYTEyKmNvcythMTMqc2luO1xuXHRcdFx0XHRcdFx0XHR0MiA9IGEyMipjb3MrYTIzKnNpbjtcblx0XHRcdFx0XHRcdFx0dDMgPSBhMzIqY29zK2EzMypzaW47XG5cdFx0XHRcdFx0XHRcdGExMyA9IGExMiotc2luK2ExMypjb3M7XG5cdFx0XHRcdFx0XHRcdGEyMyA9IGEyMiotc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0XHRcdGEzMyA9IGEzMiotc2luK2EzMypjb3M7XG5cdFx0XHRcdFx0XHRcdGE0MyA9IGE0Miotc2luK2E0Mypjb3M7XG5cdFx0XHRcdFx0XHRcdGExMiA9IHQxO1xuXHRcdFx0XHRcdFx0XHRhMjIgPSB0Mjtcblx0XHRcdFx0XHRcdFx0YTMyID0gdDM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL3JvdGF0aW9uWVxuXHRcdFx0XHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKC1hMzEsIGEzMyk7XG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvblkgPSBhbmdsZSAqIF9SQUQyREVHO1xuXHRcdFx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHQxID0gYTExKmNvcy1hMTMqc2luO1xuXHRcdFx0XHRcdFx0XHR0MiA9IGEyMSpjb3MtYTIzKnNpbjtcblx0XHRcdFx0XHRcdFx0dDMgPSBhMzEqY29zLWEzMypzaW47XG5cdFx0XHRcdFx0XHRcdGEyMyA9IGEyMSpzaW4rYTIzKmNvcztcblx0XHRcdFx0XHRcdFx0YTMzID0gYTMxKnNpbithMzMqY29zO1xuXHRcdFx0XHRcdFx0XHRhNDMgPSBhNDEqc2luK2E0Mypjb3M7XG5cdFx0XHRcdFx0XHRcdGExMSA9IHQxO1xuXHRcdFx0XHRcdFx0XHRhMjEgPSB0Mjtcblx0XHRcdFx0XHRcdFx0YTMxID0gdDM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL3JvdGF0aW9uWlxuXHRcdFx0XHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKGEyMSwgYTExKTtcblx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHRhMTEgPSBhMTEqY29zK2ExMipzaW47XG5cdFx0XHRcdFx0XHRcdHQyID0gYTIxKmNvcythMjIqc2luO1xuXHRcdFx0XHRcdFx0XHRhMjIgPSBhMjEqLXNpbithMjIqY29zO1xuXHRcdFx0XHRcdFx0XHRhMzIgPSBhMzEqLXNpbithMzIqY29zO1xuXHRcdFx0XHRcdFx0XHRhMjEgPSB0Mjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHRtLnJvdGF0aW9uWCAmJiBNYXRoLmFicyh0bS5yb3RhdGlvblgpICsgTWF0aC5hYnModG0ucm90YXRpb24pID4gMzU5LjkpIHsgLy93aGVuIHJvdGF0aW9uWSBpcyBzZXQsIGl0IHdpbGwgb2Z0ZW4gYmUgcGFyc2VkIGFzIDE4MCBkZWdyZWVzIGRpZmZlcmVudCB0aGFuIGl0IHNob3VsZCBiZSwgYW5kIHJvdGF0aW9uWCBhbmQgcm90YXRpb24gYm90aCBiZWluZyAxODAgKGl0IGxvb2tzIHRoZSBzYW1lKSwgc28gd2UgYWRqdXN0IGZvciB0aGF0IGhlcmUuXG5cdFx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWCA9IHRtLnJvdGF0aW9uID0gMDtcblx0XHRcdFx0XHRcdFx0dG0ucm90YXRpb25ZID0gMTgwIC0gdG0ucm90YXRpb25ZO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0bS5zY2FsZVggPSAoKE1hdGguc3FydChhMTEgKiBhMTEgKyBhMjEgKiBhMjEpICogcm5kICsgMC41KSB8IDApIC8gcm5kO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVZID0gKChNYXRoLnNxcnQoYTIyICogYTIyICsgYTIzICogYTIzKSAqIHJuZCArIDAuNSkgfCAwKSAvIHJuZDtcblx0XHRcdFx0XHRcdHRtLnNjYWxlWiA9ICgoTWF0aC5zcXJ0KGEzMiAqIGEzMiArIGEzMyAqIGEzMykgKiBybmQgKyAwLjUpIHwgMCkgLyBybmQ7XG5cdFx0XHRcdFx0XHR0bS5za2V3WCA9IChhMTIgfHwgYTIyKSA/IE1hdGguYXRhbjIoYTEyLCBhMjIpICogX1JBRDJERUcgKyB0bS5yb3RhdGlvbiA6IHRtLnNrZXdYIHx8IDA7XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnModG0uc2tld1gpID4gOTAgJiYgTWF0aC5hYnModG0uc2tld1gpIDwgMjcwKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbnZYKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG0uc2NhbGVYICo9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdHRtLnNrZXdYICs9ICh0bS5yb3RhdGlvbiA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHRcdFx0XHRcdFx0dG0ucm90YXRpb24gKz0gKHRtLnJvdGF0aW9uIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0bS5zY2FsZVkgKj0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0dG0uc2tld1ggKz0gKHRtLnNrZXdYIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dG0ucGVyc3BlY3RpdmUgPSBhNDMgPyAxIC8gKChhNDMgPCAwKSA/IC1hNDMgOiBhNDMpIDogMDtcblx0XHRcdFx0XHRcdHRtLnggPSBhMTQ7XG5cdFx0XHRcdFx0XHR0bS55ID0gYTI0O1xuXHRcdFx0XHRcdFx0dG0ueiA9IGEzNDtcblx0XHRcdFx0XHRcdGlmICh0bS5zdmcpIHtcblx0XHRcdFx0XHRcdFx0dG0ueCAtPSB0bS54T3JpZ2luIC0gKHRtLnhPcmlnaW4gKiBhMTEgLSB0bS55T3JpZ2luICogYTEyKTtcblx0XHRcdFx0XHRcdFx0dG0ueSAtPSB0bS55T3JpZ2luIC0gKHRtLnlPcmlnaW4gKiBhMjEgLSB0bS54T3JpZ2luICogYTIyKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoKCFfc3VwcG9ydHMzRCB8fCBwYXJzZSB8fCAhbS5sZW5ndGggfHwgdG0ueCAhPT0gbVs0XSB8fCB0bS55ICE9PSBtWzVdIHx8ICghdG0ucm90YXRpb25YICYmICF0bS5yb3RhdGlvblkpKSAmJiAhKHRtLnggIT09IHVuZGVmaW5lZCAmJiBfZ2V0U3R5bGUodCwgXCJkaXNwbGF5XCIsIGNzKSA9PT0gXCJub25lXCIpKSB7IC8vc29tZXRpbWVzIGEgNi1lbGVtZW50IG1hdHJpeCBpcyByZXR1cm5lZCBldmVuIHdoZW4gd2UgcGVyZm9ybWVkIDNEIHRyYW5zZm9ybXMsIGxpa2UgaWYgcm90YXRpb25YIGFuZCByb3RhdGlvblkgYXJlIDE4MC4gSW4gY2FzZXMgbGlrZSB0aGlzLCB3ZSBzdGlsbCBuZWVkIHRvIGhvbm9yIHRoZSAzRCB0cmFuc2Zvcm1zLiBJZiB3ZSBqdXN0IHJlbHkgb24gdGhlIDJEIGluZm8sIGl0IGNvdWxkIGFmZmVjdCBob3cgdGhlIGRhdGEgaXMgaW50ZXJwcmV0ZWQsIGxpa2Ugc2NhbGVZIG1pZ2h0IGdldCBzZXQgdG8gLTEgb3Igcm90YXRpb24gY291bGQgZ2V0IG9mZnNldCBieSAxODAgZGVncmVlcy4gRm9yIGV4YW1wbGUsIGRvIGEgVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e3JvdGF0aW9uWDoxODAsIHJvdGF0aW9uWToxODB9fSkgYW5kIHRoZW4gbGF0ZXIsIFR3ZWVuTGl0ZS50byhlbGVtZW50LCAxLCB7Y3NzOntyb3RhdGlvblg6MH19KSBhbmQgd2l0aG91dCB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluIHBsYWNlLCBpdCdkIGp1bXAgdG8gYSBzdGF0ZSBvZiBiZWluZyB1bnJvdGF0ZWQgd2hlbiB0aGUgMm5kIHR3ZWVuIHN0YXJ0cy4gVGhlbiBhZ2Fpbiwgd2UgbmVlZCB0byBob25vciB0aGUgZmFjdCB0aGF0IHRoZSB1c2VyIENPVUxEIGFsdGVyIHRoZSB0cmFuc2Zvcm1zIG91dHNpZGUgb2YgQ1NTUGx1Z2luLCBsaWtlIGJ5IG1hbnVhbGx5IGFwcGx5aW5nIG5ldyBjc3MsIHNvIHdlIHRyeSB0byBzZW5zZSB0aGF0IGJ5IGxvb2tpbmcgYXQgeCBhbmQgeSBiZWNhdXNlIGlmIHRob3NlIGNoYW5nZWQsIHdlIGtub3cgdGhlIGNoYW5nZXMgd2VyZSBtYWRlIG91dHNpZGUgQ1NTUGx1Z2luIGFuZCB3ZSBmb3JjZSBhIHJlaW50ZXJwcmV0YXRpb24gb2YgdGhlIG1hdHJpeCB2YWx1ZXMuIEFsc28sIGluIFdlYmtpdCBicm93c2VycywgaWYgdGhlIGVsZW1lbnQncyBcImRpc3BsYXlcIiBpcyBcIm5vbmVcIiwgaXRzIGNhbGN1bGF0ZWQgc3R5bGUgdmFsdWUgd2lsbCBhbHdheXMgcmV0dXJuIGVtcHR5LCBzbyBpZiB3ZSd2ZSBhbHJlYWR5IHJlY29yZGVkIHRoZSB2YWx1ZXMgaW4gdGhlIF9nc1RyYW5zZm9ybSBvYmplY3QsIHdlJ2xsIGp1c3QgcmVseSBvbiB0aG9zZS5cblx0XHRcdFx0XHRcdHZhciBrID0gKG0ubGVuZ3RoID49IDYpLFxuXHRcdFx0XHRcdFx0XHRhID0gayA/IG1bMF0gOiAxLFxuXHRcdFx0XHRcdFx0XHRiID0gbVsxXSB8fCAwLFxuXHRcdFx0XHRcdFx0XHRjID0gbVsyXSB8fCAwLFxuXHRcdFx0XHRcdFx0XHRkID0gayA/IG1bM10gOiAxO1xuXHRcdFx0XHRcdFx0dG0ueCA9IG1bNF0gfHwgMDtcblx0XHRcdFx0XHRcdHRtLnkgPSBtWzVdIHx8IDA7XG5cdFx0XHRcdFx0XHRzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG5cdFx0XHRcdFx0XHRzY2FsZVkgPSBNYXRoLnNxcnQoZCAqIGQgKyBjICogYyk7XG5cdFx0XHRcdFx0XHRyb3RhdGlvbiA9IChhIHx8IGIpID8gTWF0aC5hdGFuMihiLCBhKSAqIF9SQUQyREVHIDogdG0ucm90YXRpb24gfHwgMDsgLy9ub3RlOiBpZiBzY2FsZVggaXMgMCwgd2UgY2Fubm90IGFjY3VyYXRlbHkgbWVhc3VyZSByb3RhdGlvbi4gU2FtZSBmb3Igc2tld1ggd2l0aCBhIHNjYWxlWSBvZiAwLiBUaGVyZWZvcmUsIHdlIGRlZmF1bHQgdG8gdGhlIHByZXZpb3VzbHkgcmVjb3JkZWQgdmFsdWUgKG9yIHplcm8gaWYgdGhhdCBkb2Vzbid0IGV4aXN0KS5cblx0XHRcdFx0XHRcdHNrZXdYID0gKGMgfHwgZCkgPyBNYXRoLmF0YW4yKGMsIGQpICogX1JBRDJERUcgKyByb3RhdGlvbiA6IHRtLnNrZXdYIHx8IDA7XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoc2tld1gpID4gOTAgJiYgTWF0aC5hYnMoc2tld1gpIDwgMjcwKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbnZYKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2NhbGVYICo9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdHNrZXdYICs9IChyb3RhdGlvbiA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHRcdFx0XHRcdFx0cm90YXRpb24gKz0gKHJvdGF0aW9uIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRzY2FsZVkgKj0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0c2tld1ggKz0gKHNrZXdYIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dG0uc2NhbGVYID0gc2NhbGVYO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVZID0gc2NhbGVZO1xuXHRcdFx0XHRcdFx0dG0ucm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdFx0XHRcdHRtLnNrZXdYID0gc2tld1g7XG5cdFx0XHRcdFx0XHRpZiAoX3N1cHBvcnRzM0QpIHtcblx0XHRcdFx0XHRcdFx0dG0ucm90YXRpb25YID0gdG0ucm90YXRpb25ZID0gdG0ueiA9IDA7XG5cdFx0XHRcdFx0XHRcdHRtLnBlcnNwZWN0aXZlID0gZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlO1xuXHRcdFx0XHRcdFx0XHR0bS5zY2FsZVogPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHRtLnN2Zykge1xuXHRcdFx0XHRcdFx0XHR0bS54IC09IHRtLnhPcmlnaW4gLSAodG0ueE9yaWdpbiAqIGEgKyB0bS55T3JpZ2luICogYyk7XG5cdFx0XHRcdFx0XHRcdHRtLnkgLT0gdG0ueU9yaWdpbiAtICh0bS54T3JpZ2luICogYiArIHRtLnlPcmlnaW4gKiBkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dG0uek9yaWdpbiA9IHpPcmlnaW47XG5cdFx0XHRcdFx0Ly9zb21lIGJyb3dzZXJzIGhhdmUgYSBoYXJkIHRpbWUgd2l0aCB2ZXJ5IHNtYWxsIHZhbHVlcyBsaWtlIDIuNDQ5MjkzNTk4Mjk0NzA2NGUtMTYgKG5vdGljZSB0aGUgXCJlLVwiIHRvd2FyZHMgdGhlIGVuZCkgYW5kIHdvdWxkIHJlbmRlciB0aGUgb2JqZWN0IHNsaWdodGx5IG9mZi4gU28gd2Ugcm91bmQgdG8gMCBpbiB0aGVzZSBjYXNlcy4gVGhlIGNvbmRpdGlvbmFsIGxvZ2ljIGhlcmUgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBNYXRoLmFicygpLiBBbHNvLCBicm93c2VycyB0ZW5kIHRvIHJlbmRlciBhIFNMSUdIVExZIHJvdGF0ZWQgb2JqZWN0IGluIGEgZnV6enkgd2F5LCBzbyB3ZSBuZWVkIHRvIHNuYXAgdG8gZXhhY3RseSAwIHdoZW4gYXBwcm9wcmlhdGUuXG5cdFx0XHRcdFx0Zm9yIChpIGluIHRtKSB7XG5cdFx0XHRcdFx0XHRpZiAodG1baV0gPCBtaW4pIGlmICh0bVtpXSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdFx0dG1baV0gPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwicGFyc2VkIHJvdGF0aW9uIG9mIFwiICsgdC5nZXRBdHRyaWJ1dGUoXCJpZFwiKStcIjogXCIrKHRtLnJvdGF0aW9uWCkrXCIsIFwiKyh0bS5yb3RhdGlvblkpK1wiLCBcIisodG0ucm90YXRpb24pK1wiLCBzY2FsZTogXCIrdG0uc2NhbGVYK1wiLCBcIit0bS5zY2FsZVkrXCIsIFwiK3RtLnNjYWxlWitcIiwgcG9zaXRpb246IFwiK3RtLngrXCIsIFwiK3RtLnkrXCIsIFwiK3RtLnorXCIsIHBlcnNwZWN0aXZlOiBcIit0bS5wZXJzcGVjdGl2ZSsgXCIsIG9yaWdpbjogXCIrIHRtLnhPcmlnaW4rIFwiLFwiKyB0bS55T3JpZ2luKTtcblx0XHRcdFx0aWYgKHJlYykge1xuXHRcdFx0XHRcdHQuX2dzVHJhbnNmb3JtID0gdG07IC8vcmVjb3JkIHRvIHRoZSBvYmplY3QncyBfZ3NUcmFuc2Zvcm0gd2hpY2ggd2UgdXNlIHNvIHRoYXQgdHdlZW5zIGNhbiBjb250cm9sIGluZGl2aWR1YWwgcHJvcGVydGllcyBpbmRlcGVuZGVudGx5ICh3ZSBuZWVkIGFsbCB0aGUgcHJvcGVydGllcyB0byBhY2N1cmF0ZWx5IHJlY29tcG9zZSB0aGUgbWF0cml4IGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZClcblx0XHRcdFx0XHRpZiAodG0uc3ZnKSB7IC8vaWYgd2UncmUgc3VwcG9zZWQgdG8gYXBwbHkgdHJhbnNmb3JtcyB0byB0aGUgU1ZHIGVsZW1lbnQncyBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgbWFrZSBzdXJlIHRoZXJlIGFyZW4ndCBhbnkgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCBvciB0aGV5J2xsIG92ZXJyaWRlIHRoZSBhdHRyaWJ1dGUgb25lcy4gQWxzbyBjbGVhciB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBpZiB3ZSdyZSB1c2luZyBDU1MsIGp1c3QgdG8gYmUgY2xlYW4uXG5cdFx0XHRcdFx0XHRpZiAoX3VzZVNWR1RyYW5zZm9ybUF0dHIgJiYgdC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0pIHtcblx0XHRcdFx0XHRcdFx0VHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAuMDAxLCBmdW5jdGlvbigpeyAvL2lmIHdlIGFwcGx5IHRoaXMgcmlnaHQgYXdheSAoYmVmb3JlIGFueXRoaW5nIGhhcyByZW5kZXJlZCksIHdlIHJpc2sgdGhlcmUgYmVpbmcgbm8gdHJhbnNmb3JtcyBmb3IgYSBicmllZiBtb21lbnQgYW5kIGl0IGFsc28gaW50ZXJmZXJlcyB3aXRoIGFkanVzdGluZyB0aGUgdHJhbnNmb3JtT3JpZ2luIGluIGEgdHdlZW4gd2l0aCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSAoaXQnZCB0cnkgcmVhZGluZyB0aGUgbWF0cml4IGFuZCBpdCB3b3VsZG4ndCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBkYXRhIGluIHBsYWNlIGJlY2F1c2Ugd2UganVzdCByZW1vdmVkIGl0KS5cblx0XHRcdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcCh0LnN0eWxlLCBfdHJhbnNmb3JtUHJvcCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICghX3VzZVNWR1RyYW5zZm9ybUF0dHIgJiYgdC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcblx0XHRcdFx0XHRcdFx0VHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAuMDAxLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdHQucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRtO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9mb3Igc2V0dGluZyAyRCB0cmFuc2Zvcm1zIGluIElFNiwgSUU3LCBhbmQgSUU4IChtdXN0IHVzZSBhIFwiZmlsdGVyXCIgdG8gZW11bGF0ZSB0aGUgYmVoYXZpb3Igb2YgbW9kZXJuIGRheSBicm93c2VyIHRyYW5zZm9ybXMpXG5cdFx0XHRfc2V0SUVUcmFuc2Zvcm1SYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLmRhdGEsIC8vcmVmZXJzIHRvIHRoZSBlbGVtZW50J3MgX2dzVHJhbnNmb3JtIG9iamVjdFxuXHRcdFx0XHRcdGFuZyA9IC10LnJvdGF0aW9uICogX0RFRzJSQUQsXG5cdFx0XHRcdFx0c2tldyA9IGFuZyArIHQuc2tld1ggKiBfREVHMlJBRCxcblx0XHRcdFx0XHRybmQgPSAxMDAwMDAsXG5cdFx0XHRcdFx0YSA9ICgoTWF0aC5jb3MoYW5nKSAqIHQuc2NhbGVYICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdGIgPSAoKE1hdGguc2luKGFuZykgKiB0LnNjYWxlWCAqIHJuZCkgfCAwKSAvIHJuZCxcblx0XHRcdFx0XHRjID0gKChNYXRoLnNpbihza2V3KSAqIC10LnNjYWxlWSAqIHJuZCkgfCAwKSAvIHJuZCxcblx0XHRcdFx0XHRkID0gKChNYXRoLmNvcyhza2V3KSAqIHQuc2NhbGVZICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdHN0eWxlID0gdGhpcy50LnN0eWxlLFxuXHRcdFx0XHRcdGNzID0gdGhpcy50LmN1cnJlbnRTdHlsZSxcblx0XHRcdFx0XHRmaWx0ZXJzLCB2YWw7XG5cdFx0XHRcdGlmICghY3MpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsID0gYjsgLy9qdXN0IGZvciBzd2FwcGluZyB0aGUgdmFyaWFibGVzIGFuIGludmVydGluZyB0aGVtIChyZXVzZWQgXCJ2YWxcIiB0byBhdm9pZCBjcmVhdGluZyBhbm90aGVyIHZhcmlhYmxlIGluIG1lbW9yeSkuIElFJ3MgZmlsdGVyIG1hdHJpeCB1c2VzIGEgbm9uLXN0YW5kYXJkIG1hdHJpeCBjb25maWd1cmF0aW9uIChhbmdsZSBnb2VzIHRoZSBvcHBvc2l0ZSB3YXksIGFuZCBiIGFuZCBjIGFyZSByZXZlcnNlZCBhbmQgaW52ZXJ0ZWQpXG5cdFx0XHRcdGIgPSAtYztcblx0XHRcdFx0YyA9IC12YWw7XG5cdFx0XHRcdGZpbHRlcnMgPSBjcy5maWx0ZXI7XG5cdFx0XHRcdHN0eWxlLmZpbHRlciA9IFwiXCI7IC8vcmVtb3ZlIGZpbHRlcnMgc28gdGhhdCB3ZSBjYW4gYWNjdXJhdGVseSBtZWFzdXJlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodFxuXHRcdFx0XHR2YXIgdyA9IHRoaXMudC5vZmZzZXRXaWR0aCxcblx0XHRcdFx0XHRoID0gdGhpcy50Lm9mZnNldEhlaWdodCxcblx0XHRcdFx0XHRjbGlwID0gKGNzLnBvc2l0aW9uICE9PSBcImFic29sdXRlXCIpLFxuXHRcdFx0XHRcdG0gPSBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPVwiICsgYSArIFwiLCBNMTI9XCIgKyBiICsgXCIsIE0yMT1cIiArIGMgKyBcIiwgTTIyPVwiICsgZCxcblx0XHRcdFx0XHRveCA9IHQueCArICh3ICogdC54UGVyY2VudCAvIDEwMCksXG5cdFx0XHRcdFx0b3kgPSB0LnkgKyAoaCAqIHQueVBlcmNlbnQgLyAxMDApLFxuXHRcdFx0XHRcdGR4LCBkeTtcblxuXHRcdFx0XHQvL2lmIHRyYW5zZm9ybU9yaWdpbiBpcyBiZWluZyB1c2VkLCBhZGp1c3QgdGhlIG9mZnNldCB4IGFuZCB5XG5cdFx0XHRcdGlmICh0Lm94ICE9IG51bGwpIHtcblx0XHRcdFx0XHRkeCA9ICgodC5veHApID8gdyAqIHQub3ggKiAwLjAxIDogdC5veCkgLSB3IC8gMjtcblx0XHRcdFx0XHRkeSA9ICgodC5veXApID8gaCAqIHQub3kgKiAwLjAxIDogdC5veSkgLSBoIC8gMjtcblx0XHRcdFx0XHRveCArPSBkeCAtIChkeCAqIGEgKyBkeSAqIGIpO1xuXHRcdFx0XHRcdG95ICs9IGR5IC0gKGR4ICogYyArIGR5ICogZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWNsaXApIHtcblx0XHRcdFx0XHRtICs9IFwiLCBzaXppbmdNZXRob2Q9J2F1dG8gZXhwYW5kJylcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkeCA9ICh3IC8gMik7XG5cdFx0XHRcdFx0ZHkgPSAoaCAvIDIpO1xuXHRcdFx0XHRcdC8vdHJhbnNsYXRlIHRvIGVuc3VyZSB0aGF0IHRyYW5zZm9ybWF0aW9ucyBvY2N1ciBhcm91bmQgdGhlIGNvcnJlY3Qgb3JpZ2luIChkZWZhdWx0IGlzIGNlbnRlcikuXG5cdFx0XHRcdFx0bSArPSBcIiwgRHg9XCIgKyAoZHggLSAoZHggKiBhICsgZHkgKiBiKSArIG94KSArIFwiLCBEeT1cIiArIChkeSAtIChkeCAqIGMgKyBkeSAqIGQpICsgb3kpICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGZpbHRlcnMuaW5kZXhPZihcIkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0c3R5bGUuZmlsdGVyID0gZmlsdGVycy5yZXBsYWNlKF9pZVNldE1hdHJpeEV4cCwgbSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGUuZmlsdGVyID0gbSArIFwiIFwiICsgZmlsdGVyczsgLy93ZSBtdXN0IGFsd2F5cyBwdXQgdGhlIHRyYW5zZm9ybS9tYXRyaXggRklSU1QgKGJlZm9yZSBhbHBoYShvcGFjaXR5PXh4KSkgdG8gYXZvaWQgYW4gSUUgYnVnIHRoYXQgc2xpY2VzIHBhcnQgb2YgdGhlIG9iamVjdCB3aGVuIHJvdGF0aW9uIGlzIGFwcGxpZWQgd2l0aCBhbHBoYS5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vYXQgdGhlIGVuZCBvciBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuLCBpZiB0aGUgbWF0cml4IGlzIG5vcm1hbCAoMSwgMCwgMCwgMSkgYW5kIG9wYWNpdHkgaXMgMTAwIChvciBkb2Vzbid0IGV4aXN0KSwgcmVtb3ZlIHRoZSBmaWx0ZXIgdG8gaW1wcm92ZSBicm93c2VyIHBlcmZvcm1hbmNlLlxuXHRcdFx0XHRpZiAodiA9PT0gMCB8fCB2ID09PSAxKSBpZiAoYSA9PT0gMSkgaWYgKGIgPT09IDApIGlmIChjID09PSAwKSBpZiAoZCA9PT0gMSkgaWYgKCFjbGlwIHx8IG0uaW5kZXhPZihcIkR4PTAsIER5PTBcIikgIT09IC0xKSBpZiAoIV9vcGFjaXR5RXhwLnRlc3QoZmlsdGVycykgfHwgcGFyc2VGbG9hdChSZWdFeHAuJDEpID09PSAxMDApIGlmIChmaWx0ZXJzLmluZGV4T2YoXCJncmFkaWVudChcIiAmJiBmaWx0ZXJzLmluZGV4T2YoXCJBbHBoYVwiKSkgPT09IC0xKSB7XG5cdFx0XHRcdFx0c3R5bGUucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly93ZSBtdXN0IHNldCB0aGUgbWFyZ2lucyBBRlRFUiBhcHBseWluZyB0aGUgZmlsdGVyIGluIG9yZGVyIHRvIGF2b2lkIHNvbWUgYnVncyBpbiBJRTggdGhhdCBjb3VsZCAoaW4gcmFyZSBzY2VuYXJpb3MpIGNhdXNlIHRoZW0gdG8gYmUgaWdub3JlZCBpbnRlcm1pdHRlbnRseSAodmlicmF0aW9uKS5cblx0XHRcdFx0aWYgKCFjbGlwKSB7XG5cdFx0XHRcdFx0dmFyIG11bHQgPSAoX2llVmVycyA8IDgpID8gMSA6IC0xLCAvL2luIEludGVybmV0IEV4cGxvcmVyIDcgYW5kIGJlZm9yZSwgdGhlIGJveCBtb2RlbCBpcyBicm9rZW4sIGNhdXNpbmcgdGhlIGJyb3dzZXIgdG8gdHJlYXQgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYWN0dWFsIHJvdGF0ZWQgZmlsdGVyZWQgaW1hZ2UgYXMgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYm94IGl0c2VsZiwgYnV0IE1pY3Jvc29mdCBjb3JyZWN0ZWQgdGhhdCBpbiBJRTguIFdlIG11c3QgdXNlIGEgbmVnYXRpdmUgb2Zmc2V0IGluIElFOCBvbiB0aGUgcmlnaHQvYm90dG9tXG5cdFx0XHRcdFx0XHRtYXJnLCBwcm9wLCBkaWY7XG5cdFx0XHRcdFx0ZHggPSB0LmllT2Zmc2V0WCB8fCAwO1xuXHRcdFx0XHRcdGR5ID0gdC5pZU9mZnNldFkgfHwgMDtcblx0XHRcdFx0XHR0LmllT2Zmc2V0WCA9IE1hdGgucm91bmQoKHcgLSAoKGEgPCAwID8gLWEgOiBhKSAqIHcgKyAoYiA8IDAgPyAtYiA6IGIpICogaCkpIC8gMiArIG94KTtcblx0XHRcdFx0XHR0LmllT2Zmc2V0WSA9IE1hdGgucm91bmQoKGggLSAoKGQgPCAwID8gLWQgOiBkKSAqIGggKyAoYyA8IDAgPyAtYyA6IGMpICogdykpIC8gMiArIG95KTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRwcm9wID0gX21hcmdpbnNbaV07XG5cdFx0XHRcdFx0XHRtYXJnID0gY3NbcHJvcF07XG5cdFx0XHRcdFx0XHQvL3dlIG5lZWQgdG8gZ2V0IHRoZSBjdXJyZW50IG1hcmdpbiBpbiBjYXNlIGl0IGlzIGJlaW5nIHR3ZWVuZWQgc2VwYXJhdGVseSAod2Ugd2FudCB0byByZXNwZWN0IHRoYXQgdHdlZW4ncyBjaGFuZ2VzKVxuXHRcdFx0XHRcdFx0dmFsID0gKG1hcmcuaW5kZXhPZihcInB4XCIpICE9PSAtMSkgPyBwYXJzZUZsb2F0KG1hcmcpIDogX2NvbnZlcnRUb1BpeGVscyh0aGlzLnQsIHByb3AsIHBhcnNlRmxvYXQobWFyZyksIG1hcmcucmVwbGFjZShfc3VmZml4RXhwLCBcIlwiKSkgfHwgMDtcblx0XHRcdFx0XHRcdGlmICh2YWwgIT09IHRbcHJvcF0pIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKGkgPCAyKSA/IC10LmllT2Zmc2V0WCA6IC10LmllT2Zmc2V0WTsgLy9pZiBhbm90aGVyIHR3ZWVuIGlzIGNvbnRyb2xsaW5nIGEgbWFyZ2luLCB3ZSBjYW5ub3Qgb25seSBhcHBseSB0aGUgZGlmZmVyZW5jZSBpbiB0aGUgaWVPZmZzZXRzLCBzbyB3ZSBlc3NlbnRpYWxseSB6ZXJvLW91dCB0aGUgZHggYW5kIGR5IGhlcmUgaW4gdGhhdCBjYXNlLiBXZSByZWNvcmQgdGhlIG1hcmdpbihzKSBsYXRlciBzbyB0aGF0IHdlIGNhbiBrZWVwIGNvbXBhcmluZyB0aGVtLCBtYWtpbmcgdGhpcyBjb2RlIHZlcnkgZmxleGlibGUuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoaSA8IDIpID8gZHggLSB0LmllT2Zmc2V0WCA6IGR5IC0gdC5pZU9mZnNldFk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzdHlsZVtwcm9wXSA9ICh0W3Byb3BdID0gTWF0aC5yb3VuZCggdmFsIC0gZGlmICogKChpID09PSAwIHx8IGkgPT09IDIpID8gMSA6IG11bHQpICkpICsgXCJweFwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyogdHJhbnNsYXRlcyBhIHN1cGVyIHNtYWxsIGRlY2ltYWwgdG8gYSBzdHJpbmcgV0lUSE9VVCBzY2llbnRpZmljIG5vdGF0aW9uXG5cdFx0XHRfc2FmZURlY2ltYWwgPSBmdW5jdGlvbihuKSB7XG5cdFx0XHRcdHZhciBzID0gKG4gPCAwID8gLW4gOiBuKSArIFwiXCIsXG5cdFx0XHRcdFx0YSA9IHMuc3BsaXQoXCJlLVwiKTtcblx0XHRcdFx0cmV0dXJuIChuIDwgMCA/IFwiLTAuXCIgOiBcIjAuXCIpICsgbmV3IEFycmF5KHBhcnNlSW50KGFbMV0sIDEwKSB8fCAwKS5qb2luKFwiMFwiKSArIGFbMF0uc3BsaXQoXCIuXCIpLmpvaW4oXCJcIik7XG5cdFx0XHR9LFxuXHRcdFx0Ki9cblxuXHRcdFx0X3NldFRyYW5zZm9ybVJhdGlvID0gX2ludGVybmFscy5zZXQzRFRyYW5zZm9ybVJhdGlvID0gX2ludGVybmFscy5zZXRUcmFuc2Zvcm1SYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLmRhdGEsIC8vcmVmZXJzIHRvIHRoZSBlbGVtZW50J3MgX2dzVHJhbnNmb3JtIG9iamVjdFxuXHRcdFx0XHRcdHN0eWxlID0gdGhpcy50LnN0eWxlLFxuXHRcdFx0XHRcdGFuZ2xlID0gdC5yb3RhdGlvbixcblx0XHRcdFx0XHRyb3RhdGlvblggPSB0LnJvdGF0aW9uWCxcblx0XHRcdFx0XHRyb3RhdGlvblkgPSB0LnJvdGF0aW9uWSxcblx0XHRcdFx0XHRzeCA9IHQuc2NhbGVYLFxuXHRcdFx0XHRcdHN5ID0gdC5zY2FsZVksXG5cdFx0XHRcdFx0c3ogPSB0LnNjYWxlWixcblx0XHRcdFx0XHR4ID0gdC54LFxuXHRcdFx0XHRcdHkgPSB0LnksXG5cdFx0XHRcdFx0eiA9IHQueixcblx0XHRcdFx0XHRpc1NWRyA9IHQuc3ZnLFxuXHRcdFx0XHRcdHBlcnNwZWN0aXZlID0gdC5wZXJzcGVjdGl2ZSxcblx0XHRcdFx0XHRmb3JjZTNEID0gdC5mb3JjZTNELFxuXHRcdFx0XHRcdGExMSwgYTEyLCBhMTMsIGEyMSwgYTIyLCBhMjMsIGEzMSwgYTMyLCBhMzMsIGE0MSwgYTQyLCBhNDMsXG5cdFx0XHRcdFx0ek9yaWdpbiwgbWluLCBjb3MsIHNpbiwgdDEsIHQyLCB0cmFuc2Zvcm0sIGNvbW1hLCB6ZXJvLCBza2V3LCBybmQ7XG5cdFx0XHRcdC8vY2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCByZW5kZXIgYXMgMkQgKGFuZCBTVkdzIG11c3QgdXNlIDJEIHdoZW4gX3VzZVNWR1RyYW5zZm9ybUF0dHIgaXMgdHJ1ZSlcblx0XHRcdFx0aWYgKCgoKCh2ID09PSAxIHx8IHYgPT09IDApICYmIGZvcmNlM0QgPT09IFwiYXV0b1wiICYmICh0aGlzLnR3ZWVuLl90b3RhbFRpbWUgPT09IHRoaXMudHdlZW4uX3RvdGFsRHVyYXRpb24gfHwgIXRoaXMudHdlZW4uX3RvdGFsVGltZSkpIHx8ICFmb3JjZTNEKSAmJiAheiAmJiAhcGVyc3BlY3RpdmUgJiYgIXJvdGF0aW9uWSAmJiAhcm90YXRpb25YICYmIHN6ID09PSAxKSB8fCAoX3VzZVNWR1RyYW5zZm9ybUF0dHIgJiYgaXNTVkcpIHx8ICFfc3VwcG9ydHMzRCkgeyAvL29uIHRoZSBmaW5hbCByZW5kZXIgKHdoaWNoIGNvdWxkIGJlIDAgZm9yIGEgZnJvbSB0d2VlbiksIGlmIHRoZXJlIGFyZSBubyAzRCBhc3BlY3RzLCByZW5kZXIgaW4gMkQgdG8gZnJlZSB1cCBtZW1vcnkgYW5kIGltcHJvdmUgcGVyZm9ybWFuY2UgZXNwZWNpYWxseSBvbiBtb2JpbGUgZGV2aWNlcy4gQ2hlY2sgdGhlIHR3ZWVuJ3MgdG90YWxUaW1lL3RvdGFsRHVyYXRpb24gdG9vIGluIG9yZGVyIHRvIG1ha2Ugc3VyZSBpdCBkb2Vzbid0IGhhcHBlbiBiZXR3ZWVuIHJlcGVhdHMgaWYgaXQncyBhIHJlcGVhdGluZyB0d2Vlbi5cblxuXHRcdFx0XHRcdC8vMkRcblx0XHRcdFx0XHRpZiAoYW5nbGUgfHwgdC5za2V3WCB8fCBpc1NWRykge1xuXHRcdFx0XHRcdFx0YW5nbGUgKj0gX0RFRzJSQUQ7XG5cdFx0XHRcdFx0XHRza2V3ID0gdC5za2V3WCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRcdFx0cm5kID0gMTAwMDAwO1xuXHRcdFx0XHRcdFx0YTExID0gTWF0aC5jb3MoYW5nbGUpICogc3g7XG5cdFx0XHRcdFx0XHRhMjEgPSBNYXRoLnNpbihhbmdsZSkgKiBzeDtcblx0XHRcdFx0XHRcdGExMiA9IE1hdGguc2luKGFuZ2xlIC0gc2tldykgKiAtc3k7XG5cdFx0XHRcdFx0XHRhMjIgPSBNYXRoLmNvcyhhbmdsZSAtIHNrZXcpICogc3k7XG5cdFx0XHRcdFx0XHRpZiAoc2tldyAmJiB0LnNrZXdUeXBlID09PSBcInNpbXBsZVwiKSB7IC8vYnkgZGVmYXVsdCwgd2UgY29tcGVuc2F0ZSBza2V3aW5nIG9uIHRoZSBvdGhlciBheGlzIHRvIG1ha2UgaXQgbG9vayBtb3JlIG5hdHVyYWwsIGJ1dCB5b3UgY2FuIHNldCB0aGUgc2tld1R5cGUgdG8gXCJzaW1wbGVcIiB0byB1c2UgdGhlIHVuY29tcGVuc2F0ZWQgc2tld2luZyB0aGF0IENTUyBkb2VzXG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4oc2tldyk7XG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC5zcXJ0KDEgKyB0MSAqIHQxKTtcblx0XHRcdFx0XHRcdFx0YTEyICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRhMjIgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdGlmICh0LnNrZXdZKSB7XG5cdFx0XHRcdFx0XHRcdFx0YTExICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRcdGEyMSAqPSB0MTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGlzU1ZHKSB7XG5cdFx0XHRcdFx0XHRcdHggKz0gdC54T3JpZ2luIC0gKHQueE9yaWdpbiAqIGExMSArIHQueU9yaWdpbiAqIGExMikgKyB0LnhPZmZzZXQ7XG5cdFx0XHRcdFx0XHRcdHkgKz0gdC55T3JpZ2luIC0gKHQueE9yaWdpbiAqIGEyMSArIHQueU9yaWdpbiAqIGEyMikgKyB0LnlPZmZzZXQ7XG5cdFx0XHRcdFx0XHRcdGlmIChfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiAodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSkgeyAvL1RoZSBTVkcgc3BlYyBkb2Vzbid0IHN1cHBvcnQgcGVyY2VudGFnZS1iYXNlZCB0cmFuc2xhdGlvbiBpbiB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHNvIHdlIG1lcmdlIGl0IGludG8gdGhlIG1hdHJpeCB0byBzaW11bGF0ZSBpdC5cblx0XHRcdFx0XHRcdFx0XHRtaW4gPSB0aGlzLnQuZ2V0QkJveCgpO1xuXHRcdFx0XHRcdFx0XHRcdHggKz0gdC54UGVyY2VudCAqIDAuMDEgKiBtaW4ud2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0eSArPSB0LnlQZXJjZW50ICogMC4wMSAqIG1pbi5oZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bWluID0gMC4wMDAwMDE7XG5cdFx0XHRcdFx0XHRcdGlmICh4IDwgbWluKSBpZiAoeCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdFx0XHR4ID0gMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoeSA8IG1pbikgaWYgKHkgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRyYW5zZm9ybSA9ICgoKGExMSAqIHJuZCkgfCAwKSAvIHJuZCkgKyBcIixcIiArICgoKGEyMSAqIHJuZCkgfCAwKSAvIHJuZCkgKyBcIixcIiArICgoKGExMiAqIHJuZCkgfCAwKSAvIHJuZCkgKyBcIixcIiArICgoKGEyMiAqIHJuZCkgfCAwKSAvIHJuZCkgKyBcIixcIiArIHggKyBcIixcIiArIHkgKyBcIilcIjtcblx0XHRcdFx0XHRcdGlmIChpc1NWRyAmJiBfdXNlU1ZHVHJhbnNmb3JtQXR0cikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwibWF0cml4KFwiICsgdHJhbnNmb3JtKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vc29tZSBicm93c2VycyBoYXZlIGEgaGFyZCB0aW1lIHdpdGggdmVyeSBzbWFsbCB2YWx1ZXMgbGlrZSAyLjQ0OTI5MzU5ODI5NDcwNjRlLTE2IChub3RpY2UgdGhlIFwiZS1cIiB0b3dhcmRzIHRoZSBlbmQpIGFuZCB3b3VsZCByZW5kZXIgdGhlIG9iamVjdCBzbGlnaHRseSBvZmYuIFNvIHdlIHJvdW5kIHRvIDUgZGVjaW1hbCBwbGFjZXMuXG5cdFx0XHRcdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIG1hdHJpeChcIiA6IFwibWF0cml4KFwiKSArIHRyYW5zZm9ybTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgbWF0cml4KFwiIDogXCJtYXRyaXgoXCIpICsgc3ggKyBcIiwwLDAsXCIgKyBzeSArIFwiLFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2lzRmlyZWZveCkgeyAvL0ZpcmVmb3ggaGFzIGEgYnVnIChhdCBsZWFzdCBpbiB2MjUpIHRoYXQgY2F1c2VzIGl0IHRvIHJlbmRlciB0aGUgdHJhbnNwYXJlbnQgcGFydCBvZiAzMi1iaXQgUE5HIGltYWdlcyBhcyBibGFjayB3aGVuIGRpc3BsYXllZCBpbnNpZGUgYW4gaWZyYW1lIGFuZCB0aGUgM0Qgc2NhbGUgaXMgdmVyeSBzbWFsbCBhbmQgZG9lc24ndCBjaGFuZ2Ugc3VmZmljaWVudGx5IGVub3VnaCBiZXR3ZWVuIHJlbmRlcnMgKGxpa2UgaWYgeW91IHVzZSBhIFBvd2VyNC5lYXNlSW5PdXQgdG8gc2NhbGUgZnJvbSAwIHRvIDEgd2hlcmUgdGhlIGJlZ2lubmluZyB2YWx1ZXMgb25seSBjaGFuZ2UgYSB0aW55IGFtb3VudCB0byBiZWdpbiB0aGUgdHdlZW4gYmVmb3JlIGFjY2VsZXJhdGluZykuIEluIHRoaXMgY2FzZSwgd2UgZm9yY2UgdGhlIHNjYWxlIHRvIGJlIDAuMDAwMDIgaW5zdGVhZCB3aGljaCBpcyB2aXN1YWxseSB0aGUgc2FtZSBidXQgd29ya3MgYXJvdW5kIHRoZSBGaXJlZm94IGlzc3VlLlxuXHRcdFx0XHRcdG1pbiA9IDAuMDAwMTtcblx0XHRcdFx0XHRpZiAoc3ggPCBtaW4gJiYgc3ggPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRzeCA9IHN6ID0gMC4wMDAwMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHN5IDwgbWluICYmIHN5ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0c3kgPSBzeiA9IDAuMDAwMDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwZXJzcGVjdGl2ZSAmJiAhdC56ICYmICF0LnJvdGF0aW9uWCAmJiAhdC5yb3RhdGlvblkpIHsgLy9GaXJlZm94IGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyBlbGVtZW50cyB0byBoYXZlIGFuIG9kZCBzdXBlci10aGluLCBicm9rZW4vZG90dGVkIGJsYWNrIGJvcmRlciBvbiBlbGVtZW50cyB0aGF0IGhhdmUgYSBwZXJzcGVjdGl2ZSBzZXQgYnV0IGFyZW4ndCB1dGlsaXppbmcgM0Qgc3BhY2UgKG5vIHJvdGF0aW9uWCwgcm90YXRpb25ZLCBvciB6KS5cblx0XHRcdFx0XHRcdHBlcnNwZWN0aXZlID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFuZ2xlIHx8IHQuc2tld1gpIHtcblx0XHRcdFx0XHRhbmdsZSAqPSBfREVHMlJBRDtcblx0XHRcdFx0XHRjb3MgPSBhMTEgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gYTIxID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdGlmICh0LnNrZXdYKSB7XG5cdFx0XHRcdFx0XHRhbmdsZSAtPSB0LnNrZXdYICogX0RFRzJSQUQ7XG5cdFx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRcdFx0XHRpZiAodC5za2V3VHlwZSA9PT0gXCJzaW1wbGVcIikgeyAvL2J5IGRlZmF1bHQsIHdlIGNvbXBlbnNhdGUgc2tld2luZyBvbiB0aGUgb3RoZXIgYXhpcyB0byBtYWtlIGl0IGxvb2sgbW9yZSBuYXR1cmFsLCBidXQgeW91IGNhbiBzZXQgdGhlIHNrZXdUeXBlIHRvIFwic2ltcGxlXCIgdG8gdXNlIHRoZSB1bmNvbXBlbnNhdGVkIHNrZXdpbmcgdGhhdCBDU1MgZG9lc1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGgudGFuKHQuc2tld1ggKiBfREVHMlJBRCk7XG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC5zcXJ0KDEgKyB0MSAqIHQxKTtcblx0XHRcdFx0XHRcdFx0Y29zICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRzaW4gKj0gdDE7XG5cdFx0XHRcdFx0XHRcdGlmICh0LnNrZXdZKSB7XG5cdFx0XHRcdFx0XHRcdFx0YTExICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRcdGEyMSAqPSB0MTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhMTIgPSAtc2luO1xuXHRcdFx0XHRcdGEyMiA9IGNvcztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCFyb3RhdGlvblkgJiYgIXJvdGF0aW9uWCAmJiBzeiA9PT0gMSAmJiAhcGVyc3BlY3RpdmUgJiYgIWlzU1ZHKSB7IC8vaWYgd2UncmUgb25seSB0cmFuc2xhdGluZyBhbmQvb3IgMkQgc2NhbGluZywgdGhpcyBpcyBmYXN0ZXIuLi5cblx0XHRcdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoKHQueFBlcmNlbnQgfHwgdC55UGVyY2VudCkgPyBcInRyYW5zbGF0ZShcIiArIHQueFBlcmNlbnQgKyBcIiUsXCIgKyB0LnlQZXJjZW50ICsgXCIlKSB0cmFuc2xhdGUzZChcIiA6IFwidHJhbnNsYXRlM2QoXCIpICsgeCArIFwicHgsXCIgKyB5ICsgXCJweCxcIiArIHogK1wicHgpXCIgKyAoKHN4ICE9PSAxIHx8IHN5ICE9PSAxKSA/IFwiIHNjYWxlKFwiICsgc3ggKyBcIixcIiArIHN5ICsgXCIpXCIgOiBcIlwiKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YTExID0gYTIyID0gMTtcblx0XHRcdFx0XHRhMTIgPSBhMjEgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEtFWSAgSU5ERVggICBBRkZFQ1RTXG5cdFx0XHRcdC8vIGExMSAgMCAgICAgICByb3RhdGlvbiwgcm90YXRpb25ZLCBzY2FsZVhcblx0XHRcdFx0Ly8gYTIxICAxICAgICAgIHJvdGF0aW9uLCByb3RhdGlvblksIHNjYWxlWFxuXHRcdFx0XHQvLyBhMzEgIDIgICAgICAgcm90YXRpb25ZLCBzY2FsZVhcblx0XHRcdFx0Ly8gYTQxICAzICAgICAgIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGExMiAgNCAgICAgICByb3RhdGlvbiwgc2tld1gsIHJvdGF0aW9uWCwgc2NhbGVZXG5cdFx0XHRcdC8vIGEyMiAgNSAgICAgICByb3RhdGlvbiwgc2tld1gsIHJvdGF0aW9uWCwgc2NhbGVZXG5cdFx0XHRcdC8vIGEzMiAgNiAgICAgICByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhNDIgIDcgICAgICAgcm90YXRpb25YLCBzY2FsZVlcblx0XHRcdFx0Ly8gYTEzICA4ICAgICAgIHJvdGF0aW9uWSwgcm90YXRpb25YLCBzY2FsZVpcblx0XHRcdFx0Ly8gYTIzICA5ICAgICAgIHJvdGF0aW9uWSwgcm90YXRpb25YLCBzY2FsZVpcblx0XHRcdFx0Ly8gYTMzICAxMCAgICAgIHJvdGF0aW9uWSwgcm90YXRpb25YLCBzY2FsZVpcblx0XHRcdFx0Ly8gYTQzICAxMSAgICAgIHJvdGF0aW9uWSwgcm90YXRpb25YLCBwZXJzcGVjdGl2ZSwgc2NhbGVaXG5cdFx0XHRcdC8vIGExNCAgMTIgICAgICB4LCB6T3JpZ2luLCBzdmdPcmlnaW5cblx0XHRcdFx0Ly8gYTI0ICAxMyAgICAgIHksIHpPcmlnaW4sIHN2Z09yaWdpblxuXHRcdFx0XHQvLyBhMzQgIDE0ICAgICAgeiwgek9yaWdpblxuXHRcdFx0XHQvLyBhNDQgIDE1XG5cdFx0XHRcdC8vIHJvdGF0aW9uOiBNYXRoLmF0YW4yKGEyMSwgYTExKVxuXHRcdFx0XHQvLyByb3RhdGlvblk6IE1hdGguYXRhbjIoYTEzLCBhMzMpIChvciBNYXRoLmF0YW4yKGExMywgYTExKSlcblx0XHRcdFx0Ly8gcm90YXRpb25YOiBNYXRoLmF0YW4yKGEzMiwgYTMzKVxuXHRcdFx0XHRhMzMgPSAxO1xuXHRcdFx0XHRhMTMgPSBhMjMgPSBhMzEgPSBhMzIgPSBhNDEgPSBhNDIgPSAwO1xuXHRcdFx0XHRhNDMgPSAocGVyc3BlY3RpdmUpID8gLTEgLyBwZXJzcGVjdGl2ZSA6IDA7XG5cdFx0XHRcdHpPcmlnaW4gPSB0LnpPcmlnaW47XG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxOyAvL3RocmVzaG9sZCBiZWxvdyB3aGljaCBicm93c2VycyB1c2Ugc2NpZW50aWZpYyBub3RhdGlvbiB3aGljaCB3b24ndCB3b3JrLlxuXHRcdFx0XHRjb21tYSA9IFwiLFwiO1xuXHRcdFx0XHR6ZXJvID0gXCIwXCI7XG5cdFx0XHRcdGFuZ2xlID0gcm90YXRpb25ZICogX0RFRzJSQUQ7XG5cdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRcdFx0YTMxID0gLXNpbjtcblx0XHRcdFx0XHRhNDEgPSBhNDMqLXNpbjtcblx0XHRcdFx0XHRhMTMgPSBhMTEqc2luO1xuXHRcdFx0XHRcdGEyMyA9IGEyMSpzaW47XG5cdFx0XHRcdFx0YTMzID0gY29zO1xuXHRcdFx0XHRcdGE0MyAqPSBjb3M7XG5cdFx0XHRcdFx0YTExICo9IGNvcztcblx0XHRcdFx0XHRhMjEgKj0gY29zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFuZ2xlID0gcm90YXRpb25YICogX0RFRzJSQUQ7XG5cdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRcdFx0dDEgPSBhMTIqY29zK2ExMypzaW47XG5cdFx0XHRcdFx0dDIgPSBhMjIqY29zK2EyMypzaW47XG5cdFx0XHRcdFx0YTMyID0gYTMzKnNpbjtcblx0XHRcdFx0XHRhNDIgPSBhNDMqc2luO1xuXHRcdFx0XHRcdGExMyA9IGExMiotc2luK2ExMypjb3M7XG5cdFx0XHRcdFx0YTIzID0gYTIyKi1zaW4rYTIzKmNvcztcblx0XHRcdFx0XHRhMzMgPSBhMzMqY29zO1xuXHRcdFx0XHRcdGE0MyA9IGE0Mypjb3M7XG5cdFx0XHRcdFx0YTEyID0gdDE7XG5cdFx0XHRcdFx0YTIyID0gdDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN6ICE9PSAxKSB7XG5cdFx0XHRcdFx0YTEzKj1zejtcblx0XHRcdFx0XHRhMjMqPXN6O1xuXHRcdFx0XHRcdGEzMyo9c3o7XG5cdFx0XHRcdFx0YTQzKj1zejtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3kgIT09IDEpIHtcblx0XHRcdFx0XHRhMTIqPXN5O1xuXHRcdFx0XHRcdGEyMio9c3k7XG5cdFx0XHRcdFx0YTMyKj1zeTtcblx0XHRcdFx0XHRhNDIqPXN5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeCAhPT0gMSkge1xuXHRcdFx0XHRcdGExMSo9c3g7XG5cdFx0XHRcdFx0YTIxKj1zeDtcblx0XHRcdFx0XHRhMzEqPXN4O1xuXHRcdFx0XHRcdGE0MSo9c3g7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoek9yaWdpbiB8fCBpc1NWRykge1xuXHRcdFx0XHRcdGlmICh6T3JpZ2luKSB7XG5cdFx0XHRcdFx0XHR4ICs9IGExMyotek9yaWdpbjtcblx0XHRcdFx0XHRcdHkgKz0gYTIzKi16T3JpZ2luO1xuXHRcdFx0XHRcdFx0eiArPSBhMzMqLXpPcmlnaW4rek9yaWdpbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGlzU1ZHKSB7IC8vZHVlIHRvIGJ1Z3MgaW4gc29tZSBicm93c2Vycywgd2UgbmVlZCB0byBtYW5hZ2UgdGhlIHRyYW5zZm9ybS1vcmlnaW4gb2YgU1ZHIG1hbnVhbGx5XG5cdFx0XHRcdFx0XHR4ICs9IHQueE9yaWdpbiAtICh0LnhPcmlnaW4gKiBhMTEgKyB0LnlPcmlnaW4gKiBhMTIpICsgdC54T2Zmc2V0O1xuXHRcdFx0XHRcdFx0eSArPSB0LnlPcmlnaW4gLSAodC54T3JpZ2luICogYTIxICsgdC55T3JpZ2luICogYTIyKSArIHQueU9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHggPCBtaW4gJiYgeCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHggPSB6ZXJvO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeSA8IG1pbiAmJiB5ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0eSA9IHplcm87XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh6IDwgbWluICYmIHogPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR6ID0gMDsgLy9kb24ndCB1c2Ugc3RyaW5nIGJlY2F1c2Ugd2UgY2FsY3VsYXRlIHBlcnNwZWN0aXZlIGxhdGVyIGFuZCBuZWVkIHRoZSBudW1iZXIuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9vcHRpbWl6ZWQgd2F5IG9mIGNvbmNhdGVuYXRpbmcgYWxsIHRoZSB2YWx1ZXMgaW50byBhIHN0cmluZy4gSWYgd2UgZG8gaXQgYWxsIGluIG9uZSBzaG90LCBpdCdzIHNsb3dlciBiZWNhdXNlIG9mIHRoZSB3YXkgYnJvd3NlcnMgaGF2ZSB0byBjcmVhdGUgdGVtcCBzdHJpbmdzIGFuZCB0aGUgd2F5IGl0IGFmZmVjdHMgbWVtb3J5LiBJZiB3ZSBkbyBpdCBwaWVjZS1ieS1waWVjZSB3aXRoICs9LCBpdCdzIGEgYml0IHNsb3dlciB0b28uIFdlIGZvdW5kIHRoYXQgZG9pbmcgaXQgaW4gdGhlc2Ugc2l6ZWQgY2h1bmtzIHdvcmtzIGJlc3Qgb3ZlcmFsbDpcblx0XHRcdFx0dHJhbnNmb3JtID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgbWF0cml4M2QoXCIgOiBcIm1hdHJpeDNkKFwiKTtcblx0XHRcdFx0dHJhbnNmb3JtICs9ICgoYTExIDwgbWluICYmIGExMSA+IC1taW4pID8gemVybyA6IGExMSkgKyBjb21tYSArICgoYTIxIDwgbWluICYmIGEyMSA+IC1taW4pID8gemVybyA6IGEyMSkgKyBjb21tYSArICgoYTMxIDwgbWluICYmIGEzMSA+IC1taW4pID8gemVybyA6IGEzMSk7XG5cdFx0XHRcdHRyYW5zZm9ybSArPSBjb21tYSArICgoYTQxIDwgbWluICYmIGE0MSA+IC1taW4pID8gemVybyA6IGE0MSkgKyBjb21tYSArICgoYTEyIDwgbWluICYmIGExMiA+IC1taW4pID8gemVybyA6IGExMikgKyBjb21tYSArICgoYTIyIDwgbWluICYmIGEyMiA+IC1taW4pID8gemVybyA6IGEyMik7XG5cdFx0XHRcdGlmIChyb3RhdGlvblggfHwgcm90YXRpb25ZIHx8IHN6ICE9PSAxKSB7IC8vcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIChvZnRlbiB0aGVyZSdzIG5vIHJvdGF0aW9uWCBvciByb3RhdGlvblksIHNvIHdlIGNhbiBza2lwIHRoZXNlIGNhbGN1bGF0aW9ucylcblx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGEzMiA8IG1pbiAmJiBhMzIgPiAtbWluKSA/IHplcm8gOiBhMzIpICsgY29tbWEgKyAoKGE0MiA8IG1pbiAmJiBhNDIgPiAtbWluKSA/IHplcm8gOiBhNDIpICsgY29tbWEgKyAoKGExMyA8IG1pbiAmJiBhMTMgPiAtbWluKSA/IHplcm8gOiBhMTMpO1xuXHRcdFx0XHRcdHRyYW5zZm9ybSArPSBjb21tYSArICgoYTIzIDwgbWluICYmIGEyMyA+IC1taW4pID8gemVybyA6IGEyMykgKyBjb21tYSArICgoYTMzIDwgbWluICYmIGEzMyA+IC1taW4pID8gemVybyA6IGEzMykgKyBjb21tYSArICgoYTQzIDwgbWluICYmIGE0MyA+IC1taW4pID8gemVybyA6IGE0MykgKyBjb21tYTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gXCIsMCwwLDAsMCwxLDAsXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJhbnNmb3JtICs9IHggKyBjb21tYSArIHkgKyBjb21tYSArIHogKyBjb21tYSArIChwZXJzcGVjdGl2ZSA/ICgxICsgKC16IC8gcGVyc3BlY3RpdmUpKSA6IDEpICsgXCIpXCI7XG5cblx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXHRcdFx0fTtcblxuXHRcdHAgPSBUcmFuc2Zvcm0ucHJvdG90eXBlO1xuXHRcdHAueCA9IHAueSA9IHAueiA9IHAuc2tld1ggPSBwLnNrZXdZID0gcC5yb3RhdGlvbiA9IHAucm90YXRpb25YID0gcC5yb3RhdGlvblkgPSBwLnpPcmlnaW4gPSBwLnhQZXJjZW50ID0gcC55UGVyY2VudCA9IHAueE9mZnNldCA9IHAueU9mZnNldCA9IDA7XG5cdFx0cC5zY2FsZVggPSBwLnNjYWxlWSA9IHAuc2NhbGVaID0gMTtcblxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInRyYW5zZm9ybSxzY2FsZSxzY2FsZVgsc2NhbGVZLHNjYWxlWix4LHkseixyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHJvdGF0aW9uWixza2V3WCxza2V3WSxzaG9ydFJvdGF0aW9uLHNob3J0Um90YXRpb25YLHNob3J0Um90YXRpb25ZLHNob3J0Um90YXRpb25aLHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW4sdHJhbnNmb3JtUGVyc3BlY3RpdmUsZGlyZWN0aW9uYWxSb3RhdGlvbixwYXJzZVRyYW5zZm9ybSxmb3JjZTNELHNrZXdUeXBlLHhQZXJjZW50LHlQZXJjZW50LHNtb290aE9yaWdpblwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdGlmIChjc3NwLl9sYXN0UGFyc2VkVHJhbnNmb3JtID09PSB2YXJzKSB7IHJldHVybiBwdDsgfSAvL29ubHkgbmVlZCB0byBwYXJzZSB0aGUgdHJhbnNmb3JtIG9uY2UsIGFuZCBvbmx5IGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGl0LlxuXHRcdFx0Y3NzcC5fbGFzdFBhcnNlZFRyYW5zZm9ybSA9IHZhcnM7XG5cdFx0XHR2YXIgb3JpZ2luYWxHU1RyYW5zZm9ybSA9IHQuX2dzVHJhbnNmb3JtLFxuXHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRpID0gX3RyYW5zZm9ybVByb3BzLmxlbmd0aCxcblx0XHRcdFx0diA9IHZhcnMsXG5cdFx0XHRcdGVuZFJvdGF0aW9ucyA9IHt9LFxuXHRcdFx0XHR0cmFuc2Zvcm1PcmlnaW5TdHJpbmcgPSBcInRyYW5zZm9ybU9yaWdpblwiLFxuXHRcdFx0XHRtMSwgbTIsIGNvcHksIG9yaWcsIGhhczNELCBoYXNDaGFuZ2UsIGRyLCB4LCB5LCBtYXRyaXg7XG5cdFx0XHRpZiAodmFycy5kaXNwbGF5KSB7IC8vaWYgdGhlIHVzZXIgaXMgc2V0dGluZyBkaXNwbGF5IGR1cmluZyB0aGlzIHR3ZWVuLCBpdCBtYXkgbm90IGJlIGluc3RhbnRpYXRlZCB5ZXQgYnV0IHdlIG11c3QgZm9yY2UgaXQgaGVyZSBpbiBvcmRlciB0byBnZXQgYWNjdXJhdGUgcmVhZGluZ3MuIElmIGRpc3BsYXkgaXMgXCJub25lXCIsIHNvbWUgYnJvd3NlcnMgcmVmdXNlIHRvIHJlcG9ydCB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgY29ycmVjdGx5LlxuXHRcdFx0XHRjb3B5ID0gX2dldFN0eWxlKHQsIFwiZGlzcGxheVwiKTtcblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0XHRcdFx0bTEgPSBfZ2V0VHJhbnNmb3JtKHQsIF9jcywgdHJ1ZSwgdmFycy5wYXJzZVRyYW5zZm9ybSk7XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBjb3B5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bTEgPSBfZ2V0VHJhbnNmb3JtKHQsIF9jcywgdHJ1ZSwgdmFycy5wYXJzZVRyYW5zZm9ybSk7XG5cdFx0XHR9XG5cdFx0XHRjc3NwLl90cmFuc2Zvcm0gPSBtMTtcblx0XHRcdGlmICh0eXBlb2Yodi50cmFuc2Zvcm0pID09PSBcInN0cmluZ1wiICYmIF90cmFuc2Zvcm1Qcm9wKSB7IC8vZm9yIHZhbHVlcyBsaWtlIHRyYW5zZm9ybTpcInJvdGF0ZSg2MGRlZykgc2NhbGUoMC41LCAwLjgpXCJcblx0XHRcdFx0Y29weSA9IF90ZW1wRGl2LnN0eWxlOyAvL2Rvbid0IHVzZSB0aGUgb3JpZ2luYWwgdGFyZ2V0IGJlY2F1c2UgaXQgbWlnaHQgYmUgU1ZHIGluIHdoaWNoIGNhc2Ugc29tZSBicm93c2VycyBkb24ndCByZXBvcnQgY29tcHV0ZWQgc3R5bGUgY29ycmVjdGx5LlxuXHRcdFx0XHRjb3B5W190cmFuc2Zvcm1Qcm9wXSA9IHYudHJhbnNmb3JtO1xuXHRcdFx0XHRjb3B5LmRpc3BsYXkgPSBcImJsb2NrXCI7IC8vaWYgZGlzcGxheSBpcyBcIm5vbmVcIiwgdGhlIGJyb3dzZXIgb2Z0ZW4gcmVmdXNlcyB0byByZXBvcnQgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGNvcnJlY3RseS5cblx0XHRcdFx0Y29weS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRcdFx0X2RvYy5ib2R5LmFwcGVuZENoaWxkKF90ZW1wRGl2KTtcblx0XHRcdFx0bTIgPSBfZ2V0VHJhbnNmb3JtKF90ZW1wRGl2LCBudWxsLCBmYWxzZSk7XG5cdFx0XHRcdGlmIChtMS5zdmcpIHsgLy9pZiBpdCdzIGFuIFNWRyBlbGVtZW50LCB4L3kgcGFydCBvZiB0aGUgbWF0cml4IHdpbGwgYmUgYWZmZWN0ZWQgYnkgd2hhdGV2ZXIgd2UgdXNlIGFzIHRoZSBvcmlnaW4gYW5kIHRoZSBvZmZzZXRzLCBzbyBjb21wZW5zYXRlIGhlcmUuLi5cblx0XHRcdFx0XHR4ID0gbTEueE9yaWdpbjtcblx0XHRcdFx0XHR5ID0gbTEueU9yaWdpbjtcblx0XHRcdFx0XHRtMi54IC09IG0xLnhPZmZzZXQ7XG5cdFx0XHRcdFx0bTIueSAtPSBtMS55T2Zmc2V0O1xuXHRcdFx0XHRcdGlmICh2LnRyYW5zZm9ybU9yaWdpbiB8fCB2LnN2Z09yaWdpbikgeyAvL2lmIHRoaXMgdHdlZW4gaXMgYWx0ZXJpbmcgdGhlIG9yaWdpbiwgd2UgbXVzdCBmYWN0b3IgdGhhdCBpbiBoZXJlLiBUaGUgYWN0dWFsIHdvcmsgb2YgcmVjb3JkaW5nIHRoZSB0cmFuc2Zvcm1PcmlnaW4gdmFsdWVzIGFuZCBzZXR0aW5nIHVwIHRoZSBQcm9wVHdlZW4gaXMgZG9uZSBsYXRlciAoc3RpbGwgaW5zaWRlIHRoaXMgZnVuY3Rpb24pIHNvIHdlIGNhbm5vdCBsZWF2ZSB0aGUgY2hhbmdlcyBpbnRhY3QgaGVyZSAtIHdlIG9ubHkgd2FudCB0byB1cGRhdGUgdGhlIHgveSBhY2NvcmRpbmdseS5cblx0XHRcdFx0XHRcdG9yaWcgPSB7fTtcblx0XHRcdFx0XHRcdF9wYXJzZVNWR09yaWdpbih0LCBfcGFyc2VQb3NpdGlvbih2LnRyYW5zZm9ybU9yaWdpbiksIG9yaWcsIHYuc3ZnT3JpZ2luLCB2LnNtb290aE9yaWdpbiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR4ID0gb3JpZy54T3JpZ2luO1xuXHRcdFx0XHRcdFx0eSA9IG9yaWcueU9yaWdpbjtcblx0XHRcdFx0XHRcdG0yLnggLT0gb3JpZy54T2Zmc2V0IC0gbTEueE9mZnNldDtcblx0XHRcdFx0XHRcdG0yLnkgLT0gb3JpZy55T2Zmc2V0IC0gbTEueU9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHggfHwgeSkge1xuXHRcdFx0XHRcdFx0bWF0cml4ID0gX2dldE1hdHJpeChfdGVtcERpdik7XG5cdFx0XHRcdFx0XHRtMi54IC09IHggLSAoeCAqIG1hdHJpeFswXSArIHkgKiBtYXRyaXhbMl0pO1xuXHRcdFx0XHRcdFx0bTIueSAtPSB5IC0gKHggKiBtYXRyaXhbMV0gKyB5ICogbWF0cml4WzNdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0X2RvYy5ib2R5LnJlbW92ZUNoaWxkKF90ZW1wRGl2KTtcblx0XHRcdFx0aWYgKCFtMi5wZXJzcGVjdGl2ZSkge1xuXHRcdFx0XHRcdG0yLnBlcnNwZWN0aXZlID0gbTEucGVyc3BlY3RpdmU7IC8vdHdlZW5pbmcgdG8gbm8gcGVyc3BlY3RpdmUgZ2l2ZXMgdmVyeSB1bmludHVpdGl2ZSByZXN1bHRzIC0ganVzdCBrZWVwIHRoZSBzYW1lIHBlcnNwZWN0aXZlIGluIHRoYXQgY2FzZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi54UGVyY2VudCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0bTIueFBlcmNlbnQgPSBfcGFyc2VWYWwodi54UGVyY2VudCwgbTEueFBlcmNlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LnlQZXJjZW50ICE9IG51bGwpIHtcblx0XHRcdFx0XHRtMi55UGVyY2VudCA9IF9wYXJzZVZhbCh2LnlQZXJjZW50LCBtMS55UGVyY2VudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHYpID09PSBcIm9iamVjdFwiKSB7IC8vZm9yIHZhbHVlcyBsaWtlIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgeCwgeSwgc2tld1gsIGFuZCBza2V3WSBvciB0cmFuc2Zvcm06ey4uLn0gKG9iamVjdClcblx0XHRcdFx0bTIgPSB7c2NhbGVYOl9wYXJzZVZhbCgodi5zY2FsZVggIT0gbnVsbCkgPyB2LnNjYWxlWCA6IHYuc2NhbGUsIG0xLnNjYWxlWCksXG5cdFx0XHRcdFx0c2NhbGVZOl9wYXJzZVZhbCgodi5zY2FsZVkgIT0gbnVsbCkgPyB2LnNjYWxlWSA6IHYuc2NhbGUsIG0xLnNjYWxlWSksXG5cdFx0XHRcdFx0c2NhbGVaOl9wYXJzZVZhbCh2LnNjYWxlWiwgbTEuc2NhbGVaKSxcblx0XHRcdFx0XHR4Ol9wYXJzZVZhbCh2LngsIG0xLngpLFxuXHRcdFx0XHRcdHk6X3BhcnNlVmFsKHYueSwgbTEueSksXG5cdFx0XHRcdFx0ejpfcGFyc2VWYWwodi56LCBtMS56KSxcblx0XHRcdFx0XHR4UGVyY2VudDpfcGFyc2VWYWwodi54UGVyY2VudCwgbTEueFBlcmNlbnQpLFxuXHRcdFx0XHRcdHlQZXJjZW50Ol9wYXJzZVZhbCh2LnlQZXJjZW50LCBtMS55UGVyY2VudCksXG5cdFx0XHRcdFx0cGVyc3BlY3RpdmU6X3BhcnNlVmFsKHYudHJhbnNmb3JtUGVyc3BlY3RpdmUsIG0xLnBlcnNwZWN0aXZlKX07XG5cdFx0XHRcdGRyID0gdi5kaXJlY3Rpb25hbFJvdGF0aW9uO1xuXHRcdFx0XHRpZiAoZHIgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YoZHIpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGNvcHkgaW4gZHIpIHtcblx0XHRcdFx0XHRcdFx0dltjb3B5XSA9IGRyW2NvcHldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2LnJvdGF0aW9uID0gZHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2Yodi54KSA9PT0gXCJzdHJpbmdcIiAmJiB2LnguaW5kZXhPZihcIiVcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0bTIueCA9IDA7XG5cdFx0XHRcdFx0bTIueFBlcmNlbnQgPSBfcGFyc2VWYWwodi54LCBtMS54UGVyY2VudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZih2LnkpID09PSBcInN0cmluZ1wiICYmIHYueS5pbmRleE9mKFwiJVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRtMi55ID0gMDtcblx0XHRcdFx0XHRtMi55UGVyY2VudCA9IF9wYXJzZVZhbCh2LnksIG0xLnlQZXJjZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG0yLnJvdGF0aW9uID0gX3BhcnNlQW5nbGUoKFwicm90YXRpb25cIiBpbiB2KSA/IHYucm90YXRpb24gOiAoXCJzaG9ydFJvdGF0aW9uXCIgaW4gdikgPyB2LnNob3J0Um90YXRpb24gKyBcIl9zaG9ydFwiIDogKFwicm90YXRpb25aXCIgaW4gdikgPyB2LnJvdGF0aW9uWiA6IG0xLnJvdGF0aW9uIC0gbTEuc2tld1ksIG0xLnJvdGF0aW9uIC0gbTEuc2tld1ksIFwicm90YXRpb25cIiwgZW5kUm90YXRpb25zKTsgLy9zZWUgbm90ZXMgYmVsb3cgYWJvdXQgc2tld1kgZm9yIHdoeSB3ZSBzdWJ0cmFjdCBpdCBmcm9tIHJvdGF0aW9uIGhlcmVcblx0XHRcdFx0aWYgKF9zdXBwb3J0czNEKSB7XG5cdFx0XHRcdFx0bTIucm90YXRpb25YID0gX3BhcnNlQW5nbGUoKFwicm90YXRpb25YXCIgaW4gdikgPyB2LnJvdGF0aW9uWCA6IChcInNob3J0Um90YXRpb25YXCIgaW4gdikgPyB2LnNob3J0Um90YXRpb25YICsgXCJfc2hvcnRcIiA6IG0xLnJvdGF0aW9uWCB8fCAwLCBtMS5yb3RhdGlvblgsIFwicm90YXRpb25YXCIsIGVuZFJvdGF0aW9ucyk7XG5cdFx0XHRcdFx0bTIucm90YXRpb25ZID0gX3BhcnNlQW5nbGUoKFwicm90YXRpb25ZXCIgaW4gdikgPyB2LnJvdGF0aW9uWSA6IChcInNob3J0Um90YXRpb25ZXCIgaW4gdikgPyB2LnNob3J0Um90YXRpb25ZICsgXCJfc2hvcnRcIiA6IG0xLnJvdGF0aW9uWSB8fCAwLCBtMS5yb3RhdGlvblksIFwicm90YXRpb25ZXCIsIGVuZFJvdGF0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bTIuc2tld1ggPSBfcGFyc2VBbmdsZSh2LnNrZXdYLCBtMS5za2V3WCAtIG0xLnNrZXdZKTsgLy9zZWUgbm90ZXMgYmVsb3cgYWJvdXQgc2tld1kgYW5kIHdoeSB3ZSBzdWJ0cmFjdCBpdCBmcm9tIHNrZXdYIGhlcmVcblxuXHRcdFx0XHQvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMsIGlnbm9yaW5nIHNrZXdZIGJ1dCB3ZSBtdXN0IHN0aWxsIHJlY29yZCBpdCBzbyB0aGF0IHdlIGNhbiBkaXNjZXJuIGhvdyBtdWNoIG9mIHRoZSBvdmVyYWxsIHNrZXcgaXMgYXR0cmlidXRlZCB0byBza2V3WCB2cy4gc2tld1kuIE90aGVyd2lzZSwgaWYgdGhlIHNrZXdZIHdvdWxkIGFsd2F5cyBhY3QgcmVsYXRpdmUgKHR3ZWVuIHNrZXdZIHRvIDEwZGVnLCBmb3IgZXhhbXBsZSwgbXVsdGlwbGUgdGltZXMgYW5kIGlmIHdlIGFsd2F5cyBjb21iaW5lIHRoaW5ncyBpbnRvIHNrZXdYLCB3ZSBjYW4ndCByZW1lbWJlciB0aGF0IHNrZXdZIHdhcyAxMCBmcm9tIGxhc3QgdGltZSkuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAtMTAgZGVncmVlcy5cblx0XHRcdFx0aWYgKChtMi5za2V3WSA9IF9wYXJzZUFuZ2xlKHYuc2tld1ksIG0xLnNrZXdZKSkpIHtcblx0XHRcdFx0XHRtMi5za2V3WCArPSBtMi5za2V3WTtcblx0XHRcdFx0XHRtMi5yb3RhdGlvbiArPSBtMi5za2V3WTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKF9zdXBwb3J0czNEICYmIHYuZm9yY2UzRCAhPSBudWxsKSB7XG5cdFx0XHRcdG0xLmZvcmNlM0QgPSB2LmZvcmNlM0Q7XG5cdFx0XHRcdGhhc0NoYW5nZSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdG0xLnNrZXdUeXBlID0gdi5za2V3VHlwZSB8fCBtMS5za2V3VHlwZSB8fCBDU1NQbHVnaW4uZGVmYXVsdFNrZXdUeXBlO1xuXG5cdFx0XHRoYXMzRCA9IChtMS5mb3JjZTNEIHx8IG0xLnogfHwgbTEucm90YXRpb25YIHx8IG0xLnJvdGF0aW9uWSB8fCBtMi56IHx8IG0yLnJvdGF0aW9uWCB8fCBtMi5yb3RhdGlvblkgfHwgbTIucGVyc3BlY3RpdmUpO1xuXHRcdFx0aWYgKCFoYXMzRCAmJiB2LnNjYWxlICE9IG51bGwpIHtcblx0XHRcdFx0bTIuc2NhbGVaID0gMTsgLy9ubyBuZWVkIHRvIHR3ZWVuIHNjYWxlWi5cblx0XHRcdH1cblxuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHAgPSBfdHJhbnNmb3JtUHJvcHNbaV07XG5cdFx0XHRcdG9yaWcgPSBtMltwXSAtIG0xW3BdO1xuXHRcdFx0XHRpZiAob3JpZyA+IG1pbiB8fCBvcmlnIDwgLW1pbiB8fCB2W3BdICE9IG51bGwgfHwgX2ZvcmNlUFRbcF0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGhhc0NoYW5nZSA9IHRydWU7XG5cdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKG0xLCBwLCBtMVtwXSwgb3JpZywgcHQpO1xuXHRcdFx0XHRcdGlmIChwIGluIGVuZFJvdGF0aW9ucykge1xuXHRcdFx0XHRcdFx0cHQuZSA9IGVuZFJvdGF0aW9uc1twXTsgLy9kaXJlY3Rpb25hbCByb3RhdGlvbnMgdHlwaWNhbGx5IGhhdmUgY29tcGVuc2F0ZWQgdmFsdWVzIGR1cmluZyB0aGUgdHdlZW4sIGJ1dCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGV5IGVuZCBhdCBleGFjdGx5IHdoYXQgdGhlIHVzZXIgcmVxdWVzdGVkXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0LnhzMCA9IDA7IC8vZW5zdXJlcyB0aGUgdmFsdWUgc3RheXMgbnVtZXJpYyBpbiBzZXRSYXRpbygpXG5cdFx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRcdGNzc3AuX292ZXJ3cml0ZVByb3BzLnB1c2gocHQubik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0b3JpZyA9IHYudHJhbnNmb3JtT3JpZ2luO1xuXHRcdFx0aWYgKG0xLnN2ZyAmJiAob3JpZyB8fCB2LnN2Z09yaWdpbikpIHtcblx0XHRcdFx0eCA9IG0xLnhPZmZzZXQ7IC8vd2hlbiB3ZSBjaGFuZ2UgdGhlIG9yaWdpbiwgaW4gb3JkZXIgdG8gcHJldmVudCB0aGluZ3MgZnJvbSBqdW1waW5nIHdlIGFkanVzdCB0aGUgeC95IHNvIHdlIG11c3QgcmVjb3JkIHRob3NlIGhlcmUgc28gdGhhdCB3ZSBjYW4gY3JlYXRlIFByb3BUd2VlbnMgZm9yIHRoZW0gYW5kIGZsaXAgdGhlbSBhdCB0aGUgc2FtZSB0aW1lIGFzIHRoZSBvcmlnaW5cblx0XHRcdFx0eSA9IG0xLnlPZmZzZXQ7XG5cdFx0XHRcdF9wYXJzZVNWR09yaWdpbih0LCBfcGFyc2VQb3NpdGlvbihvcmlnKSwgbTIsIHYuc3ZnT3JpZ2luLCB2LnNtb290aE9yaWdpbik7XG5cdFx0XHRcdHB0ID0gX2FkZE5vblR3ZWVuaW5nTnVtZXJpY1BUKG0xLCBcInhPcmlnaW5cIiwgKG9yaWdpbmFsR1NUcmFuc2Zvcm0gPyBtMSA6IG0yKS54T3JpZ2luLCBtMi54T3JpZ2luLCBwdCwgdHJhbnNmb3JtT3JpZ2luU3RyaW5nKTsgLy9ub3RlOiBpZiB0aGVyZSB3YXNuJ3QgYSB0cmFuc2Zvcm1PcmlnaW4gZGVmaW5lZCB5ZXQsIGp1c3Qgc3RhcnQgd2l0aCB0aGUgZGVzdGluYXRpb24gb25lOyBpdCdzIHdhc3RlZnVsIG90aGVyd2lzZSwgYW5kIGl0IGNhdXNlcyBwcm9ibGVtcyB3aXRoIGZyb21UbygpIHR3ZWVucy4gRm9yIGV4YW1wbGUsIFR3ZWVuTGl0ZS50byhcIiN3aGVlbFwiLCAzLCB7cm90YXRpb246MTgwLCB0cmFuc2Zvcm1PcmlnaW46XCI1MCUgNTAlXCIsIGRlbGF5OjF9KTsgVHdlZW5MaXRlLmZyb21UbyhcIiN3aGVlbFwiLCAzLCB7c2NhbGU6MC41LCB0cmFuc2Zvcm1PcmlnaW46XCI1MCUgNTAlXCJ9LCB7c2NhbGU6MSwgZGVsYXk6Mn0pOyB3b3VsZCBjYXVzZSBhIGp1bXAgd2hlbiB0aGUgZnJvbSB2YWx1ZXMgcmV2ZXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIDJuZCB0d2Vlbi5cblx0XHRcdFx0cHQgPSBfYWRkTm9uVHdlZW5pbmdOdW1lcmljUFQobTEsIFwieU9yaWdpblwiLCAob3JpZ2luYWxHU1RyYW5zZm9ybSA/IG0xIDogbTIpLnlPcmlnaW4sIG0yLnlPcmlnaW4sIHB0LCB0cmFuc2Zvcm1PcmlnaW5TdHJpbmcpO1xuXHRcdFx0XHRpZiAoeCAhPT0gbTEueE9mZnNldCB8fCB5ICE9PSBtMS55T2Zmc2V0KSB7XG5cdFx0XHRcdFx0cHQgPSBfYWRkTm9uVHdlZW5pbmdOdW1lcmljUFQobTEsIFwieE9mZnNldFwiLCAob3JpZ2luYWxHU1RyYW5zZm9ybSA/IHggOiBtMS54T2Zmc2V0KSwgbTEueE9mZnNldCwgcHQsIHRyYW5zZm9ybU9yaWdpblN0cmluZyk7XG5cdFx0XHRcdFx0cHQgPSBfYWRkTm9uVHdlZW5pbmdOdW1lcmljUFQobTEsIFwieU9mZnNldFwiLCAob3JpZ2luYWxHU1RyYW5zZm9ybSA/IHkgOiBtMS55T2Zmc2V0KSwgbTEueU9mZnNldCwgcHQsIHRyYW5zZm9ybU9yaWdpblN0cmluZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3JpZyA9IF91c2VTVkdUcmFuc2Zvcm1BdHRyID8gbnVsbCA6IFwiMHB4IDBweFwiOyAvL2NlcnRhaW4gYnJvd3NlcnMgKGxpa2UgZmlyZWZveCkgY29tcGxldGVseSBib3RjaCB0cmFuc2Zvcm0tb3JpZ2luLCBzbyB3ZSBtdXN0IHJlbW92ZSBpdCB0byBwcmV2ZW50IGl0IGZyb20gY29udGFtaW5hdGluZyB0cmFuc2Zvcm1zLiBXZSBtYW5hZ2UgaXQgb3Vyc2VsdmVzIHdpdGggeE9yaWdpbiBhbmQgeU9yaWdpblxuXHRcdFx0fVxuXHRcdFx0aWYgKG9yaWcgfHwgKF9zdXBwb3J0czNEICYmIGhhczNEICYmIG0xLnpPcmlnaW4pKSB7IC8vaWYgYW55dGhpbmcgM0QgaXMgaGFwcGVuaW5nIGFuZCB0aGVyZSdzIGEgdHJhbnNmb3JtT3JpZ2luIHdpdGggYSB6IGNvbXBvbmVudCB0aGF0J3Mgbm9uLXplcm8sIHdlIG11c3QgZW5zdXJlIHRoYXQgdGhlIHRyYW5zZm9ybU9yaWdpbidzIHotY29tcG9uZW50IGlzIHNldCB0byAwIHNvIHRoYXQgd2UgY2FuIG1hbnVhbGx5IGRvIHRob3NlIGNhbGN1bGF0aW9ucyB0byBnZXQgYXJvdW5kIFNhZmFyaSBidWdzLiBFdmVuIGlmIHRoZSB1c2VyIGRpZG4ndCBzcGVjaWZpY2FsbHkgZGVmaW5lIGEgXCJ0cmFuc2Zvcm1PcmlnaW5cIiBpbiB0aGlzIHBhcnRpY3VsYXIgdHdlZW4gKG1heWJlIHRoZXkgZGlkIGl0IHZpYSBjc3MgZGlyZWN0bHkpLlxuXHRcdFx0XHRpZiAoX3RyYW5zZm9ybVByb3ApIHtcblx0XHRcdFx0XHRoYXNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHRcdHAgPSBfdHJhbnNmb3JtT3JpZ2luUHJvcDtcblx0XHRcdFx0XHRvcmlnID0gKG9yaWcgfHwgX2dldFN0eWxlKHQsIHAsIF9jcywgZmFsc2UsIFwiNTAlIDUwJVwiKSkgKyBcIlwiOyAvL2Nhc3QgYXMgc3RyaW5nIHRvIGF2b2lkIGVycm9yc1xuXHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgcCwgMCwgMCwgcHQsIC0xLCB0cmFuc2Zvcm1PcmlnaW5TdHJpbmcpO1xuXHRcdFx0XHRcdHB0LmIgPSBzdHlsZVtwXTtcblx0XHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdFx0aWYgKF9zdXBwb3J0czNEKSB7XG5cdFx0XHRcdFx0XHRjb3B5ID0gbTEuek9yaWdpbjtcblx0XHRcdFx0XHRcdG9yaWcgPSBvcmlnLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRcdG0xLnpPcmlnaW4gPSAoKG9yaWcubGVuZ3RoID4gMiAmJiAhKGNvcHkgIT09IDAgJiYgb3JpZ1syXSA9PT0gXCIwcHhcIikpID8gcGFyc2VGbG9hdChvcmlnWzJdKSA6IGNvcHkpIHx8IDA7IC8vU2FmYXJpIGRvZXNuJ3QgaGFuZGxlIHRoZSB6IHBhcnQgb2YgdHJhbnNmb3JtT3JpZ2luIGNvcnJlY3RseSwgc28gd2UnbGwgbWFudWFsbHkgaGFuZGxlIGl0IGluIHRoZSBfc2V0M0RUcmFuc2Zvcm1SYXRpbygpIG1ldGhvZC5cblx0XHRcdFx0XHRcdHB0LnhzMCA9IHB0LmUgPSBvcmlnWzBdICsgXCIgXCIgKyAob3JpZ1sxXSB8fCBcIjUwJVwiKSArIFwiIDBweFwiOyAvL3dlIG11c3QgZGVmaW5lIGEgeiB2YWx1ZSBvZiAwcHggc3BlY2lmaWNhbGx5IG90aGVyd2lzZSBpT1MgNSBTYWZhcmkgd2lsbCBzdGljayB3aXRoIHRoZSBvbGQgb25lIChpZiBvbmUgd2FzIGRlZmluZWQpIVxuXHRcdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKG0xLCBcInpPcmlnaW5cIiwgMCwgMCwgcHQsIC0xLCBwdC5uKTsgLy93ZSBtdXN0IGNyZWF0ZSBhIENTU1Byb3BUd2VlbiBmb3IgdGhlIF9nc1RyYW5zZm9ybS56T3JpZ2luIHNvIHRoYXQgaXQgZ2V0cyByZXNldCBwcm9wZXJseSBhdCB0aGUgYmVnaW5uaW5nIGlmIHRoZSB0d2VlbiBydW5zIGJhY2t3YXJkIChhcyBvcHBvc2VkIHRvIGp1c3Qgc2V0dGluZyBtMS56T3JpZ2luIGhlcmUpXG5cdFx0XHRcdFx0XHRwdC5iID0gY29weTtcblx0XHRcdFx0XHRcdHB0LnhzMCA9IHB0LmUgPSBtMS56T3JpZ2luO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC54czAgPSBwdC5lID0gb3JpZztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvL2ZvciBvbGRlciB2ZXJzaW9ucyBvZiBJRSAoNi04KSwgd2UgbmVlZCB0byBtYW51YWxseSBjYWxjdWxhdGUgdGhpbmdzIGluc2lkZSB0aGUgc2V0UmF0aW8oKSBmdW5jdGlvbi4gV2UgcmVjb3JkIG9yaWdpbiB4IGFuZCB5IChveCBhbmQgb3kpIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgdmFsdWVzIGFyZSBwZXJjZW50YWdlcyAob3hwIGFuZCBveXApLlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9wYXJzZVBvc2l0aW9uKG9yaWcgKyBcIlwiLCBtMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNDaGFuZ2UpIHtcblx0XHRcdFx0Y3NzcC5fdHJhbnNmb3JtVHlwZSA9ICghKG0xLnN2ZyAmJiBfdXNlU1ZHVHJhbnNmb3JtQXR0cikgJiYgKGhhczNEIHx8IHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09IDMpKSA/IDMgOiAyOyAvL3F1aWNrZXIgdGhhbiBjYWxsaW5nIGNzc3AuX2VuYWJsZVRyYW5zZm9ybXMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9LCBwcmVmaXg6dHJ1ZX0pO1xuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm94U2hhZG93XCIsIHtkZWZhdWx0VmFsdWU6XCIwcHggMHB4IDBweCAwcHggIzk5OVwiLCBwcmVmaXg6dHJ1ZSwgY29sb3I6dHJ1ZSwgbXVsdGk6dHJ1ZSwga2V5d29yZDpcImluc2V0XCJ9KTtcblxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJvcmRlclJhZGl1c1wiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4XCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHRlID0gdGhpcy5mb3JtYXQoZSk7XG5cdFx0XHR2YXIgcHJvcHMgPSBbXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIl0sXG5cdFx0XHRcdHN0eWxlID0gdC5zdHlsZSxcblx0XHRcdFx0ZWExLCBpLCBlczIsIGJzMiwgYnMsIGVzLCBibiwgZW4sIHcsIGgsIGVzZngsIGJzZngsIHJlbCwgaG4sIHZuLCBlbTtcblx0XHRcdHcgPSBwYXJzZUZsb2F0KHQub2Zmc2V0V2lkdGgpO1xuXHRcdFx0aCA9IHBhcnNlRmxvYXQodC5vZmZzZXRIZWlnaHQpO1xuXHRcdFx0ZWExID0gZS5zcGxpdChcIiBcIik7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgLy9pZiB3ZSdyZSBkZWFsaW5nIHdpdGggcGVyY2VudGFnZXMsIHdlIG11c3QgY29udmVydCB0aGluZ3Mgc2VwYXJhdGVseSBmb3IgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGF4aXMhXG5cdFx0XHRcdGlmICh0aGlzLnAuaW5kZXhPZihcImJvcmRlclwiKSkgeyAvL29sZGVyIGJyb3dzZXJzIHVzZWQgYSBwcmVmaXhcblx0XHRcdFx0XHRwcm9wc1tpXSA9IF9jaGVja1Byb3BQcmVmaXgocHJvcHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJzID0gYnMyID0gX2dldFN0eWxlKHQsIHByb3BzW2ldLCBfY3MsIGZhbHNlLCBcIjBweFwiKTtcblx0XHRcdFx0aWYgKGJzLmluZGV4T2YoXCIgXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdGJzMiA9IGJzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRicyA9IGJzMlswXTtcblx0XHRcdFx0XHRiczIgPSBiczJbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZXMgPSBlczIgPSBlYTFbaV07XG5cdFx0XHRcdGJuID0gcGFyc2VGbG9hdChicyk7XG5cdFx0XHRcdGJzZnggPSBicy5zdWJzdHIoKGJuICsgXCJcIikubGVuZ3RoKTtcblx0XHRcdFx0cmVsID0gKGVzLmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRpZiAocmVsKSB7XG5cdFx0XHRcdFx0ZW4gPSBwYXJzZUludChlcy5jaGFyQXQoMCkrXCIxXCIsIDEwKTtcblx0XHRcdFx0XHRlcyA9IGVzLnN1YnN0cigyKTtcblx0XHRcdFx0XHRlbiAqPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRlc2Z4ID0gZXMuc3Vic3RyKChlbiArIFwiXCIpLmxlbmd0aCAtIChlbiA8IDAgPyAxIDogMCkpIHx8IFwiXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZW4gPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRlc2Z4ID0gZXMuc3Vic3RyKChlbiArIFwiXCIpLmxlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVzZnggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRlc2Z4ID0gX3N1ZmZpeE1hcFtwXSB8fCBic2Z4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlc2Z4ICE9PSBic2Z4KSB7XG5cdFx0XHRcdFx0aG4gPSBfY29udmVydFRvUGl4ZWxzKHQsIFwiYm9yZGVyTGVmdFwiLCBibiwgYnNmeCk7IC8vaG9yaXpvbnRhbCBudW1iZXIgKHdlIHVzZSBhIGJvZ3VzIFwiYm9yZGVyTGVmdFwiIHByb3BlcnR5IGp1c3QgYmVjYXVzZSB0aGUgX2NvbnZlcnRUb1BpeGVscygpIG1ldGhvZCBzZWFyY2hlcyBmb3IgdGhlIGtleXdvcmRzIFwiTGVmdFwiLCBcIlJpZ2h0XCIsIFwiVG9wXCIsIGFuZCBcIkJvdHRvbVwiIHRvIGRldGVybWluZSBvZiBpdCdzIGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0eSwgYW5kIHdlIG5lZWQgXCJib3JkZXJcIiBpbiB0aGUgbmFtZSBzbyB0aGF0IGl0IGtub3dzIGl0IHNob3VsZCBtZWFzdXJlIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50IGl0c2VsZiwgbm90IGl0cyBwYXJlbnQuXG5cdFx0XHRcdFx0dm4gPSBfY29udmVydFRvUGl4ZWxzKHQsIFwiYm9yZGVyVG9wXCIsIGJuLCBic2Z4KTsgLy92ZXJ0aWNhbCBudW1iZXJcblx0XHRcdFx0XHRpZiAoZXNmeCA9PT0gXCIlXCIpIHtcblx0XHRcdFx0XHRcdGJzID0gKGhuIC8gdyAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHRcdGJzMiA9ICh2biAvIGggKiAxMDApICsgXCIlXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlc2Z4ID09PSBcImVtXCIpIHtcblx0XHRcdFx0XHRcdGVtID0gX2NvbnZlcnRUb1BpeGVscyh0LCBcImJvcmRlckxlZnRcIiwgMSwgXCJlbVwiKTtcblx0XHRcdFx0XHRcdGJzID0gKGhuIC8gZW0pICsgXCJlbVwiO1xuXHRcdFx0XHRcdFx0YnMyID0gKHZuIC8gZW0pICsgXCJlbVwiO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRicyA9IGhuICsgXCJweFwiO1xuXHRcdFx0XHRcdFx0YnMyID0gdm4gKyBcInB4XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRcdGVzID0gKHBhcnNlRmxvYXQoYnMpICsgZW4pICsgZXNmeDtcblx0XHRcdFx0XHRcdGVzMiA9IChwYXJzZUZsb2F0KGJzMikgKyBlbikgKyBlc2Z4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IF9wYXJzZUNvbXBsZXgoc3R5bGUsIHByb3BzW2ldLCBicyArIFwiIFwiICsgYnMyLCBlcyArIFwiIFwiICsgZXMyLCBmYWxzZSwgXCIwcHhcIiwgcHQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH0sIHByZWZpeDp0cnVlLCBmb3JtYXR0ZXI6X2dldEZvcm1hdHRlcihcIjBweCAwcHggMHB4IDBweFwiLCBmYWxzZSwgdHJ1ZSl9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzLGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLGJvcmRlclRvcExlZnRSYWRpdXMsYm9yZGVyVG9wUmlnaHRSYWRpdXNcIiwge2RlZmF1bHRWYWx1ZTpcIjBweFwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0cmV0dXJuIF9wYXJzZUNvbXBsZXgodC5zdHlsZSwgcCwgdGhpcy5mb3JtYXQoX2dldFN0eWxlKHQsIHAsIF9jcywgZmFsc2UsIFwiMHB4IDBweFwiKSksIHRoaXMuZm9ybWF0KGUpLCBmYWxzZSwgXCIwcHhcIiwgcHQpO1xuXHRcdH0sIHByZWZpeDp0cnVlLCBmb3JtYXR0ZXI6X2dldEZvcm1hdHRlcihcIjBweCAwcHhcIiwgZmFsc2UsIHRydWUpfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmFja2dyb3VuZFBvc2l0aW9uXCIsIHtkZWZhdWx0VmFsdWU6XCIwIDBcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHZhciBicCA9IFwiYmFja2dyb3VuZC1wb3NpdGlvblwiLFxuXHRcdFx0XHRjcyA9IChfY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCwgbnVsbCkpLFxuXHRcdFx0XHRicyA9IHRoaXMuZm9ybWF0KCAoKGNzKSA/IF9pZVZlcnMgPyBjcy5nZXRQcm9wZXJ0eVZhbHVlKGJwICsgXCIteFwiKSArIFwiIFwiICsgY3MuZ2V0UHJvcGVydHlWYWx1ZShicCArIFwiLXlcIikgOiBjcy5nZXRQcm9wZXJ0eVZhbHVlKGJwKSA6IHQuY3VycmVudFN0eWxlLmJhY2tncm91bmRQb3NpdGlvblggKyBcIiBcIiArIHQuY3VycmVudFN0eWxlLmJhY2tncm91bmRQb3NpdGlvblkpIHx8IFwiMCAwXCIpLCAvL0ludGVybmV0IEV4cGxvcmVyIGRvZXNuJ3QgcmVwb3J0IGJhY2tncm91bmQtcG9zaXRpb24gY29ycmVjdGx5IC0gd2UgbXVzdCBxdWVyeSBiYWNrZ3JvdW5kLXBvc2l0aW9uLXggYW5kIGJhY2tncm91bmQtcG9zaXRpb24teSBhbmQgY29tYmluZSB0aGVtIChldmVuIGluIElFMTApLiBCZWZvcmUgSUU5LCB3ZSBtdXN0IGRvIHRoZSBzYW1lIHdpdGggdGhlIGN1cnJlbnRTdHlsZSBvYmplY3QgYW5kIHVzZSBjYW1lbENhc2Vcblx0XHRcdFx0ZXMgPSB0aGlzLmZvcm1hdChlKSxcblx0XHRcdFx0YmEsIGVhLCBpLCBwY3QsIG92ZXJsYXAsIHNyYztcblx0XHRcdGlmICgoYnMuaW5kZXhPZihcIiVcIikgIT09IC0xKSAhPT0gKGVzLmluZGV4T2YoXCIlXCIpICE9PSAtMSkgJiYgZXMuc3BsaXQoXCIsXCIpLmxlbmd0aCA8IDIpIHtcblx0XHRcdFx0c3JjID0gX2dldFN0eWxlKHQsIFwiYmFja2dyb3VuZEltYWdlXCIpLnJlcGxhY2UoX3VybEV4cCwgXCJcIik7XG5cdFx0XHRcdGlmIChzcmMgJiYgc3JjICE9PSBcIm5vbmVcIikge1xuXHRcdFx0XHRcdGJhID0gYnMuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGVhID0gZXMuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdF90ZW1wSW1nLnNldEF0dHJpYnV0ZShcInNyY1wiLCBzcmMpOyAvL3NldCB0aGUgdGVtcCBJTUcncyBzcmMgdG8gdGhlIGJhY2tncm91bmQtaW1hZ2Ugc28gdGhhdCB3ZSBjYW4gbWVhc3VyZSBpdHMgd2lkdGgvaGVpZ2h0XG5cdFx0XHRcdFx0aSA9IDI7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRicyA9IGJhW2ldO1xuXHRcdFx0XHRcdFx0cGN0ID0gKGJzLmluZGV4T2YoXCIlXCIpICE9PSAtMSk7XG5cdFx0XHRcdFx0XHRpZiAocGN0ICE9PSAoZWFbaV0uaW5kZXhPZihcIiVcIikgIT09IC0xKSkge1xuXHRcdFx0XHRcdFx0XHRvdmVybGFwID0gKGkgPT09IDApID8gdC5vZmZzZXRXaWR0aCAtIF90ZW1wSW1nLndpZHRoIDogdC5vZmZzZXRIZWlnaHQgLSBfdGVtcEltZy5oZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdGJhW2ldID0gcGN0ID8gKHBhcnNlRmxvYXQoYnMpIC8gMTAwICogb3ZlcmxhcCkgKyBcInB4XCIgOiAocGFyc2VGbG9hdChicykgLyBvdmVybGFwICogMTAwKSArIFwiJVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicyA9IGJhLmpvaW4oXCIgXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgYnMsIGVzLCBwdCwgcGx1Z2luKTtcblx0XHR9LCBmb3JtYXR0ZXI6X3BhcnNlUG9zaXRpb259KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiYWNrZ3JvdW5kU2l6ZVwiLCB7ZGVmYXVsdFZhbHVlOlwiMCAwXCIsIGZvcm1hdHRlcjpfcGFyc2VQb3NpdGlvbn0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInBlcnNwZWN0aXZlXCIsIHtkZWZhdWx0VmFsdWU6XCIwcHhcIiwgcHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJwZXJzcGVjdGl2ZU9yaWdpblwiLCB7ZGVmYXVsdFZhbHVlOlwiNTAlIDUwJVwiLCBwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInRyYW5zZm9ybVN0eWxlXCIsIHtwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJhY2tmYWNlVmlzaWJpbGl0eVwiLCB7cHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ1c2VyU2VsZWN0XCIsIHtwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcIm1hcmdpblwiLCB7cGFyc2VyOl9nZXRFZGdlUGFyc2VyKFwibWFyZ2luVG9wLG1hcmdpblJpZ2h0LG1hcmdpbkJvdHRvbSxtYXJnaW5MZWZ0XCIpfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwicGFkZGluZ1wiLCB7cGFyc2VyOl9nZXRFZGdlUGFyc2VyKFwicGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxwYWRkaW5nTGVmdFwiKX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsaXBcIiwge2RlZmF1bHRWYWx1ZTpcInJlY3QoMHB4LDBweCwwcHgsMHB4KVwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbil7XG5cdFx0XHR2YXIgYiwgY3MsIGRlbGltO1xuXHRcdFx0aWYgKF9pZVZlcnMgPCA5KSB7IC8vSUU4IGFuZCBlYXJsaWVyIGRvbid0IHJlcG9ydCBhIFwiY2xpcFwiIHZhbHVlIGluIHRoZSBjdXJyZW50U3R5bGUgLSBpbnN0ZWFkLCB0aGUgdmFsdWVzIGFyZSBzcGxpdCBhcGFydCBpbnRvIGNsaXBUb3AsIGNsaXBSaWdodCwgY2xpcEJvdHRvbSwgYW5kIGNsaXBMZWZ0LiBBbHNvLCBpbiBJRTcgYW5kIGVhcmxpZXIsIHRoZSB2YWx1ZXMgaW5zaWRlIHJlY3QoKSBhcmUgc3BhY2UtZGVsaW1pdGVkLCBub3QgY29tbWEtZGVsaW1pdGVkLlxuXHRcdFx0XHRjcyA9IHQuY3VycmVudFN0eWxlO1xuXHRcdFx0XHRkZWxpbSA9IF9pZVZlcnMgPCA4ID8gXCIgXCIgOiBcIixcIjtcblx0XHRcdFx0YiA9IFwicmVjdChcIiArIGNzLmNsaXBUb3AgKyBkZWxpbSArIGNzLmNsaXBSaWdodCArIGRlbGltICsgY3MuY2xpcEJvdHRvbSArIGRlbGltICsgY3MuY2xpcExlZnQgKyBcIilcIjtcblx0XHRcdFx0ZSA9IHRoaXMuZm9ybWF0KGUpLnNwbGl0KFwiLFwiKS5qb2luKGRlbGltKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGIgPSB0aGlzLmZvcm1hdChfZ2V0U3R5bGUodCwgdGhpcy5wLCBfY3MsIGZhbHNlLCB0aGlzLmRmbHQpKTtcblx0XHRcdFx0ZSA9IHRoaXMuZm9ybWF0KGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIGIsIGUsIHB0LCBwbHVnaW4pO1xuXHRcdH19KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ0ZXh0U2hhZG93XCIsIHtkZWZhdWx0VmFsdWU6XCIwcHggMHB4IDBweCAjOTk5XCIsIGNvbG9yOnRydWUsIG11bHRpOnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJhdXRvUm91bmQsc3RyaWN0VW5pdHNcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCkge3JldHVybiBwdDt9fSk7IC8vanVzdCBzbyB0aGF0IHdlIGNhbiBpZ25vcmUgdGhlc2UgcHJvcGVydGllcyAobm90IHR3ZWVuIHRoZW0pXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyXCIsIHtkZWZhdWx0VmFsdWU6XCIwcHggc29saWQgIzAwMFwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgdGhpcy5mb3JtYXQoX2dldFN0eWxlKHQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgX2NzLCBmYWxzZSwgXCIwcHhcIikgKyBcIiBcIiArIF9nZXRTdHlsZSh0LCBcImJvcmRlclRvcFN0eWxlXCIsIF9jcywgZmFsc2UsIFwic29saWRcIikgKyBcIiBcIiArIF9nZXRTdHlsZSh0LCBcImJvcmRlclRvcENvbG9yXCIsIF9jcywgZmFsc2UsIFwiIzAwMFwiKSksIHRoaXMuZm9ybWF0KGUpLCBwdCwgcGx1Z2luKTtcblx0XHRcdH0sIGNvbG9yOnRydWUsIGZvcm1hdHRlcjpmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciBhID0gdi5zcGxpdChcIiBcIik7XG5cdFx0XHRcdHJldHVybiBhWzBdICsgXCIgXCIgKyAoYVsxXSB8fCBcInNvbGlkXCIpICsgXCIgXCIgKyAodi5tYXRjaChfY29sb3JFeHApIHx8IFtcIiMwMDBcIl0pWzBdO1xuXHRcdFx0fX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJvcmRlcldpZHRoXCIsIHtwYXJzZXI6X2dldEVkZ2VQYXJzZXIoXCJib3JkZXJUb3BXaWR0aCxib3JkZXJSaWdodFdpZHRoLGJvcmRlckJvdHRvbVdpZHRoLGJvcmRlckxlZnRXaWR0aFwiKX0pOyAvL0ZpcmVmb3ggZG9lc24ndCBwaWNrIHVwIG9uIGJvcmRlcldpZHRoIHNldCBpbiBzdHlsZSBzaGVldHMgKG9ubHkgaW5saW5lKS5cblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJmbG9hdCxjc3NGbG9hdCxzdHlsZUZsb2F0XCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0dmFyIHMgPSB0LnN0eWxlLFxuXHRcdFx0XHRwcm9wID0gKFwiY3NzRmxvYXRcIiBpbiBzKSA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiO1xuXHRcdFx0cmV0dXJuIG5ldyBDU1NQcm9wVHdlZW4ocywgcHJvcCwgMCwgMCwgcHQsIC0xLCBwLCBmYWxzZSwgMCwgc1twcm9wXSwgZSk7XG5cdFx0fX0pO1xuXG5cdFx0Ly9vcGFjaXR5LXJlbGF0ZWRcblx0XHR2YXIgX3NldElFT3BhY2l0eVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMudCwgLy9yZWZlcnMgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSBwcm9wZXJ0eVxuXHRcdFx0XHRcdGZpbHRlcnMgPSB0LmZpbHRlciB8fCBfZ2V0U3R5bGUodGhpcy5kYXRhLCBcImZpbHRlclwiKSB8fCBcIlwiLFxuXHRcdFx0XHRcdHZhbCA9ICh0aGlzLnMgKyB0aGlzLmMgKiB2KSB8IDAsXG5cdFx0XHRcdFx0c2tpcDtcblx0XHRcdFx0aWYgKHZhbCA9PT0gMTAwKSB7IC8vZm9yIG9sZGVyIHZlcnNpb25zIG9mIElFIHRoYXQgbmVlZCB0byB1c2UgYSBmaWx0ZXIgdG8gYXBwbHkgb3BhY2l0eSwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgZmlsdGVyIGlmIG9wYWNpdHkgaGl0cyAxIGluIG9yZGVyIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIGJ1dCBtYWtlIHN1cmUgdGhlcmUgaXNuJ3QgYSB0cmFuc2Zvcm0gKG1hdHJpeCkgb3IgZ3JhZGllbnQgaW4gdGhlIGZpbHRlcnMuXG5cdFx0XHRcdFx0aWYgKGZpbHRlcnMuaW5kZXhPZihcImF0cml4KFwiKSA9PT0gLTEgJiYgZmlsdGVycy5pbmRleE9mKFwicmFkaWVudChcIikgPT09IC0xICYmIGZpbHRlcnMuaW5kZXhPZihcIm9hZGVyKFwiKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdHQucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpO1xuXHRcdFx0XHRcdFx0c2tpcCA9ICghX2dldFN0eWxlKHRoaXMuZGF0YSwgXCJmaWx0ZXJcIikpOyAvL2lmIGEgY2xhc3MgaXMgYXBwbGllZCB0aGF0IGhhcyBhbiBhbHBoYSBmaWx0ZXIsIGl0IHdpbGwgdGFrZSBlZmZlY3QgKHdlIGRvbid0IHdhbnQgdGhhdCksIHNvIHJlLWFwcGx5IG91ciBhbHBoYSBmaWx0ZXIgaW4gdGhhdCBjYXNlLiBXZSBtdXN0IGZpcnN0IHJlbW92ZSBpdCBhbmQgdGhlbiBjaGVjay5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzLnJlcGxhY2UoX2FscGhhRmlsdGVyRXhwLCBcIlwiKTtcblx0XHRcdFx0XHRcdHNraXAgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXNraXApIHtcblx0XHRcdFx0XHRpZiAodGhpcy54bjEpIHtcblx0XHRcdFx0XHRcdHQuZmlsdGVyID0gZmlsdGVycyA9IGZpbHRlcnMgfHwgKFwiYWxwaGEob3BhY2l0eT1cIiArIHZhbCArIFwiKVwiKTsgLy93b3JrcyBhcm91bmQgYnVnIGluIElFNy84IHRoYXQgcHJldmVudHMgY2hhbmdlcyB0byBcInZpc2liaWxpdHlcIiBmcm9tIGJlaW5nIGFwcGxpZWQgcHJvcGVybHkgaWYgdGhlIGZpbHRlciBpcyBjaGFuZ2VkIHRvIGEgZGlmZmVyZW50IGFscGhhIG9uIHRoZSBzYW1lIGZyYW1lLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZmlsdGVycy5pbmRleE9mKFwicGFjaXR5XCIpID09PSAtMSkgeyAvL29ubHkgdXNlZCBpZiBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgc3RhbmRhcmQgb3BhY2l0eSBzdHlsZSBwcm9wZXJ0eSAoSUUgNyBhbmQgOCkuIFdlIG9taXQgdGhlIFwiT1wiIHRvIGF2b2lkIGNhc2Utc2Vuc2l0aXZpdHkgaXNzdWVzXG5cdFx0XHRcdFx0XHRpZiAodmFsICE9PSAwIHx8ICF0aGlzLnhuMSkgeyAvL2J1Z3MgaW4gSUU3Lzggd29uJ3QgcmVuZGVyIHRoZSBmaWx0ZXIgcHJvcGVybHkgaWYgb3BhY2l0eSBpcyBBRERFRCBvbiB0aGUgc2FtZSBmcmFtZS9yZW5kZXIgYXMgXCJ2aXNpYmlsaXR5XCIgY2hhbmdlcyAodGhpcy54bjEgaXMgMSBpZiB0aGlzIHR3ZWVuIGlzIGFuIFwiYXV0b0FscGhhXCIgdHdlZW4pXG5cdFx0XHRcdFx0XHRcdHQuZmlsdGVyID0gZmlsdGVycyArIFwiIGFscGhhKG9wYWNpdHk9XCIgKyB2YWwgKyBcIilcIjsgLy93ZSByb3VuZCB0aGUgdmFsdWUgYmVjYXVzZSBvdGhlcndpc2UsIGJ1Z3MgaW4gSUU3LzggY2FuIHByZXZlbnQgXCJ2aXNpYmlsaXR5XCIgY2hhbmdlcyBmcm9tIGJlaW5nIGFwcGxpZWQgcHJvcGVybHkuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHQuZmlsdGVyID0gZmlsdGVycy5yZXBsYWNlKF9vcGFjaXR5RXhwLCBcIm9wYWNpdHk9XCIgKyB2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJvcGFjaXR5LGFscGhhLGF1dG9BbHBoYVwiLCB7ZGVmYXVsdFZhbHVlOlwiMVwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0dmFyIGIgPSBwYXJzZUZsb2F0KF9nZXRTdHlsZSh0LCBcIm9wYWNpdHlcIiwgX2NzLCBmYWxzZSwgXCIxXCIpKSxcblx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRpc0F1dG9BbHBoYSA9IChwID09PSBcImF1dG9BbHBoYVwiKTtcblx0XHRcdGlmICh0eXBlb2YoZSkgPT09IFwic3RyaW5nXCIgJiYgZS5jaGFyQXQoMSkgPT09IFwiPVwiKSB7XG5cdFx0XHRcdGUgPSAoKGUuY2hhckF0KDApID09PSBcIi1cIikgPyAtMSA6IDEpICogcGFyc2VGbG9hdChlLnN1YnN0cigyKSkgKyBiO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXV0b0FscGhhICYmIGIgPT09IDEgJiYgX2dldFN0eWxlKHQsIFwidmlzaWJpbGl0eVwiLCBfY3MpID09PSBcImhpZGRlblwiICYmIGUgIT09IDApIHsgLy9pZiB2aXNpYmlsaXR5IGlzIGluaXRpYWxseSBzZXQgdG8gXCJoaWRkZW5cIiwgd2Ugc2hvdWxkIGludGVycHJldCB0aGF0IGFzIGludGVudCB0byBtYWtlIG9wYWNpdHkgMCAoYSBjb252ZW5pZW5jZSlcblx0XHRcdFx0YiA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX3N1cHBvcnRzT3BhY2l0eSkge1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIFwib3BhY2l0eVwiLCBiLCBlIC0gYiwgcHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBcIm9wYWNpdHlcIiwgYiAqIDEwMCwgKGUgLSBiKSAqIDEwMCwgcHQpO1xuXHRcdFx0XHRwdC54bjEgPSBpc0F1dG9BbHBoYSA/IDEgOiAwOyAvL3dlIG5lZWQgdG8gcmVjb3JkIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgYW4gYXV0b0FscGhhIHNvIHRoYXQgaW4gdGhlIHNldFJhdGlvKCksIHdlIGtub3cgdG8gZHVwbGljYXRlIHRoZSBzZXR0aW5nIG9mIHRoZSBhbHBoYSBpbiBvcmRlciB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpbiBJRTcgYW5kIElFOCB0aGF0IHByZXZlbnRzIGNoYW5nZXMgdG8gXCJ2aXNpYmlsaXR5XCIgZnJvbSB0YWtpbmcgZWZmZWN0IGlmIHRoZSBmaWx0ZXIgaXMgY2hhbmdlZCB0byBhIGRpZmZlcmVudCBhbHBoYShvcGFjaXR5KSBhdCB0aGUgc2FtZSB0aW1lLiBTZXR0aW5nIGl0IHRvIHRoZSBTQU1FIHZhbHVlIGZpcnN0LCB0aGVuIHRoZSBuZXcgdmFsdWUgd29ya3MgYXJvdW5kIHRoZSBJRTcvOCBidWcuXG5cdFx0XHRcdHN0eWxlLnpvb20gPSAxOyAvL2hlbHBzIGNvcnJlY3QgYW4gSUUgaXNzdWUuXG5cdFx0XHRcdHB0LnR5cGUgPSAyO1xuXHRcdFx0XHRwdC5iID0gXCJhbHBoYShvcGFjaXR5PVwiICsgcHQucyArIFwiKVwiO1xuXHRcdFx0XHRwdC5lID0gXCJhbHBoYShvcGFjaXR5PVwiICsgKHB0LnMgKyBwdC5jKSArIFwiKVwiO1xuXHRcdFx0XHRwdC5kYXRhID0gdDtcblx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRwdC5zZXRSYXRpbyA9IF9zZXRJRU9wYWNpdHlSYXRpbztcblx0XHRcdH1cblx0XHRcdGlmIChpc0F1dG9BbHBoYSkgeyAvL3dlIGhhdmUgdG8gY3JlYXRlIHRoZSBcInZpc2liaWxpdHlcIiBQcm9wVHdlZW4gYWZ0ZXIgdGhlIG9wYWNpdHkgb25lIGluIHRoZSBsaW5rZWQgbGlzdCBzbyB0aGF0IHRoZXkgcnVuIGluIHRoZSBvcmRlciB0aGF0IHdvcmtzIHByb3Blcmx5IGluIElFOCBhbmQgZWFybGllclxuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIFwidmlzaWJpbGl0eVwiLCAwLCAwLCBwdCwgLTEsIG51bGwsIGZhbHNlLCAwLCAoKGIgIT09IDApID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiKSwgKChlID09PSAwKSA/IFwiaGlkZGVuXCIgOiBcImluaGVyaXRcIikpO1xuXHRcdFx0XHRwdC54czAgPSBcImluaGVyaXRcIjtcblx0XHRcdFx0Y3NzcC5fb3ZlcndyaXRlUHJvcHMucHVzaChwdC5uKTtcblx0XHRcdFx0Y3NzcC5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9fSk7XG5cblxuXHRcdHZhciBfcmVtb3ZlUHJvcCA9IGZ1bmN0aW9uKHMsIHApIHtcblx0XHRcdFx0aWYgKHApIHtcblx0XHRcdFx0XHRpZiAocy5yZW1vdmVQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0aWYgKHAuc3Vic3RyKDAsMikgPT09IFwibXNcIiB8fCBwLnN1YnN0cigwLDYpID09PSBcIndlYmtpdFwiKSB7IC8vTWljcm9zb2Z0IGFuZCBzb21lIFdlYmtpdCBicm93c2VycyBkb24ndCBjb25mb3JtIHRvIHRoZSBzdGFuZGFyZCBvZiBjYXBpdGFsaXppbmcgdGhlIGZpcnN0IHByZWZpeCBjaGFyYWN0ZXIsIHNvIHdlIGFkanVzdCBzbyB0aGF0IHdoZW4gd2UgcHJlZml4IHRoZSBjYXBzIHdpdGggYSBkYXNoLCBpdCdzIGNvcnJlY3QgKG90aGVyd2lzZSBpdCdkIGJlIFwibXMtdHJhbnNmb3JtXCIgaW5zdGVhZCBvZiBcIi1tcy10cmFuc2Zvcm1cIiBmb3IgSUU5LCBmb3IgZXhhbXBsZSlcblx0XHRcdFx0XHRcdFx0cCA9IFwiLVwiICsgcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHMucmVtb3ZlUHJvcGVydHkocC5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdFx0XHR9IGVsc2UgeyAvL25vdGU6IG9sZCB2ZXJzaW9ucyBvZiBJRSB1c2UgXCJyZW1vdmVBdHRyaWJ1dGUoKVwiIGluc3RlYWQgb2YgXCJyZW1vdmVQcm9wZXJ0eSgpXCJcblx0XHRcdFx0XHRcdHMucmVtb3ZlQXR0cmlidXRlKHApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9zZXRDbGFzc05hbWVSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dGhpcy50Ll9nc0NsYXNzUFQgPSB0aGlzO1xuXHRcdFx0XHRpZiAodiA9PT0gMSB8fCB2ID09PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsICh2ID09PSAwKSA/IHRoaXMuYiA6IHRoaXMuZSk7XG5cdFx0XHRcdFx0dmFyIG1wdCA9IHRoaXMuZGF0YSwgLy9maXJzdCBNaW5pUHJvcFR3ZWVuXG5cdFx0XHRcdFx0XHRzID0gdGhpcy50LnN0eWxlO1xuXHRcdFx0XHRcdHdoaWxlIChtcHQpIHtcblx0XHRcdFx0XHRcdGlmICghbXB0LnYpIHtcblx0XHRcdFx0XHRcdFx0X3JlbW92ZVByb3AocywgbXB0LnApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c1ttcHQucF0gPSBtcHQudjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHYgPT09IDEgJiYgdGhpcy50Ll9nc0NsYXNzUFQgPT09IHRoaXMpIHtcblx0XHRcdFx0XHRcdHRoaXMudC5fZ3NDbGFzc1BUID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy50LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpICE9PSB0aGlzLmUpIHtcblx0XHRcdFx0XHR0aGlzLnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5lKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJjbGFzc05hbWVcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHR2YXIgYiA9IHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiwgLy9kb24ndCB1c2UgdC5jbGFzc05hbWUgYmVjYXVzZSBpdCBkb2Vzbid0IHdvcmsgY29uc2lzdGVudGx5IG9uIFNWRyBlbGVtZW50czsgZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgYW5kIHNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHZhbHVlXCIpIGlzIG1vcmUgcmVsaWFibGUuXG5cdFx0XHRcdGNzc1RleHQgPSB0LnN0eWxlLmNzc1RleHQsXG5cdFx0XHRcdGRpZkRhdGEsIGJzLCBjbnB0LCBjbnB0TG9va3VwLCBtcHQ7XG5cdFx0XHRwdCA9IGNzc3AuX2NsYXNzTmFtZVBUID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgMik7XG5cdFx0XHRwdC5zZXRSYXRpbyA9IF9zZXRDbGFzc05hbWVSYXRpbztcblx0XHRcdHB0LnByID0gLTExO1xuXHRcdFx0X2hhc1ByaW9yaXR5ID0gdHJ1ZTtcblx0XHRcdHB0LmIgPSBiO1xuXHRcdFx0YnMgPSBfZ2V0QWxsU3R5bGVzKHQsIF9jcyk7XG5cdFx0XHQvL2lmIHRoZXJlJ3MgYSBjbGFzc05hbWUgdHdlZW4gYWxyZWFkeSBvcGVyYXRpbmcgb24gdGhlIHRhcmdldCwgZm9yY2UgaXQgdG8gaXRzIGVuZCBzbyB0aGF0IHRoZSBuZWNlc3NhcnkgaW5saW5lIHN0eWxlcyBhcmUgcmVtb3ZlZCBhbmQgdGhlIGNsYXNzIG5hbWUgaXMgYXBwbGllZCBiZWZvcmUgd2UgZGV0ZXJtaW5lIHRoZSBlbmQgc3RhdGUgKHdlIGRvbid0IHdhbnQgaW5saW5lIHN0eWxlcyBpbnRlcmZlcmluZyB0aGF0IHdlcmUgdGhlcmUganVzdCBmb3IgY2xhc3Mtc3BlY2lmaWMgdmFsdWVzKVxuXHRcdFx0Y25wdCA9IHQuX2dzQ2xhc3NQVDtcblx0XHRcdGlmIChjbnB0KSB7XG5cdFx0XHRcdGNucHRMb29rdXAgPSB7fTtcblx0XHRcdFx0bXB0ID0gY25wdC5kYXRhOyAvL2ZpcnN0IE1pbmlQcm9wVHdlZW4gd2hpY2ggc3RvcmVzIHRoZSBpbmxpbmUgc3R5bGVzIC0gd2UgbmVlZCB0byBmb3JjZSB0aGVzZSBzbyB0aGF0IHRoZSBpbmxpbmUgc3R5bGVzIGRvbid0IGNvbnRhbWluYXRlIHRoaW5ncy4gT3RoZXJ3aXNlLCB0aGVyZSdzIGEgc21hbGwgY2hhbmNlIHRoYXQgYSB0d2VlbiBjb3VsZCBzdGFydCBhbmQgdGhlIGlubGluZSB2YWx1ZXMgbWF0Y2ggdGhlIGRlc3RpbmF0aW9uIHZhbHVlcyBhbmQgdGhleSBuZXZlciBnZXQgY2xlYW5lZC5cblx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdGNucHRMb29rdXBbbXB0LnBdID0gMTtcblx0XHRcdFx0XHRtcHQgPSBtcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y25wdC5zZXRSYXRpbygxKTtcblx0XHRcdH1cblx0XHRcdHQuX2dzQ2xhc3NQVCA9IHB0O1xuXHRcdFx0cHQuZSA9IChlLmNoYXJBdCgxKSAhPT0gXCI9XCIpID8gZSA6IGIucmVwbGFjZShuZXcgUmVnRXhwKFwiKD86XFxcXHN8XilcIiArIGUuc3Vic3RyKDIpICsgXCIoPyFbXFxcXHctXSlcIiksIFwiXCIpICsgKChlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlLnN1YnN0cigyKSA6IFwiXCIpO1xuXHRcdFx0dC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBwdC5lKTtcblx0XHRcdGRpZkRhdGEgPSBfY3NzRGlmKHQsIGJzLCBfZ2V0QWxsU3R5bGVzKHQpLCB2YXJzLCBjbnB0TG9va3VwKTtcblx0XHRcdHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgYik7XG5cdFx0XHRwdC5kYXRhID0gZGlmRGF0YS5maXJzdE1QVDtcblx0XHRcdHQuc3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7IC8vd2UgcmVjb3JkZWQgY3NzVGV4dCBiZWZvcmUgd2Ugc3dhcHBlZCBjbGFzc2VzIGFuZCByYW4gX2dldEFsbFN0eWxlcygpIGJlY2F1c2UgaW4gY2FzZXMgd2hlbiBhIGNsYXNzTmFtZSB0d2VlbiBpcyBvdmVyd3JpdHRlbiwgd2UgcmVtb3ZlIGFsbCB0aGUgcmVsYXRlZCB0d2VlbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhhdCBjbGFzcyBjaGFuZ2UgKG90aGVyd2lzZSBjbGFzcy1zcGVjaWZpYyBzdHVmZiBjYW4ndCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdlJ3ZlIGRpcmVjdGx5IHNldCBvbiB0aGUgdGFyZ2V0J3Mgc3R5bGUgb2JqZWN0IGR1ZSB0byBzcGVjaWZpY2l0eSkuXG5cdFx0XHRwdCA9IHB0LnhmaXJzdCA9IGNzc3AucGFyc2UodCwgZGlmRGF0YS5kaWZzLCBwdCwgcGx1Z2luKTsgLy93ZSByZWNvcmQgdGhlIENTU1Byb3BUd2VlbiBhcyB0aGUgeGZpcnN0IHNvIHRoYXQgd2UgY2FuIGhhbmRsZSBvdmVyd3JpdGluZyBwcm9wZXJ0bHkgKGlmIFwiY2xhc3NOYW1lXCIgZ2V0cyBvdmVyd3JpdHRlbiwgd2UgbXVzdCBraWxsIGFsbCB0aGUgcHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhlIGNsYXNzTmFtZSBwYXJ0IG9mIHRoZSB0d2Vlbiwgc28gd2UgY2FuIGxvb3AgdGhyb3VnaCBmcm9tIHhmaXJzdCB0byB0aGUgcHQgaXRzZWxmKVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH19KTtcblxuXG5cdFx0dmFyIF9zZXRDbGVhclByb3BzUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRpZiAodiA9PT0gMSB8fCB2ID09PSAwKSBpZiAodGhpcy5kYXRhLl90b3RhbFRpbWUgPT09IHRoaXMuZGF0YS5fdG90YWxEdXJhdGlvbiAmJiB0aGlzLmRhdGEuZGF0YSAhPT0gXCJpc0Zyb21TdGFydFwiKSB7IC8vdGhpcy5kYXRhIHJlZmVycyB0byB0aGUgdHdlZW4uIE9ubHkgY2xlYXIgYXQgdGhlIEVORCBvZiB0aGUgdHdlZW4gKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIG1ha2UgdGhlIHJhdGlvIGdvIGZyb20gMSB0byAwLCBzbyB3ZSBjYW4ndCBqdXN0IGNoZWNrIHRoYXQgYW5kIGlmIHRoZSB0d2VlbiBpcyB0aGUgemVyby1kdXJhdGlvbiBvbmUgdGhhdCdzIGNyZWF0ZWQgaW50ZXJuYWxseSB0byByZW5kZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBpbiBhIGZyb20oKSB0d2VlbiwgaWdub3JlIHRoYXQgYmVjYXVzZSBvdGhlcndpc2UsIGZvciBleGFtcGxlLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbikuXG5cdFx0XHRcdHZhciBzID0gdGhpcy50LnN0eWxlLFxuXHRcdFx0XHRcdHRyYW5zZm9ybVBhcnNlID0gX3NwZWNpYWxQcm9wcy50cmFuc2Zvcm0ucGFyc2UsXG5cdFx0XHRcdFx0YSwgcCwgaSwgY2xlYXJUcmFuc2Zvcm0sIHRyYW5zZm9ybTtcblx0XHRcdFx0aWYgKHRoaXMuZSA9PT0gXCJhbGxcIikge1xuXHRcdFx0XHRcdHMuY3NzVGV4dCA9IFwiXCI7XG5cdFx0XHRcdFx0Y2xlYXJUcmFuc2Zvcm0gPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGEgPSB0aGlzLmUuc3BsaXQoXCIgXCIpLmpvaW4oXCJcIikuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHAgPSBhW2ldO1xuXHRcdFx0XHRcdFx0aWYgKF9zcGVjaWFsUHJvcHNbcF0pIHtcblx0XHRcdFx0XHRcdFx0aWYgKF9zcGVjaWFsUHJvcHNbcF0ucGFyc2UgPT09IHRyYW5zZm9ybVBhcnNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xlYXJUcmFuc2Zvcm0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHAgPSAocCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikgPyBfdHJhbnNmb3JtT3JpZ2luUHJvcCA6IF9zcGVjaWFsUHJvcHNbcF0ucDsgLy9lbnN1cmVzIHRoYXQgc3BlY2lhbCBwcm9wZXJ0aWVzIHVzZSB0aGUgcHJvcGVyIGJyb3dzZXItc3BlY2lmaWMgcHJvcGVydHkgbmFtZSwgbGlrZSBcInNjYWxlWFwiIG1pZ2h0IGJlIFwiLXdlYmtpdC10cmFuc2Zvcm1cIiBvciBcImJveFNoYWRvd1wiIG1pZ2h0IGJlIFwiLW1vei1ib3gtc2hhZG93XCJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X3JlbW92ZVByb3AocywgcCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjbGVhclRyYW5zZm9ybSkge1xuXHRcdFx0XHRcdF9yZW1vdmVQcm9wKHMsIF90cmFuc2Zvcm1Qcm9wKTtcblx0XHRcdFx0XHR0cmFuc2Zvcm0gPSB0aGlzLnQuX2dzVHJhbnNmb3JtO1xuXHRcdFx0XHRcdGlmICh0cmFuc2Zvcm0pIHtcblx0XHRcdFx0XHRcdGlmICh0cmFuc2Zvcm0uc3ZnKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIik7XG5cdFx0XHRcdFx0XHRcdHRoaXMudC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy50Ll9nc1RyYW5zZm9ybTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH07XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiY2xlYXJQcm9wc1wiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0KSB7XG5cdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgcHQsIDIpO1xuXHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0Q2xlYXJQcm9wc1JhdGlvO1xuXHRcdFx0cHQuZSA9IGU7XG5cdFx0XHRwdC5wciA9IC0xMDtcblx0XHRcdHB0LmRhdGEgPSBjc3NwLl90d2Vlbjtcblx0XHRcdF9oYXNQcmlvcml0eSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fX0pO1xuXG5cdFx0cCA9IFwiYmV6aWVyLHRocm93UHJvcHMscGh5c2ljc1Byb3BzLHBoeXNpY3MyRFwiLnNwbGl0KFwiLFwiKTtcblx0XHRpID0gcC5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0X3JlZ2lzdGVyUGx1Z2luUHJvcChwW2ldKTtcblx0XHR9XG5cblxuXG5cblxuXG5cblxuXHRcdHAgPSBDU1NQbHVnaW4ucHJvdG90eXBlO1xuXHRcdHAuX2ZpcnN0UFQgPSBwLl9sYXN0UGFyc2VkVHJhbnNmb3JtID0gcC5fdHJhbnNmb3JtID0gbnVsbDtcblxuXHRcdC8vZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMga2lja3MgZXZlcnl0aGluZyBvZmYsIHJlY29yZGluZyBzdGFydC9lbmQgdmFsdWVzLCBldGMuXG5cdFx0cC5fb25Jbml0VHdlZW4gPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMsIHR3ZWVuKSB7XG5cdFx0XHRpZiAoIXRhcmdldC5ub2RlVHlwZSkgeyAvL2NzcyBpcyBvbmx5IGZvciBkb20gZWxlbWVudHNcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0dGhpcy5fdHdlZW4gPSB0d2Vlbjtcblx0XHRcdHRoaXMuX3ZhcnMgPSB2YXJzO1xuXHRcdFx0X2F1dG9Sb3VuZCA9IHZhcnMuYXV0b1JvdW5kO1xuXHRcdFx0X2hhc1ByaW9yaXR5ID0gZmFsc2U7XG5cdFx0XHRfc3VmZml4TWFwID0gdmFycy5zdWZmaXhNYXAgfHwgQ1NTUGx1Z2luLnN1ZmZpeE1hcDtcblx0XHRcdF9jcyA9IF9nZXRDb21wdXRlZFN0eWxlKHRhcmdldCwgXCJcIik7XG5cdFx0XHRfb3ZlcndyaXRlUHJvcHMgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcztcblx0XHRcdHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdFx0diwgcHQsIHB0MiwgZmlyc3QsIGxhc3QsIG5leHQsIHpJbmRleCwgdHB0LCB0aHJlZUQ7XG5cdFx0XHRpZiAoX3JlcVNhZmFyaUZpeCkgaWYgKHN0eWxlLnpJbmRleCA9PT0gXCJcIikge1xuXHRcdFx0XHR2ID0gX2dldFN0eWxlKHRhcmdldCwgXCJ6SW5kZXhcIiwgX2NzKTtcblx0XHRcdFx0aWYgKHYgPT09IFwiYXV0b1wiIHx8IHYgPT09IFwiXCIpIHtcblx0XHRcdFx0XHQvL2NvcnJlY3RzIGEgYnVnIGluIFtub24tQW5kcm9pZF0gU2FmYXJpIHRoYXQgcHJldmVudHMgaXQgZnJvbSByZXBhaW50aW5nIGVsZW1lbnRzIGluIHRoZWlyIG5ldyBwb3NpdGlvbnMgaWYgdGhleSBkb24ndCBoYXZlIGEgekluZGV4IHNldC4gV2UgYWxzbyBjYW4ndCBqdXN0IGFwcGx5IHRoaXMgaW5zaWRlIF9wYXJzZVRyYW5zZm9ybSgpIGJlY2F1c2UgYW55dGhpbmcgdGhhdCdzIG1vdmVkIGluIGFueSB3YXkgKGxpa2UgdXNpbmcgXCJsZWZ0XCIgb3IgXCJ0b3BcIiBpbnN0ZWFkIG9mIHRyYW5zZm9ybXMgbGlrZSBcInhcIiBhbmQgXCJ5XCIpIGNhbiBiZSBhZmZlY3RlZCwgc28gaXQgaXMgYmVzdCB0byBlbnN1cmUgdGhhdCBhbnl0aGluZyB0aGF0J3MgdHdlZW5pbmcgaGFzIGEgei1pbmRleC4gU2V0dGluZyBcIldlYmtpdFBlcnNwZWN0aXZlXCIgdG8gYSBub24temVybyB2YWx1ZSB3b3JrZWQgdG9vIGV4Y2VwdCB0aGF0IG9uIGlPUyBTYWZhcmkgdGhpbmdzIHdvdWxkIGZsaWNrZXIgcmFuZG9tbHkuIFBsdXMgekluZGV4IGlzIGxlc3MgbWVtb3J5LWludGVuc2l2ZS5cblx0XHRcdFx0XHR0aGlzLl9hZGRMYXp5U2V0KHN0eWxlLCBcInpJbmRleFwiLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mKHZhcnMpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGZpcnN0ID0gc3R5bGUuY3NzVGV4dDtcblx0XHRcdFx0diA9IF9nZXRBbGxTdHlsZXModGFyZ2V0LCBfY3MpO1xuXHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gZmlyc3QgKyBcIjtcIiArIHZhcnM7XG5cdFx0XHRcdHYgPSBfY3NzRGlmKHRhcmdldCwgdiwgX2dldEFsbFN0eWxlcyh0YXJnZXQpKS5kaWZzO1xuXHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkgJiYgX29wYWNpdHlWYWxFeHAudGVzdCh2YXJzKSkge1xuXHRcdFx0XHRcdHYub3BhY2l0eSA9IHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhcnMgPSB2O1xuXHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gZmlyc3Q7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YXJzLmNsYXNzTmFtZSkgeyAvL2NsYXNzTmFtZSB0d2VlbnMgd2lsbCBjb21iaW5lIGFueSBkaWZmZXJlbmNlcyB0aGV5IGZpbmQgaW4gdGhlIGNzcyB3aXRoIHRoZSB2YXJzIHRoYXQgYXJlIHBhc3NlZCBpbiwgc28ge2NsYXNzTmFtZTpcIm15Q2xhc3NcIiwgc2NhbGU6MC41LCBsZWZ0OjIwfSB3b3VsZCB3b3JrLlxuXHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSBfc3BlY2lhbFByb3BzLmNsYXNzTmFtZS5wYXJzZSh0YXJnZXQsIHZhcnMuY2xhc3NOYW1lLCBcImNsYXNzTmFtZVwiLCB0aGlzLCBudWxsLCBudWxsLCB2YXJzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdCA9IHRoaXMucGFyc2UodGFyZ2V0LCB2YXJzLCBudWxsKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX3RyYW5zZm9ybVR5cGUpIHtcblx0XHRcdFx0dGhyZWVEID0gKHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09IDMpO1xuXHRcdFx0XHRpZiAoIV90cmFuc2Zvcm1Qcm9wKSB7XG5cdFx0XHRcdFx0c3R5bGUuem9vbSA9IDE7IC8vaGVscHMgY29ycmVjdCBhbiBJRSBpc3N1ZS5cblx0XHRcdFx0fSBlbHNlIGlmIChfaXNTYWZhcmkpIHtcblx0XHRcdFx0XHRfcmVxU2FmYXJpRml4ID0gdHJ1ZTtcblx0XHRcdFx0XHQvL2lmIHpJbmRleCBpc24ndCBzZXQsIGlPUyBTYWZhcmkgZG9lc24ndCByZXBhaW50IHRoaW5ncyBjb3JyZWN0bHkgc29tZXRpbWVzIChzZWVtaW5nbHkgYXQgcmFuZG9tKS5cblx0XHRcdFx0XHRpZiAoc3R5bGUuekluZGV4ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHR6SW5kZXggPSBfZ2V0U3R5bGUodGFyZ2V0LCBcInpJbmRleFwiLCBfY3MpO1xuXHRcdFx0XHRcdFx0aWYgKHpJbmRleCA9PT0gXCJhdXRvXCIgfHwgekluZGV4ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2FkZExhenlTZXQoc3R5bGUsIFwiekluZGV4XCIsIDApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL1NldHRpbmcgV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IGNvcnJlY3RzIDMgYnVnczpcblx0XHRcdFx0XHQvLyAxKSBbbm9uLUFuZHJvaWRdIFNhZmFyaSBza2lwcyByZW5kZXJpbmcgY2hhbmdlcyB0byBcInRvcFwiIGFuZCBcImxlZnRcIiB0aGF0IGFyZSBtYWRlIG9uIHRoZSBzYW1lIGZyYW1lL3JlbmRlciBhcyBhIHRyYW5zZm9ybSB1cGRhdGUuXG5cdFx0XHRcdFx0Ly8gMikgaU9TIFNhZmFyaSBzb21ldGltZXMgbmVnbGVjdHMgdG8gcmVwYWludCBlbGVtZW50cyBpbiB0aGVpciBuZXcgcG9zaXRpb25zLiBTZXR0aW5nIFwiV2Via2l0UGVyc3BlY3RpdmVcIiB0byBhIG5vbi16ZXJvIHZhbHVlIHdvcmtlZCB0b28gZXhjZXB0IHRoYXQgb24gaU9TIFNhZmFyaSB0aGluZ3Mgd291bGQgZmxpY2tlciByYW5kb21seS5cblx0XHRcdFx0XHQvLyAzKSBTYWZhcmkgc29tZXRpbWVzIGRpc3BsYXllZCBvZGQgYXJ0aWZhY3RzIHdoZW4gdHdlZW5pbmcgdGhlIHRyYW5zZm9ybSAob3IgV2Via2l0VHJhbnNmb3JtKSBwcm9wZXJ0eSwgbGlrZSBnaG9zdHMgb2YgdGhlIGVkZ2VzIG9mIHRoZSBlbGVtZW50IHJlbWFpbmVkLiBEZWZpbml0ZWx5IGEgYnJvd3NlciBidWcuXG5cdFx0XHRcdFx0Ly9Ob3RlOiB3ZSBhbGxvdyB0aGUgdXNlciB0byBvdmVycmlkZSB0aGUgYXV0by1zZXR0aW5nIGJ5IGRlZmluaW5nIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSBpbiB0aGUgdmFycyBvZiB0aGUgdHdlZW4uXG5cdFx0XHRcdFx0aWYgKF9pc1NhZmFyaUxUNikge1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkTGF6eVNldChzdHlsZSwgXCJXZWJraXRCYWNrZmFjZVZpc2liaWxpdHlcIiwgdGhpcy5fdmFycy5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgfHwgKHRocmVlRCA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdDIgPSBwdDtcblx0XHRcdFx0d2hpbGUgKHB0MiAmJiBwdDIuX25leHQpIHtcblx0XHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0YXJnZXQsIFwidHJhbnNmb3JtXCIsIDAsIDAsIG51bGwsIDIpO1xuXHRcdFx0XHR0aGlzLl9saW5rQ1NTUCh0cHQsIG51bGwsIHB0Mik7XG5cdFx0XHRcdHRwdC5zZXRSYXRpbyA9IF90cmFuc2Zvcm1Qcm9wID8gX3NldFRyYW5zZm9ybVJhdGlvIDogX3NldElFVHJhbnNmb3JtUmF0aW87XG5cdFx0XHRcdHRwdC5kYXRhID0gdGhpcy5fdHJhbnNmb3JtIHx8IF9nZXRUcmFuc2Zvcm0odGFyZ2V0LCBfY3MsIHRydWUpO1xuXHRcdFx0XHR0cHQudHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0dHB0LnByID0gLTE7IC8vZW5zdXJlcyB0aGF0IHRoZSB0cmFuc2Zvcm1zIGdldCBhcHBsaWVkIGFmdGVyIHRoZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLlxuXHRcdFx0XHRfb3ZlcndyaXRlUHJvcHMucG9wKCk7IC8vd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSB0aGUgb3ZlcndyaXRlIG9mIGFsbCBcInRyYW5zZm9ybVwiIHR3ZWVucyBvZiB0aGUgdGFyZ2V0IC0gd2Ugb25seSBjYXJlIGFib3V0IGluZGl2aWR1YWwgdHJhbnNmb3JtIHByb3BlcnRpZXMgbGlrZSBzY2FsZVgsIHJvdGF0aW9uLCBldGMuIFRoZSBDU1NQcm9wVHdlZW4gY29uc3RydWN0b3IgYXV0b21hdGljYWxseSBhZGRzIHRoZSBwcm9wZXJ0eSB0byBfb3ZlcndyaXRlUHJvcHMgd2hpY2ggaXMgd2h5IHdlIG5lZWQgdG8gcG9wKCkgaGVyZS5cblx0XHRcdH1cblxuXHRcdFx0aWYgKF9oYXNQcmlvcml0eSkge1xuXHRcdFx0XHQvL3Jlb3JkZXJzIHRoZSBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwciAocHJpb3JpdHkpXG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdG5leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRwdDIgPSBmaXJzdDtcblx0XHRcdFx0XHR3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG5cdFx0XHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSkge1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zmlyc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fbmV4dCA9IHB0MikpIHtcblx0XHRcdFx0XHRcdHB0Mi5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsYXN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9maXJzdFBUID0gZmlyc3Q7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cblx0XHRwLnBhcnNlID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG5cdFx0XHRcdHAsIHNwLCBibiwgZW4sIGJzLCBlcywgYnNmeCwgZXNmeCwgaXNTdHIsIHJlbDtcblx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdGVzID0gdmFyc1twXTsgLy9lbmRpbmcgdmFsdWUgc3RyaW5nXG5cdFx0XHRcdHNwID0gX3NwZWNpYWxQcm9wc1twXTsgLy9TcGVjaWFsUHJvcCBsb29rdXAuXG5cdFx0XHRcdGlmIChzcCkge1xuXHRcdFx0XHRcdHB0ID0gc3AucGFyc2UodGFyZ2V0LCBlcywgcCwgdGhpcywgcHQsIHBsdWdpbiwgdmFycyk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicyA9IF9nZXRTdHlsZSh0YXJnZXQsIHAsIF9jcykgKyBcIlwiO1xuXHRcdFx0XHRcdGlzU3RyID0gKHR5cGVvZihlcykgPT09IFwic3RyaW5nXCIpO1xuXHRcdFx0XHRcdGlmIChwID09PSBcImNvbG9yXCIgfHwgcCA9PT0gXCJmaWxsXCIgfHwgcCA9PT0gXCJzdHJva2VcIiB8fCBwLmluZGV4T2YoXCJDb2xvclwiKSAhPT0gLTEgfHwgKGlzU3RyICYmIF9yZ2Joc2xFeHAudGVzdChlcykpKSB7IC8vT3BlcmEgdXNlcyBiYWNrZ3JvdW5kOiB0byBkZWZpbmUgY29sb3Igc29tZXRpbWVzIGluIGFkZGl0aW9uIHRvIGJhY2tncm91bmRDb2xvcjpcblx0XHRcdFx0XHRcdGlmICghaXNTdHIpIHtcblx0XHRcdFx0XHRcdFx0ZXMgPSBfcGFyc2VDb2xvcihlcyk7XG5cdFx0XHRcdFx0XHRcdGVzID0gKChlcy5sZW5ndGggPiAzKSA/IFwicmdiYShcIiA6IFwicmdiKFwiKSArIGVzLmpvaW4oXCIsXCIpICsgXCIpXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwdCA9IF9wYXJzZUNvbXBsZXgoc3R5bGUsIHAsIGJzLCBlcywgdHJ1ZSwgXCJ0cmFuc3BhcmVudFwiLCBwdCwgMCwgcGx1Z2luKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaXNTdHIgJiYgX2NvbXBsZXhFeHAudGVzdChlcykpIHtcblx0XHRcdFx0XHRcdHB0ID0gX3BhcnNlQ29tcGxleChzdHlsZSwgcCwgYnMsIGVzLCB0cnVlLCBudWxsLCBwdCwgMCwgcGx1Z2luKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRibiA9IHBhcnNlRmxvYXQoYnMpO1xuXHRcdFx0XHRcdFx0YnNmeCA9IChibiB8fCBibiA9PT0gMCkgPyBicy5zdWJzdHIoKGJuICsgXCJcIikubGVuZ3RoKSA6IFwiXCI7IC8vcmVtZW1iZXIsIGJzIGNvdWxkIGJlIG5vbi1udW1lcmljIGxpa2UgXCJub3JtYWxcIiBmb3IgZm9udFdlaWdodCwgc28gd2Ugc2hvdWxkIGRlZmF1bHQgdG8gYSBibGFuayBzdWZmaXggaW4gdGhhdCBjYXNlLlxuXG5cdFx0XHRcdFx0XHRpZiAoYnMgPT09IFwiXCIgfHwgYnMgPT09IFwiYXV0b1wiKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwID09PSBcIndpZHRoXCIgfHwgcCA9PT0gXCJoZWlnaHRcIikge1xuXHRcdFx0XHRcdFx0XHRcdGJuID0gX2dldERpbWVuc2lvbih0YXJnZXQsIHAsIF9jcyk7XG5cdFx0XHRcdFx0XHRcdFx0YnNmeCA9IFwicHhcIjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwID09PSBcImxlZnRcIiB8fCBwID09PSBcInRvcFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gPSBfY2FsY3VsYXRlT2Zmc2V0KHRhcmdldCwgcCwgX2NzKTtcblx0XHRcdFx0XHRcdFx0XHRic2Z4ID0gXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGJuID0gKHAgIT09IFwib3BhY2l0eVwiKSA/IDAgOiAxO1xuXHRcdFx0XHRcdFx0XHRcdGJzZnggPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJlbCA9IChpc1N0ciAmJiBlcy5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRcdFx0ZW4gPSBwYXJzZUludChlcy5jaGFyQXQoMCkgKyBcIjFcIiwgMTApO1xuXHRcdFx0XHRcdFx0XHRlcyA9IGVzLnN1YnN0cigyKTtcblx0XHRcdFx0XHRcdFx0ZW4gKj0gcGFyc2VGbG9hdChlcyk7XG5cdFx0XHRcdFx0XHRcdGVzZnggPSBlcy5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZW4gPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRcdFx0ZXNmeCA9IGlzU3RyID8gZXMucmVwbGFjZShfc3VmZml4RXhwLCBcIlwiKSA6IFwiXCI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChlc2Z4ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRcdGVzZnggPSAocCBpbiBfc3VmZml4TWFwKSA/IF9zdWZmaXhNYXBbcF0gOiBic2Z4OyAvL3BvcHVsYXRlIHRoZSBlbmQgc3VmZml4LCBwcmlvcml0aXppbmcgdGhlIG1hcCwgdGhlbiBpZiBub25lIGlzIGZvdW5kLCB1c2UgdGhlIGJlZ2lubmluZyBzdWZmaXguXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGVzID0gKGVuIHx8IGVuID09PSAwKSA/IChyZWwgPyBlbiArIGJuIDogZW4pICsgZXNmeCA6IHZhcnNbcF07IC8vZW5zdXJlcyB0aGF0IGFueSArPSBvciAtPSBwcmVmaXhlcyBhcmUgdGFrZW4gY2FyZSBvZi4gUmVjb3JkIHRoZSBlbmQgdmFsdWUgYmVmb3JlIG5vcm1hbGl6aW5nIHRoZSBzdWZmaXggYmVjYXVzZSB3ZSBhbHdheXMgd2FudCB0byBlbmQgdGhlIHR3ZWVuIG9uIGV4YWN0bHkgd2hhdCB0aGV5IGludGVuZGVkIGV2ZW4gaWYgaXQgZG9lc24ndCBtYXRjaCB0aGUgYmVnaW5uaW5nIHZhbHVlJ3Mgc3VmZml4LlxuXG5cdFx0XHRcdFx0XHQvL2lmIHRoZSBiZWdpbm5pbmcvZW5kaW5nIHN1ZmZpeGVzIGRvbid0IG1hdGNoLCBub3JtYWxpemUgdGhlbS4uLlxuXHRcdFx0XHRcdFx0aWYgKGJzZnggIT09IGVzZngpIGlmIChlc2Z4ICE9PSBcIlwiKSBpZiAoZW4gfHwgZW4gPT09IDApIGlmIChibikgeyAvL25vdGU6IGlmIHRoZSBiZWdpbm5pbmcgdmFsdWUgKGJuKSBpcyAwLCB3ZSBkb24ndCBuZWVkIHRvIGNvbnZlcnQgdW5pdHMhXG5cdFx0XHRcdFx0XHRcdGJuID0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIGJuLCBic2Z4KTtcblx0XHRcdFx0XHRcdFx0aWYgKGVzZnggPT09IFwiJVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gLz0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIDEwMCwgXCIlXCIpIC8gMTAwO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh2YXJzLnN0cmljdFVuaXRzICE9PSB0cnVlKSB7IC8vc29tZSBicm93c2VycyByZXBvcnQgb25seSBcInB4XCIgdmFsdWVzIGluc3RlYWQgb2YgYWxsb3dpbmcgXCIlXCIgd2l0aCBnZXRDb21wdXRlZFN0eWxlKCksIHNvIHdlIGFzc3VtZSB0aGF0IGlmIHdlJ3JlIHR3ZWVuaW5nIHRvIGEgJSwgd2Ugc2hvdWxkIHN0YXJ0IHRoZXJlIHRvbyB1bmxlc3Mgc3RyaWN0VW5pdHM6dHJ1ZSBpcyBkZWZpbmVkLiBUaGlzIGFwcHJvYWNoIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHJlc3BvbnNpdmUgZGVzaWducyB0aGF0IHVzZSBmcm9tKCkgdHdlZW5zLlxuXHRcdFx0XHRcdFx0XHRcdFx0YnMgPSBibiArIFwiJVwiO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGVzZnggPT09IFwiZW1cIiB8fCBlc2Z4ID09PSBcInJlbVwiIHx8IGVzZnggPT09IFwidndcIiB8fCBlc2Z4ID09PSBcInZoXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiAvPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgMSwgZXNmeCk7XG5cblx0XHRcdFx0XHRcdFx0Ly9vdGhlcndpc2UgY29udmVydCB0byBwaXhlbHMuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZXNmeCAhPT0gXCJweFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZW4gPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgZW4sIGVzZngpO1xuXHRcdFx0XHRcdFx0XHRcdGVzZnggPSBcInB4XCI7IC8vd2UgZG9uJ3QgdXNlIGJzZnggYWZ0ZXIgdGhpcywgc28gd2UgZG9uJ3QgbmVlZCB0byBzZXQgaXQgdG8gcHggdG9vLlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChyZWwpIGlmIChlbiB8fCBlbiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGVzID0gKGVuICsgYm4pICsgZXNmeDsgLy90aGUgY2hhbmdlcyB3ZSBtYWRlIGFmZmVjdCByZWxhdGl2ZSBjYWxjdWxhdGlvbnMsIHNvIGFkanVzdCB0aGUgZW5kIHZhbHVlIGhlcmUuXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdFx0XHRlbiArPSBibjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKChibiB8fCBibiA9PT0gMCkgJiYgKGVuIHx8IGVuID09PSAwKSkgeyAvL2Zhc3RlciB0aGFuIGlzTmFOKCkuIEFsc28sIHByZXZpb3VzbHkgd2UgcmVxdWlyZWQgZW4gIT09IGJuIGJ1dCB0aGF0IGRvZXNuJ3QgcmVhbGx5IGdhaW4gbXVjaCBwZXJmb3JtYW5jZSBhbmQgaXQgcHJldmVudHMgX3BhcnNlVG9Qcm94eSgpIGZyb20gd29ya2luZyBwcm9wZXJseSBpZiBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgbWF0Y2ggYnV0IG5lZWQgdG8gZ2V0IHR3ZWVuZWQgYnkgYW4gZXh0ZXJuYWwgcGx1Z2luIGFueXdheS4gRm9yIGV4YW1wbGUsIGEgYmV6aWVyIHR3ZWVuIHdoZXJlIHRoZSB0YXJnZXQgc3RhcnRzIGF0IGxlZnQ6MCBhbmQgaGFzIHRoZXNlIHBvaW50czogW3tsZWZ0OjUwfSx7bGVmdDowfV0gd291bGRuJ3Qgd29yayBwcm9wZXJseSBiZWNhdXNlIHdoZW4gcGFyc2luZyB0aGUgbGFzdCBwb2ludCwgaXQnZCBtYXRjaCB0aGUgZmlyc3QgKGN1cnJlbnQpIG9uZSBhbmQgYSBub24tdHdlZW5pbmcgQ1NTUHJvcFR3ZWVuIHdvdWxkIGJlIHJlY29yZGVkIHdoZW4gd2UgYWN0dWFsbHkgbmVlZCBhIG5vcm1hbCB0d2VlbiAodHlwZTowKSBzbyB0aGF0IHRoaW5ncyBnZXQgdXBkYXRlZCBkdXJpbmcgdGhlIHR3ZWVuIHByb3Blcmx5LlxuXHRcdFx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIHAsIGJuLCBlbiAtIGJuLCBwdCwgMCwgcCwgKF9hdXRvUm91bmQgIT09IGZhbHNlICYmIChlc2Z4ID09PSBcInB4XCIgfHwgcCA9PT0gXCJ6SW5kZXhcIikpLCAwLCBicywgZXMpO1xuXHRcdFx0XHRcdFx0XHRwdC54czAgPSBlc2Z4O1xuXHRcdFx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwidHdlZW4gXCIrcCtcIiBmcm9tIFwiK3B0LmIrXCIgKFwiK2JuK2VzZngrXCIpIHRvIFwiK3B0LmUrXCIgd2l0aCBzdWZmaXg6IFwiK3B0LnhzMCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0eWxlW3BdID09PSB1bmRlZmluZWQgfHwgIWVzICYmIChlcyArIFwiXCIgPT09IFwiTmFOXCIgfHwgZXMgPT0gbnVsbCkpIHtcblx0XHRcdFx0XHRcdFx0X2xvZyhcImludmFsaWQgXCIgKyBwICsgXCIgdHdlZW4gdmFsdWU6IFwiICsgdmFyc1twXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIHAsIGVuIHx8IGJuIHx8IDAsIDAsIHB0LCAtMSwgcCwgZmFsc2UsIDAsIGJzLCBlcyk7XG5cdFx0XHRcdFx0XHRcdHB0LnhzMCA9IChlcyA9PT0gXCJub25lXCIgJiYgKHAgPT09IFwiZGlzcGxheVwiIHx8IHAuaW5kZXhPZihcIlN0eWxlXCIpICE9PSAtMSkpID8gYnMgOiBlczsgLy9pbnRlcm1lZGlhdGUgdmFsdWUgc2hvdWxkIHR5cGljYWxseSBiZSBzZXQgaW1tZWRpYXRlbHkgKGVuZCB2YWx1ZSkgZXhjZXB0IGZvciBcImRpc3BsYXlcIiBvciB0aGluZ3MgbGlrZSBib3JkZXJUb3BTdHlsZSwgYm9yZGVyQm90dG9tU3R5bGUsIGV0Yy4gd2hpY2ggc2hvdWxkIHVzZSB0aGUgYmVnaW5uaW5nIHZhbHVlIGR1cmluZyB0aGUgdHdlZW4uXG5cdFx0XHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJub24tdHdlZW5pbmcgdmFsdWUgXCIrcCtcIjogXCIrcHQueHMwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBsdWdpbikgaWYgKHB0ICYmICFwdC5wbHVnaW4pIHtcblx0XHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9O1xuXG5cblx0XHQvL2dldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHR3ZWVuIHVwZGF0ZXMsIHBhc3NpbmcgdGhlIG5ldyByYXRpbyAodHlwaWNhbGx5IGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgbm90IGFsd2F5cyAoZm9yIGV4YW1wbGUsIGlmIGFuIEVsYXN0aWMuZWFzZU91dCBpcyB1c2VkLCB0aGUgdmFsdWUgY2FuIGp1bXAgYWJvdmUgMSBtaWQtdHdlZW4pLiBJdCB3aWxsIGFsd2F5cyBzdGFydCBhbmQgMCBhbmQgZW5kIGF0IDEuXG5cdFx0cC5zZXRSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHR2YWwsIHN0ciwgaTtcblx0XHRcdC8vYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4sIHdlIHNldCB0aGUgdmFsdWVzIHRvIGV4YWN0bHkgd2hhdCB3ZSByZWNlaXZlZCBpbiBvcmRlciB0byBtYWtlIHN1cmUgbm9uLXR3ZWVuaW5nIHZhbHVlcyAobGlrZSBcInBvc2l0aW9uXCIgb3IgXCJmbG9hdFwiIG9yIHdoYXRldmVyKSBhcmUgc2V0IGFuZCBzbyB0aGF0IGlmIHRoZSBiZWdpbm5pbmcvZW5kaW5nIHN1ZmZpeGVzICh1bml0cykgZGlkbid0IG1hdGNoIGFuZCB3ZSBub3JtYWxpemVkIHRvIHB4LCB0aGUgdmFsdWUgdGhhdCB0aGUgdXNlciBwYXNzZWQgaW4gaXMgdXNlZCBoZXJlLiBXZSBjaGVjayB0byBzZWUgaWYgdGhlIHR3ZWVuIGlzIGF0IGl0cyBiZWdpbm5pbmcgaW4gY2FzZSBpdCdzIGEgZnJvbSgpIHR3ZWVuIGluIHdoaWNoIGNhc2UgdGhlIHJhdGlvIHdpbGwgYWN0dWFsbHkgZ28gZnJvbSAxIHRvIDAgb3ZlciB0aGUgY291cnNlIG9mIHRoZSB0d2VlbiAoYmFja3dhcmRzKS5cblx0XHRcdGlmICh2ID09PSAxICYmICh0aGlzLl90d2Vlbi5fdGltZSA9PT0gdGhpcy5fdHdlZW4uX2R1cmF0aW9uIHx8IHRoaXMuX3R3ZWVuLl90aW1lID09PSAwKSkge1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRpZiAocHQudHlwZSAhPT0gMikge1xuXHRcdFx0XHRcdFx0aWYgKHB0LnIgJiYgcHQudHlwZSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0dmFsID0gTWF0aC5yb3VuZChwdC5zICsgcHQuYyk7XG5cdFx0XHRcdFx0XHRcdGlmICghcHQudHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSB2YWwgKyBwdC54czA7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gMSkgeyAvL2NvbXBsZXggdmFsdWUgKG9uZSB0aGF0IHR5cGljYWxseSBoYXMgbXVsdGlwbGUgbnVtYmVycyBpbnNpZGUgYSBzdHJpbmcsIGxpa2UgXCJyZWN0KDVweCwxMHB4LDIwcHgsMjVweClcIlxuXHRcdFx0XHRcdFx0XHRcdGkgPSBwdC5sO1xuXHRcdFx0XHRcdFx0XHRcdHN0ciA9IHB0LnhzMCArIHZhbCArIHB0LnhzMTtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgcHQubDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gcHRbXCJ4blwiK2ldICsgcHRbXCJ4c1wiKyhpKzEpXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHN0cjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnNldFJhdGlvKHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAodiB8fCAhKHRoaXMuX3R3ZWVuLl90aW1lID09PSB0aGlzLl90d2Vlbi5fZHVyYXRpb24gfHwgdGhpcy5fdHdlZW4uX3RpbWUgPT09IDApIHx8IHRoaXMuX3R3ZWVuLl9yYXdQcmV2VGltZSA9PT0gLTAuMDAwMDAxKSB7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdHZhbCA9IHB0LmMgKiB2ICsgcHQucztcblx0XHRcdFx0XHRpZiAocHQucikge1xuXHRcdFx0XHRcdFx0dmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsIDwgbWluKSBpZiAodmFsID4gLW1pbikge1xuXHRcdFx0XHRcdFx0dmFsID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFwdC50eXBlKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gdmFsICsgcHQueHMwO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gMSkgeyAvL2NvbXBsZXggdmFsdWUgKG9uZSB0aGF0IHR5cGljYWxseSBoYXMgbXVsdGlwbGUgbnVtYmVycyBpbnNpZGUgYSBzdHJpbmcsIGxpa2UgXCJyZWN0KDVweCwxMHB4LDIwcHgsMjVweClcIlxuXHRcdFx0XHRcdFx0aSA9IHB0Lmw7XG5cdFx0XHRcdFx0XHRpZiAoaSA9PT0gMikge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpID09PSAzKSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czIgKyBwdC54bjIgKyBwdC54czM7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IDQpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMiArIHB0LnhuMiArIHB0LnhzMyArIHB0LnhuMyArIHB0LnhzNDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gNSkge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyICsgcHQueG4yICsgcHQueHMzICsgcHQueG4zICsgcHQueHM0ICsgcHQueG40ICsgcHQueHM1O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c3RyID0gcHQueHMwICsgdmFsICsgcHQueHMxO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgcHQubDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieG5cIitpXSArIHB0W1wieHNcIisoaSsxKV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHN0cjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gLTEpIHsgLy9ub24tdHdlZW5pbmcgdmFsdWVcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czA7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnNldFJhdGlvKSB7IC8vY3VzdG9tIHNldFJhdGlvKCkgZm9yIHRoaW5ncyBsaWtlIFNwZWNpYWxQcm9wcywgZXh0ZXJuYWwgcGx1Z2lucywgZXRjLlxuXHRcdFx0XHRcdFx0cHQuc2V0UmF0aW8odik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly9pZiB0aGUgdHdlZW4gaXMgcmV2ZXJzZWQgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHZhbHVlcyB3aGljaCBtYXkgaGF2ZSBkaWZmZXJlbnQgdW5pdHMgKGxpa2UgJSBpbnN0ZWFkIG9mIHB4IG9yIGVtIG9yIHdoYXRldmVyKS5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdGlmIChwdC50eXBlICE9PSAyKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuYjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQuc2V0UmF0aW8odik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBGb3JjZXMgcmVuZGVyaW5nIG9mIHRoZSB0YXJnZXQncyB0cmFuc2Zvcm1zIChyb3RhdGlvbiwgc2NhbGUsIGV0Yy4pIHdoZW5ldmVyIHRoZSBDU1NQbHVnaW4ncyBzZXRSYXRpbygpIGlzIGNhbGxlZC5cblx0XHQgKiBCYXNpY2FsbHksIHRoaXMgdGVsbHMgdGhlIENTU1BsdWdpbiB0byBjcmVhdGUgYSBDU1NQcm9wVHdlZW4gKHR5cGUgMikgYWZ0ZXIgaW5zdGFudGlhdGlvbiB0aGF0IHJ1bnMgbGFzdCBpbiB0aGUgbGlua2VkXG5cdFx0ICogbGlzdCBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlICgzRCBvciAyRCkgcmVuZGVyaW5nIGZ1bmN0aW9uLiBXZSBzZXBhcmF0ZSB0aGlzIGludG8gaXRzIG93biBtZXRob2Qgc28gdGhhdCB3ZSBjYW4gY2FsbFxuXHRcdCAqIGl0IGZyb20gb3RoZXIgcGx1Z2lucyBsaWtlIEJlemllclBsdWdpbiBpZiwgZm9yIGV4YW1wbGUsIGl0IG5lZWRzIHRvIGFwcGx5IGFuIGF1dG9Sb3RhdGlvbiBhbmQgdGhpcyBDU1NQbHVnaW5cblx0XHQgKiBkb2Vzbid0IGhhdmUgYW55IHRyYW5zZm9ybS1yZWxhdGVkIHByb3BlcnRpZXMgb2YgaXRzIG93bi4gWW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kIGFzIG1hbnkgdGltZXMgYXMgeW91XG5cdFx0ICogd2FudCBhbmQgaXQgd29uJ3QgY3JlYXRlIGR1cGxpY2F0ZSBDU1NQcm9wVHdlZW5zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSB0aHJlZUQgaWYgdHJ1ZSwgaXQgc2hvdWxkIGFwcGx5IDNEIHR3ZWVucyAob3RoZXJ3aXNlLCBqdXN0IDJEIG9uZXMgYXJlIGZpbmUgYW5kIHR5cGljYWxseSBmYXN0ZXIpXG5cdFx0ICovXG5cdFx0cC5fZW5hYmxlVHJhbnNmb3JtcyA9IGZ1bmN0aW9uKHRocmVlRCkge1xuXHRcdFx0dGhpcy5fdHJhbnNmb3JtID0gdGhpcy5fdHJhbnNmb3JtIHx8IF9nZXRUcmFuc2Zvcm0odGhpcy5fdGFyZ2V0LCBfY3MsIHRydWUpOyAvL2Vuc3VyZXMgdGhhdCB0aGUgZWxlbWVudCBoYXMgYSBfZ3NUcmFuc2Zvcm0gcHJvcGVydHkgd2l0aCB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzLlxuXHRcdFx0dGhpcy5fdHJhbnNmb3JtVHlwZSA9ICghKHRoaXMuX3RyYW5zZm9ybS5zdmcgJiYgX3VzZVNWR1RyYW5zZm9ybUF0dHIpICYmICh0aHJlZUQgfHwgdGhpcy5fdHJhbnNmb3JtVHlwZSA9PT0gMykpID8gMyA6IDI7XG5cdFx0fTtcblxuXHRcdHZhciBsYXp5U2V0ID0gZnVuY3Rpb24odikge1xuXHRcdFx0dGhpcy50W3RoaXMucF0gPSB0aGlzLmU7XG5cdFx0XHR0aGlzLmRhdGEuX2xpbmtDU1NQKHRoaXMsIHRoaXMuX25leHQsIG51bGwsIHRydWUpOyAvL3dlIHB1cnBvc2VmdWxseSBrZWVwIHRoaXMuX25leHQgZXZlbiB0aG91Z2ggaXQnZCBtYWtlIHNlbnNlIHRvIG51bGwgaXQsIGJ1dCB0aGlzIGlzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBhcyB0aGlzIGhhcHBlbnMgZHVyaW5nIHRoZSB3aGlsZSAocHQpIHt9IGxvb3AgaW4gc2V0UmF0aW8oKSBhdCB0aGUgYm90dG9tIG9mIHdoaWNoIGl0IHNldHMgcHQgPSBwdC5fbmV4dCwgc28gaWYgd2UgbnVsbCBpdCwgdGhlIGxpbmtlZCBsaXN0IHdpbGwgYmUgYnJva2VuIGluIHRoYXQgbG9vcC5cblx0XHR9O1xuXHRcdC8qKiBAcHJpdmF0ZSBHaXZlcyB1cyBhIHdheSB0byBzZXQgYSB2YWx1ZSBvbiB0aGUgZmlyc3QgcmVuZGVyIChhbmQgb25seSB0aGUgZmlyc3QgcmVuZGVyKS4gKiovXG5cdFx0cC5fYWRkTGF6eVNldCA9IGZ1bmN0aW9uKHQsIHAsIHYpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHRoaXMuX2ZpcnN0UFQsIDIpO1xuXHRcdFx0cHQuZSA9IHY7XG5cdFx0XHRwdC5zZXRSYXRpbyA9IGxhenlTZXQ7XG5cdFx0XHRwdC5kYXRhID0gdGhpcztcblx0XHR9O1xuXG5cdFx0LyoqIEBwcml2YXRlICoqL1xuXHRcdHAuX2xpbmtDU1NQID0gZnVuY3Rpb24ocHQsIG5leHQsIHByZXYsIHJlbW92ZSkge1xuXHRcdFx0aWYgKHB0KSB7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0bmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQuX3ByZXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9maXJzdFBUID09PSBwdCkge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRyZW1vdmUgPSB0cnVlOyAvL2p1c3QgdG8gcHJldmVudCByZXNldHRpbmcgdGhpcy5fZmlyc3RQVCA1IGxpbmVzIGRvd24gaW4gY2FzZSBwdC5fbmV4dCBpcyBudWxsLiAob3B0aW1pemVkIGZvciBzcGVlZClcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJldikge1xuXHRcdFx0XHRcdHByZXYuX25leHQgPSBwdDtcblx0XHRcdFx0fSBlbHNlIGlmICghcmVtb3ZlICYmIHRoaXMuX2ZpcnN0UFQgPT09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQuX25leHQgPSBuZXh0O1xuXHRcdFx0XHRwdC5fcHJldiA9IHByZXY7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fTtcblxuXHRcdC8vd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBpZiBhbHBoYSBvciBhdXRvQWxwaGEgaXMga2lsbGVkLCBvcGFjaXR5IGlzIHRvby4gQW5kIGF1dG9BbHBoYSBhZmZlY3RzIHRoZSBcInZpc2liaWxpdHlcIiBwcm9wZXJ0eS5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgY29weSA9IGxvb2t1cCxcblx0XHRcdFx0cHQsIHAsIHhmaXJzdDtcblx0XHRcdGlmIChsb29rdXAuYXV0b0FscGhhIHx8IGxvb2t1cC5hbHBoYSkge1xuXHRcdFx0XHRjb3B5ID0ge307XG5cdFx0XHRcdGZvciAocCBpbiBsb29rdXApIHsgLy9jb3B5IHRoZSBsb29rdXAgc28gdGhhdCB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIG9yaWdpbmFsIHdoaWNoIG1heSBiZSBwYXNzZWQgZWxzZXdoZXJlLlxuXHRcdFx0XHRcdGNvcHlbcF0gPSBsb29rdXBbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29weS5vcGFjaXR5ID0gMTtcblx0XHRcdFx0aWYgKGNvcHkuYXV0b0FscGhhKSB7XG5cdFx0XHRcdFx0Y29weS52aXNpYmlsaXR5ID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGxvb2t1cC5jbGFzc05hbWUgJiYgKHB0ID0gdGhpcy5fY2xhc3NOYW1lUFQpKSB7IC8vZm9yIGNsYXNzTmFtZSB0d2VlbnMsIHdlIG5lZWQgdG8ga2lsbCBhbnkgYXNzb2NpYXRlZCBDU1NQcm9wVHdlZW5zIHRvbzsgYSBsaW5rZWQgbGlzdCBzdGFydHMgYXQgdGhlIGNsYXNzTmFtZSdzIFwieGZpcnN0XCIuXG5cdFx0XHRcdHhmaXJzdCA9IHB0LnhmaXJzdDtcblx0XHRcdFx0aWYgKHhmaXJzdCAmJiB4Zmlyc3QuX3ByZXYpIHtcblx0XHRcdFx0XHR0aGlzLl9saW5rQ1NTUCh4Zmlyc3QuX3ByZXYsIHB0Ll9uZXh0LCB4Zmlyc3QuX3ByZXYuX3ByZXYpOyAvL2JyZWFrIG9mZiB0aGUgcHJldlxuXHRcdFx0XHR9IGVsc2UgaWYgKHhmaXJzdCA9PT0gdGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHR0aGlzLl9saW5rQ1NTUChwdC5fbmV4dCwgcHQuX25leHQuX25leHQsIHhmaXJzdC5fcHJldik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2xhc3NOYW1lUFQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFR3ZWVuUGx1Z2luLnByb3RvdHlwZS5fa2lsbC5jYWxsKHRoaXMsIGNvcHkpO1xuXHRcdH07XG5cblxuXG5cdFx0Ly91c2VkIGJ5IGNhc2NhZGVUbygpIGZvciBnYXRoZXJpbmcgYWxsIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIG9mIGVhY2ggY2hpbGQgZWxlbWVudCBpbnRvIGFuIGFycmF5IGZvciBjb21wYXJpc29uLlxuXHRcdHZhciBfZ2V0Q2hpbGRTdHlsZXMgPSBmdW5jdGlvbihlLCBwcm9wcywgdGFyZ2V0cykge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4sIGksIGNoaWxkLCB0eXBlO1xuXHRcdFx0XHRpZiAoZS5zbGljZSkge1xuXHRcdFx0XHRcdGkgPSBlLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdF9nZXRDaGlsZFN0eWxlcyhlW2ldLCBwcm9wcywgdGFyZ2V0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZHJlbiA9IGUuY2hpbGROb2Rlcztcblx0XHRcdFx0aSA9IGNoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0Y2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdFx0XHR0eXBlID0gY2hpbGQudHlwZTtcblx0XHRcdFx0XHRpZiAoY2hpbGQuc3R5bGUpIHtcblx0XHRcdFx0XHRcdHByb3BzLnB1c2goX2dldEFsbFN0eWxlcyhjaGlsZCkpO1xuXHRcdFx0XHRcdFx0aWYgKHRhcmdldHMpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCh0eXBlID09PSAxIHx8IHR5cGUgPT09IDkgfHwgdHlwZSA9PT0gMTEpICYmIGNoaWxkLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRfZ2V0Q2hpbGRTdHlsZXMoY2hpbGQsIHByb3BzLCB0YXJnZXRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBUeXBpY2FsbHkgb25seSB1c2VmdWwgZm9yIGNsYXNzTmFtZSB0d2VlbnMgdGhhdCBtYXkgYWZmZWN0IGNoaWxkIGVsZW1lbnRzLCB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgVHdlZW5MaXRlXG5cdFx0ICogYW5kIHRoZW4gY29tcGFyZXMgdGhlIHN0eWxlIHByb3BlcnRpZXMgb2YgYWxsIHRoZSB0YXJnZXQncyBjaGlsZCBlbGVtZW50cyBhdCB0aGUgdHdlZW4ncyBzdGFydCBhbmQgZW5kLCBhbmRcblx0XHQgKiBpZiBhbnkgYXJlIGRpZmZlcmVudCwgaXQgYWxzbyBjcmVhdGVzIHR3ZWVucyBmb3IgdGhvc2UgYW5kIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBBTEwgb2YgdGhlIHJlc3VsdGluZ1xuXHRcdCAqIHR3ZWVucyAoc28gdGhhdCB5b3UgY2FuIGVhc2lseSBhZGQoKSB0aGVtIHRvIGEgVGltZWxpbmVMaXRlLCBmb3IgZXhhbXBsZSkuIFRoZSByZWFzb24gdGhpcyBmdW5jdGlvbmFsaXR5IGlzXG5cdFx0ICogd3JhcHBlZCBpbnRvIGEgc2VwYXJhdGUgc3RhdGljIG1ldGhvZCBvZiBDU1NQbHVnaW4gaW5zdGVhZCBvZiBiZWluZyBpbnRlZ3JhdGVkIGludG8gYWxsIHJlZ3VsYXIgY2xhc3NOYW1lIHR3ZWVuc1xuXHRcdCAqIGlzIGJlY2F1c2UgaXQgY3JlYXRlcyBlbnRpcmVseSBuZXcgdHdlZW5zIHRoYXQgbWF5IGhhdmUgY29tcGxldGVseSBkaWZmZXJlbnQgdGFyZ2V0cyB0aGFuIHRoZSBvcmlnaW5hbCB0d2Vlbixcblx0XHQgKiBzbyBpZiB0aGV5IHdlcmUgYWxsIGx1bXBlZCBpbnRvIHRoZSBvcmlnaW5hbCB0d2VlbiBpbnN0YW5jZSwgaXQgd291bGQgYmUgaW5jb25zaXN0ZW50IHdpdGggdGhlIHJlc3Qgb2YgdGhlIEFQSVxuXHRcdCAqIGFuZCBpdCB3b3VsZCBjcmVhdGUgb3RoZXIgcHJvYmxlbXMuIEZvciBleGFtcGxlOlxuXHRcdCAqICAtIElmIEkgY3JlYXRlIGEgdHdlZW4gb2YgZWxlbWVudEEsIHRoYXQgdHdlZW4gaW5zdGFuY2UgbWF5IHN1ZGRlbmx5IGNoYW5nZSBpdHMgdGFyZ2V0IHRvIGluY2x1ZGUgNTAgb3RoZXIgZWxlbWVudHMgKHVuaW50dWl0aXZlIGlmIEkgc3BlY2lmaWNhbGx5IGRlZmluZWQgdGhlIHRhcmdldCBJIHdhbnRlZClcblx0XHQgKiAgLSBXZSBjYW4ndCBqdXN0IGNyZWF0ZSBuZXcgaW5kZXBlbmRlbnQgdHdlZW5zIGJlY2F1c2Ugb3RoZXJ3aXNlLCB3aGF0IGhhcHBlbnMgaWYgdGhlIG9yaWdpbmFsL3BhcmVudCB0d2VlbiBpcyByZXZlcnNlZCBvciBwYXVzZSBvciBkcm9wcGVkIGludG8gYSBUaW1lbGluZUxpdGUgZm9yIHRpZ2h0IGNvbnRyb2w/IFlvdSdkIGV4cGVjdCB0aGF0IHR3ZWVuJ3MgYmVoYXZpb3IgdG8gYWZmZWN0IGFsbCB0aGUgb3RoZXJzLlxuXHRcdCAqICAtIEFuYWx5emluZyBldmVyeSBzdHlsZSBwcm9wZXJ0eSBvZiBldmVyeSBjaGlsZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSB0d2VlbiBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uIHdoZW4gdGhlcmUgYXJlIG1hbnkgY2hpbGRyZW4sIHNvIHRoaXMgYmVoYXZpb3Igc2hvdWxkbid0IGJlIGltcG9zZWQgb24gYWxsIGNsYXNzTmFtZSB0d2VlbnMgYnkgZGVmYXVsdCwgZXNwZWNpYWxseSBzaW5jZSBpdCdzIHByb2JhYmx5IHJhcmUgdGhhdCB0aGlzIGV4dHJhIGZ1bmN0aW9uYWxpdHkgaXMgbmVlZGVkLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBvYmplY3QgdG8gYmUgdHdlZW5lZFxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBEdXJhdGlvbiBpbiBzZWNvbmRzIChvciBmcmFtZXMgZm9yIGZyYW1lcy1iYXNlZCB0d2VlbnMpXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBlbmQgdmFsdWVzLCBsaWtlIHtjbGFzc05hbWU6XCJuZXdDbGFzc1wiLCBlYXNlOkxpbmVhci5lYXNlTm9uZX1cblx0XHQgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgVHdlZW5MaXRlIGluc3RhbmNlc1xuXHRcdCAqL1xuXHRcdENTU1BsdWdpbi5jYXNjYWRlVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSBUd2VlbkxpdGUudG8odGFyZ2V0LCBkdXJhdGlvbiwgdmFycyksXG5cdFx0XHRcdHJlc3VsdHMgPSBbdHdlZW5dLFxuXHRcdFx0XHRiID0gW10sXG5cdFx0XHRcdGUgPSBbXSxcblx0XHRcdFx0dGFyZ2V0cyA9IFtdLFxuXHRcdFx0XHRfcmVzZXJ2ZWRQcm9wcyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLnJlc2VydmVkUHJvcHMsXG5cdFx0XHRcdGksIGRpZnMsIHAsIGZyb207XG5cdFx0XHR0YXJnZXQgPSB0d2Vlbi5fdGFyZ2V0cyB8fCB0d2Vlbi50YXJnZXQ7XG5cdFx0XHRfZ2V0Q2hpbGRTdHlsZXModGFyZ2V0LCBiLCB0YXJnZXRzKTtcblx0XHRcdHR3ZWVuLnJlbmRlcihkdXJhdGlvbiwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRfZ2V0Q2hpbGRTdHlsZXModGFyZ2V0LCBlKTtcblx0XHRcdHR3ZWVuLnJlbmRlcigwLCB0cnVlLCB0cnVlKTtcblx0XHRcdHR3ZWVuLl9lbmFibGVkKHRydWUpO1xuXHRcdFx0aSA9IHRhcmdldHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGRpZnMgPSBfY3NzRGlmKHRhcmdldHNbaV0sIGJbaV0sIGVbaV0pO1xuXHRcdFx0XHRpZiAoZGlmcy5maXJzdE1QVCkge1xuXHRcdFx0XHRcdGRpZnMgPSBkaWZzLmRpZnM7XG5cdFx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRcdGlmIChfcmVzZXJ2ZWRQcm9wc1twXSkge1xuXHRcdFx0XHRcdFx0XHRkaWZzW3BdID0gdmFyc1twXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZnJvbSA9IHt9O1xuXHRcdFx0XHRcdGZvciAocCBpbiBkaWZzKSB7XG5cdFx0XHRcdFx0XHRmcm9tW3BdID0gYltpXVtwXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0cy5wdXNoKFR3ZWVuTGl0ZS5mcm9tVG8odGFyZ2V0c1tpXSwgZHVyYXRpb24sIGZyb20sIGRpZnMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHRcdFR3ZWVuUGx1Z2luLmFjdGl2YXRlKFtDU1NQbHVnaW5dKTtcblx0XHRyZXR1cm4gQ1NTUGx1Z2luO1xuXG5cdH0sIHRydWUpO1xuXG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFJvdW5kUHJvcHNQbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHQoZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgUm91bmRQcm9wc1BsdWdpbiA9IF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdFx0XHRwcm9wTmFtZTogXCJyb3VuZFByb3BzXCIsXG5cdFx0XHRcdHZlcnNpb246IFwiMS41XCIsXG5cdFx0XHRcdHByaW9yaXR5OiAtMSxcblx0XHRcdFx0QVBJOiAyLFxuXG5cdFx0XHRcdC8vY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0XHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG5cdFx0XHRcdFx0dGhpcy5fdHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9KSxcblx0XHRcdF9yb3VuZExpbmtlZExpc3QgPSBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdHdoaWxlIChub2RlKSB7XG5cdFx0XHRcdFx0aWYgKCFub2RlLmYgJiYgIW5vZGUuYmxvYikge1xuXHRcdFx0XHRcdFx0bm9kZS5yID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bm9kZSA9IG5vZGUuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRwID0gUm91bmRQcm9wc1BsdWdpbi5wcm90b3R5cGU7XG5cblx0XHRwLl9vbkluaXRBbGxQcm9wcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fdHdlZW4sXG5cdFx0XHRcdHJwID0gKHR3ZWVuLnZhcnMucm91bmRQcm9wcy5qb2luKSA/IHR3ZWVuLnZhcnMucm91bmRQcm9wcyA6IHR3ZWVuLnZhcnMucm91bmRQcm9wcy5zcGxpdChcIixcIiksXG5cdFx0XHRcdGkgPSBycC5sZW5ndGgsXG5cdFx0XHRcdGxvb2t1cCA9IHt9LFxuXHRcdFx0XHRycHQgPSB0d2Vlbi5fcHJvcExvb2t1cC5yb3VuZFByb3BzLFxuXHRcdFx0XHRwcm9wLCBwdCwgbmV4dDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRsb29rdXBbcnBbaV1dID0gMTtcblx0XHRcdH1cblx0XHRcdGkgPSBycC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0cHJvcCA9IHJwW2ldO1xuXHRcdFx0XHRwdCA9IHR3ZWVuLl9maXJzdFBUO1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRuZXh0ID0gcHQuX25leHQ7IC8vcmVjb3JkIGhlcmUsIGJlY2F1c2UgaXQgbWF5IGdldCByZW1vdmVkXG5cdFx0XHRcdFx0aWYgKHB0LnBnKSB7XG5cdFx0XHRcdFx0XHRwdC50Ll9yb3VuZFByb3BzKGxvb2t1cCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC5uID09PSBwcm9wKSB7XG5cdFx0XHRcdFx0XHRpZiAocHQuZiA9PT0gMiAmJiBwdC50KSB7IC8vYSBibG9iICh0ZXh0IGNvbnRhaW5pbmcgbXVsdGlwbGUgbnVtZXJpYyB2YWx1ZXMpXG5cdFx0XHRcdFx0XHRcdF9yb3VuZExpbmtlZExpc3QocHQudC5fZmlyc3RQVCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9hZGQocHQudCwgcHJvcCwgcHQucywgcHQuYyk7XG5cdFx0XHRcdFx0XHRcdC8vcmVtb3ZlIGZyb20gbGlua2VkIGxpc3Rcblx0XHRcdFx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gcHQuX3ByZXY7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBuZXh0O1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9maXJzdFBUID09PSBwdCkge1xuXHRcdFx0XHRcdFx0XHRcdHR3ZWVuLl9maXJzdFBUID0gbmV4dDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwdC5fbmV4dCA9IHB0Ll9wcmV2ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0dHdlZW4uX3Byb3BMb29rdXBbcHJvcF0gPSBycHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLl9hZGQgPSBmdW5jdGlvbih0YXJnZXQsIHAsIHMsIGMpIHtcblx0XHRcdHRoaXMuX2FkZFR3ZWVuKHRhcmdldCwgcCwgcywgcyArIGMsIHAsIHRydWUpO1xuXHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHR9O1xuXG5cdH0oKSk7XG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBdHRyUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXHQoZnVuY3Rpb24oKSB7XG5cblx0XHRfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRcdHByb3BOYW1lOiBcImF0dHJcIixcblx0XHRcdEFQSTogMixcblx0XHRcdHZlcnNpb246IFwiMC41LjBcIixcblxuXHRcdFx0Ly9jYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgaXMgd2hlcmUgaW5pdGlhbCB2YWx1ZXMgc2hvdWxkIGJlIHJlY29yZGVkIGFuZCBhbnkgc2V0dXAgcm91dGluZXMgc2hvdWxkIHJ1bi5cblx0XHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG5cdFx0XHRcdHZhciBwO1xuXHRcdFx0XHRpZiAodHlwZW9mKHRhcmdldC5zZXRBdHRyaWJ1dGUpICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwIGluIHZhbHVlKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWRkVHdlZW4odGFyZ2V0LCBcInNldEF0dHJpYnV0ZVwiLCB0YXJnZXQuZ2V0QXR0cmlidXRlKHApICsgXCJcIiwgdmFsdWVbcF0gKyBcIlwiLCBwLCBmYWxzZSwgcCk7XG5cdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdH0pO1xuXG5cdH0oKSk7XG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0cHJvcE5hbWU6IFwiZGlyZWN0aW9uYWxSb3RhdGlvblwiLFxuXHRcdHZlcnNpb246IFwiMC4yLjFcIixcblx0XHRBUEk6IDIsXG5cblx0XHQvL2NhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG5cdFx0XHRpZiAodHlwZW9mKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHR2YWx1ZSA9IHtyb3RhdGlvbjp2YWx1ZX07XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZpbmFscyA9IHt9O1xuXHRcdFx0dmFyIGNhcCA9ICh2YWx1ZS51c2VSYWRpYW5zID09PSB0cnVlKSA/IE1hdGguUEkgKiAyIDogMzYwLFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0cCwgdiwgc3RhcnQsIGVuZCwgZGlmLCBzcGxpdDtcblx0XHRcdGZvciAocCBpbiB2YWx1ZSkge1xuXHRcdFx0XHRpZiAocCAhPT0gXCJ1c2VSYWRpYW5zXCIpIHtcblx0XHRcdFx0XHRzcGxpdCA9ICh2YWx1ZVtwXSArIFwiXCIpLnNwbGl0KFwiX1wiKTtcblx0XHRcdFx0XHR2ID0gc3BsaXRbMF07XG5cdFx0XHRcdFx0c3RhcnQgPSBwYXJzZUZsb2F0KCAodHlwZW9mKHRhcmdldFtwXSkgIT09IFwiZnVuY3Rpb25cIikgPyB0YXJnZXRbcF0gOiB0YXJnZXRbICgocC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHAuc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdKCkgKTtcblx0XHRcdFx0XHRlbmQgPSB0aGlzLmZpbmFsc1twXSA9ICh0eXBlb2YodikgPT09IFwic3RyaW5nXCIgJiYgdi5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHN0YXJ0ICsgcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogTnVtYmVyKHYuc3Vic3RyKDIpKSA6IE51bWJlcih2KSB8fCAwO1xuXHRcdFx0XHRcdGRpZiA9IGVuZCAtIHN0YXJ0O1xuXHRcdFx0XHRcdGlmIChzcGxpdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHYgPSBzcGxpdC5qb2luKFwiX1wiKTtcblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJzaG9ydFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gZGlmICUgY2FwO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGlmICE9PSBkaWYgJSAoY2FwIC8gMikpIHtcblx0XHRcdFx0XHRcdFx0XHRkaWYgPSAoZGlmIDwgMCkgPyBkaWYgKyBjYXAgOiBkaWYgLSBjYXA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJfY3dcIikgIT09IC0xICYmIGRpZiA8IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgKyBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodi5pbmRleE9mKFwiY2N3XCIpICE9PSAtMSAmJiBkaWYgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmIC0gY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChkaWYgPiBtaW4gfHwgZGlmIDwgLW1pbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkVHdlZW4odGFyZ2V0LCBwLCBzdGFydCwgc3RhcnQgKyBkaWYsIHApO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvL2NhbGxlZCBlYWNoIHRpbWUgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCwgYW5kIHRoZSByYXRpbyBnZXRzIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXIgKHR5cGljYWxseSBpdCdzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgaXQgY2FuIGV4Y2VlZCB0aG9zZSB3aGVuIHVzaW5nIGFuIGVhc2UgbGlrZSBFbGFzdGljLmVhc2VPdXQgb3IgQmFjay5lYXNlT3V0LCBldGMuKVxuXHRcdHNldDogZnVuY3Rpb24ocmF0aW8pIHtcblx0XHRcdHZhciBwdDtcblx0XHRcdGlmIChyYXRpbyAhPT0gMSkge1xuXHRcdFx0XHR0aGlzLl9zdXBlci5zZXRSYXRpby5jYWxsKHRoaXMsIHJhdGlvKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0odGhpcy5maW5hbHNbcHQucF0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gdGhpcy5maW5hbHNbcHQucF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fSkuX2F1dG9DU1MgPSB0cnVlO1xuXG5cblxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEVhc2VQYWNrXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwiZWFzaW5nLkJhY2tcIiwgW1wiZWFzaW5nLkVhc2VcIl0sIGZ1bmN0aW9uKEVhc2UpIHtcblx0XHRcblx0XHR2YXIgdyA9IChfZ3NTY29wZS5HcmVlblNvY2tHbG9iYWxzIHx8IF9nc1Njb3BlKSxcblx0XHRcdGdzID0gdy5jb20uZ3JlZW5zb2NrLFxuXHRcdFx0XzJQSSA9IE1hdGguUEkgKiAyLFxuXHRcdFx0X0hBTEZfUEkgPSBNYXRoLlBJIC8gMixcblx0XHRcdF9jbGFzcyA9IGdzLl9jbGFzcyxcblx0XHRcdF9jcmVhdGUgPSBmdW5jdGlvbihuLCBmKSB7XG5cdFx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiICsgbiwgZnVuY3Rpb24oKXt9LCB0cnVlKSxcblx0XHRcdFx0XHRwID0gQy5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdFx0XHRwLmNvbnN0cnVjdG9yID0gQztcblx0XHRcdFx0cC5nZXRSYXRpbyA9IGY7XG5cdFx0XHRcdHJldHVybiBDO1xuXHRcdFx0fSxcblx0XHRcdF9lYXNlUmVnID0gRWFzZS5yZWdpc3RlciB8fCBmdW5jdGlvbigpe30sIC8vcHV0IGFuIGVtcHR5IGZ1bmN0aW9uIGluIHBsYWNlIGp1c3QgYXMgYSBzYWZldHkgbWVhc3VyZSBpbiBjYXNlIHNvbWVvbmUgbG9hZHMgYW4gT0xEIHZlcnNpb24gb2YgVHdlZW5MaXRlLmpzIHdoZXJlIEVhc2UucmVnaXN0ZXIgZG9lc24ndCBleGlzdC5cblx0XHRcdF93cmFwID0gZnVuY3Rpb24obmFtZSwgRWFzZU91dCwgRWFzZUluLCBFYXNlSW5PdXQsIGFsaWFzZXMpIHtcblx0XHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIrbmFtZSwge1xuXHRcdFx0XHRcdGVhc2VPdXQ6bmV3IEVhc2VPdXQoKSxcblx0XHRcdFx0XHRlYXNlSW46bmV3IEVhc2VJbigpLFxuXHRcdFx0XHRcdGVhc2VJbk91dDpuZXcgRWFzZUluT3V0KClcblx0XHRcdFx0fSwgdHJ1ZSk7XG5cdFx0XHRcdF9lYXNlUmVnKEMsIG5hbWUpO1xuXHRcdFx0XHRyZXR1cm4gQztcblx0XHRcdH0sXG5cdFx0XHRFYXNlUG9pbnQgPSBmdW5jdGlvbih0aW1lLCB2YWx1ZSwgbmV4dCkge1xuXHRcdFx0XHR0aGlzLnQgPSB0aW1lO1xuXHRcdFx0XHR0aGlzLnYgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHR0aGlzLm5leHQgPSBuZXh0O1xuXHRcdFx0XHRcdG5leHQucHJldiA9IHRoaXM7XG5cdFx0XHRcdFx0dGhpcy5jID0gbmV4dC52IC0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5nYXAgPSBuZXh0LnQgLSB0aW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvL0JhY2tcblx0XHRcdF9jcmVhdGVCYWNrID0gZnVuY3Rpb24obiwgZikge1xuXHRcdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIiArIG4sIGZ1bmN0aW9uKG92ZXJzaG9vdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fcDEgPSAob3ZlcnNob290IHx8IG92ZXJzaG9vdCA9PT0gMCkgPyBvdmVyc2hvb3QgOiAxLjcwMTU4O1xuXHRcdFx0XHRcdFx0dGhpcy5fcDIgPSB0aGlzLl9wMSAqIDEuNTI1O1xuXHRcdFx0XHRcdH0sIHRydWUpLFxuXHRcdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdFx0cC5jb25maWcgPSBmdW5jdGlvbihvdmVyc2hvb3QpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEMob3ZlcnNob290KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXG5cdFx0XHRCYWNrID0gX3dyYXAoXCJCYWNrXCIsXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgocCA9IHAgLSAxKSAqIHAgKiAoKHRoaXMuX3AxICsgMSkgKiBwICsgdGhpcy5fcDEpICsgMSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRfY3JlYXRlQmFjayhcIkJhY2tJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHAgKiBwICogKCh0aGlzLl9wMSArIDEpICogcCAtIHRoaXMuX3AxKTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAwLjUgKiBwICogcCAqICgodGhpcy5fcDIgKyAxKSAqIHAgLSB0aGlzLl9wMikgOiAwLjUgKiAoKHAgLT0gMikgKiBwICogKCh0aGlzLl9wMiArIDEpICogcCArIHRoaXMuX3AyKSArIDIpO1xuXHRcdFx0XHR9KVxuXHRcdFx0KSxcblxuXG5cdFx0XHQvL1Nsb3dNb1xuXHRcdFx0U2xvd01vID0gX2NsYXNzKFwiZWFzaW5nLlNsb3dNb1wiLCBmdW5jdGlvbihsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKSB7XG5cdFx0XHRcdHBvd2VyID0gKHBvd2VyIHx8IHBvd2VyID09PSAwKSA/IHBvd2VyIDogMC43O1xuXHRcdFx0XHRpZiAobGluZWFyUmF0aW8gPT0gbnVsbCkge1xuXHRcdFx0XHRcdGxpbmVhclJhdGlvID0gMC43O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmVhclJhdGlvID4gMSkge1xuXHRcdFx0XHRcdGxpbmVhclJhdGlvID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9wID0gKGxpbmVhclJhdGlvICE9PSAxKSA/IHBvd2VyIDogMDtcblx0XHRcdFx0dGhpcy5fcDEgPSAoMSAtIGxpbmVhclJhdGlvKSAvIDI7XG5cdFx0XHRcdHRoaXMuX3AyID0gbGluZWFyUmF0aW87XG5cdFx0XHRcdHRoaXMuX3AzID0gdGhpcy5fcDEgKyB0aGlzLl9wMjtcblx0XHRcdFx0dGhpcy5fY2FsY0VuZCA9ICh5b3lvTW9kZSA9PT0gdHJ1ZSk7XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdHAgPSBTbG93TW8ucHJvdG90eXBlID0gbmV3IEVhc2UoKSxcblx0XHRcdFN0ZXBwZWRFYXNlLCBSb3VnaEVhc2UsIF9jcmVhdGVFbGFzdGljO1xuXG5cdFx0cC5jb25zdHJ1Y3RvciA9IFNsb3dNbztcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0dmFyIHIgPSBwICsgKDAuNSAtIHApICogdGhpcy5fcDtcblx0XHRcdGlmIChwIDwgdGhpcy5fcDEpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbGNFbmQgPyAxIC0gKChwID0gMSAtIChwIC8gdGhpcy5fcDEpKSAqIHApIDogciAtICgocCA9IDEgLSAocCAvIHRoaXMuX3AxKSkgKiBwICogcCAqIHAgKiByKTtcblx0XHRcdH0gZWxzZSBpZiAocCA+IHRoaXMuX3AzKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gMSAtIChwID0gKHAgLSB0aGlzLl9wMykgLyB0aGlzLl9wMSkgKiBwIDogciArICgocCAtIHIpICogKHAgPSAocCAtIHRoaXMuX3AzKSAvIHRoaXMuX3AxKSAqIHAgKiBwICogcCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsY0VuZCA/IDEgOiByO1xuXHRcdH07XG5cdFx0U2xvd01vLmVhc2UgPSBuZXcgU2xvd01vKDAuNywgMC43KTtcblxuXHRcdHAuY29uZmlnID0gU2xvd01vLmNvbmZpZyA9IGZ1bmN0aW9uKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2xvd01vKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpO1xuXHRcdH07XG5cblxuXHRcdC8vU3RlcHBlZEVhc2Vcblx0XHRTdGVwcGVkRWFzZSA9IF9jbGFzcyhcImVhc2luZy5TdGVwcGVkRWFzZVwiLCBmdW5jdGlvbihzdGVwcykge1xuXHRcdFx0XHRzdGVwcyA9IHN0ZXBzIHx8IDE7XG5cdFx0XHRcdHRoaXMuX3AxID0gMSAvIHN0ZXBzO1xuXHRcdFx0XHR0aGlzLl9wMiA9IHN0ZXBzICsgMTtcblx0XHRcdH0sIHRydWUpO1xuXHRcdHAgPSBTdGVwcGVkRWFzZS5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBTdGVwcGVkRWFzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYgKHAgPCAwKSB7XG5cdFx0XHRcdHAgPSAwO1xuXHRcdFx0fSBlbHNlIGlmIChwID49IDEpIHtcblx0XHRcdFx0cCA9IDAuOTk5OTk5OTk5O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICgodGhpcy5fcDIgKiBwKSA+PiAwKSAqIHRoaXMuX3AxO1xuXHRcdH07XG5cdFx0cC5jb25maWcgPSBTdGVwcGVkRWFzZS5jb25maWcgPSBmdW5jdGlvbihzdGVwcykge1xuXHRcdFx0cmV0dXJuIG5ldyBTdGVwcGVkRWFzZShzdGVwcyk7XG5cdFx0fTtcblxuXG5cdFx0Ly9Sb3VnaEVhc2Vcblx0XHRSb3VnaEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuUm91Z2hFYXNlXCIsIGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0dmFyIHRhcGVyID0gdmFycy50YXBlciB8fCBcIm5vbmVcIixcblx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRwb2ludHMgPSAodmFycy5wb2ludHMgfHwgMjApIHwgMCxcblx0XHRcdFx0aSA9IHBvaW50cyxcblx0XHRcdFx0cmFuZG9taXplID0gKHZhcnMucmFuZG9taXplICE9PSBmYWxzZSksXG5cdFx0XHRcdGNsYW1wID0gKHZhcnMuY2xhbXAgPT09IHRydWUpLFxuXHRcdFx0XHR0ZW1wbGF0ZSA9ICh2YXJzLnRlbXBsYXRlIGluc3RhbmNlb2YgRWFzZSkgPyB2YXJzLnRlbXBsYXRlIDogbnVsbCxcblx0XHRcdFx0c3RyZW5ndGggPSAodHlwZW9mKHZhcnMuc3RyZW5ndGgpID09PSBcIm51bWJlclwiKSA/IHZhcnMuc3RyZW5ndGggKiAwLjQgOiAwLjQsXG5cdFx0XHRcdHgsIHksIGJ1bXAsIGludlgsIG9iaiwgcG50O1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHggPSByYW5kb21pemUgPyBNYXRoLnJhbmRvbSgpIDogKDEgLyBwb2ludHMpICogaTtcblx0XHRcdFx0eSA9IHRlbXBsYXRlID8gdGVtcGxhdGUuZ2V0UmF0aW8oeCkgOiB4O1xuXHRcdFx0XHRpZiAodGFwZXIgPT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0YnVtcCA9IHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcIm91dFwiKSB7XG5cdFx0XHRcdFx0aW52WCA9IDEgLSB4O1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcImluXCIpIHtcblx0XHRcdFx0XHRidW1wID0geCAqIHggKiBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmICh4IDwgMC41KSB7ICAvL1wiYm90aFwiIChzdGFydClcblx0XHRcdFx0XHRpbnZYID0geCAqIDI7XG5cdFx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogMC41ICogc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHQvL1wiYm90aFwiIChlbmQpXG5cdFx0XHRcdFx0aW52WCA9ICgxIC0geCkgKiAyO1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyYW5kb21pemUpIHtcblx0XHRcdFx0XHR5ICs9IChNYXRoLnJhbmRvbSgpICogYnVtcCkgLSAoYnVtcCAqIDAuNSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaSAlIDIpIHtcblx0XHRcdFx0XHR5ICs9IGJ1bXAgKiAwLjU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eSAtPSBidW1wICogMC41O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjbGFtcCkge1xuXHRcdFx0XHRcdGlmICh5ID4gMSkge1xuXHRcdFx0XHRcdFx0eSA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh5IDwgMCkge1xuXHRcdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGFbY250KytdID0ge3g6eCwgeTp5fTtcblx0XHRcdH1cblx0XHRcdGEuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhLnggLSBiLng7XG5cdFx0XHR9KTtcblxuXHRcdFx0cG50ID0gbmV3IEVhc2VQb2ludCgxLCAxLCBudWxsKTtcblx0XHRcdGkgPSBwb2ludHM7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0b2JqID0gYVtpXTtcblx0XHRcdFx0cG50ID0gbmV3IEVhc2VQb2ludChvYmoueCwgb2JqLnksIHBudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3ByZXYgPSBuZXcgRWFzZVBvaW50KDAsIDAsIChwbnQudCAhPT0gMCkgPyBwbnQgOiBwbnQubmV4dCk7XG5cdFx0fSwgdHJ1ZSk7XG5cdFx0cCA9IFJvdWdoRWFzZS5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBSb3VnaEVhc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdHZhciBwbnQgPSB0aGlzLl9wcmV2O1xuXHRcdFx0aWYgKHAgPiBwbnQudCkge1xuXHRcdFx0XHR3aGlsZSAocG50Lm5leHQgJiYgcCA+PSBwbnQudCkge1xuXHRcdFx0XHRcdHBudCA9IHBudC5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBudCA9IHBudC5wcmV2O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKHBudC5wcmV2ICYmIHAgPD0gcG50LnQpIHtcblx0XHRcdFx0XHRwbnQgPSBwbnQucHJldjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcHJldiA9IHBudDtcblx0XHRcdHJldHVybiAocG50LnYgKyAoKHAgLSBwbnQudCkgLyBwbnQuZ2FwKSAqIHBudC5jKTtcblx0XHR9O1xuXHRcdHAuY29uZmlnID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBSb3VnaEVhc2UodmFycyk7XG5cdFx0fTtcblx0XHRSb3VnaEVhc2UuZWFzZSA9IG5ldyBSb3VnaEVhc2UoKTtcblxuXG5cdFx0Ly9Cb3VuY2Vcblx0XHRfd3JhcChcIkJvdW5jZVwiLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZU91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmIChwIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogcCAqIHA7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChwIC09IDEuNSAvIDIuNzUpICogcCArIDAuNzU7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMi4yNSAvIDIuNzUpICogcCArIDAuOTM3NTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMi42MjUgLyAyLjc1KSAqIHAgKyAwLjk4NDM3NTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZUluXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKChwID0gMSAtIHApIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiBwICogcCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1KTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZUluT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0dmFyIGludmVydCA9IChwIDwgMC41KTtcblx0XHRcdFx0aWYgKGludmVydCkge1xuXHRcdFx0XHRcdHAgPSAxIC0gKHAgKiAyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwID0gKHAgKiAyKSAtIDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHAgPCAxIC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiBwICogcDtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMiAvIDIuNzUpIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMi41IC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBpbnZlcnQgPyAoMSAtIHApICogMC41IDogcCAqIDAuNSArIDAuNTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXG5cdFx0Ly9DSVJDXG5cdFx0X3dyYXAoXCJDaXJjXCIsXG5cdFx0XHRfY3JlYXRlKFwiQ2lyY091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoMSAtIChwID0gcCAtIDEpICogcCk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJDaXJjSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIChwICogcCkpIC0gMSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJDaXJjSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwKj0yKSA8IDEpID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHAgKiBwKSAtIDEpIDogMC41ICogKE1hdGguc3FydCgxIC0gKHAgLT0gMikgKiBwKSArIDEpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cblx0XHQvL0VsYXN0aWNcblx0XHRfY3JlYXRlRWxhc3RpYyA9IGZ1bmN0aW9uKG4sIGYsIGRlZikge1xuXHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbihhbXBsaXR1ZGUsIHBlcmlvZCkge1xuXHRcdFx0XHRcdHRoaXMuX3AxID0gKGFtcGxpdHVkZSA+PSAxKSA/IGFtcGxpdHVkZSA6IDE7IC8vbm90ZTogaWYgYW1wbGl0dWRlIGlzIDwgMSwgd2Ugc2ltcGx5IGFkanVzdCB0aGUgcGVyaW9kIGZvciBhIG1vcmUgbmF0dXJhbCBmZWVsLiBPdGhlcndpc2UgdGhlIG1hdGggZG9lc24ndCB3b3JrIHJpZ2h0IGFuZCB0aGUgY3VydmUgc3RhcnRzIGF0IDEuXG5cdFx0XHRcdFx0dGhpcy5fcDIgPSAocGVyaW9kIHx8IGRlZikgLyAoYW1wbGl0dWRlIDwgMSA/IGFtcGxpdHVkZSA6IDEpO1xuXHRcdFx0XHRcdHRoaXMuX3AzID0gdGhpcy5fcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gdGhpcy5fcDEpIHx8IDApO1xuXHRcdFx0XHRcdHRoaXMuX3AyID0gXzJQSSAvIHRoaXMuX3AyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXHRcdFx0XHR9LCB0cnVlKSxcblx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0cC5nZXRSYXRpbyA9IGY7XG5cdFx0XHRwLmNvbmZpZyA9IGZ1bmN0aW9uKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQyhhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIEM7XG5cdFx0fTtcblx0XHRfd3JhcChcIkVsYXN0aWNcIixcblx0XHRcdF9jcmVhdGVFbGFzdGljKFwiRWxhc3RpY091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wMSAqIE1hdGgucG93KDIsIC0xMCAqIHApICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSArIDE7XG5cdFx0XHR9LCAwLjMpLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLSh0aGlzLl9wMSAqIE1hdGgucG93KDIsIDEwICogKHAgLT0gMSkpICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSk7XG5cdFx0XHR9LCAwLjMpLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAtMC41ICogKHRoaXMuX3AxICogTWF0aC5wb3coMiwgMTAgKiAocCAtPSAxKSkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMikpIDogdGhpcy5fcDEgKiBNYXRoLnBvdygyLCAtMTAgKihwIC09IDEpKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyICkgKiAwLjUgKyAxO1xuXHRcdFx0fSwgMC40NSlcblx0XHQpO1xuXG5cblx0XHQvL0V4cG9cblx0XHRfd3JhcChcIkV4cG9cIixcblx0XHRcdF9jcmVhdGUoXCJFeHBvT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygyLCAtMTAgKiBwKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkV4cG9JblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnBvdygyLCAxMCAqIChwIC0gMSkpIC0gMC4wMDE7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJFeHBvSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqIChwIC0gMSkpIDogMC41ICogKDIgLSBNYXRoLnBvdygyLCAtMTAgKiAocCAtIDEpKSk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblxuXHRcdC8vU2luZVxuXHRcdF93cmFwKFwiU2luZVwiLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zaW4ocCAqIF9IQUxGX1BJKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtTWF0aC5jb3MocCAqIF9IQUxGX1BJKSArIDE7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJTaW5lSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogcCkgLSAxKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXHRcdF9jbGFzcyhcImVhc2luZy5FYXNlTG9va3VwXCIsIHtcblx0XHRcdFx0ZmluZDpmdW5jdGlvbihzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEVhc2UubWFwW3NdO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0cnVlKTtcblxuXHRcdC8vcmVnaXN0ZXIgdGhlIG5vbi1zdGFuZGFyZCBlYXNlc1xuXHRcdF9lYXNlUmVnKHcuU2xvd01vLCBcIlNsb3dNb1wiLCBcImVhc2UsXCIpO1xuXHRcdF9lYXNlUmVnKFJvdWdoRWFzZSwgXCJSb3VnaEVhc2VcIiwgXCJlYXNlLFwiKTtcblx0XHRfZWFzZVJlZyhTdGVwcGVkRWFzZSwgXCJTdGVwcGVkRWFzZVwiLCBcImVhc2UsXCIpO1xuXG5cdFx0cmV0dXJuIEJhY2s7XG5cdFx0XG5cdH0sIHRydWUpO1xuXG5cbn0pO1xuXG5pZiAoX2dzU2NvcGUuX2dzRGVmaW5lKSB7IF9nc1Njb3BlLl9nc1F1ZXVlLnBvcCgpKCk7IH0gLy9uZWNlc3NhcnkgaW4gY2FzZSBUd2VlbkxpdGUgd2FzIGFscmVhZHkgbG9hZGVkIHNlcGFyYXRlbHkuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJhc2UgY2xhc3NlcyBsaWtlIFR3ZWVuTGl0ZSwgU2ltcGxlVGltZWxpbmUsIEVhc2UsIFRpY2tlciwgZXRjLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4oZnVuY3Rpb24od2luZG93LCBtb2R1bGVOYW1lKSB7XG5cblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX2dsb2JhbHMgPSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzIHx8IHdpbmRvdztcblx0XHRpZiAoX2dsb2JhbHMuVHdlZW5MaXRlKSB7XG5cdFx0XHRyZXR1cm47IC8vaW4gY2FzZSB0aGUgY29yZSBzZXQgb2YgY2xhc3NlcyBpcyBhbHJlYWR5IGxvYWRlZCwgZG9uJ3QgaW5zdGFudGlhdGUgdHdpY2UuXG5cdFx0fVxuXHRcdHZhciBfbmFtZXNwYWNlID0gZnVuY3Rpb24obnMpIHtcblx0XHRcdFx0dmFyIGEgPSBucy5zcGxpdChcIi5cIiksXG5cdFx0XHRcdFx0cCA9IF9nbG9iYWxzLCBpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHBbYVtpXV0gPSBwID0gcFthW2ldXSB8fCB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcDtcblx0XHRcdH0sXG5cdFx0XHRncyA9IF9uYW1lc3BhY2UoXCJjb20uZ3JlZW5zb2NrXCIpLFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRfc2xpY2UgPSBmdW5jdGlvbihhKSB7IC8vZG9uJ3QgdXNlIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRhcmdldCwgMCkgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0dmFyIGIgPSBbXSxcblx0XHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSAhPT0gbDsgYi5wdXNoKGFbaSsrXSkpIHt9XG5cdFx0XHRcdHJldHVybiBiO1xuXHRcdFx0fSxcblx0XHRcdF9lbXB0eUZ1bmMgPSBmdW5jdGlvbigpIHt9LFxuXHRcdFx0X2lzQXJyYXkgPSAoZnVuY3Rpb24oKSB7IC8vd29ya3MgYXJvdW5kIGlzc3VlcyBpbiBpZnJhbWUgZW52aXJvbm1lbnRzIHdoZXJlIHRoZSBBcnJheSBnbG9iYWwgaXNuJ3Qgc2hhcmVkLCB0aHVzIGlmIHRoZSBvYmplY3Qgb3JpZ2luYXRlcyBpbiBhIGRpZmZlcmVudCB3aW5kb3cvaWZyYW1lLCBcIihvYmogaW5zdGFuY2VvZiBBcnJheSlcIiB3aWxsIGV2YWx1YXRlIGZhbHNlLiBXZSBhZGRlZCBzb21lIHNwZWVkIG9wdGltaXphdGlvbnMgdG8gYXZvaWQgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCkgdW5sZXNzIGl0J3MgYWJzb2x1dGVseSBuZWNlc3NhcnkgYmVjYXVzZSBpdCdzIFZFUlkgc2xvdyAobGlrZSAyMHggc2xvd2VyKVxuXHRcdFx0XHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuXHRcdFx0XHRcdGFycmF5ID0gdG9TdHJpbmcuY2FsbChbXSk7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgKG9iaiBpbnN0YW5jZW9mIEFycmF5IHx8ICh0eXBlb2Yob2JqKSA9PT0gXCJvYmplY3RcIiAmJiAhIW9iai5wdXNoICYmIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gYXJyYXkpKTtcblx0XHRcdFx0fTtcblx0XHRcdH0oKSksXG5cdFx0XHRhLCBpLCBwLCBfdGlja2VyLCBfdGlja2VyQWN0aXZlLFxuXHRcdFx0X2RlZkxvb2t1cCA9IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdFx0ICogRGVmaW5lcyBhIEdyZWVuU29jayBjbGFzcywgb3B0aW9uYWxseSB3aXRoIGFuIGFycmF5IG9mIGRlcGVuZGVuY2llcyB0aGF0IG11c3QgYmUgaW5zdGFudGlhdGVkIGZpcnN0IGFuZCBwYXNzZWQgaW50byB0aGUgZGVmaW5pdGlvbi5cblx0XHRcdCAqIFRoaXMgYWxsb3dzIHVzZXJzIHRvIGxvYWQgR3JlZW5Tb2NrIEpTIGZpbGVzIGluIGFueSBvcmRlciBldmVuIGlmIHRoZXkgaGF2ZSBpbnRlcmRlcGVuZGVuY2llcyAobGlrZSBDU1NQbHVnaW4gZXh0ZW5kcyBUd2VlblBsdWdpbiB3aGljaCBpc1xuXHRcdFx0ICogaW5zaWRlIFR3ZWVuTGl0ZS5qcywgYnV0IGlmIENTU1BsdWdpbiBpcyBsb2FkZWQgZmlyc3QsIGl0IHNob3VsZCB3YWl0IHRvIHJ1biBpdHMgY29kZSB1bnRpbCBUd2VlbkxpdGUuanMgbG9hZHMgYW5kIGluc3RhbnRpYXRlcyBUd2VlblBsdWdpblxuXHRcdFx0ICogYW5kIHRoZW4gcGFzcyBUd2VlblBsdWdpbiB0byBDU1NQbHVnaW4ncyBkZWZpbml0aW9uKS4gVGhpcyBpcyBhbGwgZG9uZSBhdXRvbWF0aWNhbGx5IGFuZCBpbnRlcm5hbGx5LlxuXHRcdFx0ICpcblx0XHRcdCAqIEV2ZXJ5IGRlZmluaXRpb24gd2lsbCBiZSBhZGRlZCB0byBhIFwiY29tLmdyZWVuc29ja1wiIGdsb2JhbCBvYmplY3QgKHR5cGljYWxseSB3aW5kb3csIGJ1dCBpZiBhIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzIG9iamVjdCBpcyBmb3VuZCxcblx0XHRcdCAqIGl0IHdpbGwgZ28gdGhlcmUgYXMgb2YgdjEuNykuIEZvciBleGFtcGxlLCBUd2VlbkxpdGUgd2lsbCBiZSBmb3VuZCBhdCB3aW5kb3cuY29tLmdyZWVuc29jay5Ud2VlbkxpdGUgYW5kIHNpbmNlIGl0J3MgYSBnbG9iYWwgY2xhc3MgdGhhdCBzaG91bGQgYmUgYXZhaWxhYmxlIGFueXdoZXJlLFxuXHRcdFx0ICogaXQgaXMgQUxTTyByZWZlcmVuY2VkIGF0IHdpbmRvdy5Ud2VlbkxpdGUuIEhvd2V2ZXIgc29tZSBjbGFzc2VzIGFyZW4ndCBjb25zaWRlcmVkIGdsb2JhbCwgbGlrZSB0aGUgYmFzZSBjb20uZ3JlZW5zb2NrLmNvcmUuQW5pbWF0aW9uIGNsYXNzLCBzb1xuXHRcdFx0ICogdGhvc2Ugd2lsbCBvbmx5IGJlIGF0IHRoZSBwYWNrYWdlIGxpa2Ugd2luZG93LmNvbS5ncmVlbnNvY2suY29yZS5BbmltYXRpb24uIEFnYWluLCBpZiB5b3UgZGVmaW5lIGEgR3JlZW5Tb2NrR2xvYmFscyBvYmplY3Qgb24gdGhlIHdpbmRvdywgZXZlcnl0aGluZ1xuXHRcdFx0ICogZ2V0cyB0dWNrZWQgbmVhdGx5IGluc2lkZSB0aGVyZSBpbnN0ZWFkIG9mIG9uIHRoZSB3aW5kb3cgZGlyZWN0bHkuIFRoaXMgYWxsb3dzIHlvdSB0byBkbyBhZHZhbmNlZCB0aGluZ3MgbGlrZSBsb2FkIG11bHRpcGxlIHZlcnNpb25zIG9mIEdyZWVuU29ja1xuXHRcdFx0ICogZmlsZXMgYW5kIHB1dCB0aGVtIGludG8gZGlzdGluY3Qgb2JqZWN0cyAoaW1hZ2luZSBhIGJhbm5lciBhZCB1c2VzIGEgbmV3ZXIgdmVyc2lvbiBidXQgdGhlIG1haW4gc2l0ZSB1c2VzIGFuIG9sZGVyIG9uZSkuIEluIHRoYXQgY2FzZSwgeW91IGNvdWxkXG5cdFx0XHQgKiBzYW5kYm94IHRoZSBiYW5uZXIgb25lIGxpa2U6XG5cdFx0XHQgKlxuXHRcdFx0ICogPHNjcmlwdD5cblx0XHRcdCAqICAgICB2YXIgZ3MgPSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHt9OyAvL3RoZSBuZXdlciB2ZXJzaW9uIHdlJ3JlIGFib3V0IHRvIGxvYWQgY291bGQgbm93IGJlIHJlZmVyZW5jZWQgaW4gYSBcImdzXCIgb2JqZWN0LCBsaWtlIGdzLlR3ZWVuTGl0ZS50byguLi4pLiBVc2Ugd2hhdGV2ZXIgYWxpYXMgeW91IHdhbnQgYXMgbG9uZyBhcyBpdCdzIHVuaXF1ZSwgXCJnc1wiIG9yIFwiYmFubmVyXCIgb3Igd2hhdGV2ZXIuXG5cdFx0XHQgKiA8L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQgc3JjPVwianMvZ3JlZW5zb2NrL3YxLjcvVHdlZW5NYXguanNcIj48L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQ+XG5cdFx0XHQgKiAgICAgd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB3aW5kb3cuX2dzUXVldWUgPSB3aW5kb3cuX2dzRGVmaW5lID0gbnVsbDsgLy9yZXNldCBpdCBiYWNrIHRvIG51bGwgKGFsb25nIHdpdGggdGhlIHNwZWNpYWwgX2dzUXVldWUgdmFyaWFibGUpIHNvIHRoYXQgdGhlIG5leHQgbG9hZCBvZiBUd2Vlbk1heCBhZmZlY3RzIHRoZSB3aW5kb3cgYW5kIHdlIGNhbiByZWZlcmVuY2UgdGhpbmdzIGRpcmVjdGx5IGxpa2UgVHdlZW5MaXRlLnRvKC4uLilcblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdCBzcmM9XCJqcy9ncmVlbnNvY2svdjEuNi9Ud2Vlbk1heC5qc1wiPjwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdD5cblx0XHRcdCAqICAgICBncy5Ud2VlbkxpdGUudG8oLi4uKTsgLy93b3VsZCB1c2UgdjEuN1xuXHRcdFx0ICogICAgIFR3ZWVuTGl0ZS50byguLi4pOyAvL3dvdWxkIHVzZSB2MS42XG5cdFx0XHQgKiA8L3NjcmlwdD5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IG5zIFRoZSBuYW1lc3BhY2Ugb2YgdGhlIGNsYXNzIGRlZmluaXRpb24sIGxlYXZpbmcgb2ZmIFwiY29tLmdyZWVuc29jay5cIiBhcyB0aGF0J3MgYXNzdW1lZC4gRm9yIGV4YW1wbGUsIFwiVHdlZW5MaXRlXCIgb3IgXCJwbHVnaW5zLkNTU1BsdWdpblwiIG9yIFwiZWFzaW5nLkJhY2tcIi5cblx0XHRcdCAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBkZXBlbmRlbmNpZXMgQW4gYXJyYXkgb2YgZGVwZW5kZW5jaWVzIChkZXNjcmliZWQgYXMgdGhlaXIgbmFtZXNwYWNlcyBtaW51cyBcImNvbS5ncmVlbnNvY2suXCIgcHJlZml4KS4gRm9yIGV4YW1wbGUgW1wiVHdlZW5MaXRlXCIsXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsXCJjb3JlLkFuaW1hdGlvblwiXVxuXHRcdFx0ICogQHBhcmFtIHshZnVuY3Rpb24oKTpPYmplY3R9IGZ1bmMgVGhlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCBhbmQgcGFzc2VkIHRoZSByZXNvbHZlZCBkZXBlbmRlbmNpZXMgd2hpY2ggd2lsbCByZXR1cm4gdGhlIGFjdHVhbCBjbGFzcyBmb3IgdGhpcyBkZWZpbml0aW9uLlxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gZ2xvYmFsIElmIHRydWUsIHRoZSBjbGFzcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBnbG9iYWwgc2NvcGUgKHR5cGljYWxseSB3aW5kb3cgdW5sZXNzIHlvdSBkZWZpbmUgYSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyBvYmplY3QpXG5cdFx0XHQgKi9cblx0XHRcdERlZmluaXRpb24gPSBmdW5jdGlvbihucywgZGVwZW5kZW5jaWVzLCBmdW5jLCBnbG9iYWwpIHtcblx0XHRcdFx0dGhpcy5zYyA9IChfZGVmTG9va3VwW25zXSkgPyBfZGVmTG9va3VwW25zXS5zYyA6IFtdOyAvL3N1YmNsYXNzZXNcblx0XHRcdFx0X2RlZkxvb2t1cFtuc10gPSB0aGlzO1xuXHRcdFx0XHR0aGlzLmdzQ2xhc3MgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmZ1bmMgPSBmdW5jO1xuXHRcdFx0XHR2YXIgX2NsYXNzZXMgPSBbXTtcblx0XHRcdFx0dGhpcy5jaGVjayA9IGZ1bmN0aW9uKGluaXQpIHtcblx0XHRcdFx0XHR2YXIgaSA9IGRlcGVuZGVuY2llcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRtaXNzaW5nID0gaSxcblx0XHRcdFx0XHRcdGN1ciwgYSwgbiwgY2wsIGhhc01vZHVsZTtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICgoY3VyID0gX2RlZkxvb2t1cFtkZXBlbmRlbmNpZXNbaV1dIHx8IG5ldyBEZWZpbml0aW9uKGRlcGVuZGVuY2llc1tpXSwgW10pKS5nc0NsYXNzKSB7XG5cdFx0XHRcdFx0XHRcdF9jbGFzc2VzW2ldID0gY3VyLmdzQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdG1pc3NpbmctLTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5pdCkge1xuXHRcdFx0XHRcdFx0XHRjdXIuc2MucHVzaCh0aGlzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1pc3NpbmcgPT09IDAgJiYgZnVuYykge1xuXHRcdFx0XHRcdFx0YSA9IChcImNvbS5ncmVlbnNvY2suXCIgKyBucykuc3BsaXQoXCIuXCIpO1xuXHRcdFx0XHRcdFx0biA9IGEucG9wKCk7XG5cdFx0XHRcdFx0XHRjbCA9IF9uYW1lc3BhY2UoYS5qb2luKFwiLlwiKSlbbl0gPSB0aGlzLmdzQ2xhc3MgPSBmdW5jLmFwcGx5KGZ1bmMsIF9jbGFzc2VzKTtcblxuXHRcdFx0XHRcdFx0Ly9leHBvcnRzIHRvIG11bHRpcGxlIGVudmlyb25tZW50c1xuXHRcdFx0XHRcdFx0aWYgKGdsb2JhbCkge1xuXHRcdFx0XHRcdFx0XHRfZ2xvYmFsc1tuXSA9IGNsOyAvL3Byb3ZpZGVzIGEgd2F5IHRvIGF2b2lkIGdsb2JhbCBuYW1lc3BhY2UgcG9sbHV0aW9uLiBCeSBkZWZhdWx0LCB0aGUgbWFpbiBjbGFzc2VzIGxpa2UgVHdlZW5MaXRlLCBQb3dlcjEsIFN0cm9uZywgZXRjLiBhcmUgYWRkZWQgdG8gd2luZG93IHVubGVzcyBhIEdyZWVuU29ja0dsb2JhbHMgaXMgZGVmaW5lZC4gU28gaWYgeW91IHdhbnQgdG8gaGF2ZSB0aGluZ3MgYWRkZWQgdG8gYSBjdXN0b20gb2JqZWN0IGluc3RlYWQsIGp1c3QgZG8gc29tZXRoaW5nIGxpa2Ugd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB7fSBiZWZvcmUgbG9hZGluZyBhbnkgR3JlZW5Tb2NrIGZpbGVzLiBZb3UgY2FuIGV2ZW4gc2V0IHVwIGFuIGFsaWFzIGxpa2Ugd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB3aW5kb3dzLmdzID0ge30gc28gdGhhdCB5b3UgY2FuIGFjY2VzcyBldmVyeXRoaW5nIGxpa2UgZ3MuVHdlZW5MaXRlLiBBbHNvIHJlbWVtYmVyIHRoYXQgQUxMIGNsYXNzZXMgYXJlIGFkZGVkIHRvIHRoZSB3aW5kb3cuY29tLmdyZWVuc29jayBvYmplY3QgKGluIHRoZWlyIHJlc3BlY3RpdmUgcGFja2FnZXMsIGxpa2UgY29tLmdyZWVuc29jay5lYXNpbmcuUG93ZXIxLCBjb20uZ3JlZW5zb2NrLlR3ZWVuTGl0ZSwgZXRjLilcblx0XHRcdFx0XHRcdFx0aGFzTW9kdWxlID0gKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFoYXNNb2R1bGUgJiYgdHlwZW9mKGRlZmluZSkgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKXsgLy9BTURcblx0XHRcdFx0XHRcdFx0XHRkZWZpbmUoKHdpbmRvdy5HcmVlblNvY2tBTURQYXRoID8gd2luZG93LkdyZWVuU29ja0FNRFBhdGggKyBcIi9cIiA6IFwiXCIpICsgbnMuc3BsaXQoXCIuXCIpLnBvcCgpLCBbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBjbDsgfSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobnMgPT09IG1vZHVsZU5hbWUgJiYgaGFzTW9kdWxlKXsgLy9ub2RlXG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBjbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuc2MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zY1tpXS5jaGVjaygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5jaGVjayh0cnVlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vdXNlZCB0byBjcmVhdGUgRGVmaW5pdGlvbiBpbnN0YW5jZXMgKHdoaWNoIGJhc2ljYWxseSByZWdpc3RlcnMgYSBjbGFzcyB0aGF0IGhhcyBkZXBlbmRlbmNpZXMpLlxuXHRcdFx0X2dzRGVmaW5lID0gd2luZG93Ll9nc0RlZmluZSA9IGZ1bmN0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IERlZmluaXRpb24obnMsIGRlcGVuZGVuY2llcywgZnVuYywgZ2xvYmFsKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vYSBxdWljayB3YXkgdG8gY3JlYXRlIGEgY2xhc3MgdGhhdCBkb2Vzbid0IGhhdmUgYW55IGRlcGVuZGVuY2llcy4gUmV0dXJucyB0aGUgY2xhc3MsIGJ1dCBmaXJzdCByZWdpc3RlcnMgaXQgaW4gdGhlIEdyZWVuU29jayBuYW1lc3BhY2Ugc28gdGhhdCBvdGhlciBjbGFzc2VzIGNhbiBncmFiIGl0IChvdGhlciBjbGFzc2VzIG1pZ2h0IGJlIGRlcGVuZGVudCBvbiB0aGUgY2xhc3MpLlxuXHRcdFx0X2NsYXNzID0gZ3MuX2NsYXNzID0gZnVuY3Rpb24obnMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHRmdW5jID0gZnVuYyB8fCBmdW5jdGlvbigpIHt9O1xuXHRcdFx0XHRfZ3NEZWZpbmUobnMsIFtdLCBmdW5jdGlvbigpeyByZXR1cm4gZnVuYzsgfSwgZ2xvYmFsKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmM7XG5cdFx0XHR9O1xuXG5cdFx0X2dzRGVmaW5lLmdsb2JhbHMgPSBfZ2xvYmFscztcblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBFYXNlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgX2Jhc2VQYXJhbXMgPSBbMCwgMCwgMSwgMV0sXG5cdFx0XHRfYmxhbmtBcnJheSA9IFtdLFxuXHRcdFx0RWFzZSA9IF9jbGFzcyhcImVhc2luZy5FYXNlXCIsIGZ1bmN0aW9uKGZ1bmMsIGV4dHJhUGFyYW1zLCB0eXBlLCBwb3dlcikge1xuXHRcdFx0XHR0aGlzLl9mdW5jID0gZnVuYztcblx0XHRcdFx0dGhpcy5fdHlwZSA9IHR5cGUgfHwgMDtcblx0XHRcdFx0dGhpcy5fcG93ZXIgPSBwb3dlciB8fCAwO1xuXHRcdFx0XHR0aGlzLl9wYXJhbXMgPSBleHRyYVBhcmFtcyA/IF9iYXNlUGFyYW1zLmNvbmNhdChleHRyYVBhcmFtcykgOiBfYmFzZVBhcmFtcztcblx0XHRcdH0sIHRydWUpLFxuXHRcdFx0X2Vhc2VNYXAgPSBFYXNlLm1hcCA9IHt9LFxuXHRcdFx0X2Vhc2VSZWcgPSBFYXNlLnJlZ2lzdGVyID0gZnVuY3Rpb24oZWFzZSwgbmFtZXMsIHR5cGVzLCBjcmVhdGUpIHtcblx0XHRcdFx0dmFyIG5hID0gbmFtZXMuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRcdGkgPSBuYS5sZW5ndGgsXG5cdFx0XHRcdFx0dGEgPSAodHlwZXMgfHwgXCJlYXNlSW4sZWFzZU91dCxlYXNlSW5PdXRcIikuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRcdGUsIG5hbWUsIGosIHR5cGU7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdG5hbWUgPSBuYVtpXTtcblx0XHRcdFx0XHRlID0gY3JlYXRlID8gX2NsYXNzKFwiZWFzaW5nLlwiK25hbWUsIG51bGwsIHRydWUpIDogZ3MuZWFzaW5nW25hbWVdIHx8IHt9O1xuXHRcdFx0XHRcdGogPSB0YS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gdGFbal07XG5cdFx0XHRcdFx0XHRfZWFzZU1hcFtuYW1lICsgXCIuXCIgKyB0eXBlXSA9IF9lYXNlTWFwW3R5cGUgKyBuYW1lXSA9IGVbdHlwZV0gPSBlYXNlLmdldFJhdGlvID8gZWFzZSA6IGVhc2VbdHlwZV0gfHwgbmV3IGVhc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRwID0gRWFzZS5wcm90b3R5cGU7XG5cdFx0cC5fY2FsY0VuZCA9IGZhbHNlO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHRpZiAodGhpcy5fZnVuYykge1xuXHRcdFx0XHR0aGlzLl9wYXJhbXNbMF0gPSBwO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZnVuYy5hcHBseShudWxsLCB0aGlzLl9wYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHQgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHRwdyA9IHRoaXMuX3Bvd2VyLFxuXHRcdFx0XHRyID0gKHQgPT09IDEpID8gMSAtIHAgOiAodCA9PT0gMikgPyBwIDogKHAgPCAwLjUpID8gcCAqIDIgOiAoMSAtIHApICogMjtcblx0XHRcdGlmIChwdyA9PT0gMSkge1xuXHRcdFx0XHRyICo9IHI7XG5cdFx0XHR9IGVsc2UgaWYgKHB3ID09PSAyKSB7XG5cdFx0XHRcdHIgKj0gciAqIHI7XG5cdFx0XHR9IGVsc2UgaWYgKHB3ID09PSAzKSB7XG5cdFx0XHRcdHIgKj0gciAqIHIgKiByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gNCkge1xuXHRcdFx0XHRyICo9IHIgKiByICogciAqIHI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHQgPT09IDEpID8gMSAtIHIgOiAodCA9PT0gMikgPyByIDogKHAgPCAwLjUpID8gciAvIDIgOiAxIC0gKHIgLyAyKTtcblx0XHR9O1xuXG5cdFx0Ly9jcmVhdGUgYWxsIHRoZSBzdGFuZGFyZCBlYXNlcyBsaWtlIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIGFuZCBQb3dlcjQgKGVhY2ggd2l0aCBlYXNlSW4sIGVhc2VPdXQsIGFuZCBlYXNlSW5PdXQpXG5cdFx0YSA9IFtcIkxpbmVhclwiLFwiUXVhZFwiLFwiQ3ViaWNcIixcIlF1YXJ0XCIsXCJRdWludCxTdHJvbmdcIl07XG5cdFx0aSA9IGEubGVuZ3RoO1xuXHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0cCA9IGFbaV0rXCIsUG93ZXJcIitpO1xuXHRcdFx0X2Vhc2VSZWcobmV3IEVhc2UobnVsbCxudWxsLDEsaSksIHAsIFwiZWFzZU91dFwiLCB0cnVlKTtcblx0XHRcdF9lYXNlUmVnKG5ldyBFYXNlKG51bGwsbnVsbCwyLGkpLCBwLCBcImVhc2VJblwiICsgKChpID09PSAwKSA/IFwiLGVhc2VOb25lXCIgOiBcIlwiKSk7XG5cdFx0XHRfZWFzZVJlZyhuZXcgRWFzZShudWxsLG51bGwsMyxpKSwgcCwgXCJlYXNlSW5PdXRcIik7XG5cdFx0fVxuXHRcdF9lYXNlTWFwLmxpbmVhciA9IGdzLmVhc2luZy5MaW5lYXIuZWFzZUluO1xuXHRcdF9lYXNlTWFwLnN3aW5nID0gZ3MuZWFzaW5nLlF1YWQuZWFzZUluT3V0OyAvL2ZvciBqUXVlcnkgZm9sa3NcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRXZlbnREaXNwYXRjaGVyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgRXZlbnREaXNwYXRjaGVyID0gX2NsYXNzKFwiZXZlbnRzLkV2ZW50RGlzcGF0Y2hlclwiLCBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRcdHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXHRcdFx0dGhpcy5fZXZlbnRUYXJnZXQgPSB0YXJnZXQgfHwgdGhpcztcblx0XHR9KTtcblx0XHRwID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZTtcblxuXHRcdHAuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBzY29wZSwgdXNlUGFyYW0sIHByaW9yaXR5KSB7XG5cdFx0XHRwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsaXN0ZW5lciwgaTtcblx0XHRcdGlmIChsaXN0ID09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gbGlzdCA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGxpc3RlbmVyID0gbGlzdFtpXTtcblx0XHRcdFx0aWYgKGxpc3RlbmVyLmMgPT09IGNhbGxiYWNrICYmIGxpc3RlbmVyLnMgPT09IHNjb3BlKSB7XG5cdFx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IDAgJiYgbGlzdGVuZXIucHIgPCBwcmlvcml0eSkge1xuXHRcdFx0XHRcdGluZGV4ID0gaSArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxpc3Quc3BsaWNlKGluZGV4LCAwLCB7YzpjYWxsYmFjaywgczpzY29wZSwgdXA6dXNlUGFyYW0sIHByOnByaW9yaXR5fSk7XG5cdFx0XHRpZiAodGhpcyA9PT0gX3RpY2tlciAmJiAhX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLCBpO1xuXHRcdFx0aWYgKGxpc3QpIHtcblx0XHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAobGlzdFtpXS5jID09PSBjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLFxuXHRcdFx0XHRpLCB0LCBsaXN0ZW5lcjtcblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0dCA9IHRoaXMuX2V2ZW50VGFyZ2V0O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRsaXN0ZW5lciA9IGxpc3RbaV07XG5cdFx0XHRcdFx0aWYgKGxpc3RlbmVyKSB7XG5cdFx0XHRcdFx0XHRpZiAobGlzdGVuZXIudXApIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIuYy5jYWxsKGxpc3RlbmVyLnMgfHwgdCwge3R5cGU6dHlwZSwgdGFyZ2V0OnR9KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmMuY2FsbChsaXN0ZW5lci5zIHx8IHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRpY2tlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4gXHRcdHZhciBfcmVxQW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxcblx0XHRcdF9jYW5jZWxBbmltRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUsXG5cdFx0XHRfZ2V0VGltZSA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTt9LFxuXHRcdFx0X2xhc3RVcGRhdGUgPSBfZ2V0VGltZSgpO1xuXG5cdFx0Ly9ub3cgdHJ5IHRvIGRldGVybWluZSB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFuZCBjYW5jZWxBbmltYXRpb25GcmFtZSBmdW5jdGlvbnMgYW5kIGlmIG5vbmUgYXJlIGZvdW5kLCB3ZSdsbCB1c2UgYSBzZXRUaW1lb3V0KCkvY2xlYXJUaW1lb3V0KCkgcG9seWZpbGwuXG5cdFx0YSA9IFtcIm1zXCIsXCJtb3pcIixcIndlYmtpdFwiLFwib1wiXTtcblx0XHRpID0gYS5sZW5ndGg7XG5cdFx0d2hpbGUgKC0taSA+IC0xICYmICFfcmVxQW5pbUZyYW1lKSB7XG5cdFx0XHRfcmVxQW5pbUZyYW1lID0gd2luZG93W2FbaV0gKyBcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcblx0XHRcdF9jYW5jZWxBbmltRnJhbWUgPSB3aW5kb3dbYVtpXSArIFwiQ2FuY2VsQW5pbWF0aW9uRnJhbWVcIl0gfHwgd2luZG93W2FbaV0gKyBcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcblx0XHR9XG5cblx0XHRfY2xhc3MoXCJUaWNrZXJcIiwgZnVuY3Rpb24oZnBzLCB1c2VSQUYpIHtcblx0XHRcdHZhciBfc2VsZiA9IHRoaXMsXG5cdFx0XHRcdF9zdGFydFRpbWUgPSBfZ2V0VGltZSgpLFxuXHRcdFx0XHRfdXNlUkFGID0gKHVzZVJBRiAhPT0gZmFsc2UgJiYgX3JlcUFuaW1GcmFtZSkgPyBcImF1dG9cIiA6IGZhbHNlLFxuXHRcdFx0XHRfbGFnVGhyZXNob2xkID0gNTAwLFxuXHRcdFx0XHRfYWRqdXN0ZWRMYWcgPSAzMyxcblx0XHRcdFx0X3RpY2tXb3JkID0gXCJ0aWNrXCIsIC8vaGVscHMgcmVkdWNlIGdjIGJ1cmRlblxuXHRcdFx0XHRfZnBzLCBfcmVxLCBfaWQsIF9nYXAsIF9uZXh0VGltZSxcblx0XHRcdFx0X3RpY2sgPSBmdW5jdGlvbihtYW51YWwpIHtcblx0XHRcdFx0XHR2YXIgZWxhcHNlZCA9IF9nZXRUaW1lKCkgLSBfbGFzdFVwZGF0ZSxcblx0XHRcdFx0XHRcdG92ZXJsYXAsIGRpc3BhdGNoO1xuXHRcdFx0XHRcdGlmIChlbGFwc2VkID4gX2xhZ1RocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0X3N0YXJ0VGltZSArPSBlbGFwc2VkIC0gX2FkanVzdGVkTGFnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfbGFzdFVwZGF0ZSArPSBlbGFwc2VkO1xuXHRcdFx0XHRcdF9zZWxmLnRpbWUgPSAoX2xhc3RVcGRhdGUgLSBfc3RhcnRUaW1lKSAvIDEwMDA7XG5cdFx0XHRcdFx0b3ZlcmxhcCA9IF9zZWxmLnRpbWUgLSBfbmV4dFRpbWU7XG5cdFx0XHRcdFx0aWYgKCFfZnBzIHx8IG92ZXJsYXAgPiAwIHx8IG1hbnVhbCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0X3NlbGYuZnJhbWUrKztcblx0XHRcdFx0XHRcdF9uZXh0VGltZSArPSBvdmVybGFwICsgKG92ZXJsYXAgPj0gX2dhcCA/IDAuMDA0IDogX2dhcCAtIG92ZXJsYXApO1xuXHRcdFx0XHRcdFx0ZGlzcGF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWFudWFsICE9PSB0cnVlKSB7IC8vbWFrZSBzdXJlIHRoZSByZXF1ZXN0IGlzIG1hZGUgYmVmb3JlIHdlIGRpc3BhdGNoIHRoZSBcInRpY2tcIiBldmVudCBzbyB0aGF0IHRpbWluZyBpcyBtYWludGFpbmVkLiBPdGhlcndpc2UsIGlmIHByb2Nlc3NpbmcgdGhlIFwidGlja1wiIHJlcXVpcmVzIGEgYnVuY2ggb2YgdGltZSAobGlrZSAxNW1zKSBhbmQgd2UncmUgdXNpbmcgYSBzZXRUaW1lb3V0KCkgdGhhdCdzIGJhc2VkIG9uIDE2LjdtcywgaXQnZCB0ZWNobmljYWxseSB0YWtlIDMxLjdtcyBiZXR3ZWVuIGZyYW1lcyBvdGhlcndpc2UuXG5cdFx0XHRcdFx0XHRfaWQgPSBfcmVxKF90aWNrKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRpc3BhdGNoKSB7XG5cdFx0XHRcdFx0XHRfc2VsZi5kaXNwYXRjaEV2ZW50KF90aWNrV29yZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRFdmVudERpc3BhdGNoZXIuY2FsbChfc2VsZik7XG5cdFx0XHRfc2VsZi50aW1lID0gX3NlbGYuZnJhbWUgPSAwO1xuXHRcdFx0X3NlbGYudGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdGljayh0cnVlKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLmxhZ1Ntb290aGluZyA9IGZ1bmN0aW9uKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpIHtcblx0XHRcdFx0X2xhZ1RocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAoMSAvIF90aW55TnVtKTsgLy96ZXJvIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNpY2FsbHkgdW5saW1pdGVkXG5cdFx0XHRcdF9hZGp1c3RlZExhZyA9IE1hdGgubWluKGFkanVzdGVkTGFnLCBfbGFnVGhyZXNob2xkLCAwKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLnNsZWVwID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfaWQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIV91c2VSQUYgfHwgIV9jYW5jZWxBbmltRnJhbWUpIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoX2lkKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfY2FuY2VsQW5pbUZyYW1lKF9pZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3JlcSA9IF9lbXB0eUZ1bmM7XG5cdFx0XHRcdF9pZCA9IG51bGw7XG5cdFx0XHRcdGlmIChfc2VsZiA9PT0gX3RpY2tlcikge1xuXHRcdFx0XHRcdF90aWNrZXJBY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYud2FrZSA9IGZ1bmN0aW9uKHNlYW1sZXNzKSB7XG5cdFx0XHRcdGlmIChfaWQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRfc2VsZi5zbGVlcCgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNlYW1sZXNzKSB7XG5cdFx0XHRcdFx0X3N0YXJ0VGltZSArPSAtX2xhc3RVcGRhdGUgKyAoX2xhc3RVcGRhdGUgPSBfZ2V0VGltZSgpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChfc2VsZi5mcmFtZSA+IDEwKSB7IC8vZG9uJ3QgdHJpZ2dlciBsYWdTbW9vdGhpbmcgaWYgd2UncmUganVzdCB3YWtpbmcgdXAsIGFuZCBtYWtlIHN1cmUgdGhhdCBhdCBsZWFzdCAxMCBmcmFtZXMgaGF2ZSBlbGFwc2VkIGJlY2F1c2Ugb2YgdGhlIGlPUyBidWcgdGhhdCB3ZSB3b3JrIGFyb3VuZCBiZWxvdyB3aXRoIHRoZSAxLjUtc2Vjb25kIHNldFRpbW91dCgpLlxuXHRcdFx0XHRcdF9sYXN0VXBkYXRlID0gX2dldFRpbWUoKSAtIF9sYWdUaHJlc2hvbGQgKyA1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yZXEgPSAoX2ZwcyA9PT0gMCkgPyBfZW1wdHlGdW5jIDogKCFfdXNlUkFGIHx8ICFfcmVxQW5pbUZyYW1lKSA/IGZ1bmN0aW9uKGYpIHsgcmV0dXJuIHNldFRpbWVvdXQoZiwgKChfbmV4dFRpbWUgLSBfc2VsZi50aW1lKSAqIDEwMDAgKyAxKSB8IDApOyB9IDogX3JlcUFuaW1GcmFtZTtcblx0XHRcdFx0aWYgKF9zZWxmID09PSBfdGlja2VyKSB7XG5cdFx0XHRcdFx0X3RpY2tlckFjdGl2ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3RpY2soMik7XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi5mcHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2Zwcztcblx0XHRcdFx0fVxuXHRcdFx0XHRfZnBzID0gdmFsdWU7XG5cdFx0XHRcdF9nYXAgPSAxIC8gKF9mcHMgfHwgNjApO1xuXHRcdFx0XHRfbmV4dFRpbWUgPSB0aGlzLnRpbWUgKyBfZ2FwO1xuXHRcdFx0XHRfc2VsZi53YWtlKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi51c2VSQUYgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gX3VzZVJBRjtcblx0XHRcdFx0fVxuXHRcdFx0XHRfc2VsZi5zbGVlcCgpO1xuXHRcdFx0XHRfdXNlUkFGID0gdmFsdWU7XG5cdFx0XHRcdF9zZWxmLmZwcyhfZnBzKTtcblx0XHRcdH07XG5cdFx0XHRfc2VsZi5mcHMoZnBzKTtcblxuXHRcdFx0Ly9hIGJ1ZyBpbiBpT1MgNiBTYWZhcmkgb2NjYXNpb25hbGx5IHByZXZlbnRzIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJvbSB3b3JraW5nIGluaXRpYWxseSwgc28gd2UgdXNlIGEgMS41LXNlY29uZCB0aW1lb3V0IHRoYXQgYXV0b21hdGljYWxseSBmYWxscyBiYWNrIHRvIHNldFRpbWVvdXQoKSBpZiBpdCBzZW5zZXMgdGhpcyBjb25kaXRpb24uXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX3VzZVJBRiA9PT0gXCJhdXRvXCIgJiYgX3NlbGYuZnJhbWUgPCA1ICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIikge1xuXHRcdFx0XHRcdF9zZWxmLnVzZVJBRihmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIDE1MDApO1xuXHRcdH0pO1xuXG5cdFx0cCA9IGdzLlRpY2tlci5wcm90b3R5cGUgPSBuZXcgZ3MuZXZlbnRzLkV2ZW50RGlzcGF0Y2hlcigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBncy5UaWNrZXI7XG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEFuaW1hdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIEFuaW1hdGlvbiA9IF9jbGFzcyhcImNvcmUuQW5pbWF0aW9uXCIsIGZ1bmN0aW9uKGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRcdHRoaXMudmFycyA9IHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0XHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwO1xuXHRcdFx0XHR0aGlzLl9kZWxheSA9IE51bWJlcih2YXJzLmRlbGF5KSB8fCAwO1xuXHRcdFx0XHR0aGlzLl90aW1lU2NhbGUgPSAxO1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLmRhdGEgPSB2YXJzLmRhdGE7XG5cdFx0XHRcdHRoaXMuX3JldmVyc2VkID0gKHZhcnMucmV2ZXJzZWQgPT09IHRydWUpO1xuXG5cdFx0XHRcdGlmICghX3Jvb3RUaW1lbGluZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHsgLy9zb21lIGJyb3dzZXJzIChsaWtlIGlPUyA2IFNhZmFyaSkgc2h1dCBkb3duIEphdmFTY3JpcHQgZXhlY3V0aW9uIHdoZW4gdGhlIHRhYiBpcyBkaXNhYmxlZCBhbmQgdGhleSBbb2NjYXNpb25hbGx5XSBuZWdsZWN0IHRvIHN0YXJ0IHVwIHJlcXVlc3RBbmltYXRpb25GcmFtZSBhZ2FpbiB3aGVuIHJldHVybmluZyAtIHRoaXMgY29kZSBlbnN1cmVzIHRoYXQgdGhlIGVuZ2luZSBzdGFydHMgdXAgYWdhaW4gcHJvcGVybHkuXG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdGwgPSB0aGlzLnZhcnMudXNlRnJhbWVzID8gX3Jvb3RGcmFtZXNUaW1lbGluZSA6IF9yb290VGltZWxpbmU7XG5cdFx0XHRcdHRsLmFkZCh0aGlzLCB0bC5fdGltZSk7XG5cblx0XHRcdFx0aWYgKHRoaXMudmFycy5wYXVzZWQpIHtcblx0XHRcdFx0XHR0aGlzLnBhdXNlZCh0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRfdGlja2VyID0gQW5pbWF0aW9uLnRpY2tlciA9IG5ldyBncy5UaWNrZXIoKTtcblx0XHRwID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblx0XHRwLl9kaXJ0eSA9IHAuX2djID0gcC5faW5pdHRlZCA9IHAuX3BhdXNlZCA9IGZhbHNlO1xuXHRcdHAuX3RvdGFsVGltZSA9IHAuX3RpbWUgPSAwO1xuXHRcdHAuX3Jhd1ByZXZUaW1lID0gLTE7XG5cdFx0cC5fbmV4dCA9IHAuX2xhc3QgPSBwLl9vblVwZGF0ZSA9IHAuX3RpbWVsaW5lID0gcC50aW1lbGluZSA9IG51bGw7XG5cdFx0cC5fcGF1c2VkID0gZmFsc2U7XG5cblxuXHRcdC8vc29tZSBicm93c2VycyAobGlrZSBpT1MpIG9jY2FzaW9uYWxseSBkcm9wIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZXZlbnQgd2hlbiB0aGUgdXNlciBzd2l0Y2hlcyB0byBhIGRpZmZlcmVudCB0YWIgYW5kIHRoZW4gY29tZXMgYmFjayBhZ2Fpbiwgc28gd2UgdXNlIGEgMi1zZWNvbmQgc2V0VGltZW91dCgpIHRvIHNlbnNlIGlmL3doZW4gdGhhdCBjb25kaXRpb24gb2NjdXJzIGFuZCB0aGVuIHdha2UoKSB0aGUgdGlja2VyLlxuXHRcdHZhciBfY2hlY2tUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfdGlja2VyQWN0aXZlICYmIF9nZXRUaW1lKCkgLSBfbGFzdFVwZGF0ZSA+IDIwMDApIHtcblx0XHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRUaW1lb3V0KF9jaGVja1RpbWVvdXQsIDIwMDApO1xuXHRcdFx0fTtcblx0XHRfY2hlY2tUaW1lb3V0KCk7XG5cblxuXHRcdHAucGxheSA9IGZ1bmN0aW9uKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5wYXVzZSA9IGZ1bmN0aW9uKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChhdFRpbWUgIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAucmVzdW1lID0gZnVuY3Rpb24oZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZChmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAuc2VlayA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoTnVtYmVyKHRpbWUpLCBzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnJlc3RhcnQgPSBmdW5jdGlvbihpbmNsdWRlRGVsYXksIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKS50b3RhbFRpbWUoaW5jbHVkZURlbGF5ID8gLXRoaXMuX2RlbGF5IDogMCwgKHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSksIHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJldmVyc2UgPSBmdW5jdGlvbihmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoKGZyb20gfHwgdGhpcy50b3RhbER1cmF0aW9uKCkpLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0Ly9zdHViIC0gd2Ugb3ZlcnJpZGUgdGhpcyBtZXRob2QgaW4gc3ViY2xhc3Nlcy5cblx0XHR9O1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lID0gMDtcblx0XHRcdHRoaXMuX2luaXR0ZWQgPSB0aGlzLl9nYyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAtMTtcblx0XHRcdGlmICh0aGlzLl9nYyB8fCAhdGhpcy50aW1lbGluZSkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0bCA9IHRoaXMuX3RpbWVsaW5lLCAvL3RoZSAyIHJvb3QgdGltZWxpbmVzIHdvbid0IGhhdmUgYSBfdGltZWxpbmU7IHRoZXkncmUgYWx3YXlzIGFjdGl2ZS5cblx0XHRcdFx0c3RhcnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdFx0XHRyYXdUaW1lO1xuXHRcdFx0cmV0dXJuICghdGwgfHwgKCF0aGlzLl9nYyAmJiAhdGhpcy5fcGF1c2VkICYmIHRsLmlzQWN0aXZlKCkgJiYgKHJhd1RpbWUgPSB0bC5yYXdUaW1lKCkpID49IHN0YXJ0VGltZSAmJiByYXdUaW1lIDwgc3RhcnRUaW1lICsgdGhpcy50b3RhbER1cmF0aW9uKCkgLyB0aGlzLl90aW1lU2NhbGUpKTtcblx0XHR9O1xuXG5cdFx0cC5fZW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkLCBpZ25vcmVUaW1lbGluZSkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZ2MgPSAhZW5hYmxlZDtcblx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRoaXMuaXNBY3RpdmUoKTtcblx0XHRcdGlmIChpZ25vcmVUaW1lbGluZSAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRpZiAoZW5hYmxlZCAmJiAhdGhpcy50aW1lbGluZSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWVsaW5lLmFkZCh0aGlzLCB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9kZWxheSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgdGhpcy50aW1lbGluZSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWVsaW5lLl9yZW1vdmUodGhpcywgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLmtpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdHRoaXMuX2tpbGwodmFycywgdGFyZ2V0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl91bmNhY2hlID0gZnVuY3Rpb24oaW5jbHVkZVNlbGYpIHtcblx0XHRcdHZhciB0d2VlbiA9IGluY2x1ZGVTZWxmID8gdGhpcyA6IHRoaXMudGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0dHdlZW4uX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl9zd2FwU2VsZkluUGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0XHR2YXIgaSA9IHBhcmFtcy5sZW5ndGgsXG5cdFx0XHRcdGNvcHkgPSBwYXJhbXMuY29uY2F0KCk7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHBhcmFtc1tpXSA9PT0gXCJ7c2VsZn1cIikge1xuXHRcdFx0XHRcdGNvcHlbaV0gPSB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29weTtcblx0XHR9O1xuXG5cdFx0cC5fY2FsbGJhY2sgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgdiA9IHRoaXMudmFycztcblx0XHRcdHZbdHlwZV0uYXBwbHkodlt0eXBlICsgXCJTY29wZVwiXSB8fCB2LmNhbGxiYWNrU2NvcGUgfHwgdGhpcywgdlt0eXBlICsgXCJQYXJhbXNcIl0gfHwgX2JsYW5rQXJyYXkpO1xuXHRcdH07XG5cbi8vLS0tLUFuaW1hdGlvbiBnZXR0ZXJzL3NldHRlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAuZXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHRpZiAoKHR5cGUgfHwgXCJcIikuc3Vic3RyKDAsMikgPT09IFwib25cIikge1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFycztcblx0XHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdlt0eXBlXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB2W3R5cGVdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZbdHlwZV0gPSBjYWxsYmFjaztcblx0XHRcdFx0XHR2W3R5cGUgKyBcIlBhcmFtc1wiXSA9IChfaXNBcnJheShwYXJhbXMpICYmIHBhcmFtcy5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikgIT09IC0xKSA/IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXMocGFyYW1zKSA6IHBhcmFtcztcblx0XHRcdFx0XHR2W3R5cGUgKyBcIlNjb3BlXCJdID0gc2NvcGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGUgPT09IFwib25VcGRhdGVcIikge1xuXHRcdFx0XHRcdHRoaXMuX29uVXBkYXRlID0gY2FsbGJhY2s7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmRlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZGVsYXk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0dGhpcy5zdGFydFRpbWUoIHRoaXMuX3N0YXJ0VGltZSArIHZhbHVlIC0gdGhpcy5fZGVsYXkgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RlbGF5ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gdmFsdWU7XG5cdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpOyAvL3RydWUgaW4gY2FzZSBpdCdzIGEgVHdlZW5NYXggb3IgVGltZWxpbmVNYXggdGhhdCBoYXMgYSByZXBlYXQgLSB3ZSdsbCBuZWVkIHRvIHJlZnJlc2ggdGhlIHRvdGFsRHVyYXRpb24uXG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIGlmICh0aGlzLl90aW1lID4gMCkgaWYgKHRoaXMuX3RpbWUgPCB0aGlzLl9kdXJhdGlvbikgaWYgKHZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHRoaXMudG90YWxUaW1lKHRoaXMuX3RvdGFsVGltZSAqICh2YWx1ZSAvIHRoaXMuX2R1cmF0aW9uKSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLmR1cmF0aW9uKHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC50aW1lID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoKHZhbHVlID4gdGhpcy5fZHVyYXRpb24pID8gdGhpcy5fZHVyYXRpb24gOiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsVGltZSA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCB1bmNhcHBlZCkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbFRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwICYmICF1bmNhcHBlZCkge1xuXHRcdFx0XHRcdHRpbWUgKz0gdGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHRvdGFsRHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uLFxuXHRcdFx0XHRcdFx0dGwgPSB0aGlzLl90aW1lbGluZTtcblx0XHRcdFx0XHRpZiAodGltZSA+IHRvdGFsRHVyYXRpb24gJiYgIXVuY2FwcGVkKSB7XG5cdFx0XHRcdFx0XHR0aW1lID0gdG90YWxEdXJhdGlvbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gKHRoaXMuX3BhdXNlZCA/IHRoaXMuX3BhdXNlVGltZSA6IHRsLl90aW1lKSAtICgoIXRoaXMuX3JldmVyc2VkID8gdGltZSA6IHRvdGFsRHVyYXRpb24gLSB0aW1lKSAvIHRoaXMuX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0aWYgKCF0bC5fZGlydHkpIHsgLy9mb3IgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuIElmIHRoZSBwYXJlbnQncyBjYWNoZSBpcyBhbHJlYWR5IGRpcnR5LCBpdCBhbHJlYWR5IHRvb2sgY2FyZSBvZiBtYXJraW5nIHRoZSBhbmNlc3RvcnMgYXMgZGlydHkgdG9vLCBzbyBza2lwIHRoZSBmdW5jdGlvbiBjYWxsIGhlcmUuXG5cdFx0XHRcdFx0XHR0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0VGltZSBvZiB0aGF0IGNoaWxkIHdvdWxkIGdldCBwdXNoZWQgb3V0LCBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgbWF5IGhhdmUgY29tcGxldGVkLlxuXHRcdFx0XHRcdGlmICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHRsLl90aW1lbGluZS5fdGltZSAhPT0gKHRsLl9zdGFydFRpbWUgKyB0bC5fdG90YWxUaW1lKSAvIHRsLl90aW1lU2NhbGUpIHtcblx0XHRcdFx0XHRcdFx0XHR0bC50b3RhbFRpbWUodGwuX3RvdGFsVGltZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl90b3RhbFRpbWUgIT09IHRpbWUgfHwgdGhpcy5fZHVyYXRpb24gPT09IDApIHtcblx0XHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZmFsc2UpO1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIHNvbWVvbmUgY2FsbHMgc2VlaygpIG9yIHRpbWUoKSBvciBwcm9ncmVzcygpLCB0aGV5IGV4cGVjdCBhbiBpbW1lZGlhdGUgcmVuZGVyLlxuXHRcdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnByb2dyZXNzID0gcC50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHR2YXIgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCk7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IChkdXJhdGlvbiA/IHRoaXMuX3RpbWUgLyBkdXJhdGlvbiA6IHRoaXMucmF0aW8pIDogdGhpcy50b3RhbFRpbWUoZHVyYXRpb24gKiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnN0YXJ0VGltZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3N0YXJ0VGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAodGhpcy50aW1lbGluZSkgaWYgKHRoaXMudGltZWxpbmUuX3NvcnRDaGlsZHJlbikge1xuXHRcdFx0XHRcdHRoaXMudGltZWxpbmUuYWRkKHRoaXMsIHZhbHVlIC0gdGhpcy5fZGVsYXkpOyAvL2Vuc3VyZXMgdGhhdCBhbnkgbmVjZXNzYXJ5IHJlLXNlcXVlbmNpbmcgb2YgQW5pbWF0aW9ucyBpbiB0aGUgdGltZWxpbmUgb2NjdXJzIHRvIG1ha2Ugc3VyZSB0aGUgcmVuZGVyaW5nIG9yZGVyIGlzIGNvcnJlY3QuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmVuZFRpbWUgPSBmdW5jdGlvbihpbmNsdWRlUmVwZWF0cykge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0YXJ0VGltZSArICgoaW5jbHVkZVJlcGVhdHMgIT0gZmFsc2UpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLmR1cmF0aW9uKCkpIC8gdGhpcy5fdGltZVNjYWxlO1xuXHRcdH07XG5cblx0XHRwLnRpbWVTY2FsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWVTY2FsZTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgX3RpbnlOdW07IC8vY2FuJ3QgYWxsb3cgemVybyBiZWNhdXNlIGl0J2xsIHRocm93IHRoZSBtYXRoIG9mZlxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lICYmIHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdHZhciBwYXVzZVRpbWUgPSB0aGlzLl9wYXVzZVRpbWUsXG5cdFx0XHRcdFx0dCA9IChwYXVzZVRpbWUgfHwgcGF1c2VUaW1lID09PSAwKSA/IHBhdXNlVGltZSA6IHRoaXMuX3RpbWVsaW5lLnRvdGFsVGltZSgpO1xuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB0IC0gKCh0IC0gdGhpcy5fc3RhcnRUaW1lKSAqIHRoaXMuX3RpbWVTY2FsZSAvIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3RpbWVTY2FsZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnJldmVyc2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT0gdGhpcy5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0dGhpcy5fcmV2ZXJzZWQgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy50b3RhbFRpbWUoKCh0aGlzLl90aW1lbGluZSAmJiAhdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgLSB0aGlzLl90b3RhbFRpbWUgOiB0aGlzLl90b3RhbFRpbWUpLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhdXNlZDtcblx0XHRcdH1cblx0XHRcdHZhciB0bCA9IHRoaXMuX3RpbWVsaW5lLFxuXHRcdFx0XHRyYXcsIGVsYXBzZWQ7XG5cdFx0XHRpZiAodmFsdWUgIT0gdGhpcy5fcGF1c2VkKSBpZiAodGwpIHtcblx0XHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlICYmICF2YWx1ZSkge1xuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJhdyA9IHRsLnJhd1RpbWUoKTtcblx0XHRcdFx0ZWxhcHNlZCA9IHJhdyAtIHRoaXMuX3BhdXNlVGltZTtcblx0XHRcdFx0aWYgKCF2YWx1ZSAmJiB0bC5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSArPSBlbGFwc2VkO1xuXHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3BhdXNlVGltZSA9IHZhbHVlID8gcmF3IDogbnVsbDtcblx0XHRcdFx0dGhpcy5fcGF1c2VkID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRoaXMuaXNBY3RpdmUoKTtcblx0XHRcdFx0aWYgKCF2YWx1ZSAmJiBlbGFwc2VkICE9PSAwICYmIHRoaXMuX2luaXR0ZWQgJiYgdGhpcy5kdXJhdGlvbigpKSB7XG5cdFx0XHRcdFx0cmF3ID0gdGwuc21vb3RoQ2hpbGRUaW1pbmcgPyB0aGlzLl90b3RhbFRpbWUgOiAocmF3IC0gdGhpcy5fc3RhcnRUaW1lKSAvIHRoaXMuX3RpbWVTY2FsZTtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcihyYXcsIChyYXcgPT09IHRoaXMuX3RvdGFsVGltZSksIHRydWUpOyAvL2luIGNhc2UgdGhlIHRhcmdldCdzIHByb3BlcnRpZXMgY2hhbmdlZCB2aWEgc29tZSBvdGhlciB0d2VlbiBvciBtYW51YWwgdXBkYXRlIGJ5IHRoZSB1c2VyLCB3ZSBzaG91bGQgZm9yY2UgYSByZW5kZXIuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9nYyAmJiAhdmFsdWUpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBTaW1wbGVUaW1lbGluZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFNpbXBsZVRpbWVsaW5lID0gX2NsYXNzKFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLCBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRBbmltYXRpb24uY2FsbCh0aGlzLCAwLCB2YXJzKTtcblx0XHRcdHRoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gdGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9IHRydWU7XG5cdFx0fSk7XG5cblx0XHRwID0gU2ltcGxlVGltZWxpbmUucHJvdG90eXBlID0gbmV3IEFuaW1hdGlvbigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBTaW1wbGVUaW1lbGluZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblx0XHRwLl9maXJzdCA9IHAuX2xhc3QgPSBwLl9yZWNlbnQgPSBudWxsO1xuXHRcdHAuX3NvcnRDaGlsZHJlbiA9IGZhbHNlO1xuXG5cdFx0cC5hZGQgPSBwLmluc2VydCA9IGZ1bmN0aW9uKGNoaWxkLCBwb3NpdGlvbiwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHZhciBwcmV2VHdlZW4sIHN0O1xuXHRcdFx0Y2hpbGQuX3N0YXJ0VGltZSA9IE51bWJlcihwb3NpdGlvbiB8fCAwKSArIGNoaWxkLl9kZWxheTtcblx0XHRcdGlmIChjaGlsZC5fcGF1c2VkKSBpZiAodGhpcyAhPT0gY2hpbGQuX3RpbWVsaW5lKSB7IC8vd2Ugb25seSBhZGp1c3QgdGhlIF9wYXVzZVRpbWUgaWYgaXQgd2Fzbid0IGluIHRoaXMgdGltZWxpbmUgYWxyZWFkeS4gUmVtZW1iZXIsIHNvbWV0aW1lcyBhIHR3ZWVuIHdpbGwgYmUgaW5zZXJ0ZWQgYWdhaW4gaW50byB0aGUgc2FtZSB0aW1lbGluZSB3aGVuIGl0cyBzdGFydFRpbWUgaXMgY2hhbmdlZCBzbyB0aGF0IHRoZSB0d2VlbnMgaW4gdGhlIFRpbWVsaW5lTGl0ZS9NYXggYXJlIHJlLW9yZGVyZWQgcHJvcGVybHkgaW4gdGhlIGxpbmtlZCBsaXN0IChzbyBldmVyeXRoaW5nIHJlbmRlcnMgaW4gdGhlIHByb3BlciBvcmRlcikuXG5cdFx0XHRcdGNoaWxkLl9wYXVzZVRpbWUgPSBjaGlsZC5fc3RhcnRUaW1lICsgKCh0aGlzLnJhd1RpbWUoKSAtIGNoaWxkLl9zdGFydFRpbWUpIC8gY2hpbGQuX3RpbWVTY2FsZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hpbGQudGltZWxpbmUpIHtcblx0XHRcdFx0Y2hpbGQudGltZWxpbmUuX3JlbW92ZShjaGlsZCwgdHJ1ZSk7IC8vcmVtb3ZlcyBmcm9tIGV4aXN0aW5nIHRpbWVsaW5lIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IGFkZGVkIHRvIHRoaXMgb25lLlxuXHRcdFx0fVxuXHRcdFx0Y2hpbGQudGltZWxpbmUgPSBjaGlsZC5fdGltZWxpbmUgPSB0aGlzO1xuXHRcdFx0aWYgKGNoaWxkLl9nYykge1xuXHRcdFx0XHRjaGlsZC5fZW5hYmxlZCh0cnVlLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHByZXZUd2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRpZiAodGhpcy5fc29ydENoaWxkcmVuKSB7XG5cdFx0XHRcdHN0ID0gY2hpbGQuX3N0YXJ0VGltZTtcblx0XHRcdFx0d2hpbGUgKHByZXZUd2VlbiAmJiBwcmV2VHdlZW4uX3N0YXJ0VGltZSA+IHN0KSB7XG5cdFx0XHRcdFx0cHJldlR3ZWVuID0gcHJldlR3ZWVuLl9wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlR3ZWVuKSB7XG5cdFx0XHRcdGNoaWxkLl9uZXh0ID0gcHJldlR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRwcmV2VHdlZW4uX25leHQgPSBjaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoaWxkLl9uZXh0ID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0ID0gY2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hpbGQuX25leHQpIHtcblx0XHRcdFx0Y2hpbGQuX25leHQuX3ByZXYgPSBjaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2xhc3QgPSBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGNoaWxkLl9wcmV2ID0gcHJldlR3ZWVuO1xuXHRcdFx0dGhpcy5fcmVjZW50ID0gY2hpbGQ7XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl9yZW1vdmUgPSBmdW5jdGlvbih0d2Vlbiwgc2tpcERpc2FibGUpIHtcblx0XHRcdGlmICh0d2Vlbi50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHRpZiAoIXNraXBEaXNhYmxlKSB7XG5cdFx0XHRcdFx0dHdlZW4uX2VuYWJsZWQoZmFsc2UsIHRydWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHR3ZWVuLl9wcmV2KSB7XG5cdFx0XHRcdFx0dHdlZW4uX3ByZXYuX25leHQgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9maXJzdCA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0d2Vlbi5fbmV4dCkge1xuXHRcdFx0XHRcdHR3ZWVuLl9uZXh0Ll9wcmV2ID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fbGFzdCA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHR0aGlzLl9sYXN0ID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4uX25leHQgPSB0d2Vlbi5fcHJldiA9IHR3ZWVuLnRpbWVsaW5lID0gbnVsbDtcblx0XHRcdFx0aWYgKHR3ZWVuID09PSB0aGlzLl9yZWNlbnQpIHtcblx0XHRcdFx0XHR0aGlzLl9yZWNlbnQgPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0bmV4dDtcblx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0aWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHRpbWUgPj0gdHdlZW4uX3N0YXJ0VGltZSAmJiAhdHdlZW4uX3BhdXNlZCkpIHtcblx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5yYXdUaW1lID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxUaW1lO1xuXHRcdH07XG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUd2VlbkxpdGVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBUd2VlbkxpdGUgPSBfY2xhc3MoXCJUd2VlbkxpdGVcIiwgZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0XHRBbmltYXRpb24uY2FsbCh0aGlzLCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0XHRcdHRoaXMucmVuZGVyID0gVHdlZW5MaXRlLnByb3RvdHlwZS5yZW5kZXI7IC8vc3BlZWQgb3B0aW1pemF0aW9uIChhdm9pZCBwcm90b3R5cGUgbG9va3VwIG9uIHRoaXMgXCJob3RcIiBtZXRob2QpXG5cblx0XHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJDYW5ub3QgdHdlZW4gYSBudWxsIHRhcmdldC5cIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/IHRhcmdldCA6IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXQpIHx8IHRhcmdldDtcblxuXHRcdFx0XHR2YXIgaXNTZWxlY3RvciA9ICh0YXJnZXQuanF1ZXJ5IHx8ICh0YXJnZXQubGVuZ3RoICYmIHRhcmdldCAhPT0gd2luZG93ICYmIHRhcmdldFswXSAmJiAodGFyZ2V0WzBdID09PSB3aW5kb3cgfHwgKHRhcmdldFswXS5ub2RlVHlwZSAmJiB0YXJnZXRbMF0uc3R5bGUgJiYgIXRhcmdldC5ub2RlVHlwZSkpKSksXG5cdFx0XHRcdFx0b3ZlcndyaXRlID0gdGhpcy52YXJzLm92ZXJ3cml0ZSxcblx0XHRcdFx0XHRpLCB0YXJnLCB0YXJnZXRzO1xuXG5cdFx0XHRcdHRoaXMuX292ZXJ3cml0ZSA9IG92ZXJ3cml0ZSA9IChvdmVyd3JpdGUgPT0gbnVsbCkgPyBfb3ZlcndyaXRlTG9va3VwW1R3ZWVuTGl0ZS5kZWZhdWx0T3ZlcndyaXRlXSA6ICh0eXBlb2Yob3ZlcndyaXRlKSA9PT0gXCJudW1iZXJcIikgPyBvdmVyd3JpdGUgPj4gMCA6IF9vdmVyd3JpdGVMb29rdXBbb3ZlcndyaXRlXTtcblxuXHRcdFx0XHRpZiAoKGlzU2VsZWN0b3IgfHwgdGFyZ2V0IGluc3RhbmNlb2YgQXJyYXkgfHwgKHRhcmdldC5wdXNoICYmIF9pc0FycmF5KHRhcmdldCkpKSAmJiB0eXBlb2YodGFyZ2V0WzBdKSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdHRoaXMuX3RhcmdldHMgPSB0YXJnZXRzID0gX3NsaWNlKHRhcmdldCk7ICAvL2Rvbid0IHVzZSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0YXJnZXQsIDApIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdFx0dGhpcy5fcHJvcExvb2t1cCA9IFtdO1xuXHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzID0gW107XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHRhcmcgPSB0YXJnZXRzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKCF0YXJnKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodGFyZykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdFx0dGFyZyA9IHRhcmdldHNbaS0tXSA9IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnKTsgLy9pbiBjYXNlIGl0J3MgYW4gYXJyYXkgb2Ygc3RyaW5nc1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mKHRhcmcpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaSsxLCAxKTsgLy90byBhdm9pZCBhbiBlbmRsZXNzIGxvb3AgKGNhbid0IGltYWdpbmUgd2h5IHRoZSBzZWxlY3RvciB3b3VsZCByZXR1cm4gYSBzdHJpbmcsIGJ1dCBqdXN0IGluIGNhc2UpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhcmcubGVuZ3RoICYmIHRhcmcgIT09IHdpbmRvdyAmJiB0YXJnWzBdICYmICh0YXJnWzBdID09PSB3aW5kb3cgfHwgKHRhcmdbMF0ubm9kZVR5cGUgJiYgdGFyZ1swXS5zdHlsZSAmJiAhdGFyZy5ub2RlVHlwZSkpKSB7IC8vaW4gY2FzZSB0aGUgdXNlciBpcyBwYXNzaW5nIGluIGFuIGFycmF5IG9mIHNlbGVjdG9yIG9iamVjdHMgKGxpa2UgalF1ZXJ5IG9iamVjdHMpLCB3ZSBuZWVkIHRvIGNoZWNrIG9uZSBtb3JlIGxldmVsIGFuZCBwdWxsIHRoaW5ncyBvdXQgaWYgbmVjZXNzYXJ5LiBBbHNvIG5vdGUgdGhhdCA8c2VsZWN0PiBlbGVtZW50cyBwYXNzIGFsbCB0aGUgY3JpdGVyaWEgcmVnYXJkaW5nIGxlbmd0aCBhbmQgdGhlIGZpcnN0IGNoaWxkIGhhdmluZyBzdHlsZSwgc28gd2UgbXVzdCBhbHNvIGNoZWNrIHRvIGVuc3VyZSB0aGUgdGFyZ2V0IGlzbid0IGFuIEhUTUwgbm9kZSBpdHNlbGYuXG5cdFx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RhcmdldHMgPSB0YXJnZXRzID0gdGFyZ2V0cy5jb25jYXQoX3NsaWNlKHRhcmcpKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9zaWJsaW5nc1tpXSA9IF9yZWdpc3Rlcih0YXJnLCB0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRpZiAob3ZlcndyaXRlID09PSAxKSBpZiAodGhpcy5fc2libGluZ3NbaV0ubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0XHRfYXBwbHlPdmVyd3JpdGUodGFyZywgdGhpcywgbnVsbCwgMSwgdGhpcy5fc2libGluZ3NbaV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BMb29rdXAgPSB7fTtcblx0XHRcdFx0XHR0aGlzLl9zaWJsaW5ncyA9IF9yZWdpc3Rlcih0YXJnZXQsIHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0XHRpZiAob3ZlcndyaXRlID09PSAxKSBpZiAodGhpcy5fc2libGluZ3MubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0X2FwcGx5T3ZlcndyaXRlKHRhcmdldCwgdGhpcywgbnVsbCwgMSwgdGhpcy5fc2libGluZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciB8fCAoZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fZGVsYXkgPT09IDAgJiYgdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIoTWF0aC5taW4oMCwgLXRoaXMuX2RlbGF5KSk7IC8vaW4gY2FzZSBkZWxheSBpcyBuZWdhdGl2ZVxuXHRcdFx0XHR9XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdF9pc1NlbGVjdG9yID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHRyZXR1cm4gKHYgJiYgdi5sZW5ndGggJiYgdiAhPT0gd2luZG93ICYmIHZbMF0gJiYgKHZbMF0gPT09IHdpbmRvdyB8fCAodlswXS5ub2RlVHlwZSAmJiB2WzBdLnN0eWxlICYmICF2Lm5vZGVUeXBlKSkpOyAvL3dlIGNhbm5vdCBjaGVjayBcIm5vZGVUeXBlXCIgaWYgdGhlIHRhcmdldCBpcyB3aW5kb3cgZnJvbSB3aXRoaW4gYW4gaWZyYW1lLCBvdGhlcndpc2UgaXQgd2lsbCB0cmlnZ2VyIGEgc2VjdXJpdHkgZXJyb3IgaW4gc29tZSBicm93c2VycyBsaWtlIEZpcmVmb3guXG5cdFx0XHR9LFxuXHRcdFx0X2F1dG9DU1MgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdFx0dmFyIGNzcyA9IHt9LFxuXHRcdFx0XHRcdHA7XG5cdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0aWYgKCFfcmVzZXJ2ZWRQcm9wc1twXSAmJiAoIShwIGluIHRhcmdldCkgfHwgcCA9PT0gXCJ0cmFuc2Zvcm1cIiB8fCBwID09PSBcInhcIiB8fCBwID09PSBcInlcIiB8fCBwID09PSBcIndpZHRoXCIgfHwgcCA9PT0gXCJoZWlnaHRcIiB8fCBwID09PSBcImNsYXNzTmFtZVwiIHx8IHAgPT09IFwiYm9yZGVyXCIpICYmICghX3BsdWdpbnNbcF0gfHwgKF9wbHVnaW5zW3BdICYmIF9wbHVnaW5zW3BdLl9hdXRvQ1NTKSkpIHsgLy9ub3RlOiA8aW1nPiBlbGVtZW50cyBjb250YWluIHJlYWQtb25seSBcInhcIiBhbmQgXCJ5XCIgcHJvcGVydGllcy4gV2Ugc2hvdWxkIGFsc28gcHJpb3JpdGl6ZSBlZGl0aW5nIGNzcyB3aWR0aC9oZWlnaHQgcmF0aGVyIHRoYW4gdGhlIGVsZW1lbnQncyBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRcdFx0Y3NzW3BdID0gdmFyc1twXTtcblx0XHRcdFx0XHRcdGRlbGV0ZSB2YXJzW3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXJzLmNzcyA9IGNzcztcblx0XHRcdH07XG5cblx0XHRwID0gVHdlZW5MaXRlLnByb3RvdHlwZSA9IG5ldyBBbmltYXRpb24oKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gVHdlZW5MaXRlO1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXG4vLy0tLS1Ud2VlbkxpdGUgZGVmYXVsdHMsIG92ZXJ3cml0ZSBtYW5hZ2VtZW50LCBhbmQgcm9vdCB1cGRhdGVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAucmF0aW8gPSAwO1xuXHRcdHAuX2ZpcnN0UFQgPSBwLl90YXJnZXRzID0gcC5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHAuX3N0YXJ0QXQgPSBudWxsO1xuXHRcdHAuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgPSBwLl9sYXp5ID0gZmFsc2U7XG5cblx0XHRUd2VlbkxpdGUudmVyc2lvbiA9IFwiMS4xOC40XCI7XG5cdFx0VHdlZW5MaXRlLmRlZmF1bHRFYXNlID0gcC5fZWFzZSA9IG5ldyBFYXNlKG51bGwsIG51bGwsIDEsIDEpO1xuXHRcdFR3ZWVuTGl0ZS5kZWZhdWx0T3ZlcndyaXRlID0gXCJhdXRvXCI7XG5cdFx0VHdlZW5MaXRlLnRpY2tlciA9IF90aWNrZXI7XG5cdFx0VHdlZW5MaXRlLmF1dG9TbGVlcCA9IDEyMDtcblx0XHRUd2VlbkxpdGUubGFnU21vb3RoaW5nID0gZnVuY3Rpb24odGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuXHRcdFx0X3RpY2tlci5sYWdTbW9vdGhpbmcodGhyZXNob2xkLCBhZGp1c3RlZExhZyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5zZWxlY3RvciA9IHdpbmRvdy4kIHx8IHdpbmRvdy5qUXVlcnkgfHwgZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gd2luZG93LiQgfHwgd2luZG93LmpRdWVyeTtcblx0XHRcdGlmIChzZWxlY3Rvcikge1xuXHRcdFx0XHRUd2VlbkxpdGUuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0cmV0dXJuIHNlbGVjdG9yKGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0eXBlb2YoZG9jdW1lbnQpID09PSBcInVuZGVmaW5lZFwiKSA/IGUgOiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZSkgOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgoZS5jaGFyQXQoMCkgPT09IFwiI1wiKSA/IGUuc3Vic3RyKDEpIDogZSkpO1xuXHRcdH07XG5cblx0XHR2YXIgX2xhenlUd2VlbnMgPSBbXSxcblx0XHRcdF9sYXp5TG9va3VwID0ge30sXG5cdFx0XHRfbnVtYmVyc0V4cCA9IC8oPzooLXwtPXxcXCs9KT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbMC05XS9pZyxcblx0XHRcdC8vX25vbk51bWJlcnNFeHAgPSAvKD86KFtcXC0rXSg/IShcXGR8PSkpKXxbXlxcZFxcLSs9ZV18KGUoPyFbXFwtK11bXFxkXSkpKSsvaWcsXG5cdFx0XHRfc2V0UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdFx0dmFsO1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHR2YWwgPSAhcHQuYmxvYiA/IHB0LmMgKiB2ICsgcHQucyA6IHYgPyB0aGlzLmpvaW4oXCJcIikgOiB0aGlzLnN0YXJ0O1xuXHRcdFx0XHRcdGlmIChwdC5yKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWwgPCBtaW4pIGlmICh2YWwgPiAtbWluKSB7IC8vcHJldmVudHMgaXNzdWVzIHdpdGggY29udmVydGluZyB2ZXJ5IHNtYWxsIG51bWJlcnMgdG8gc3RyaW5ncyBpbiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdFx0dmFsID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFwdC5mKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gdmFsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQuZnApIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0ocHQuZnAsIHZhbCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0odmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8vY29tcGFyZXMgdHdvIHN0cmluZ3MgKHN0YXJ0L2VuZCksIGZpbmRzIHRoZSBudW1iZXJzIHRoYXQgYXJlIGRpZmZlcmVudCBhbmQgc3BpdHMgYmFjayBhbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIHdob2xlIHZhbHVlIGJ1dCB3aXRoIHRoZSBjaGFuZ2luZyB2YWx1ZXMgaXNvbGF0ZWQgYXMgZWxlbWVudHMuIEZvciBleGFtcGxlLCBcInJnYigwLDAsMClcIiBhbmQgXCJyZ2IoMTAwLDUwLDApXCIgd291bGQgYmVjb21lIFtcInJnYihcIiwgMCwgXCIsXCIsIDUwLCBcIiwwKVwiXS4gTm90aWNlIGl0IG1lcmdlcyB0aGUgcGFydHMgdGhhdCBhcmUgaWRlbnRpY2FsIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pLiBUaGUgYXJyYXkgYWxzbyBoYXMgYSBsaW5rZWQgbGlzdCBvZiBQcm9wVHdlZW5zIGF0dGFjaGVkIHN0YXJ0aW5nIHdpdGggX2ZpcnN0UFQgdGhhdCBjb250YWluIHRoZSB0d2VlbmluZyBkYXRhICh0LCBwLCBzLCBjLCBmLCBldGMuKS4gSXQgYWxzbyBzdG9yZXMgdGhlIHN0YXJ0aW5nIHZhbHVlIGFzIGEgXCJzdGFydFwiIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIHJldmVydCB0byBpdCBpZi93aGVuIG5lY2Vzc2FyeSwgbGlrZSB3aGVuIGEgdHdlZW4gcmV3aW5kcyBmdWxseS4gSWYgdGhlIHF1YW50aXR5IG9mIG51bWJlcnMgZGlmZmVycyBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kLCBpdCB3aWxsIGFsd2F5cyBwcmlvcml0aXplIHRoZSBlbmQgdmFsdWUocykuIFRoZSBwdCBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwgLSBpdCdzIGZvciBhIFByb3BUd2VlbiB0aGF0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgbGlua2VkIGxpc3QgYW5kIGlzIHR5cGljYWxseSBmb3IgYWN0dWFsbHkgc2V0dGluZyB0aGUgdmFsdWUgYWZ0ZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBoYXZlIGJlZW4gdXBkYXRlZCAod2l0aCBhcnJheS5qb2luKFwiXCIpKS5cblx0XHRcdF9ibG9iRGlmID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgZmlsdGVyLCBwdCkge1xuXHRcdFx0XHR2YXIgYSA9IFtzdGFydCwgZW5kXSxcblx0XHRcdFx0XHRjaGFySW5kZXggPSAwLFxuXHRcdFx0XHRcdHMgPSBcIlwiLFxuXHRcdFx0XHRcdGNvbG9yID0gMCxcblx0XHRcdFx0XHRzdGFydE51bXMsIGVuZE51bXMsIG51bSwgaSwgbCwgbm9uTnVtYmVycywgY3VycmVudE51bTtcblx0XHRcdFx0YS5zdGFydCA9IHN0YXJ0O1xuXHRcdFx0XHRpZiAoZmlsdGVyKSB7XG5cdFx0XHRcdFx0ZmlsdGVyKGEpOyAvL3Bhc3MgYW4gYXJyYXkgd2l0aCB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgYW5kIGxldCB0aGUgZmlsdGVyIGRvIHdoYXRldmVyIGl0IG5lZWRzIHRvIHRoZSB2YWx1ZXMuXG5cdFx0XHRcdFx0c3RhcnQgPSBhWzBdO1xuXHRcdFx0XHRcdGVuZCA9IGFbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5sZW5ndGggPSAwO1xuXHRcdFx0XHRzdGFydE51bXMgPSBzdGFydC5tYXRjaChfbnVtYmVyc0V4cCkgfHwgW107XG5cdFx0XHRcdGVuZE51bXMgPSBlbmQubWF0Y2goX251bWJlcnNFeHApIHx8IFtdO1xuXHRcdFx0XHRpZiAocHQpIHtcblx0XHRcdFx0XHRwdC5fbmV4dCA9IG51bGw7XG5cdFx0XHRcdFx0cHQuYmxvYiA9IDE7XG5cdFx0XHRcdFx0YS5fZmlyc3RQVCA9IHB0OyAvL2FwcGx5IGxhc3QgaW4gdGhlIGxpbmtlZCBsaXN0ICh3aGljaCBtZWFucyBpbnNlcnRpbmcgaXQgZmlyc3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0bCA9IGVuZE51bXMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y3VycmVudE51bSA9IGVuZE51bXNbaV07XG5cdFx0XHRcdFx0bm9uTnVtYmVycyA9IGVuZC5zdWJzdHIoY2hhckluZGV4LCBlbmQuaW5kZXhPZihjdXJyZW50TnVtLCBjaGFySW5kZXgpLWNoYXJJbmRleCk7XG5cdFx0XHRcdFx0cyArPSAobm9uTnVtYmVycyB8fCAhaSkgPyBub25OdW1iZXJzIDogXCIsXCI7IC8vbm90ZTogU1ZHIHNwZWMgYWxsb3dzIG9taXNzaW9uIG9mIGNvbW1hL3NwYWNlIHdoZW4gYSBuZWdhdGl2ZSBzaWduIGlzIHdlZGdlZCBiZXR3ZWVuIHR3byBudW1iZXJzLCBsaWtlIDIuNS01LjMgaW5zdGVhZCBvZiAyLjUsLTUuMyBidXQgd2hlbiB0d2VlbmluZywgdGhlIG5lZ2F0aXZlIHZhbHVlIG1heSBzd2l0Y2ggdG8gcG9zaXRpdmUsIHNvIHdlIGluc2VydCB0aGUgY29tbWEganVzdCBpbiBjYXNlLlxuXHRcdFx0XHRcdGNoYXJJbmRleCArPSBub25OdW1iZXJzLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAoY29sb3IpIHsgLy9zZW5zZSByZ2JhKCkgdmFsdWVzIGFuZCByb3VuZCB0aGVtLlxuXHRcdFx0XHRcdFx0Y29sb3IgPSAoY29sb3IgKyAxKSAlIDU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub25OdW1iZXJzLnN1YnN0cigtNSkgPT09IFwicmdiYShcIikge1xuXHRcdFx0XHRcdFx0Y29sb3IgPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY3VycmVudE51bSA9PT0gc3RhcnROdW1zW2ldIHx8IHN0YXJ0TnVtcy5sZW5ndGggPD0gaSkge1xuXHRcdFx0XHRcdFx0cyArPSBjdXJyZW50TnVtO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAocykge1xuXHRcdFx0XHRcdFx0XHRhLnB1c2gocyk7XG5cdFx0XHRcdFx0XHRcdHMgPSBcIlwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bnVtID0gcGFyc2VGbG9hdChzdGFydE51bXNbaV0pO1xuXHRcdFx0XHRcdFx0YS5wdXNoKG51bSk7XG5cdFx0XHRcdFx0XHRhLl9maXJzdFBUID0ge19uZXh0OiBhLl9maXJzdFBULCB0OmEsIHA6IGEubGVuZ3RoLTEsIHM6bnVtLCBjOigoY3VycmVudE51bS5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHBhcnNlSW50KGN1cnJlbnROdW0uY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIHBhcnNlRmxvYXQoY3VycmVudE51bS5zdWJzdHIoMikpIDogKHBhcnNlRmxvYXQoY3VycmVudE51bSkgLSBudW0pKSB8fCAwLCBmOjAsIHI6KGNvbG9yICYmIGNvbG9yIDwgNCl9O1xuXHRcdFx0XHRcdFx0Ly9ub3RlOiB3ZSBkb24ndCBzZXQgX3ByZXYgYmVjYXVzZSB3ZSdsbCBuZXZlciBuZWVkIHRvIHJlbW92ZSBpbmRpdmlkdWFsIFByb3BUd2VlbnMgZnJvbSB0aGlzIGxpc3QuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNoYXJJbmRleCArPSBjdXJyZW50TnVtLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRzICs9IGVuZC5zdWJzdHIoY2hhckluZGV4KTtcblx0XHRcdFx0aWYgKHMpIHtcblx0XHRcdFx0XHRhLnB1c2gocyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5zZXRSYXRpbyA9IF9zZXRSYXRpbztcblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9LFxuXHRcdFx0Ly9ub3RlOiBcImZ1bmNQYXJhbVwiIGlzIG9ubHkgbmVjZXNzYXJ5IGZvciBmdW5jdGlvbi1iYXNlZCBnZXR0ZXJzL3NldHRlcnMgdGhhdCByZXF1aXJlIGFuIGV4dHJhIHBhcmFtZXRlciBsaWtlIGdldEF0dHJpYnV0ZShcIndpZHRoXCIpIGFuZCBzZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB2YWx1ZSkuIEluIHRoaXMgZXhhbXBsZSwgZnVuY1BhcmFtIHdvdWxkIGJlIFwid2lkdGhcIi4gVXNlZCBieSBBdHRyUGx1Z2luIGZvciBleGFtcGxlLlxuXHRcdFx0X2FkZFByb3BUd2VlbiA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgb3ZlcndyaXRlUHJvcCwgcm91bmQsIGZ1bmNQYXJhbSwgc3RyaW5nRmlsdGVyKSB7XG5cdFx0XHRcdHZhciBzID0gKHN0YXJ0ID09PSBcImdldFwiKSA/IHRhcmdldFtwcm9wXSA6IHN0YXJ0LFxuXHRcdFx0XHRcdHR5cGUgPSB0eXBlb2YodGFyZ2V0W3Byb3BdKSxcblx0XHRcdFx0XHRpc1JlbGF0aXZlID0gKHR5cGVvZihlbmQpID09PSBcInN0cmluZ1wiICYmIGVuZC5jaGFyQXQoMSkgPT09IFwiPVwiKSxcblx0XHRcdFx0XHRwdCA9IHt0OnRhcmdldCwgcDpwcm9wLCBzOnMsIGY6KHR5cGUgPT09IFwiZnVuY3Rpb25cIiksIHBnOjAsIG46b3ZlcndyaXRlUHJvcCB8fCBwcm9wLCByOnJvdW5kLCBwcjowLCBjOmlzUmVsYXRpdmUgPyBwYXJzZUludChlbmQuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIHBhcnNlRmxvYXQoZW5kLnN1YnN0cigyKSkgOiAocGFyc2VGbG9hdChlbmQpIC0gcykgfHwgMH0sXG5cdFx0XHRcdFx0YmxvYiwgZ2V0dGVyTmFtZTtcblx0XHRcdFx0aWYgKHR5cGUgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXJ0ID09PSBcImdldFwiKSB7XG5cdFx0XHRcdFx0XHRnZXR0ZXJOYW1lID0gKChwcm9wLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHByb3AgOiBcImdldFwiICsgcHJvcC5zdWJzdHIoMykpO1xuXHRcdFx0XHRcdFx0cHQucyA9IHMgPSBmdW5jUGFyYW0gPyB0YXJnZXRbZ2V0dGVyTmFtZV0oZnVuY1BhcmFtKSA6IHRhcmdldFtnZXR0ZXJOYW1lXSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodHlwZW9mKHMpID09PSBcInN0cmluZ1wiICYmIChmdW5jUGFyYW0gfHwgaXNOYU4ocykpKSB7XG5cdFx0XHRcdFx0XHQvL2EgYmxvYiAoc3RyaW5nIHRoYXQgaGFzIG11bHRpcGxlIG51bWJlcnMgaW4gaXQpXG5cdFx0XHRcdFx0XHRwdC5mcCA9IGZ1bmNQYXJhbTtcblx0XHRcdFx0XHRcdGJsb2IgPSBfYmxvYkRpZihzLCBlbmQsIHN0cmluZ0ZpbHRlciB8fCBUd2VlbkxpdGUuZGVmYXVsdFN0cmluZ0ZpbHRlciwgcHQpO1xuXHRcdFx0XHRcdFx0cHQgPSB7dDpibG9iLCBwOlwic2V0UmF0aW9cIiwgczowLCBjOjEsIGY6MiwgcGc6MCwgbjpvdmVyd3JpdGVQcm9wIHx8IHByb3AsIHByOjB9OyAvL1wiMlwiIGluZGljYXRlcyBpdCdzIGEgQmxvYiBwcm9wZXJ0eSB0d2Vlbi4gTmVlZGVkIGZvciBSb3VuZFByb3BzUGx1Z2luIGZvciBleGFtcGxlLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWlzUmVsYXRpdmUpIHtcblx0XHRcdFx0XHRcdHB0LnMgPSBwYXJzZUZsb2F0KHMpO1xuXHRcdFx0XHRcdFx0cHQuYyA9IChwYXJzZUZsb2F0KGVuZCkgLSBwdC5zKSB8fCAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuYykgeyAvL29ubHkgYWRkIGl0IHRvIHRoZSBsaW5rZWQgbGlzdCBpZiB0aGVyZSdzIGEgY2hhbmdlLlxuXHRcdFx0XHRcdGlmICgocHQuX25leHQgPSB0aGlzLl9maXJzdFBUKSkge1xuXHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0O1xuXHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9pbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyA9IHtpc0FycmF5Ol9pc0FycmF5LCBpc1NlbGVjdG9yOl9pc1NlbGVjdG9yLCBsYXp5VHdlZW5zOl9sYXp5VHdlZW5zLCBibG9iRGlmOl9ibG9iRGlmfSwgLy9naXZlcyB1cyBhIHdheSB0byBleHBvc2UgY2VydGFpbiBwcml2YXRlIHZhbHVlcyB0byBvdGhlciBHcmVlblNvY2sgY2xhc3NlcyB3aXRob3V0IGNvbnRhbWluYXRpbmcgdGhhIG1haW4gVHdlZW5MaXRlIG9iamVjdC5cblx0XHRcdF9wbHVnaW5zID0gVHdlZW5MaXRlLl9wbHVnaW5zID0ge30sXG5cdFx0XHRfdHdlZW5Mb29rdXAgPSBfaW50ZXJuYWxzLnR3ZWVuTG9va3VwID0ge30sXG5cdFx0XHRfdHdlZW5Mb29rdXBOdW0gPSAwLFxuXHRcdFx0X3Jlc2VydmVkUHJvcHMgPSBfaW50ZXJuYWxzLnJlc2VydmVkUHJvcHMgPSB7ZWFzZToxLCBkZWxheToxLCBvdmVyd3JpdGU6MSwgb25Db21wbGV0ZToxLCBvbkNvbXBsZXRlUGFyYW1zOjEsIG9uQ29tcGxldGVTY29wZToxLCB1c2VGcmFtZXM6MSwgcnVuQmFja3dhcmRzOjEsIHN0YXJ0QXQ6MSwgb25VcGRhdGU6MSwgb25VcGRhdGVQYXJhbXM6MSwgb25VcGRhdGVTY29wZToxLCBvblN0YXJ0OjEsIG9uU3RhcnRQYXJhbXM6MSwgb25TdGFydFNjb3BlOjEsIG9uUmV2ZXJzZUNvbXBsZXRlOjEsIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOjEsIG9uUmV2ZXJzZUNvbXBsZXRlU2NvcGU6MSwgb25SZXBlYXQ6MSwgb25SZXBlYXRQYXJhbXM6MSwgb25SZXBlYXRTY29wZToxLCBlYXNlUGFyYW1zOjEsIHlveW86MSwgaW1tZWRpYXRlUmVuZGVyOjEsIHJlcGVhdDoxLCByZXBlYXREZWxheToxLCBkYXRhOjEsIHBhdXNlZDoxLCByZXZlcnNlZDoxLCBhdXRvQ1NTOjEsIGxhenk6MSwgb25PdmVyd3JpdGU6MSwgY2FsbGJhY2tTY29wZToxLCBzdHJpbmdGaWx0ZXI6MX0sXG5cdFx0XHRfb3ZlcndyaXRlTG9va3VwID0ge25vbmU6MCwgYWxsOjEsIGF1dG86MiwgY29uY3VycmVudDozLCBhbGxPblN0YXJ0OjQsIHByZWV4aXN0aW5nOjUsIFwidHJ1ZVwiOjEsIFwiZmFsc2VcIjowfSxcblx0XHRcdF9yb290RnJhbWVzVGltZWxpbmUgPSBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpLFxuXHRcdFx0X3Jvb3RUaW1lbGluZSA9IEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lID0gbmV3IFNpbXBsZVRpbWVsaW5lKCksXG5cdFx0XHRfbmV4dEdDRnJhbWUgPSAzMCxcblx0XHRcdF9sYXp5UmVuZGVyID0gX2ludGVybmFscy5sYXp5UmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuXHRcdFx0XHRcdHR3ZWVuO1xuXHRcdFx0XHRfbGF6eUxvb2t1cCA9IHt9O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0d2VlbiA9IF9sYXp5VHdlZW5zW2ldO1xuXHRcdFx0XHRcdGlmICh0d2VlbiAmJiB0d2Vlbi5fbGF6eSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcih0d2Vlbi5fbGF6eVswXSwgdHdlZW4uX2xhenlbMV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0dHdlZW4uX2xhenkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0X2xhenlUd2VlbnMubGVuZ3RoID0gMDtcblx0XHRcdH07XG5cblx0XHRfcm9vdFRpbWVsaW5lLl9zdGFydFRpbWUgPSBfdGlja2VyLnRpbWU7XG5cdFx0X3Jvb3RGcmFtZXNUaW1lbGluZS5fc3RhcnRUaW1lID0gX3RpY2tlci5mcmFtZTtcblx0XHRfcm9vdFRpbWVsaW5lLl9hY3RpdmUgPSBfcm9vdEZyYW1lc1RpbWVsaW5lLl9hY3RpdmUgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoX2xhenlSZW5kZXIsIDEpOyAvL29uIHNvbWUgbW9iaWxlIGRldmljZXMsIHRoZXJlIGlzbid0IGEgXCJ0aWNrXCIgYmVmb3JlIGNvZGUgcnVucyB3aGljaCBtZWFucyBhbnkgbGF6eSByZW5kZXJzIHdvdWxkbid0IHJ1biBiZWZvcmUgdGhlIG5leHQgb2ZmaWNpYWwgXCJ0aWNrXCIuXG5cblx0XHRBbmltYXRpb24uX3VwZGF0ZVJvb3QgPSBUd2VlbkxpdGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpLCBhLCBwO1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaWYgY29kZSBpcyBydW4gb3V0c2lkZSBvZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3AsIHRoZXJlIG1heSBiZSB0d2VlbnMgcXVldWVkIEFGVEVSIHRoZSBlbmdpbmUgcmVmcmVzaGVkLCBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBhbnkgcGVuZGluZyByZW5kZXJzIG9jY3VyIGJlZm9yZSB3ZSByZWZyZXNoIGFnYWluLlxuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3Jvb3RUaW1lbGluZS5yZW5kZXIoKF90aWNrZXIudGltZSAtIF9yb290VGltZWxpbmUuX3N0YXJ0VGltZSkgKiBfcm9vdFRpbWVsaW5lLl90aW1lU2NhbGUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdF9yb290RnJhbWVzVGltZWxpbmUucmVuZGVyKChfdGlja2VyLmZyYW1lIC0gX3Jvb3RGcmFtZXNUaW1lbGluZS5fc3RhcnRUaW1lKSAqIF9yb290RnJhbWVzVGltZWxpbmUuX3RpbWVTY2FsZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkge1xuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7IC8vZHVtcCBnYXJiYWdlIGV2ZXJ5IDEyMCBmcmFtZXMgb3Igd2hhdGV2ZXIgdGhlIHVzZXIgc2V0cyBUd2VlbkxpdGUuYXV0b1NsZWVwIHRvXG5cdFx0XHRcdFx0X25leHRHQ0ZyYW1lID0gX3RpY2tlci5mcmFtZSArIChwYXJzZUludChUd2VlbkxpdGUuYXV0b1NsZWVwLCAxMCkgfHwgMTIwKTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gX3R3ZWVuTG9va3VwKSB7XG5cdFx0XHRcdFx0XHRhID0gX3R3ZWVuTG9va3VwW3BdLnR3ZWVucztcblx0XHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYVtpXS5fZ2MpIHtcblx0XHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGEubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBfdHdlZW5Mb29rdXBbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vaWYgdGhlcmUgYXJlIG5vIG1vcmUgdHdlZW5zIGluIHRoZSByb290IHRpbWVsaW5lcywgb3IgaWYgdGhleSdyZSBhbGwgcGF1c2VkLCBtYWtlIHRoZSBfdGltZXIgc2xlZXAgdG8gcmVkdWNlIGxvYWQgb24gdGhlIENQVSBzbGlnaHRseVxuXHRcdFx0XHRcdHAgPSBfcm9vdFRpbWVsaW5lLl9maXJzdDtcblx0XHRcdFx0XHRpZiAoIXAgfHwgcC5fcGF1c2VkKSBpZiAoVHdlZW5MaXRlLmF1dG9TbGVlcCAmJiAhX3Jvb3RGcmFtZXNUaW1lbGluZS5fZmlyc3QgJiYgX3RpY2tlci5fbGlzdGVuZXJzLnRpY2subGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAocCAmJiBwLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHAuX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXApIHtcblx0XHRcdFx0XHRcdFx0X3RpY2tlci5zbGVlcCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdF90aWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgQW5pbWF0aW9uLl91cGRhdGVSb290KTtcblxuXHRcdHZhciBfcmVnaXN0ZXIgPSBmdW5jdGlvbih0YXJnZXQsIHR3ZWVuLCBzY3J1Yikge1xuXHRcdFx0XHR2YXIgaWQgPSB0YXJnZXQuX2dzVHdlZW5JRCwgYSwgaTtcblx0XHRcdFx0aWYgKCFfdHdlZW5Mb29rdXBbaWQgfHwgKHRhcmdldC5fZ3NUd2VlbklEID0gaWQgPSBcInRcIiArIChfdHdlZW5Mb29rdXBOdW0rKykpXSkge1xuXHRcdFx0XHRcdF90d2Vlbkxvb2t1cFtpZF0gPSB7dGFyZ2V0OnRhcmdldCwgdHdlZW5zOltdfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHdlZW4pIHtcblx0XHRcdFx0XHRhID0gX3R3ZWVuTG9va3VwW2lkXS50d2VlbnM7XG5cdFx0XHRcdFx0YVsoaSA9IGEubGVuZ3RoKV0gPSB0d2Vlbjtcblx0XHRcdFx0XHRpZiAoc2NydWIpIHtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYVtpXSA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gX3R3ZWVuTG9va3VwW2lkXS50d2VlbnM7XG5cdFx0XHR9LFxuXHRcdFx0X29uT3ZlcndyaXRlID0gZnVuY3Rpb24ob3ZlcndyaXR0ZW5Ud2Vlbiwgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWRQcm9wcykge1xuXHRcdFx0XHR2YXIgZnVuYyA9IG92ZXJ3cml0dGVuVHdlZW4udmFycy5vbk92ZXJ3cml0ZSwgcjEsIHIyO1xuXHRcdFx0XHRpZiAoZnVuYykge1xuXHRcdFx0XHRcdHIxID0gZnVuYyhvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jID0gVHdlZW5MaXRlLm9uT3ZlcndyaXRlO1xuXHRcdFx0XHRpZiAoZnVuYykge1xuXHRcdFx0XHRcdHIyID0gZnVuYyhvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKHIxICE9PSBmYWxzZSAmJiByMiAhPT0gZmFsc2UpO1xuXHRcdFx0fSxcblx0XHRcdF9hcHBseU92ZXJ3cml0ZSA9IGZ1bmN0aW9uKHRhcmdldCwgdHdlZW4sIHByb3BzLCBtb2RlLCBzaWJsaW5ncykge1xuXHRcdFx0XHR2YXIgaSwgY2hhbmdlZCwgY3VyVHdlZW4sIGw7XG5cdFx0XHRcdGlmIChtb2RlID09PSAxIHx8IG1vZGUgPj0gNCkge1xuXHRcdFx0XHRcdGwgPSBzaWJsaW5ncy5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKChjdXJUd2VlbiA9IHNpYmxpbmdzW2ldKSAhPT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFjdXJUd2Vlbi5fZ2MpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY3VyVHdlZW4uX2tpbGwobnVsbCwgdGFyZ2V0LCB0d2VlbikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChtb2RlID09PSA1KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL05PVEU6IEFkZCAwLjAwMDAwMDAwMDEgdG8gb3ZlcmNvbWUgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHRoYXQgY2FuIGNhdXNlIHRoZSBzdGFydFRpbWUgdG8gYmUgVkVSWSBzbGlnaHRseSBvZmYgKHdoZW4gYSB0d2VlbidzIHRpbWUoKSBpcyBzZXQgZm9yIGV4YW1wbGUpXG5cdFx0XHRcdHZhciBzdGFydFRpbWUgPSB0d2Vlbi5fc3RhcnRUaW1lICsgX3RpbnlOdW0sXG5cdFx0XHRcdFx0b3ZlcmxhcHMgPSBbXSxcblx0XHRcdFx0XHRvQ291bnQgPSAwLFxuXHRcdFx0XHRcdHplcm9EdXIgPSAodHdlZW4uX2R1cmF0aW9uID09PSAwKSxcblx0XHRcdFx0XHRnbG9iYWxTdGFydDtcblx0XHRcdFx0aSA9IHNpYmxpbmdzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKChjdXJUd2VlbiA9IHNpYmxpbmdzW2ldKSA9PT0gdHdlZW4gfHwgY3VyVHdlZW4uX2djIHx8IGN1clR3ZWVuLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdC8vaWdub3JlXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjdXJUd2Vlbi5fdGltZWxpbmUgIT09IHR3ZWVuLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0Z2xvYmFsU3RhcnQgPSBnbG9iYWxTdGFydCB8fCBfY2hlY2tPdmVybGFwKHR3ZWVuLCAwLCB6ZXJvRHVyKTtcblx0XHRcdFx0XHRcdGlmIChfY2hlY2tPdmVybGFwKGN1clR3ZWVuLCBnbG9iYWxTdGFydCwgemVyb0R1cikgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmxhcHNbb0NvdW50KytdID0gY3VyVHdlZW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjdXJUd2Vlbi5fc3RhcnRUaW1lIDw9IHN0YXJ0VGltZSkgaWYgKGN1clR3ZWVuLl9zdGFydFRpbWUgKyBjdXJUd2Vlbi50b3RhbER1cmF0aW9uKCkgLyBjdXJUd2Vlbi5fdGltZVNjYWxlID4gc3RhcnRUaW1lKSBpZiAoISgoemVyb0R1ciB8fCAhY3VyVHdlZW4uX2luaXR0ZWQpICYmIHN0YXJ0VGltZSAtIGN1clR3ZWVuLl9zdGFydFRpbWUgPD0gMC4wMDAwMDAwMDAyKSkge1xuXHRcdFx0XHRcdFx0b3ZlcmxhcHNbb0NvdW50KytdID0gY3VyVHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSA9IG9Db3VudDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0Y3VyVHdlZW4gPSBvdmVybGFwc1tpXTtcblx0XHRcdFx0XHRpZiAobW9kZSA9PT0gMikgaWYgKGN1clR3ZWVuLl9raWxsKHByb3BzLCB0YXJnZXQsIHR3ZWVuKSkge1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtb2RlICE9PSAyIHx8ICghY3VyVHdlZW4uX2ZpcnN0UFQgJiYgY3VyVHdlZW4uX2luaXR0ZWQpKSB7XG5cdFx0XHRcdFx0XHRpZiAobW9kZSAhPT0gMiAmJiAhX29uT3ZlcndyaXRlKGN1clR3ZWVuLCB0d2VlbikpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoY3VyVHdlZW4uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKSkgeyAvL2lmIGFsbCBwcm9wZXJ0eSB0d2VlbnMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuLCBraWxsIHRoZSB0d2Vlbi5cblx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdFx0fSxcblx0XHRcdF9jaGVja092ZXJsYXAgPSBmdW5jdGlvbih0d2VlbiwgcmVmZXJlbmNlLCB6ZXJvRHVyKSB7XG5cdFx0XHRcdHZhciB0bCA9IHR3ZWVuLl90aW1lbGluZSxcblx0XHRcdFx0XHR0cyA9IHRsLl90aW1lU2NhbGUsXG5cdFx0XHRcdFx0dCA9IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHR0ICs9IHRsLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0dHMgKj0gdGwuX3RpbWVTY2FsZTtcblx0XHRcdFx0XHRpZiAodGwuX3BhdXNlZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIC0xMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHQgLz0gdHM7XG5cdFx0XHRcdHJldHVybiAodCA+IHJlZmVyZW5jZSkgPyB0IC0gcmVmZXJlbmNlIDogKCh6ZXJvRHVyICYmIHQgPT09IHJlZmVyZW5jZSkgfHwgKCF0d2Vlbi5faW5pdHRlZCAmJiB0IC0gcmVmZXJlbmNlIDwgMiAqIF90aW55TnVtKSkgPyBfdGlueU51bSA6ICgodCArPSB0d2Vlbi50b3RhbER1cmF0aW9uKCkgLyB0d2Vlbi5fdGltZVNjYWxlIC8gdHMpID4gcmVmZXJlbmNlICsgX3RpbnlOdW0pID8gMCA6IHQgLSByZWZlcmVuY2UgLSBfdGlueU51bTtcblx0XHRcdH07XG5cblxuLy8tLS0tIFR3ZWVuTGl0ZSBpbnN0YW5jZSBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLl9pbml0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdiA9IHRoaXMudmFycyxcblx0XHRcdFx0b3AgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzLFxuXHRcdFx0XHRkdXIgPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0aW1tZWRpYXRlID0gISF2LmltbWVkaWF0ZVJlbmRlcixcblx0XHRcdFx0ZWFzZSA9IHYuZWFzZSxcblx0XHRcdFx0aSwgaW5pdFBsdWdpbnMsIHB0LCBwLCBzdGFydFZhcnM7XG5cdFx0XHRpZiAodi5zdGFydEF0KSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zdGFydEF0KSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpOyAvL2lmIHdlJ3ZlIHJ1biBhIHN0YXJ0QXQgcHJldmlvdXNseSAod2hlbiB0aGUgdHdlZW4gaW5zdGFudGlhdGVkKSwgd2Ugc2hvdWxkIHJldmVydCBpdCBzbyB0aGF0IHRoZSB2YWx1ZXMgcmUtaW5zdGFudGlhdGUgY29ycmVjdGx5IHBhcnRpY3VsYXJseSBmb3IgcmVsYXRpdmUgdHdlZW5zLiBXaXRob3V0IHRoaXMsIGEgVHdlZW5MaXRlLmZyb21UbyhvYmosIDEsIHt4OlwiKz0xMDBcIn0sIHt4OlwiLT0xMDBcIn0pLCBmb3IgZXhhbXBsZSwgd291bGQgYWN0dWFsbHkganVtcCB0byArPTIwMCBiZWNhdXNlIHRoZSBzdGFydEF0IHdvdWxkIHJ1biB0d2ljZSwgZG91YmxpbmcgdGhlIHJlbGF0aXZlIGNoYW5nZS5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LmtpbGwoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydFZhcnMgPSB7fTtcblx0XHRcdFx0Zm9yIChwIGluIHYuc3RhcnRBdCkgeyAvL2NvcHkgdGhlIHByb3BlcnRpZXMvdmFsdWVzIGludG8gYSBuZXcgb2JqZWN0IHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgdmFyIHRvID0ge3g6MH0sIGZyb20gPSB7eDo1MDB9OyB0aW1lbGluZS5mcm9tVG8oZSwgMSwgZnJvbSwgdG8pLmZyb21UbyhlLCAxLCB0bywgZnJvbSk7XG5cdFx0XHRcdFx0c3RhcnRWYXJzW3BdID0gdi5zdGFydEF0W3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0VmFycy5vdmVyd3JpdGUgPSBmYWxzZTtcblx0XHRcdFx0c3RhcnRWYXJzLmltbWVkaWF0ZVJlbmRlciA9IHRydWU7XG5cdFx0XHRcdHN0YXJ0VmFycy5sYXp5ID0gKGltbWVkaWF0ZSAmJiB2LmxhenkgIT09IGZhbHNlKTtcblx0XHRcdFx0c3RhcnRWYXJzLnN0YXJ0QXQgPSBzdGFydFZhcnMuZGVsYXkgPSBudWxsOyAvL25vIG5lc3Rpbmcgb2Ygc3RhcnRBdCBvYmplY3RzIGFsbG93ZWQgKG90aGVyd2lzZSBpdCBjb3VsZCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wKS5cblx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IFR3ZWVuTGl0ZS50byh0aGlzLnRhcmdldCwgMCwgc3RhcnRWYXJzKTtcblx0XHRcdFx0aWYgKGltbWVkaWF0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lTGl0ZS9NYXggaW5zdGFuY2VzIHdoZXJlIGltbWVkaWF0ZVJlbmRlciB3YXMgZmFsc2UgKHdoaWNoIGlzIHRoZSBkZWZhdWx0IGluIHRoZSBjb252ZW5pZW5jZSBtZXRob2RzIGxpa2UgZnJvbSgpKS5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGR1ciAhPT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lTGl0ZSBvciBUaW1lbGluZU1heCwgdGhlIGxhc3Qgb25lIGNyZWF0ZWQgd291bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmVzIGJlY2F1c2UgdGhleSBkaWRuJ3QgZ2V0IHBsYWNlZCBpbnRvIHRoZSB0aW1lbGluZSB5ZXQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIgb2NjdXJzIGFuZCBraWNrcyBpbiBvdmVyd3JpdGluZy5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodi5ydW5CYWNrd2FyZHMgJiYgZHVyICE9PSAwKSB7XG5cdFx0XHRcdC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5raWxsKCk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgIT09IDApIHsgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcblx0XHRcdFx0XHRcdGltbWVkaWF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHt9O1xuXHRcdFx0XHRcdGZvciAocCBpbiB2KSB7IC8vY29weSBwcm9wcyBpbnRvIGEgbmV3IG9iamVjdCBhbmQgc2tpcCBhbnkgcmVzZXJ2ZWQgcHJvcHMsIG90aGVyd2lzZSBvbkNvbXBsZXRlIG9yIG9uVXBkYXRlIG9yIG9uU3RhcnQgY291bGQgZmlyZS4gV2Ugc2hvdWxkLCBob3dldmVyLCBwZXJtaXQgYXV0b0NTUyB0byBnbyB0aHJvdWdoLlxuXHRcdFx0XHRcdFx0aWYgKCFfcmVzZXJ2ZWRQcm9wc1twXSB8fCBwID09PSBcImF1dG9DU1NcIikge1xuXHRcdFx0XHRcdFx0XHRwdFtwXSA9IHZbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0Lm92ZXJ3cml0ZSA9IDA7XG5cdFx0XHRcdFx0cHQuZGF0YSA9IFwiaXNGcm9tU3RhcnRcIjsgLy93ZSB0YWcgdGhlIHR3ZWVuIHdpdGggYXMgXCJpc0Zyb21TdGFydFwiIHNvIHRoYXQgaWYgW2luc2lkZSBhIHBsdWdpbl0gd2UgbmVlZCB0byBvbmx5IGRvIHNvbWV0aGluZyBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2Vlbiwgd2UgaGF2ZSBhIHdheSBvZiBpZGVudGlmeWluZyB0aGlzIHR3ZWVuIGFzIG1lcmVseSB0aGUgb25lIHRoYXQncyBzZXR0aW5nIHRoZSBiZWdpbm5pbmcgdmFsdWVzIGZvciBhIFwiZnJvbSgpXCIgdHdlZW4uIEZvciBleGFtcGxlLCBjbGVhclByb3BzIGluIENTU1BsdWdpbiBzaG91bGQgb25seSBnZXQgYXBwbGllZCBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2VlbiBhbmQgd2l0aG91dCB0aGlzIHRhZywgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4uXG5cdFx0XHRcdFx0cHQubGF6eSA9IChpbW1lZGlhdGUgJiYgdi5sYXp5ICE9PSBmYWxzZSk7XG5cdFx0XHRcdFx0cHQuaW1tZWRpYXRlUmVuZGVyID0gaW1tZWRpYXRlOyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIHJlbmRlciBpbW1lZGlhdGVseSBieSBkZWZhdWx0LCBidXQgaWYgd2UncmUgbm90IHNwZWNpZmljYWxseSBpbnN0cnVjdGVkIHRvIHJlbmRlciB0aGlzIHR3ZWVuIGltbWVkaWF0ZWx5LCB3ZSBzaG91bGQgc2tpcCB0aGlzIGFuZCBtZXJlbHkgX2luaXQoKSB0byByZWNvcmQgdGhlIHN0YXJ0aW5nIHZhbHVlcyAocmVuZGVyaW5nIHRoZW0gaW1tZWRpYXRlbHkgd291bGQgcHVzaCB0aGVtIHRvIGNvbXBsZXRpb24gd2hpY2ggaXMgd2FzdGVmdWwgaW4gdGhhdCBjYXNlIC0gd2UnZCBoYXZlIHRvIHJlbmRlcigtMSkgaW1tZWRpYXRlbHkgYWZ0ZXIpXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IFR3ZWVuTGl0ZS50byh0aGlzLnRhcmdldCwgMCwgcHQpO1xuXHRcdFx0XHRcdGlmICghaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0Ll9pbml0KCk7IC8vZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIHZhbHVlcyBhcmUgcmVjb3JkZWRcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQuX2VuYWJsZWQoZmFsc2UpOyAvL25vIG5lZWQgdG8gaGF2ZSB0aGUgdHdlZW4gcmVuZGVyIG9uIHRoZSBuZXh0IGN5Y2xlLiBEaXNhYmxlIGl0IGJlY2F1c2Ugd2UnbGwgYWx3YXlzIG1hbnVhbGx5IGNvbnRyb2wgdGhlIHJlbmRlcnMgb2YgdGhlIF9zdGFydEF0IHR3ZWVuLlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9lYXNlID0gZWFzZSA9ICghZWFzZSkgPyBUd2VlbkxpdGUuZGVmYXVsdEVhc2UgOiAoZWFzZSBpbnN0YW5jZW9mIEVhc2UpID8gZWFzZSA6ICh0eXBlb2YoZWFzZSkgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgRWFzZShlYXNlLCB2LmVhc2VQYXJhbXMpIDogX2Vhc2VNYXBbZWFzZV0gfHwgVHdlZW5MaXRlLmRlZmF1bHRFYXNlO1xuXHRcdFx0aWYgKHYuZWFzZVBhcmFtcyBpbnN0YW5jZW9mIEFycmF5ICYmIGVhc2UuY29uZmlnKSB7XG5cdFx0XHRcdHRoaXMuX2Vhc2UgPSBlYXNlLmNvbmZpZy5hcHBseShlYXNlLCB2LmVhc2VQYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZWFzZVR5cGUgPSB0aGlzLl9lYXNlLl90eXBlO1xuXHRcdFx0dGhpcy5fZWFzZVBvd2VyID0gdGhpcy5fZWFzZS5fcG93ZXI7XG5cdFx0XHR0aGlzLl9maXJzdFBUID0gbnVsbDtcblxuXHRcdFx0aWYgKHRoaXMuX3RhcmdldHMpIHtcblx0XHRcdFx0aSA9IHRoaXMuX3RhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMuX2luaXRQcm9wcyggdGhpcy5fdGFyZ2V0c1tpXSwgKHRoaXMuX3Byb3BMb29rdXBbaV0gPSB7fSksIHRoaXMuX3NpYmxpbmdzW2ldLCAob3AgPyBvcFtpXSA6IG51bGwpKSApIHtcblx0XHRcdFx0XHRcdGluaXRQbHVnaW5zID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluaXRQbHVnaW5zID0gdGhpcy5faW5pdFByb3BzKHRoaXMudGFyZ2V0LCB0aGlzLl9wcm9wTG9va3VwLCB0aGlzLl9zaWJsaW5ncywgb3ApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaW5pdFBsdWdpbnMpIHtcblx0XHRcdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KFwiX29uSW5pdEFsbFByb3BzXCIsIHRoaXMpOyAvL3Jlb3JkZXJzIHRoZSBhcnJheSBpbiBvcmRlciBvZiBwcmlvcml0eS4gVXNlcyBhIHN0YXRpYyBUd2VlblBsdWdpbiBtZXRob2QgaW4gb3JkZXIgdG8gbWluaW1pemUgZmlsZSBzaXplIGluIFR3ZWVuTGl0ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9wKSBpZiAoIXRoaXMuX2ZpcnN0UFQpIGlmICh0eXBlb2YodGhpcy50YXJnZXQpICE9PSBcImZ1bmN0aW9uXCIpIHsgLy9pZiBhbGwgdHdlZW5pbmcgcHJvcGVydGllcyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4sIGtpbGwgdGhlIHR3ZWVuLiBJZiB0aGUgdGFyZ2V0IGlzIGEgZnVuY3Rpb24sIGl0J3MgcHJvYmFibHkgYSBkZWxheWVkQ2FsbCBzbyBsZXQgaXQgbGl2ZS5cblx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHYucnVuQmFja3dhcmRzKSB7XG5cdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0cHQucyArPSBwdC5jO1xuXHRcdFx0XHRcdHB0LmMgPSAtcHQuYztcblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9vblVwZGF0ZSA9IHYub25VcGRhdGU7XG5cdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0cC5faW5pdFByb3BzID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wTG9va3VwLCBzaWJsaW5ncywgb3ZlcndyaXR0ZW5Qcm9wcykge1xuXHRcdFx0dmFyIHAsIGksIGluaXRQbHVnaW5zLCBwbHVnaW4sIHB0LCB2O1xuXHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKF9sYXp5TG9va3VwW3RhcmdldC5fZ3NUd2VlbklEXSkge1xuXHRcdFx0XHRfbGF6eVJlbmRlcigpOyAvL2lmIG90aGVyIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQgaGF2ZSByZWNlbnRseSBpbml0dGVkIGJ1dCBoYXZlbid0IHJlbmRlcmVkIHlldCwgd2UndmUgZ290IHRvIGZvcmNlIHRoZSByZW5kZXIgc28gdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWVzIGFyZSBjb3JyZWN0IChpbWFnaW5lIHBvcHVsYXRpbmcgYSB0aW1lbGluZSB3aXRoIGEgYnVuY2ggb2Ygc2VxdWVudGlhbCB0d2VlbnMgYW5kIHRoZW4ganVtcGluZyB0byB0aGUgZW5kKVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMudmFycy5jc3MpIGlmICh0YXJnZXQuc3R5bGUpIGlmICh0YXJnZXQgIT09IHdpbmRvdyAmJiB0YXJnZXQubm9kZVR5cGUpIGlmIChfcGx1Z2lucy5jc3MpIGlmICh0aGlzLnZhcnMuYXV0b0NTUyAhPT0gZmFsc2UpIHsgLy9pdCdzIHNvIGNvbW1vbiB0byB1c2UgVHdlZW5MaXRlL01heCB0byBhbmltYXRlIHRoZSBjc3Mgb2YgRE9NIGVsZW1lbnRzLCB3ZSBhc3N1bWUgdGhhdCBpZiB0aGUgdGFyZ2V0IGlzIGEgRE9NIGVsZW1lbnQsIHRoYXQncyB3aGF0IGlzIGludGVuZGVkIChhIGNvbnZlbmllbmNlIHNvIHRoYXQgdXNlcnMgZG9uJ3QgaGF2ZSB0byB3cmFwIHRoaW5ncyBpbiBjc3M6e30sIGFsdGhvdWdoIHdlIHN0aWxsIHJlY29tbWVuZCBpdCBmb3IgYSBzbGlnaHQgcGVyZm9ybWFuY2UgYm9vc3QgYW5kIGJldHRlciBzcGVjaWZpY2l0eSkuIE5vdGU6IHdlIGNhbm5vdCBjaGVjayBcIm5vZGVUeXBlXCIgb24gdGhlIHdpbmRvdyBpbnNpZGUgYW4gaWZyYW1lLlxuXHRcdFx0XHRfYXV0b0NTUyh0aGlzLnZhcnMsIHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHAgaW4gdGhpcy52YXJzKSB7XG5cdFx0XHRcdHYgPSB0aGlzLnZhcnNbcF07XG5cdFx0XHRcdGlmIChfcmVzZXJ2ZWRQcm9wc1twXSkge1xuXHRcdFx0XHRcdGlmICh2KSBpZiAoKHYgaW5zdGFuY2VvZiBBcnJheSkgfHwgKHYucHVzaCAmJiBfaXNBcnJheSh2KSkpIGlmICh2LmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHRoaXMudmFyc1twXSA9IHYgPSB0aGlzLl9zd2FwU2VsZkluUGFyYW1zKHYsIHRoaXMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKF9wbHVnaW5zW3BdICYmIChwbHVnaW4gPSBuZXcgX3BsdWdpbnNbcF0oKSkuX29uSW5pdFR3ZWVuKHRhcmdldCwgdGhpcy52YXJzW3BdLCB0aGlzKSkge1xuXG5cdFx0XHRcdFx0Ly90IC0gdGFyZ2V0IFx0XHRbb2JqZWN0XVxuXHRcdFx0XHRcdC8vcCAtIHByb3BlcnR5IFx0XHRbc3RyaW5nXVxuXHRcdFx0XHRcdC8vcyAtIHN0YXJ0XHRcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL2MgLSBjaGFuZ2VcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL2YgLSBpc0Z1bmN0aW9uXHRbYm9vbGVhbl1cblx0XHRcdFx0XHQvL24gLSBuYW1lXHRcdFx0W3N0cmluZ11cblx0XHRcdFx0XHQvL3BnIC0gaXNQbHVnaW4gXHRbYm9vbGVhbl1cblx0XHRcdFx0XHQvL3ByIC0gcHJpb3JpdHlcdFx0W251bWJlcl1cblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSB7X25leHQ6dGhpcy5fZmlyc3RQVCwgdDpwbHVnaW4sIHA6XCJzZXRSYXRpb1wiLCBzOjAsIGM6MSwgZjoxLCBuOnAsIHBnOjEsIHByOnBsdWdpbi5fcHJpb3JpdHl9O1xuXHRcdFx0XHRcdGkgPSBwbHVnaW4uX292ZXJ3cml0ZVByb3BzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHByb3BMb29rdXBbcGx1Z2luLl9vdmVyd3JpdGVQcm9wc1tpXV0gPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGx1Z2luLl9wcmlvcml0eSB8fCBwbHVnaW4uX29uSW5pdEFsbFByb3BzKSB7XG5cdFx0XHRcdFx0XHRpbml0UGx1Z2lucyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwbHVnaW4uX29uRGlzYWJsZSB8fCBwbHVnaW4uX29uRW5hYmxlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByb3BMb29rdXBbcF0gPSBfYWRkUHJvcFR3ZWVuLmNhbGwodGhpcywgdGFyZ2V0LCBwLCBcImdldFwiLCB2LCBwLCAwLCBudWxsLCB0aGlzLnZhcnMuc3RyaW5nRmlsdGVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3ZlcndyaXR0ZW5Qcm9wcykgaWYgKHRoaXMuX2tpbGwob3ZlcndyaXR0ZW5Qcm9wcywgdGFyZ2V0KSkgeyAvL2Fub3RoZXIgdHdlZW4gbWF5IGhhdmUgdHJpZWQgdG8gb3ZlcndyaXRlIHByb3BlcnRpZXMgb2YgdGhpcyB0d2VlbiBiZWZvcmUgaW5pdCgpIHdhcyBjYWxsZWQgKGxpa2UgaWYgdHdvIHR3ZWVucyBzdGFydCBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgb25lIGNyZWF0ZWQgc2Vjb25kIHdpbGwgcnVuIGZpcnN0KVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5faW5pdFByb3BzKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX292ZXJ3cml0ZSA+IDEpIGlmICh0aGlzLl9maXJzdFBUKSBpZiAoc2libGluZ3MubGVuZ3RoID4gMSkgaWYgKF9hcHBseU92ZXJ3cml0ZSh0YXJnZXQsIHRoaXMsIHByb3BMb29rdXAsIHRoaXMuX292ZXJ3cml0ZSwgc2libGluZ3MpKSB7XG5cdFx0XHRcdHRoaXMuX2tpbGwocHJvcExvb2t1cCwgdGFyZ2V0KTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2luaXRQcm9wcyh0YXJnZXQsIHByb3BMb29rdXAsIHNpYmxpbmdzLCBvdmVyd3JpdHRlblByb3BzKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9maXJzdFBUKSBpZiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpIHsgLy96ZXJvIGR1cmF0aW9uIHR3ZWVucyBkb24ndCBsYXp5IHJlbmRlciBieSBkZWZhdWx0OyBldmVyeXRoaW5nIGVsc2UgZG9lcy5cblx0XHRcdFx0X2xhenlMb29rdXBbdGFyZ2V0Ll9nc1R3ZWVuSURdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbml0UGx1Z2lucztcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdHByZXZSYXdQcmV2VGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lLFxuXHRcdFx0XHRpc0NvbXBsZXRlLCBjYWxsYmFjaywgcHQsIHJhd1ByZXZUaW1lO1xuXHRcdFx0aWYgKHRpbWUgPj0gZHVyYXRpb24gLSAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygxKSA6IDE7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQgKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRmb3JjZSA9IChmb3JjZSB8fCB0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9zdGFydFRpbWUgPT09IHRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbikgeyAvL2lmIGEgemVyby1kdXJhdGlvbiB0d2VlbiBpcyBhdCB0aGUgVkVSWSBlbmQgb2YgYSB0aW1lbGluZSBhbmQgdGhhdCB0aW1lbGluZSByZW5kZXJzIGF0IGl0cyBlbmQsIGl0IHdpbGwgdHlwaWNhbGx5IGFkZCBhIHRpbnkgYml0IG9mIGN1c2hpb24gdG8gdGhlIHJlbmRlciB0aW1lIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzIGZyb20gZ2V0dGluZyBpbiB0aGUgd2F5IG9mIHR3ZWVucyByZW5kZXJpbmcgdGhlaXIgVkVSWSBlbmQuIElmIHdlIHRoZW4gcmV2ZXJzZSgpIHRoYXQgdGltZWxpbmUsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHdpbGwgdHJpZ2dlciBpdHMgb25SZXZlcnNlQ29tcGxldGUgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHkgdGhlIHBsYXloZWFkIGRpZG4ndCBwYXNzIG92ZXIgaXQgYWdhaW4uIEl0J3MgYSB2ZXJ5IHNwZWNpZmljIGVkZ2UgY2FzZSB3ZSBtdXN0IGFjY29tbW9kYXRlLlxuXHRcdFx0XHRcdFx0dGltZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPCAwIHx8ICh0aW1lIDw9IDAgJiYgdGltZSA+PSAtMC4wMDAwMDAxKSB8fCAocHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiB0aGlzLmRhdGEgIT09IFwiaXNQYXVzZVwiKSkgaWYgKHByZXZSYXdQcmV2VGltZSAhPT0gdGltZSkgeyAvL25vdGU6IHdoZW4gdGhpcy5kYXRhIGlzIFwiaXNQYXVzZVwiLCBpdCdzIGEgY2FsbGJhY2sgYWRkZWQgYnkgYWRkUGF1c2UoKSBvbiBhIHRpbWVsaW5lIHRoYXQgd2Ugc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgd2hlbiBMRUFWSU5HIGl0cyBleGFjdCBzdGFydCB0aW1lLiBJbiBvdGhlciB3b3JkcywgdGwuYWRkUGF1c2UoMSkucGxheSgxKSBzaG91bGRuJ3QgcGF1c2UuXG5cdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLCByb3VuZCBzdXBlciBzbWFsbCB2YWx1ZXMgdG8gMC5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygwKSA6IDA7XG5cdFx0XHRcdGlmIChwcmV2VGltZSAhPT0gMCB8fCAoZHVyYXRpb24gPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lID4gMCkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPj0gMCAmJiAhKHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgdGhpcy5kYXRhID09PSBcImlzUGF1c2VcIikpIHtcblx0XHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHsgLy9pZiB3ZSByZW5kZXIgdGhlIHZlcnkgYmVnaW5uaW5nICh0aW1lID09IDApIG9mIGEgZnJvbVRvKCksIHdlIG11c3QgZm9yY2UgdGhlIHJlbmRlciAobm9ybWFsIHR3ZWVucyB3b3VsZG4ndCBuZWVkIHRvIHJlbmRlciBhdCBhIHRpbWUgb2YgMCB3aGVuIHRoZSBwcmV2VGltZSB3YXMgYWxzbyAwKS4gVGhpcyBpcyBhbHNvIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgb3ZlcndyaXRpbmcga2lja3MgaW4gaW1tZWRpYXRlbHkuXG5cdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGltZTtcblxuXHRcdFx0XHRpZiAodGhpcy5fZWFzZVR5cGUpIHtcblx0XHRcdFx0XHR2YXIgciA9IHRpbWUgLyBkdXJhdGlvbiwgdHlwZSA9IHRoaXMuX2Vhc2VUeXBlLCBwb3cgPSB0aGlzLl9lYXNlUG93ZXI7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEgfHwgKHR5cGUgPT09IDMgJiYgciA+PSAwLjUpKSB7XG5cdFx0XHRcdFx0XHRyID0gMSAtIHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwb3cgPT09IDEpIHtcblx0XHRcdFx0XHRcdHIgKj0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMikge1xuXHRcdFx0XHRcdFx0ciAqPSByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDQpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByICogcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gMikge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aW1lIC8gZHVyYXRpb24gPCAwLjUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByIC8gMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSAociAvIDIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX3RpbWUgPT09IHByZXZUaW1lICYmICFmb3JjZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXQoKTtcblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkIHx8IHRoaXMuX2djKSB7IC8vaW1tZWRpYXRlUmVuZGVyIHR3ZWVucyB0eXBpY2FsbHkgd29uJ3QgaW5pdGlhbGl6ZSB1bnRpbCB0aGUgcGxheWhlYWQgYWR2YW5jZXMgKF90aW1lIGlzIGdyZWF0ZXIgdGhhbiAwKSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBvdmVyd3JpdGluZyBvY2N1cnMgcHJvcGVybHkuIEFsc28sIGlmIGFsbCBvZiB0aGUgdHdlZW5pbmcgcHJvcGVydGllcyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4gKHdoaWNoIHdvdWxkIGNhdXNlIF9nYyB0byBiZSB0cnVlLCBhcyBzZXQgaW4gX2luaXQoKSksIHdlIHNob3VsZG4ndCBjb250aW51ZSBvdGhlcndpc2UgYW4gb25TdGFydCBjYWxsYmFjayBjb3VsZCBiZSBjYWxsZWQgZm9yIGV4YW1wbGUuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFmb3JjZSAmJiB0aGlzLl9maXJzdFBUICYmICgodGhpcy52YXJzLmxhenkgIT09IGZhbHNlICYmIHRoaXMuX2R1cmF0aW9uKSB8fCAodGhpcy52YXJzLmxhenkgJiYgIXRoaXMuX2R1cmF0aW9uKSkpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lID0gcHJldlRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSBwcmV2UmF3UHJldlRpbWU7XG5cdFx0XHRcdFx0X2xhenlUd2VlbnMucHVzaCh0aGlzKTtcblx0XHRcdFx0XHR0aGlzLl9sYXp5ID0gW3RpbWUsIHN1cHByZXNzRXZlbnRzXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9fZWFzZSBpcyBpbml0aWFsbHkgc2V0IHRvIGRlZmF1bHRFYXNlLCBzbyBub3cgdGhhdCBpbml0KCkgaGFzIHJ1biwgX2Vhc2UgaXMgc2V0IHByb3Blcmx5IGFuZCB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSByYXRpby4gT3ZlcmFsbCB0aGlzIGlzIGZhc3RlciB0aGFuIHVzaW5nIGNvbmRpdGlvbmFsIGxvZ2ljIGVhcmxpZXIgaW4gdGhlIG1ldGhvZCB0byBhdm9pZCBoYXZpbmcgdG8gc2V0IHJhdGlvIHR3aWNlIGJlY2F1c2Ugd2Ugb25seSBpbml0KCkgb25jZSBidXQgcmVuZGVyVGltZSgpIGdldHMgY2FsbGVkIFZFUlkgZnJlcXVlbnRseS5cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgJiYgIWlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzQ29tcGxldGUgJiYgdGhpcy5fZWFzZS5fY2FsY0VuZCkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKCh0aGlzLl90aW1lID09PSAwKSA/IDAgOiAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2xhenkgIT09IGZhbHNlKSB7IC8vaW4gY2FzZSBhIGxhenkgcmVuZGVyIGlzIHBlbmRpbmcsIHdlIHNob3VsZCBmbHVzaCBpdCBiZWNhdXNlIHRoZSBuZXcgcmVuZGVyIGlzIG9jY3VycmluZyBub3cgKGltYWdpbmUgYSBsYXp5IHR3ZWVuIGluc3RhbnRpYXRpbmcgYW5kIHRoZW4gaW1tZWRpYXRlbHkgdGhlIHVzZXIgY2FsbHMgdHdlZW4uc2Vlayh0d2Vlbi5kdXJhdGlvbigpKSwgc2tpcHBpbmcgdG8gdGhlIGVuZCAtIHRoZSBlbmQgcmVuZGVyIHdvdWxkIGJlIGZvcmNlZCwgYW5kIHRoZW4gaWYgd2UgZGlkbid0IGZsdXNoIHRoZSBsYXp5IHJlbmRlciwgaXQnZCBmaXJlIEFGVEVSIHRoZSBzZWVrKCksIHJlbmRlcmluZyBpdCBhdCB0aGUgd3JvbmcgdGltZS5cblx0XHRcdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RpbWUgIT09IHByZXZUaW1lICYmIHRpbWUgPj0gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgYSB0d2VlbiAoYXMgb3Bwb3NlZCB0byB0aGUgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgdGhlIHRpbWVsaW5lIGlzIGZvcmNlZCB0byByZS1yZW5kZXIgYW5kIGFsaWduIGl0IHdpdGggdGhlIHByb3BlciB0aW1lL2ZyYW1lIG9uIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZS4gTWF5YmUgdGhlIHR3ZWVuIGFscmVhZHkgZmluaXNoZWQgYnV0IHRoZSB1c2VyIG1hbnVhbGx5IHJlLXJlbmRlcnMgaXQgYXMgaGFsZndheSBkb25lLlxuXHRcdFx0fVxuXHRcdFx0aWYgKHByZXZUaW1lID09PSAwKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zdGFydEF0KSB7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIl9kdW1teUdTXCI7IC8vaWYgbm8gY2FsbGJhY2sgaXMgZGVmaW5lZCwgdXNlIGEgZHVtbXkgdmFsdWUganVzdCBzbyB0aGF0IHRoZSBjb25kaXRpb24gYXQgdGhlIGVuZCBldmFsdWF0ZXMgYXMgdHJ1ZSBiZWNhdXNlIF9zdGFydEF0IHNob3VsZCByZW5kZXIgQUZURVIgdGhlIG5vcm1hbCByZW5kZXIgbG9vcCB3aGVuIHRoZSB0aW1lIGlzIG5lZ2F0aXZlLiBXZSBjb3VsZCBoYW5kbGUgdGhpcyBpbiBhIG1vcmUgaW50dWl0aXZlIHdheSwgb2YgY291cnNlLCBidXQgdGhlIHJlbmRlciBsb29wIGlzIHRoZSBNT1NUIGltcG9ydGFudCB0aGluZyB0byBvcHRpbWl6ZSwgc28gdGhpcyB0ZWNobmlxdWUgYWxsb3dzIHVzIHRvIGF2b2lkIGFkZGluZyBleHRyYSBjb25kaXRpb25hbCBsb2dpYyBpbiBhIGhpZ2gtZnJlcXVlbmN5IGFyZWEuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RpbWUgIT09IDAgfHwgZHVyYXRpb24gPT09IDApIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0ocHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDApIGlmICh0aGlzLl9zdGFydEF0ICYmIHRpbWUgIT09IC0wLjAwMDEpIHsgLy9pZiB0aGUgdHdlZW4gaXMgcG9zaXRpb25lZCBhdCB0aGUgVkVSWSBiZWdpbm5pbmcgKF9zdGFydFRpbWUgMCkgb2YgaXRzIHBhcmVudCB0aW1lbGluZSwgaXQncyBpbGxlZ2FsIGZvciB0aGUgcGxheWhlYWQgdG8gZ28gYmFjayBmdXJ0aGVyLCBzbyB3ZSBzaG91bGQgbm90IHJlbmRlciB0aGUgcmVjb3JkZWQgc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAodGhpcy5fdGltZSAhPT0gcHJldlRpbWUgfHwgaXNDb21wbGV0ZSB8fCBmb3JjZSkge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9nYyB8fCBmb3JjZSkgeyAvL2NoZWNrIF9nYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmICh0aW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aW1lICE9PSAtMC4wMDAxKSB7IC8vLTAuMDAwMSBpcyBhIHNwZWNpYWwgdmFsdWUgdGhhdCB3ZSB1c2Ugd2hlbiBsb29waW5nIGJhY2sgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHJlcGVhdGVkIFRpbWVsaW5lTWF4LCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZG4ndCByZW5kZXIgdGhlIF9zdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzICYmIHRoaXMudmFyc1tjYWxsYmFja10pIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiByYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0pIHsgLy90aGUgb25Db21wbGV0ZSBvciBvblJldmVyc2VDb21wbGV0ZSBjb3VsZCB0cmlnZ2VyIG1vdmVtZW50IG9mIHRoZSBwbGF5aGVhZCBhbmQgZm9yIHplcm8tZHVyYXRpb24gdHdlZW5zICh3aGljaCBtdXN0IGRpc2Nlcm4gZGlyZWN0aW9uKSB0aGF0IGxhbmQgZGlyZWN0bHkgYmFjayBvbiB0aGVpciBzdGFydCB0aW1lLCB3ZSBkb24ndCB3YW50IHRvIGZpcmUgYWdhaW4gb24gdGhlIG5leHQgcmVuZGVyLiBUaGluayBvZiBzZXZlcmFsIGFkZFBhdXNlKCkncyBpbiBhIHRpbWVsaW5lIHRoYXQgZm9yY2VzIHRoZSBwbGF5aGVhZCB0byBhIGNlcnRhaW4gc3BvdCwgYnV0IHdoYXQgaWYgaXQncyBhbHJlYWR5IHBhdXNlZCBhbmQgYW5vdGhlciB0d2VlbiBpcyB0d2VlbmluZyB0aGUgXCJ0aW1lXCIgb2YgdGhlIHRpbWVsaW5lPyBFYWNoIHRpbWUgaXQgbW92ZXMgW2ZvcndhcmRdIHBhc3QgdGhhdCBzcG90LCBpdCB3b3VsZCBtb3ZlIGJhY2ssIGFuZCBzaW5jZSBzdXBwcmVzc0V2ZW50cyBpcyB0cnVlLCBpdCdkIHJlc2V0IF9yYXdQcmV2VGltZSB0byBfdGlueU51bSBzbyB0aGF0IHdoZW4gaXQgYmVnaW5zIGFnYWluLCB0aGUgY2FsbGJhY2sgd291bGQgZmlyZSAoc28gdWx0aW1hdGVseSBpdCBjb3VsZCBib3VuY2UgYmFjayBhbmQgZm9ydGggZHVyaW5nIHRoYXQgdHdlZW4pLiBBZ2FpbiwgdGhpcyBpcyBhIHZlcnkgdW5jb21tb24gc2NlbmFyaW8sIGJ1dCBwb3NzaWJsZSBub25ldGhlbGVzcy5cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCwgb3ZlcndyaXRpbmdUd2Vlbikge1xuXHRcdFx0aWYgKHZhcnMgPT09IFwiYWxsXCIpIHtcblx0XHRcdFx0dmFycyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFycyA9PSBudWxsKSBpZiAodGFyZ2V0ID09IG51bGwgfHwgdGFyZ2V0ID09PSB0aGlzLnRhcmdldCkge1xuXHRcdFx0XHR0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQgPSAodHlwZW9mKHRhcmdldCkgIT09IFwic3RyaW5nXCIpID8gKHRhcmdldCB8fCB0aGlzLl90YXJnZXRzIHx8IHRoaXMudGFyZ2V0KSA6IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXQpIHx8IHRhcmdldDtcblx0XHRcdHZhciBzaW11bHRhbmVvdXNPdmVyd3JpdGUgPSAob3ZlcndyaXRpbmdUd2VlbiAmJiB0aGlzLl90aW1lICYmIG92ZXJ3cml0aW5nVHdlZW4uX3N0YXJ0VGltZSA9PT0gdGhpcy5fc3RhcnRUaW1lICYmIHRoaXMuX3RpbWVsaW5lID09PSBvdmVyd3JpdGluZ1R3ZWVuLl90aW1lbGluZSksXG5cdFx0XHRcdGksIG92ZXJ3cml0dGVuUHJvcHMsIHAsIHB0LCBwcm9wTG9va3VwLCBjaGFuZ2VkLCBraWxsUHJvcHMsIHJlY29yZCwga2lsbGVkO1xuXHRcdFx0aWYgKChfaXNBcnJheSh0YXJnZXQpIHx8IF9pc1NlbGVjdG9yKHRhcmdldCkpICYmIHR5cGVvZih0YXJnZXRbMF0pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdGkgPSB0YXJnZXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fa2lsbCh2YXJzLCB0YXJnZXRbaV0sIG92ZXJ3cml0aW5nVHdlZW4pKSB7XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl90YXJnZXRzKSB7XG5cdFx0XHRcdFx0aSA9IHRoaXMuX3RhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKHRhcmdldCA9PT0gdGhpcy5fdGFyZ2V0c1tpXSkge1xuXHRcdFx0XHRcdFx0XHRwcm9wTG9va3VwID0gdGhpcy5fcHJvcExvb2t1cFtpXSB8fCB7fTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgfHwgW107XG5cdFx0XHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzW2ldID0gdmFycyA/IHRoaXMuX292ZXJ3cml0dGVuUHJvcHNbaV0gfHwge30gOiBcImFsbFwiO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0ICE9PSB0aGlzLnRhcmdldCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwcm9wTG9va3VwID0gdGhpcy5fcHJvcExvb2t1cDtcblx0XHRcdFx0XHRvdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHZhcnMgPyB0aGlzLl9vdmVyd3JpdHRlblByb3BzIHx8IHt9IDogXCJhbGxcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwcm9wTG9va3VwKSB7XG5cdFx0XHRcdFx0a2lsbFByb3BzID0gdmFycyB8fCBwcm9wTG9va3VwO1xuXHRcdFx0XHRcdHJlY29yZCA9ICh2YXJzICE9PSBvdmVyd3JpdHRlblByb3BzICYmIG92ZXJ3cml0dGVuUHJvcHMgIT09IFwiYWxsXCIgJiYgdmFycyAhPT0gcHJvcExvb2t1cCAmJiAodHlwZW9mKHZhcnMpICE9PSBcIm9iamVjdFwiIHx8ICF2YXJzLl90ZW1wS2lsbCkpOyAvL190ZW1wS2lsbCBpcyBhIHN1cGVyLXNlY3JldCB3YXkgdG8gZGVsZXRlIGEgcGFydGljdWxhciB0d2VlbmluZyBwcm9wZXJ0eSBidXQgTk9UIGhhdmUgaXQgcmVtZW1iZXJlZCBhcyBhbiBvZmZpY2lhbCBvdmVyd3JpdHRlbiBwcm9wZXJ0eSAobGlrZSBpbiBCZXppZXJQbHVnaW4pXG5cdFx0XHRcdFx0aWYgKG92ZXJ3cml0aW5nVHdlZW4gJiYgKFR3ZWVuTGl0ZS5vbk92ZXJ3cml0ZSB8fCB0aGlzLnZhcnMub25PdmVyd3JpdGUpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHAgaW4ga2lsbFByb3BzKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwcm9wTG9va3VwW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFraWxsZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGtpbGxlZCA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRraWxsZWQucHVzaChwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKChraWxsZWQgfHwgIXZhcnMpICYmICFfb25PdmVyd3JpdGUodGhpcywgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWQpKSB7IC8vaWYgdGhlIG9uT3ZlcndyaXRlIHJldHVybmVkIGZhbHNlLCB0aGF0IG1lYW5zIHRoZSB1c2VyIHdhbnRzIHRvIG92ZXJyaWRlIHRoZSBvdmVyd3JpdGluZyAoY2FuY2VsIGl0KS5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAocCBpbiBraWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdGlmICgocHQgPSBwcm9wTG9va3VwW3BdKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc2ltdWx0YW5lb3VzT3ZlcndyaXRlKSB7IC8vaWYgYW5vdGhlciB0d2VlbiBvdmVyd3JpdGVzIHRoaXMgb25lIGFuZCB0aGV5IGJvdGggc3RhcnQgYXQgZXhhY3RseSB0aGUgc2FtZSB0aW1lLCB5ZXQgdGhpcyB0d2VlbiBoYXMgYWxyZWFkeSByZW5kZXJlZCBvbmNlIChmb3IgZXhhbXBsZSwgYXQgMC4wMDEpIGJlY2F1c2UgaXQncyBmaXJzdCBpbiB0aGUgcXVldWUsIHdlIHNob3VsZCByZXZlcnQgdGhlIHZhbHVlcyB0byB3aGVyZSB0aGV5IHdlcmUgYXQgMCBzbyB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZXMgYXJlbid0IGNvbnRhbWluYXRlZCBvbiB0aGUgb3ZlcndyaXRpbmcgdHdlZW4uXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0ocHQucyk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC5zO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAocHQucGcgJiYgcHQudC5fa2lsbChraWxsUHJvcHMpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7IC8vc29tZSBwbHVnaW5zIG5lZWQgdG8gYmUgbm90aWZpZWQgc28gdGhleSBjYW4gcGVyZm9ybSBjbGVhbnVwIHRhc2tzIGZpcnN0XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCFwdC5wZyB8fCBwdC50Ll9vdmVyd3JpdGVQcm9wcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwdCA9PT0gdGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQuX3ByZXY7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHB0Ll9uZXh0ID0gcHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBwcm9wTG9va3VwW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHJlY29yZCkge1xuXHRcdFx0XHRcdFx0XHRvdmVyd3JpdHRlblByb3BzW3BdID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9maXJzdFBUICYmIHRoaXMuX2luaXR0ZWQpIHsgLy9pZiBhbGwgdHdlZW5pbmcgcHJvcGVydGllcyBhcmUga2lsbGVkLCBraWxsIHRoZSB0d2Vlbi4gV2l0aG91dCB0aGlzIGxpbmUsIGlmIHRoZXJlJ3MgYSB0d2VlbiB3aXRoIG11bHRpcGxlIHRhcmdldHMgYW5kIHRoZW4geW91IGtpbGxUd2VlbnNPZigpIGVhY2ggdGFyZ2V0IGluZGl2aWR1YWxseSwgdGhlIHR3ZWVuIHdvdWxkIHRlY2huaWNhbGx5IHN0aWxsIHJlbWFpbiBhY3RpdmUgYW5kIGZpcmUgaXRzIG9uQ29tcGxldGUgZXZlbiB0aG91Z2ggdGhlcmUgYXJlbid0IGFueSBtb3JlIHByb3BlcnRpZXMgdHdlZW5pbmcuXG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCkge1xuXHRcdFx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZmlyc3RQVCA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9zdGFydEF0ID0gdGhpcy5fb25VcGRhdGUgPSBudWxsO1xuXHRcdFx0dGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCA9IHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3Byb3BMb29rdXAgPSAodGhpcy5fdGFyZ2V0cykgPyB7fSA6IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0XHRpZiAodGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlcikge1xuXHRcdFx0XHR0aGlzLl90aW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblx0XHRcdFx0dGhpcy5yZW5kZXIoTWF0aC5taW4oMCwgLXRoaXMuX2RlbGF5KSk7IC8vaW4gY2FzZSBkZWxheSBpcyBuZWdhdGl2ZS5cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl9lbmFibGVkID0gZnVuY3Rpb24oZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdGlmIChlbmFibGVkICYmIHRoaXMuX2djKSB7XG5cdFx0XHRcdHZhciB0YXJnZXRzID0gdGhpcy5fdGFyZ2V0cyxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRpZiAodGFyZ2V0cykge1xuXHRcdFx0XHRcdGkgPSB0YXJnZXRzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzW2ldID0gX3JlZ2lzdGVyKHRhcmdldHNbaV0sIHRoaXMsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9zaWJsaW5ncyA9IF9yZWdpc3Rlcih0aGlzLnRhcmdldCwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdEFuaW1hdGlvbi5wcm90b3R5cGUuX2VuYWJsZWQuY2FsbCh0aGlzLCBlbmFibGVkLCBpZ25vcmVUaW1lbGluZSk7XG5cdFx0XHRpZiAodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCkgaWYgKHRoaXMuX2ZpcnN0UFQpIHtcblx0XHRcdFx0cmV0dXJuIFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudCgoZW5hYmxlZCA/IFwiX29uRW5hYmxlXCIgOiBcIl9vbkRpc2FibGVcIiksIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblxuLy8tLS0tVHdlZW5MaXRlIHN0YXRpYyBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRUd2VlbkxpdGUudG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmZyb20gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgZHVyYXRpb24sIHRvVmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCA9IGZ1bmN0aW9uKGRlbGF5LCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSwgdXNlRnJhbWVzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZShjYWxsYmFjaywgMCwge2RlbGF5OmRlbGF5LCBvbkNvbXBsZXRlOmNhbGxiYWNrLCBvbkNvbXBsZXRlUGFyYW1zOnBhcmFtcywgY2FsbGJhY2tTY29wZTpzY29wZSwgb25SZXZlcnNlQ29tcGxldGU6Y2FsbGJhY2ssIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOnBhcmFtcywgaW1tZWRpYXRlUmVuZGVyOmZhbHNlLCBsYXp5OmZhbHNlLCB1c2VGcmFtZXM6dXNlRnJhbWVzLCBvdmVyd3JpdGU6MH0pO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIDAsIHZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbih0YXJnZXQsIG9ubHlBY3RpdmUpIHtcblx0XHRcdGlmICh0YXJnZXQgPT0gbnVsbCkgeyByZXR1cm4gW107IH1cblx0XHRcdHRhcmdldCA9ICh0eXBlb2YodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIikgPyB0YXJnZXQgOiBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cdFx0XHR2YXIgaSwgYSwgaiwgdDtcblx0XHRcdGlmICgoX2lzQXJyYXkodGFyZ2V0KSB8fCBfaXNTZWxlY3Rvcih0YXJnZXQpKSAmJiB0eXBlb2YodGFyZ2V0WzBdKSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRpID0gdGFyZ2V0Lmxlbmd0aDtcblx0XHRcdFx0YSA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRhID0gYS5jb25jYXQoVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldFtpXSwgb25seUFjdGl2ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0Ly9ub3cgZ2V0IHJpZCBvZiBhbnkgZHVwbGljYXRlcyAodHdlZW5zIG9mIGFycmF5cyBvZiBvYmplY3RzIGNvdWxkIGNhdXNlIGR1cGxpY2F0ZXMpXG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHQgPSBhW2ldO1xuXHRcdFx0XHRcdGogPSBpO1xuXHRcdFx0XHRcdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKHQgPT09IGFbal0pIHtcblx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhID0gX3JlZ2lzdGVyKHRhcmdldCkuY29uY2F0KCk7XG5cdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGFbaV0uX2djIHx8IChvbmx5QWN0aXZlICYmICFhW2ldLmlzQWN0aXZlKCkpKSB7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUua2lsbFR3ZWVuc09mID0gVHdlZW5MaXRlLmtpbGxEZWxheWVkQ2FsbHNUbyA9IGZ1bmN0aW9uKHRhcmdldCwgb25seUFjdGl2ZSwgdmFycykge1xuXHRcdFx0aWYgKHR5cGVvZihvbmx5QWN0aXZlKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHR2YXJzID0gb25seUFjdGl2ZTsgLy9mb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKGJlZm9yZSBcIm9ubHlBY3RpdmVcIiBwYXJhbWV0ZXIgd2FzIGluc2VydGVkKVxuXHRcdFx0XHRvbmx5QWN0aXZlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXQsIG9ubHlBY3RpdmUpLFxuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0YVtpXS5fa2lsbCh2YXJzLCB0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVHdlZW5QbHVnaW4gICAoY291bGQgZWFzaWx5IGJlIHNwbGl0IG91dCBhcyBhIHNlcGFyYXRlIGZpbGUvY2xhc3MsIGJ1dCBpbmNsdWRlZCBmb3IgZWFzZSBvZiB1c2UgKHNvIHRoYXQgcGVvcGxlIGRvbid0IG5lZWQgdG8gaW5jbHVkZSBhbm90aGVyIHNjcmlwdCBjYWxsIGJlZm9yZSBsb2FkaW5nIHBsdWdpbnMgd2hpY2ggaXMgZWFzeSB0byBmb3JnZXQpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgVHdlZW5QbHVnaW4gPSBfY2xhc3MoXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsIGZ1bmN0aW9uKHByb3BzLCBwcmlvcml0eSkge1xuXHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzID0gKHByb3BzIHx8IFwiXCIpLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0XHR0aGlzLl9wcm9wTmFtZSA9IHRoaXMuX292ZXJ3cml0ZVByb3BzWzBdO1xuXHRcdFx0XHRcdHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcblx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IFR3ZWVuUGx1Z2luLnByb3RvdHlwZTtcblx0XHRcdFx0fSwgdHJ1ZSk7XG5cblx0XHRwID0gVHdlZW5QbHVnaW4ucHJvdG90eXBlO1xuXHRcdFR3ZWVuUGx1Z2luLnZlcnNpb24gPSBcIjEuMTguMFwiO1xuXHRcdFR3ZWVuUGx1Z2luLkFQSSA9IDI7XG5cdFx0cC5fZmlyc3RQVCA9IG51bGw7XG5cdFx0cC5fYWRkVHdlZW4gPSBfYWRkUHJvcFR3ZWVuO1xuXHRcdHAuc2V0UmF0aW8gPSBfc2V0UmF0aW87XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgYSA9IHRoaXMuX292ZXJ3cml0ZVByb3BzLFxuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdGk7XG5cdFx0XHRpZiAobG9va3VwW3RoaXMuX3Byb3BOYW1lXSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChsb29rdXBbYVtpXV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKGxvb2t1cFtwdC5uXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9maXJzdFBUID09PSBwdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLl9yb3VuZFByb3BzID0gZnVuY3Rpb24obG9va3VwLCB2YWx1ZSkge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAobG9va3VwW3RoaXMuX3Byb3BOYW1lXSB8fCAocHQubiAhPSBudWxsICYmIGxvb2t1cFsgcHQubi5zcGxpdCh0aGlzLl9wcm9wTmFtZSArIFwiX1wiKS5qb2luKFwiXCIpIF0pKSB7IC8vc29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHZlcnkgcGx1Z2luLXNwZWNpZmljIGFkZCBhIHByZWZpeCBuYW1lZCBhZnRlciB0aGUgX3Byb3BOYW1lIHBsdXMgYW4gdW5kZXJzY29yZSwgc28gd2UgbmVlZCB0byBpZ25vcmUgdGhhdCBleHRyYSBzdHVmZiBoZXJlLlxuXHRcdFx0XHRcdHB0LnIgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQgPSBmdW5jdGlvbih0eXBlLCB0d2Vlbikge1xuXHRcdFx0dmFyIHB0ID0gdHdlZW4uX2ZpcnN0UFQsXG5cdFx0XHRcdGNoYW5nZWQsIHB0MiwgZmlyc3QsIGxhc3QsIG5leHQ7XG5cdFx0XHRpZiAodHlwZSA9PT0gXCJfb25Jbml0QWxsUHJvcHNcIikge1xuXHRcdFx0XHQvL3NvcnRzIHRoZSBQcm9wVHdlZW4gbGlua2VkIGxpc3QgaW4gb3JkZXIgb2YgcHJpb3JpdHkgYmVjYXVzZSBzb21lIHBsdWdpbnMgbmVlZCB0byByZW5kZXIgZWFybGllci9sYXRlciB0aGFuIG90aGVycywgbGlrZSBNb3Rpb25CbHVyUGx1Z2luIGFwcGxpZXMgaXRzIGVmZmVjdHMgYWZ0ZXIgYWxsIHgveS9hbHBoYSB0d2VlbnMgaGF2ZSByZW5kZXJlZCBvbiBlYWNoIGZyYW1lLlxuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRuZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0cHQyID0gZmlyc3Q7XG5cdFx0XHRcdFx0d2hpbGUgKHB0MiAmJiBwdDIucHIgPiBwdC5wcikge1xuXHRcdFx0XHRcdFx0cHQyID0gcHQyLl9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9wcmV2ID0gcHQyID8gcHQyLl9wcmV2IDogbGFzdCkpIHtcblx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcnN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX25leHQgPSBwdDIpKSB7XG5cdFx0XHRcdFx0XHRwdDIuX3ByZXYgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGFzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSB0d2Vlbi5fZmlyc3RQVCA9IGZpcnN0O1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChwdC5wZykgaWYgKHR5cGVvZihwdC50W3R5cGVdKSA9PT0gXCJmdW5jdGlvblwiKSBpZiAocHQudFt0eXBlXSgpKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHRUd2VlblBsdWdpbi5hY3RpdmF0ZSA9IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHRcdHZhciBpID0gcGx1Z2lucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHBsdWdpbnNbaV0uQVBJID09PSBUd2VlblBsdWdpbi5BUEkpIHtcblx0XHRcdFx0XHRfcGx1Z2luc1sobmV3IHBsdWdpbnNbaV0oKSkuX3Byb3BOYW1lXSA9IHBsdWdpbnNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvL3Byb3ZpZGVzIGEgbW9yZSBjb25jaXNlIHdheSB0byBkZWZpbmUgcGx1Z2lucyB0aGF0IGhhdmUgbm8gZGVwZW5kZW5jaWVzIGJlc2lkZXMgVHdlZW5QbHVnaW4gYW5kIFR3ZWVuTGl0ZSwgd3JhcHBpbmcgY29tbW9uIGJvaWxlcnBsYXRlIHN0dWZmIGludG8gb25lIGZ1bmN0aW9uIChhZGRlZCBpbiAxLjkuMCkuIFlvdSBkb24ndCBORUVEIHRvIHVzZSB0aGlzIHRvIGRlZmluZSBhIHBsdWdpbiAtIHRoZSBvbGQgd2F5IHN0aWxsIHdvcmtzIGFuZCBjYW4gYmUgdXNlZnVsIGluIGNlcnRhaW4gKHJhcmUpIHNpdHVhdGlvbnMuXG5cdFx0X2dzRGVmaW5lLnBsdWdpbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdFx0aWYgKCFjb25maWcgfHwgIWNvbmZpZy5wcm9wTmFtZSB8fCAhY29uZmlnLmluaXQgfHwgIWNvbmZpZy5BUEkpIHsgdGhyb3cgXCJpbGxlZ2FsIHBsdWdpbiBkZWZpbml0aW9uLlwiOyB9XG5cdFx0XHR2YXIgcHJvcE5hbWUgPSBjb25maWcucHJvcE5hbWUsXG5cdFx0XHRcdHByaW9yaXR5ID0gY29uZmlnLnByaW9yaXR5IHx8IDAsXG5cdFx0XHRcdG92ZXJ3cml0ZVByb3BzID0gY29uZmlnLm92ZXJ3cml0ZVByb3BzLFxuXHRcdFx0XHRtYXAgPSB7aW5pdDpcIl9vbkluaXRUd2VlblwiLCBzZXQ6XCJzZXRSYXRpb1wiLCBraWxsOlwiX2tpbGxcIiwgcm91bmQ6XCJfcm91bmRQcm9wc1wiLCBpbml0QWxsOlwiX29uSW5pdEFsbFByb3BzXCJ9LFxuXHRcdFx0XHRQbHVnaW4gPSBfY2xhc3MoXCJwbHVnaW5zLlwiICsgcHJvcE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wTmFtZS5zdWJzdHIoMSkgKyBcIlBsdWdpblwiLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0VHdlZW5QbHVnaW4uY2FsbCh0aGlzLCBwcm9wTmFtZSwgcHJpb3JpdHkpO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMgPSBvdmVyd3JpdGVQcm9wcyB8fCBbXTtcblx0XHRcdFx0XHR9LCAoY29uZmlnLmdsb2JhbCA9PT0gdHJ1ZSkpLFxuXHRcdFx0XHRwID0gUGx1Z2luLnByb3RvdHlwZSA9IG5ldyBUd2VlblBsdWdpbihwcm9wTmFtZSksXG5cdFx0XHRcdHByb3A7XG5cdFx0XHRwLmNvbnN0cnVjdG9yID0gUGx1Z2luO1xuXHRcdFx0UGx1Z2luLkFQSSA9IGNvbmZpZy5BUEk7XG5cdFx0XHRmb3IgKHByb3AgaW4gbWFwKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YoY29uZmlnW3Byb3BdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0cFttYXBbcHJvcF1dID0gY29uZmlnW3Byb3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRQbHVnaW4udmVyc2lvbiA9IGNvbmZpZy52ZXJzaW9uO1xuXHRcdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUoW1BsdWdpbl0pO1xuXHRcdFx0cmV0dXJuIFBsdWdpbjtcblx0XHR9O1xuXG5cblx0XHQvL25vdyBydW4gdGhyb3VnaCBhbGwgdGhlIGRlcGVuZGVuY2llcyBkaXNjb3ZlcmVkIGFuZCBpZiBhbnkgYXJlIG1pc3NpbmcsIGxvZyB0aGF0IHRvIHRoZSBjb25zb2xlIGFzIGEgd2FybmluZy4gVGhpcyBpcyB3aHkgaXQncyBiZXN0IHRvIGhhdmUgVHdlZW5MaXRlIGxvYWQgbGFzdCAtIGl0IGNhbiBjaGVjayBhbGwgdGhlIGRlcGVuZGVuY2llcyBmb3IgeW91LlxuXHRcdGEgPSB3aW5kb3cuX2dzUXVldWU7XG5cdFx0aWYgKGEpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGFbaV0oKTtcblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiBfZGVmTG9va3VwKSB7XG5cdFx0XHRcdGlmICghX2RlZkxvb2t1cFtwXS5mdW5jKSB7XG5cdFx0XHRcdFx0d2luZG93LmNvbnNvbGUubG9nKFwiR1NBUCBlbmNvdW50ZXJlZCBtaXNzaW5nIGRlcGVuZGVuY3k6IGNvbS5ncmVlbnNvY2suXCIgKyBwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF90aWNrZXJBY3RpdmUgPSBmYWxzZTsgLy9lbnN1cmVzIHRoYXQgdGhlIGZpcnN0IG9mZmljaWFsIGFuaW1hdGlvbiBmb3JjZXMgYSB0aWNrZXIudGljaygpIHRvIHVwZGF0ZSB0aGUgdGltZSB3aGVuIGl0IGlzIGluc3RhbnRpYXRlZFxuXG59KSgodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mKGdsb2JhbCkgIT09IFwidW5kZWZpbmVkXCIpID8gZ2xvYmFsIDogdGhpcyB8fCB3aW5kb3csIFwiVHdlZW5NYXhcIik7IiwiLyohXG4gKiBTY3JvbGxNYWdpYyB2Mi4wLjUgKDIwMTUtMDQtMjkpXG4gKiBUaGUgamF2YXNjcmlwdCBsaWJyYXJ5IGZvciBtYWdpY2FsIHNjcm9sbCBpbnRlcmFjdGlvbnMuXG4gKiAoYykgMjAxNSBKYW4gUGFlcGtlIChAamFucGFlcGtlKVxuICogUHJvamVjdCBXZWJzaXRlOiBodHRwOi8vc2Nyb2xsbWFnaWMuaW9cbiAqIFxuICogQHZlcnNpb24gMi4wLjVcbiAqIEBsaWNlbnNlIER1YWwgbGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2UgYW5kIEdQTC5cbiAqIEBhdXRob3IgSmFuIFBhZXBrZSAtIGUtbWFpbEBqYW5wYWVwa2UuZGVcbiAqXG4gKiBAZmlsZSBTY3JvbGxNYWdpYyBtYWluIGxpYnJhcnkuXG4gKi9cbi8qKlxuICogQG5hbWVzcGFjZSBTY3JvbGxNYWdpY1xuICovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fSBlbHNlIHtcblx0XHQvLyBCcm93c2VyIGdsb2JhbFxuXHRcdHJvb3QuU2Nyb2xsTWFnaWMgPSBmYWN0b3J5KCk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgU2Nyb2xsTWFnaWMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0X3V0aWwubG9nKDIsICcoQ09NUEFUSUJJTElUWSBOT1RJQ0UpIC0+IEFzIG9mIFNjcm9sbE1hZ2ljIDIuMC4wIHlvdSBuZWVkIHRvIHVzZSBcXCduZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcigpXFwnIHRvIGNyZWF0ZSBhIG5ldyBjb250cm9sbGVyIGluc3RhbmNlLiBVc2UgXFwnbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKClcXCcgdG8gaW5zdGFuY2UgYSBzY2VuZS4nKTtcblx0fTtcblxuXHRTY3JvbGxNYWdpYy52ZXJzaW9uID0gXCIyLjAuNVwiO1xuXG5cdC8vIFRPRE86IHRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBjaHJvbWUncyBzY3JvbGwgaml0dGVyIGJ1Z1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNld2hlZWxcIiwgZnVuY3Rpb24gKCkge30pO1xuXG5cdC8vIGdsb2JhbCBjb25zdFxuXHR2YXIgUElOX1NQQUNFUl9BVFRSSUJVVEUgPSBcImRhdGEtc2Nyb2xsbWFnaWMtcGluLXNwYWNlclwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgbWFpbiBjbGFzcyB0aGF0IGlzIG5lZWRlZCBvbmNlIHBlciBzY3JvbGwgY29udGFpbmVyLlxuXHQgKlxuXHQgKiBAY2xhc3Ncblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogLy8gYmFzaWMgaW5pdGlhbGl6YXRpb25cblx0ICogdmFyIGNvbnRyb2xsZXIgPSBuZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcigpO1xuXHQgKlxuXHQgKiAvLyBwYXNzaW5nIG9wdGlvbnNcblx0ICogdmFyIGNvbnRyb2xsZXIgPSBuZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcih7Y29udGFpbmVyOiBcIiNteUNvbnRhaW5lclwiLCBsb2dsZXZlbDogM30pO1xuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgb3B0aW9ucyBmb3IgdGhlIGNvbnRyb2xsZXIuXG5cdCAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSBbb3B0aW9ucy5jb250YWluZXI9d2luZG93XSAtIEEgc2VsZWN0b3IsIERPTSBvYmplY3QgdGhhdCByZWZlcmVuY2VzIHRoZSBtYWluIGNvbnRhaW5lciBmb3Igc2Nyb2xsaW5nLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnZlcnRpY2FsPXRydWVdIC0gU2V0cyB0aGUgc2Nyb2xsIG1vZGUgdG8gdmVydGljYWwgKGB0cnVlYCkgb3IgaG9yaXpvbnRhbCAoYGZhbHNlYCkgc2Nyb2xsaW5nLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZ2xvYmFsU2NlbmVPcHRpb25zPXt9XSAtIFRoZXNlIG9wdGlvbnMgd2lsbCBiZSBwYXNzZWQgdG8gZXZlcnkgU2NlbmUgdGhhdCBpcyBhZGRlZCB0byB0aGUgY29udHJvbGxlciB1c2luZyB0aGUgYWRkU2NlbmUgbWV0aG9kLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBTY2VuZSBvcHRpb25zIHNlZSB7QGxpbmsgU2Nyb2xsTWFnaWMuU2NlbmV9LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9nbGV2ZWw9Ml0gTG9nbGV2ZWwgZm9yIGRlYnVnZ2luZy4gTm90ZSB0aGF0IGxvZ2dpbmcgaXMgZGlzYWJsZWQgaW4gdGhlIG1pbmlmaWVkIHZlcnNpb24gb2YgU2Nyb2xsTWFnaWMuXG5cdCAqKiBgMGAgPT4gc2lsZW50XG5cdCAqKiBgMWAgPT4gZXJyb3JzXG5cdCAqKiBgMmAgPT4gZXJyb3JzLCB3YXJuaW5nc1xuXHQgKiogYDNgID0+IGVycm9ycywgd2FybmluZ3MsIGRlYnVnaW5mb1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlZnJlc2hJbnRlcnZhbD0xMDBdIC0gU29tZSBjaGFuZ2VzIGRvbid0IGNhbGwgZXZlbnRzIGJ5IGRlZmF1bHQsIGxpa2UgY2hhbmdpbmcgdGhlIGNvbnRhaW5lciBzaXplIG9yIG1vdmluZyBhIHNjZW5lIHRyaWdnZXIgZWxlbWVudC4gIFxuXHQgVGhpcyBpbnRlcnZhbCBwb2xscyB0aGVzZSBwYXJhbWV0ZXJzIHRvIGZpcmUgdGhlIG5lY2Vzc2FyeSBldmVudHMuICBcblx0IElmIHlvdSBkb24ndCB1c2UgY3VzdG9tIGNvbnRhaW5lcnMsIHRyaWdnZXIgZWxlbWVudHMgb3IgaGF2ZSBzdGF0aWMgbGF5b3V0cywgd2hlcmUgdGhlIHBvc2l0aW9ucyBvZiB0aGUgdHJpZ2dlciBlbGVtZW50cyBkb24ndCBjaGFuZ2UsIHlvdSBjYW4gc2V0IHRoaXMgdG8gMCBkaXNhYmxlIGludGVydmFsIGNoZWNraW5nIGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKi9cblx0U2Nyb2xsTWFnaWMuQ29udHJvbGxlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4vKlxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIHNldHRpbmdzXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICovXG5cdFx0dmFyXG5cdFx0TkFNRVNQQUNFID0gJ1Njcm9sbE1hZ2ljLkNvbnRyb2xsZXInLFxuXHRcdFx0U0NST0xMX0RJUkVDVElPTl9GT1JXQVJEID0gJ0ZPUldBUkQnLFxuXHRcdFx0U0NST0xMX0RJUkVDVElPTl9SRVZFUlNFID0gJ1JFVkVSU0UnLFxuXHRcdFx0U0NST0xMX0RJUkVDVElPTl9QQVVTRUQgPSAnUEFVU0VEJyxcblx0XHRcdERFRkFVTFRfT1BUSU9OUyA9IENPTlRST0xMRVJfT1BUSU9OUy5kZWZhdWx0cztcblxuLypcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKiBwcml2YXRlIHZhcnNcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKi9cblx0XHR2YXJcblx0XHRDb250cm9sbGVyID0gdGhpcyxcblx0XHRcdF9vcHRpb25zID0gX3V0aWwuZXh0ZW5kKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpLFxuXHRcdFx0X3NjZW5lT2JqZWN0cyA9IFtdLFxuXHRcdFx0X3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlID0gZmFsc2UsXG5cdFx0XHQvLyBjYW4gYmUgYm9vbGVhbiAodHJ1ZSA9PiBhbGwgc2NlbmVzKSBvciBhbiBhcnJheSBvZiBzY2VuZXMgdG8gYmUgdXBkYXRlZFxuXHRcdFx0X3Njcm9sbFBvcyA9IDAsXG5cdFx0XHRfc2Nyb2xsRGlyZWN0aW9uID0gU0NST0xMX0RJUkVDVElPTl9QQVVTRUQsXG5cdFx0XHRfaXNEb2N1bWVudCA9IHRydWUsXG5cdFx0XHRfdmlld1BvcnRTaXplID0gMCxcblx0XHRcdF9lbmFibGVkID0gdHJ1ZSxcblx0XHRcdF91cGRhdGVUaW1lb3V0LCBfcmVmcmVzaFRpbWVvdXQ7XG5cbi8qXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogcHJpdmF0ZSBmdW5jdGlvbnNcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIEludGVybmFsIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIG9mIHRoZSBTY3JvbGxNYWdpYyBDb250cm9sbGVyXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIF9vcHRpb25zKSB7XG5cdFx0XHRcdGlmICghREVGQVVMVF9PUFRJT05TLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRsb2coMiwgXCJXQVJOSU5HOiBVbmtub3duIG9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIik7XG5cdFx0XHRcdFx0ZGVsZXRlIF9vcHRpb25zW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdF9vcHRpb25zLmNvbnRhaW5lciA9IF91dGlsLmdldC5lbGVtZW50cyhfb3B0aW9ucy5jb250YWluZXIpWzBdO1xuXHRcdFx0Ly8gY2hlY2sgU2Nyb2xsQ29udGFpbmVyXG5cdFx0XHRpZiAoIV9vcHRpb25zLmNvbnRhaW5lcikge1xuXHRcdFx0XHRsb2coMSwgXCJFUlJPUiBjcmVhdGluZyBvYmplY3QgXCIgKyBOQU1FU1BBQ0UgKyBcIjogTm8gdmFsaWQgc2Nyb2xsIGNvbnRhaW5lciBzdXBwbGllZFwiKTtcblx0XHRcdFx0dGhyb3cgTkFNRVNQQUNFICsgXCIgaW5pdCBmYWlsZWQuXCI7IC8vIGNhbmNlbFxuXHRcdFx0fVxuXHRcdFx0X2lzRG9jdW1lbnQgPSBfb3B0aW9ucy5jb250YWluZXIgPT09IHdpbmRvdyB8fCBfb3B0aW9ucy5jb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkgfHwgIWRvY3VtZW50LmJvZHkuY29udGFpbnMoX29wdGlvbnMuY29udGFpbmVyKTtcblx0XHRcdC8vIG5vcm1hbGl6ZSB0byB3aW5kb3dcblx0XHRcdGlmIChfaXNEb2N1bWVudCkge1xuXHRcdFx0XHRfb3B0aW9ucy5jb250YWluZXIgPSB3aW5kb3c7XG5cdFx0XHR9XG5cdFx0XHQvLyB1cGRhdGUgY29udGFpbmVyIHNpemUgaW1tZWRpYXRlbHlcblx0XHRcdF92aWV3UG9ydFNpemUgPSBnZXRWaWV3cG9ydFNpemUoKTtcblx0XHRcdC8vIHNldCBldmVudCBoYW5kbGVyc1xuXHRcdFx0X29wdGlvbnMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25DaGFuZ2UpO1xuXHRcdFx0X29wdGlvbnMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgb25DaGFuZ2UpO1xuXG5cdFx0XHRfb3B0aW9ucy5yZWZyZXNoSW50ZXJ2YWwgPSBwYXJzZUludChfb3B0aW9ucy5yZWZyZXNoSW50ZXJ2YWwpIHx8IERFRkFVTFRfT1BUSU9OUy5yZWZyZXNoSW50ZXJ2YWw7XG5cdFx0XHRzY2hlZHVsZVJlZnJlc2goKTtcblxuXHRcdFx0bG9nKDMsIFwiYWRkZWQgbmV3IFwiICsgTkFNRVNQQUNFICsgXCIgY29udHJvbGxlciAodlwiICsgU2Nyb2xsTWFnaWMudmVyc2lvbiArIFwiKVwiKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogU2NoZWR1bGUgdGhlIG5leHQgZXhlY3V0aW9uIG9mIHRoZSByZWZyZXNoIGZ1bmN0aW9uXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgc2NoZWR1bGVSZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKF9vcHRpb25zLnJlZnJlc2hJbnRlcnZhbCA+IDApIHtcblx0XHRcdFx0X3JlZnJlc2hUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQocmVmcmVzaCwgX29wdGlvbnMucmVmcmVzaEludGVydmFsKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmYXVsdCBmdW5jdGlvbiB0byBnZXQgc2Nyb2xsIHBvcyAtIG92ZXJ3cml0ZWFibGUgdXNpbmcgYENvbnRyb2xsZXIuc2Nyb2xsUG9zKG5ld0Z1bmN0aW9uKWBcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciBnZXRTY3JvbGxQb3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gX29wdGlvbnMudmVydGljYWwgPyBfdXRpbC5nZXQuc2Nyb2xsVG9wKF9vcHRpb25zLmNvbnRhaW5lcikgOiBfdXRpbC5nZXQuc2Nyb2xsTGVmdChfb3B0aW9ucy5jb250YWluZXIpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZpZXdwb3J0IFNpemUgKHdpZHRoIHZvciBob3Jpem9udGFsLCBoZWlnaHQgZm9yIHZlcnRpY2FsKVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIGdldFZpZXdwb3J0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBfb3B0aW9ucy52ZXJ0aWNhbCA/IF91dGlsLmdldC5oZWlnaHQoX29wdGlvbnMuY29udGFpbmVyKSA6IF91dGlsLmdldC53aWR0aChfb3B0aW9ucy5jb250YWluZXIpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBEZWZhdWx0IGZ1bmN0aW9uIHRvIHNldCBzY3JvbGwgcG9zIC0gb3ZlcndyaXRlYWJsZSB1c2luZyBgQ29udHJvbGxlci5zY3JvbGxUbyhuZXdGdW5jdGlvbilgXG5cdFx0ICogTWFrZSBhdmFpbGFibGUgcHVibGljbHkgZm9yIHBpbm5lZCBtb3VzZXdoZWVsIHdvcmthcm91bmQuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgc2V0U2Nyb2xsUG9zID0gdGhpcy5fc2V0U2Nyb2xsUG9zID0gZnVuY3Rpb24gKHBvcykge1xuXHRcdFx0aWYgKF9vcHRpb25zLnZlcnRpY2FsKSB7XG5cdFx0XHRcdGlmIChfaXNEb2N1bWVudCkge1xuXHRcdFx0XHRcdHdpbmRvdy5zY3JvbGxUbyhfdXRpbC5nZXQuc2Nyb2xsTGVmdCgpLCBwb3MpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9vcHRpb25zLmNvbnRhaW5lci5zY3JvbGxUb3AgPSBwb3M7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChfaXNEb2N1bWVudCkge1xuXHRcdFx0XHRcdHdpbmRvdy5zY3JvbGxUbyhwb3MsIF91dGlsLmdldC5zY3JvbGxUb3AoKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X29wdGlvbnMuY29udGFpbmVyLnNjcm9sbExlZnQgPSBwb3M7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlIHVwZGF0ZXMgaW4gY3ljbGVzIGluc3RlYWQgb2Ygb24gc2Nyb2xsIChwZXJmb3JtYW5jZSlcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciB1cGRhdGVTY2VuZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoX2VuYWJsZWQgJiYgX3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlKSB7XG5cdFx0XHRcdC8vIGRldGVybWluZSBzY2VuZXMgdG8gdXBkYXRlXG5cdFx0XHRcdHZhciBzY2VuZXNUb1VwZGF0ZSA9IF91dGlsLnR5cGUuQXJyYXkoX3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlKSA/IF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSA6IF9zY2VuZU9iamVjdHMuc2xpY2UoMCk7XG5cdFx0XHRcdC8vIHJlc2V0IHNjZW5lc1xuXHRcdFx0XHRfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUgPSBmYWxzZTtcblx0XHRcdFx0dmFyIG9sZFNjcm9sbFBvcyA9IF9zY3JvbGxQb3M7XG5cdFx0XHRcdC8vIHVwZGF0ZSBzY3JvbGwgcG9zIG5vdyBpbnN0ZWFkIG9mIG9uQ2hhbmdlLCBhcyBpdCBtaWdodCBoYXZlIGNoYW5nZWQgc2luY2Ugc2NoZWR1bGluZyAoaS5lLiBpbi1icm93c2VyIHNtb290aCBzY3JvbGwpXG5cdFx0XHRcdF9zY3JvbGxQb3MgPSBDb250cm9sbGVyLnNjcm9sbFBvcygpO1xuXHRcdFx0XHR2YXIgZGVsdGFTY3JvbGwgPSBfc2Nyb2xsUG9zIC0gb2xkU2Nyb2xsUG9zO1xuXHRcdFx0XHRpZiAoZGVsdGFTY3JvbGwgIT09IDApIHsgLy8gc2Nyb2xsIHBvc2l0aW9uIGNoYW5nZWQ/XG5cdFx0XHRcdFx0X3Njcm9sbERpcmVjdGlvbiA9IChkZWx0YVNjcm9sbCA+IDApID8gU0NST0xMX0RJUkVDVElPTl9GT1JXQVJEIDogU0NST0xMX0RJUkVDVElPTl9SRVZFUlNFO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHJldmVyc2Ugb3JkZXIgb2Ygc2NlbmVzIGlmIHNjcm9sbGluZyByZXZlcnNlXG5cdFx0XHRcdGlmIChfc2Nyb2xsRGlyZWN0aW9uID09PSBTQ1JPTExfRElSRUNUSU9OX1JFVkVSU0UpIHtcblx0XHRcdFx0XHRzY2VuZXNUb1VwZGF0ZS5yZXZlcnNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdXBkYXRlIHNjZW5lc1xuXHRcdFx0XHRzY2VuZXNUb1VwZGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChzY2VuZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRsb2coMywgXCJ1cGRhdGluZyBTY2VuZSBcIiArIChpbmRleCArIDEpICsgXCIvXCIgKyBzY2VuZXNUb1VwZGF0ZS5sZW5ndGggKyBcIiAoXCIgKyBfc2NlbmVPYmplY3RzLmxlbmd0aCArIFwiIHRvdGFsKVwiKTtcblx0XHRcdFx0XHRzY2VuZS51cGRhdGUodHJ1ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoc2NlbmVzVG9VcGRhdGUubGVuZ3RoID09PSAwICYmIF9vcHRpb25zLmxvZ2xldmVsID49IDMpIHtcblx0XHRcdFx0XHRsb2coMywgXCJ1cGRhdGluZyAwIFNjZW5lcyAobm90aGluZyBhZGRlZCB0byBjb250cm9sbGVyKVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplcyByQUYgY2FsbGJhY2tcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciBkZWJvdW5jZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdF91cGRhdGVUaW1lb3V0ID0gX3V0aWwuckFGKHVwZGF0ZVNjZW5lcyk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXMgQ29udGFpbmVyIGNoYW5nZXNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciBvbkNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRsb2coMywgXCJldmVudCBmaXJlZCBjYXVzaW5nIGFuIHVwZGF0ZTpcIiwgZS50eXBlKTtcblx0XHRcdGlmIChlLnR5cGUgPT0gXCJyZXNpemVcIikge1xuXHRcdFx0XHQvLyByZXNpemVcblx0XHRcdFx0X3ZpZXdQb3J0U2l6ZSA9IGdldFZpZXdwb3J0U2l6ZSgpO1xuXHRcdFx0XHRfc2Nyb2xsRGlyZWN0aW9uID0gU0NST0xMX0RJUkVDVElPTl9QQVVTRUQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBzY2hlZHVsZSB1cGRhdGVcblx0XHRcdGlmIChfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUgIT09IHRydWUpIHtcblx0XHRcdFx0X3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlID0gdHJ1ZTtcblx0XHRcdFx0ZGVib3VuY2VVcGRhdGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIHJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIV9pc0RvY3VtZW50KSB7XG5cdFx0XHRcdC8vIHNpbXVsYXRlIHJlc2l6ZSBldmVudC4gT25seSB3b3JrcyBmb3Igdmlld3BvcnQgcmVsZXZhbnQgcGFyYW0gKHBlcmZvcm1hbmNlKVxuXHRcdFx0XHRpZiAoX3ZpZXdQb3J0U2l6ZSAhPSBnZXRWaWV3cG9ydFNpemUoKSkge1xuXHRcdFx0XHRcdHZhciByZXNpemVFdmVudDtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cmVzaXplRXZlbnQgPSBuZXcgRXZlbnQoJ3Jlc2l6ZScsIHtcblx0XHRcdFx0XHRcdFx0YnViYmxlczogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdGNhbmNlbGFibGU6IGZhbHNlXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7IC8vIHN0dXBpZCBJRVxuXHRcdFx0XHRcdFx0cmVzaXplRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuXHRcdFx0XHRcdFx0cmVzaXplRXZlbnQuaW5pdEV2ZW50KFwicmVzaXplXCIsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9vcHRpb25zLmNvbnRhaW5lci5kaXNwYXRjaEV2ZW50KHJlc2l6ZUV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0X3NjZW5lT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChzY2VuZSwgaW5kZXgpIHsgLy8gcmVmcmVzaCBhbGwgc2NlbmVzXG5cdFx0XHRcdHNjZW5lLnJlZnJlc2goKTtcblx0XHRcdH0pO1xuXHRcdFx0c2NoZWR1bGVSZWZyZXNoKCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFNlbmQgYSBkZWJ1ZyBtZXNzYWdlIHRvIHRoZSBjb25zb2xlLlxuXHRcdCAqIHByb3ZpZGVkIHB1YmxpY2x5IHdpdGggX2xvZyBmb3IgcGx1Z2luc1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gbG9nbGV2ZWwgLSBUaGUgbG9nbGV2ZWwgcmVxdWlyZWQgdG8gaW5pdGlhdGUgb3V0cHV0IGZvciB0aGUgbWVzc2FnZS5cblx0XHQgKiBAcGFyYW0gey4uLm1peGVkfSBvdXRwdXQgLSBPbmUgb3IgbW9yZSB2YXJpYWJsZXMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBjb25zb2xlLlxuXHRcdCAqL1xuXHRcdHZhciBsb2cgPSB0aGlzLl9sb2cgPSBmdW5jdGlvbiAobG9nbGV2ZWwsIG91dHB1dCkge1xuXHRcdFx0aWYgKF9vcHRpb25zLmxvZ2xldmVsID49IGxvZ2xldmVsKSB7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDEsIDAsIFwiKFwiICsgTkFNRVNQQUNFICsgXCIpIC0+XCIpO1xuXHRcdFx0XHRfdXRpbC5sb2cuYXBwbHkod2luZG93LCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Ly8gZm9yIHNjZW5lcyB3ZSBoYXZlIGdldHRlcnMgZm9yIGVhY2ggb3B0aW9uLCBidXQgZm9yIHRoZSBjb250cm9sbGVyIHdlIGRvbid0LCBzbyB3ZSBuZWVkIHRvIG1ha2UgaXQgYXZhaWxhYmxlIGV4dGVybmFsbHkgZm9yIHBsdWdpbnNcblx0XHR0aGlzLl9vcHRpb25zID0gX29wdGlvbnM7XG5cblx0XHQvKipcblx0XHQgKiBTb3J0IHNjZW5lcyBpbiBhc2NlbmRpbmcgb3JkZXIgb2YgdGhlaXIgc3RhcnQgb2Zmc2V0LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2FycmF5fSBTY2VuZXNBcnJheSAtIGFuIGFycmF5IG9mIFNjcm9sbE1hZ2ljIFNjZW5lcyB0aGF0IHNob3VsZCBiZSBzb3J0ZWRcblx0XHQgKiBAcmV0dXJuIHthcnJheX0gVGhlIHNvcnRlZCBhcnJheSBvZiBTY2VuZXMuXG5cdFx0ICovXG5cdFx0dmFyIHNvcnRTY2VuZXMgPSBmdW5jdGlvbiAoU2NlbmVzQXJyYXkpIHtcblx0XHRcdGlmIChTY2VuZXNBcnJheS5sZW5ndGggPD0gMSkge1xuXHRcdFx0XHRyZXR1cm4gU2NlbmVzQXJyYXk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc2NlbmVzID0gU2NlbmVzQXJyYXkuc2xpY2UoMCk7XG5cdFx0XHRcdHNjZW5lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEuc2Nyb2xsT2Zmc2V0KCkgPiBiLnNjcm9sbE9mZnNldCgpID8gMSA6IC0xO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHNjZW5lcztcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqIHB1YmxpYyBmdW5jdGlvbnNcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBBZGQgb25lIG9yZSBtb3JlIHNjZW5lKHMpIHRvIHRoZSBjb250cm9sbGVyLiAgXG5cdFx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCB0byBgU2NlbmUuYWRkVG8oY29udHJvbGxlcilgLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHdpdGggYSBwcmV2aW91c2x5IGRlZmluZWQgc2NlbmVcblx0XHQgKiBjb250cm9sbGVyLmFkZFNjZW5lKHNjZW5lKTtcblx0XHQgKlxuXHRcdCAqIC8vIHdpdGggYSBuZXdseSBjcmVhdGVkIHNjZW5lLlxuXHRcdCAqIGNvbnRyb2xsZXIuYWRkU2NlbmUobmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtkdXJhdGlvbiA6IDB9KSk7XG5cdFx0ICpcblx0XHQgKiAvLyBhZGRpbmcgbXVsdGlwbGUgc2NlbmVzXG5cdFx0ICogY29udHJvbGxlci5hZGRTY2VuZShbc2NlbmUsIHNjZW5lMiwgbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtkdXJhdGlvbiA6IDB9KV0pO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsoU2Nyb2xsTWFnaWMuU2NlbmV8YXJyYXkpfSBuZXdTY2VuZSAtIFNjcm9sbE1hZ2ljIFNjZW5lIG9yIEFycmF5IG9mIFNjZW5lcyB0byBiZSBhZGRlZCB0byB0aGUgY29udHJvbGxlci5cblx0XHQgKiBAcmV0dXJuIHtDb250cm9sbGVyfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLmFkZFNjZW5lID0gZnVuY3Rpb24gKG5ld1NjZW5lKSB7XG5cdFx0XHRpZiAoX3V0aWwudHlwZS5BcnJheShuZXdTY2VuZSkpIHtcblx0XHRcdFx0bmV3U2NlbmUuZm9yRWFjaChmdW5jdGlvbiAoc2NlbmUsIGluZGV4KSB7XG5cdFx0XHRcdFx0Q29udHJvbGxlci5hZGRTY2VuZShzY2VuZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIGlmIChuZXdTY2VuZSBpbnN0YW5jZW9mIFNjcm9sbE1hZ2ljLlNjZW5lKSB7XG5cdFx0XHRcdGlmIChuZXdTY2VuZS5jb250cm9sbGVyKCkgIT09IENvbnRyb2xsZXIpIHtcblx0XHRcdFx0XHRuZXdTY2VuZS5hZGRUbyhDb250cm9sbGVyKTtcblx0XHRcdFx0fSBlbHNlIGlmIChfc2NlbmVPYmplY3RzLmluZGV4T2YobmV3U2NlbmUpIDwgMCkge1xuXHRcdFx0XHRcdC8vIG5ldyBzY2VuZVxuXHRcdFx0XHRcdF9zY2VuZU9iamVjdHMucHVzaChuZXdTY2VuZSk7IC8vIGFkZCB0byBhcnJheVxuXHRcdFx0XHRcdF9zY2VuZU9iamVjdHMgPSBzb3J0U2NlbmVzKF9zY2VuZU9iamVjdHMpOyAvLyBzb3J0XG5cdFx0XHRcdFx0bmV3U2NlbmUub24oXCJzaGlmdC5jb250cm9sbGVyX3NvcnRcIiwgZnVuY3Rpb24gKCkgeyAvLyByZXNvcnQgd2hlbmV2ZXIgc2NlbmUgbW92ZXNcblx0XHRcdFx0XHRcdF9zY2VuZU9iamVjdHMgPSBzb3J0U2NlbmVzKF9zY2VuZU9iamVjdHMpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdC8vIGluc2VydCBHbG9iYWwgZGVmYXVsdHMuXG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIF9vcHRpb25zLmdsb2JhbFNjZW5lT3B0aW9ucykge1xuXHRcdFx0XHRcdFx0aWYgKG5ld1NjZW5lW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0bmV3U2NlbmVba2V5XS5jYWxsKG5ld1NjZW5lLCBfb3B0aW9ucy5nbG9iYWxTY2VuZU9wdGlvbnNba2V5XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxvZygzLCBcImFkZGluZyBTY2VuZSAobm93IFwiICsgX3NjZW5lT2JqZWN0cy5sZW5ndGggKyBcIiB0b3RhbClcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvZygxLCBcIkVSUk9SOiBpbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIGZvciAnLmFkZFNjZW5lKCknXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIENvbnRyb2xsZXI7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBvbmUgb3JlIG1vcmUgc2NlbmUocykgZnJvbSB0aGUgY29udHJvbGxlci4gIFxuXHRcdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgdG8gYFNjZW5lLnJlbW92ZSgpYC5cblx0XHQgKiBAcHVibGljXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyByZW1vdmUgYSBzY2VuZSBmcm9tIHRoZSBjb250cm9sbGVyXG5cdFx0ICogY29udHJvbGxlci5yZW1vdmVTY2VuZShzY2VuZSk7XG5cdFx0ICpcblx0XHQgKiAvLyByZW1vdmUgbXVsdGlwbGUgc2NlbmVzIGZyb20gdGhlIGNvbnRyb2xsZXJcblx0XHQgKiBjb250cm9sbGVyLnJlbW92ZVNjZW5lKFtzY2VuZSwgc2NlbmUyLCBzY2VuZTNdKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7KFNjcm9sbE1hZ2ljLlNjZW5lfGFycmF5KX0gU2NlbmUgLSBTY3JvbGxNYWdpYyBTY2VuZSBvciBBcnJheSBvZiBTY2VuZXMgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBjb250cm9sbGVyLlxuXHRcdCAqIEByZXR1cm5zIHtDb250cm9sbGVyfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnJlbW92ZVNjZW5lID0gZnVuY3Rpb24gKFNjZW5lKSB7XG5cdFx0XHRpZiAoX3V0aWwudHlwZS5BcnJheShTY2VuZSkpIHtcblx0XHRcdFx0U2NlbmUuZm9yRWFjaChmdW5jdGlvbiAoc2NlbmUsIGluZGV4KSB7XG5cdFx0XHRcdFx0Q29udHJvbGxlci5yZW1vdmVTY2VuZShzY2VuZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gX3NjZW5lT2JqZWN0cy5pbmRleE9mKFNjZW5lKTtcblx0XHRcdFx0aWYgKGluZGV4ID4gLTEpIHtcblx0XHRcdFx0XHRTY2VuZS5vZmYoXCJzaGlmdC5jb250cm9sbGVyX3NvcnRcIik7XG5cdFx0XHRcdFx0X3NjZW5lT2JqZWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGxvZygzLCBcInJlbW92aW5nIFNjZW5lIChub3cgXCIgKyBfc2NlbmVPYmplY3RzLmxlbmd0aCArIFwiIGxlZnQpXCIpO1xuXHRcdFx0XHRcdFNjZW5lLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQ29udHJvbGxlcjtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIG9uZSBvcmUgbW9yZSBzY2VuZShzKSBhY2NvcmRpbmcgdG8gdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyLiAgXG5cdFx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCB0byBgU2NlbmUudXBkYXRlKClgLiAgXG5cdFx0ICogVGhlIHVwZGF0ZSBtZXRob2QgY2FsY3VsYXRlcyB0aGUgc2NlbmUncyBzdGFydCBhbmQgZW5kIHBvc2l0aW9uIChiYXNlZCBvbiB0aGUgdHJpZ2dlciBlbGVtZW50LCB0cmlnZ2VyIGhvb2ssIGR1cmF0aW9uIGFuZCBvZmZzZXQpIGFuZCBjaGVja3MgaXQgYWdhaW5zdCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lci4gIFxuXHRcdCAqIEl0IHRoZW4gdXBkYXRlcyB0aGUgY3VycmVudCBzY2VuZSBzdGF0ZSBhY2NvcmRpbmdseSAob3IgZG9lcyBub3RoaW5nLCBpZiB0aGUgc3RhdGUgaXMgYWxyZWFkeSBjb3JyZWN0KSDigJMgUGlucyB3aWxsIGJlIHNldCB0byB0aGVpciBjb3JyZWN0IHBvc2l0aW9uIGFuZCB0d2VlbnMgd2lsbCBiZSB1cGRhdGVkIHRvIHRoZWlyIGNvcnJlY3QgcHJvZ3Jlc3MuICBcblx0XHQgKiBfKipOb3RlOioqIFRoaXMgbWV0aG9kIGdldHMgY2FsbGVkIGNvbnN0YW50bHkgd2hlbmV2ZXIgQ29udHJvbGxlciBkZXRlY3RzIGEgY2hhbmdlLiBUaGUgb25seSBhcHBsaWNhdGlvbiBmb3IgeW91IGlzIGlmIHlvdSBjaGFuZ2Ugc29tZXRoaW5nIG91dHNpZGUgb2YgdGhlIHJlYWxtIG9mIFNjcm9sbE1hZ2ljLCBsaWtlIG1vdmluZyB0aGUgdHJpZ2dlciBvciBjaGFuZ2luZyB0d2VlbiBwYXJhbWV0ZXJzLl9cblx0XHQgKiBAcHVibGljXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyB1cGRhdGUgYSBzcGVjaWZpYyBzY2VuZSBvbiBuZXh0IGN5Y2xlXG5cdFx0ICogY29udHJvbGxlci51cGRhdGVTY2VuZShzY2VuZSk7XG5cdFx0ICpcblx0XHQgKiAvLyB1cGRhdGUgYSBzcGVjaWZpYyBzY2VuZSBpbW1lZGlhdGVseVxuXHRcdCAqIGNvbnRyb2xsZXIudXBkYXRlU2NlbmUoc2NlbmUsIHRydWUpO1xuXHRcdCAqXG5cdFx0ICogLy8gdXBkYXRlIG11bHRpcGxlIHNjZW5lcyBzY2VuZSBvbiBuZXh0IGN5Y2xlXG5cdFx0ICogY29udHJvbGxlci51cGRhdGVTY2VuZShbc2NlbmUxLCBzY2VuZTIsIHNjZW5lM10pO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTY3JvbGxNYWdpYy5TY2VuZX0gU2NlbmUgLSBTY3JvbGxNYWdpYyBTY2VuZSBvciBBcnJheSBvZiBTY2VuZXMgdGhhdCBpcy9hcmUgc3VwcG9zZWQgdG8gYmUgdXBkYXRlZC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbW1lZGlhdGVseT1mYWxzZV0gLSBJZiBgdHJ1ZWAgdGhlIHVwZGF0ZSB3aWxsIGJlIGluc3RhbnQsIGlmIGBmYWxzZWAgaXQgd2lsbCB3YWl0IHVudGlsIG5leHQgdXBkYXRlIGN5Y2xlLiAgXG5cdFx0IFRoaXMgaXMgdXNlZnVsIHdoZW4gY2hhbmdpbmcgbXVsdGlwbGUgcHJvcGVydGllcyBvZiB0aGUgc2NlbmUgLSB0aGlzIHdheSBpdCB3aWxsIG9ubHkgYmUgdXBkYXRlZCBvbmNlIGFsbCBuZXcgcHJvcGVydGllcyBhcmUgc2V0ICh1cGRhdGVTY2VuZXMpLlxuXHRcdCAqIEByZXR1cm4ge0NvbnRyb2xsZXJ9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMudXBkYXRlU2NlbmUgPSBmdW5jdGlvbiAoU2NlbmUsIGltbWVkaWF0ZWx5KSB7XG5cdFx0XHRpZiAoX3V0aWwudHlwZS5BcnJheShTY2VuZSkpIHtcblx0XHRcdFx0U2NlbmUuZm9yRWFjaChmdW5jdGlvbiAoc2NlbmUsIGluZGV4KSB7XG5cdFx0XHRcdFx0Q29udHJvbGxlci51cGRhdGVTY2VuZShzY2VuZSwgaW1tZWRpYXRlbHkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChpbW1lZGlhdGVseSkge1xuXHRcdFx0XHRcdFNjZW5lLnVwZGF0ZSh0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUgIT09IHRydWUgJiYgU2NlbmUgaW5zdGFuY2VvZiBTY3JvbGxNYWdpYy5TY2VuZSkgeyAvLyBpZiBfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUgaXMgdHJ1ZSwgYWxsIGNvbm5lY3RlZCBzY2VuZXMgYXJlIGFscmVhZHkgc2NoZWR1bGVkIGZvciB1cGRhdGVcblx0XHRcdFx0XHQvLyBwcmVwIGFycmF5IGZvciBuZXh0IHVwZGF0ZSBjeWNsZVxuXHRcdFx0XHRcdF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSA9IF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSB8fCBbXTtcblx0XHRcdFx0XHRpZiAoX3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlLmluZGV4T2YoU2NlbmUpID09IC0xKSB7XG5cdFx0XHRcdFx0XHRfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUucHVzaChTY2VuZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSA9IHNvcnRTY2VuZXMoX3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlKTsgLy8gc29ydFxuXHRcdFx0XHRcdGRlYm91bmNlVXBkYXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBDb250cm9sbGVyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBjb250cm9sbGVyIHBhcmFtcyBhbmQgY2FsbHMgdXBkYXRlU2NlbmUgb24gZXZlcnkgc2NlbmUsIHRoYXQgaXMgYXR0YWNoZWQgdG8gdGhlIGNvbnRyb2xsZXIuICBcblx0XHQgKiBTZWUgYENvbnRyb2xsZXIudXBkYXRlU2NlbmUoKWAgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCB0aGlzIG1lYW5zLiAgXG5cdFx0ICogSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCBub3QgbmVlZCB0aGlzIGZ1bmN0aW9uLCBhcyBpdCBpcyBjYWxsZWQgY29uc3RhbnRseSwgd2hlbmV2ZXIgU2Nyb2xsTWFnaWMgZGV0ZWN0cyBhIHN0YXRlIGNoYW5nZSBldmVudCwgbGlrZSByZXNpemUgb3Igc2Nyb2xsLiAgXG5cdFx0ICogVGhlIG9ubHkgYXBwbGljYXRpb24gZm9yIHRoaXMgbWV0aG9kIGlzIHdoZW4gU2Nyb2xsTWFnaWMgZmFpbHMgdG8gZGV0ZWN0IHRoZXNlIGV2ZW50cy4gIFxuXHRcdCAqIE9uZSBhcHBsaWNhdGlvbiBpcyB3aXRoIHNvbWUgZXh0ZXJuYWwgc2Nyb2xsIGxpYnJhcmllcyAobGlrZSBpU2Nyb2xsKSB0aGF0IG1vdmUgYW4gaW50ZXJuYWwgY29udGFpbmVyIHRvIGEgbmVnYXRpdmUgb2Zmc2V0IGluc3RlYWQgb2YgYWN0dWFsbHkgc2Nyb2xsaW5nLiBJbiB0aGlzIGNhc2UgdGhlIHVwZGF0ZSBvbiB0aGUgY29udHJvbGxlciBuZWVkcyB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIGNoaWxkIGNvbnRhaW5lcidzIHBvc2l0aW9uIGNoYW5nZXMuXG5cdFx0ICogRm9yIHRoaXMgY2FzZSB0aGVyZSB3aWxsIGFsc28gYmUgdGhlIG5lZWQgdG8gcHJvdmlkZSBhIGN1c3RvbSBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3Qgc2Nyb2xsIHBvc2l0aW9uLiBTZWUgYENvbnRyb2xsZXIuc2Nyb2xsUG9zKClgIGZvciBkZXRhaWxzLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHVwZGF0ZSB0aGUgY29udHJvbGxlciBvbiBuZXh0IGN5Y2xlIChzYXZlcyBwZXJmb3JtYW5jZSBkdWUgdG8gZWxpbWluYXRpb24gb2YgcmVkdW5kYW50IHVwZGF0ZXMpXG5cdFx0ICogY29udHJvbGxlci51cGRhdGUoKTtcblx0XHQgKlxuXHRcdCAqIC8vIHVwZGF0ZSB0aGUgY29udHJvbGxlciBpbW1lZGlhdGVseVxuXHRcdCAqIGNvbnRyb2xsZXIudXBkYXRlKHRydWUpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbaW1tZWRpYXRlbHk9ZmFsc2VdIC0gSWYgYHRydWVgIHRoZSB1cGRhdGUgd2lsbCBiZSBpbnN0YW50LCBpZiBgZmFsc2VgIGl0IHdpbGwgd2FpdCB1bnRpbCBuZXh0IHVwZGF0ZSBjeWNsZSAoYmV0dGVyIHBlcmZvcm1hbmNlKVxuXHRcdCAqIEByZXR1cm4ge0NvbnRyb2xsZXJ9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKGltbWVkaWF0ZWx5KSB7XG5cdFx0XHRvbkNoYW5nZSh7XG5cdFx0XHRcdHR5cGU6IFwicmVzaXplXCJcblx0XHRcdH0pOyAvLyB3aWxsIHVwZGF0ZSBzaXplIGFuZCBzZXQgX3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlIHRvIHRydWVcblx0XHRcdGlmIChpbW1lZGlhdGVseSkge1xuXHRcdFx0XHR1cGRhdGVTY2VuZXMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBDb250cm9sbGVyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBTY3JvbGwgdG8gYSBudW1lcmljIHNjcm9sbCBvZmZzZXQsIGEgRE9NIGVsZW1lbnQsIHRoZSBzdGFydCBvZiBhIHNjZW5lIG9yIHByb3ZpZGUgYW4gYWx0ZXJuYXRlIG1ldGhvZCBmb3Igc2Nyb2xsaW5nLiAgXG5cdFx0ICogRm9yIHZlcnRpY2FsIGNvbnRyb2xsZXJzIGl0IHdpbGwgY2hhbmdlIHRoZSB0b3Agc2Nyb2xsIG9mZnNldCBhbmQgZm9yIGhvcml6b250YWwgYXBwbGljYXRpb25zIGl0IHdpbGwgY2hhbmdlIHRoZSBsZWZ0IG9mZnNldC5cblx0XHQgKiBAcHVibGljXG5cdFx0ICpcblx0XHQgKiBAc2luY2UgMS4xLjBcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHNjcm9sbCB0byBhbiBvZmZzZXQgb2YgMTAwXG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxUbygxMDApO1xuXHRcdCAqXG5cdFx0ICogLy8gc2Nyb2xsIHRvIGEgRE9NIGVsZW1lbnRcblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFRvKFwiI2FuY2hvclwiKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNjcm9sbCB0byB0aGUgYmVnaW5uaW5nIG9mIGEgc2NlbmVcblx0XHQgKiB2YXIgc2NlbmUgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe29mZnNldDogMjAwfSk7XG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxUbyhzY2VuZSk7XG5cdFx0ICpcblx0XHQgKiAvLyBkZWZpbmUgYSBuZXcgc2Nyb2xsIHBvc2l0aW9uIG1vZGlmaWNhdGlvbiBmdW5jdGlvbiAoalF1ZXJ5IGFuaW1hdGUgaW5zdGVhZCBvZiBqdW1wKVxuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsVG8oZnVuY3Rpb24gKG5ld1Njcm9sbFBvcykge1xuXHRcdCAqXHQkKFwiaHRtbCwgYm9keVwiKS5hbmltYXRlKHtzY3JvbGxUb3A6IG5ld1Njcm9sbFBvc30pO1xuXHRcdCAqIH0pO1xuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsVG8oMTAwKTsgLy8gY2FsbCBhcyB1c3VhbCwgYnV0IHRoZSBuZXcgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGluc3RlYWRcblx0XHQgKlxuXHRcdCAqIC8vIGRlZmluZSBhIG5ldyBzY3JvbGwgZnVuY3Rpb24gd2l0aCBhbiBhZGRpdGlvbmFsIHBhcmFtZXRlclxuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsVG8oZnVuY3Rpb24gKG5ld1Njcm9sbFBvcywgbWVzc2FnZSkge1xuXHRcdCAqICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcblx0XHQgKlx0JCh0aGlzKS5hbmltYXRlKHtzY3JvbGxUb3A6IG5ld1Njcm9sbFBvc30pO1xuXHRcdCAqIH0pO1xuXHRcdCAqIC8vIGNhbGwgYXMgdXN1YWwsIGJ1dCBzdXBwbHkgYW4gZXh0cmEgcGFyYW1ldGVyIHRvIHRoZSBkZWZpbmVkIGN1c3RvbSBmdW5jdGlvblxuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsVG8oMTAwLCBcIm15IG1lc3NhZ2VcIik7XG5cdFx0ICpcblx0XHQgKiAvLyBkZWZpbmUgYSBuZXcgc2Nyb2xsIGZ1bmN0aW9uIHdpdGggYW4gYWRkaXRpb25hbCBwYXJhbWV0ZXIgY29udGFpbmluZyBtdWx0aXBsZSB2YXJpYWJsZXNcblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFRvKGZ1bmN0aW9uIChuZXdTY3JvbGxQb3MsIG9wdGlvbnMpIHtcblx0XHQgKiAgc29tZUdsb2JhbFZhciA9IG9wdGlvbnMuYSArIG9wdGlvbnMuYjtcblx0XHQgKlx0JCh0aGlzKS5hbmltYXRlKHtzY3JvbGxUb3A6IG5ld1Njcm9sbFBvc30pO1xuXHRcdCAqIH0pO1xuXHRcdCAqIC8vIGNhbGwgYXMgdXN1YWwsIGJ1dCBzdXBwbHkgYW4gZXh0cmEgcGFyYW1ldGVyIGNvbnRhaW5pbmcgbXVsdGlwbGUgb3B0aW9uc1xuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsVG8oMTAwLCB7YTogMSwgYjogMn0pO1xuXHRcdCAqXG5cdFx0ICogLy8gZGVmaW5lIGEgbmV3IHNjcm9sbCBmdW5jdGlvbiB3aXRoIGEgY2FsbGJhY2sgc3VwcGxpZWQgYXMgYW4gYWRkaXRpb25hbCBwYXJhbWV0ZXJcblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFRvKGZ1bmN0aW9uIChuZXdTY3JvbGxQb3MsIGNhbGxiYWNrKSB7XG5cdFx0ICpcdCQodGhpcykuYW5pbWF0ZSh7c2Nyb2xsVG9wOiBuZXdTY3JvbGxQb3N9LCA0MDAsIFwic3dpbmdcIiwgY2FsbGJhY2spO1xuXHRcdCAqIH0pO1xuXHRcdCAqIC8vIGNhbGwgYXMgdXN1YWwsIGJ1dCBzdXBwbHkgYW4gZXh0cmEgcGFyYW1ldGVyLCB3aGljaCBpcyB1c2VkIGFzIGEgY2FsbGJhY2sgaW4gdGhlIHByZXZpb3VzbHkgZGVmaW5lZCBjdXN0b20gc2Nyb2xsIGZ1bmN0aW9uXG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxUbygxMDAsIGZ1bmN0aW9uKCkge1xuXHRcdCAqXHRjb25zb2xlLmxvZyhcInNjcm9sbCBoYXMgZmluaXNoZWQuXCIpO1xuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gc2Nyb2xsVGFyZ2V0IC0gVGhlIHN1cHBsaWVkIGFyZ3VtZW50IGNhbiBiZSBvbmUgb2YgdGhlc2UgdHlwZXM6XG5cdFx0ICogMS4gYG51bWJlcmAgLT4gVGhlIGNvbnRhaW5lciB3aWxsIHNjcm9sbCB0byB0aGlzIG5ldyBzY3JvbGwgb2Zmc2V0LlxuXHRcdCAqIDIuIGBzdHJpbmdgIG9yIGBvYmplY3RgIC0+IENhbiBiZSBhIHNlbGVjdG9yIG9yIGEgRE9NIG9iamVjdC4gIFxuXHRcdCAqICBUaGUgY29udGFpbmVyIHdpbGwgc2Nyb2xsIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnQuXG5cdFx0ICogMy4gYFNjcm9sbE1hZ2ljIFNjZW5lYCAtPiBUaGUgY29udGFpbmVyIHdpbGwgc2Nyb2xsIHRvIHRoZSBzdGFydCBvZiB0aGlzIHNjZW5lLlxuXHRcdCAqIDQuIGBmdW5jdGlvbmAgLT4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGZ1dHVyZSBzY3JvbGwgcG9zaXRpb24gbW9kaWZpY2F0aW9ucy4gIFxuXHRcdCAqICBUaGlzIHByb3ZpZGVzIGEgd2F5IGZvciB5b3UgdG8gY2hhbmdlIHRoZSBiZWhhdmlvdXIgb2Ygc2Nyb2xsaW5nIGFuZCBhZGRpbmcgbmV3IGJlaGF2aW91ciBsaWtlIGFuaW1hdGlvbi4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBuZXcgc2Nyb2xsIHBvc2l0aW9uIGFzIGEgcGFyYW1ldGVyIGFuZCBhIHJlZmVyZW5jZSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnQgdXNpbmcgYHRoaXNgLiAgXG5cdFx0ICogIEl0IG1heSBhbHNvIG9wdGlvbmFsbHkgcmVjZWl2ZSBhbiBvcHRpb25hbCBhZGRpdGlvbmFsIHBhcmFtZXRlciAoc2VlIGJlbG93KSAgXG5cdFx0ICogIF8qKk5PVEU6KiogIFxuXHRcdCAqICBBbGwgb3RoZXIgb3B0aW9ucyB3aWxsIHN0aWxsIHdvcmsgYXMgZXhwZWN0ZWQsIHVzaW5nIHRoZSBuZXcgZnVuY3Rpb24gdG8gc2Nyb2xsLl9cblx0XHQgKiBAcGFyYW0ge21peGVkfSBbYWRkaXRpb25hbFBhcmFtZXRlcl0gLSBJZiBhIGN1c3RvbSBzY3JvbGwgZnVuY3Rpb24gd2FzIGRlZmluZWQgKHNlZSBhYm92ZSA0LiksIHlvdSBtYXkgd2FudCB0byBzdXBwbHkgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGl0LCB3aGVuIGNhbGxpbmcgaXQuIFlvdSBjYW4gZG8gdGhpcyB1c2luZyB0aGlzIHBhcmFtZXRlciDigJMgc2VlIGV4YW1wbGVzIGZvciBkZXRhaWxzLiBQbGVhc2Ugbm90ZSwgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGhhdmUgbm8gZWZmZWN0LCBpZiB5b3UgdXNlIHRoZSBkZWZhdWx0IHNjcm9sbGluZyBmdW5jdGlvbi5cblx0XHQgKiBAcmV0dXJucyB7Q29udHJvbGxlcn0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5zY3JvbGxUbyA9IGZ1bmN0aW9uIChzY3JvbGxUYXJnZXQsIGFkZGl0aW9uYWxQYXJhbWV0ZXIpIHtcblx0XHRcdGlmIChfdXRpbC50eXBlLk51bWJlcihzY3JvbGxUYXJnZXQpKSB7IC8vIGV4Y2VjdXRlXG5cdFx0XHRcdHNldFNjcm9sbFBvcy5jYWxsKF9vcHRpb25zLmNvbnRhaW5lciwgc2Nyb2xsVGFyZ2V0LCBhZGRpdGlvbmFsUGFyYW1ldGVyKTtcblx0XHRcdH0gZWxzZSBpZiAoc2Nyb2xsVGFyZ2V0IGluc3RhbmNlb2YgU2Nyb2xsTWFnaWMuU2NlbmUpIHsgLy8gc2Nyb2xsIHRvIHNjZW5lXG5cdFx0XHRcdGlmIChzY3JvbGxUYXJnZXQuY29udHJvbGxlcigpID09PSBDb250cm9sbGVyKSB7IC8vIGNoZWNrIGlmIHRoZSBjb250cm9sbGVyIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNjZW5lXG5cdFx0XHRcdFx0Q29udHJvbGxlci5zY3JvbGxUbyhzY3JvbGxUYXJnZXQuc2Nyb2xsT2Zmc2V0KCksIGFkZGl0aW9uYWxQYXJhbWV0ZXIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxvZygyLCBcInNjcm9sbFRvKCk6IFRoZSBzdXBwbGllZCBzY2VuZSBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBjb250cm9sbGVyLiBTY3JvbGwgY2FuY2VsbGVkLlwiLCBzY3JvbGxUYXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKF91dGlsLnR5cGUuRnVuY3Rpb24oc2Nyb2xsVGFyZ2V0KSkgeyAvLyBhc3NpZ24gbmV3IHNjcm9sbCBmdW5jdGlvblxuXHRcdFx0XHRzZXRTY3JvbGxQb3MgPSBzY3JvbGxUYXJnZXQ7XG5cdFx0XHR9IGVsc2UgeyAvLyBzY3JvbGwgdG8gZWxlbWVudFxuXHRcdFx0XHR2YXIgZWxlbSA9IF91dGlsLmdldC5lbGVtZW50cyhzY3JvbGxUYXJnZXQpWzBdO1xuXHRcdFx0XHRpZiAoZWxlbSkge1xuXHRcdFx0XHRcdC8vIGlmIHBhcmVudCBpcyBwaW4gc3BhY2VyLCB1c2Ugc3BhY2VyIHBvc2l0aW9uIGluc3RlYWQgc28gY29ycmVjdCBzdGFydCBwb3NpdGlvbiBpcyByZXR1cm5lZCBmb3IgcGlubmVkIGVsZW1lbnRzLlxuXHRcdFx0XHRcdHdoaWxlIChlbGVtLnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKFBJTl9TUEFDRVJfQVRUUklCVVRFKSkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRwYXJhbSA9IF9vcHRpb25zLnZlcnRpY2FsID8gXCJ0b3BcIiA6IFwibGVmdFwiLFxuXHRcdFx0XHRcdFx0Ly8gd2hpY2ggcGFyYW0gaXMgb2YgaW50ZXJlc3QgP1xuXHRcdFx0XHRcdFx0Y29udGFpbmVyT2Zmc2V0ID0gX3V0aWwuZ2V0Lm9mZnNldChfb3B0aW9ucy5jb250YWluZXIpLFxuXHRcdFx0XHRcdFx0Ly8gY29udGFpbmVyIHBvc2l0aW9uIGlzIG5lZWRlZCBiZWNhdXNlIGVsZW1lbnQgb2Zmc2V0IGlzIHJldHVybmVkIGluIHJlbGF0aW9uIHRvIGRvY3VtZW50LCBub3QgaW4gcmVsYXRpb24gdG8gY29udGFpbmVyLlxuXHRcdFx0XHRcdFx0ZWxlbWVudE9mZnNldCA9IF91dGlsLmdldC5vZmZzZXQoZWxlbSk7XG5cblx0XHRcdFx0XHRpZiAoIV9pc0RvY3VtZW50KSB7IC8vIGNvbnRhaW5lciBpcyBub3QgdGhlIGRvY3VtZW50IHJvb3QsIHNvIHN1YnN0cmFjdCBzY3JvbGwgUG9zaXRpb24gdG8gZ2V0IGNvcnJlY3QgdHJpZ2dlciBlbGVtZW50IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHNjcm9sbGNvbnRlbnRcblx0XHRcdFx0XHRcdGNvbnRhaW5lck9mZnNldFtwYXJhbV0gLT0gQ29udHJvbGxlci5zY3JvbGxQb3MoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRDb250cm9sbGVyLnNjcm9sbFRvKGVsZW1lbnRPZmZzZXRbcGFyYW1dIC0gY29udGFpbmVyT2Zmc2V0W3BhcmFtXSwgYWRkaXRpb25hbFBhcmFtZXRlcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bG9nKDIsIFwic2Nyb2xsVG8oKTogVGhlIHN1cHBsaWVkIGFyZ3VtZW50IGlzIGludmFsaWQuIFNjcm9sbCBjYW5jZWxsZWQuXCIsIHNjcm9sbFRhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBDb250cm9sbGVyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIHRoZSBjdXJyZW50IHNjcm9sbFBvc2l0aW9uIG9yICoqU2V0KiogYSBuZXcgbWV0aG9kIHRvIGNhbGN1bGF0ZSBpdC4gIFxuXHRcdCAqIC0+ICoqR0VUKio6XG5cdFx0ICogV2hlbiB1c2VkIGFzIGEgZ2V0dGVyIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLiAgXG5cdFx0ICogVG8gZ2V0IGEgY2FjaGVkIHZhbHVlIHVzZSBDb250cm9sbGVyLmluZm8oXCJzY3JvbGxQb3NcIiksIHdoaWNoIHdpbGwgYmUgdXBkYXRlZCBpbiB0aGUgdXBkYXRlIGN5Y2xlLiAgXG5cdFx0ICogRm9yIHZlcnRpY2FsIGNvbnRyb2xsZXJzIGl0IHdpbGwgcmV0dXJuIHRoZSB0b3Agc2Nyb2xsIG9mZnNldCBhbmQgZm9yIGhvcml6b250YWwgYXBwbGljYXRpb25zIGl0IHdpbGwgcmV0dXJuIHRoZSBsZWZ0IG9mZnNldC5cblx0XHQgKlxuXHRcdCAqIC0+ICoqU0VUKio6XG5cdFx0ICogV2hlbiB1c2VkIGFzIGEgc2V0dGVyIHRoaXMgbWV0aG9kIHByb2RlcyBhIHdheSB0byBwZXJtYW5lbnRseSBvdmVyd3JpdGUgdGhlIGNvbnRyb2xsZXIncyBzY3JvbGwgcG9zaXRpb24gY2FsY3VsYXRpb24uICBcblx0XHQgKiBBIHR5cGljYWwgdXNlY2FzZSBpcyB3aGVuIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgbm90IHJlZmxlY3RlZCBieSB0aGUgY29udGFpbmVycyBzY3JvbGxUb3Agb3Igc2Nyb2xsTGVmdCB2YWx1ZXMsIGJ1dCBmb3IgZXhhbXBsZSBieSB0aGUgaW5uZXIgb2Zmc2V0IG9mIGEgY2hpbGQgY29udGFpbmVyLiAgXG5cdFx0ICogTW92aW5nIGEgY2hpbGQgY29udGFpbmVyIGluc2lkZSBhIHBhcmVudCBpcyBhIGNvbW1vbmx5IHVzZWQgbWV0aG9kIGZvciBzZXZlcmFsIHNjcm9sbGluZyBmcmFtZXdvcmtzLCBpbmNsdWRpbmcgaVNjcm9sbC4gIFxuXHRcdCAqIEJ5IHByb3ZpZGluZyBhbiBhbHRlcm5hdGUgY2FsY3VsYXRpb24gZnVuY3Rpb24geW91IGNhbiBtYWtlIHN1cmUgU2Nyb2xsTWFnaWMgcmVjZWl2ZXMgdGhlIGNvcnJlY3Qgc2Nyb2xsIHBvc2l0aW9uLiAgXG5cdFx0ICogUGxlYXNlIGFsc28gYmVhciBpbiBtaW5kIHRoYXQgeW91ciBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHkgdmFsdWVzIGZvciB2ZXJ0aWNhbCBzY3JvbGxzIGFuIHggZm9yIGhvcml6b250YWxzLlxuXHRcdCAqXG5cdFx0ICogVG8gY2hhbmdlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBwbGVhc2UgdXNlIGBDb250cm9sbGVyLnNjcm9sbFRvKClgLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IHNjcm9sbCBQb3NpdGlvblxuXHRcdCAqIHZhciBzY3JvbGxQb3MgPSBjb250cm9sbGVyLnNjcm9sbFBvcygpO1xuXHRcdCAqXG5cdFx0ICogLy8gc2V0IGEgbmV3IHNjcm9sbCBwb3NpdGlvbiBjYWxjdWxhdGlvbiBtZXRob2Rcblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFBvcyhmdW5jdGlvbiAoKSB7XG5cdFx0ICpcdHJldHVybiB0aGlzLmluZm8oXCJ2ZXJ0aWNhbFwiKSA/IC1teWNoaWxkY29udGFpbmVyLnkgOiAtbXljaGlsZGNvbnRhaW5lci54XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbc2Nyb2xsUG9zTWV0aG9kXSAtIFRoZSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciB0aGUgc2Nyb2xsIHBvc2l0aW9uIGNhbGN1bGF0aW9uIG9mIHRoZSBjb250YWluZXIuXG5cdFx0ICogQHJldHVybnMgeyhudW1iZXJ8Q29udHJvbGxlcil9IEN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9yIHBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMuc2Nyb2xsUG9zID0gZnVuY3Rpb24gKHNjcm9sbFBvc01ldGhvZCkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7IC8vIGdldFxuXHRcdFx0XHRyZXR1cm4gZ2V0U2Nyb2xsUG9zLmNhbGwoQ29udHJvbGxlcik7XG5cdFx0XHR9IGVsc2UgeyAvLyBzZXRcblx0XHRcdFx0aWYgKF91dGlsLnR5cGUuRnVuY3Rpb24oc2Nyb2xsUG9zTWV0aG9kKSkge1xuXHRcdFx0XHRcdGdldFNjcm9sbFBvcyA9IHNjcm9sbFBvc01ldGhvZDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2coMiwgXCJQcm92aWRlZCB2YWx1ZSBmb3IgbWV0aG9kICdzY3JvbGxQb3MnIGlzIG5vdCBhIGZ1bmN0aW9uLiBUbyBjaGFuZ2UgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHVzZSAnc2Nyb2xsVG8oKScuXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQ29udHJvbGxlcjtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiBhbGwgaW5mb3Mgb3Igb25lIGluIHBhcnRpY3VsYXIgYWJvdXQgdGhlIGNvbnRyb2xsZXIuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gcmV0dXJucyB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gKG51bWJlcilcblx0XHQgKiB2YXIgc2Nyb2xsUG9zID0gY29udHJvbGxlci5pbmZvKFwic2Nyb2xsUG9zXCIpO1xuXHRcdCAqXG5cdFx0ICogLy8gcmV0dXJucyBhbGwgaW5mb3MgYXMgYW4gb2JqZWN0XG5cdFx0ICogdmFyIGluZm9zID0gY29udHJvbGxlci5pbmZvKCk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW2Fib3V0XSAtIElmIHBhc3NlZCBvbmx5IHRoaXMgaW5mbyB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsLiAgXG5cdFx0IFZhbGlkIG9wdGlvbnMgYXJlOlxuXHRcdCAqKiBgXCJzaXplXCJgID0+IHRoZSBjdXJyZW50IHZpZXdwb3J0IHNpemUgb2YgdGhlIGNvbnRhaW5lclxuXHRcdCAqKiBgXCJ2ZXJ0aWNhbFwiYCA9PiB0cnVlIGlmIHZlcnRpY2FsIHNjcm9sbGluZywgb3RoZXJ3aXNlIGZhbHNlXG5cdFx0ICoqIGBcInNjcm9sbFBvc1wiYCA9PiB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cblx0XHQgKiogYFwic2Nyb2xsRGlyZWN0aW9uXCJgID0+IHRoZSBsYXN0IGtub3duIGRpcmVjdGlvbiBvZiB0aGUgc2Nyb2xsXG5cdFx0ICoqIGBcImNvbnRhaW5lclwiYCA9PiB0aGUgY29udGFpbmVyIGVsZW1lbnRcblx0XHQgKiogYFwiaXNEb2N1bWVudFwiYCA9PiB0cnVlIGlmIGNvbnRhaW5lciBlbGVtZW50IGlzIHRoZSBkb2N1bWVudC5cblx0XHQgKiBAcmV0dXJucyB7KG1peGVkfG9iamVjdCl9IFRoZSByZXF1ZXN0ZWQgaW5mbyhzKS5cblx0XHQgKi9cblx0XHR0aGlzLmluZm8gPSBmdW5jdGlvbiAoYWJvdXQpIHtcblx0XHRcdHZhciB2YWx1ZXMgPSB7XG5cdFx0XHRcdHNpemU6IF92aWV3UG9ydFNpemUsXG5cdFx0XHRcdC8vIGNvbnRhaW5zIGhlaWdodCBvciB3aWR0aCAoaW4gcmVnYXJkIHRvIG9yaWVudGF0aW9uKTtcblx0XHRcdFx0dmVydGljYWw6IF9vcHRpb25zLnZlcnRpY2FsLFxuXHRcdFx0XHRzY3JvbGxQb3M6IF9zY3JvbGxQb3MsXG5cdFx0XHRcdHNjcm9sbERpcmVjdGlvbjogX3Njcm9sbERpcmVjdGlvbixcblx0XHRcdFx0Y29udGFpbmVyOiBfb3B0aW9ucy5jb250YWluZXIsXG5cdFx0XHRcdGlzRG9jdW1lbnQ6IF9pc0RvY3VtZW50XG5cdFx0XHR9O1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7IC8vIGdldCBhbGwgYXMgYW4gb2JqZWN0XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlc1thYm91dF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVzW2Fib3V0XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvZygxLCBcIkVSUk9SOiBvcHRpb24gXFxcIlwiICsgYWJvdXQgKyBcIlxcXCIgaXMgbm90IGF2YWlsYWJsZVwiKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIG9yICoqU2V0KiogdGhlIGN1cnJlbnQgbG9nbGV2ZWwgb3B0aW9uIHZhbHVlLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlXG5cdFx0ICogdmFyIGxvZ2xldmVsID0gY29udHJvbGxlci5sb2dsZXZlbCgpO1xuXHRcdCAqXG5cdFx0ICogLy8gc2V0IGEgbmV3IHZhbHVlXG5cdFx0ICogY29udHJvbGxlci5sb2dsZXZlbCgzKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3TG9nbGV2ZWxdIC0gVGhlIG5ldyBsb2dsZXZlbCBzZXR0aW5nIG9mIHRoZSBDb250cm9sbGVyLiBgWzAtM11gXG5cdFx0ICogQHJldHVybnMgeyhudW1iZXJ8Q29udHJvbGxlcil9IEN1cnJlbnQgbG9nbGV2ZWwgb3IgcGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5sb2dsZXZlbCA9IGZ1bmN0aW9uIChuZXdMb2dsZXZlbCkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7IC8vIGdldFxuXHRcdFx0XHRyZXR1cm4gX29wdGlvbnMubG9nbGV2ZWw7XG5cdFx0XHR9IGVsc2UgaWYgKF9vcHRpb25zLmxvZ2xldmVsICE9IG5ld0xvZ2xldmVsKSB7IC8vIHNldFxuXHRcdFx0XHRfb3B0aW9ucy5sb2dsZXZlbCA9IG5ld0xvZ2xldmVsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIENvbnRyb2xsZXI7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0Kiogb3IgKipTZXQqKiB0aGUgY3VycmVudCBlbmFibGVkIHN0YXRlIG9mIHRoZSBjb250cm9sbGVyLiAgXG5cdFx0ICogVGhpcyBjYW4gYmUgdXNlZCB0byBkaXNhYmxlIGFsbCBTY2VuZXMgY29ubmVjdGVkIHRvIHRoZSBjb250cm9sbGVyIHdpdGhvdXQgZGVzdHJveWluZyBvciByZW1vdmluZyB0aGVtLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlXG5cdFx0ICogdmFyIGVuYWJsZWQgPSBjb250cm9sbGVyLmVuYWJsZWQoKTtcblx0XHQgKlxuXHRcdCAqIC8vIGRpc2FibGUgdGhlIGNvbnRyb2xsZXJcblx0XHQgKiBjb250cm9sbGVyLmVuYWJsZWQoZmFsc2UpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbbmV3U3RhdGVdIC0gVGhlIG5ldyBlbmFibGVkIHN0YXRlIG9mIHRoZSBjb250cm9sbGVyIGB0cnVlYCBvciBgZmFsc2VgLlxuXHRcdCAqIEByZXR1cm5zIHsoYm9vbGVhbnxDb250cm9sbGVyKX0gQ3VycmVudCBlbmFibGVkIHN0YXRlIG9yIHBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMuZW5hYmxlZCA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7IC8vIGdldFxuXHRcdFx0XHRyZXR1cm4gX2VuYWJsZWQ7XG5cdFx0XHR9IGVsc2UgaWYgKF9lbmFibGVkICE9IG5ld1N0YXRlKSB7IC8vIHNldFxuXHRcdFx0XHRfZW5hYmxlZCA9ICEhIG5ld1N0YXRlO1xuXHRcdFx0XHRDb250cm9sbGVyLnVwZGF0ZVNjZW5lKF9zY2VuZU9iamVjdHMsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIENvbnRyb2xsZXI7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3kgdGhlIENvbnRyb2xsZXIsIGFsbCBTY2VuZXMgYW5kIGV2ZXJ5dGhpbmcuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyB3aXRob3V0IHJlc2V0dGluZyB0aGUgc2NlbmVzXG5cdFx0ICogY29udHJvbGxlciA9IGNvbnRyb2xsZXIuZGVzdHJveSgpO1xuXHRcdCAqXG5cdFx0ICogLy8gd2l0aCBzY2VuZSByZXNldFxuXHRcdCAqIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyLmRlc3Ryb3kodHJ1ZSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldFNjZW5lcz1mYWxzZV0gLSBJZiBgdHJ1ZWAgdGhlIHBpbnMgYW5kIHR3ZWVucyAoaWYgZXhpc3RlbnQpIG9mIGFsbCBzY2VuZXMgd2lsbCBiZSByZXNldC5cblx0XHQgKiBAcmV0dXJucyB7bnVsbH0gTnVsbCB0byB1bnNldCBoYW5kbGVyIHZhcmlhYmxlcy5cblx0XHQgKi9cblx0XHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAocmVzZXRTY2VuZXMpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoX3JlZnJlc2hUaW1lb3V0KTtcblx0XHRcdHZhciBpID0gX3NjZW5lT2JqZWN0cy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdF9zY2VuZU9iamVjdHNbaV0uZGVzdHJveShyZXNldFNjZW5lcyk7XG5cdFx0XHR9XG5cdFx0XHRfb3B0aW9ucy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvbkNoYW5nZSk7XG5cdFx0XHRfb3B0aW9ucy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBvbkNoYW5nZSk7XG5cdFx0XHRfdXRpbC5jQUYoX3VwZGF0ZVRpbWVvdXQpO1xuXHRcdFx0bG9nKDMsIFwiZGVzdHJveWVkIFwiICsgTkFNRVNQQUNFICsgXCIgKHJlc2V0OiBcIiArIChyZXNldFNjZW5lcyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKSArIFwiKVwiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cblx0XHQvLyBJTklUXG5cdFx0Y29uc3RydWN0KCk7XG5cdFx0cmV0dXJuIENvbnRyb2xsZXI7XG5cdH07XG5cblx0Ly8gc3RvcmUgcGFnZXdpZGUgY29udHJvbGxlciBvcHRpb25zXG5cdHZhciBDT05UUk9MTEVSX09QVElPTlMgPSB7XG5cdFx0ZGVmYXVsdHM6IHtcblx0XHRcdGNvbnRhaW5lcjogd2luZG93LFxuXHRcdFx0dmVydGljYWw6IHRydWUsXG5cdFx0XHRnbG9iYWxTY2VuZU9wdGlvbnM6IHt9LFxuXHRcdFx0bG9nbGV2ZWw6IDIsXG5cdFx0XHRyZWZyZXNoSW50ZXJ2YWw6IDEwMFxuXHRcdH1cblx0fTtcbi8qXG4gKiBtZXRob2QgdXNlZCB0byBhZGQgYW4gb3B0aW9uIHRvIFNjcm9sbE1hZ2ljIFNjZW5lcy5cbiAqL1xuXHRTY3JvbGxNYWdpYy5Db250cm9sbGVyLmFkZE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBkZWZhdWx0VmFsdWUpIHtcblx0XHRDT05UUk9MTEVSX09QVElPTlMuZGVmYXVsdHNbbmFtZV0gPSBkZWZhdWx0VmFsdWU7XG5cdH07XG5cdC8vIGluc3RhbmNlIGV4dGVuc2lvbiBmdW5jdGlvbiBmb3IgcGx1Z2luc1xuXHRTY3JvbGxNYWdpYy5Db250cm9sbGVyLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcblx0XHR2YXIgb2xkQ2xhc3MgPSB0aGlzO1xuXHRcdFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRvbGRDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy4kc3VwZXIgPSBfdXRpbC5leHRlbmQoe30sIHRoaXMpOyAvLyBjb3B5IHBhcmVudCBzdGF0ZVxuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdFx0fTtcblx0XHRfdXRpbC5leHRlbmQoU2Nyb2xsTWFnaWMuQ29udHJvbGxlciwgb2xkQ2xhc3MpOyAvLyBjb3B5IHByb3BlcnRpZXNcblx0XHRTY3JvbGxNYWdpYy5Db250cm9sbGVyLnByb3RvdHlwZSA9IG9sZENsYXNzLnByb3RvdHlwZTsgLy8gY29weSBwcm90b3R5cGVcblx0XHRTY3JvbGxNYWdpYy5Db250cm9sbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXI7IC8vIHJlc3RvcmUgY29uc3RydWN0b3Jcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBBIFNjZW5lIGRlZmluZXMgd2hlcmUgdGhlIGNvbnRyb2xsZXIgc2hvdWxkIHJlYWN0IGFuZCBob3cuXG5cdCAqXG5cdCAqIEBjbGFzc1xuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBjcmVhdGUgYSBzdGFuZGFyZCBzY2VuZSBhbmQgYWRkIGl0IHRvIGEgY29udHJvbGxlclxuXHQgKiBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoKVxuXHQgKlx0XHQuYWRkVG8oY29udHJvbGxlcik7XG5cdCAqXG5cdCAqIC8vIGNyZWF0ZSBhIHNjZW5lIHdpdGggY3VzdG9tIG9wdGlvbnMgYW5kIGFzc2lnbiBhIGhhbmRsZXIgdG8gaXQuXG5cdCAqIHZhciBzY2VuZSA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7XG5cdCAqIFx0XHRkdXJhdGlvbjogMTAwLFxuXHQgKlx0XHRvZmZzZXQ6IDIwMCxcblx0ICpcdFx0dHJpZ2dlckhvb2s6IFwib25FbnRlclwiLFxuXHQgKlx0XHRyZXZlcnNlOiBmYWxzZVxuXHQgKiB9KTtcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHRoZSBTY2VuZS4gVGhlIG9wdGlvbnMgY2FuIGJlIHVwZGF0ZWQgYXQgYW55IHRpbWUuICBcblx0IEluc3RlYWQgb2Ygc2V0dGluZyB0aGUgb3B0aW9ucyBmb3IgZWFjaCBzY2VuZSBpbmRpdmlkdWFsbHkgeW91IGNhbiBhbHNvIHNldCB0aGVtIGdsb2JhbGx5IGluIHRoZSBjb250cm9sbGVyIGFzIHRoZSBjb250cm9sbGVycyBgZ2xvYmFsU2NlbmVPcHRpb25zYCBvcHRpb24uIFRoZSBvYmplY3QgYWNjZXB0cyB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoZSBvbmVzIGJlbG93LiAgXG5cdCBXaGVuIGEgc2NlbmUgaXMgYWRkZWQgdG8gdGhlIGNvbnRyb2xsZXIgdGhlIG9wdGlvbnMgZGVmaW5lZCB1c2luZyB0aGUgU2NlbmUgY29uc3RydWN0b3Igd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aG9zZSBzZXQgaW4gYGdsb2JhbFNjZW5lT3B0aW9uc2AuXG5cdCAqIEBwYXJhbSB7KG51bWJlcnxmdW5jdGlvbil9IFtvcHRpb25zLmR1cmF0aW9uPTBdIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSBzY2VuZS4gXG5cdCBJZiBgMGAgdHdlZW5zIHdpbGwgYXV0by1wbGF5IHdoZW4gcmVhY2hpbmcgdGhlIHNjZW5lIHN0YXJ0IHBvaW50LCBwaW5zIHdpbGwgYmUgcGlubmVkIGluZGVmaW5ldGx5IHN0YXJ0aW5nIGF0IHRoZSBzdGFydCBwb3NpdGlvbi4gIFxuXHQgQSBmdW5jdGlvbiByZXR1bmluZyB0aGUgZHVyYXRpb24gdmFsdWUgaXMgYWxzbyBzdXBwb3J0ZWQuIFBsZWFzZSBzZWUgYFNjZW5lLmR1cmF0aW9uKClgIGZvciBkZXRhaWxzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMub2Zmc2V0PTBdIC0gT2Zmc2V0IFZhbHVlIGZvciB0aGUgVHJpZ2dlciBQb3NpdGlvbi4gSWYgbm8gdHJpZ2dlckVsZW1lbnQgaXMgZGVmaW5lZCB0aGlzIHdpbGwgYmUgdGhlIHNjcm9sbCBkaXN0YW5jZSBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGFnZSwgYWZ0ZXIgd2hpY2ggdGhlIHNjZW5lIHdpbGwgc3RhcnQuXG5cdCAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSBbb3B0aW9ucy50cmlnZ2VyRWxlbWVudD1udWxsXSAtIFNlbGVjdG9yIG9yIERPTSBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSBzdGFydCBvZiB0aGUgc2NlbmUuIElmIHVuZGVmaW5lZCB0aGUgc2NlbmUgd2lsbCBzdGFydCByaWdodCBhdCB0aGUgc3RhcnQgb2YgdGhlIHBhZ2UgKHVubGVzcyBhbiBvZmZzZXQgaXMgc2V0KS5cblx0ICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyl9IFtvcHRpb25zLnRyaWdnZXJIb29rPVwib25DZW50ZXJcIl0gLSBDYW4gYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIGRlZmluaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHJpZ2dlciBIb29rIGluIHJlbGF0aW9uIHRvIHRoZSB2aWV3cG9ydC4gIFxuXHQgQ2FuIGFsc28gYmUgZGVmaW5lZCB1c2luZyBhIHN0cmluZzpcblx0ICoqIGBcIm9uRW50ZXJcImAgPT4gYDFgXG5cdCAqKiBgXCJvbkNlbnRlclwiYCA9PiBgMC41YFxuXHQgKiogYFwib25MZWF2ZVwiYCA9PiBgMGBcblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXZlcnNlPXRydWVdIC0gU2hvdWxkIHRoZSBzY2VuZSByZXZlcnNlLCB3aGVuIHNjcm9sbGluZyB1cD9cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvZ2xldmVsPTJdIC0gTG9nbGV2ZWwgZm9yIGRlYnVnZ2luZy4gTm90ZSB0aGF0IGxvZ2dpbmcgaXMgZGlzYWJsZWQgaW4gdGhlIG1pbmlmaWVkIHZlcnNpb24gb2YgU2Nyb2xsTWFnaWMuXG5cdCAqKiBgMGAgPT4gc2lsZW50XG5cdCAqKiBgMWAgPT4gZXJyb3JzXG5cdCAqKiBgMmAgPT4gZXJyb3JzLCB3YXJuaW5nc1xuXHQgKiogYDNgID0+IGVycm9ycywgd2FybmluZ3MsIGRlYnVnaW5mb1xuXHQgKiBcblx0ICovXG5cdFNjcm9sbE1hZ2ljLlNjZW5lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuLypcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKiBzZXR0aW5nc1xuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqL1xuXG5cdFx0dmFyXG5cdFx0TkFNRVNQQUNFID0gJ1Njcm9sbE1hZ2ljLlNjZW5lJyxcblx0XHRcdFNDRU5FX1NUQVRFX0JFRk9SRSA9ICdCRUZPUkUnLFxuXHRcdFx0U0NFTkVfU1RBVEVfRFVSSU5HID0gJ0RVUklORycsXG5cdFx0XHRTQ0VORV9TVEFURV9BRlRFUiA9ICdBRlRFUicsXG5cdFx0XHRERUZBVUxUX09QVElPTlMgPSBTQ0VORV9PUFRJT05TLmRlZmF1bHRzO1xuXG4vKlxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIHByaXZhdGUgdmFyc1xuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqL1xuXG5cdFx0dmFyXG5cdFx0U2NlbmUgPSB0aGlzLFxuXHRcdFx0X29wdGlvbnMgPSBfdXRpbC5leHRlbmQoe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyksXG5cdFx0XHRfc3RhdGUgPSBTQ0VORV9TVEFURV9CRUZPUkUsXG5cdFx0XHRfcHJvZ3Jlc3MgPSAwLFxuXHRcdFx0X3Njcm9sbE9mZnNldCA9IHtcblx0XHRcdFx0c3RhcnQ6IDAsXG5cdFx0XHRcdGVuZDogMFxuXHRcdFx0fSxcblx0XHRcdC8vIHJlZmxlY3RzIHRoZSBjb250cm9sbGVycydzIHNjcm9sbCBwb3NpdGlvbiBmb3IgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHNjZW5lIHJlc3BlY3RpdmVseVxuXHRcdFx0X3RyaWdnZXJQb3MgPSAwLFxuXHRcdFx0X2VuYWJsZWQgPSB0cnVlLFxuXHRcdFx0X2R1cmF0aW9uVXBkYXRlTWV0aG9kLCBfY29udHJvbGxlcjtcblxuXHRcdC8qKlxuXHRcdCAqIEludGVybmFsIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIG9mIHRoZSBTY3JvbGxNYWdpYyBTY2VuZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBfb3B0aW9ucykgeyAvLyBjaGVjayBzdXBwbGllZCBvcHRpb25zXG5cdFx0XHRcdGlmICghREVGQVVMVF9PUFRJT05TLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRsb2coMiwgXCJXQVJOSU5HOiBVbmtub3duIG9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIik7XG5cdFx0XHRcdFx0ZGVsZXRlIF9vcHRpb25zW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGFkZCBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwb3NzaWJsZSBvcHRpb25zXG5cdFx0XHRmb3IgKHZhciBvcHRpb25OYW1lIGluIERFRkFVTFRfT1BUSU9OUykge1xuXHRcdFx0XHRhZGRTY2VuZU9wdGlvbihvcHRpb25OYW1lKTtcblx0XHRcdH1cblx0XHRcdC8vIHZhbGlkYXRlIGFsbCBvcHRpb25zXG5cdFx0XHR2YWxpZGF0ZU9wdGlvbigpO1xuXHRcdH07XG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBFdmVudCBNYW5hZ2VtZW50XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXHRcdHZhciBfbGlzdGVuZXJzID0ge307XG5cdFx0LyoqXG5cdFx0ICogU2NlbmUgc3RhcnQgZXZlbnQuICBcblx0XHQgKiBGaXJlcyB3aGVuZXZlciB0aGUgc2Nyb2xsIHBvc2l0aW9uIGl0cyB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIHNjZW5lLiAgXG5cdFx0ICogSXQgd2lsbCBhbHNvIGZpcmUgd2hlbiBzY3JvbGxpbmcgYmFjayB1cCBnb2luZyBvdmVyIHRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc2NlbmUuIElmIHlvdSB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb25seSB3aGVuIHNjcm9sbGluZyBkb3duL3JpZ2h0LCB1c2UgdGhlIHNjcm9sbERpcmVjdGlvbiBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cblx0XHQgKlxuXHRcdCAqIEZvciBkZXRhaWxzIG9uIHRoaXMgZXZlbnQgYW5kIHRoZSBvcmRlciBpbiB3aGljaCBpdCBpcyBmaXJlZCwgcGxlYXNlIHJldmlldyB0aGUge0BsaW5rIFNjZW5lLnByb2dyZXNzfSBtZXRob2QuXG5cdFx0ICpcblx0XHQgKiBAZXZlbnQgU2Nyb2xsTWFnaWMuU2NlbmUjc3RhcnRcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUub24oXCJzdGFydFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiBcdGNvbnNvbGUubG9nKFwiSGl0IHN0YXJ0IHBvaW50IG9mIHNjZW5lLlwiKTtcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBPYmplY3QgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2tcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7U2NlbmV9IGV2ZW50LnRhcmdldCAtIFRoZSBTY2VuZSBvYmplY3QgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudC5wcm9ncmVzcyAtIFJlZmxlY3RzIHRoZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoZSBzY2VuZVxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5zdGF0ZSAtIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzY2VuZSBgXCJCRUZPUkVcImAgb3IgYFwiRFVSSU5HXCJgXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnNjcm9sbERpcmVjdGlvbiAtIEluZGljYXRlcyB3aGljaCB3YXkgd2UgYXJlIHNjcm9sbGluZyBgXCJQQVVTRURcImAsIGBcIkZPUldBUkRcImAgb3IgYFwiUkVWRVJTRVwiYFxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFNjZW5lIGVuZCBldmVudC4gIFxuXHRcdCAqIEZpcmVzIHdoZW5ldmVyIHRoZSBzY3JvbGwgcG9zaXRpb24gaXRzIHRoZSBlbmRpbmcgcG9pbnQgb2YgdGhlIHNjZW5lLiAgXG5cdFx0ICogSXQgd2lsbCBhbHNvIGZpcmUgd2hlbiBzY3JvbGxpbmcgYmFjayB1cCBmcm9tIGFmdGVyIHRoZSBzY2VuZSBhbmQgZ29pbmcgb3ZlciBpdHMgZW5kIHBvc2l0aW9uLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9ubHkgd2hlbiBzY3JvbGxpbmcgZG93bi9yaWdodCwgdXNlIHRoZSBzY3JvbGxEaXJlY3Rpb24gcGFyYW1ldGVyIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG5cdFx0ICpcblx0XHQgKiBGb3IgZGV0YWlscyBvbiB0aGlzIGV2ZW50IGFuZCB0aGUgb3JkZXIgaW4gd2hpY2ggaXQgaXMgZmlyZWQsIHBsZWFzZSByZXZpZXcgdGhlIHtAbGluayBTY2VuZS5wcm9ncmVzc30gbWV0aG9kLlxuXHRcdCAqXG5cdFx0ICogQGV2ZW50IFNjcm9sbE1hZ2ljLlNjZW5lI2VuZFxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZS5vbihcImVuZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiBcdGNvbnNvbGUubG9nKFwiSGl0IGVuZCBwb2ludCBvZiBzY2VuZS5cIik7XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgT2JqZWN0IHBhc3NlZCB0byBlYWNoIGNhbGxiYWNrXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge1NjZW5lfSBldmVudC50YXJnZXQgLSBUaGUgU2NlbmUgb2JqZWN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnQucHJvZ3Jlc3MgLSBSZWZsZWN0cyB0aGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgc2NlbmVcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQuc3RhdGUgLSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2NlbmUgYFwiRFVSSU5HXCJgIG9yIGBcIkFGVEVSXCJgXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnNjcm9sbERpcmVjdGlvbiAtIEluZGljYXRlcyB3aGljaCB3YXkgd2UgYXJlIHNjcm9sbGluZyBgXCJQQVVTRURcImAsIGBcIkZPUldBUkRcImAgb3IgYFwiUkVWRVJTRVwiYFxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFNjZW5lIGVudGVyIGV2ZW50LiAgXG5cdFx0ICogRmlyZXMgd2hlbmV2ZXIgdGhlIHNjZW5lIGVudGVycyB0aGUgXCJEVVJJTkdcIiBzdGF0ZS4gIFxuXHRcdCAqIEtlZXAgaW4gbWluZCB0aGF0IGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHRoZSBzY2VuZSBwbGF5cyBmb3J3YXJkIG9yIGJhY2t3YXJkOiBUaGlzIGV2ZW50IGFsd2F5cyBmaXJlcyB3aGVuIHRoZSBzY2VuZSBlbnRlcnMgaXRzIGFjdGl2ZSBzY3JvbGwgdGltZWZyYW1lLCByZWdhcmRsZXNzIG9mIHRoZSBzY3JvbGwtZGlyZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogRm9yIGRldGFpbHMgb24gdGhpcyBldmVudCBhbmQgdGhlIG9yZGVyIGluIHdoaWNoIGl0IGlzIGZpcmVkLCBwbGVhc2UgcmV2aWV3IHRoZSB7QGxpbmsgU2NlbmUucHJvZ3Jlc3N9IG1ldGhvZC5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBTY3JvbGxNYWdpYy5TY2VuZSNlbnRlclxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZS5vbihcImVudGVyXCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqIFx0Y29uc29sZS5sb2coXCJTY2VuZSBlbnRlcmVkLlwiKTtcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBPYmplY3QgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2tcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7U2NlbmV9IGV2ZW50LnRhcmdldCAtIFRoZSBTY2VuZSBvYmplY3QgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudC5wcm9ncmVzcyAtIFJlZmxlY3RzIHRoZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoZSBzY2VuZVxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5zdGF0ZSAtIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzY2VuZSAtIGFsd2F5cyBgXCJEVVJJTkdcImBcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQuc2Nyb2xsRGlyZWN0aW9uIC0gSW5kaWNhdGVzIHdoaWNoIHdheSB3ZSBhcmUgc2Nyb2xsaW5nIGBcIlBBVVNFRFwiYCwgYFwiRk9SV0FSRFwiYCBvciBgXCJSRVZFUlNFXCJgXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogU2NlbmUgbGVhdmUgZXZlbnQuICBcblx0XHQgKiBGaXJlcyB3aGVuZXZlciB0aGUgc2NlbmUncyBzdGF0ZSBnb2VzIGZyb20gXCJEVVJJTkdcIiB0byBlaXRoZXIgXCJCRUZPUkVcIiBvciBcIkFGVEVSXCIuICBcblx0XHQgKiBLZWVwIGluIG1pbmQgdGhhdCBpdCBkb2Vzbid0IG1hdHRlciBpZiB0aGUgc2NlbmUgcGxheXMgZm9yd2FyZCBvciBiYWNrd2FyZDogVGhpcyBldmVudCBhbHdheXMgZmlyZXMgd2hlbiB0aGUgc2NlbmUgbGVhdmVzIGl0cyBhY3RpdmUgc2Nyb2xsIHRpbWVmcmFtZSwgcmVnYXJkbGVzcyBvZiB0aGUgc2Nyb2xsLWRpcmVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEZvciBkZXRhaWxzIG9uIHRoaXMgZXZlbnQgYW5kIHRoZSBvcmRlciBpbiB3aGljaCBpdCBpcyBmaXJlZCwgcGxlYXNlIHJldmlldyB0aGUge0BsaW5rIFNjZW5lLnByb2dyZXNzfSBtZXRob2QuXG5cdFx0ICpcblx0XHQgKiBAZXZlbnQgU2Nyb2xsTWFnaWMuU2NlbmUjbGVhdmVcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUub24oXCJsZWF2ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiBcdGNvbnNvbGUubG9nKFwiU2NlbmUgbGVmdC5cIik7XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgT2JqZWN0IHBhc3NlZCB0byBlYWNoIGNhbGxiYWNrXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge1NjZW5lfSBldmVudC50YXJnZXQgLSBUaGUgU2NlbmUgb2JqZWN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnQucHJvZ3Jlc3MgLSBSZWZsZWN0cyB0aGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgc2NlbmVcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQuc3RhdGUgLSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2NlbmUgYFwiQkVGT1JFXCJgIG9yIGBcIkFGVEVSXCJgXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnNjcm9sbERpcmVjdGlvbiAtIEluZGljYXRlcyB3aGljaCB3YXkgd2UgYXJlIHNjcm9sbGluZyBgXCJQQVVTRURcImAsIGBcIkZPUldBUkRcImAgb3IgYFwiUkVWRVJTRVwiYFxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFNjZW5lIHVwZGF0ZSBldmVudC4gIFxuXHRcdCAqIEZpcmVzIHdoZW5ldmVyIHRoZSBzY2VuZSBpcyB1cGRhdGVkIChidXQgbm90IG5lY2Vzc2FyaWx5IGNoYW5nZXMgdGhlIHByb2dyZXNzKS5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBTY3JvbGxNYWdpYy5TY2VuZSN1cGRhdGVcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUub24oXCJ1cGRhdGVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogXHRjb25zb2xlLmxvZyhcIlNjZW5lIHVwZGF0ZWQuXCIpO1xuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IE9iamVjdCBwYXNzZWQgdG8gZWFjaCBjYWxsYmFja1xuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtTY2VuZX0gZXZlbnQudGFyZ2V0IC0gVGhlIFNjZW5lIG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50LnN0YXJ0UG9zIC0gVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSBzY2VuZSAoaW4gcmVsYXRpb24gdG8gdGhlIGNvbmFpbmVyKVxuXHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudC5lbmRQb3MgLSBUaGUgZW5kaW5nIHBvc2l0aW9uIG9mIHRoZSBzY2VuZSAoaW4gcmVsYXRpb24gdG8gdGhlIGNvbmFpbmVyKVxuXHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudC5zY3JvbGxQb3MgLSBUaGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lclxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFNjZW5lIHByb2dyZXNzIGV2ZW50LiAgXG5cdFx0ICogRmlyZXMgd2hlbmV2ZXIgdGhlIHByb2dyZXNzIG9mIHRoZSBzY2VuZSBjaGFuZ2VzLlxuXHRcdCAqXG5cdFx0ICogRm9yIGRldGFpbHMgb24gdGhpcyBldmVudCBhbmQgdGhlIG9yZGVyIGluIHdoaWNoIGl0IGlzIGZpcmVkLCBwbGVhc2UgcmV2aWV3IHRoZSB7QGxpbmsgU2NlbmUucHJvZ3Jlc3N9IG1ldGhvZC5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBTY3JvbGxNYWdpYy5TY2VuZSNwcm9ncmVzc1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZS5vbihcInByb2dyZXNzXCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqIFx0Y29uc29sZS5sb2coXCJTY2VuZSBwcm9ncmVzcyBjaGFuZ2VkIHRvIFwiICsgZXZlbnQucHJvZ3Jlc3MpO1xuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IE9iamVjdCBwYXNzZWQgdG8gZWFjaCBjYWxsYmFja1xuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtTY2VuZX0gZXZlbnQudGFyZ2V0IC0gVGhlIFNjZW5lIG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50LnByb2dyZXNzIC0gUmVmbGVjdHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIHNjZW5lXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnN0YXRlIC0gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNjZW5lIGBcIkJFRk9SRVwiYCwgYFwiRFVSSU5HXCJgIG9yIGBcIkFGVEVSXCJgXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnNjcm9sbERpcmVjdGlvbiAtIEluZGljYXRlcyB3aGljaCB3YXkgd2UgYXJlIHNjcm9sbGluZyBgXCJQQVVTRURcImAsIGBcIkZPUldBUkRcImAgb3IgYFwiUkVWRVJTRVwiYFxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFNjZW5lIGNoYW5nZSBldmVudC4gIFxuXHRcdCAqIEZpcmVzIHdoZW52ZXZlciBhIHByb3BlcnR5IG9mIHRoZSBzY2VuZSBpcyBjaGFuZ2VkLlxuXHRcdCAqXG5cdFx0ICogQGV2ZW50IFNjcm9sbE1hZ2ljLlNjZW5lI2NoYW5nZVxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZS5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiBcdGNvbnNvbGUubG9nKFwiU2NlbmUgUHJvcGVydHkgXFxcIlwiICsgZXZlbnQud2hhdCArIFwiXFxcIiBjaGFuZ2VkIHRvIFwiICsgZXZlbnQubmV3dmFsKTtcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBPYmplY3QgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2tcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7U2NlbmV9IGV2ZW50LnRhcmdldCAtIFRoZSBTY2VuZSBvYmplY3QgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC53aGF0IC0gSW5kaWNhdGVzIHdoYXQgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZFxuXHRcdCAqIEBwcm9wZXJ0eSB7bWl4ZWR9IGV2ZW50Lm5ld3ZhbCAtIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGNoYW5nZWQgcHJvcGVydHlcblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBTY2VuZSBzaGlmdCBldmVudC4gIFxuXHRcdCAqIEZpcmVzIHdoZW52ZXZlciB0aGUgc3RhcnQgb3IgZW5kICoqc2Nyb2xsIG9mZnNldCoqIG9mIHRoZSBzY2VuZSBjaGFuZ2UuXG5cdFx0ICogVGhpcyBoYXBwZW5zIGV4cGxpY2l0ZWx5LCB3aGVuIG9uZSBvZiB0aGVzZSB2YWx1ZXMgY2hhbmdlOiBgb2Zmc2V0YCwgYGR1cmF0aW9uYCBvciBgdHJpZ2dlckhvb2tgLlxuXHRcdCAqIEl0IHdpbGwgZmlyZSBpbXBsaWNpdGx5IHdoZW4gdGhlIGB0cmlnZ2VyRWxlbWVudGAgY2hhbmdlcywgaWYgdGhlIG5ldyBlbGVtZW50IGhhcyBhIGRpZmZlcmVudCBwb3NpdGlvbiAobW9zdCBjYXNlcykuXG5cdFx0ICogSXQgd2lsbCBhbHNvIGZpcmUgaW1wbGljaXRseSB3aGVuIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIgY2hhbmdlcyBhbmQgdGhlIHRyaWdnZXJIb29rIGlzIGFueXRoaW5nIG90aGVyIHRoYW4gYG9uTGVhdmVgLlxuXHRcdCAqXG5cdFx0ICogQGV2ZW50IFNjcm9sbE1hZ2ljLlNjZW5lI3NoaWZ0XG5cdFx0ICogQHNpbmNlIDEuMS4wXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lLm9uKFwic2hpZnRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogXHRjb25zb2xlLmxvZyhcIlNjZW5lIG1vdmVkLCBiZWNhdXNlIHRoZSBcIiArIGV2ZW50LnJlYXNvbiArIFwiIGhhcyBjaGFuZ2VkLilcIik7XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgT2JqZWN0IHBhc3NlZCB0byBlYWNoIGNhbGxiYWNrXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge1NjZW5lfSBldmVudC50YXJnZXQgLSBUaGUgU2NlbmUgb2JqZWN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQucmVhc29uIC0gSW5kaWNhdGVzIHdoeSB0aGUgc2NlbmUgaGFzIHNoaWZ0ZWRcblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBTY2VuZSBkZXN0cm95IGV2ZW50LiAgXG5cdFx0ICogRmlyZXMgd2hlbnZldmVyIHRoZSBzY2VuZSBpcyBkZXN0cm95ZWQuXG5cdFx0ICogVGhpcyBjYW4gYmUgdXNlZCB0byB0aWR5IHVwIGN1c3RvbSBiZWhhdmlvdXIgdXNlZCBpbiBldmVudHMuXG5cdFx0ICpcblx0XHQgKiBAZXZlbnQgU2Nyb2xsTWFnaWMuU2NlbmUjZGVzdHJveVxuXHRcdCAqIEBzaW5jZSAxLjEuMFxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZS5vbihcImVudGVyXCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqICAgICAgICAvLyBhZGQgY3VzdG9tIGFjdGlvblxuXHRcdCAqICAgICAgICAkKFwiI215LWVsZW1cIikubGVmdChcIjIwMFwiKTtcblx0XHQgKiAgICAgIH0pXG5cdFx0ICogICAgICAub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqICAgICAgICAvLyByZXNldCBteSBlbGVtZW50IHRvIHN0YXJ0IHBvc2l0aW9uXG5cdFx0ICogICAgICAgIGlmIChldmVudC5yZXNldCkge1xuXHRcdCAqICAgICAgICAgICQoXCIjbXktZWxlbVwiKS5sZWZ0KFwiMFwiKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgT2JqZWN0IHBhc3NlZCB0byBlYWNoIGNhbGxiYWNrXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge1NjZW5lfSBldmVudC50YXJnZXQgLSBUaGUgU2NlbmUgb2JqZWN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IGV2ZW50LnJlc2V0IC0gSW5kaWNhdGVzIGlmIHRoZSBkZXN0cm95IG1ldGhvZCB3YXMgY2FsbGVkIHdpdGggcmVzZXQgYHRydWVgIG9yIGBmYWxzZWAuXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogU2NlbmUgYWRkIGV2ZW50LiAgXG5cdFx0ICogRmlyZXMgd2hlbiB0aGUgc2NlbmUgaXMgYWRkZWQgdG8gYSBjb250cm9sbGVyLlxuXHRcdCAqIFRoaXMgaXMgbW9zdGx5IHVzZWQgYnkgcGx1Z2lucyB0byBrbm93IHRoYXQgY2hhbmdlIG1pZ2h0IGJlIGR1ZS5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBTY3JvbGxNYWdpYy5TY2VuZSNhZGRcblx0XHQgKiBAc2luY2UgMi4wLjBcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUub24oXCJhZGRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogXHRjb25zb2xlLmxvZygnU2NlbmUgd2FzIGFkZGVkIHRvIGEgbmV3IGNvbnRyb2xsZXIuJyk7XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgT2JqZWN0IHBhc3NlZCB0byBlYWNoIGNhbGxiYWNrXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge1NjZW5lfSBldmVudC50YXJnZXQgLSBUaGUgU2NlbmUgb2JqZWN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IGV2ZW50LmNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciBvYmplY3QgdGhlIHNjZW5lIHdhcyBhZGRlZCB0by5cblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBTY2VuZSByZW1vdmUgZXZlbnQuICBcblx0XHQgKiBGaXJlcyB3aGVuIHRoZSBzY2VuZSBpcyByZW1vdmVkIGZyb20gYSBjb250cm9sbGVyLlxuXHRcdCAqIFRoaXMgaXMgbW9zdGx5IHVzZWQgYnkgcGx1Z2lucyB0byBrbm93IHRoYXQgY2hhbmdlIG1pZ2h0IGJlIGR1ZS5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBTY3JvbGxNYWdpYy5TY2VuZSNyZW1vdmVcblx0XHQgKiBAc2luY2UgMi4wLjBcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUub24oXCJyZW1vdmVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogXHRjb25zb2xlLmxvZygnU2NlbmUgd2FzIHJlbW92ZWQgZnJvbSBpdHMgY29udHJvbGxlci4nKTtcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBPYmplY3QgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2tcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7U2NlbmV9IGV2ZW50LnRhcmdldCAtIFRoZSBTY2VuZSBvYmplY3QgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudFxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkIG9uZSBvcmUgbW9yZSBldmVudCBsaXN0ZW5lci4gIFxuXHRcdCAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGZpcmVkIGF0IHRoZSByZXNwZWN0aXZlIGV2ZW50LCBhbmQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgcmVsZXZhbnQgZGF0YSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNvblxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBmdW5jdGlvbiBjYWxsYmFjayAoZXZlbnQpIHtcblx0XHQgKiBcdFx0Y29uc29sZS5sb2coXCJFdmVudCBmaXJlZCEgKFwiICsgZXZlbnQudHlwZSArIFwiKVwiKTtcblx0XHQgKiB9XG5cdFx0ICogLy8gYWRkIGxpc3RlbmVyc1xuXHRcdCAqIHNjZW5lLm9uKFwiY2hhbmdlIHVwZGF0ZSBwcm9ncmVzcyBzdGFydCBlbmQgZW50ZXIgbGVhdmVcIiwgY2FsbGJhY2spO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzIC0gVGhlIG5hbWUgb3IgbmFtZXMgb2YgdGhlIGV2ZW50IHRoZSBjYWxsYmFjayBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGV4ZWN1dGVkLCB3aGVuIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLiBBbiBldmVudCBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5vbiA9IGZ1bmN0aW9uIChuYW1lcywgY2FsbGJhY2spIHtcblx0XHRcdGlmIChfdXRpbC50eXBlLkZ1bmN0aW9uKGNhbGxiYWNrKSkge1xuXHRcdFx0XHRuYW1lcyA9IG5hbWVzLnRyaW0oKS5zcGxpdCgnICcpO1xuXHRcdFx0XHRuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmdWxsbmFtZSkge1xuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdG5hbWVwYXJ0cyA9IGZ1bGxuYW1lLnNwbGl0KCcuJyksXG5cdFx0XHRcdFx0XHRldmVudG5hbWUgPSBuYW1lcGFydHNbMF0sXG5cdFx0XHRcdFx0XHRuYW1lc3BhY2UgPSBuYW1lcGFydHNbMV07XG5cdFx0XHRcdFx0aWYgKGV2ZW50bmFtZSAhPSBcIipcIikgeyAvLyBkaXNhbGxvdyB3aWxkY2FyZHNcblx0XHRcdFx0XHRcdGlmICghX2xpc3RlbmVyc1tldmVudG5hbWVdKSB7XG5cdFx0XHRcdFx0XHRcdF9saXN0ZW5lcnNbZXZlbnRuYW1lXSA9IFtdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X2xpc3RlbmVyc1tldmVudG5hbWVdLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZSB8fCAnJyxcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2s6IGNhbGxiYWNrXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bG9nKDEsIFwiRVJST1Igd2hlbiBjYWxsaW5nICcub24oKSc6IFN1cHBsaWVkIGNhbGxiYWNrIGZvciAnXCIgKyBuYW1lcyArIFwiJyBpcyBub3QgYSB2YWxpZCBmdW5jdGlvbiFcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBvbmUgb3IgbW9yZSBldmVudCBsaXN0ZW5lci5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI29mZlxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBmdW5jdGlvbiBjYWxsYmFjayAoZXZlbnQpIHtcblx0XHQgKiBcdFx0Y29uc29sZS5sb2coXCJFdmVudCBmaXJlZCEgKFwiICsgZXZlbnQudHlwZSArIFwiKVwiKTtcblx0XHQgKiB9XG5cdFx0ICogLy8gYWRkIGxpc3RlbmVyc1xuXHRcdCAqIHNjZW5lLm9uKFwiY2hhbmdlIHVwZGF0ZVwiLCBjYWxsYmFjayk7XG5cdFx0ICogLy8gcmVtb3ZlIGxpc3RlbmVyc1xuXHRcdCAqIHNjZW5lLm9mZihcImNoYW5nZSB1cGRhdGVcIiwgY2FsbGJhY2spO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzIC0gVGhlIG5hbWUgb3IgbmFtZXMgb2YgdGhlIGV2ZW50IHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgc3BlY2lmaWMgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC4gSWYgbm9uZSBpcyBwYXNzZWQgYWxsIGNhbGxiYWNrcyB0byB0aGUgZXZlbnQgbGlzdGVuZXIgd2lsbCBiZSByZW1vdmVkLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5vZmYgPSBmdW5jdGlvbiAobmFtZXMsIGNhbGxiYWNrKSB7XG5cdFx0XHRpZiAoIW5hbWVzKSB7XG5cdFx0XHRcdGxvZygxLCBcIkVSUk9SOiBJbnZhbGlkIGV2ZW50IG5hbWUgc3VwcGxpZWQuXCIpO1xuXHRcdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0XHR9XG5cdFx0XHRuYW1lcyA9IG5hbWVzLnRyaW0oKS5zcGxpdCgnICcpO1xuXHRcdFx0bmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZnVsbG5hbWUsIGtleSkge1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0bmFtZXBhcnRzID0gZnVsbG5hbWUuc3BsaXQoJy4nKSxcblx0XHRcdFx0XHRldmVudG5hbWUgPSBuYW1lcGFydHNbMF0sXG5cdFx0XHRcdFx0bmFtZXNwYWNlID0gbmFtZXBhcnRzWzFdIHx8ICcnLFxuXHRcdFx0XHRcdHJlbW92ZUxpc3QgPSBldmVudG5hbWUgPT09ICcqJyA/IE9iamVjdC5rZXlzKF9saXN0ZW5lcnMpIDogW2V2ZW50bmFtZV07XG5cdFx0XHRcdHJlbW92ZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0bGlzdCA9IF9saXN0ZW5lcnNbcmVtb3ZlXSB8fCBbXSxcblx0XHRcdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0XHR2YXIgbGlzdGVuZXIgPSBsaXN0W2ldO1xuXHRcdFx0XHRcdFx0aWYgKGxpc3RlbmVyICYmIChuYW1lc3BhY2UgPT09IGxpc3RlbmVyLm5hbWVzcGFjZSB8fCBuYW1lc3BhY2UgPT09ICcqJykgJiYgKCFjYWxsYmFjayB8fCBjYWxsYmFjayA9PSBsaXN0ZW5lci5jYWxsYmFjaykpIHtcblx0XHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghbGlzdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSBfbGlzdGVuZXJzW3JlbW92ZV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBUcmlnZ2VyIGFuIGV2ZW50LlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjdHJpZ2dlclxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiB0aGlzLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0aGF0IHNob3VsZCBiZSB0cmlnZ2VyZWQuXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFt2YXJzXSAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm8gdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lLCB2YXJzKSB7XG5cdFx0XHRpZiAobmFtZSkge1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0bmFtZXBhcnRzID0gbmFtZS50cmltKCkuc3BsaXQoJy4nKSxcblx0XHRcdFx0XHRldmVudG5hbWUgPSBuYW1lcGFydHNbMF0sXG5cdFx0XHRcdFx0bmFtZXNwYWNlID0gbmFtZXBhcnRzWzFdLFxuXHRcdFx0XHRcdGxpc3RlbmVycyA9IF9saXN0ZW5lcnNbZXZlbnRuYW1lXTtcblx0XHRcdFx0bG9nKDMsICdldmVudCBmaXJlZDonLCBldmVudG5hbWUsIHZhcnMgPyBcIi0+XCIgOiAnJywgdmFycyB8fCAnJyk7XG5cdFx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcblx0XHRcdFx0XHRsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIsIGtleSkge1xuXHRcdFx0XHRcdFx0aWYgKCFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSBsaXN0ZW5lci5uYW1lc3BhY2UpIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIuY2FsbGJhY2suY2FsbChTY2VuZSwgbmV3IFNjcm9sbE1hZ2ljLkV2ZW50KGV2ZW50bmFtZSwgbGlzdGVuZXIubmFtZXNwYWNlLCBTY2VuZSwgdmFycykpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsb2coMSwgXCJFUlJPUjogSW52YWxpZCBldmVudCBuYW1lIHN1cHBsaWVkLlwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0Ly8gc2V0IGV2ZW50IGxpc3RlbmVyc1xuXHRcdFNjZW5lLm9uKFwiY2hhbmdlLmludGVybmFsXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoZS53aGF0ICE9PSBcImxvZ2xldmVsXCIgJiYgZS53aGF0ICE9PSBcInR3ZWVuQ2hhbmdlc1wiKSB7IC8vIG5vIG5lZWQgZm9yIGEgc2NlbmUgdXBkYXRlIHNjZW5lIHdpdGggdGhlc2Ugb3B0aW9ucy4uLlxuXHRcdFx0XHRpZiAoZS53aGF0ID09PSBcInRyaWdnZXJFbGVtZW50XCIpIHtcblx0XHRcdFx0XHR1cGRhdGVUcmlnZ2VyRWxlbWVudFBvc2l0aW9uKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZS53aGF0ID09PSBcInJldmVyc2VcIikgeyAvLyB0aGUgb25seSBwcm9wZXJ0eSBsZWZ0IHRoYXQgbWF5IGhhdmUgYW4gaW1wYWN0IG9uIHRoZSBjdXJyZW50IHNjZW5lIHN0YXRlLiBFdmVyeXRoaW5nIGVsc2UgaXMgaGFuZGxlZCBieSB0aGUgc2hpZnQgZXZlbnQuXG5cdFx0XHRcdFx0U2NlbmUudXBkYXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KS5vbihcInNoaWZ0LmludGVybmFsXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR1cGRhdGVTY3JvbGxPZmZzZXQoKTtcblx0XHRcdFNjZW5lLnVwZGF0ZSgpOyAvLyB1cGRhdGUgc2NlbmUgdG8gcmVmbGVjdCBuZXcgcG9zaXRpb25cblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIFNlbmQgYSBkZWJ1ZyBtZXNzYWdlIHRvIHRoZSBjb25zb2xlLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogYnV0IHByb3ZpZGVkIHB1YmxpY2x5IHdpdGggX2xvZyBmb3IgcGx1Z2luc1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGxvZ2xldmVsIC0gVGhlIGxvZ2xldmVsIHJlcXVpcmVkIHRvIGluaXRpYXRlIG91dHB1dCBmb3IgdGhlIG1lc3NhZ2UuXG5cdFx0ICogQHBhcmFtIHsuLi5taXhlZH0gb3V0cHV0IC0gT25lIG9yIG1vcmUgdmFyaWFibGVzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgY29uc29sZS5cblx0XHQgKi9cblx0XHR2YXIgbG9nID0gdGhpcy5fbG9nID0gZnVuY3Rpb24gKGxvZ2xldmVsLCBvdXRwdXQpIHtcblx0XHRcdGlmIChfb3B0aW9ucy5sb2dsZXZlbCA+PSBsb2dsZXZlbCkge1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAwLCBcIihcIiArIE5BTUVTUEFDRSArIFwiKSAtPlwiKTtcblx0XHRcdFx0X3V0aWwubG9nLmFwcGx5KHdpbmRvdywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkIHRoZSBzY2VuZSB0byBhIGNvbnRyb2xsZXIuICBcblx0XHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IHRvIGBDb250cm9sbGVyLmFkZFNjZW5lKHNjZW5lKWAuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNhZGRUb1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBhZGQgYSBzY2VuZSB0byBhIFNjcm9sbE1hZ2ljIENvbnRyb2xsZXJcblx0XHQgKiBzY2VuZS5hZGRUbyhjb250cm9sbGVyKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U2Nyb2xsTWFnaWMuQ29udHJvbGxlcn0gY29udHJvbGxlciAtIFRoZSBjb250cm9sbGVyIHRvIHdoaWNoIHRoZSBzY2VuZSBzaG91bGQgYmUgYWRkZWQuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLmFkZFRvID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcblx0XHRcdGlmICghKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBTY3JvbGxNYWdpYy5Db250cm9sbGVyKSkge1xuXHRcdFx0XHRsb2coMSwgXCJFUlJPUjogc3VwcGxpZWQgYXJndW1lbnQgb2YgJ2FkZFRvKCknIGlzIG5vdCBhIHZhbGlkIFNjcm9sbE1hZ2ljIENvbnRyb2xsZXJcIik7XG5cdFx0XHR9IGVsc2UgaWYgKF9jb250cm9sbGVyICE9IGNvbnRyb2xsZXIpIHtcblx0XHRcdFx0Ly8gbmV3IGNvbnRyb2xsZXJcblx0XHRcdFx0aWYgKF9jb250cm9sbGVyKSB7IC8vIHdhcyBhc3NvY2lhdGVkIHRvIGEgZGlmZmVyZW50IGNvbnRyb2xsZXIgYmVmb3JlLCBzbyByZW1vdmUgaXQuLi5cblx0XHRcdFx0XHRfY29udHJvbGxlci5yZW1vdmVTY2VuZShTY2VuZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2NvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXHRcdFx0XHR2YWxpZGF0ZU9wdGlvbigpO1xuXHRcdFx0XHR1cGRhdGVEdXJhdGlvbih0cnVlKTtcblx0XHRcdFx0dXBkYXRlVHJpZ2dlckVsZW1lbnRQb3NpdGlvbih0cnVlKTtcblx0XHRcdFx0dXBkYXRlU2Nyb2xsT2Zmc2V0KCk7XG5cdFx0XHRcdF9jb250cm9sbGVyLmluZm8oXCJjb250YWluZXJcIikuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25Db250YWluZXJSZXNpemUpO1xuXHRcdFx0XHRjb250cm9sbGVyLmFkZFNjZW5lKFNjZW5lKTtcblx0XHRcdFx0U2NlbmUudHJpZ2dlcihcImFkZFwiLCB7XG5cdFx0XHRcdFx0Y29udHJvbGxlcjogX2NvbnRyb2xsZXJcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGxvZygzLCBcImFkZGVkIFwiICsgTkFNRVNQQUNFICsgXCIgdG8gY29udHJvbGxlclwiKTtcblx0XHRcdFx0U2NlbmUudXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0Kiogb3IgKipTZXQqKiB0aGUgY3VycmVudCBlbmFibGVkIHN0YXRlIG9mIHRoZSBzY2VuZS4gIFxuXHRcdCAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGlzYWJsZSB0aGlzIHNjZW5lIHdpdGhvdXQgcmVtb3Zpbmcgb3IgZGVzdHJveWluZyBpdC5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI2VuYWJsZWRcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlXG5cdFx0ICogdmFyIGVuYWJsZWQgPSBzY2VuZS5lbmFibGVkKCk7XG5cdFx0ICpcblx0XHQgKiAvLyBkaXNhYmxlIHRoZSBzY2VuZVxuXHRcdCAqIHNjZW5lLmVuYWJsZWQoZmFsc2UpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbbmV3U3RhdGVdIC0gVGhlIG5ldyBlbmFibGVkIHN0YXRlIG9mIHRoZSBzY2VuZSBgdHJ1ZWAgb3IgYGZhbHNlYC5cblx0XHQgKiBAcmV0dXJucyB7KGJvb2xlYW58U2NlbmUpfSBDdXJyZW50IGVuYWJsZWQgc3RhdGUgb3IgcGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5lbmFibGVkID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHsgLy8gZ2V0XG5cdFx0XHRcdHJldHVybiBfZW5hYmxlZDtcblx0XHRcdH0gZWxzZSBpZiAoX2VuYWJsZWQgIT0gbmV3U3RhdGUpIHsgLy8gc2V0XG5cdFx0XHRcdF9lbmFibGVkID0gISEgbmV3U3RhdGU7XG5cdFx0XHRcdFNjZW5lLnVwZGF0ZSh0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIHRoZSBzY2VuZSBmcm9tIHRoZSBjb250cm9sbGVyLiAgXG5cdFx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCB0byBgQ29udHJvbGxlci5yZW1vdmVTY2VuZShzY2VuZSlgLlxuXHRcdCAqIFRoZSBzY2VuZSB3aWxsIG5vdCBiZSB1cGRhdGVkIGFueW1vcmUgdW50aWwgeW91IHJlYWRkIGl0IHRvIGEgY29udHJvbGxlci5cblx0XHQgKiBUbyByZW1vdmUgdGhlIHBpbiBvciB0aGUgdHdlZW4geW91IG5lZWQgdG8gY2FsbCByZW1vdmVUd2VlbigpIG9yIHJlbW92ZVBpbigpIHJlc3BlY3RpdmVseS5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3JlbW92ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gcmVtb3ZlIHRoZSBzY2VuZSBmcm9tIGl0cyBjb250cm9sbGVyXG5cdFx0ICogc2NlbmUucmVtb3ZlKCk7XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKF9jb250cm9sbGVyKSB7XG5cdFx0XHRcdF9jb250cm9sbGVyLmluZm8oXCJjb250YWluZXJcIikucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25Db250YWluZXJSZXNpemUpO1xuXHRcdFx0XHR2YXIgdG1wUGFyZW50ID0gX2NvbnRyb2xsZXI7XG5cdFx0XHRcdF9jb250cm9sbGVyID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR0bXBQYXJlbnQucmVtb3ZlU2NlbmUoU2NlbmUpO1xuXHRcdFx0XHRTY2VuZS50cmlnZ2VyKFwicmVtb3ZlXCIpO1xuXHRcdFx0XHRsb2coMywgXCJyZW1vdmVkIFwiICsgTkFNRVNQQUNFICsgXCIgZnJvbSBjb250cm9sbGVyXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95IHRoZSBzY2VuZSBhbmQgZXZlcnl0aGluZy5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI2Rlc3Ryb3lcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGRlc3Ryb3kgdGhlIHNjZW5lIHdpdGhvdXQgcmVzZXR0aW5nIHRoZSBwaW4gYW5kIHR3ZWVuIHRvIHRoZWlyIGluaXRpYWwgcG9zaXRpb25zXG5cdFx0ICogc2NlbmUgPSBzY2VuZS5kZXN0cm95KCk7XG5cdFx0ICpcblx0XHQgKiAvLyBkZXN0cm95IHRoZSBzY2VuZSBhbmQgcmVzZXQgdGhlIHBpbiBhbmQgdHdlZW5cblx0XHQgKiBzY2VuZSA9IHNjZW5lLmRlc3Ryb3kodHJ1ZSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD1mYWxzZV0gLSBJZiBgdHJ1ZWAgdGhlIHBpbiBhbmQgdHdlZW4gKGlmIGV4aXN0ZW50KSB3aWxsIGJlIHJlc2V0LlxuXHRcdCAqIEByZXR1cm5zIHtudWxsfSBOdWxsIHRvIHVuc2V0IGhhbmRsZXIgdmFyaWFibGVzLlxuXHRcdCAqL1xuXHRcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uIChyZXNldCkge1xuXHRcdFx0U2NlbmUudHJpZ2dlcihcImRlc3Ryb3lcIiwge1xuXHRcdFx0XHRyZXNldDogcmVzZXRcblx0XHRcdH0pO1xuXHRcdFx0U2NlbmUucmVtb3ZlKCk7XG5cdFx0XHRTY2VuZS5vZmYoXCIqLipcIik7XG5cdFx0XHRsb2coMywgXCJkZXN0cm95ZWQgXCIgKyBOQU1FU1BBQ0UgKyBcIiAocmVzZXQ6IFwiICsgKHJlc2V0ID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpICsgXCIpXCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgU2NlbmUgdG8gcmVmbGVjdCB0aGUgY3VycmVudCBzdGF0ZS4gIFxuXHRcdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgdG8gYENvbnRyb2xsZXIudXBkYXRlU2NlbmUoc2NlbmUsIGltbWVkaWF0ZWx5KWAuICBcblx0XHQgKiBUaGUgdXBkYXRlIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBzY2VuZSdzIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24gKGJhc2VkIG9uIHRoZSB0cmlnZ2VyIGVsZW1lbnQsIHRyaWdnZXIgaG9vaywgZHVyYXRpb24gYW5kIG9mZnNldCkgYW5kIGNoZWNrcyBpdCBhZ2FpbnN0IHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyLiAgXG5cdFx0ICogSXQgdGhlbiB1cGRhdGVzIHRoZSBjdXJyZW50IHNjZW5lIHN0YXRlIGFjY29yZGluZ2x5IChvciBkb2VzIG5vdGhpbmcsIGlmIHRoZSBzdGF0ZSBpcyBhbHJlYWR5IGNvcnJlY3QpIOKAkyBQaW5zIHdpbGwgYmUgc2V0IHRvIHRoZWlyIGNvcnJlY3QgcG9zaXRpb24gYW5kIHR3ZWVucyB3aWxsIGJlIHVwZGF0ZWQgdG8gdGhlaXIgY29ycmVjdCBwcm9ncmVzcy5cblx0XHQgKiBUaGlzIG1lYW5zIGFuIHVwZGF0ZSBkb2Vzbid0IG5lY2Vzc2FyaWx5IHJlc3VsdCBpbiBhIHByb2dyZXNzIGNoYW5nZS4gVGhlIGBwcm9ncmVzc2AgZXZlbnQgd2lsbCBiZSBmaXJlZCBpZiB0aGUgcHJvZ3Jlc3MgaGFzIGluZGVlZCBjaGFuZ2VkIGJldHdlZW4gdGhpcyB1cGRhdGUgYW5kIHRoZSBsYXN0LiAgXG5cdFx0ICogXyoqTk9URToqKiBUaGlzIG1ldGhvZCBnZXRzIGNhbGxlZCBjb25zdGFudGx5IHdoZW5ldmVyIFNjcm9sbE1hZ2ljIGRldGVjdHMgYSBjaGFuZ2UuIFRoZSBvbmx5IGFwcGxpY2F0aW9uIGZvciB5b3UgaXMgaWYgeW91IGNoYW5nZSBzb21ldGhpbmcgb3V0c2lkZSBvZiB0aGUgcmVhbG0gb2YgU2Nyb2xsTWFnaWMsIGxpa2UgbW92aW5nIHRoZSB0cmlnZ2VyIG9yIGNoYW5naW5nIHR3ZWVuIHBhcmFtZXRlcnMuX1xuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjdXBkYXRlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyB1cGRhdGUgdGhlIHNjZW5lIG9uIG5leHQgdGlja1xuXHRcdCAqIHNjZW5lLnVwZGF0ZSgpO1xuXHRcdCAqXG5cdFx0ICogLy8gdXBkYXRlIHRoZSBzY2VuZSBpbW1lZGlhdGVseVxuXHRcdCAqIHNjZW5lLnVwZGF0ZSh0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEBmaXJlcyBTY2VuZS51cGRhdGVcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbWVkaWF0ZWx5PWZhbHNlXSAtIElmIGB0cnVlYCB0aGUgdXBkYXRlIHdpbGwgYmUgaW5zdGFudCwgaWYgYGZhbHNlYCBpdCB3aWxsIHdhaXQgdW50aWwgbmV4dCB1cGRhdGUgY3ljbGUgKGJldHRlciBwZXJmb3JtYW5jZSkuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbW1lZGlhdGVseSkge1xuXHRcdFx0aWYgKF9jb250cm9sbGVyKSB7XG5cdFx0XHRcdGlmIChpbW1lZGlhdGVseSkge1xuXHRcdFx0XHRcdGlmIChfY29udHJvbGxlci5lbmFibGVkKCkgJiYgX2VuYWJsZWQpIHtcblx0XHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0c2Nyb2xsUG9zID0gX2NvbnRyb2xsZXIuaW5mbyhcInNjcm9sbFBvc1wiKSxcblx0XHRcdFx0XHRcdFx0bmV3UHJvZ3Jlc3M7XG5cblx0XHRcdFx0XHRcdGlmIChfb3B0aW9ucy5kdXJhdGlvbiA+IDApIHtcblx0XHRcdFx0XHRcdFx0bmV3UHJvZ3Jlc3MgPSAoc2Nyb2xsUG9zIC0gX3Njcm9sbE9mZnNldC5zdGFydCkgLyAoX3Njcm9sbE9mZnNldC5lbmQgLSBfc2Nyb2xsT2Zmc2V0LnN0YXJ0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5ld1Byb2dyZXNzID0gc2Nyb2xsUG9zID49IF9zY3JvbGxPZmZzZXQuc3RhcnQgPyAxIDogMDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0U2NlbmUudHJpZ2dlcihcInVwZGF0ZVwiLCB7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0UG9zOiBfc2Nyb2xsT2Zmc2V0LnN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRlbmRQb3M6IF9zY3JvbGxPZmZzZXQuZW5kLFxuXHRcdFx0XHRcdFx0XHRzY3JvbGxQb3M6IHNjcm9sbFBvc1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFNjZW5lLnByb2dyZXNzKG5ld1Byb2dyZXNzKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKF9waW4gJiYgX3N0YXRlID09PSBTQ0VORV9TVEFURV9EVVJJTkcpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZVBpblN0YXRlKHRydWUpOyAvLyB1bnBpbiBpbiBwb3NpdGlvblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfY29udHJvbGxlci51cGRhdGVTY2VuZShTY2VuZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgZHluYW1pYyBzY2VuZSB2YXJpYWJsZXMgbGlrZSB0aGUgdHJpZ2dlciBlbGVtZW50IHBvc2l0aW9uIG9yIHRoZSBkdXJhdGlvbi5cblx0XHQgKiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBpbiByZWd1bGFyIGludGVydmFscyBmcm9tIHRoZSBjb250cm9sbGVyLiBTZWUge0BsaW5rIFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXJ9IG9wdGlvbiBgcmVmcmVzaEludGVydmFsYC5cblx0XHQgKiBcblx0XHQgKiBZb3UgY2FuIGNhbGwgaXQgdG8gbWluaW1pemUgbGFnLCBmb3IgZXhhbXBsZSB3aGVuIHlvdSBpbnRlbnRpb25hbGx5IGNoYW5nZSB0aGUgcG9zaXRpb24gb2YgdGhlIHRyaWdnZXJFbGVtZW50LlxuXHRcdCAqIElmIHlvdSBkb24ndCBpdCB3aWxsIHNpbXBseSBiZSB1cGRhdGVkIGluIHRoZSBuZXh0IHJlZnJlc2ggaW50ZXJ2YWwgb2YgdGhlIGNvbnRhaW5lciwgd2hpY2ggaXMgdXN1YWxseSBzdWZmaWNpZW50LlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNyZWZyZXNoXG5cdFx0ICogQHNpbmNlIDEuMS4wXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZSA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7dHJpZ2dlckVsZW1lbnQ6IFwiI3RyaWdnZXJcIn0pO1xuXHRcdCAqIFxuXHRcdCAqIC8vIGNoYW5nZSB0aGUgcG9zaXRpb24gb2YgdGhlIHRyaWdnZXJcblx0XHQgKiAkKFwiI3RyaWdnZXJcIikuY3NzKFwidG9wXCIsIDUwMCk7XG5cdFx0ICogLy8gaW1tZWRpYXRlbHkgbGV0IHRoZSBzY2VuZSBrbm93IG9mIHRoaXMgY2hhbmdlXG5cdFx0ICogc2NlbmUucmVmcmVzaCgpO1xuXHRcdCAqXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5zaGlmdH0sIGlmIHRoZSB0cmlnZ2VyIGVsZW1lbnQgcG9zaXRpb24gb3IgdGhlIGR1cmF0aW9uIGNoYW5nZWRcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmNoYW5nZX0sIGlmIHRoZSBkdXJhdGlvbiBjaGFuZ2VkXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHVwZGF0ZUR1cmF0aW9uKCk7XG5cdFx0XHR1cGRhdGVUcmlnZ2VyRWxlbWVudFBvc2l0aW9uKCk7XG5cdFx0XHQvLyB1cGRhdGUgdHJpZ2dlciBlbGVtZW50IHBvc2l0aW9uXG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0Kiogb3IgKipTZXQqKiB0aGUgc2NlbmUncyBwcm9ncmVzcy4gIFxuXHRcdCAqIFVzdWFsbHkgaXQgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSB0byB1c2UgdGhpcyBhcyBhIHNldHRlciwgYXMgaXQgaXMgc2V0IGF1dG9tYXRpY2FsbHkgYnkgc2NlbmUudXBkYXRlKCkuICBcblx0XHQgKiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIGV2ZW50cyBhcmUgZmlyZWQgZGVwZW5kcyBvbiB0aGUgZHVyYXRpb24gb2YgdGhlIHNjZW5lOlxuXHRcdCAqICAxLiBTY2VuZXMgd2l0aCBgZHVyYXRpb24gPT0gMGA6ICBcblx0XHQgKiAgU2NlbmVzIHRoYXQgaGF2ZSBubyBkdXJhdGlvbiBieSBkZWZpbml0aW9uIGhhdmUgbm8gZW5kaW5nLiBUaHVzIHRoZSBgZW5kYCBldmVudCB3aWxsIG5ldmVyIGJlIGZpcmVkLiAgXG5cdFx0ICogIFdoZW4gdGhlIHRyaWdnZXIgcG9zaXRpb24gb2YgdGhlIHNjZW5lIGlzIHBhc3NlZCB0aGUgZXZlbnRzIGFyZSBhbHdheXMgZmlyZWQgaW4gdGhpcyBvcmRlcjogIFxuXHRcdCAqICBgZW50ZXJgLCBgc3RhcnRgLCBgcHJvZ3Jlc3NgIHdoZW4gc2Nyb2xsaW5nIGZvcndhcmQgIFxuXHRcdCAqICBhbmQgIFxuXHRcdCAqICBgcHJvZ3Jlc3NgLCBgc3RhcnRgLCBgbGVhdmVgIHdoZW4gc2Nyb2xsaW5nIGluIHJldmVyc2Vcblx0XHQgKiAgMi4gU2NlbmVzIHdpdGggYGR1cmF0aW9uID4gMGA6ICBcblx0XHQgKiAgU2NlbmVzIHdpdGggYSBzZXQgZHVyYXRpb24gaGF2ZSBhIGRlZmluZWQgc3RhcnQgYW5kIGVuZCBwb2ludC4gIFxuXHRcdCAqICBXaGVuIHNjcm9sbGluZyBwYXN0IHRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc2NlbmUgaXQgd2lsbCBmaXJlIHRoZXNlIGV2ZW50cyBpbiB0aGlzIG9yZGVyOiAgXG5cdFx0ICogIGBlbnRlcmAsIGBzdGFydGAsIGBwcm9ncmVzc2AgIFxuXHRcdCAqICBXaGVuIGNvbnRpbnVpbmcgdG8gc2Nyb2xsIGFuZCBwYXNzaW5nIHRoZSBlbmQgcG9pbnQgaXQgd2lsbCBmaXJlIHRoZXNlIGV2ZW50czogIFxuXHRcdCAqICBgcHJvZ3Jlc3NgLCBgZW5kYCwgYGxlYXZlYCAgXG5cdFx0ICogIFdoZW4gcmV2ZXJzaW5nIHRocm91Z2ggdGhlIGVuZCBwb2ludCB0aGVzZSBldmVudHMgYXJlIGZpcmVkOiAgXG5cdFx0ICogIGBlbnRlcmAsIGBlbmRgLCBgcHJvZ3Jlc3NgICBcblx0XHQgKiAgQW5kIHdoZW4gY29udGludWluZyB0byBzY3JvbGwgcGFzdCB0aGUgc3RhcnQgcG9zaXRpb24gaW4gcmV2ZXJzZSBpdCB3aWxsIGZpcmU6ICBcblx0XHQgKiAgYHByb2dyZXNzYCwgYHN0YXJ0YCwgYGxlYXZlYCAgXG5cdFx0ICogIEluIGJldHdlZW4gc3RhcnQgYW5kIGVuZCB0aGUgYHByb2dyZXNzYCBldmVudCB3aWxsIGJlIGNhbGxlZCBjb25zdGFudGx5LCB3aGVuZXZlciB0aGUgcHJvZ3Jlc3MgY2hhbmdlcy5cblx0XHQgKiBcblx0XHQgKiBJbiBzaG9ydDogIFxuXHRcdCAqIGBlbnRlcmAgZXZlbnRzIHdpbGwgYWx3YXlzIHRyaWdnZXIgKipiZWZvcmUqKiB0aGUgcHJvZ3Jlc3MgdXBkYXRlIGFuZCBgbGVhdmVgIGVudmVudHMgd2lsbCB0cmlnZ2VyICoqYWZ0ZXIqKiB0aGUgcHJvZ3Jlc3MgdXBkYXRlLiAgXG5cdFx0ICogYHN0YXJ0YCBhbmQgYGVuZGAgd2lsbCBhbHdheXMgdHJpZ2dlciBhdCB0aGVpciByZXNwZWN0aXZlIHBvc2l0aW9uLlxuXHRcdCAqIFxuXHRcdCAqIFBsZWFzZSByZXZpZXcgdGhlIGV2ZW50IGRlc2NyaXB0aW9ucyBmb3IgZGV0YWlscyBvbiB0aGUgZXZlbnRzIGFuZCB0aGUgZXZlbnQgb2JqZWN0IHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cblx0XHQgKiBcblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3Byb2dyZXNzXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgc2NlbmUgcHJvZ3Jlc3Ncblx0XHQgKiB2YXIgcHJvZ3Jlc3MgPSBzY2VuZS5wcm9ncmVzcygpO1xuXHRcdCAqXG5cdFx0ICogLy8gc2V0IG5ldyBzY2VuZSBwcm9ncmVzc1xuXHRcdCAqIHNjZW5lLnByb2dyZXNzKDAuMyk7XG5cdFx0ICpcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmVudGVyfSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuc3RhcnR9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5wcm9ncmVzc30sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmVuZH0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmxlYXZlfSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IFtwcm9ncmVzc10gLSBUaGUgbmV3IHByb2dyZXNzIHZhbHVlIG9mIHRoZSBzY2VuZSBgWzAtMV1gLlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IGBnZXRgIC0gIEN1cnJlbnQgc2NlbmUgcHJvZ3Jlc3MuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBgc2V0YCAtICBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnByb2dyZXNzID0gZnVuY3Rpb24gKHByb2dyZXNzKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHsgLy8gZ2V0XG5cdFx0XHRcdHJldHVybiBfcHJvZ3Jlc3M7XG5cdFx0XHR9IGVsc2UgeyAvLyBzZXRcblx0XHRcdFx0dmFyXG5cdFx0XHRcdGRvVXBkYXRlID0gZmFsc2UsXG5cdFx0XHRcdFx0b2xkU3RhdGUgPSBfc3RhdGUsXG5cdFx0XHRcdFx0c2Nyb2xsRGlyZWN0aW9uID0gX2NvbnRyb2xsZXIgPyBfY29udHJvbGxlci5pbmZvKFwic2Nyb2xsRGlyZWN0aW9uXCIpIDogJ1BBVVNFRCcsXG5cdFx0XHRcdFx0cmV2ZXJzZU9yRm9yd2FyZCA9IF9vcHRpb25zLnJldmVyc2UgfHwgcHJvZ3Jlc3MgPj0gX3Byb2dyZXNzO1xuXHRcdFx0XHRpZiAoX29wdGlvbnMuZHVyYXRpb24gPT09IDApIHtcblx0XHRcdFx0XHQvLyB6ZXJvIGR1cmF0aW9uIHNjZW5lc1xuXHRcdFx0XHRcdGRvVXBkYXRlID0gX3Byb2dyZXNzICE9IHByb2dyZXNzO1xuXHRcdFx0XHRcdF9wcm9ncmVzcyA9IHByb2dyZXNzIDwgMSAmJiByZXZlcnNlT3JGb3J3YXJkID8gMCA6IDE7XG5cdFx0XHRcdFx0X3N0YXRlID0gX3Byb2dyZXNzID09PSAwID8gU0NFTkVfU1RBVEVfQkVGT1JFIDogU0NFTkVfU1RBVEVfRFVSSU5HO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHNjZW5lcyB3aXRoIHN0YXJ0IGFuZCBlbmRcblx0XHRcdFx0XHRpZiAocHJvZ3Jlc3MgPCAwICYmIF9zdGF0ZSAhPT0gU0NFTkVfU1RBVEVfQkVGT1JFICYmIHJldmVyc2VPckZvcndhcmQpIHtcblx0XHRcdFx0XHRcdC8vIGdvIGJhY2sgdG8gaW5pdGlhbCBzdGF0ZVxuXHRcdFx0XHRcdFx0X3Byb2dyZXNzID0gMDtcblx0XHRcdFx0XHRcdF9zdGF0ZSA9IFNDRU5FX1NUQVRFX0JFRk9SRTtcblx0XHRcdFx0XHRcdGRvVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb2dyZXNzID49IDAgJiYgcHJvZ3Jlc3MgPCAxICYmIHJldmVyc2VPckZvcndhcmQpIHtcblx0XHRcdFx0XHRcdF9wcm9ncmVzcyA9IHByb2dyZXNzO1xuXHRcdFx0XHRcdFx0X3N0YXRlID0gU0NFTkVfU1RBVEVfRFVSSU5HO1xuXHRcdFx0XHRcdFx0ZG9VcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHJvZ3Jlc3MgPj0gMSAmJiBfc3RhdGUgIT09IFNDRU5FX1NUQVRFX0FGVEVSKSB7XG5cdFx0XHRcdFx0XHRfcHJvZ3Jlc3MgPSAxO1xuXHRcdFx0XHRcdFx0X3N0YXRlID0gU0NFTkVfU1RBVEVfQUZURVI7XG5cdFx0XHRcdFx0XHRkb1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0RVUklORyAmJiAhcmV2ZXJzZU9yRm9yd2FyZCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlUGluU3RhdGUoKTsgLy8gaW4gY2FzZSB3ZSBzY3JvbGxlZCBiYWNrd2FyZHMgbWlkLXNjZW5lIGFuZCByZXZlcnNlIGlzIGRpc2FibGVkID0+IHVwZGF0ZSB0aGUgcGluIHBvc2l0aW9uLCBzbyBpdCBkb2Vzbid0IG1vdmUgYmFjayBhcyB3ZWxsLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZG9VcGRhdGUpIHtcblx0XHRcdFx0XHQvLyBmaXJlIGV2ZW50c1xuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdGV2ZW50VmFycyA9IHtcblx0XHRcdFx0XHRcdHByb2dyZXNzOiBfcHJvZ3Jlc3MsXG5cdFx0XHRcdFx0XHRzdGF0ZTogX3N0YXRlLFxuXHRcdFx0XHRcdFx0c2Nyb2xsRGlyZWN0aW9uOiBzY3JvbGxEaXJlY3Rpb25cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0c3RhdGVDaGFuZ2VkID0gX3N0YXRlICE9IG9sZFN0YXRlO1xuXG5cdFx0XHRcdFx0dmFyIHRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IC8vIHRtcCBoZWxwZXIgdG8gc2ltcGxpZnkgY29kZVxuXHRcdFx0XHRcdFx0U2NlbmUudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50VmFycyk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmIChzdGF0ZUNoYW5nZWQpIHsgLy8gZW50ZXIgZXZlbnRzXG5cdFx0XHRcdFx0XHRpZiAob2xkU3RhdGUgIT09IFNDRU5FX1NUQVRFX0RVUklORykge1xuXHRcdFx0XHRcdFx0XHR0cmlnZ2VyKFwiZW50ZXJcIik7XG5cdFx0XHRcdFx0XHRcdHRyaWdnZXIob2xkU3RhdGUgPT09IFNDRU5FX1NUQVRFX0JFRk9SRSA/IFwic3RhcnRcIiA6IFwiZW5kXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0cmlnZ2VyKFwicHJvZ3Jlc3NcIik7XG5cdFx0XHRcdFx0aWYgKHN0YXRlQ2hhbmdlZCkgeyAvLyBsZWF2ZSBldmVudHNcblx0XHRcdFx0XHRcdGlmIChfc3RhdGUgIT09IFNDRU5FX1NUQVRFX0RVUklORykge1xuXHRcdFx0XHRcdFx0XHR0cmlnZ2VyKF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfQkVGT1JFID8gXCJzdGFydFwiIDogXCJlbmRcIik7XG5cdFx0XHRcdFx0XHRcdHRyaWdnZXIoXCJsZWF2ZVwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0XHR9XG5cdFx0fTtcblxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBzdGFydCBhbmQgZW5kIHNjcm9sbE9mZnNldCBvZiB0aGUgY29udGFpbmVyLlxuXHRcdCAqIFRoZSBwb3NpdGlvbnMgcmVmbGVjdCB3aGF0IHRoZSBjb250cm9sbGVyJ3Mgc2Nyb2xsIHBvc2l0aW9uIHdpbGwgYmUgYXQgdGhlIHN0YXJ0IGFuZCBlbmQgcmVzcGVjdGl2ZWx5LlxuXHRcdCAqIElzIGNhbGxlZCwgd2hlbjpcblx0XHQgKiAgIC0gU2NlbmUgZXZlbnQgXCJjaGFuZ2VcIiBpcyBjYWxsZWQgd2l0aDogb2Zmc2V0LCB0cmlnZ2VySG9vaywgZHVyYXRpb24gXG5cdFx0ICogICAtIHNjcm9sbCBjb250YWluZXIgZXZlbnQgXCJyZXNpemVcIiBpcyBjYWxsZWRcblx0XHQgKiAgIC0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0cmlnZ2VyRWxlbWVudCBjaGFuZ2VzXG5cdFx0ICogICAtIHRoZSBjb250cm9sbGVyIGNoYW5nZXMgLT4gYWRkVG8oKVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHVwZGF0ZVNjcm9sbE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdF9zY3JvbGxPZmZzZXQgPSB7XG5cdFx0XHRcdHN0YXJ0OiBfdHJpZ2dlclBvcyArIF9vcHRpb25zLm9mZnNldFxuXHRcdFx0fTtcblx0XHRcdGlmIChfY29udHJvbGxlciAmJiBfb3B0aW9ucy50cmlnZ2VyRWxlbWVudCkge1xuXHRcdFx0XHQvLyB0YWtlIGF3YXkgdHJpZ2dlckhvb2sgcG9ydGlvbiB0byBnZXQgcmVsYXRpdmUgdG8gdG9wXG5cdFx0XHRcdF9zY3JvbGxPZmZzZXQuc3RhcnQgLT0gX2NvbnRyb2xsZXIuaW5mbyhcInNpemVcIikgKiBfb3B0aW9ucy50cmlnZ2VySG9vaztcblx0XHRcdH1cblx0XHRcdF9zY3JvbGxPZmZzZXQuZW5kID0gX3Njcm9sbE9mZnNldC5zdGFydCArIF9vcHRpb25zLmR1cmF0aW9uO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBkdXJhdGlvbiBpZiBzZXQgdG8gYSBkeW5hbWljIGZ1bmN0aW9uLlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBzY2VuZSBpcyBhZGRlZCB0byBhIGNvbnRyb2xsZXIgYW5kIGluIHJlZ3VsYXIgaW50ZXJ2YWxzIGZyb20gdGhlIGNvbnRyb2xsZXIgdGhyb3VnaCBzY2VuZS5yZWZyZXNoKCkuXG5cdFx0ICogXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5jaGFuZ2V9LCBpZiB0aGUgZHVyYXRpb24gY2hhbmdlZFxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuc2hpZnR9LCBpZiB0aGUgZHVyYXRpb24gY2hhbmdlZFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbc3VwcHJlc3NFdmVudHM9ZmFsc2VdIC0gSWYgdHJ1ZSB0aGUgc2hpZnQgZXZlbnQgd2lsbCBiZSBzdXBwcmVzc2VkLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHVwZGF0ZUR1cmF0aW9uID0gZnVuY3Rpb24gKHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHQvLyB1cGRhdGUgZHVyYXRpb25cblx0XHRcdGlmIChfZHVyYXRpb25VcGRhdGVNZXRob2QpIHtcblx0XHRcdFx0dmFyIHZhcm5hbWUgPSBcImR1cmF0aW9uXCI7XG5cdFx0XHRcdGlmIChjaGFuZ2VPcHRpb24odmFybmFtZSwgX2R1cmF0aW9uVXBkYXRlTWV0aG9kLmNhbGwoU2NlbmUpKSAmJiAhc3VwcHJlc3NFdmVudHMpIHsgLy8gc2V0XG5cdFx0XHRcdFx0U2NlbmUudHJpZ2dlcihcImNoYW5nZVwiLCB7XG5cdFx0XHRcdFx0XHR3aGF0OiB2YXJuYW1lLFxuXHRcdFx0XHRcdFx0bmV3dmFsOiBfb3B0aW9uc1t2YXJuYW1lXVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFNjZW5lLnRyaWdnZXIoXCJzaGlmdFwiLCB7XG5cdFx0XHRcdFx0XHRyZWFzb246IHZhcm5hbWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHJpZ2dlckVsZW1lbnQsIGlmIHByZXNlbnQuXG5cdFx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIC4uLlxuXHRcdCAqICAtIC4uLiB3aGVuIHRoZSB0cmlnZ2VyRWxlbWVudCBpcyBjaGFuZ2VkXG5cdFx0ICogIC0gLi4uIHdoZW4gdGhlIHNjZW5lIGlzIGFkZGVkIHRvIGEgKG5ldykgY29udHJvbGxlclxuXHRcdCAqICAtIC4uLiBpbiByZWd1bGFyIGludGVydmFscyBmcm9tIHRoZSBjb250cm9sbGVyIHRocm91Z2ggc2NlbmUucmVmcmVzaCgpLlxuXHRcdCAqIFxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuc2hpZnR9LCBpZiB0aGUgcG9zaXRpb24gY2hhbmdlZFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbc3VwcHJlc3NFdmVudHM9ZmFsc2VdIC0gSWYgdHJ1ZSB0aGUgc2hpZnQgZXZlbnQgd2lsbCBiZSBzdXBwcmVzc2VkLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHVwZGF0ZVRyaWdnZXJFbGVtZW50UG9zaXRpb24gPSBmdW5jdGlvbiAoc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHZhclxuXHRcdFx0ZWxlbWVudFBvcyA9IDAsXG5cdFx0XHRcdHRlbGVtID0gX29wdGlvbnMudHJpZ2dlckVsZW1lbnQ7XG5cdFx0XHRpZiAoX2NvbnRyb2xsZXIgJiYgdGVsZW0pIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdGNvbnRyb2xsZXJJbmZvID0gX2NvbnRyb2xsZXIuaW5mbygpLFxuXHRcdFx0XHRcdGNvbnRhaW5lck9mZnNldCA9IF91dGlsLmdldC5vZmZzZXQoY29udHJvbGxlckluZm8uY29udGFpbmVyKSxcblx0XHRcdFx0XHQvLyBjb250YWluZXIgcG9zaXRpb24gaXMgbmVlZGVkIGJlY2F1c2UgZWxlbWVudCBvZmZzZXQgaXMgcmV0dXJuZWQgaW4gcmVsYXRpb24gdG8gZG9jdW1lbnQsIG5vdCBpbiByZWxhdGlvbiB0byBjb250YWluZXIuXG5cdFx0XHRcdFx0cGFyYW0gPSBjb250cm9sbGVySW5mby52ZXJ0aWNhbCA/IFwidG9wXCIgOiBcImxlZnRcIjsgLy8gd2hpY2ggcGFyYW0gaXMgb2YgaW50ZXJlc3QgP1xuXHRcdFx0XHQvLyBpZiBwYXJlbnQgaXMgc3BhY2VyLCB1c2Ugc3BhY2VyIHBvc2l0aW9uIGluc3RlYWQgc28gY29ycmVjdCBzdGFydCBwb3NpdGlvbiBpcyByZXR1cm5lZCBmb3IgcGlubmVkIGVsZW1lbnRzLlxuXHRcdFx0XHR3aGlsZSAodGVsZW0ucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoUElOX1NQQUNFUl9BVFRSSUJVVEUpKSB7XG5cdFx0XHRcdFx0dGVsZW0gPSB0ZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGVsZW1lbnRPZmZzZXQgPSBfdXRpbC5nZXQub2Zmc2V0KHRlbGVtKTtcblxuXHRcdFx0XHRpZiAoIWNvbnRyb2xsZXJJbmZvLmlzRG9jdW1lbnQpIHsgLy8gY29udGFpbmVyIGlzIG5vdCB0aGUgZG9jdW1lbnQgcm9vdCwgc28gc3Vic3RyYWN0IHNjcm9sbCBQb3NpdGlvbiB0byBnZXQgY29ycmVjdCB0cmlnZ2VyIGVsZW1lbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gc2Nyb2xsY29udGVudFxuXHRcdFx0XHRcdGNvbnRhaW5lck9mZnNldFtwYXJhbV0gLT0gX2NvbnRyb2xsZXIuc2Nyb2xsUG9zKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtZW50UG9zID0gZWxlbWVudE9mZnNldFtwYXJhbV0gLSBjb250YWluZXJPZmZzZXRbcGFyYW1dO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGNoYW5nZWQgPSBlbGVtZW50UG9zICE9IF90cmlnZ2VyUG9zO1xuXHRcdFx0X3RyaWdnZXJQb3MgPSBlbGVtZW50UG9zO1xuXHRcdFx0aWYgKGNoYW5nZWQgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFNjZW5lLnRyaWdnZXIoXCJzaGlmdFwiLCB7XG5cdFx0XHRcdFx0cmVhc29uOiBcInRyaWdnZXJFbGVtZW50UG9zaXRpb25cIlxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlciBhIHNoaWZ0IGV2ZW50LCB3aGVuIHRoZSBjb250YWluZXIgaXMgcmVzaXplZCBhbmQgdGhlIHRyaWdnZXJIb29rIGlzID4gMS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciBvbkNvbnRhaW5lclJlc2l6ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoX29wdGlvbnMudHJpZ2dlckhvb2sgPiAwKSB7XG5cdFx0XHRcdFNjZW5lLnRyaWdnZXIoXCJzaGlmdFwiLCB7XG5cdFx0XHRcdFx0cmVhc29uOiBcImNvbnRhaW5lclJlc2l6ZVwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgX3ZhbGlkYXRlID0gX3V0aWwuZXh0ZW5kKFNDRU5FX09QVElPTlMudmFsaWRhdGUsIHtcblx0XHRcdC8vIHZhbGlkYXRpb24gZm9yIGR1cmF0aW9uIGhhbmRsZWQgaW50ZXJuYWxseSBmb3IgcmVmZXJlbmNlIHRvIHByaXZhdGUgdmFyIF9kdXJhdGlvbk1ldGhvZFxuXHRcdFx0ZHVyYXRpb246IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0aWYgKF91dGlsLnR5cGUuU3RyaW5nKHZhbCkgJiYgdmFsLm1hdGNoKC9eKFxcLnxcXGQpKlxcZCslJC8pKSB7XG5cdFx0XHRcdFx0Ly8gcGVyY2VudGFnZSB2YWx1ZVxuXHRcdFx0XHRcdHZhciBwZXJjID0gcGFyc2VGbG9hdCh2YWwpIC8gMTAwO1xuXHRcdFx0XHRcdHZhbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBfY29udHJvbGxlciA/IF9jb250cm9sbGVyLmluZm8oXCJzaXplXCIpICogcGVyYyA6IDA7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX3V0aWwudHlwZS5GdW5jdGlvbih2YWwpKSB7XG5cdFx0XHRcdFx0Ly8gZnVuY3Rpb25cblx0XHRcdFx0XHRfZHVyYXRpb25VcGRhdGVNZXRob2QgPSB2YWw7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHZhbCA9IHBhcnNlRmxvYXQoX2R1cmF0aW9uVXBkYXRlTWV0aG9kKCkpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHZhbCA9IC0xOyAvLyB3aWxsIGNhdXNlIGVycm9yIGJlbG93XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHZhbCBoYXMgdG8gYmUgZmxvYXRcblx0XHRcdFx0dmFsID0gcGFyc2VGbG9hdCh2YWwpO1xuXHRcdFx0XHRpZiAoIV91dGlsLnR5cGUuTnVtYmVyKHZhbCkgfHwgdmFsIDwgMCkge1xuXHRcdFx0XHRcdGlmIChfZHVyYXRpb25VcGRhdGVNZXRob2QpIHtcblx0XHRcdFx0XHRcdF9kdXJhdGlvblVwZGF0ZU1ldGhvZCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdHRocm93IFtcIkludmFsaWQgcmV0dXJuIHZhbHVlIG9mIHN1cHBsaWVkIGZ1bmN0aW9uIGZvciBvcHRpb24gXFxcImR1cmF0aW9uXFxcIjpcIiwgdmFsXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgW1wiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJkdXJhdGlvblxcXCI6XCIsIHZhbF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBDaGVja3MgdGhlIHZhbGlkaXR5IG9mIGEgc3BlY2lmaWMgb3IgYWxsIG9wdGlvbnMgYW5kIHJlc2V0IHRvIGRlZmF1bHQgaWYgbmVjY2Vzc2FyeS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciB2YWxpZGF0ZU9wdGlvbiA9IGZ1bmN0aW9uIChjaGVjaykge1xuXHRcdFx0Y2hlY2sgPSBhcmd1bWVudHMubGVuZ3RoID8gW2NoZWNrXSA6IE9iamVjdC5rZXlzKF92YWxpZGF0ZSk7XG5cdFx0XHRjaGVjay5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb25OYW1lLCBrZXkpIHtcblx0XHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0XHRpZiAoX3ZhbGlkYXRlW29wdGlvbk5hbWVdKSB7IC8vIHRoZXJlIGlzIGEgdmFsaWRhdGlvbiBtZXRob2QgZm9yIHRoaXMgb3B0aW9uXG5cdFx0XHRcdFx0dHJ5IHsgLy8gdmFsaWRhdGUgdmFsdWVcblx0XHRcdFx0XHRcdHZhbHVlID0gX3ZhbGlkYXRlW29wdGlvbk5hbWVdKF9vcHRpb25zW29wdGlvbk5hbWVdKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7IC8vIHZhbGlkYXRpb24gZmFpbGVkIC0+IHJlc2V0IHRvIGRlZmF1bHRcblx0XHRcdFx0XHRcdHZhbHVlID0gREVGQVVMVF9PUFRJT05TW29wdGlvbk5hbWVdO1xuXHRcdFx0XHRcdFx0dmFyIGxvZ01TRyA9IF91dGlsLnR5cGUuU3RyaW5nKGUpID8gW2VdIDogZTtcblx0XHRcdFx0XHRcdGlmIChfdXRpbC50eXBlLkFycmF5KGxvZ01TRykpIHtcblx0XHRcdFx0XHRcdFx0bG9nTVNHWzBdID0gXCJFUlJPUjogXCIgKyBsb2dNU0dbMF07XG5cdFx0XHRcdFx0XHRcdGxvZ01TRy51bnNoaWZ0KDEpOyAvLyBsb2dsZXZlbCAxIGZvciBlcnJvciBtc2dcblx0XHRcdFx0XHRcdFx0bG9nLmFwcGx5KHRoaXMsIGxvZ01TRyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsb2coMSwgXCJFUlJPUjogUHJvYmxlbSBleGVjdXRpbmcgdmFsaWRhdGlvbiBjYWxsYmFjayBmb3Igb3B0aW9uICdcIiArIG9wdGlvbk5hbWUgKyBcIic6XCIsIGUubWVzc2FnZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdF9vcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGVscGVyIHVzZWQgYnkgdGhlIHNldHRlci9nZXR0ZXJzIGZvciBzY2VuZSBvcHRpb25zXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgY2hhbmdlT3B0aW9uID0gZnVuY3Rpb24gKHZhcm5hbWUsIG5ld3ZhbCkge1xuXHRcdFx0dmFyXG5cdFx0XHRjaGFuZ2VkID0gZmFsc2UsXG5cdFx0XHRcdG9sZHZhbCA9IF9vcHRpb25zW3Zhcm5hbWVdO1xuXHRcdFx0aWYgKF9vcHRpb25zW3Zhcm5hbWVdICE9IG5ld3ZhbCkge1xuXHRcdFx0XHRfb3B0aW9uc1t2YXJuYW1lXSA9IG5ld3ZhbDtcblx0XHRcdFx0dmFsaWRhdGVPcHRpb24odmFybmFtZSk7IC8vIHJlc2V0cyB0byBkZWZhdWx0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRjaGFuZ2VkID0gb2xkdmFsICE9IF9vcHRpb25zW3Zhcm5hbWVdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdC8vIGdlbmVyYXRlIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIG9wdGlvbnNcblx0XHR2YXIgYWRkU2NlbmVPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uTmFtZSkge1xuXHRcdFx0aWYgKCFTY2VuZVtvcHRpb25OYW1lXSkge1xuXHRcdFx0XHRTY2VuZVtvcHRpb25OYW1lXSA9IGZ1bmN0aW9uIChuZXdWYWwpIHtcblx0XHRcdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHsgLy8gZ2V0XG5cdFx0XHRcdFx0XHRyZXR1cm4gX29wdGlvbnNbb3B0aW9uTmFtZV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvcHRpb25OYW1lID09PSBcImR1cmF0aW9uXCIpIHsgLy8gbmV3IGR1cmF0aW9uIGlzIHNldCwgc28gYW55IHByZXZpb3VzbHkgc2V0IGZ1bmN0aW9uIG11c3QgYmUgdW5zZXRcblx0XHRcdFx0XHRcdFx0X2R1cmF0aW9uVXBkYXRlTWV0aG9kID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGNoYW5nZU9wdGlvbihvcHRpb25OYW1lLCBuZXdWYWwpKSB7IC8vIHNldFxuXHRcdFx0XHRcdFx0XHRTY2VuZS50cmlnZ2VyKFwiY2hhbmdlXCIsIHtcblx0XHRcdFx0XHRcdFx0XHR3aGF0OiBvcHRpb25OYW1lLFxuXHRcdFx0XHRcdFx0XHRcdG5ld3ZhbDogX29wdGlvbnNbb3B0aW9uTmFtZV1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGlmIChTQ0VORV9PUFRJT05TLnNoaWZ0cy5pbmRleE9mKG9wdGlvbk5hbWUpID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRTY2VuZS50cmlnZ2VyKFwic2hpZnRcIiwge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVhc29uOiBvcHRpb25OYW1lXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIG9yICoqU2V0KiogdGhlIGR1cmF0aW9uIG9wdGlvbiB2YWx1ZS5cblx0XHQgKiBBcyBhIHNldHRlciBpdCBhbHNvIGFjY2VwdHMgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBudW1lcmljIHZhbHVlLiAgXG5cdFx0ICogVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciByZXNwb25zaXZlIHNldHVwcy5cblx0XHQgKlxuXHRcdCAqIFRoZSBkdXJhdGlvbiBpcyB1cGRhdGVkIHVzaW5nIHRoZSBzdXBwbGllZCBmdW5jdGlvbiBldmVyeSB0aW1lIGBTY2VuZS5yZWZyZXNoKClgIGlzIGNhbGxlZCwgd2hpY2ggaGFwcGVucyBwZXJpb2RpY2FsbHkgZnJvbSB0aGUgY29udHJvbGxlciAoc2VlIFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIgb3B0aW9uIGByZWZyZXNoSW50ZXJ2YWxgKS4gIFxuXHRcdCAqIF8qKk5PVEU6KiogQmUgYXdhcmUgdGhhdCBpdCdzIGFuIGVhc3kgd2F5IHRvIGtpbGwgcGVyZm9ybWFuY2UsIGlmIHlvdSBzdXBwbHkgYSBmdW5jdGlvbiB0aGF0IGhhcyBoaWdoIENQVSBkZW1hbmQuICBcblx0XHQgKiBFdmVuIGZvciBzaXplIGFuZCBwb3NpdGlvbiBjYWxjdWxhdGlvbnMgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGEgdmFyaWFibGUgdG8gY2FjaGUgdGhlIHZhbHVlLiAoc2VlIGV4YW1wbGUpICBcblx0XHQgKiBUaGlzIGNvdW50cyBkb3VibGUgaWYgeW91IHVzZSB0aGUgc2FtZSBmdW5jdGlvbiBmb3IgbXVsdGlwbGUgc2NlbmVzLl9cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjZHVyYXRpb25cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCBkdXJhdGlvbiB2YWx1ZVxuXHRcdCAqIHZhciBkdXJhdGlvbiA9IHNjZW5lLmR1cmF0aW9uKCk7XG5cdFx0ICpcblx0XHQgKiAvLyBzZXQgYSBuZXcgZHVyYXRpb25cblx0XHQgKiBzY2VuZS5kdXJhdGlvbigzMDApO1xuXHRcdCAqXG5cdFx0ICogLy8gdXNlIGEgZnVuY3Rpb24gdG8gYXV0b21hdGljYWxseSBhZGp1c3QgdGhlIGR1cmF0aW9uIHRvIHRoZSB3aW5kb3cgaGVpZ2h0LlxuXHRcdCAqIHZhciBkdXJhdGlvblZhbHVlQ2FjaGU7XG5cdFx0ICogZnVuY3Rpb24gZ2V0RHVyYXRpb24gKCkge1xuXHRcdCAqICAgcmV0dXJuIGR1cmF0aW9uVmFsdWVDYWNoZTtcblx0XHQgKiB9XG5cdFx0ICogZnVuY3Rpb24gdXBkYXRlRHVyYXRpb24gKGUpIHtcblx0XHQgKiAgIGR1cmF0aW9uVmFsdWVDYWNoZSA9IHdpbmRvdy5pbm5lckhlaWdodDtcblx0XHQgKiB9XG5cdFx0ICogJCh3aW5kb3cpLm9uKFwicmVzaXplXCIsIHVwZGF0ZUR1cmF0aW9uKTsgLy8gdXBkYXRlIHRoZSBkdXJhdGlvbiB3aGVuIHRoZSB3aW5kb3cgc2l6ZSBjaGFuZ2VzXG5cdFx0ICogJCh3aW5kb3cpLnRyaWdnZXJIYW5kbGVyKFwicmVzaXplXCIpOyAvLyBzZXQgdG8gaW5pdGlhbCB2YWx1ZVxuXHRcdCAqIHNjZW5lLmR1cmF0aW9uKGdldER1cmF0aW9uKTsgLy8gc3VwcGx5IGR1cmF0aW9uIG1ldGhvZFxuXHRcdCAqXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5jaGFuZ2V9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5zaGlmdH0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAcGFyYW0geyhudW1iZXJ8ZnVuY3Rpb24pfSBbbmV3RHVyYXRpb25dIC0gVGhlIG5ldyBkdXJhdGlvbiBvZiB0aGUgc2NlbmUuXG5cdFx0ICogQHJldHVybnMge251bWJlcn0gYGdldGAgLSAgQ3VycmVudCBzY2VuZSBkdXJhdGlvbi5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IGBzZXRgIC0gIFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiBvciAqKlNldCoqIHRoZSBvZmZzZXQgb3B0aW9uIHZhbHVlLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjb2Zmc2V0XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgb2Zmc2V0XG5cdFx0ICogdmFyIG9mZnNldCA9IHNjZW5lLm9mZnNldCgpO1xuXHRcdCAqXG5cdFx0ICogLy8gc2V0IGEgbmV3IG9mZnNldFxuXHRcdCAqIHNjZW5lLm9mZnNldCgxMDApO1xuXHRcdCAqXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5jaGFuZ2V9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5zaGlmdH0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gW25ld09mZnNldF0gLSBUaGUgbmV3IG9mZnNldCBvZiB0aGUgc2NlbmUuXG5cdFx0ICogQHJldHVybnMge251bWJlcn0gYGdldGAgLSAgQ3VycmVudCBzY2VuZSBvZmZzZXQuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBgc2V0YCAtICBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0Kiogb3IgKipTZXQqKiB0aGUgdHJpZ2dlckVsZW1lbnQgb3B0aW9uIHZhbHVlLlxuXHRcdCAqIERvZXMgKipub3QqKiBmaXJlIGBTY2VuZS5zaGlmdGAsIGJlY2F1c2UgY2hhbmdpbmcgdGhlIHRyaWdnZXIgRWxlbWVudCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1lYW4gdGhlIHN0YXJ0IHBvc2l0aW9uIGNoYW5nZXMuIFRoaXMgd2lsbCBiZSBkZXRlcm1pbmVkIGluIGBTY2VuZS5yZWZyZXNoKClgLCB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHRyaWdnZXJlZC5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3RyaWdnZXJFbGVtZW50XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgdHJpZ2dlckVsZW1lbnRcblx0XHQgKiB2YXIgdHJpZ2dlckVsZW1lbnQgPSBzY2VuZS50cmlnZ2VyRWxlbWVudCgpO1xuXHRcdCAqXG5cdFx0ICogLy8gc2V0IGEgbmV3IHRyaWdnZXJFbGVtZW50IHVzaW5nIGEgc2VsZWN0b3Jcblx0XHQgKiBzY2VuZS50cmlnZ2VyRWxlbWVudChcIiN0cmlnZ2VyXCIpO1xuXHRcdCAqIC8vIHNldCBhIG5ldyB0cmlnZ2VyRWxlbWVudCB1c2luZyBhIERPTSBvYmplY3Rcblx0XHQgKiBzY2VuZS50cmlnZ2VyRWxlbWVudChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRyaWdnZXJcIikpO1xuXHRcdCAqXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5jaGFuZ2V9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IFtuZXdUcmlnZ2VyRWxlbWVudF0gLSBUaGUgbmV3IHRyaWdnZXIgZWxlbWVudCBmb3IgdGhlIHNjZW5lLlxuXHRcdCAqIEByZXR1cm5zIHsoc3RyaW5nfG9iamVjdCl9IGBnZXRgIC0gIEN1cnJlbnQgdHJpZ2dlckVsZW1lbnQuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBgc2V0YCAtICBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0Kiogb3IgKipTZXQqKiB0aGUgdHJpZ2dlckhvb2sgb3B0aW9uIHZhbHVlLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjdHJpZ2dlckhvb2tcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCB0cmlnZ2VySG9vayB2YWx1ZVxuXHRcdCAqIHZhciB0cmlnZ2VySG9vayA9IHNjZW5lLnRyaWdnZXJIb29rKCk7XG5cdFx0ICpcblx0XHQgKiAvLyBzZXQgYSBuZXcgdHJpZ2dlckhvb2sgdXNpbmcgYSBzdHJpbmdcblx0XHQgKiBzY2VuZS50cmlnZ2VySG9vayhcIm9uTGVhdmVcIik7XG5cdFx0ICogLy8gc2V0IGEgbmV3IHRyaWdnZXJIb29rIHVzaW5nIGEgbnVtYmVyXG5cdFx0ICogc2NlbmUudHJpZ2dlckhvb2soMC43KTtcblx0XHQgKlxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuY2hhbmdlfSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuc2hpZnR9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyl9IFtuZXdUcmlnZ2VySG9va10gLSBUaGUgbmV3IHRyaWdnZXJIb29rIG9mIHRoZSBzY2VuZS4gU2VlIHtAbGluayBTY2VuZX0gcGFyYW1ldGVyIGRlc2NyaXB0aW9uIGZvciB2YWx1ZSBvcHRpb25zLlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IGBnZXRgIC0gIEN1cnJlbnQgdHJpZ2dlckhvb2sgKEFMV0FZUyBudW1lcmljYWwpLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gYHNldGAgLSAgUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIG9yICoqU2V0KiogdGhlIHJldmVyc2Ugb3B0aW9uIHZhbHVlLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjcmV2ZXJzZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IHJldmVyc2Ugb3B0aW9uXG5cdFx0ICogdmFyIHJldmVyc2UgPSBzY2VuZS5yZXZlcnNlKCk7XG5cdFx0ICpcblx0XHQgKiAvLyBzZXQgbmV3IHJldmVyc2Ugb3B0aW9uXG5cdFx0ICogc2NlbmUucmV2ZXJzZShmYWxzZSk7XG5cdFx0ICpcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmNoYW5nZX0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtuZXdSZXZlcnNlXSAtIFRoZSBuZXcgcmV2ZXJzZSBzZXR0aW5nIG9mIHRoZSBzY2VuZS5cblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYGdldGAgLSAgQ3VycmVudCByZXZlcnNlIG9wdGlvbiB2YWx1ZS5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IGBzZXRgIC0gIFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiBvciAqKlNldCoqIHRoZSBsb2dsZXZlbCBvcHRpb24gdmFsdWUuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNsb2dsZXZlbFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IGxvZ2xldmVsXG5cdFx0ICogdmFyIGxvZ2xldmVsID0gc2NlbmUubG9nbGV2ZWwoKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNldCBuZXcgbG9nbGV2ZWxcblx0XHQgKiBzY2VuZS5sb2dsZXZlbCgzKTtcblx0XHQgKlxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuY2hhbmdlfSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3TG9nbGV2ZWxdIC0gVGhlIG5ldyBsb2dsZXZlbCBzZXR0aW5nIG9mIHRoZSBzY2VuZS4gYFswLTNdYFxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IGBnZXRgIC0gIEN1cnJlbnQgbG9nbGV2ZWwuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBgc2V0YCAtICBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0KiogdGhlIGFzc29jaWF0ZWQgY29udHJvbGxlci5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI2NvbnRyb2xsZXJcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY29udHJvbGxlciBvZiBhIHNjZW5lXG5cdFx0ICogdmFyIGNvbnRyb2xsZXIgPSBzY2VuZS5jb250cm9sbGVyKCk7XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7U2Nyb2xsTWFnaWMuQ29udHJvbGxlcn0gUGFyZW50IGNvbnRyb2xsZXIgb3IgYHVuZGVmaW5lZGBcblx0XHQgKi9cblx0XHR0aGlzLmNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gX2NvbnRyb2xsZXI7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0KiogdGhlIGN1cnJlbnQgc3RhdGUuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNzdGF0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IHN0YXRlXG5cdFx0ICogdmFyIHN0YXRlID0gc2NlbmUuc3RhdGUoKTtcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IGBcIkJFRk9SRVwiYCwgYFwiRFVSSU5HXCJgIG9yIGBcIkFGVEVSXCJgXG5cdFx0ICovXG5cdFx0dGhpcy5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBfc3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0KiogdGhlIGN1cnJlbnQgc2Nyb2xsIG9mZnNldCBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBzY2VuZS4gIFxuXHRcdCAqIE1pbmQsIHRoYXQgdGhlIHNjcm9sbE9mZnNldCBpcyByZWxhdGVkIHRvIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIsIGlmIGB0cmlnZ2VySG9va2AgaXMgYmlnZ2VyIHRoYW4gYDBgIChvciBgXCJvbkxlYXZlXCJgKS4gIFxuXHRcdCAqIFRoaXMgbWVhbnMsIHRoYXQgcmVzaXppbmcgdGhlIGNvbnRhaW5lciBvciBjaGFuZ2luZyB0aGUgYHRyaWdnZXJIb29rYCB3aWxsIGluZmx1ZW5jZSB0aGUgc2NlbmUncyBzdGFydCBvZmZzZXQuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNzY3JvbGxPZmZzZXRcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCBzY3JvbGwgb2Zmc2V0IGZvciB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc2NlbmUuXG5cdFx0ICogdmFyIHN0YXJ0ID0gc2NlbmUuc2Nyb2xsT2Zmc2V0KCk7XG5cdFx0ICogdmFyIGVuZCA9IHNjZW5lLnNjcm9sbE9mZnNldCgpICsgc2NlbmUuZHVyYXRpb24oKTtcblx0XHQgKiBjb25zb2xlLmxvZyhcInRoZSBzY2VuZSBzdGFydHMgYXRcIiwgc3RhcnQsIFwiYW5kIGVuZHMgYXRcIiwgZW5kKTtcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzY3JvbGwgb2Zmc2V0IChvZiB0aGUgY29udGFpbmVyKSBhdCB3aGljaCB0aGUgc2NlbmUgd2lsbCB0cmlnZ2VyLiBZIHZhbHVlIGZvciB2ZXJ0aWNhbCBhbmQgWCB2YWx1ZSBmb3IgaG9yaXpvbnRhbCBzY3JvbGxzLlxuXHRcdCAqL1xuXHRcdHRoaXMuc2Nyb2xsT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIF9zY3JvbGxPZmZzZXQuc3RhcnQ7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0KiogdGhlIHRyaWdnZXIgcG9zaXRpb24gb2YgdGhlIHNjZW5lIChpbmNsdWRpbmcgdGhlIHZhbHVlIG9mIHRoZSBgb2Zmc2V0YCBvcHRpb24pLiAgXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSN0cmlnZ2VyUG9zaXRpb25cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgc2NlbmUncyB0cmlnZ2VyIHBvc2l0aW9uXG5cdFx0ICogdmFyIHRyaWdnZXJQb3NpdGlvbiA9IHNjZW5lLnRyaWdnZXJQb3NpdGlvbigpO1xuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge251bWJlcn0gU3RhcnQgcG9zaXRpb24gb2YgdGhlIHNjZW5lLiBUb3AgcG9zaXRpb24gdmFsdWUgZm9yIHZlcnRpY2FsIGFuZCBsZWZ0IHBvc2l0aW9uIHZhbHVlIGZvciBob3Jpem9udGFsIHNjcm9sbHMuXG5cdFx0ICovXG5cdFx0dGhpcy50cmlnZ2VyUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcG9zID0gX29wdGlvbnMub2Zmc2V0OyAvLyB0aGUgb2Zmc2V0IGlzIHRoZSBiYXNpc1xuXHRcdFx0aWYgKF9jb250cm9sbGVyKSB7XG5cdFx0XHRcdC8vIGdldCB0aGUgdHJpZ2dlciBwb3NpdGlvblxuXHRcdFx0XHRpZiAoX29wdGlvbnMudHJpZ2dlckVsZW1lbnQpIHtcblx0XHRcdFx0XHQvLyBFbGVtZW50IGFzIHRyaWdnZXJcblx0XHRcdFx0XHRwb3MgKz0gX3RyaWdnZXJQb3M7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHRyaWdnZXJIb29rIHRvIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmdcblx0XHRcdFx0XHRwb3MgKz0gX2NvbnRyb2xsZXIuaW5mbyhcInNpemVcIikgKiBTY2VuZS50cmlnZ2VySG9vaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcG9zO1xuXHRcdH07XG5cblx0XHR2YXJcblx0XHRfcGluLCBfcGluT3B0aW9ucztcblxuXHRcdFNjZW5lLm9uKFwic2hpZnQuaW50ZXJuYWxcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBkdXJhdGlvbkNoYW5nZWQgPSBlLnJlYXNvbiA9PT0gXCJkdXJhdGlvblwiO1xuXHRcdFx0aWYgKChfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0FGVEVSICYmIGR1cmF0aW9uQ2hhbmdlZCkgfHwgKF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfRFVSSU5HICYmIF9vcHRpb25zLmR1cmF0aW9uID09PSAwKSkge1xuXHRcdFx0XHQvLyBpZiBbZHVyYXRpb24gY2hhbmdlZCBhZnRlciBhIHNjZW5lIChpbnNpZGUgc2NlbmUgcHJvZ3Jlc3MgdXBkYXRlcyBwaW4gcG9zaXRpb24pXSBvciBbZHVyYXRpb24gaXMgMCwgd2UgYXJlIGluIHBpbiBwaGFzZSBhbmQgc29tZSBvdGhlciB2YWx1ZSBjaGFuZ2VkXS5cblx0XHRcdFx0dXBkYXRlUGluU3RhdGUoKTtcblx0XHRcdH1cblx0XHRcdGlmIChkdXJhdGlvbkNoYW5nZWQpIHtcblx0XHRcdFx0dXBkYXRlUGluRGltZW5zaW9ucygpO1xuXHRcdFx0fVxuXHRcdH0pLm9uKFwicHJvZ3Jlc3MuaW50ZXJuYWxcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdHVwZGF0ZVBpblN0YXRlKCk7XG5cdFx0fSkub24oXCJhZGQuaW50ZXJuYWxcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdHVwZGF0ZVBpbkRpbWVuc2lvbnMoKTtcblx0XHR9KS5vbihcImRlc3Ryb3kuaW50ZXJuYWxcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFNjZW5lLnJlbW92ZVBpbihlLnJlc2V0KTtcblx0XHR9KTtcblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdGhlIHBpbiBzdGF0ZS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciB1cGRhdGVQaW5TdGF0ZSA9IGZ1bmN0aW9uIChmb3JjZVVucGluKSB7XG5cdFx0XHRpZiAoX3BpbiAmJiBfY29udHJvbGxlcikge1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0Y29udGFpbmVySW5mbyA9IF9jb250cm9sbGVyLmluZm8oKSxcblx0XHRcdFx0XHRwaW5UYXJnZXQgPSBfcGluT3B0aW9ucy5zcGFjZXIuZmlyc3RDaGlsZDsgLy8gbWF5IGJlIHBpbiBlbGVtZW50IG9yIGFub3RoZXIgc3BhY2VyLCBpZiBjYXNjYWRpbmcgcGluc1xuXHRcdFx0XHRpZiAoIWZvcmNlVW5waW4gJiYgX3N0YXRlID09PSBTQ0VORV9TVEFURV9EVVJJTkcpIHsgLy8gZHVyaW5nIHNjZW5lIG9yIGlmIGR1cmF0aW9uIGlzIDAgYW5kIHdlIGFyZSBwYXN0IHRoZSB0cmlnZ2VyXG5cdFx0XHRcdFx0Ly8gcGlubmVkIHN0YXRlXG5cdFx0XHRcdFx0aWYgKF91dGlsLmNzcyhwaW5UYXJnZXQsIFwicG9zaXRpb25cIikgIT0gXCJmaXhlZFwiKSB7XG5cdFx0XHRcdFx0XHQvLyBjaGFuZ2Ugc3RhdGUgYmVmb3JlIHVwZGF0aW5nIHBpbiBzcGFjZXIgKHBvc2l0aW9uIGNoYW5nZXMgZHVlIHRvIGZpeGVkIGNvbGxhcHNpbmcgbWlnaHQgb2NjdXIuKVxuXHRcdFx0XHRcdFx0X3V0aWwuY3NzKHBpblRhcmdldCwge1xuXHRcdFx0XHRcdFx0XHRcInBvc2l0aW9uXCI6IFwiZml4ZWRcIlxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHQvLyB1cGRhdGUgcGluIHNwYWNlclxuXHRcdFx0XHRcdFx0dXBkYXRlUGluRGltZW5zaW9ucygpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdGZpeGVkUG9zID0gX3V0aWwuZ2V0Lm9mZnNldChfcGluT3B0aW9ucy5zcGFjZXIsIHRydWUpLFxuXHRcdFx0XHRcdFx0Ly8gZ2V0IHZpZXdwb3J0IHBvc2l0aW9uIG9mIHNwYWNlclxuXHRcdFx0XHRcdFx0c2Nyb2xsRGlzdGFuY2UgPSBfb3B0aW9ucy5yZXZlcnNlIHx8IF9vcHRpb25zLmR1cmF0aW9uID09PSAwID8gY29udGFpbmVySW5mby5zY3JvbGxQb3MgLSBfc2Nyb2xsT2Zmc2V0LnN0YXJ0IC8vIHF1aWNrZXJcblx0XHRcdFx0XHRcdDogTWF0aC5yb3VuZChfcHJvZ3Jlc3MgKiBfb3B0aW9ucy5kdXJhdGlvbiAqIDEwKSAvIDEwOyAvLyBpZiBubyByZXZlcnNlIGFuZCBkdXJpbmcgcGluIHRoZSBwb3NpdGlvbiBuZWVkcyB0byBiZSByZWNhbGN1bGF0ZWQgdXNpbmcgdGhlIHByb2dyZXNzXG5cdFx0XHRcdFx0Ly8gYWRkIHNjcm9sbERpc3RhbmNlXG5cdFx0XHRcdFx0Zml4ZWRQb3NbY29udGFpbmVySW5mby52ZXJ0aWNhbCA/IFwidG9wXCIgOiBcImxlZnRcIl0gKz0gc2Nyb2xsRGlzdGFuY2U7XG5cblx0XHRcdFx0XHQvLyBzZXQgbmV3IHZhbHVlc1xuXHRcdFx0XHRcdF91dGlsLmNzcyhfcGluT3B0aW9ucy5zcGFjZXIuZmlyc3RDaGlsZCwge1xuXHRcdFx0XHRcdFx0dG9wOiBmaXhlZFBvcy50b3AsXG5cdFx0XHRcdFx0XHRsZWZ0OiBmaXhlZFBvcy5sZWZ0XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5waW5uZWQgc3RhdGVcblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRuZXdDU1MgPSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogX3Bpbk9wdGlvbnMuaW5GbG93ID8gXCJyZWxhdGl2ZVwiIDogXCJhYnNvbHV0ZVwiLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0bGVmdDogMFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRjaGFuZ2UgPSBfdXRpbC5jc3MocGluVGFyZ2V0LCBcInBvc2l0aW9uXCIpICE9IG5ld0NTUy5wb3NpdGlvbjtcblxuXHRcdFx0XHRcdGlmICghX3Bpbk9wdGlvbnMucHVzaEZvbGxvd2Vycykge1xuXHRcdFx0XHRcdFx0bmV3Q1NTW2NvbnRhaW5lckluZm8udmVydGljYWwgPyBcInRvcFwiIDogXCJsZWZ0XCJdID0gX29wdGlvbnMuZHVyYXRpb24gKiBfcHJvZ3Jlc3M7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChfb3B0aW9ucy5kdXJhdGlvbiA+IDApIHsgLy8gb25seSBjb25jZXJucyBzY2VuZXMgd2l0aCBkdXJhdGlvblxuXHRcdFx0XHRcdFx0aWYgKF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfQUZURVIgJiYgcGFyc2VGbG9hdChfdXRpbC5jc3MoX3Bpbk9wdGlvbnMuc3BhY2VyLCBcInBhZGRpbmctdG9wXCIpKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRjaGFuZ2UgPSB0cnVlOyAvLyBpZiBpbiBhZnRlciBzdGF0ZSBidXQgaGF2ZW50IHVwZGF0ZWQgc3BhY2VyIHlldCAoanVtcGVkIHBhc3QgcGluKVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0JFRk9SRSAmJiBwYXJzZUZsb2F0KF91dGlsLmNzcyhfcGluT3B0aW9ucy5zcGFjZXIsIFwicGFkZGluZy1ib3R0b21cIikpID09PSAwKSB7IC8vIGJlZm9yZVxuXHRcdFx0XHRcdFx0XHRjaGFuZ2UgPSB0cnVlOyAvLyBqdW1wZWQgcGFzdCBmaXhlZCBzdGF0ZSB1cHdhcmQgZGlyZWN0aW9uXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHNldCBuZXcgdmFsdWVzXG5cdFx0XHRcdFx0X3V0aWwuY3NzKHBpblRhcmdldCwgbmV3Q1NTKTtcblx0XHRcdFx0XHRpZiAoY2hhbmdlKSB7XG5cdFx0XHRcdFx0XHQvLyB1cGRhdGUgcGluIHNwYWNlciBpZiBzdGF0ZSBjaGFuZ2VkXG5cdFx0XHRcdFx0XHR1cGRhdGVQaW5EaW1lbnNpb25zKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSB0aGUgcGluIHNwYWNlciBhbmQvb3IgZWxlbWVudCBzaXplLlxuXHRcdCAqIFRoZSBzaXplIG9mIHRoZSBzcGFjZXIgbmVlZHMgdG8gYmUgdXBkYXRlZCB3aGVuZXZlciB0aGUgZHVyYXRpb24gb2YgdGhlIHNjZW5lIGNoYW5nZXMsIGlmIGl0IGlzIHRvIHB1c2ggZG93biBmb2xsb3dpbmcgZWxlbWVudHMuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgdXBkYXRlUGluRGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChfcGluICYmIF9jb250cm9sbGVyICYmIF9waW5PcHRpb25zLmluRmxvdykgeyAvLyBubyBzcGFjZXJyZXNpemUsIGlmIG9yaWdpbmFsIHBvc2l0aW9uIGlzIGFic29sdXRlXG5cdFx0XHRcdHZhclxuXHRcdFx0XHRhZnRlciA9IChfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0FGVEVSKSxcblx0XHRcdFx0XHRiZWZvcmUgPSAoX3N0YXRlID09PSBTQ0VORV9TVEFURV9CRUZPUkUpLFxuXHRcdFx0XHRcdGR1cmluZyA9IChfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0RVUklORyksXG5cdFx0XHRcdFx0dmVydGljYWwgPSBfY29udHJvbGxlci5pbmZvKFwidmVydGljYWxcIiksXG5cdFx0XHRcdFx0cGluVGFyZ2V0ID0gX3Bpbk9wdGlvbnMuc3BhY2VyLmZpcnN0Q2hpbGQsXG5cdFx0XHRcdFx0Ly8gdXN1YWxseSB0aGUgcGluZWQgZWxlbWVudCBidXQgY2FuIGFsc28gYmUgYW5vdGhlciBzcGFjZXIgKGNhc2NhZGVkIHBpbnMpXG5cdFx0XHRcdFx0bWFyZ2luQ29sbGFwc2UgPSBfdXRpbC5pc01hcmdpbkNvbGxhcHNlVHlwZShfdXRpbC5jc3MoX3Bpbk9wdGlvbnMuc3BhY2VyLCBcImRpc3BsYXlcIikpLFxuXHRcdFx0XHRcdGNzcyA9IHt9O1xuXG5cdFx0XHRcdC8vIHNldCBuZXcgc2l6ZVxuXHRcdFx0XHQvLyBpZiByZWxzaXplOiBzcGFjZXIgLT4gcGluIHwgZWxzZTogcGluIC0+IHNwYWNlclxuXHRcdFx0XHRpZiAoX3Bpbk9wdGlvbnMucmVsU2l6ZS53aWR0aCB8fCBfcGluT3B0aW9ucy5yZWxTaXplLmF1dG9GdWxsV2lkdGgpIHtcblx0XHRcdFx0XHRpZiAoZHVyaW5nKSB7XG5cdFx0XHRcdFx0XHRfdXRpbC5jc3MoX3Bpbiwge1xuXHRcdFx0XHRcdFx0XHRcIndpZHRoXCI6IF91dGlsLmdldC53aWR0aChfcGluT3B0aW9ucy5zcGFjZXIpXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0X3V0aWwuY3NzKF9waW4sIHtcblx0XHRcdFx0XHRcdFx0XCJ3aWR0aFwiOiBcIjEwMCVcIlxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG1pbndpZHRoIGlzIG5lZWRlZCBmb3IgY2FzY2FkZWQgcGlucy5cblx0XHRcdFx0XHRjc3NbXCJtaW4td2lkdGhcIl0gPSBfdXRpbC5nZXQud2lkdGgodmVydGljYWwgPyBfcGluIDogcGluVGFyZ2V0LCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0XHRjc3Mud2lkdGggPSBkdXJpbmcgPyBjc3NbXCJtaW4td2lkdGhcIl0gOiBcImF1dG9cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX3Bpbk9wdGlvbnMucmVsU2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0XHRpZiAoZHVyaW5nKSB7XG5cdFx0XHRcdFx0XHQvLyB0aGUgb25seSBwYWRkaW5nIHRoZSBzcGFjZXIgc2hvdWxkIGV2ZXIgaW5jbHVkZSBpcyB0aGUgZHVyYXRpb24gKGlmIHB1c2hGb2xsb3dlcnMgPSB0cnVlKSwgc28gd2UgbmVlZCB0byBzdWJzdHJhY3QgdGhhdC5cblx0XHRcdFx0XHRcdF91dGlsLmNzcyhfcGluLCB7XG5cdFx0XHRcdFx0XHRcdFwiaGVpZ2h0XCI6IF91dGlsLmdldC5oZWlnaHQoX3Bpbk9wdGlvbnMuc3BhY2VyKSAtIChfcGluT3B0aW9ucy5wdXNoRm9sbG93ZXJzID8gX29wdGlvbnMuZHVyYXRpb24gOiAwKVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdF91dGlsLmNzcyhfcGluLCB7XG5cdFx0XHRcdFx0XHRcdFwiaGVpZ2h0XCI6IFwiMTAwJVwiXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbWFyZ2luIGlzIG9ubHkgaW5jbHVkZWQgaWYgaXQncyBhIGNhc2NhZGVkIHBpbiB0byByZXNvbHZlIGFuIElFOSBidWdcblx0XHRcdFx0XHRjc3NbXCJtaW4taGVpZ2h0XCJdID0gX3V0aWwuZ2V0LmhlaWdodCh2ZXJ0aWNhbCA/IHBpblRhcmdldCA6IF9waW4sIHRydWUsICFtYXJnaW5Db2xsYXBzZSk7IC8vIG5lZWRlZCBmb3IgY2FzY2FkaW5nIHBpbnNcblx0XHRcdFx0XHRjc3MuaGVpZ2h0ID0gZHVyaW5nID8gY3NzW1wibWluLWhlaWdodFwiXSA6IFwiYXV0b1wiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYWRkIHNwYWNlIGZvciBkdXJhdGlvbiBpZiBwdXNoRm9sbG93ZXJzIGlzIHRydWVcblx0XHRcdFx0aWYgKF9waW5PcHRpb25zLnB1c2hGb2xsb3dlcnMpIHtcblx0XHRcdFx0XHRjc3NbXCJwYWRkaW5nXCIgKyAodmVydGljYWwgPyBcIlRvcFwiIDogXCJMZWZ0XCIpXSA9IF9vcHRpb25zLmR1cmF0aW9uICogX3Byb2dyZXNzO1xuXHRcdFx0XHRcdGNzc1tcInBhZGRpbmdcIiArICh2ZXJ0aWNhbCA/IFwiQm90dG9tXCIgOiBcIlJpZ2h0XCIpXSA9IF9vcHRpb25zLmR1cmF0aW9uICogKDEgLSBfcHJvZ3Jlc3MpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF91dGlsLmNzcyhfcGluT3B0aW9ucy5zcGFjZXIsIGNzcyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIFBpbiBzdGF0ZSAoaW4gY2VydGFpbiBzY2VuYXJpb3MpXG5cdFx0ICogSWYgdGhlIGNvbnRyb2xsZXIgY29udGFpbmVyIGlzIG5vdCB0aGUgZG9jdW1lbnQgYW5kIHdlIGFyZSBtaWQtcGluLXBoYXNlIHNjcm9sbGluZyBvciByZXNpemluZyB0aGUgbWFpbiBkb2N1bWVudCBjYW4gcmVzdWx0IHRvIHdyb25nIHBpbiBwb3NpdGlvbnMuXG5cdFx0ICogU28gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gcmVzaXplIGFuZCBzY3JvbGwgb2YgdGhlIGRvY3VtZW50LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHVwZGF0ZVBpbkluQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKF9jb250cm9sbGVyICYmIF9waW4gJiYgX3N0YXRlID09PSBTQ0VORV9TVEFURV9EVVJJTkcgJiYgIV9jb250cm9sbGVyLmluZm8oXCJpc0RvY3VtZW50XCIpKSB7XG5cdFx0XHRcdHVwZGF0ZVBpblN0YXRlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIFBpbiBzcGFjZXIgc2l6ZSBzdGF0ZSAoaW4gY2VydGFpbiBzY2VuYXJpb3MpXG5cdFx0ICogSWYgY29udGFpbmVyIGlzIHJlc2l6ZWQgZHVyaW5nIHBpbiBhbmQgcmVsYXRpdmVseSBzaXplZCB0aGUgc2l6ZSBvZiB0aGUgcGluIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZC4uLlxuXHRcdCAqIFNvIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIHJlc2l6ZSBvZiB0aGUgY29udGFpbmVyLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHVwZGF0ZVJlbGF0aXZlUGluU3BhY2VyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKF9jb250cm9sbGVyICYmIF9waW4gJiYgLy8gd2VsbCwgZHVoXG5cdFx0XHRfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0RVUklORyAmJiAvLyBlbGVtZW50IGluIHBpbm5lZCBzdGF0ZT9cblx0XHRcdCggLy8gaXMgd2lkdGggb3IgaGVpZ2h0IHJlbGF0aXZlbHkgc2l6ZWQsIGJ1dCBub3QgaW4gcmVsYXRpb24gdG8gYm9keT8gdGhlbiB3ZSBuZWVkIHRvIHJlY2FsYy5cblx0XHRcdCgoX3Bpbk9wdGlvbnMucmVsU2l6ZS53aWR0aCB8fCBfcGluT3B0aW9ucy5yZWxTaXplLmF1dG9GdWxsV2lkdGgpICYmIF91dGlsLmdldC53aWR0aCh3aW5kb3cpICE9IF91dGlsLmdldC53aWR0aChfcGluT3B0aW9ucy5zcGFjZXIucGFyZW50Tm9kZSkpIHx8IChfcGluT3B0aW9ucy5yZWxTaXplLmhlaWdodCAmJiBfdXRpbC5nZXQuaGVpZ2h0KHdpbmRvdykgIT0gX3V0aWwuZ2V0LmhlaWdodChfcGluT3B0aW9ucy5zcGFjZXIucGFyZW50Tm9kZSkpKSkge1xuXHRcdFx0XHR1cGRhdGVQaW5EaW1lbnNpb25zKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIElzIGNhbGxlZCwgd2hlbiB0aGUgbW91c2V3aGVsIGlzIHVzZWQgd2hpbGUgb3ZlciBhIHBpbm5lZCBlbGVtZW50IGluc2lkZSBhIGRpdiBjb250YWluZXIuXG5cdFx0ICogSWYgdGhlIHNjZW5lIGlzIGluIGZpeGVkIHN0YXRlIHNjcm9sbCBldmVudHMgd291bGQgYmUgY291bnRlZCB0b3dhcmRzIHRoZSBib2R5LiBUaGlzIGZvcndhcmRzIHRoZSBldmVudCB0byB0aGUgc2Nyb2xsIGNvbnRhaW5lci5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciBvbk1vdXNld2hlZWxPdmVyUGluID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChfY29udHJvbGxlciAmJiBfcGluICYmIF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfRFVSSU5HICYmICFfY29udHJvbGxlci5pbmZvKFwiaXNEb2N1bWVudFwiKSkgeyAvLyBpbiBwaW4gc3RhdGVcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRfY29udHJvbGxlci5fc2V0U2Nyb2xsUG9zKF9jb250cm9sbGVyLmluZm8oXCJzY3JvbGxQb3NcIikgLSAoKGUud2hlZWxEZWx0YSB8fCBlW19jb250cm9sbGVyLmluZm8oXCJ2ZXJ0aWNhbFwiKSA/IFwid2hlZWxEZWx0YVlcIiA6IFwid2hlZWxEZWx0YVhcIl0pIC8gMyB8fCAtZS5kZXRhaWwgKiAzMCkpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBQaW4gYW4gZWxlbWVudCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSB0d2Vlbi4gIFxuXHRcdCAqIElmIHRoZSBzY2VuZSBkdXJhdGlvbiBpcyAwIHRoZSBlbGVtZW50IHdpbGwgb25seSBiZSB1bnBpbm5lZCwgaWYgdGhlIHVzZXIgc2Nyb2xscyBiYWNrIHBhc3QgdGhlIHN0YXJ0IHBvc2l0aW9uLiAgXG5cdFx0ICogTWFrZSBzdXJlIG9ubHkgb25lIHBpbiBpcyBhcHBsaWVkIHRvIGFuIGVsZW1lbnQgYXQgdGhlIHNhbWUgdGltZS5cblx0XHQgKiBBbiBlbGVtZW50IGNhbiBiZSBwaW5uZWQgbXVsdGlwbGUgdGltZXMsIGJ1dCBvbmx5IHN1Y2Nlc3NpdmVseS5cblx0XHQgKiBfKipOT1RFOioqIFRoZSBvcHRpb24gYHB1c2hGb2xsb3dlcnNgIGhhcyBubyBlZmZlY3QsIHdoZW4gdGhlIHNjZW5lIGR1cmF0aW9uIGlzIDAuX1xuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjc2V0UGluXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBwaW4gZWxlbWVudCBhbmQgcHVzaCBhbGwgZm9sbG93aW5nIGVsZW1lbnRzIGRvd24gYnkgdGhlIGFtb3VudCBvZiB0aGUgcGluIGR1cmF0aW9uLlxuXHRcdCAqIHNjZW5lLnNldFBpbihcIiNwaW5cIik7XG5cdFx0ICpcblx0XHQgKiAvLyBwaW4gZWxlbWVudCBhbmQga2VlcGluZyBhbGwgZm9sbG93aW5nIGVsZW1lbnRzIGluIHRoZWlyIHBsYWNlLiBUaGUgcGlubmVkIGVsZW1lbnQgd2lsbCBtb3ZlIHBhc3QgdGhlbS5cblx0XHQgKiBzY2VuZS5zZXRQaW4oXCIjcGluXCIsIHtwdXNoRm9sbG93ZXJzOiBmYWxzZX0pO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IGVsZW1lbnQgLSBBIFNlbGVjdG9yIHRhcmdldGluZyBhbiBlbGVtZW50IG9yIGEgRE9NIG9iamVjdCB0aGF0IGlzIHN1cHBvc2VkIHRvIGJlIHBpbm5lZC5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gW3NldHRpbmdzXSAtIHNldHRpbmdzIGZvciB0aGUgcGluXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbc2V0dGluZ3MucHVzaEZvbGxvd2Vycz10cnVlXSAtIElmIGB0cnVlYCBmb2xsb3dpbmcgZWxlbWVudHMgd2lsbCBiZSBcInB1c2hlZFwiIGRvd24gZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgcGluLCBpZiBgZmFsc2VgIHRoZSBwaW5uZWQgZWxlbWVudCB3aWxsIGp1c3Qgc2Nyb2xsIHBhc3QgdGhlbS4gIFxuXHRcdCBJZ25vcmVkLCB3aGVuIGR1cmF0aW9uIGlzIGAwYC5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW3NldHRpbmdzLnNwYWNlckNsYXNzPVwic2Nyb2xsbWFnaWMtcGluLXNwYWNlclwiXSAtIENsYXNzbmFtZSBvZiB0aGUgcGluIHNwYWNlciBlbGVtZW50LCB3aGljaCBpcyB1c2VkIHRvIHJlcGxhY2UgdGhlIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMuc2V0UGluID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNldHRpbmdzKSB7XG5cdFx0XHR2YXJcblx0XHRcdGRlZmF1bHRTZXR0aW5ncyA9IHtcblx0XHRcdFx0cHVzaEZvbGxvd2VyczogdHJ1ZSxcblx0XHRcdFx0c3BhY2VyQ2xhc3M6IFwic2Nyb2xsbWFnaWMtcGluLXNwYWNlclwiXG5cdFx0XHR9O1xuXHRcdFx0c2V0dGluZ3MgPSBfdXRpbC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgc2V0dGluZ3MpO1xuXG5cdFx0XHQvLyB2YWxpZGF0ZSBFbGVtZW50XG5cdFx0XHRlbGVtZW50ID0gX3V0aWwuZ2V0LmVsZW1lbnRzKGVsZW1lbnQpWzBdO1xuXHRcdFx0aWYgKCFlbGVtZW50KSB7XG5cdFx0XHRcdGxvZygxLCBcIkVSUk9SIGNhbGxpbmcgbWV0aG9kICdzZXRQaW4oKSc6IEludmFsaWQgcGluIGVsZW1lbnQgc3VwcGxpZWQuXCIpO1xuXHRcdFx0XHRyZXR1cm4gU2NlbmU7IC8vIGNhbmNlbFxuXHRcdFx0fSBlbHNlIGlmIChfdXRpbC5jc3MoZWxlbWVudCwgXCJwb3NpdGlvblwiKSA9PT0gXCJmaXhlZFwiKSB7XG5cdFx0XHRcdGxvZygxLCBcIkVSUk9SIGNhbGxpbmcgbWV0aG9kICdzZXRQaW4oKSc6IFBpbiBkb2VzIG5vdCB3b3JrIHdpdGggZWxlbWVudHMgdGhhdCBhcmUgcG9zaXRpb25lZCAnZml4ZWQnLlwiKTtcblx0XHRcdFx0cmV0dXJuIFNjZW5lOyAvLyBjYW5jZWxcblx0XHRcdH1cblxuXHRcdFx0aWYgKF9waW4pIHsgLy8gcHJlZXhpc3RpbmcgcGluP1xuXHRcdFx0XHRpZiAoX3BpbiA9PT0gZWxlbWVudCkge1xuXHRcdFx0XHRcdC8vIHNhbWUgcGluIHdlIGFscmVhZHkgaGF2ZSAtPiBkbyBub3RoaW5nXG5cdFx0XHRcdFx0cmV0dXJuIFNjZW5lOyAvLyBjYW5jZWxcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBraWxsIG9sZCBwaW5cblx0XHRcdFx0XHRTY2VuZS5yZW1vdmVQaW4oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHRfcGluID0gZWxlbWVudDtcblxuXHRcdFx0dmFyXG5cdFx0XHRwYXJlbnREaXNwbGF5ID0gX3Bpbi5wYXJlbnROb2RlLnN0eWxlLmRpc3BsYXksXG5cdFx0XHRcdGJvdW5kc1BhcmFtcyA9IFtcInRvcFwiLCBcImxlZnRcIiwgXCJib3R0b21cIiwgXCJyaWdodFwiLCBcIm1hcmdpblwiLCBcIm1hcmdpbkxlZnRcIiwgXCJtYXJnaW5SaWdodFwiLCBcIm1hcmdpblRvcFwiLCBcIm1hcmdpbkJvdHRvbVwiXTtcblxuXHRcdFx0X3Bpbi5wYXJlbnROb2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIGhhY2sgc3RhcnQgdG8gZm9yY2UgY3NzIHRvIHJldHVybiBzdHlsZXNoZWV0IHZhbHVlcyBpbnN0ZWFkIG9mIGNhbGN1bGF0ZWQgcHggdmFsdWVzLlxuXHRcdFx0dmFyXG5cdFx0XHRpbkZsb3cgPSBfdXRpbC5jc3MoX3BpbiwgXCJwb3NpdGlvblwiKSAhPSBcImFic29sdXRlXCIsXG5cdFx0XHRcdHBpbkNTUyA9IF91dGlsLmNzcyhfcGluLCBib3VuZHNQYXJhbXMuY29uY2F0KFtcImRpc3BsYXlcIl0pKSxcblx0XHRcdFx0c2l6ZUNTUyA9IF91dGlsLmNzcyhfcGluLCBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXSk7XG5cdFx0XHRfcGluLnBhcmVudE5vZGUuc3R5bGUuZGlzcGxheSA9IHBhcmVudERpc3BsYXk7IC8vIGhhY2sgZW5kLlxuXHRcdFx0aWYgKCFpbkZsb3cgJiYgc2V0dGluZ3MucHVzaEZvbGxvd2Vycykge1xuXHRcdFx0XHRsb2coMiwgXCJXQVJOSU5HOiBJZiB0aGUgcGlubmVkIGVsZW1lbnQgaXMgcG9zaXRpb25lZCBhYnNvbHV0ZWx5IHB1c2hGb2xsb3dlcnMgd2lsbCBiZSBkaXNhYmxlZC5cIik7XG5cdFx0XHRcdHNldHRpbmdzLnB1c2hGb2xsb3dlcnMgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgLy8gd2FpdCB1bnRpbCBhbGwgZmluaXNoZWQsIGJlY2F1c2Ugd2l0aCByZXNwb25zaXZlIGR1cmF0aW9uIGl0IHdpbGwgb25seSBiZSBzZXQgYWZ0ZXIgc2NlbmUgaXMgYWRkZWQgdG8gY29udHJvbGxlclxuXHRcdFx0XHRpZiAoX3BpbiAmJiBfb3B0aW9ucy5kdXJhdGlvbiA9PT0gMCAmJiBzZXR0aW5ncy5wdXNoRm9sbG93ZXJzKSB7XG5cdFx0XHRcdFx0bG9nKDIsIFwiV0FSTklORzogcHVzaEZvbGxvd2VycyA9XCIsIHRydWUsIFwiaGFzIG5vIGVmZmVjdCwgd2hlbiBzY2VuZSBkdXJhdGlvbiBpcyAwLlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMCk7XG5cblx0XHRcdC8vIGNyZWF0ZSBzcGFjZXIgYW5kIGluc2VydFxuXHRcdFx0dmFyXG5cdFx0XHRzcGFjZXIgPSBfcGluLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBfcGluKSxcblx0XHRcdFx0c3BhY2VyQ1NTID0gX3V0aWwuZXh0ZW5kKHBpbkNTUywge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBpbkZsb3cgPyBcInJlbGF0aXZlXCIgOiBcImFic29sdXRlXCIsXG5cdFx0XHRcdFx0Ym94U2l6aW5nOiBcImNvbnRlbnQtYm94XCIsXG5cdFx0XHRcdFx0bW96Qm94U2l6aW5nOiBcImNvbnRlbnQtYm94XCIsXG5cdFx0XHRcdFx0d2Via2l0Qm94U2l6aW5nOiBcImNvbnRlbnQtYm94XCJcblx0XHRcdFx0fSk7XG5cblx0XHRcdGlmICghaW5GbG93KSB7IC8vIGNvcHkgc2l6ZSBpZiBwb3NpdGlvbmVkIGFic29sdXRlbHksIHRvIHdvcmsgZm9yIGJvdHRvbS9yaWdodCBwb3NpdGlvbmVkIGVsZW1lbnRzLlxuXHRcdFx0XHRfdXRpbC5leHRlbmQoc3BhY2VyQ1NTLCBfdXRpbC5jc3MoX3BpbiwgW1wid2lkdGhcIiwgXCJoZWlnaHRcIl0pKTtcblx0XHRcdH1cblxuXHRcdFx0X3V0aWwuY3NzKHNwYWNlciwgc3BhY2VyQ1NTKTtcblx0XHRcdHNwYWNlci5zZXRBdHRyaWJ1dGUoUElOX1NQQUNFUl9BVFRSSUJVVEUsIFwiXCIpO1xuXHRcdFx0X3V0aWwuYWRkQ2xhc3Moc3BhY2VyLCBzZXR0aW5ncy5zcGFjZXJDbGFzcyk7XG5cblx0XHRcdC8vIHNldCB0aGUgcGluIE9wdGlvbnNcblx0XHRcdF9waW5PcHRpb25zID0ge1xuXHRcdFx0XHRzcGFjZXI6IHNwYWNlcixcblx0XHRcdFx0cmVsU2l6ZTogeyAvLyBzYXZlIGlmIHNpemUgaXMgZGVmaW5lZCB1c2luZyAlIHZhbHVlcy4gaWYgc28sIGhhbmRsZSBzcGFjZXIgcmVzaXplIGRpZmZlcmVudGx5Li4uXG5cdFx0XHRcdFx0d2lkdGg6IHNpemVDU1Mud2lkdGguc2xpY2UoLTEpID09PSBcIiVcIixcblx0XHRcdFx0XHRoZWlnaHQ6IHNpemVDU1MuaGVpZ2h0LnNsaWNlKC0xKSA9PT0gXCIlXCIsXG5cdFx0XHRcdFx0YXV0b0Z1bGxXaWR0aDogc2l6ZUNTUy53aWR0aCA9PT0gXCJhdXRvXCIgJiYgaW5GbG93ICYmIF91dGlsLmlzTWFyZ2luQ29sbGFwc2VUeXBlKHBpbkNTUy5kaXNwbGF5KVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRwdXNoRm9sbG93ZXJzOiBzZXR0aW5ncy5wdXNoRm9sbG93ZXJzLFxuXHRcdFx0XHRpbkZsb3c6IGluRmxvdyxcblx0XHRcdFx0Ly8gc3RvcmVzIGlmIHRoZSBlbGVtZW50IHRha2VzIHVwIHNwYWNlIGluIHRoZSBkb2N1bWVudCBmbG93XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIV9waW4uX19fb3JpZ1N0eWxlKSB7XG5cdFx0XHRcdF9waW4uX19fb3JpZ1N0eWxlID0ge307XG5cdFx0XHRcdHZhclxuXHRcdFx0XHRwaW5JbmxpbmVDU1MgPSBfcGluLnN0eWxlLFxuXHRcdFx0XHRcdGNvcHlTdHlsZXMgPSBib3VuZHNQYXJhbXMuY29uY2F0KFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwicG9zaXRpb25cIiwgXCJib3hTaXppbmdcIiwgXCJtb3pCb3hTaXppbmdcIiwgXCJ3ZWJraXRCb3hTaXppbmdcIl0pO1xuXHRcdFx0XHRjb3B5U3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHRcdF9waW4uX19fb3JpZ1N0eWxlW3ZhbF0gPSBwaW5JbmxpbmVDU1NbdmFsXSB8fCBcIlwiO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgcmVsYXRpdmUgc2l6ZSwgdHJhbnNmZXIgaXQgdG8gc3BhY2VyIGFuZCBtYWtlIHBpbiBjYWxjdWxhdGUgaXQuLi5cblx0XHRcdGlmIChfcGluT3B0aW9ucy5yZWxTaXplLndpZHRoKSB7XG5cdFx0XHRcdF91dGlsLmNzcyhzcGFjZXIsIHtcblx0XHRcdFx0XHR3aWR0aDogc2l6ZUNTUy53aWR0aFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGlmIChfcGluT3B0aW9ucy5yZWxTaXplLmhlaWdodCkge1xuXHRcdFx0XHRfdXRpbC5jc3Moc3BhY2VyLCB7XG5cdFx0XHRcdFx0aGVpZ2h0OiBzaXplQ1NTLmhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbm93IHBsYWNlIHRoZSBwaW4gZWxlbWVudCBpbnNpZGUgdGhlIHNwYWNlclx0XG5cdFx0XHRzcGFjZXIuYXBwZW5kQ2hpbGQoX3Bpbik7XG5cdFx0XHQvLyBhbmQgc2V0IG5ldyBjc3Ncblx0XHRcdF91dGlsLmNzcyhfcGluLCB7XG5cdFx0XHRcdHBvc2l0aW9uOiBpbkZsb3cgPyBcInJlbGF0aXZlXCIgOiBcImFic29sdXRlXCIsXG5cdFx0XHRcdG1hcmdpbjogXCJhdXRvXCIsXG5cdFx0XHRcdHRvcDogXCJhdXRvXCIsXG5cdFx0XHRcdGxlZnQ6IFwiYXV0b1wiLFxuXHRcdFx0XHRib3R0b206IFwiYXV0b1wiLFxuXHRcdFx0XHRyaWdodDogXCJhdXRvXCJcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoX3Bpbk9wdGlvbnMucmVsU2l6ZS53aWR0aCB8fCBfcGluT3B0aW9ucy5yZWxTaXplLmF1dG9GdWxsV2lkdGgpIHtcblx0XHRcdFx0X3V0aWwuY3NzKF9waW4sIHtcblx0XHRcdFx0XHRib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdG1vekJveFNpemluZzogXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0d2Via2l0Qm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGxpc3RlbmVyIHRvIGRvY3VtZW50IHRvIHVwZGF0ZSBwaW4gcG9zaXRpb24gaW4gY2FzZSBjb250cm9sbGVyIGlzIG5vdCB0aGUgZG9jdW1lbnQuXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlUGluSW5Db250YWluZXIpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZVBpbkluQ29udGFpbmVyKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVSZWxhdGl2ZVBpblNwYWNlcik7XG5cdFx0XHQvLyBhZGQgbW91c2V3aGVlbCBsaXN0ZW5lciB0byBjYXRjaCBzY3JvbGxzIG92ZXIgZml4ZWQgZWxlbWVudHNcblx0XHRcdF9waW4uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNld2hlZWxcIiwgb25Nb3VzZXdoZWVsT3ZlclBpbik7XG5cdFx0XHRfcGluLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Nb3VzZVNjcm9sbFwiLCBvbk1vdXNld2hlZWxPdmVyUGluKTtcblxuXHRcdFx0bG9nKDMsIFwiYWRkZWQgcGluXCIpO1xuXG5cdFx0XHQvLyBmaW5hbGx5IHVwZGF0ZSB0aGUgcGluIHRvIGluaXRcblx0XHRcdHVwZGF0ZVBpblN0YXRlKCk7XG5cblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIHRoZSBwaW4gZnJvbSB0aGUgc2NlbmUuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNyZW1vdmVQaW5cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHJlbW92ZSB0aGUgcGluIGZyb20gdGhlIHNjZW5lIHdpdGhvdXQgcmVzZXR0aW5nIGl0ICh0aGUgc3BhY2VyIGlzIG5vdCByZW1vdmVkKVxuXHRcdCAqIHNjZW5lLnJlbW92ZVBpbigpO1xuXHRcdCAqXG5cdFx0ICogLy8gcmVtb3ZlIHRoZSBwaW4gZnJvbSB0aGUgc2NlbmUgYW5kIHJlc2V0IHRoZSBwaW4gZWxlbWVudCB0byBpdHMgaW5pdGlhbCBwb3NpdGlvbiAoc3BhY2VyIGlzIHJlbW92ZWQpXG5cdFx0ICogc2NlbmUucmVtb3ZlUGluKHRydWUpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbcmVzZXQ9ZmFsc2VdIC0gSWYgYGZhbHNlYCB0aGUgc3BhY2VyIHdpbGwgbm90IGJlIHJlbW92ZWQgYW5kIHRoZSBlbGVtZW50J3MgcG9zaXRpb24gd2lsbCBub3QgYmUgcmVzZXQuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnJlbW92ZVBpbiA9IGZ1bmN0aW9uIChyZXNldCkge1xuXHRcdFx0aWYgKF9waW4pIHtcblx0XHRcdFx0aWYgKF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfRFVSSU5HKSB7XG5cdFx0XHRcdFx0dXBkYXRlUGluU3RhdGUodHJ1ZSk7IC8vIGZvcmNlIHVucGluIGF0IHBvc2l0aW9uXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc2V0IHx8ICFfY29udHJvbGxlcikgeyAvLyBpZiB0aGVyZSdzIG5vIGNvbnRyb2xsZXIgbm8gcHJvZ3Jlc3Mgd2FzIG1hZGUgYW55d2F5Li4uXG5cdFx0XHRcdFx0dmFyIHBpblRhcmdldCA9IF9waW5PcHRpb25zLnNwYWNlci5maXJzdENoaWxkOyAvLyB1c3VhbGx5IHRoZSBwaW4gZWxlbWVudCwgYnV0IG1heSBiZSBhbm90aGVyIHNwYWNlciAoY2FzY2FkZWQgcGlucykuLi5cblx0XHRcdFx0XHRpZiAocGluVGFyZ2V0Lmhhc0F0dHJpYnV0ZShQSU5fU1BBQ0VSX0FUVFJJQlVURSkpIHsgLy8gY29weSBtYXJnaW5zIHRvIGNoaWxkIHNwYWNlclxuXHRcdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHRzdHlsZSA9IF9waW5PcHRpb25zLnNwYWNlci5zdHlsZSxcblx0XHRcdFx0XHRcdFx0dmFsdWVzID0gW1wibWFyZ2luXCIsIFwibWFyZ2luTGVmdFwiLCBcIm1hcmdpblJpZ2h0XCIsIFwibWFyZ2luVG9wXCIsIFwibWFyZ2luQm90dG9tXCJdO1xuXHRcdFx0XHRcdFx0bWFyZ2lucyA9IHt9O1xuXHRcdFx0XHRcdFx0dmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHRcdFx0XHRtYXJnaW5zW3ZhbF0gPSBzdHlsZVt2YWxdIHx8IFwiXCI7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdF91dGlsLmNzcyhwaW5UYXJnZXQsIG1hcmdpbnMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfcGluT3B0aW9ucy5zcGFjZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocGluVGFyZ2V0LCBfcGluT3B0aW9ucy5zcGFjZXIpO1xuXHRcdFx0XHRcdF9waW5PcHRpb25zLnNwYWNlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9waW5PcHRpb25zLnNwYWNlcik7XG5cdFx0XHRcdFx0aWYgKCFfcGluLnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKFBJTl9TUEFDRVJfQVRUUklCVVRFKSkgeyAvLyBpZiBpdCdzIHRoZSBsYXN0IHBpbiBmb3IgdGhpcyBlbGVtZW50IC0+IHJlc3RvcmUgaW5saW5lIHN0eWxlc1xuXHRcdFx0XHRcdFx0Ly8gVE9ETzogb25seSBjb3JyZWN0bHkgc2V0IGZvciBmaXJzdCBwaW4gKHdoZW4gY2FzY2FkaW5nKSAtIGhvdyB0byBmaXg/XG5cdFx0XHRcdFx0XHRfdXRpbC5jc3MoX3BpbiwgX3Bpbi5fX19vcmlnU3R5bGUpO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIF9waW4uX19fb3JpZ1N0eWxlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlUGluSW5Db250YWluZXIpO1xuXHRcdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlUGluSW5Db250YWluZXIpO1xuXHRcdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlUmVsYXRpdmVQaW5TcGFjZXIpO1xuXHRcdFx0XHRfcGluLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXdoZWVsXCIsIG9uTW91c2V3aGVlbE92ZXJQaW4pO1xuXHRcdFx0XHRfcGluLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Nb3VzZVNjcm9sbFwiLCBvbk1vdXNld2hlZWxPdmVyUGluKTtcblx0XHRcdFx0X3BpbiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0bG9nKDMsIFwicmVtb3ZlZCBwaW4gKHJlc2V0OiBcIiArIChyZXNldCA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKSArIFwiKVwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cblx0XHR2YXJcblx0XHRfY3NzQ2xhc3NlcywgX2Nzc0NsYXNzRWxlbXMgPSBbXTtcblxuXHRcdFNjZW5lLm9uKFwiZGVzdHJveS5pbnRlcm5hbFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0U2NlbmUucmVtb3ZlQ2xhc3NUb2dnbGUoZS5yZXNldCk7XG5cdFx0fSk7XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lIGEgY3NzIGNsYXNzIG1vZGlmaWNhdGlvbiB3aGlsZSB0aGUgc2NlbmUgaXMgYWN0aXZlLiAgXG5cdFx0ICogV2hlbiB0aGUgc2NlbmUgdHJpZ2dlcnMgdGhlIGNsYXNzZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgc3VwcGxpZWQgZWxlbWVudCBhbmQgcmVtb3ZlZCwgd2hlbiB0aGUgc2NlbmUgaXMgb3Zlci5cblx0XHQgKiBJZiB0aGUgc2NlbmUgZHVyYXRpb24gaXMgMCB0aGUgY2xhc3NlcyB3aWxsIG9ubHkgYmUgcmVtb3ZlZCBpZiB0aGUgdXNlciBzY3JvbGxzIGJhY2sgcGFzdCB0aGUgc3RhcnQgcG9zaXRpb24uXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNzZXRDbGFzc1RvZ2dsZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gYWRkIHRoZSBjbGFzcyAnbXljbGFzcycgdG8gdGhlIGVsZW1lbnQgd2l0aCB0aGUgaWQgJ215LWVsZW0nIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHNjZW5lXG5cdFx0ICogc2NlbmUuc2V0Q2xhc3NUb2dnbGUoXCIjbXktZWxlbVwiLCBcIm15Y2xhc3NcIik7XG5cdFx0ICpcblx0XHQgKiAvLyBhZGQgbXVsdGlwbGUgY2xhc3NlcyB0byBtdWx0aXBsZSBlbGVtZW50cyBkZWZpbmVkIGJ5IHRoZSBzZWxlY3RvciAnLmNsYXNzQ2hhbmdlJ1xuXHRcdCAqIHNjZW5lLnNldENsYXNzVG9nZ2xlKFwiLmNsYXNzQ2hhbmdlXCIsIFwiY2xhc3MxIGNsYXNzMiBjbGFzczNcIik7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gZWxlbWVudCAtIEEgU2VsZWN0b3IgdGFyZ2V0aW5nIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9yIGEgRE9NIG9iamVjdCB0aGF0IGlzIHN1cHBvc2VkIHRvIGJlIG1vZGlmaWVkLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc2VzIC0gT25lIG9yIG1vcmUgQ2xhc3NuYW1lcyAoc2VwYXJhdGVkIGJ5IHNwYWNlKSB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgZWxlbWVudCBkdXJpbmcgdGhlIHNjZW5lLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnNldENsYXNzVG9nZ2xlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzZXMpIHtcblx0XHRcdHZhciBlbGVtcyA9IF91dGlsLmdldC5lbGVtZW50cyhlbGVtZW50KTtcblx0XHRcdGlmIChlbGVtcy5sZW5ndGggPT09IDAgfHwgIV91dGlsLnR5cGUuU3RyaW5nKGNsYXNzZXMpKSB7XG5cdFx0XHRcdGxvZygxLCBcIkVSUk9SIGNhbGxpbmcgbWV0aG9kICdzZXRDbGFzc1RvZ2dsZSgpJzogSW52YWxpZCBcIiArIChlbGVtcy5sZW5ndGggPT09IDAgPyBcImVsZW1lbnRcIiA6IFwiY2xhc3Nlc1wiKSArIFwiIHN1cHBsaWVkLlwiKTtcblx0XHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9jc3NDbGFzc0VsZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gcmVtb3ZlIG9sZCBvbmVzXG5cdFx0XHRcdFNjZW5lLnJlbW92ZUNsYXNzVG9nZ2xlKCk7XG5cdFx0XHR9XG5cdFx0XHRfY3NzQ2xhc3NlcyA9IGNsYXNzZXM7XG5cdFx0XHRfY3NzQ2xhc3NFbGVtcyA9IGVsZW1zO1xuXHRcdFx0U2NlbmUub24oXCJlbnRlci5pbnRlcm5hbF9jbGFzcyBsZWF2ZS5pbnRlcm5hbF9jbGFzc1wiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR2YXIgdG9nZ2xlID0gZS50eXBlID09PSBcImVudGVyXCIgPyBfdXRpbC5hZGRDbGFzcyA6IF91dGlsLnJlbW92ZUNsYXNzO1xuXHRcdFx0XHRfY3NzQ2xhc3NFbGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtLCBrZXkpIHtcblx0XHRcdFx0XHR0b2dnbGUoZWxlbSwgX2Nzc0NsYXNzZXMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgdGhlIGNsYXNzIGJpbmRpbmcgZnJvbSB0aGUgc2NlbmUuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNyZW1vdmVDbGFzc1RvZ2dsZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gcmVtb3ZlIGNsYXNzIGJpbmRpbmcgZnJvbSB0aGUgc2NlbmUgd2l0aG91dCByZXNldFxuXHRcdCAqIHNjZW5lLnJlbW92ZUNsYXNzVG9nZ2xlKCk7XG5cdFx0ICpcblx0XHQgKiAvLyByZW1vdmUgY2xhc3MgYmluZGluZyBhbmQgcmVtb3ZlIHRoZSBjaGFuZ2VzIGl0IGNhdXNlZFxuXHRcdCAqIHNjZW5lLnJlbW92ZUNsYXNzVG9nZ2xlKHRydWUpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbcmVzZXQ9ZmFsc2VdIC0gSWYgYGZhbHNlYCBhbmQgdGhlIGNsYXNzZXMgYXJlIGN1cnJlbnRseSBhY3RpdmUsIHRoZXkgd2lsbCByZW1haW4gb24gdGhlIGVsZW1lbnQuIElmIGB0cnVlYCB0aGV5IHdpbGwgYmUgcmVtb3ZlZC5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMucmVtb3ZlQ2xhc3NUb2dnbGUgPSBmdW5jdGlvbiAocmVzZXQpIHtcblx0XHRcdGlmIChyZXNldCkge1xuXHRcdFx0XHRfY3NzQ2xhc3NFbGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtLCBrZXkpIHtcblx0XHRcdFx0XHRfdXRpbC5yZW1vdmVDbGFzcyhlbGVtLCBfY3NzQ2xhc3Nlcyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0U2NlbmUub2ZmKFwic3RhcnQuaW50ZXJuYWxfY2xhc3MgZW5kLmludGVybmFsX2NsYXNzXCIpO1xuXHRcdFx0X2Nzc0NsYXNzZXMgPSB1bmRlZmluZWQ7XG5cdFx0XHRfY3NzQ2xhc3NFbGVtcyA9IFtdO1xuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvLyBJTklUXG5cdFx0Y29uc3RydWN0KCk7XG5cdFx0cmV0dXJuIFNjZW5lO1xuXHR9O1xuXG5cdC8vIHN0b3JlIHBhZ2V3aWRlIHNjZW5lIG9wdGlvbnNcblx0dmFyIFNDRU5FX09QVElPTlMgPSB7XG5cdFx0ZGVmYXVsdHM6IHtcblx0XHRcdGR1cmF0aW9uOiAwLFxuXHRcdFx0b2Zmc2V0OiAwLFxuXHRcdFx0dHJpZ2dlckVsZW1lbnQ6IHVuZGVmaW5lZCxcblx0XHRcdHRyaWdnZXJIb29rOiAwLjUsXG5cdFx0XHRyZXZlcnNlOiB0cnVlLFxuXHRcdFx0bG9nbGV2ZWw6IDJcblx0XHR9LFxuXHRcdHZhbGlkYXRlOiB7XG5cdFx0XHRvZmZzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0dmFsID0gcGFyc2VGbG9hdCh2YWwpO1xuXHRcdFx0XHRpZiAoIV91dGlsLnR5cGUuTnVtYmVyKHZhbCkpIHtcblx0XHRcdFx0XHR0aHJvdyBbXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIm9mZnNldFxcXCI6XCIsIHZhbF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH0sXG5cdFx0XHR0cmlnZ2VyRWxlbWVudDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHR2YWwgPSB2YWwgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAodmFsKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSBfdXRpbC5nZXQuZWxlbWVudHModmFsKVswXTtcblx0XHRcdFx0XHRpZiAoZWxlbSkge1xuXHRcdFx0XHRcdFx0dmFsID0gZWxlbTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgW1wiRWxlbWVudCBkZWZpbmVkIGluIG9wdGlvbiBcXFwidHJpZ2dlckVsZW1lbnRcXFwiIHdhcyBub3QgZm91bmQ6XCIsIHZhbF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlckhvb2s6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0dmFyIHRyYW5zbGF0ZSA9IHtcblx0XHRcdFx0XHRcIm9uQ2VudGVyXCI6IDAuNSxcblx0XHRcdFx0XHRcIm9uRW50ZXJcIjogMSxcblx0XHRcdFx0XHRcIm9uTGVhdmVcIjogMFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoX3V0aWwudHlwZS5OdW1iZXIodmFsKSkge1xuXHRcdFx0XHRcdHZhbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhcnNlRmxvYXQodmFsKSwgMSkpOyAvLyAgbWFrZSBzdXJlIGl0cyBiZXR3ZWVlbiAwIGFuZCAxXG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsIGluIHRyYW5zbGF0ZSkge1xuXHRcdFx0XHRcdHZhbCA9IHRyYW5zbGF0ZVt2YWxdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFtcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwidHJpZ2dlckhvb2tcXFwiOiBcIiwgdmFsXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fSxcblx0XHRcdHJldmVyc2U6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0cmV0dXJuICEhdmFsOyAvLyBmb3JjZSBib29sZWFuXG5cdFx0XHR9LFxuXHRcdFx0bG9nbGV2ZWw6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0dmFsID0gcGFyc2VJbnQodmFsKTtcblx0XHRcdFx0aWYgKCFfdXRpbC50eXBlLk51bWJlcih2YWwpIHx8IHZhbCA8IDAgfHwgdmFsID4gMykge1xuXHRcdFx0XHRcdHRocm93IFtcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwibG9nbGV2ZWxcXFwiOlwiLCB2YWxdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBob2xkZXIgZm9yICB2YWxpZGF0aW9uIG1ldGhvZHMuIGR1cmF0aW9uIHZhbGlkYXRpb24gaXMgaGFuZGxlZCBpbiAnZ2V0dGVycy1zZXR0ZXJzLmpzJ1xuXHRcdHNoaWZ0czogW1wiZHVyYXRpb25cIiwgXCJvZmZzZXRcIiwgXCJ0cmlnZ2VySG9va1wiXSxcblx0XHQvLyBsaXN0IG9mIG9wdGlvbnMgdGhhdCB0cmlnZ2VyIGEgYHNoaWZ0YCBldmVudFxuXHR9O1xuLypcbiAqIG1ldGhvZCB1c2VkIHRvIGFkZCBhbiBvcHRpb24gdG8gU2Nyb2xsTWFnaWMgU2NlbmVzLlxuICogVE9ETzogRE9DIChwcml2YXRlIGZvciBkZXYpXG4gKi9cblx0U2Nyb2xsTWFnaWMuU2NlbmUuYWRkT3B0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGRlZmF1bHRWYWx1ZSwgdmFsaWRhdGlvbkNhbGxiYWNrLCBzaGlmdHMpIHtcblx0XHRpZiAoIShuYW1lIGluIFNDRU5FX09QVElPTlMuZGVmYXVsdHMpKSB7XG5cdFx0XHRTQ0VORV9PUFRJT05TLmRlZmF1bHRzW25hbWVdID0gZGVmYXVsdFZhbHVlO1xuXHRcdFx0U0NFTkVfT1BUSU9OUy52YWxpZGF0ZVtuYW1lXSA9IHZhbGlkYXRpb25DYWxsYmFjaztcblx0XHRcdGlmIChzaGlmdHMpIHtcblx0XHRcdFx0U0NFTkVfT1BUSU9OUy5zaGlmdHMucHVzaChuYW1lKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0U2Nyb2xsTWFnaWMuX3V0aWwubG9nKDEsIFwiW3N0YXRpY10gU2Nyb2xsTWFnaWMuU2NlbmUgLT4gQ2Fubm90IGFkZCBTY2VuZSBvcHRpb24gJ1wiICsgbmFtZSArIFwiJywgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cy5cIik7XG5cdFx0fVxuXHR9O1xuXHQvLyBpbnN0YW5jZSBleHRlbnNpb24gZnVuY3Rpb24gZm9yIHBsdWdpbnNcblx0Ly8gVE9ETzogRE9DIChwcml2YXRlIGZvciBkZXYpXG5cdFNjcm9sbE1hZ2ljLlNjZW5lLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcblx0XHR2YXIgb2xkQ2xhc3MgPSB0aGlzO1xuXHRcdFNjcm9sbE1hZ2ljLlNjZW5lID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0b2xkQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuJHN1cGVyID0gX3V0aWwuZXh0ZW5kKHt9LCB0aGlzKTsgLy8gY29weSBwYXJlbnQgc3RhdGVcblx0XHRcdHJldHVybiBleHRlbnNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHRcdH07XG5cdFx0X3V0aWwuZXh0ZW5kKFNjcm9sbE1hZ2ljLlNjZW5lLCBvbGRDbGFzcyk7IC8vIGNvcHkgcHJvcGVydGllc1xuXHRcdFNjcm9sbE1hZ2ljLlNjZW5lLnByb3RvdHlwZSA9IG9sZENsYXNzLnByb3RvdHlwZTsgLy8gY29weSBwcm90b3R5cGVcblx0XHRTY3JvbGxNYWdpYy5TY2VuZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY3JvbGxNYWdpYy5TY2VuZTsgLy8gcmVzdG9yZSBjb25zdHJ1Y3RvclxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFRPRE86IERPQ1MgKHByaXZhdGUgZm9yIGRldilcblx0ICogQGNsYXNzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXG5cdFNjcm9sbE1hZ2ljLkV2ZW50ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWVzcGFjZSwgdGFyZ2V0LCB2YXJzKSB7XG5cdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0Zm9yICh2YXIga2V5IGluIHZhcnMpIHtcblx0XHRcdHRoaXNba2V5XSA9IHZhcnNba2V5XTtcblx0XHR9XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLnRhcmdldCA9IHRoaXMuY3VycmVudFRhcmdldCA9IHRhcmdldDtcblx0XHR0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZSB8fCAnJztcblx0XHR0aGlzLnRpbWVTdGFtcCA9IHRoaXMudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuLypcbiAqIFRPRE86IERPQ1MgKHByaXZhdGUgZm9yIGRldilcbiAqL1xuXG5cdHZhciBfdXRpbCA9IFNjcm9sbE1hZ2ljLl91dGlsID0gKGZ1bmN0aW9uICh3aW5kb3cpIHtcblx0XHR2YXIgVSA9IHt9LFxuXHRcdFx0aTtcblxuXHRcdC8qKlxuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqIGludGVybmFsIGhlbHBlcnNcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKi9cblxuXHRcdC8vIHBhcnNlIGZsb2F0IGFuZCBmYWxsIGJhY2sgdG8gMC5cblx0XHR2YXIgZmxvYXR2YWwgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VGbG9hdChudW1iZXIpIHx8IDA7XG5cdFx0fTtcblx0XHQvLyBnZXQgY3VycmVudCBzdHlsZSBJRSBzYWZlIChvdGhlcndpc2UgSUUgd291bGQgcmV0dXJuIGNhbGN1bGF0ZWQgdmFsdWVzIGZvciAnYXV0bycpXG5cdFx0dmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gKGVsZW0pIHtcblx0XHRcdHJldHVybiBlbGVtLmN1cnJlbnRTdHlsZSA/IGVsZW0uY3VycmVudFN0eWxlIDogd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG5cdFx0fTtcblxuXHRcdC8vIGdldCBlbGVtZW50IGRpbWVuc2lvbiAod2lkdGggb3IgaGVpZ2h0KVxuXHRcdHZhciBfZGltZW5zaW9uID0gZnVuY3Rpb24gKHdoaWNoLCBlbGVtLCBvdXRlciwgaW5jbHVkZU1hcmdpbikge1xuXHRcdFx0ZWxlbSA9IChlbGVtID09PSBkb2N1bWVudCkgPyB3aW5kb3cgOiBlbGVtO1xuXHRcdFx0aWYgKGVsZW0gPT09IHdpbmRvdykge1xuXHRcdFx0XHRpbmNsdWRlTWFyZ2luID0gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCFfdHlwZS5Eb21FbGVtZW50KGVsZW0pKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0d2hpY2ggPSB3aGljaC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdoaWNoLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0dmFyIGRpbWVuc2lvbiA9IChvdXRlciA/IGVsZW1bJ29mZnNldCcgKyB3aGljaF0gfHwgZWxlbVsnb3V0ZXInICsgd2hpY2hdIDogZWxlbVsnY2xpZW50JyArIHdoaWNoXSB8fCBlbGVtWydpbm5lcicgKyB3aGljaF0pIHx8IDA7XG5cdFx0XHRpZiAob3V0ZXIgJiYgaW5jbHVkZU1hcmdpbikge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcblx0XHRcdFx0ZGltZW5zaW9uICs9IHdoaWNoID09PSAnSGVpZ2h0JyA/IGZsb2F0dmFsKHN0eWxlLm1hcmdpblRvcCkgKyBmbG9hdHZhbChzdHlsZS5tYXJnaW5Cb3R0b20pIDogZmxvYXR2YWwoc3R5bGUubWFyZ2luTGVmdCkgKyBmbG9hdHZhbChzdHlsZS5tYXJnaW5SaWdodCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGltZW5zaW9uO1xuXHRcdH07XG5cdFx0Ly8gY29udmVydHMgJ21hcmdpbi10b3AnIGludG8gJ21hcmdpblRvcCdcblx0XHR2YXIgX2NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvXlteYS16XSsoW2Etel0pL2csICckMScpLnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uIChnKSB7XG5cdFx0XHRcdHJldHVybiBnWzFdLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICogZXh0ZXJuYWwgaGVscGVyc1xuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqL1xuXG5cdFx0Ly8gZXh0ZW5kIG9iaiDigJMgc2FtZSBhcyBqUXVlcnkuZXh0ZW5kKHt9LCBvYmpBLCBvYmpCKVxuXHRcdFUuZXh0ZW5kID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gb2JqIHx8IHt9O1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoIWFyZ3VtZW50c1tpXSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbaV0pIHtcblx0XHRcdFx0XHRpZiAoYXJndW1lbnRzW2ldLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdG9ialtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cblx0XHQvLyBjaGVjayBpZiBhIGNzcyBkaXNwbGF5IHR5cGUgcmVzdWx0cyBpbiBtYXJnaW4tY29sbGFwc2Ugb3Igbm90XG5cdFx0VS5pc01hcmdpbkNvbGxhcHNlVHlwZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRcdHJldHVybiBbXCJibG9ja1wiLCBcImZsZXhcIiwgXCJsaXN0LWl0ZW1cIiwgXCJ0YWJsZVwiLCBcIi13ZWJraXQtYm94XCJdLmluZGV4T2Yoc3RyKSA+IC0xO1xuXHRcdH07XG5cblx0XHQvLyBpbXBsZW1lbnRhdGlvbiBvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblx0XHQvLyBiYXNlZCBvbiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MVxuXHRcdHZhclxuXHRcdGxhc3RUaW1lID0gMCxcblx0XHRcdHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuXHRcdHZhciBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHR2YXIgX2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXHRcdC8vIHRyeSB2ZW5kb3IgcHJlZml4ZXMgaWYgdGhlIGFib3ZlIGRvZXNuJ3Qgd29ya1xuXHRcdGZvciAoaSA9IDA7ICFfcmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIGkgPCB2ZW5kb3JzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbaV0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG5cdFx0XHRfY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1tpXSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8IHdpbmRvd1t2ZW5kb3JzW2ldICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuXHRcdH1cblxuXHRcdC8vIGZhbGxiYWNrc1xuXHRcdGlmICghX3JlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdFx0X3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0Y3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcblx0XHRcdFx0XHR0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpLFxuXHRcdFx0XHRcdGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcblx0XHRcdFx0XHR9LCB0aW1lVG9DYWxsKTtcblx0XHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG5cdFx0XHRcdHJldHVybiBpZDtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGlmICghX2NhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHRfY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dChpZCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRVLnJBRiA9IF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpO1xuXHRcdFUuY0FGID0gX2NhbmNlbEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KTtcblxuXHRcdHZhclxuXHRcdGxvZ2xldmVscyA9IFtcImVycm9yXCIsIFwid2FyblwiLCBcImxvZ1wiXSxcblx0XHRcdGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZSB8fCB7fTtcblxuXHRcdGNvbnNvbGUubG9nID0gY29uc29sZS5sb2cgfHxcblx0XHRmdW5jdGlvbiAoKSB7fTsgLy8gbm8gY29uc29sZSBsb2csIHdlbGwgLSBkbyBub3RoaW5nIHRoZW4uLi5cblx0XHQvLyBtYWtlIHN1cmUgbWV0aG9kcyBmb3IgYWxsIGxldmVscyBleGlzdC5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbG9nbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbWV0aG9kID0gbG9nbGV2ZWxzW2ldO1xuXHRcdFx0aWYgKCFjb25zb2xlW21ldGhvZF0pIHtcblx0XHRcdFx0Y29uc29sZVttZXRob2RdID0gY29uc29sZS5sb2c7IC8vIHByZWZlciAubG9nIG92ZXIgbm90aGluZ1xuXHRcdFx0fVxuXHRcdH1cblx0XHRVLmxvZyA9IGZ1bmN0aW9uIChsb2dsZXZlbCkge1xuXHRcdFx0aWYgKGxvZ2xldmVsID4gbG9nbGV2ZWxzLmxlbmd0aCB8fCBsb2dsZXZlbCA8PSAwKSBsb2dsZXZlbCA9IGxvZ2xldmVscy5sZW5ndGg7XG5cdFx0XHR2YXIgbm93ID0gbmV3IERhdGUoKSxcblx0XHRcdFx0dGltZSA9IChcIjBcIiArIG5vdy5nZXRIb3VycygpKS5zbGljZSgtMikgKyBcIjpcIiArIChcIjBcIiArIG5vdy5nZXRNaW51dGVzKCkpLnNsaWNlKC0yKSArIFwiOlwiICsgKFwiMFwiICsgbm93LmdldFNlY29uZHMoKSkuc2xpY2UoLTIpICsgXCI6XCIgKyAoXCIwMFwiICsgbm93LmdldE1pbGxpc2Vjb25kcygpKS5zbGljZSgtMyksXG5cdFx0XHRcdG1ldGhvZCA9IGxvZ2xldmVsc1tsb2dsZXZlbCAtIDFdLFxuXHRcdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG5cdFx0XHRcdGZ1bmMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGVbbWV0aG9kXSwgY29uc29sZSk7XG5cdFx0XHRhcmdzLnVuc2hpZnQodGltZSk7XG5cdFx0XHRmdW5jLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKiB0eXBlIHRlc3Rpbmdcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKi9cblxuXHRcdHZhciBfdHlwZSA9IFUudHlwZSA9IGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpLnJlcGxhY2UoL15cXFtvYmplY3QgKC4rKVxcXSQvLCBcIiQxXCIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0fTtcblx0XHRfdHlwZS5TdHJpbmcgPSBmdW5jdGlvbiAodikge1xuXHRcdFx0cmV0dXJuIF90eXBlKHYpID09PSAnc3RyaW5nJztcblx0XHR9O1xuXHRcdF90eXBlLkZ1bmN0aW9uID0gZnVuY3Rpb24gKHYpIHtcblx0XHRcdHJldHVybiBfdHlwZSh2KSA9PT0gJ2Z1bmN0aW9uJztcblx0XHR9O1xuXHRcdF90eXBlLkFycmF5ID0gZnVuY3Rpb24gKHYpIHtcblx0XHRcdHJldHVybiBBcnJheS5pc0FycmF5KHYpO1xuXHRcdH07XG5cdFx0X3R5cGUuTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcblx0XHRcdHJldHVybiAhX3R5cGUuQXJyYXkodikgJiYgKHYgLSBwYXJzZUZsb2F0KHYpICsgMSkgPj0gMDtcblx0XHR9O1xuXHRcdF90eXBlLkRvbUVsZW1lbnQgPSBmdW5jdGlvbiAobykge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJvYmplY3RcIiA/IG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IC8vRE9NMlxuXHRcdFx0byAmJiB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiBvICE9PSBudWxsICYmIG8ubm9kZVR5cGUgPT09IDEgJiYgdHlwZW9mIG8ubm9kZU5hbWUgPT09IFwic3RyaW5nXCIpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKiBET00gRWxlbWVudCBpbmZvXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICovXG5cdFx0Ly8gYWx3YXlzIHJldHVybnMgYSBsaXN0IG9mIG1hdGNoaW5nIERPTSBlbGVtZW50cywgZnJvbSBhIHNlbGVjdG9yLCBhIERPTSBlbGVtZW50IG9yIGFuIGxpc3Qgb2YgZWxlbWVudHMgb3IgZXZlbiBhbiBhcnJheSBvZiBzZWxlY3RvcnNcblx0XHR2YXIgX2dldCA9IFUuZ2V0ID0ge307XG5cdFx0X2dldC5lbGVtZW50cyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuXHRcdFx0dmFyIGFyciA9IFtdO1xuXHRcdFx0aWYgKF90eXBlLlN0cmluZyhzZWxlY3RvcikpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRzZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7IC8vIGludmFsaWQgc2VsZWN0b3Jcblx0XHRcdFx0XHRyZXR1cm4gYXJyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoX3R5cGUoc2VsZWN0b3IpID09PSAnbm9kZWxpc3QnIHx8IF90eXBlLkFycmF5KHNlbGVjdG9yKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgcmVmID0gYXJyLmxlbmd0aCA9IHNlbGVjdG9yLmxlbmd0aDsgaSA8IHJlZjsgaSsrKSB7IC8vIGxpc3Qgb2YgZWxlbWVudHNcblx0XHRcdFx0XHR2YXIgZWxlbSA9IHNlbGVjdG9yW2ldO1xuXHRcdFx0XHRcdGFycltpXSA9IF90eXBlLkRvbUVsZW1lbnQoZWxlbSkgPyBlbGVtIDogX2dldC5lbGVtZW50cyhlbGVtKTsgLy8gaWYgbm90IGFuIGVsZW1lbnQsIHRyeSB0byByZXNvbHZlIHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoX3R5cGUuRG9tRWxlbWVudChzZWxlY3RvcikgfHwgc2VsZWN0b3IgPT09IGRvY3VtZW50IHx8IHNlbGVjdG9yID09PSB3aW5kb3cpIHtcblx0XHRcdFx0YXJyID0gW3NlbGVjdG9yXTsgLy8gb25seSB0aGUgZWxlbWVudFxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFycjtcblx0XHR9O1xuXHRcdC8vIGdldCBzY3JvbGwgdG9wIHZhbHVlXG5cdFx0X2dldC5zY3JvbGxUb3AgPSBmdW5jdGlvbiAoZWxlbSkge1xuXHRcdFx0cmV0dXJuIChlbGVtICYmIHR5cGVvZiBlbGVtLnNjcm9sbFRvcCA9PT0gJ251bWJlcicpID8gZWxlbS5zY3JvbGxUb3AgOiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgMDtcblx0XHR9O1xuXHRcdC8vIGdldCBzY3JvbGwgbGVmdCB2YWx1ZVxuXHRcdF9nZXQuc2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIChlbGVtKSB7XG5cdFx0XHRyZXR1cm4gKGVsZW0gJiYgdHlwZW9mIGVsZW0uc2Nyb2xsTGVmdCA9PT0gJ251bWJlcicpID8gZWxlbS5zY3JvbGxMZWZ0IDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IDA7XG5cdFx0fTtcblx0XHQvLyBnZXQgZWxlbWVudCBoZWlnaHRcblx0XHRfZ2V0LndpZHRoID0gZnVuY3Rpb24gKGVsZW0sIG91dGVyLCBpbmNsdWRlTWFyZ2luKSB7XG5cdFx0XHRyZXR1cm4gX2RpbWVuc2lvbignd2lkdGgnLCBlbGVtLCBvdXRlciwgaW5jbHVkZU1hcmdpbik7XG5cdFx0fTtcblx0XHQvLyBnZXQgZWxlbWVudCB3aWR0aFxuXHRcdF9nZXQuaGVpZ2h0ID0gZnVuY3Rpb24gKGVsZW0sIG91dGVyLCBpbmNsdWRlTWFyZ2luKSB7XG5cdFx0XHRyZXR1cm4gX2RpbWVuc2lvbignaGVpZ2h0JywgZWxlbSwgb3V0ZXIsIGluY2x1ZGVNYXJnaW4pO1xuXHRcdH07XG5cblx0XHQvLyBnZXQgZWxlbWVudCBwb3NpdGlvbiAob3B0aW9uYWxseSByZWxhdGl2ZSB0byB2aWV3cG9ydClcblx0XHRfZ2V0Lm9mZnNldCA9IGZ1bmN0aW9uIChlbGVtLCByZWxhdGl2ZVRvVmlld3BvcnQpIHtcblx0XHRcdHZhciBvZmZzZXQgPSB7XG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0bGVmdDogMFxuXHRcdFx0fTtcblx0XHRcdGlmIChlbGVtICYmIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7IC8vIGNoZWNrIGlmIGF2YWlsYWJsZVxuXHRcdFx0XHR2YXIgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRcdG9mZnNldC50b3AgPSByZWN0LnRvcDtcblx0XHRcdFx0b2Zmc2V0LmxlZnQgPSByZWN0LmxlZnQ7XG5cdFx0XHRcdGlmICghcmVsYXRpdmVUb1ZpZXdwb3J0KSB7IC8vIGNsaWVudFJlY3QgaXMgYnkgZGVmYXVsdCByZWxhdGl2ZSB0byB2aWV3cG9ydC4uLlxuXHRcdFx0XHRcdG9mZnNldC50b3AgKz0gX2dldC5zY3JvbGxUb3AoKTtcblx0XHRcdFx0XHRvZmZzZXQubGVmdCArPSBfZ2V0LnNjcm9sbExlZnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICogRE9NIEVsZW1lbnQgbWFuaXB1bGF0aW9uXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICovXG5cblx0XHRVLmFkZENsYXNzID0gZnVuY3Rpb24gKGVsZW0sIGNsYXNzbmFtZSkge1xuXHRcdFx0aWYgKGNsYXNzbmFtZSkge1xuXHRcdFx0XHRpZiAoZWxlbS5jbGFzc0xpc3QpIGVsZW0uY2xhc3NMaXN0LmFkZChjbGFzc25hbWUpO1xuXHRcdFx0XHRlbHNlIGVsZW0uY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzbmFtZTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbSwgY2xhc3NuYW1lKSB7XG5cdFx0XHRpZiAoY2xhc3NuYW1lKSB7XG5cdFx0XHRcdGlmIChlbGVtLmNsYXNzTGlzdCkgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzbmFtZSk7XG5cdFx0XHRcdGVsc2UgZWxlbS5jbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoJyhefFxcXFxiKScgKyBjbGFzc25hbWUuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKFxcXFxifCQpJywgJ2dpJyksICcgJyk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvLyBpZiBvcHRpb25zIGlzIHN0cmluZyAtPiByZXR1cm5zIGNzcyB2YWx1ZVxuXHRcdC8vIGlmIG9wdGlvbnMgaXMgYXJyYXkgLT4gcmV0dXJucyBvYmplY3Qgd2l0aCBjc3MgdmFsdWUgcGFpcnNcblx0XHQvLyBpZiBvcHRpb25zIGlzIG9iamVjdCAtPiBzZXQgbmV3IGNzcyB2YWx1ZXNcblx0XHRVLmNzcyA9IGZ1bmN0aW9uIChlbGVtLCBvcHRpb25zKSB7XG5cdFx0XHRpZiAoX3R5cGUuU3RyaW5nKG9wdGlvbnMpKSB7XG5cdFx0XHRcdHJldHVybiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKVtfY2FtZWxDYXNlKG9wdGlvbnMpXTtcblx0XHRcdH0gZWxzZSBpZiAoX3R5cGUuQXJyYXkob3B0aW9ucykpIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdG9iaiA9IHt9LFxuXHRcdFx0XHRcdHN0eWxlID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbSk7XG5cdFx0XHRcdG9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uLCBrZXkpIHtcblx0XHRcdFx0XHRvYmpbb3B0aW9uXSA9IHN0eWxlW19jYW1lbENhc2Uob3B0aW9uKV07XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gb3B0aW9uc1tvcHRpb25dO1xuXHRcdFx0XHRcdGlmICh2YWwgPT0gcGFyc2VGbG9hdCh2YWwpKSB7IC8vIGFzc3VtZSBwaXhlbCBmb3Igc2VlbWluZ2x5IG51bWVyaWNhbCB2YWx1ZXNcblx0XHRcdFx0XHRcdHZhbCArPSAncHgnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtLnN0eWxlW19jYW1lbENhc2Uob3B0aW9uKV0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmV0dXJuIFU7XG5cdH0od2luZG93IHx8IHt9KSk7XG5cblx0U2Nyb2xsTWFnaWMuU2NlbmUucHJvdG90eXBlLmFkZEluZGljYXRvcnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0U2Nyb2xsTWFnaWMuX3V0aWwubG9nKDEsICcoU2Nyb2xsTWFnaWMuU2NlbmUpIC0+IEVSUk9SIGNhbGxpbmcgYWRkSW5kaWNhdG9ycygpIGR1ZSB0byBtaXNzaW5nIFBsdWdpbiBcXCdkZWJ1Zy5hZGRJbmRpY2F0b3JzXFwnLiBQbGVhc2UgbWFrZSBzdXJlIHRvIGluY2x1ZGUgcGx1Z2lucy9kZWJ1Zy5hZGRJbmRpY2F0b3JzLmpzJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0U2Nyb2xsTWFnaWMuU2NlbmUucHJvdG90eXBlLnJlbW92ZUluZGljYXRvcnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0U2Nyb2xsTWFnaWMuX3V0aWwubG9nKDEsICcoU2Nyb2xsTWFnaWMuU2NlbmUpIC0+IEVSUk9SIGNhbGxpbmcgcmVtb3ZlSW5kaWNhdG9ycygpIGR1ZSB0byBtaXNzaW5nIFBsdWdpbiBcXCdkZWJ1Zy5hZGRJbmRpY2F0b3JzXFwnLiBQbGVhc2UgbWFrZSBzdXJlIHRvIGluY2x1ZGUgcGx1Z2lucy9kZWJ1Zy5hZGRJbmRpY2F0b3JzLmpzJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0U2Nyb2xsTWFnaWMuU2NlbmUucHJvdG90eXBlLnNldFR3ZWVuID0gZnVuY3Rpb24gKCkge1xuXHRcdFNjcm9sbE1hZ2ljLl91dGlsLmxvZygxLCAnKFNjcm9sbE1hZ2ljLlNjZW5lKSAtPiBFUlJPUiBjYWxsaW5nIHNldFR3ZWVuKCkgZHVlIHRvIG1pc3NpbmcgUGx1Z2luIFxcJ2FuaW1hdGlvbi5nc2FwXFwnLiBQbGVhc2UgbWFrZSBzdXJlIHRvIGluY2x1ZGUgcGx1Z2lucy9hbmltYXRpb24uZ3NhcC5qcycpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdFNjcm9sbE1hZ2ljLlNjZW5lLnByb3RvdHlwZS5yZW1vdmVUd2VlbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRTY3JvbGxNYWdpYy5fdXRpbC5sb2coMSwgJyhTY3JvbGxNYWdpYy5TY2VuZSkgLT4gRVJST1IgY2FsbGluZyByZW1vdmVUd2VlbigpIGR1ZSB0byBtaXNzaW5nIFBsdWdpbiBcXCdhbmltYXRpb24uZ3NhcFxcJy4gUGxlYXNlIG1ha2Ugc3VyZSB0byBpbmNsdWRlIHBsdWdpbnMvYW5pbWF0aW9uLmdzYXAuanMnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRTY3JvbGxNYWdpYy5TY2VuZS5wcm90b3R5cGUuc2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0U2Nyb2xsTWFnaWMuX3V0aWwubG9nKDEsICcoU2Nyb2xsTWFnaWMuU2NlbmUpIC0+IEVSUk9SIGNhbGxpbmcgc2V0VmVsb2NpdHkoKSBkdWUgdG8gbWlzc2luZyBQbHVnaW4gXFwnYW5pbWF0aW9uLnZlbG9jaXR5XFwnLiBQbGVhc2UgbWFrZSBzdXJlIHRvIGluY2x1ZGUgcGx1Z2lucy9hbmltYXRpb24udmVsb2NpdHkuanMnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRTY3JvbGxNYWdpYy5TY2VuZS5wcm90b3R5cGUucmVtb3ZlVmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0U2Nyb2xsTWFnaWMuX3V0aWwubG9nKDEsICcoU2Nyb2xsTWFnaWMuU2NlbmUpIC0+IEVSUk9SIGNhbGxpbmcgcmVtb3ZlVmVsb2NpdHkoKSBkdWUgdG8gbWlzc2luZyBQbHVnaW4gXFwnYW5pbWF0aW9uLnZlbG9jaXR5XFwnLiBQbGVhc2UgbWFrZSBzdXJlIHRvIGluY2x1ZGUgcGx1Z2lucy9hbmltYXRpb24udmVsb2NpdHkuanMnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHJldHVybiBTY3JvbGxNYWdpYztcbn0pKTsiLCIvKiFcbiAqIFNjcm9sbE1hZ2ljIHYyLjAuNSAoMjAxNS0wNC0yOSlcbiAqIFRoZSBqYXZhc2NyaXB0IGxpYnJhcnkgZm9yIG1hZ2ljYWwgc2Nyb2xsIGludGVyYWN0aW9ucy5cbiAqIChjKSAyMDE1IEphbiBQYWVwa2UgKEBqYW5wYWVwa2UpXG4gKiBQcm9qZWN0IFdlYnNpdGU6IGh0dHA6Ly9zY3JvbGxtYWdpYy5pb1xuICogXG4gKiBAdmVyc2lvbiAyLjAuNVxuICogQGxpY2Vuc2UgRHVhbCBsaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZSBhbmQgR1BMLlxuICogQGF1dGhvciBKYW4gUGFlcGtlIC0gZS1tYWlsQGphbnBhZXBrZS5kZVxuICpcbiAqIEBmaWxlIFNjcm9sbE1hZ2ljIEdTQVAgQW5pbWF0aW9uIFBsdWdpbi5cbiAqXG4gKiByZXF1aXJlczogR1NBUCB+MS4xNFxuICogUG93ZXJlZCBieSB0aGUgR3JlZW5zb2NrIEFuaW1hdGlvbiBQbGF0Zm9ybSAoR1NBUCk6IGh0dHA6Ly93d3cuZ3JlZW5zb2NrLmNvbS9qc1xuICogR3JlZW5zb2NrIExpY2Vuc2UgaW5mbyBhdCBodHRwOi8vd3d3LmdyZWVuc29jay5jb20vbGljZW5zaW5nL1xuICovXG4vKipcbiAqIFRoaXMgcGx1Z2luIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgR3JlZW5zb2NrIEFuaW1hdGlvbiBQbGF0dGZvcm0uICBcbiAqIEl0IG9mZmVycyBhbiBlYXN5IEFQSSB0byB0cmlnZ2VyIFR3ZWVucyBvciBzeW5jaHJvbml6ZSB0aGVtIHRvIHRoZSBzY3JvbGxiYXIgbW92ZW1lbnQuXG4gKlxuICogQm90aCB0aGUgYGxpdGVgIGFuZCB0aGUgYG1heGAgdmVyc2lvbnMgb2YgdGhlIEdTQVAgbGlicmFyeSBhcmUgc3VwcG9ydGVkLiAgXG4gKiBUaGUgbW9zdCBiYXNpYyByZXF1aXJlbWVudCBpcyBgVHdlZW5MaXRlYC5cbiAqIFxuICogVG8gaGF2ZSBhY2Nlc3MgdG8gdGhpcyBleHRlbnNpb24sIHBsZWFzZSBpbmNsdWRlIGBwbHVnaW5zL2FuaW1hdGlvbi5nc2FwLmpzYC5cbiAqIEByZXF1aXJlcyB7QGxpbmsgaHR0cDovL2dyZWVuc29jay5jb20vZ3NhcHxHU0FQIH4xLjE0Lnh9XG4gKiBAbWl4aW4gYW5pbWF0aW9uLkdTQVBcbiAqL1xuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKFsnU2Nyb2xsTWFnaWMnLCAnVHdlZW5NYXgnLCAnVGltZWxpbmVNYXgnXSwgZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHQvLyBMb2FkcyB3aG9sZSBnc2FwIHBhY2thZ2Ugb250byBnbG9iYWwgc2NvcGUuXG5cdFx0cmVxdWlyZSgnZ3NhcCcpO1xuXHRcdGZhY3RvcnkocmVxdWlyZSgnc2Nyb2xsbWFnaWMnKSwgVHdlZW5NYXgsIFRpbWVsaW5lTWF4KTtcblx0fSBlbHNlIHtcblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KHJvb3QuU2Nyb2xsTWFnaWMgfHwgKHJvb3QualF1ZXJ5ICYmIHJvb3QualF1ZXJ5LlNjcm9sbE1hZ2ljKSwgcm9vdC5Ud2Vlbk1heCB8fCByb290LlR3ZWVuTGl0ZSwgcm9vdC5UaW1lbGluZU1heCB8fCByb290LlRpbWVsaW5lTGl0ZSk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKFNjcm9sbE1hZ2ljLCBUd2VlbiwgVGltZWxpbmUpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBOQU1FU1BBQ0UgPSBcImFuaW1hdGlvbi5nc2FwXCI7XG5cblx0dmFyXG5cdGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZSB8fCB7fSxcblx0XHRlcnIgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUuZXJyb3IgfHwgY29uc29sZS5sb2cgfHxcblx0XHRmdW5jdGlvbiAoKSB7fSwgY29uc29sZSk7XG5cdGlmICghU2Nyb2xsTWFnaWMpIHtcblx0XHRlcnIoXCIoXCIgKyBOQU1FU1BBQ0UgKyBcIikgLT4gRVJST1I6IFRoZSBTY3JvbGxNYWdpYyBtYWluIG1vZHVsZSBjb3VsZCBub3QgYmUgZm91bmQuIFBsZWFzZSBtYWtlIHN1cmUgaXQncyBsb2FkZWQgYmVmb3JlIHRoaXMgcGx1Z2luIG9yIHVzZSBhbiBhc3luY2hyb25vdXMgbG9hZGVyIGxpa2UgcmVxdWlyZWpzLlwiKTtcblx0fVxuXHRpZiAoIVR3ZWVuKSB7XG5cdFx0ZXJyKFwiKFwiICsgTkFNRVNQQUNFICsgXCIpIC0+IEVSUk9SOiBUd2VlbkxpdGUgb3IgVHdlZW5NYXggY291bGQgbm90IGJlIGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIEdTQVAgaXMgbG9hZGVkIGJlZm9yZSBTY3JvbGxNYWdpYyBvciB1c2UgYW4gYXN5bmNocm9ub3VzIGxvYWRlciBsaWtlIHJlcXVpcmVqcy5cIik7XG5cdH1cblxuLypcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKiBFeHRlbnNpb25zIGZvciBTY2VuZVxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqL1xuXHQvKipcblx0ICogRXZlcnkgaW5zdGFuY2Ugb2YgU2Nyb2xsTWFnaWMuU2NlbmUgbm93IGFjY2VwdHMgYW4gYWRkaXRpb25hbCBvcHRpb24uICBcblx0ICogU2VlIHtAbGluayBTY3JvbGxNYWdpYy5TY2VuZX0gZm9yIGEgY29tcGxldGUgbGlzdCBvZiB0aGUgc3RhbmRhcmQgb3B0aW9ucy5cblx0ICogQG1lbWJlcm9mISBhbmltYXRpb24uR1NBUCNcblx0ICogQG1ldGhvZCBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUob3B0aW9ucylcblx0ICogQGV4YW1wbGVcblx0ICogdmFyIHNjZW5lID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHt0d2VlbkNoYW5nZXM6IHRydWV9KTtcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHRoZSBTY2VuZS4gVGhlIG9wdGlvbnMgY2FuIGJlIHVwZGF0ZWQgYXQgYW55IHRpbWUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHdlZW5DaGFuZ2VzPWZhbHNlXSAtIFR3ZWVucyBBbmltYXRpb24gdG8gdGhlIHByb2dyZXNzIHRhcmdldCBpbnN0ZWFkIG9mIHNldHRpbmcgaXQuICBcblx0IERvZXMgbm90IGFmZmVjdCBhbmltYXRpb25zIHdoZXJlIGR1cmF0aW9uIGlzIGAwYC5cblx0ICovXG5cdC8qKlxuXHQgKiAqKkdldCoqIG9yICoqU2V0KiogdGhlIHR3ZWVuQ2hhbmdlcyBvcHRpb24gdmFsdWUuICBcblx0ICogVGhpcyBvbmx5IGFmZmVjdHMgc2NlbmVzIHdpdGggYSBkdXJhdGlvbi4gSWYgYHR3ZWVuQ2hhbmdlc2AgaXMgYHRydWVgLCB0aGUgcHJvZ3Jlc3MgdXBkYXRlIHdoZW4gc2Nyb2xsaW5nIHdpbGwgbm90IGJlIGltbWVkaWF0ZSwgYnV0IGluc3RlYWQgdGhlIGFuaW1hdGlvbiB3aWxsIHNtb290aGx5IGFuaW1hdGUgdG8gdGhlIHRhcmdldCBzdGF0ZS4gIFxuXHQgKiBGb3IgYSBiZXR0ZXIgdW5kZXJzdGFuZGluZywgdHJ5IGVuYWJsaW5nIGFuZCBkaXNhYmxpbmcgdGhpcyBvcHRpb24gaW4gdGhlIFtTY2VuZSBNYW5pcHVsYXRpb24gRXhhbXBsZV0oLi4vZXhhbXBsZXMvYmFzaWMvc2NlbmVfbWFuaXB1bGF0aW9uLmh0bWwpLlxuXHQgKiBAbWVtYmVyb2YhIGFuaW1hdGlvbi5HU0FQI1xuXHQgKiBAbWV0aG9kIFNjZW5lLnR3ZWVuQ2hhbmdlc1xuXHQgKiBcblx0ICogQGV4YW1wbGVcblx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IHR3ZWVuQ2hhbmdlcyBvcHRpb25cblx0ICogdmFyIHR3ZWVuQ2hhbmdlcyA9IHNjZW5lLnR3ZWVuQ2hhbmdlcygpO1xuXHQgKlxuXHQgKiAvLyBzZXQgbmV3IHR3ZWVuQ2hhbmdlcyBvcHRpb25cblx0ICogc2NlbmUudHdlZW5DaGFuZ2VzKHRydWUpO1xuXHQgKlxuXHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmNoYW5nZX0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0ICogQHBhcmFtIHtib29sZWFufSBbbmV3VHdlZW5DaGFuZ2VzXSAtIFRoZSBuZXcgdHdlZW5DaGFuZ2VzIHNldHRpbmcgb2YgdGhlIHNjZW5lLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYGdldGAgLSAgQ3VycmVudCB0d2VlbkNoYW5nZXMgb3B0aW9uIHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7U2NlbmV9IGBzZXRgIC0gIFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0Ly8gYWRkIG9wdGlvbiAoVE9ETzogRE9DIChwcml2YXRlIGZvciBkZXYpKVxuXHRTY3JvbGxNYWdpYy5TY2VuZS5hZGRPcHRpb24oXCJ0d2VlbkNoYW5nZXNcIiwgLy8gbmFtZVxuXHRmYWxzZSwgLy8gZGVmYXVsdFxuXG5cblx0ZnVuY3Rpb24gKHZhbCkgeyAvLyB2YWxpZGF0aW9uIGNhbGxiYWNrXG5cdFx0cmV0dXJuICEhdmFsO1xuXHR9KTtcblx0Ly8gZXh0ZW5kIHNjZW5lXG5cdFNjcm9sbE1hZ2ljLlNjZW5lLmV4dGVuZChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIFNjZW5lID0gdGhpcyxcblx0XHRcdF90d2VlbjtcblxuXHRcdHZhciBsb2cgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoU2NlbmUuX2xvZykgeyAvLyBub3QgYXZhaWxhYmxlLCB3aGVuIG1haW4gc291cmNlIG1pbmlmaWVkXG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDEsIDAsIFwiKFwiICsgTkFNRVNQQUNFICsgXCIpXCIsIFwiLT5cIik7XG5cdFx0XHRcdFNjZW5lLl9sb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc2V0IGxpc3RlbmVyc1xuXHRcdFNjZW5lLm9uKFwicHJvZ3Jlc3MucGx1Z2luX2dzYXBcIiwgZnVuY3Rpb24gKCkge1xuXHRcdFx0dXBkYXRlVHdlZW5Qcm9ncmVzcygpO1xuXHRcdH0pO1xuXHRcdFNjZW5lLm9uKFwiZGVzdHJveS5wbHVnaW5fZ3NhcFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0U2NlbmUucmVtb3ZlVHdlZW4oZS5yZXNldCk7XG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdGhlIHR3ZWVuIHByb2dyZXNzIHRvIGN1cnJlbnQgcG9zaXRpb24uXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgdXBkYXRlVHdlZW5Qcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChfdHdlZW4pIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdHByb2dyZXNzID0gU2NlbmUucHJvZ3Jlc3MoKSxcblx0XHRcdFx0XHRzdGF0ZSA9IFNjZW5lLnN0YXRlKCk7XG5cdFx0XHRcdGlmIChfdHdlZW4ucmVwZWF0ICYmIF90d2Vlbi5yZXBlYXQoKSA9PT0gLTEpIHtcblx0XHRcdFx0XHQvLyBpbmZpbml0ZSBsb29wLCBzbyBub3QgaW4gcmVsYXRpb24gdG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRpZiAoc3RhdGUgPT09ICdEVVJJTkcnICYmIF90d2Vlbi5wYXVzZWQoKSkge1xuXHRcdFx0XHRcdFx0X3R3ZWVuLnBsYXkoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0YXRlICE9PSAnRFVSSU5HJyAmJiAhX3R3ZWVuLnBhdXNlZCgpKSB7XG5cdFx0XHRcdFx0XHRfdHdlZW4ucGF1c2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJvZ3Jlc3MgIT0gX3R3ZWVuLnByb2dyZXNzKCkpIHsgLy8gZG8gd2UgZXZlbiBuZWVkIHRvIHVwZGF0ZSB0aGUgcHJvZ3Jlc3M/XG5cdFx0XHRcdFx0Ly8gbm8gaW5maW5pdGUgbG9vcCAtIHNvIHNob3VsZCB3ZSBqdXN0IHBsYXkgb3IgZ28gdG8gYSBzcGVjaWZpYyBwb2ludCBpbiB0aW1lP1xuXHRcdFx0XHRcdGlmIChTY2VuZS5kdXJhdGlvbigpID09PSAwKSB7XG5cdFx0XHRcdFx0XHQvLyBwbGF5IHRoZSBhbmltYXRpb25cblx0XHRcdFx0XHRcdGlmIChwcm9ncmVzcyA+IDApIHsgLy8gcGxheSBmcm9tIDAgdG8gMVxuXHRcdFx0XHRcdFx0XHRfdHdlZW4ucGxheSgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHsgLy8gcGxheSBmcm9tIDEgdG8gMFxuXHRcdFx0XHRcdFx0XHRfdHdlZW4ucmV2ZXJzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBnbyB0byBhIHNwZWNpZmljIHBvaW50IGluIHRpbWVcblx0XHRcdFx0XHRcdGlmIChTY2VuZS50d2VlbkNoYW5nZXMoKSAmJiBfdHdlZW4udHdlZW5Ubykge1xuXHRcdFx0XHRcdFx0XHQvLyBnbyBzbW9vdGhcblx0XHRcdFx0XHRcdFx0X3R3ZWVuLnR3ZWVuVG8ocHJvZ3Jlc3MgKiBfdHdlZW4uZHVyYXRpb24oKSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBqdXN0IGhhcmQgc2V0IGl0XG5cdFx0XHRcdFx0XHRcdF90d2Vlbi5wcm9ncmVzcyhwcm9ncmVzcykucGF1c2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGEgdHdlZW4gdG8gdGhlIHNjZW5lLiAgXG5cdFx0ICogSWYgeW91IHdhbnQgdG8gYWRkIG11bHRpcGxlIHR3ZWVucywgYWRkIHRoZW0gaW50byBhIEdTQVAgVGltZWxpbmUgb2JqZWN0IGFuZCBzdXBwbHkgaXQgaW5zdGVhZCAoc2VlIGV4YW1wbGUgYmVsb3cpLiAgXG5cdFx0ICogXG5cdFx0ICogSWYgdGhlIHNjZW5lIGhhcyBhIGR1cmF0aW9uLCB0aGUgdHdlZW4ncyBkdXJhdGlvbiB3aWxsIGJlIHByb2plY3RlZCB0byB0aGUgc2Nyb2xsIGRpc3RhbmNlIG9mIHRoZSBzY2VuZSwgbWVhbmluZyBpdHMgcHJvZ3Jlc3Mgd2lsbCBiZSBzeW5jZWQgdG8gc2Nyb2xsYmFyIG1vdmVtZW50LiAgXG5cdFx0ICogRm9yIGEgc2NlbmUgd2l0aCBhIGR1cmF0aW9uIG9mIGAwYCwgdGhlIHR3ZWVuIHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gc2Nyb2xsaW5nIGZvcndhcmQgcGFzdCB0aGUgc2NlbmUncyB0cmlnZ2VyIHBvc2l0aW9uIGFuZCByZXZlcnNlZCwgd2hlbiBzY3JvbGxpbmcgYmFjay4gIFxuXHRcdCAqIFRvIGdhaW4gYmV0dGVyIHVuZGVyc3RhbmRpbmcsIGNoZWNrIG91dCB0aGUgW1NpbXBsZSBUd2VlbmluZyBleGFtcGxlXSguLi9leGFtcGxlcy9iYXNpYy9zaW1wbGVfdHdlZW5pbmcuaHRtbCkuXG5cdFx0ICpcblx0XHQgKiBJbnN0ZWFkIG9mIHN1cHBseWluZyBhIHR3ZWVuIHRoaXMgbWV0aG9kIGNhbiBhbHNvIGJlIHVzZWQgYXMgYSBzaG9ydGhhbmQgZm9yIGBUd2Vlbk1heC50bygpYCAoc2VlIGV4YW1wbGUgYmVsb3cpLlxuXHRcdCAqIEBtZW1iZXJvZiEgYW5pbWF0aW9uLkdTQVAjXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGFkZCBhIHNpbmdsZSB0d2VlbiBkaXJlY3RseVxuXHRcdCAqIHNjZW5lLnNldFR3ZWVuKFR3ZWVuTWF4LnRvKFwib2JqXCIpLCAxLCB7eDogMTAwfSk7XG5cdFx0ICpcblx0XHQgKiAvLyBhZGQgYSBzaW5nbGUgdHdlZW4gdmlhIHZhcmlhYmxlXG5cdFx0ICogdmFyIHR3ZWVuID0gVHdlZW5NYXgudG8oXCJvYmpcIiksIDEsIHt4OiAxMDB9O1xuXHRcdCAqIHNjZW5lLnNldFR3ZWVuKHR3ZWVuKTtcblx0XHQgKlxuXHRcdCAqIC8vIGFkZCBtdWx0aXBsZSB0d2VlbnMsIHdyYXBwZWQgaW4gYSB0aW1lbGluZS5cblx0XHQgKiB2YXIgdGltZWxpbmUgPSBuZXcgVGltZWxpbmVNYXgoKTtcblx0XHQgKiB2YXIgdHdlZW4xID0gVHdlZW5NYXguZnJvbShcIm9iajFcIiwgMSwge3g6IDEwMH0pO1xuXHRcdCAqIHZhciB0d2VlbjIgPSBUd2Vlbk1heC50byhcIm9iajJcIiwgMSwge3k6IDEwMH0pO1xuXHRcdCAqIHRpbWVsaW5lXG5cdFx0ICpcdFx0LmFkZCh0d2VlbjEpXG5cdFx0ICpcdFx0LmFkZCh0d2VlbjIpO1xuXHRcdCAqIHNjZW5lLmFkZFR3ZWVuKHRpbWVsaW5lKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNob3J0IGhhbmQgdG8gYWRkIGEgVHdlZW5NYXgudG8oKSB0d2VlblxuXHRcdCAqIHNjZW5lLnNldFR3ZWVuKFwib2JqM1wiLCAwLjUsIHt5OiAxMDB9KTtcblx0XHQgKlxuXHRcdCAqIC8vIHNob3J0IGhhbmQgdG8gYWRkIGEgVHdlZW5NYXgudG8oKSB0d2VlbiBmb3IgMSBzZWNvbmRcblx0XHQgKiAvLyB0aGlzIGlzIHVzZWZ1bCwgd2hlbiB0aGUgc2NlbmUgaGFzIGEgZHVyYXRpb24gYW5kIHRoZSB0d2VlbiBkdXJhdGlvbiBpc24ndCBpbXBvcnRhbnQgYW55d2F5XG5cdFx0ICogc2NlbmUuc2V0VHdlZW4oXCJvYmozXCIsIHt5OiAxMDB9KTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7KG9iamVjdHxzdHJpbmcpfSBUd2Vlbk9iamVjdCAtIEEgVHdlZW5NYXgsIFR3ZWVuTGl0ZSwgVGltZWxpbmVNYXggb3IgVGltZWxpbmVMaXRlIG9iamVjdCB0aGF0IHNob3VsZCBiZSBhbmltYXRlZCBpbiB0aGUgc2NlbmUuIENhbiBhbHNvIGJlIGEgRG9tIEVsZW1lbnQgb3IgU2VsZWN0b3IsIHdoZW4gdXNpbmcgZGlyZWN0IHR3ZWVuIGRlZmluaXRpb24gKHNlZSBleGFtcGxlcykuXG5cdFx0ICogQHBhcmFtIHsobnVtYmVyfG9iamVjdCl9IGR1cmF0aW9uIC0gQSBkdXJhdGlvbiBmb3IgdGhlIHR3ZWVuLCBvciB0d2VlbiBwYXJhbWV0ZXJzLiBJZiBhbiBvYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIGFyZSBzdXBwbGllZCwgYSBkZWZhdWx0IGR1cmF0aW9uIG9mIDEgd2lsbCBiZSB1c2VkLlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHR3ZWVuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHRTY2VuZS5zZXRUd2VlbiA9IGZ1bmN0aW9uIChUd2Vlbk9iamVjdCwgZHVyYXRpb24sIHBhcmFtcykge1xuXHRcdFx0dmFyIG5ld1R3ZWVuO1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuXHRcdFx0XHRcdHBhcmFtcyA9IGR1cmF0aW9uO1xuXHRcdFx0XHRcdGR1cmF0aW9uID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRUd2Vlbk9iamVjdCA9IFR3ZWVuLnRvKFR3ZWVuT2JqZWN0LCBkdXJhdGlvbiwgcGFyYW1zKTtcblx0XHRcdH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIHdyYXAgVHdlZW4gaW50byBhIFRpbWVsaW5lIE9iamVjdCBpZiBhdmFpbGFibGUgdG8gaW5jbHVkZSBkZWxheSBhbmQgcmVwZWF0cyBpbiB0aGUgZHVyYXRpb24gYW5kIHN0YW5kYXJkaXplIG1ldGhvZHMuXG5cdFx0XHRcdGlmIChUaW1lbGluZSkge1xuXHRcdFx0XHRcdG5ld1R3ZWVuID0gbmV3IFRpbWVsaW5lKHtcblx0XHRcdFx0XHRcdHNtb290aENoaWxkVGltaW5nOiB0cnVlXG5cdFx0XHRcdFx0fSkuYWRkKFR3ZWVuT2JqZWN0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdUd2VlbiA9IFR3ZWVuT2JqZWN0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld1R3ZWVuLnBhdXNlKCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGxvZygxLCBcIkVSUk9SIGNhbGxpbmcgbWV0aG9kICdzZXRUd2VlbigpJzogU3VwcGxpZWQgYXJndW1lbnQgaXMgbm90IGEgdmFsaWQgVHdlZW5PYmplY3RcIik7XG5cdFx0XHRcdHJldHVybiBTY2VuZTtcblx0XHRcdH1cblx0XHRcdGlmIChfdHdlZW4pIHsgLy8ga2lsbCBvbGQgdHdlZW4/XG5cdFx0XHRcdFNjZW5lLnJlbW92ZVR3ZWVuKCk7XG5cdFx0XHR9XG5cdFx0XHRfdHdlZW4gPSBuZXdUd2VlbjtcblxuXHRcdFx0Ly8gc29tZSBwcm9wZXJ0aWVzIG5lZWQgdG8gYmUgdHJhbnNmZXJyZWQgaXQgdG8gdGhlIHdyYXBwZXIsIG90aGVyd2lzZSB0aGV5IHdvdWxkIGdldCBsb3N0LlxuXHRcdFx0aWYgKFR3ZWVuT2JqZWN0LnJlcGVhdCAmJiBUd2Vlbk9iamVjdC5yZXBlYXQoKSA9PT0gLTEpIHsgLy8gVHdlZW5NYXggb3IgVGltZWxpbmVNYXggT2JqZWN0P1xuXHRcdFx0XHRfdHdlZW4ucmVwZWF0KC0xKTtcblx0XHRcdFx0X3R3ZWVuLnlveW8oVHdlZW5PYmplY3QueW95bygpKTtcblx0XHRcdH1cblx0XHRcdC8vIFNvbWUgdHdlZW4gdmFsaWRhdGlvbnMgYW5kIGRlYnVnZ2luZyBoZWxwZXJzXG5cdFx0XHRpZiAoU2NlbmUudHdlZW5DaGFuZ2VzKCkgJiYgIV90d2Vlbi50d2VlblRvKSB7XG5cdFx0XHRcdGxvZygyLCBcIldBUk5JTkc6IHR3ZWVuQ2hhbmdlcyB3aWxsIG9ubHkgd29yayBpZiB0aGUgVGltZWxpbmVNYXggb2JqZWN0IGlzIGF2YWlsYWJsZSBmb3IgU2Nyb2xsTWFnaWMuXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBpZiB0aGVyZSBhcmUgcG9zaXRpb24gdHdlZW5zIGRlZmluZWQgZm9yIHRoZSB0cmlnZ2VyIGFuZCB3YXJuIGFib3V0IGl0IDopXG5cdFx0XHRpZiAoX3R3ZWVuICYmIFNjZW5lLmNvbnRyb2xsZXIoKSAmJiBTY2VuZS50cmlnZ2VyRWxlbWVudCgpICYmIFNjZW5lLmxvZ2xldmVsKCkgPj0gMikgeyAvLyBjb250cm9sbGVyIGlzIG5lZWRlZCB0byBrbm93IHNjcm9sbCBkaXJlY3Rpb24uXG5cdFx0XHRcdHZhclxuXHRcdFx0XHR0cmlnZ2VyVHdlZW5zID0gVHdlZW4uZ2V0VHdlZW5zT2YoU2NlbmUudHJpZ2dlckVsZW1lbnQoKSksXG5cdFx0XHRcdFx0dmVydGljYWwgPSBTY2VuZS5jb250cm9sbGVyKCkuaW5mbyhcInZlcnRpY2FsXCIpO1xuXHRcdFx0XHR0cmlnZ2VyVHdlZW5zLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdHR3ZWVudmFycyA9IHZhbHVlLnZhcnMuY3NzIHx8IHZhbHVlLnZhcnMsXG5cdFx0XHRcdFx0XHRjb25kaXRpb24gPSB2ZXJ0aWNhbCA/ICh0d2VlbnZhcnMudG9wICE9PSB1bmRlZmluZWQgfHwgdHdlZW52YXJzLmJvdHRvbSAhPT0gdW5kZWZpbmVkKSA6ICh0d2VlbnZhcnMubGVmdCAhPT0gdW5kZWZpbmVkIHx8IHR3ZWVudmFycy5yaWdodCAhPT0gdW5kZWZpbmVkKTtcblx0XHRcdFx0XHRpZiAoY29uZGl0aW9uKSB7XG5cdFx0XHRcdFx0XHRsb2coMiwgXCJXQVJOSU5HOiBUd2VlbmluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHRyaWdnZXIgZWxlbWVudCBhZmZlY3RzIHRoZSBzY2VuZSB0aW1pbmcgYW5kIHNob3VsZCBiZSBhdm9pZGVkIVwiKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB3YXJuIGFib3V0IHR3ZWVuIG92ZXJ3cml0ZXMsIHdoZW4gYW4gZWxlbWVudCBpcyB0d2VlbmVkIG11bHRpcGxlIHRpbWVzXG5cdFx0XHRpZiAocGFyc2VGbG9hdChUd2VlbkxpdGUudmVyc2lvbikgPj0gMS4xNCkgeyAvLyBvbk92ZXJ3cml0ZSBvbmx5IHByZXNlbnQgc2luY2UgR1NBUCB2MS4xNC4wXG5cdFx0XHRcdHZhclxuXHRcdFx0XHRsaXN0ID0gX3R3ZWVuLmdldENoaWxkcmVuID8gX3R3ZWVuLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKSA6IFtfdHdlZW5dLFxuXHRcdFx0XHRcdC8vIGdldCBhbGwgbmVzdGVkIHR3ZWVuIG9iamVjdHNcblx0XHRcdFx0XHRuZXdDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGxvZygyLCBcIldBUk5JTkc6IHR3ZWVuIHdhcyBvdmVyd3JpdHRlbiBieSBhbm90aGVyLiBUbyBsZWFybiBob3cgdG8gYXZvaWQgdGhpcyBpc3N1ZSBzZWUgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2phbnBhZXBrZS9TY3JvbGxNYWdpYy93aWtpL1dBUk5JTkc6LXR3ZWVuLXdhcy1vdmVyd3JpdHRlbi1ieS1hbm90aGVyXCIpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCB0aGlzVHdlZW4sIG9sZENhbGxiYWNrOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgeyAvKmpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuXHRcdFx0XHRcdHRoaXNUd2VlbiA9IGxpc3RbaV07XG5cdFx0XHRcdFx0aWYgKG9sZENhbGxiYWNrICE9PSBuZXdDYWxsYmFjaykgeyAvLyBpZiB0d2VlbnMgaXMgYWRkZWQgbW9yZSB0aGFuIG9uY2Vcblx0XHRcdFx0XHRcdG9sZENhbGxiYWNrID0gdGhpc1R3ZWVuLnZhcnMub25PdmVyd3JpdGU7XG5cdFx0XHRcdFx0XHR0aGlzVHdlZW4udmFycy5vbk92ZXJ3cml0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9sZENhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRcdFx0b2xkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRuZXdDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxvZygzLCBcImFkZGVkIHR3ZWVuXCIpO1xuXG5cdFx0XHR1cGRhdGVUd2VlblByb2dyZXNzKCk7XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSB0aGUgdHdlZW4gZnJvbSB0aGUgc2NlbmUuICBcblx0XHQgKiBUaGlzIHdpbGwgdGVybWluYXRlIHRoZSBjb250cm9sIG9mIHRoZSBTY2VuZSBvdmVyIHRoZSB0d2Vlbi5cblx0XHQgKlxuXHRcdCAqIFVzaW5nIHRoZSByZXNldCBvcHRpb24geW91IGNhbiBkZWNpZGUgaWYgdGhlIHR3ZWVuIHNob3VsZCByZW1haW4gaW4gdGhlIGN1cnJlbnQgc3RhdGUgb3IgYmUgcmV3b3VuZCB0byBzZXQgdGhlIHRhcmdldCBlbGVtZW50cyBiYWNrIHRvIHRoZSBzdGF0ZSB0aGV5IHdlcmUgaW4gYmVmb3JlIHRoZSB0d2VlbiB3YXMgYWRkZWQgdG8gdGhlIHNjZW5lLlxuXHRcdCAqIEBtZW1iZXJvZiEgYW5pbWF0aW9uLkdTQVAjXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHJlbW92ZSB0aGUgdHdlZW4gZnJvbSB0aGUgc2NlbmUgd2l0aG91dCByZXNldHRpbmcgaXRcblx0XHQgKiBzY2VuZS5yZW1vdmVUd2VlbigpO1xuXHRcdCAqXG5cdFx0ICogLy8gcmVtb3ZlIHRoZSB0d2VlbiBmcm9tIHRoZSBzY2VuZSBhbmQgcmVzZXQgaXQgdG8gaW5pdGlhbCBwb3NpdGlvblxuXHRcdCAqIHNjZW5lLnJlbW92ZVR3ZWVuKHRydWUpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbcmVzZXQ9ZmFsc2VdIC0gSWYgYHRydWVgIHRoZSB0d2VlbiB3aWxsIGJlIHJlc2V0IHRvIGl0cyBpbml0aWFsIHZhbHVlcy5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdFNjZW5lLnJlbW92ZVR3ZWVuID0gZnVuY3Rpb24gKHJlc2V0KSB7XG5cdFx0XHRpZiAoX3R3ZWVuKSB7XG5cdFx0XHRcdGlmIChyZXNldCkge1xuXHRcdFx0XHRcdF90d2Vlbi5wcm9ncmVzcygwKS5wYXVzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF90d2Vlbi5raWxsKCk7XG5cdFx0XHRcdF90d2VlbiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0bG9nKDMsIFwicmVtb3ZlZCB0d2VlbiAocmVzZXQ6IFwiICsgKHJlc2V0ID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpICsgXCIpXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0fSk7XG59KSk7IiwiLyohIExhenkgTG9hZCBYVCB2MS4wLjUgMjAxNC0wNi0wNVxuICogaHR0cDovL3Jlc3Npby5naXRodWIuaW8vbGF6eS1sb2FkLXh0XG4gKiAoQykgMjAxNCBSRVNTLmlvXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKi9cblxuKGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcbiAgICAvLyBvcHRpb25zXG4gICAgdmFyIGxhenlMb2FkWFQgPSAnbGF6eUxvYWRYVCcsXG4gICAgICAgIGRhdGFMYXppZWQgPSAnbGF6aWVkJyxcbiAgICAgICAgbG9hZF9lcnJvciA9ICdsb2FkIGVycm9yJyxcbiAgICAgICAgY2xhc3NMYXp5SGlkZGVuID0gJ2xhenktaGlkZGVuJyxcbiAgICAgICAgZG9jRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LFxuICAgIC8vICBmb3JjZSBsb2FkIGFsbCBpbWFnZXMgaW4gT3BlcmEgTWluaSBhbmQgc29tZSBtb2JpbGUgYnJvd3NlcnMgd2l0aG91dCBzY3JvbGwgZXZlbnQgb3IgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgZm9yY2VMb2FkID0gKHdpbmRvdy5vbnNjcm9sbCA9PT0gdW5kZWZpbmVkIHx8ICEhd2luZG93Lm9wZXJhbWluaSB8fCAhZG9jRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpLFxuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgYXV0b0luaXQ6IHRydWUsIC8vIGF1dG8gaW5pdGlhbGl6ZSBpbiAkLnJlYWR5XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2ltZ1tkYXRhLXNyY10nLCAvLyBzZWxlY3RvciBmb3IgbGF6eWxvYWRpbmcgZWxlbWVudHNcbiAgICAgICAgICAgIGJsYW5rSW1hZ2U6ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTcnLFxuICAgICAgICAgICAgdGhyb3R0bGU6IDk5LCAvLyBpbnRlcnZhbCAobXMpIGZvciBjaGFuZ2VzIGNoZWNrXG4gICAgICAgICAgICBmb3JjZUxvYWQ6IGZvcmNlTG9hZCwgLy8gZm9yY2UgYXV0byBsb2FkIGFsbCBpbWFnZXNcblxuICAgICAgICAgICAgbG9hZEV2ZW50OiAncGFnZXNob3cnLCAvLyBjaGVjayBBSkFYLWxvYWRlZCBjb250ZW50IGluIGpRdWVyeU1vYmlsZVxuICAgICAgICAgICAgdXBkYXRlRXZlbnQ6ICdsb2FkIG9yaWVudGF0aW9uY2hhbmdlIHJlc2l6ZSBzY3JvbGwgdG91Y2htb3ZlIGZvY3VzJywgLy8gcGFnZS1tb2RpZmllZCBldmVudHNcbiAgICAgICAgICAgIGZvcmNlRXZlbnQ6ICcnLCAvLyBmb3JjZSBsb2FkaW5nIG9mIGFsbCBlbGVtZW50c1xuXG4gICAgICAgICAgICAvL29uc3RhcnQ6IG51bGwsXG4gICAgICAgICAgICBvbmluaXQ6IHtyZW1vdmVDbGFzczogJ2xhenknfSwgLy8gaW5pdCBoYW5kbGVyXG4gICAgICAgICAgICBvbnNob3c6IHthZGRDbGFzczogY2xhc3NMYXp5SGlkZGVufSwgLy8gc3RhcnQgbG9hZGluZyBoYW5kbGVyXG4gICAgICAgICAgICBvbmxvYWQ6IHtyZW1vdmVDbGFzczogY2xhc3NMYXp5SGlkZGVuLCBhZGRDbGFzczogJ2xhenktbG9hZGVkJ30sIC8vIGxvYWQgc3VjY2VzcyBoYW5kbGVyXG4gICAgICAgICAgICBvbmVycm9yOiB7cmVtb3ZlQ2xhc3M6IGNsYXNzTGF6eUhpZGRlbn0sIC8vIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIC8vb25jb21wbGV0ZTogbnVsbCwgLy8gY29tcGxldGUgaGFuZGxlclxuXG4gICAgICAgICAgICAvL3Njcm9sbENvbnRhaW5lcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVzOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGVsZW1lbnRPcHRpb25zID0ge1xuICAgICAgICAgICAgc3JjQXR0cjogJ2RhdGEtc3JjJyxcbiAgICAgICAgICAgIGVkZ2VYOiAwLFxuICAgICAgICAgICAgZWRnZVk6IDAsXG4gICAgICAgICAgICB2aXNpYmxlT25seTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAkd2luZG93ID0gJCh3aW5kb3cpLFxuICAgICAgICAkaXNGdW5jdGlvbiA9ICQuaXNGdW5jdGlvbixcbiAgICAgICAgJGV4dGVuZCA9ICQuZXh0ZW5kLFxuICAgICAgICAkZGF0YSA9ICQuZGF0YSB8fCBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAkKGVsKS5kYXRhKG5hbWUpO1xuICAgICAgICB9LFxuICAgIC8vICQuY29udGFpbnMgaXMgbm90IGluY2x1ZGVkIGludG8gRE9NdGFzdGljLCBzbyBpbXBsZW1lbnQgaXQgdGhlcmVcbiAgICAgICAgJGNvbnRhaW5zID0gJC5jb250YWlucyB8fCBmdW5jdGlvbiAocGFyZW50LCBlbCkge1xuICAgICAgICAgICAgd2hpbGUgKGVsID0gZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZWxlbWVudHMgPSBbXSxcbiAgICAgICAgdG9wTGF6eSA9IDAsXG4gICAgLypcbiAgICAgd2FpdGluZ01vZGU9MCA6IG5vIHNldFRpbWVvdXRcbiAgICAgd2FpdGluZ01vZGU9MSA6IHNldFRpbWVvdXQsIG5vIGRlZmVycmVkIGV2ZW50c1xuICAgICB3YWl0aW5nTW9kZT0yIDogc2V0VGltZW91dCwgZGVmZXJyZWQgZXZlbnRzXG4gICAgICovXG4gICAgICAgIHdhaXRpbmdNb2RlID0gMDtcblxuICAgICRbbGF6eUxvYWRYVF0gPSAkZXh0ZW5kKG9wdGlvbnMsIGVsZW1lbnRPcHRpb25zLCAkW2xhenlMb2FkWFRdKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBvcHRpb25zLnByb3AgaWYgb2JqLnByb3AgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgcmV0dXJuIG9iai5wcm9wXG4gICAgICogQHBhcmFtIHsqfSBvYmpcbiAgICAgKiBAcGFyYW0geyp9IHByb3BcbiAgICAgKiBAcmV0dXJucyAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0T3JEZWYob2JqLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHVuZGVmaW5lZCA/IG9wdGlvbnNbcHJvcF0gOiBvYmpbcHJvcF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY3JvbGxUb3AoKSB7XG4gICAgICAgIHZhciBzY3JvbGwgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHJldHVybiAoc2Nyb2xsID09PSB1bmRlZmluZWQpID8gZG9jRWxlbWVudC5zY3JvbGxUb3AgOiBzY3JvbGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIG5ldyBlbGVtZW50cyB0byBsYXp5LWxvYWQgbGlzdDpcbiAgICAgKiAkKGVsZW1lbnRzKS5sYXp5TG9hZFhUKCkgb3IgJCh3aW5kb3cpLmxhenlMb2FkWFQoKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvdmVycmlkZXNdIG92ZXJyaWRlIGdsb2JhbCBvcHRpb25zXG4gICAgICovXG4gICAgJC5mbltsYXp5TG9hZFhUXSA9IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgb3ZlcnJpZGVzID0gb3ZlcnJpZGVzIHx8IHt9O1xuXG4gICAgICAgIHZhciBibGFua0ltYWdlID0gZ2V0T3JEZWYob3ZlcnJpZGVzLCAnYmxhbmtJbWFnZScpLFxuICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVzID0gZ2V0T3JEZWYob3ZlcnJpZGVzLCAnY2hlY2tEdXBsaWNhdGVzJyksXG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXIgPSBnZXRPckRlZihvdmVycmlkZXMsICdzY3JvbGxDb250YWluZXInKSxcbiAgICAgICAgICAgIGVsZW1lbnRPcHRpb25zT3ZlcnJpZGVzID0ge30sXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIC8vIGVtcHR5IG92ZXJyaWRlcy5zY3JvbGxDb250YWluZXIgaXMgc3VwcG9ydGVkIGJ5IGJvdGggalF1ZXJ5IGFuZCBaZXB0b1xuICAgICAgICAkKHNjcm9sbENvbnRhaW5lcikub24oJ3Njcm9sbCcsIHF1ZXVlQ2hlY2tMYXp5RWxlbWVudHMpO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBlbGVtZW50T3B0aW9ucykge1xuICAgICAgICAgICAgZWxlbWVudE9wdGlvbnNPdmVycmlkZXNbcHJvcF0gPSBnZXRPckRlZihvdmVycmlkZXMsIHByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaW5kZXgsIGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IHdpbmRvdykge1xuICAgICAgICAgICAgICAgICQob3B0aW9ucy5zZWxlY3RvcikubGF6eUxvYWRYVChvdmVycmlkZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tEdXBsaWNhdGVzICYmICRkYXRhKGVsLCBkYXRhTGF6aWVkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyICRlbCA9ICQoZWwpLmRhdGEoZGF0YUxhemllZCwgMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmxhbmtJbWFnZSAmJiBlbC50YWdOYW1lID09PSAnSU1HJyAmJiAhZWwuc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNyYyA9IGJsYW5rSW1hZ2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2xvbmUgZWxlbWVudE9wdGlvbnNPdmVycmlkZXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgJGVsW2xhenlMb2FkWFRdID0gJGV4dGVuZCh7fSwgZWxlbWVudE9wdGlvbnNPdmVycmlkZXMpO1xuXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbml0JywgJGVsKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goJGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBmdW5jdGlvbi9vYmplY3QgZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBzdWZmaXhcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGV2ZW50LCAkZWwpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBvcHRpb25zWydvbicgKyBldmVudF07XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAoJGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwoJGVsWzBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuYWRkQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsLmFkZENsYXNzKGhhbmRsZXIuYWRkQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yZW1vdmVDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAkZWwucmVtb3ZlQ2xhc3MoaGFuZGxlci5yZW1vdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJGVsLnRyaWdnZXIoJ2xhenknICsgZXZlbnQsIFskZWxdKTtcblxuICAgICAgICAvLyBxdWV1ZSBuZXh0IGNoZWNrIGFzIGltYWdlcyBtYXkgYmUgcmVzaXplZCBhZnRlciBsb2FkaW5nIG9mIGFjdHVhbCBmaWxlXG4gICAgICAgIHF1ZXVlQ2hlY2tMYXp5RWxlbWVudHMoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgb25sb2FkL29uZXJyb3IgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmlnZ2VyTG9hZE9yRXJyb3IoZSkge1xuICAgICAgICB0cmlnZ2VyRXZlbnQoZS50eXBlLCAkKHRoaXMpLm9mZihsb2FkX2Vycm9yLCB0cmlnZ2VyTG9hZE9yRXJyb3IpKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExvYWQgdmlzaWJsZSBlbGVtZW50c1xuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2ZvcmNlXSBsb2FkaW5nIG9mIGFsbCBlbGVtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrTGF6eUVsZW1lbnRzKGZvcmNlKSB7XG4gICAgICAgIGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3JjZSA9IGZvcmNlIHx8IG9wdGlvbnMuZm9yY2VMb2FkO1xuXG4gICAgICAgIHRvcExhenkgPSBJbmZpbml0eTtcblxuICAgICAgICB2YXIgdmlld3BvcnRUb3AgPSBzY3JvbGxUb3AoKSxcbiAgICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY0VsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgdmlld3BvcnRXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY0VsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgJGVsID0gZWxlbWVudHNbaV0sXG4gICAgICAgICAgICAgICAgZWwgPSAkZWxbMF0sXG4gICAgICAgICAgICAgICAgb2JqRGF0YSA9ICRlbFtsYXp5TG9hZFhUXSxcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IGZvcmNlLFxuICAgICAgICAgICAgICAgIHRvcEVkZ2U7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBpdGVtcyB0aGF0IGFyZSBub3QgaW4gRE9NXG4gICAgICAgICAgICBpZiAoISRjb250YWlucyhkb2NFbGVtZW50LCBlbCkpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9yY2UgfHwgIW9iakRhdGEudmlzaWJsZU9ubHkgfHwgZWwub2Zmc2V0V2lkdGggfHwgZWwub2Zmc2V0SGVpZ2h0KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsUG9zID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlWCA9IG9iakRhdGEuZWRnZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlWSA9IG9iakRhdGEuZWRnZVk7XG5cbiAgICAgICAgICAgICAgICAgICAgdG9wRWRnZSA9IChlbFBvcy50b3AgKyB2aWV3cG9ydFRvcCAtIGVkZ2VZKSAtIHZpZXdwb3J0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGUgPSAodG9wRWRnZSA8PSB2aWV3cG9ydFRvcCAmJiBlbFBvcy5ib3R0b20gPiAtZWRnZVkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUG9zLmxlZnQgPD0gdmlld3BvcnRXaWR0aCArIGVkZ2VYICYmIGVsUG9zLnJpZ2h0ID4gLWVkZ2VYKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ3Nob3cnLCAkZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcmNBdHRyID0gb2JqRGF0YS5zcmNBdHRyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjID0gJGlzRnVuY3Rpb24oc3JjQXR0cikgPyBzcmNBdHRyKCRlbCkgOiBlbC5nZXRBdHRyaWJ1dGUoc3JjQXR0cik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRlbC5vbihsb2FkX2Vycm9yLCB0cmlnZ2VyTG9hZE9yRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcEVkZ2UgPCB0b3BMYXp5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BMYXp5ID0gdG9wRWRnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbW92ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2NvbXBsZXRlJywgJChkb2NFbGVtZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJ1biBjaGVjayBvZiBsYXp5IGVsZW1lbnRzIGFmdGVyIHRpbWVvdXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lb3V0TGF6eUVsZW1lbnRzKCkge1xuICAgICAgICBpZiAod2FpdGluZ01vZGUgPiAxKSB7XG4gICAgICAgICAgICB3YWl0aW5nTW9kZSA9IDE7XG4gICAgICAgICAgICBjaGVja0xhenlFbGVtZW50cygpO1xuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lb3V0TGF6eUVsZW1lbnRzLCBvcHRpb25zLnRocm90dGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhaXRpbmdNb2RlID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUXVldWUgY2hlY2sgb2YgbGF6eSBlbGVtZW50cyBiZWNhdXNlIG9mIGV2ZW50IGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWV1ZUNoZWNrTGF6eUVsZW1lbnRzKGUpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhc3QgY2hlY2sgZm9yIHNjcm9sbCBldmVudCB3aXRob3V0IG5ldyB2aXNpYmxlIGVsZW1lbnRzXG4gICAgICAgIGlmIChlICYmIGUudHlwZSA9PT0gJ3Njcm9sbCcgJiYgZS5jdXJyZW50VGFyZ2V0ID09PSB3aW5kb3cpIHtcbiAgICAgICAgICAgIGlmICh0b3BMYXp5ID49IHNjcm9sbFRvcCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3YWl0aW5nTW9kZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lb3V0TGF6eUVsZW1lbnRzLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB3YWl0aW5nTW9kZSA9IDI7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGxpc3Qgb2YgaGlkZGVuIGVsZW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdExhenlFbGVtZW50cygpIHtcbiAgICAgICAgJHdpbmRvdy5sYXp5TG9hZFhUKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMb2FkaW5nIG9mIGFsbCBlbGVtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcmNlTG9hZEFsbCgpIHtcbiAgICAgICAgY2hlY2tMYXp5RWxlbWVudHModHJ1ZSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXphdGlvblxuICAgICAqL1xuICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50KCdzdGFydCcsICR3aW5kb3cpO1xuXG4gICAgICAgICR3aW5kb3dcbiAgICAgICAgICAgIC5vbihvcHRpb25zLmxvYWRFdmVudCwgaW5pdExhenlFbGVtZW50cylcbiAgICAgICAgICAgIC5vbihvcHRpb25zLnVwZGF0ZUV2ZW50LCBxdWV1ZUNoZWNrTGF6eUVsZW1lbnRzKVxuICAgICAgICAgICAgLm9uKG9wdGlvbnMuZm9yY2VFdmVudCwgZm9yY2VMb2FkQWxsKTtcblxuICAgICAgICAkKGRvY3VtZW50KS5vbihvcHRpb25zLnVwZGF0ZUV2ZW50LCBxdWV1ZUNoZWNrTGF6eUVsZW1lbnRzKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdXRvSW5pdCkge1xuICAgICAgICAgICAgaW5pdExhenlFbGVtZW50cygpOyAvLyBzdGFuZGFyZCBpbml0aWFsaXphdGlvblxuICAgICAgICB9XG4gICAgfSk7XG5cbn0pKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvIHx8IHdpbmRvdy4kLCB3aW5kb3csIGRvY3VtZW50KTsiLCIvKiEgTGF6eSBMb2FkIFhUIHYxLjAuNSAyMDE0LTA2LTA1XG4gKiBodHRwOi8vcmVzc2lvLmdpdGh1Yi5pby9sYXp5LWxvYWQteHRcbiAqIChDKSAyMDE0IFJFU1MuaW9cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAqL1xuXG4oZnVuY3Rpb24gKCQpIHtcbiAgICB2YXIgb3B0aW9ucyA9ICQubGF6eUxvYWRYVDtcblxuICAgIG9wdGlvbnMuZm9yY2VFdmVudCArPSAnIGxhenlhdXRvbG9hZCc7XG4gICAgb3B0aW9ucy5hdXRvTG9hZFRpbWUgPSBvcHRpb25zLmF1dG9Mb2FkVGltZSB8fCA1MDtcblxuICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHdpbmRvdykudHJpZ2dlcignbGF6eWF1dG9sb2FkJyk7XG4gICAgICAgIH0sIG9wdGlvbnMuYXV0b0xvYWRUaW1lKTtcbiAgICB9KTtcblxufSkod2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG8gfHwgd2luZG93LiQpO1xuIiwiLyohIExhenkgTG9hZCBYVCB2MS4wLjUgMjAxNC0wNi0wNVxuICogaHR0cDovL3Jlc3Npby5naXRodWIuaW8vbGF6eS1sb2FkLXh0XG4gKiAoQykgMjAxNCBSRVNTLmlvXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKi9cblxuKGZ1bmN0aW9uICgkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSAkLmxhenlMb2FkWFQsXG4gICAgICAgIGJnQXR0ciA9IG9wdGlvbnMuYmdBdHRyIHx8ICdkYXRhLWJnJztcblxuICAgIG9wdGlvbnMuc2VsZWN0b3IgKz0gJyxbJyArIGJnQXR0ciArICddJztcblxuICAgICQoZG9jdW1lbnQpLm9uKCdsYXp5c2hvdycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciAkdGhpcyA9ICQoZS50YXJnZXQpO1xuICAgICAgICAkdGhpc1xuICAgICAgICAgICAgLmNzcygnYmFja2dyb3VuZC1pbWFnZScsIFwidXJsKCdcIiArICR0aGlzLmF0dHIoYmdBdHRyKSArIFwiJylcIilcbiAgICAgICAgICAgIC5yZW1vdmVBdHRyKGJnQXR0cik7XG4gICAgfSk7XG5cbn0pKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvIHx8IHdpbmRvdy4kKTtcbiIsIiFmdW5jdGlvbigkKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRk9VTkRBVElPTl9WRVJTSU9OID0gJzYuMi4xJztcblxuLy8gR2xvYmFsIEZvdW5kYXRpb24gb2JqZWN0XG4vLyBUaGlzIGlzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3csIG9yIHVzZWQgYXMgYSBtb2R1bGUgZm9yIEFNRC9Ccm93c2VyaWZ5XG52YXIgRm91bmRhdGlvbiA9IHtcbiAgdmVyc2lvbjogRk9VTkRBVElPTl9WRVJTSU9OLFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgaW5pdGlhbGl6ZWQgcGx1Z2lucy5cbiAgICovXG4gIF9wbHVnaW5zOiB7fSxcblxuICAvKipcbiAgICogU3RvcmVzIGdlbmVyYXRlZCB1bmlxdWUgaWRzIGZvciBwbHVnaW4gaW5zdGFuY2VzXG4gICAqL1xuICBfdXVpZHM6IFtdLFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBmb3IgUlRMIHN1cHBvcnRcbiAgICovXG4gIHJ0bDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gJCgnaHRtbCcpLmF0dHIoJ2RpcicpID09PSAncnRsJztcbiAgfSxcbiAgLyoqXG4gICAqIERlZmluZXMgYSBGb3VuZGF0aW9uIHBsdWdpbiwgYWRkaW5nIGl0IHRvIHRoZSBgRm91bmRhdGlvbmAgbmFtZXNwYWNlIGFuZCB0aGUgbGlzdCBvZiBwbHVnaW5zIHRvIGluaXRpYWxpemUgd2hlbiByZWZsb3dpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHBsdWdpbi5cbiAgICovXG4gIHBsdWdpbjogZnVuY3Rpb24ocGx1Z2luLCBuYW1lKSB7XG4gICAgLy8gT2JqZWN0IGtleSB0byB1c2Ugd2hlbiBhZGRpbmcgdG8gZ2xvYmFsIEZvdW5kYXRpb24gb2JqZWN0XG4gICAgLy8gRXhhbXBsZXM6IEZvdW5kYXRpb24uUmV2ZWFsLCBGb3VuZGF0aW9uLk9mZkNhbnZhc1xuICAgIHZhciBjbGFzc05hbWUgPSAobmFtZSB8fCBmdW5jdGlvbk5hbWUocGx1Z2luKSk7XG4gICAgLy8gT2JqZWN0IGtleSB0byB1c2Ugd2hlbiBzdG9yaW5nIHRoZSBwbHVnaW4sIGFsc28gdXNlZCB0byBjcmVhdGUgdGhlIGlkZW50aWZ5aW5nIGRhdGEgYXR0cmlidXRlIGZvciB0aGUgcGx1Z2luXG4gICAgLy8gRXhhbXBsZXM6IGRhdGEtcmV2ZWFsLCBkYXRhLW9mZi1jYW52YXNcbiAgICB2YXIgYXR0ck5hbWUgID0gaHlwaGVuYXRlKGNsYXNzTmFtZSk7XG5cbiAgICAvLyBBZGQgdG8gdGhlIEZvdW5kYXRpb24gb2JqZWN0IGFuZCB0aGUgcGx1Z2lucyBsaXN0IChmb3IgcmVmbG93aW5nKVxuICAgIHRoaXMuX3BsdWdpbnNbYXR0ck5hbWVdID0gdGhpc1tjbGFzc05hbWVdID0gcGx1Z2luO1xuICB9LFxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIFBvcHVsYXRlcyB0aGUgX3V1aWRzIGFycmF5IHdpdGggcG9pbnRlcnMgdG8gZWFjaCBpbmRpdmlkdWFsIHBsdWdpbiBpbnN0YW5jZS5cbiAgICogQWRkcyB0aGUgYHpmUGx1Z2luYCBkYXRhLWF0dHJpYnV0ZSB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZWQgcGx1Z2lucyB0byBhbGxvdyB1c2Ugb2YgJChzZWxlY3RvcikuZm91bmRhdGlvbihtZXRob2QpIGNhbGxzLlxuICAgKiBBbHNvIGZpcmVzIHRoZSBpbml0aWFsaXphdGlvbiBldmVudCBmb3IgZWFjaCBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZWRpdGl2ZSBjb2RlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIC0gYW4gaW5zdGFuY2Ugb2YgYSBwbHVnaW4sIHVzdWFsbHkgYHRoaXNgIGluIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHBsdWdpbiwgcGFzc2VkIGFzIGEgY2FtZWxDYXNlZCBzdHJpbmcuXG4gICAqIEBmaXJlcyBQbHVnaW4jaW5pdFxuICAgKi9cbiAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uKHBsdWdpbiwgbmFtZSl7XG4gICAgdmFyIHBsdWdpbk5hbWUgPSBuYW1lID8gaHlwaGVuYXRlKG5hbWUpIDogZnVuY3Rpb25OYW1lKHBsdWdpbi5jb25zdHJ1Y3RvcikudG9Mb3dlckNhc2UoKTtcbiAgICBwbHVnaW4udXVpZCA9IHRoaXMuR2V0WW9EaWdpdHMoNiwgcGx1Z2luTmFtZSk7XG5cbiAgICBpZighcGx1Z2luLiRlbGVtZW50LmF0dHIoYGRhdGEtJHtwbHVnaW5OYW1lfWApKXsgcGx1Z2luLiRlbGVtZW50LmF0dHIoYGRhdGEtJHtwbHVnaW5OYW1lfWAsIHBsdWdpbi51dWlkKTsgfVxuICAgIGlmKCFwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nKSl7IHBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicsIHBsdWdpbik7IH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGluaXRpYWxpemVkLlxuICAgICAgICAgICAqIEBldmVudCBQbHVnaW4jaW5pdFxuICAgICAgICAgICAqL1xuICAgIHBsdWdpbi4kZWxlbWVudC50cmlnZ2VyKGBpbml0LnpmLiR7cGx1Z2luTmFtZX1gKTtcblxuICAgIHRoaXMuX3V1aWRzLnB1c2gocGx1Z2luLnV1aWQpO1xuXG4gICAgcmV0dXJuO1xuICB9LFxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIFJlbW92ZXMgdGhlIHBsdWdpbnMgdXVpZCBmcm9tIHRoZSBfdXVpZHMgYXJyYXkuXG4gICAqIFJlbW92ZXMgdGhlIHpmUGx1Z2luIGRhdGEgYXR0cmlidXRlLCBhcyB3ZWxsIGFzIHRoZSBkYXRhLXBsdWdpbi1uYW1lIGF0dHJpYnV0ZS5cbiAgICogQWxzbyBmaXJlcyB0aGUgZGVzdHJveWVkIGV2ZW50IGZvciB0aGUgcGx1Z2luLCBjb25zb2xpZGF0aW5nIHJlcGVkaXRpdmUgY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxuICAgKiBAZmlyZXMgUGx1Z2luI2Rlc3Ryb3llZFxuICAgKi9cbiAgdW5yZWdpc3RlclBsdWdpbjogZnVuY3Rpb24ocGx1Z2luKXtcbiAgICB2YXIgcGx1Z2luTmFtZSA9IGh5cGhlbmF0ZShmdW5jdGlvbk5hbWUocGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykuY29uc3RydWN0b3IpKTtcblxuICAgIHRoaXMuX3V1aWRzLnNwbGljZSh0aGlzLl91dWlkcy5pbmRleE9mKHBsdWdpbi51dWlkKSwgMSk7XG4gICAgcGx1Z2luLiRlbGVtZW50LnJlbW92ZUF0dHIoYGRhdGEtJHtwbHVnaW5OYW1lfWApLnJlbW92ZURhdGEoJ3pmUGx1Z2luJylcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGJlZW4gZGVzdHJveWVkLlxuICAgICAgICAgICAqIEBldmVudCBQbHVnaW4jZGVzdHJveWVkXG4gICAgICAgICAgICovXG4gICAgICAgICAgLnRyaWdnZXIoYGRlc3Ryb3llZC56Zi4ke3BsdWdpbk5hbWV9YCk7XG4gICAgZm9yKHZhciBwcm9wIGluIHBsdWdpbil7XG4gICAgICBwbHVnaW5bcHJvcF0gPSBudWxsOy8vY2xlYW4gdXAgc2NyaXB0IHRvIHByZXAgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQ2F1c2VzIG9uZSBvciBtb3JlIGFjdGl2ZSBwbHVnaW5zIHRvIHJlLWluaXRpYWxpemUsIHJlc2V0dGluZyBldmVudCBsaXN0ZW5lcnMsIHJlY2FsY3VsYXRpbmcgcG9zaXRpb25zLCBldGMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW5zIC0gb3B0aW9uYWwgc3RyaW5nIG9mIGFuIGluZGl2aWR1YWwgcGx1Z2luIGtleSwgYXR0YWluZWQgYnkgY2FsbGluZyBgJChlbGVtZW50KS5kYXRhKCdwbHVnaW5OYW1lJylgLCBvciBzdHJpbmcgb2YgYSBwbHVnaW4gY2xhc3MgaS5lLiBgJ2Ryb3Bkb3duJ2BcbiAgICogQGRlZmF1bHQgSWYgbm8gYXJndW1lbnQgaXMgcGFzc2VkLCByZWZsb3cgYWxsIGN1cnJlbnRseSBhY3RpdmUgcGx1Z2lucy5cbiAgICovXG4gICByZUluaXQ6IGZ1bmN0aW9uKHBsdWdpbnMpe1xuICAgICB2YXIgaXNKUSA9IHBsdWdpbnMgaW5zdGFuY2VvZiAkO1xuICAgICB0cnl7XG4gICAgICAgaWYoaXNKUSl7XG4gICAgICAgICBwbHVnaW5zLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgJCh0aGlzKS5kYXRhKCd6ZlBsdWdpbicpLl9pbml0KCk7XG4gICAgICAgICB9KTtcbiAgICAgICB9ZWxzZXtcbiAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHBsdWdpbnMsXG4gICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgICBmbnMgPSB7XG4gICAgICAgICAgICdvYmplY3QnOiBmdW5jdGlvbihwbGdzKXtcbiAgICAgICAgICAgICBwbGdzLmZvckVhY2goZnVuY3Rpb24ocCl7XG4gICAgICAgICAgICAgICBwID0gaHlwaGVuYXRlKHApO1xuICAgICAgICAgICAgICAgJCgnW2RhdGEtJysgcCArJ10nKS5mb3VuZGF0aW9uKCdfaW5pdCcpO1xuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICAnc3RyaW5nJzogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICBwbHVnaW5zID0gaHlwaGVuYXRlKHBsdWdpbnMpO1xuICAgICAgICAgICAgICQoJ1tkYXRhLScrIHBsdWdpbnMgKyddJykuZm91bmRhdGlvbignX2luaXQnKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgJ3VuZGVmaW5lZCc6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgdGhpc1snb2JqZWN0J10oT2JqZWN0LmtleXMoX3RoaXMuX3BsdWdpbnMpKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfTtcbiAgICAgICAgIGZuc1t0eXBlXShwbHVnaW5zKTtcbiAgICAgICB9XG4gICAgIH1jYXRjaChlcnIpe1xuICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgfWZpbmFsbHl7XG4gICAgICAgcmV0dXJuIHBsdWdpbnM7XG4gICAgIH1cbiAgIH0sXG5cbiAgLyoqXG4gICAqIHJldHVybnMgYSByYW5kb20gYmFzZS0zNiB1aWQgd2l0aCBuYW1lc3BhY2luZ1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIG51bWJlciBvZiByYW5kb20gYmFzZS0zNiBkaWdpdHMgZGVzaXJlZC4gSW5jcmVhc2UgZm9yIG1vcmUgcmFuZG9tIHN0cmluZ3MuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgLSBuYW1lIG9mIHBsdWdpbiB0byBiZSBpbmNvcnBvcmF0ZWQgaW4gdWlkLCBvcHRpb25hbC5cbiAgICogQGRlZmF1bHQge1N0cmluZ30gJycgLSBpZiBubyBwbHVnaW4gbmFtZSBpcyBwcm92aWRlZCwgbm90aGluZyBpcyBhcHBlbmRlZCB0byB0aGUgdWlkLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIHVuaXF1ZSBpZFxuICAgKi9cbiAgR2V0WW9EaWdpdHM6IGZ1bmN0aW9uKGxlbmd0aCwgbmFtZXNwYWNlKXtcbiAgICBsZW5ndGggPSBsZW5ndGggfHwgNjtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoTWF0aC5wb3coMzYsIGxlbmd0aCArIDEpIC0gTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDM2LCBsZW5ndGgpKSkudG9TdHJpbmcoMzYpLnNsaWNlKDEpICsgKG5hbWVzcGFjZSA/IGAtJHtuYW1lc3BhY2V9YCA6ICcnKTtcbiAgfSxcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgcGx1Z2lucyBvbiBhbnkgZWxlbWVudHMgd2l0aGluIGBlbGVtYCAoYW5kIGBlbGVtYCBpdHNlbGYpIHRoYXQgYXJlbid0IGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtIC0galF1ZXJ5IG9iamVjdCBjb250YWluaW5nIHRoZSBlbGVtZW50IHRvIGNoZWNrIGluc2lkZS4gQWxzbyBjaGVja3MgdGhlIGVsZW1lbnQgaXRzZWxmLCB1bmxlc3MgaXQncyB0aGUgYGRvY3VtZW50YCBvYmplY3QuXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwbHVnaW5zIC0gQSBsaXN0IG9mIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZS4gTGVhdmUgdGhpcyBvdXQgdG8gaW5pdGlhbGl6ZSBldmVyeXRoaW5nLlxuICAgKi9cbiAgcmVmbG93OiBmdW5jdGlvbihlbGVtLCBwbHVnaW5zKSB7XG5cbiAgICAvLyBJZiBwbHVnaW5zIGlzIHVuZGVmaW5lZCwganVzdCBncmFiIGV2ZXJ5dGhpbmdcbiAgICBpZiAodHlwZW9mIHBsdWdpbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwbHVnaW5zID0gT2JqZWN0LmtleXModGhpcy5fcGx1Z2lucyk7XG4gICAgfVxuICAgIC8vIElmIHBsdWdpbnMgaXMgYSBzdHJpbmcsIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBvbmUgaXRlbVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAnc3RyaW5nJykge1xuICAgICAgcGx1Z2lucyA9IFtwbHVnaW5zXTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcGx1Z2luXG4gICAgJC5lYWNoKHBsdWdpbnMsIGZ1bmN0aW9uKGksIG5hbWUpIHtcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBwbHVnaW5cbiAgICAgIHZhciBwbHVnaW4gPSBfdGhpcy5fcGx1Z2luc1tuYW1lXTtcblxuICAgICAgLy8gTG9jYWxpemUgdGhlIHNlYXJjaCB0byBhbGwgZWxlbWVudHMgaW5zaWRlIGVsZW0sIGFzIHdlbGwgYXMgZWxlbSBpdHNlbGYsIHVubGVzcyBlbGVtID09PSBkb2N1bWVudFxuICAgICAgdmFyICRlbGVtID0gJChlbGVtKS5maW5kKCdbZGF0YS0nK25hbWUrJ10nKS5hZGRCYWNrKCdbZGF0YS0nK25hbWUrJ10nKTtcblxuICAgICAgLy8gRm9yIGVhY2ggcGx1Z2luIGZvdW5kLCBpbml0aWFsaXplIGl0XG4gICAgICAkZWxlbS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgJGVsID0gJCh0aGlzKSxcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgLy8gRG9uJ3QgZG91YmxlLWRpcCBvbiBwbHVnaW5zXG4gICAgICAgIGlmICgkZWwuZGF0YSgnemZQbHVnaW4nKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRyaWVkIHRvIGluaXRpYWxpemUgXCIrbmFtZStcIiBvbiBhbiBlbGVtZW50IHRoYXQgYWxyZWFkeSBoYXMgYSBGb3VuZGF0aW9uIHBsdWdpbi5cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpKXtcbiAgICAgICAgICB2YXIgdGhpbmcgPSAkZWwuYXR0cignZGF0YS1vcHRpb25zJykuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uKGUsIGkpe1xuICAgICAgICAgICAgdmFyIG9wdCA9IGUuc3BsaXQoJzonKS5tYXAoZnVuY3Rpb24oZWwpeyByZXR1cm4gZWwudHJpbSgpOyB9KTtcbiAgICAgICAgICAgIGlmKG9wdFswXSkgb3B0c1tvcHRbMF1dID0gcGFyc2VWYWx1ZShvcHRbMV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeXtcbiAgICAgICAgICAkZWwuZGF0YSgnemZQbHVnaW4nLCBuZXcgcGx1Z2luKCQodGhpcyksIG9wdHMpKTtcbiAgICAgICAgfWNhdGNoKGVyKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVyKTtcbiAgICAgICAgfWZpbmFsbHl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgZ2V0Rm5OYW1lOiBmdW5jdGlvbk5hbWUsXG4gIHRyYW5zaXRpb25lbmQ6IGZ1bmN0aW9uKCRlbGVtKXtcbiAgICB2YXIgdHJhbnNpdGlvbnMgPSB7XG4gICAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgICdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICAgJ01velRyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICAnT1RyYW5zaXRpb24nOiAnb3RyYW5zaXRpb25lbmQnXG4gICAgfTtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICBlbmQ7XG5cbiAgICBmb3IgKHZhciB0IGluIHRyYW5zaXRpb25zKXtcbiAgICAgIGlmICh0eXBlb2YgZWxlbS5zdHlsZVt0XSAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICBlbmQgPSB0cmFuc2l0aW9uc1t0XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoZW5kKXtcbiAgICAgIHJldHVybiBlbmQ7XG4gICAgfWVsc2V7XG4gICAgICBlbmQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICRlbGVtLnRyaWdnZXJIYW5kbGVyKCd0cmFuc2l0aW9uZW5kJywgWyRlbGVtXSk7XG4gICAgICB9LCAxKTtcbiAgICAgIHJldHVybiAndHJhbnNpdGlvbmVuZCc7XG4gICAgfVxuICB9XG59O1xuXG5Gb3VuZGF0aW9uLnV0aWwgPSB7XG4gIC8qKlxuICAgKiBGdW5jdGlvbiBmb3IgYXBwbHlpbmcgYSBkZWJvdW5jZSBlZmZlY3QgdG8gYSBmdW5jdGlvbiBjYWxsLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhdCBlbmQgb2YgdGltZW91dC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IC0gVGltZSBpbiBtcyB0byBkZWxheSB0aGUgY2FsbCBvZiBgZnVuY2AuXG4gICAqIEByZXR1cm5zIGZ1bmN0aW9uXG4gICAqL1xuICB0aHJvdHRsZTogZnVuY3Rpb24gKGZ1bmMsIGRlbGF5KSB7XG4gICAgdmFyIHRpbWVyID0gbnVsbDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgIGlmICh0aW1lciA9PT0gbnVsbCkge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLy8gVE9ETzogY29uc2lkZXIgbm90IG1ha2luZyB0aGlzIGEgalF1ZXJ5IGZ1bmN0aW9uXG4vLyBUT0RPOiBuZWVkIHdheSB0byByZWZsb3cgdnMuIHJlLWluaXRpYWxpemVcbi8qKlxuICogVGhlIEZvdW5kYXRpb24galF1ZXJ5IG1ldGhvZC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBtZXRob2QgLSBBbiBhY3Rpb24gdG8gcGVyZm9ybSBvbiB0aGUgY3VycmVudCBqUXVlcnkgb2JqZWN0LlxuICovXG52YXIgZm91bmRhdGlvbiA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBtZXRob2QsXG4gICAgICAkbWV0YSA9ICQoJ21ldGEuZm91bmRhdGlvbi1tcScpLFxuICAgICAgJG5vSlMgPSAkKCcubm8tanMnKTtcblxuICBpZighJG1ldGEubGVuZ3RoKXtcbiAgICAkKCc8bWV0YSBjbGFzcz1cImZvdW5kYXRpb24tbXFcIj4nKS5hcHBlbmRUbyhkb2N1bWVudC5oZWFkKTtcbiAgfVxuICBpZigkbm9KUy5sZW5ndGgpe1xuICAgICRub0pTLnJlbW92ZUNsYXNzKCduby1qcycpO1xuICB9XG5cbiAgaWYodHlwZSA9PT0gJ3VuZGVmaW5lZCcpey8vbmVlZHMgdG8gaW5pdGlhbGl6ZSB0aGUgRm91bmRhdGlvbiBvYmplY3QsIG9yIGFuIGluZGl2aWR1YWwgcGx1Z2luLlxuICAgIEZvdW5kYXRpb24uTWVkaWFRdWVyeS5faW5pdCgpO1xuICAgIEZvdW5kYXRpb24ucmVmbG93KHRoaXMpO1xuICB9ZWxzZSBpZih0eXBlID09PSAnc3RyaW5nJyl7Ly9hbiBpbmRpdmlkdWFsIG1ldGhvZCB0byBpbnZva2Ugb24gYSBwbHVnaW4gb3IgZ3JvdXAgb2YgcGx1Z2luc1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsvL2NvbGxlY3QgYWxsIHRoZSBhcmd1bWVudHMsIGlmIG5lY2Vzc2FyeVxuICAgIHZhciBwbHVnQ2xhc3MgPSB0aGlzLmRhdGEoJ3pmUGx1Z2luJyk7Ly9kZXRlcm1pbmUgdGhlIGNsYXNzIG9mIHBsdWdpblxuXG4gICAgaWYocGx1Z0NsYXNzICE9PSB1bmRlZmluZWQgJiYgcGx1Z0NsYXNzW21ldGhvZF0gIT09IHVuZGVmaW5lZCl7Ly9tYWtlIHN1cmUgYm90aCB0aGUgY2xhc3MgYW5kIG1ldGhvZCBleGlzdFxuICAgICAgaWYodGhpcy5sZW5ndGggPT09IDEpey8vaWYgdGhlcmUncyBvbmx5IG9uZSwgY2FsbCBpdCBkaXJlY3RseS5cbiAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseShwbHVnQ2xhc3MsIGFyZ3MpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpLCBlbCl7Ly9vdGhlcndpc2UgbG9vcCB0aHJvdWdoIHRoZSBqUXVlcnkgY29sbGVjdGlvbiBhbmQgaW52b2tlIHRoZSBtZXRob2Qgb24gZWFjaFxuICAgICAgICAgIHBsdWdDbGFzc1ttZXRob2RdLmFwcGx5KCQoZWwpLmRhdGEoJ3pmUGx1Z2luJyksIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9ZWxzZXsvL2Vycm9yIGZvciBubyBjbGFzcyBvciBubyBtZXRob2RcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIldlJ3JlIHNvcnJ5LCAnXCIgKyBtZXRob2QgKyBcIicgaXMgbm90IGFuIGF2YWlsYWJsZSBtZXRob2QgZm9yIFwiICsgKHBsdWdDbGFzcyA/IGZ1bmN0aW9uTmFtZShwbHVnQ2xhc3MpIDogJ3RoaXMgZWxlbWVudCcpICsgJy4nKTtcbiAgICB9XG4gIH1lbHNley8vZXJyb3IgZm9yIGludmFsaWQgYXJndW1lbnQgdHlwZVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdlJ3JlIHNvcnJ5LCAke3R5cGV9IGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlci4gWW91IG11c3QgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWV0aG9kIHlvdSB3aXNoIHRvIGludm9rZS5gKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbndpbmRvdy5Gb3VuZGF0aW9uID0gRm91bmRhdGlvbjtcbiQuZm4uZm91bmRhdGlvbiA9IGZvdW5kYXRpb247XG5cbi8vIFBvbHlmaWxsIGZvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbihmdW5jdGlvbigpIHtcbiAgaWYgKCFEYXRlLm5vdyB8fCAhd2luZG93LkRhdGUubm93KVxuICAgIHdpbmRvdy5EYXRlLm5vdyA9IERhdGUubm93ID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuICB2YXIgdmVuZG9ycyA9IFsnd2Via2l0JywgJ21veiddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK2kpIHtcbiAgICAgIHZhciB2cCA9IHZlbmRvcnNbaV07XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZwKydSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9ICh3aW5kb3dbdnArJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvd1t2cCsnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10pO1xuICB9XG4gIGlmICgvaVAoYWR8aG9uZXxvZCkuKk9TIDYvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgfHwgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgbmV4dFRpbWUgPSBNYXRoLm1heChsYXN0VGltZSArIDE2LCBub3cpO1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2sobGFzdFRpbWUgPSBuZXh0VGltZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRUaW1lIC0gbm93KTtcbiAgICB9O1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dDtcbiAgfVxuICAvKipcbiAgICogUG9seWZpbGwgZm9yIHBlcmZvcm1hbmNlLm5vdywgcmVxdWlyZWQgYnkgckFGXG4gICAqL1xuICBpZighd2luZG93LnBlcmZvcm1hbmNlIHx8ICF3aW5kb3cucGVyZm9ybWFuY2Uubm93KXtcbiAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7XG4gICAgICBzdGFydDogRGF0ZS5ub3coKSxcbiAgICAgIG5vdzogZnVuY3Rpb24oKXsgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnN0YXJ0OyB9XG4gICAgfTtcbiAgfVxufSkoKTtcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihvVGhpcykge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XG4gICAgICAvLyBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xuICAgIH1cblxuICAgIHZhciBhQXJncyAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgIGZOT1AgICAgPSBmdW5jdGlvbigpIHt9LFxuICAgICAgICBmQm91bmQgID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1BcbiAgICAgICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICAgICAgIDogb1RoaXMsXG4gICAgICAgICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG5cbiAgICBpZiAodGhpcy5wcm90b3R5cGUpIHtcbiAgICAgIC8vIG5hdGl2ZSBmdW5jdGlvbnMgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZVxuICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICB9XG4gICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICByZXR1cm4gZkJvdW5kO1xuICB9O1xufVxuLy8gUG9seWZpbGwgdG8gZ2V0IHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gaW4gSUU5XG5mdW5jdGlvbiBmdW5jdGlvbk5hbWUoZm4pIHtcbiAgaWYgKEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvblxccyhbXihdezEsfSlcXCgvO1xuICAgIHZhciByZXN1bHRzID0gKGZ1bmNOYW1lUmVnZXgpLmV4ZWMoKGZuKS50b1N0cmluZygpKTtcbiAgICByZXR1cm4gKHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGggPiAxKSA/IHJlc3VsdHNbMV0udHJpbSgpIDogXCJcIjtcbiAgfVxuICBlbHNlIGlmIChmbi5wcm90b3R5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmbi5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmbi5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZShzdHIpe1xuICBpZigvdHJ1ZS8udGVzdChzdHIpKSByZXR1cm4gdHJ1ZTtcbiAgZWxzZSBpZigvZmFsc2UvLnRlc3Qoc3RyKSkgcmV0dXJuIGZhbHNlO1xuICBlbHNlIGlmKCFpc05hTihzdHIgKiAxKSkgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cbi8vIENvbnZlcnQgUGFzY2FsQ2FzZSB0byBrZWJhYi1jYXNlXG4vLyBUaGFuayB5b3U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg5NTU1ODBcbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufVxuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbkZvdW5kYXRpb24uQm94ID0ge1xuICBJbU5vdFRvdWNoaW5nWW91OiBJbU5vdFRvdWNoaW5nWW91LFxuICBHZXREaW1lbnNpb25zOiBHZXREaW1lbnNpb25zLFxuICBHZXRPZmZzZXRzOiBHZXRPZmZzZXRzXG59XG5cbi8qKlxuICogQ29tcGFyZXMgdGhlIGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudCB0byBhIGNvbnRhaW5lciBhbmQgZGV0ZXJtaW5lcyBjb2xsaXNpb24gZXZlbnRzIHdpdGggY29udGFpbmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdGVzdCBmb3IgY29sbGlzaW9ucy5cbiAqIEBwYXJhbSB7alF1ZXJ5fSBwYXJlbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHVzZSBhcyBib3VuZGluZyBjb250YWluZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGxyT25seSAtIHNldCB0byB0cnVlIHRvIGNoZWNrIGxlZnQgYW5kIHJpZ2h0IHZhbHVlcyBvbmx5LlxuICogQHBhcmFtIHtCb29sZWFufSB0Yk9ubHkgLSBzZXQgdG8gdHJ1ZSB0byBjaGVjayB0b3AgYW5kIGJvdHRvbSB2YWx1ZXMgb25seS5cbiAqIEBkZWZhdWx0IGlmIG5vIHBhcmVudCBvYmplY3QgcGFzc2VkLCBkZXRlY3RzIGNvbGxpc2lvbnMgd2l0aCBgd2luZG93YC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgY29sbGlzaW9uIGZyZWUsIGZhbHNlIGlmIGEgY29sbGlzaW9uIGluIGFueSBkaXJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIEltTm90VG91Y2hpbmdZb3UoZWxlbWVudCwgcGFyZW50LCBsck9ubHksIHRiT25seSkge1xuICB2YXIgZWxlRGltcyA9IEdldERpbWVuc2lvbnMoZWxlbWVudCksXG4gICAgICB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQ7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHZhciBwYXJEaW1zID0gR2V0RGltZW5zaW9ucyhwYXJlbnQpO1xuXG4gICAgYm90dG9tID0gKGVsZURpbXMub2Zmc2V0LnRvcCArIGVsZURpbXMuaGVpZ2h0IDw9IHBhckRpbXMuaGVpZ2h0ICsgcGFyRGltcy5vZmZzZXQudG9wKTtcbiAgICB0b3AgICAgPSAoZWxlRGltcy5vZmZzZXQudG9wID49IHBhckRpbXMub2Zmc2V0LnRvcCk7XG4gICAgbGVmdCAgID0gKGVsZURpbXMub2Zmc2V0LmxlZnQgPj0gcGFyRGltcy5vZmZzZXQubGVmdCk7XG4gICAgcmlnaHQgID0gKGVsZURpbXMub2Zmc2V0LmxlZnQgKyBlbGVEaW1zLndpZHRoIDw9IHBhckRpbXMud2lkdGgpO1xuICB9XG4gIGVsc2Uge1xuICAgIGJvdHRvbSA9IChlbGVEaW1zLm9mZnNldC50b3AgKyBlbGVEaW1zLmhlaWdodCA8PSBlbGVEaW1zLndpbmRvd0RpbXMuaGVpZ2h0ICsgZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3ApO1xuICAgIHRvcCAgICA9IChlbGVEaW1zLm9mZnNldC50b3AgPj0gZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3ApO1xuICAgIGxlZnQgICA9IChlbGVEaW1zLm9mZnNldC5sZWZ0ID49IGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCk7XG4gICAgcmlnaHQgID0gKGVsZURpbXMub2Zmc2V0LmxlZnQgKyBlbGVEaW1zLndpZHRoIDw9IGVsZURpbXMud2luZG93RGltcy53aWR0aCk7XG4gIH1cblxuICB2YXIgYWxsRGlycyA9IFtib3R0b20sIHRvcCwgbGVmdCwgcmlnaHRdO1xuXG4gIGlmIChsck9ubHkpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgPT09IHRydWU7XG4gIH1cblxuICBpZiAodGJPbmx5KSB7XG4gICAgcmV0dXJuIHRvcCA9PT0gYm90dG9tID09PSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGFsbERpcnMuaW5kZXhPZihmYWxzZSkgPT09IC0xO1xufTtcblxuLyoqXG4gKiBVc2VzIG5hdGl2ZSBtZXRob2RzIHRvIHJldHVybiBhbiBvYmplY3Qgb2YgZGltZW5zaW9uIHZhbHVlcy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtqUXVlcnkgfHwgSFRNTH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3Qgb3IgRE9NIGVsZW1lbnQgZm9yIHdoaWNoIHRvIGdldCB0aGUgZGltZW5zaW9ucy4gQ2FuIGJlIGFueSBlbGVtZW50IG90aGVyIHRoYXQgZG9jdW1lbnQgb3Igd2luZG93LlxuICogQHJldHVybnMge09iamVjdH0gLSBuZXN0ZWQgb2JqZWN0IG9mIGludGVnZXIgcGl4ZWwgdmFsdWVzXG4gKiBUT0RPIC0gaWYgZWxlbWVudCBpcyB3aW5kb3csIHJldHVybiBvbmx5IHRob3NlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gR2V0RGltZW5zaW9ucyhlbGVtLCB0ZXN0KXtcbiAgZWxlbSA9IGVsZW0ubGVuZ3RoID8gZWxlbVswXSA6IGVsZW07XG5cbiAgaWYgKGVsZW0gPT09IHdpbmRvdyB8fCBlbGVtID09PSBkb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkknbSBzb3JyeSwgRGF2ZS4gSSdtIGFmcmFpZCBJIGNhbid0IGRvIHRoYXQuXCIpO1xuICB9XG5cbiAgdmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgcGFyUmVjdCA9IGVsZW0ucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHdpblJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgd2luWSA9IHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgIHdpblggPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIG9mZnNldDoge1xuICAgICAgdG9wOiByZWN0LnRvcCArIHdpblksXG4gICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5YXG4gICAgfSxcbiAgICBwYXJlbnREaW1zOiB7XG4gICAgICB3aWR0aDogcGFyUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogcGFyUmVjdC5oZWlnaHQsXG4gICAgICBvZmZzZXQ6IHtcbiAgICAgICAgdG9wOiBwYXJSZWN0LnRvcCArIHdpblksXG4gICAgICAgIGxlZnQ6IHBhclJlY3QubGVmdCArIHdpblhcbiAgICAgIH1cbiAgICB9LFxuICAgIHdpbmRvd0RpbXM6IHtcbiAgICAgIHdpZHRoOiB3aW5SZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5SZWN0LmhlaWdodCxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICB0b3A6IHdpblksXG4gICAgICAgIGxlZnQ6IHdpblhcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB0b3AgYW5kIGxlZnQgaW50ZWdlciBwaXhlbCB2YWx1ZXMgZm9yIGR5bmFtaWNhbGx5IHJlbmRlcmVkIGVsZW1lbnRzLFxuICogc3VjaCBhczogVG9vbHRpcCwgUmV2ZWFsLCBhbmQgRHJvcGRvd25cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IGZvciB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxuICogQHBhcmFtIHtqUXVlcnl9IGFuY2hvciAtIGpRdWVyeSBvYmplY3QgZm9yIHRoZSBlbGVtZW50J3MgYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uIC0gYSBzdHJpbmcgcmVsYXRpbmcgdG8gdGhlIGRlc2lyZWQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQsIHJlbGF0aXZlIHRvIGl0J3MgYW5jaG9yXG4gKiBAcGFyYW0ge051bWJlcn0gdk9mZnNldCAtIGludGVnZXIgcGl4ZWwgdmFsdWUgb2YgZGVzaXJlZCB2ZXJ0aWNhbCBzZXBhcmF0aW9uIGJldHdlZW4gYW5jaG9yIGFuZCBlbGVtZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IGhPZmZzZXQgLSBpbnRlZ2VyIHBpeGVsIHZhbHVlIG9mIGRlc2lyZWQgaG9yaXpvbnRhbCBzZXBhcmF0aW9uIGJldHdlZW4gYW5jaG9yIGFuZCBlbGVtZW50LlxuICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJmbG93IC0gaWYgYSBjb2xsaXNpb24gZXZlbnQgaXMgZGV0ZWN0ZWQsIHNldHMgdG8gdHJ1ZSB0byBkZWZhdWx0IHRoZSBlbGVtZW50IHRvIGZ1bGwgd2lkdGggLSBhbnkgZGVzaXJlZCBvZmZzZXQuXG4gKiBUT0RPIGFsdGVyL3Jld3JpdGUgdG8gd29yayB3aXRoIGBlbWAgdmFsdWVzIGFzIHdlbGwvaW5zdGVhZCBvZiBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gR2V0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsIHBvc2l0aW9uLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KSB7XG4gIHZhciAkZWxlRGltcyA9IEdldERpbWVuc2lvbnMoZWxlbWVudCksXG4gICAgICAkYW5jaG9yRGltcyA9IGFuY2hvciA/IEdldERpbWVuc2lvbnMoYW5jaG9yKSA6IG51bGw7XG5cbiAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAoRm91bmRhdGlvbi5ydGwoKSA/ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gJGVsZURpbXMud2lkdGggKyAkYW5jaG9yRGltcy53aWR0aCA6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0KSxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gKCRlbGVEaW1zLndpZHRoICsgaE9mZnNldCksXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcFxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAkYW5jaG9yRGltcy53aWR0aCArIGhPZmZzZXQsXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcFxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2VudGVyIHRvcCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAoJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAoJGFuY2hvckRpbXMud2lkdGggLyAyKSkgLSAoJGVsZURpbXMud2lkdGggLyAyKSxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXIgYm90dG9tJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGlzT3ZlcmZsb3cgPyBoT2Zmc2V0IDogKCgkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICgkYW5jaG9yRGltcy53aWR0aCAvIDIpKSAtICgkZWxlRGltcy53aWR0aCAvIDIpKSxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgJGFuY2hvckRpbXMuaGVpZ2h0ICsgdk9mZnNldFxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2VudGVyIGxlZnQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAoJGVsZURpbXMud2lkdGggKyBoT2Zmc2V0KSxcbiAgICAgICAgdG9wOiAoJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICgkYW5jaG9yRGltcy5oZWlnaHQgLyAyKSkgLSAoJGVsZURpbXMuaGVpZ2h0IC8gMilcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NlbnRlciByaWdodCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoICsgaE9mZnNldCArIDEsXG4gICAgICAgIHRvcDogKCRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAoJGFuY2hvckRpbXMuaGVpZ2h0IC8gMikpIC0gKCRlbGVEaW1zLmhlaWdodCAvIDIpXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogKCRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQgKyAoJGVsZURpbXMud2luZG93RGltcy53aWR0aCAvIDIpKSAtICgkZWxlRGltcy53aWR0aCAvIDIpLFxuICAgICAgICB0b3A6ICgkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3AgKyAoJGVsZURpbXMud2luZG93RGltcy5oZWlnaHQgLyAyKSkgLSAoJGVsZURpbXMuaGVpZ2h0IC8gMilcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JldmVhbCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAoJGVsZURpbXMud2luZG93RGltcy53aWR0aCAtICRlbGVEaW1zLndpZHRoKSAvIDIsXG4gICAgICAgIHRvcDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wICsgdk9mZnNldFxuICAgICAgfVxuICAgIGNhc2UgJ3JldmVhbCBmdWxsJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQsXG4gICAgICAgIHRvcDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0IGJvdHRvbSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICgkZWxlRGltcy53aWR0aCArIGhPZmZzZXQpLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAkYW5jaG9yRGltcy53aWR0aCArIGhPZmZzZXQgLSAkZWxlRGltcy53aWR0aCxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgJGFuY2hvckRpbXMuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IChGb3VuZGF0aW9uLnJ0bCgpID8gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAkZWxlRGltcy53aWR0aCArICRhbmNob3JEaW1zLndpZHRoIDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQpLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgKyB2T2Zmc2V0XG4gICAgICB9XG4gIH1cbn1cblxufShqUXVlcnkpO1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBUaGlzIHV0aWwgd2FzIGNyZWF0ZWQgYnkgTWFyaXVzIE9sYmVydHogKlxuICogUGxlYXNlIHRoYW5rIE1hcml1cyBvbiBHaXRIdWIgL293bGJlcnR6ICpcbiAqIG9yIHRoZSB3ZWIgaHR0cDovL3d3dy5tYXJpdXNvbGJlcnR6LmRlLyAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG5jb25zdCBrZXlDb2RlcyA9IHtcbiAgOTogJ1RBQicsXG4gIDEzOiAnRU5URVInLFxuICAyNzogJ0VTQ0FQRScsXG4gIDMyOiAnU1BBQ0UnLFxuICAzNzogJ0FSUk9XX0xFRlQnLFxuICAzODogJ0FSUk9XX1VQJyxcbiAgMzk6ICdBUlJPV19SSUdIVCcsXG4gIDQwOiAnQVJST1dfRE9XTidcbn1cblxudmFyIGNvbW1hbmRzID0ge31cblxudmFyIEtleWJvYXJkID0ge1xuICBrZXlzOiBnZXRLZXlDb2RlcyhrZXlDb2RlcyksXG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgKGtleWJvYXJkKSBldmVudCBhbmQgcmV0dXJucyBhIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgaXRzIGtleVxuICAgKiBDYW4gYmUgdXNlZCBsaWtlIEZvdW5kYXRpb24ucGFyc2VLZXkoZXZlbnQpID09PSBGb3VuZGF0aW9uLmtleXMuU1BBQ0VcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXG4gICAqIEByZXR1cm4gU3RyaW5nIGtleSAtIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGtleSBwcmVzc2VkXG4gICAqL1xuICBwYXJzZUtleShldmVudCkge1xuICAgIHZhciBrZXkgPSBrZXlDb2Rlc1tldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlXSB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LndoaWNoKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChldmVudC5zaGlmdEtleSkga2V5ID0gYFNISUZUXyR7a2V5fWA7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIGtleSA9IGBDVFJMXyR7a2V5fWA7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkga2V5ID0gYEFMVF8ke2tleX1gO1xuICAgIHJldHVybiBrZXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIChrZXlib2FyZCkgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgLSBGb3VuZGF0aW9uIGNvbXBvbmVudCdzIG5hbWUsIGUuZy4gU2xpZGVyIG9yIFJldmVhbFxuICAgKiBAcGFyYW0ge09iamVjdHN9IGZ1bmN0aW9ucyAtIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHRoYXQgYXJlIHRvIGJlIGV4ZWN1dGVkXG4gICAqL1xuICBoYW5kbGVLZXkoZXZlbnQsIGNvbXBvbmVudCwgZnVuY3Rpb25zKSB7XG4gICAgdmFyIGNvbW1hbmRMaXN0ID0gY29tbWFuZHNbY29tcG9uZW50XSxcbiAgICAgIGtleUNvZGUgPSB0aGlzLnBhcnNlS2V5KGV2ZW50KSxcbiAgICAgIGNtZHMsXG4gICAgICBjb21tYW5kLFxuICAgICAgZm47XG5cbiAgICBpZiAoIWNvbW1hbmRMaXN0KSByZXR1cm4gY29uc29sZS53YXJuKCdDb21wb25lbnQgbm90IGRlZmluZWQhJyk7XG5cbiAgICBpZiAodHlwZW9mIGNvbW1hbmRMaXN0Lmx0ciA9PT0gJ3VuZGVmaW5lZCcpIHsgLy8gdGhpcyBjb21wb25lbnQgZG9lcyBub3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGx0ciBhbmQgcnRsXG4gICAgICAgIGNtZHMgPSBjb21tYW5kTGlzdDsgLy8gdXNlIHBsYWluIGxpc3RcbiAgICB9IGVsc2UgeyAvLyBtZXJnZSBsdHIgYW5kIHJ0bDogaWYgZG9jdW1lbnQgaXMgcnRsLCBydGwgb3ZlcndyaXRlcyBsdHIgYW5kIHZpY2UgdmVyc2FcbiAgICAgICAgaWYgKEZvdW5kYXRpb24ucnRsKCkpIGNtZHMgPSAkLmV4dGVuZCh7fSwgY29tbWFuZExpc3QubHRyLCBjb21tYW5kTGlzdC5ydGwpO1xuXG4gICAgICAgIGVsc2UgY21kcyA9ICQuZXh0ZW5kKHt9LCBjb21tYW5kTGlzdC5ydGwsIGNvbW1hbmRMaXN0Lmx0cik7XG4gICAgfVxuICAgIGNvbW1hbmQgPSBjbWRzW2tleUNvZGVdO1xuXG4gICAgZm4gPSBmdW5jdGlvbnNbY29tbWFuZF07XG4gICAgaWYgKGZuICYmIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBleGVjdXRlIGZ1bmN0aW9uICBpZiBleGlzdHNcbiAgICAgIGZuLmFwcGx5KCk7XG4gICAgICBpZiAoZnVuY3Rpb25zLmhhbmRsZWQgfHwgdHlwZW9mIGZ1bmN0aW9ucy5oYW5kbGVkID09PSAnZnVuY3Rpb24nKSB7IC8vIGV4ZWN1dGUgZnVuY3Rpb24gd2hlbiBldmVudCB3YXMgaGFuZGxlZFxuICAgICAgICAgIGZ1bmN0aW9ucy5oYW5kbGVkLmFwcGx5KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmdW5jdGlvbnMudW5oYW5kbGVkIHx8IHR5cGVvZiBmdW5jdGlvbnMudW5oYW5kbGVkID09PSAnZnVuY3Rpb24nKSB7IC8vIGV4ZWN1dGUgZnVuY3Rpb24gd2hlbiBldmVudCB3YXMgbm90IGhhbmRsZWRcbiAgICAgICAgICBmdW5jdGlvbnMudW5oYW5kbGVkLmFwcGx5KCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGhpbiB0aGUgZ2l2ZW4gYCRlbGVtZW50YFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHNlYXJjaCB3aXRoaW5cbiAgICogQHJldHVybiB7alF1ZXJ5fSAkZm9jdXNhYmxlIC0gYWxsIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoaW4gYCRlbGVtZW50YFxuICAgKi9cbiAgZmluZEZvY3VzYWJsZSgkZWxlbWVudCkge1xuICAgIHJldHVybiAkZWxlbWVudC5maW5kKCdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XSwgKltjb250ZW50ZWRpdGFibGVdJykuZmlsdGVyKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCEkKHRoaXMpLmlzKCc6dmlzaWJsZScpIHx8ICQodGhpcykuYXR0cigndGFiaW5kZXgnKSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9IC8vb25seSBoYXZlIHZpc2libGUgZWxlbWVudHMgYW5kIHRob3NlIHRoYXQgaGF2ZSBhIHRhYmluZGV4IGdyZWF0ZXIgb3IgZXF1YWwgMFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbXBvbmVudCBuYW1lIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCAtIEZvdW5kYXRpb24gY29tcG9uZW50LCBlLmcuIFNsaWRlciBvciBSZXZlYWxcbiAgICogQHJldHVybiBTdHJpbmcgY29tcG9uZW50TmFtZVxuICAgKi9cblxuICByZWdpc3Rlcihjb21wb25lbnROYW1lLCBjbWRzKSB7XG4gICAgY29tbWFuZHNbY29tcG9uZW50TmFtZV0gPSBjbWRzO1xuICB9XG59XG5cbi8qXG4gKiBDb25zdGFudHMgZm9yIGVhc2llciBjb21wYXJpbmcuXG4gKiBDYW4gYmUgdXNlZCBsaWtlIEZvdW5kYXRpb24ucGFyc2VLZXkoZXZlbnQpID09PSBGb3VuZGF0aW9uLmtleXMuU1BBQ0VcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5Q29kZXMoa2NzKSB7XG4gIHZhciBrID0ge307XG4gIGZvciAodmFyIGtjIGluIGtjcykga1trY3Nba2NdXSA9IGtjc1trY107XG4gIHJldHVybiBrO1xufVxuXG5Gb3VuZGF0aW9uLktleWJvYXJkID0gS2V5Ym9hcmQ7XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuLy8gRGVmYXVsdCBzZXQgb2YgbWVkaWEgcXVlcmllc1xuY29uc3QgZGVmYXVsdFF1ZXJpZXMgPSB7XG4gICdkZWZhdWx0JyA6ICdvbmx5IHNjcmVlbicsXG4gIGxhbmRzY2FwZSA6ICdvbmx5IHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpJyxcbiAgcG9ydHJhaXQgOiAnb25seSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpJyxcbiAgcmV0aW5hIDogJ29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCcgK1xuICAgICdvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIvMSksJyArXG4gICAgJ29ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksJyArXG4gICAgJ29ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE5MmRwaSksJyArXG4gICAgJ29ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDJkcHB4KSdcbn07XG5cbnZhciBNZWRpYVF1ZXJ5ID0ge1xuICBxdWVyaWVzOiBbXSxcblxuICBjdXJyZW50OiAnJyxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1lZGlhIHF1ZXJ5IGhlbHBlciwgYnkgZXh0cmFjdGluZyB0aGUgYnJlYWtwb2ludCBsaXN0IGZyb20gdGhlIENTUyBhbmQgYWN0aXZhdGluZyB0aGUgYnJlYWtwb2ludCB3YXRjaGVyLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZXh0cmFjdGVkU3R5bGVzID0gJCgnLmZvdW5kYXRpb24tbXEnKS5jc3MoJ2ZvbnQtZmFtaWx5Jyk7XG4gICAgdmFyIG5hbWVkUXVlcmllcztcblxuICAgIG5hbWVkUXVlcmllcyA9IHBhcnNlU3R5bGVUb09iamVjdChleHRyYWN0ZWRTdHlsZXMpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG5hbWVkUXVlcmllcykge1xuICAgICAgc2VsZi5xdWVyaWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIHZhbHVlOiBgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6ICR7bmFtZWRRdWVyaWVzW2tleV19KWBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuX2dldEN1cnJlbnRTaXplKCk7XG5cbiAgICB0aGlzLl93YXRjaGVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc2NyZWVuIGlzIGF0IGxlYXN0IGFzIHdpZGUgYXMgYSBicmVha3BvaW50LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBicmVha3BvaW50IG1hdGNoZXMsIGBmYWxzZWAgaWYgaXQncyBzbWFsbGVyLlxuICAgKi9cbiAgYXRMZWFzdChzaXplKSB7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpcy5nZXQoc2l6ZSk7XG5cbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYShxdWVyeSkubWF0Y2hlcztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1lZGlhIHF1ZXJ5IG9mIGEgYnJlYWtwb2ludC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gLSBUaGUgbWVkaWEgcXVlcnkgb2YgdGhlIGJyZWFrcG9pbnQsIG9yIGBudWxsYCBpZiB0aGUgYnJlYWtwb2ludCBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZ2V0KHNpemUpIHtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMucXVlcmllcykge1xuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xuICAgICAgaWYgKHNpemUgPT09IHF1ZXJ5Lm5hbWUpIHJldHVybiBxdWVyeS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBicmVha3BvaW50IG5hbWUgYnkgdGVzdGluZyBldmVyeSBicmVha3BvaW50IGFuZCByZXR1cm5pbmcgdGhlIGxhc3Qgb25lIHRvIG1hdGNoICh0aGUgYmlnZ2VzdCBvbmUpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge1N0cmluZ30gTmFtZSBvZiB0aGUgY3VycmVudCBicmVha3BvaW50LlxuICAgKi9cbiAgX2dldEN1cnJlbnRTaXplKCkge1xuICAgIHZhciBtYXRjaGVkO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnF1ZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcmllc1tpXTtcblxuICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5LnZhbHVlKS5tYXRjaGVzKSB7XG4gICAgICAgIG1hdGNoZWQgPSBxdWVyeTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG1hdGNoZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlZC5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgYnJlYWtwb2ludCB3YXRjaGVyLCB3aGljaCBmaXJlcyBhbiBldmVudCBvbiB0aGUgd2luZG93IHdoZW5ldmVyIHRoZSBicmVha3BvaW50IGNoYW5nZXMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3dhdGNoZXIoKSB7XG4gICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuemYubWVkaWFxdWVyeScsICgpID0+IHtcbiAgICAgIHZhciBuZXdTaXplID0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKTtcblxuICAgICAgaWYgKG5ld1NpemUgIT09IHRoaXMuY3VycmVudCkge1xuICAgICAgICAvLyBCcm9hZGNhc3QgdGhlIG1lZGlhIHF1ZXJ5IGNoYW5nZSBvbiB0aGUgd2luZG93XG4gICAgICAgICQod2luZG93KS50cmlnZ2VyKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBbbmV3U2l6ZSwgdGhpcy5jdXJyZW50XSk7XG5cbiAgICAgICAgLy8gQ2hhbmdlIHRoZSBjdXJyZW50IG1lZGlhIHF1ZXJ5XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5ld1NpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbkZvdW5kYXRpb24uTWVkaWFRdWVyeSA9IE1lZGlhUXVlcnk7XG5cbi8vIG1hdGNoTWVkaWEoKSBwb2x5ZmlsbCAtIFRlc3QgYSBDU1MgbWVkaWEgdHlwZS9xdWVyeSBpbiBKUy5cbi8vIEF1dGhvcnMgJiBjb3B5cmlnaHQgKGMpIDIwMTI6IFNjb3R0IEplaGwsIFBhdWwgSXJpc2gsIE5pY2hvbGFzIFpha2FzLCBEYXZpZCBLbmlnaHQuIER1YWwgTUlUL0JTRCBsaWNlbnNlXG53aW5kb3cubWF0Y2hNZWRpYSB8fCAod2luZG93Lm1hdGNoTWVkaWEgPSBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgbWF0Y2hNZWRpdW0gYXBpIHN1Y2ggYXMgSUUgOSBhbmQgd2Via2l0XG4gIHZhciBzdHlsZU1lZGlhID0gKHdpbmRvdy5zdHlsZU1lZGlhIHx8IHdpbmRvdy5tZWRpYSk7XG5cbiAgLy8gRm9yIHRob3NlIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtYXRjaE1lZGl1bVxuICBpZiAoIXN0eWxlTWVkaWEpIHtcbiAgICB2YXIgc3R5bGUgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksXG4gICAgc2NyaXB0ICAgICAgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF0sXG4gICAgaW5mbyAgICAgICAgPSBudWxsO1xuXG4gICAgc3R5bGUudHlwZSAgPSAndGV4dC9jc3MnO1xuICAgIHN0eWxlLmlkICAgID0gJ21hdGNobWVkaWFqcy10ZXN0JztcblxuICAgIHNjcmlwdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZSwgc2NyaXB0KTtcblxuICAgIC8vICdzdHlsZS5jdXJyZW50U3R5bGUnIGlzIHVzZWQgYnkgSUUgPD0gOCBhbmQgJ3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlJyBmb3IgYWxsIG90aGVyIGJyb3dzZXJzXG4gICAgaW5mbyA9ICgnZ2V0Q29tcHV0ZWRTdHlsZScgaW4gd2luZG93KSAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSwgbnVsbCkgfHwgc3R5bGUuY3VycmVudFN0eWxlO1xuXG4gICAgc3R5bGVNZWRpYSA9IHtcbiAgICAgIG1hdGNoTWVkaXVtKG1lZGlhKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gYEBtZWRpYSAke21lZGlhfXsgI21hdGNobWVkaWFqcy10ZXN0IHsgd2lkdGg6IDFweDsgfSB9YDtcblxuICAgICAgICAvLyAnc3R5bGUuc3R5bGVTaGVldCcgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnc3R5bGUudGV4dENvbnRlbnQnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcbiAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3QgaWYgbWVkaWEgcXVlcnkgaXMgdHJ1ZSBvciBmYWxzZVxuICAgICAgICByZXR1cm4gaW5mby53aWR0aCA9PT0gJzFweCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG1lZGlhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoZXM6IHN0eWxlTWVkaWEubWF0Y2hNZWRpdW0obWVkaWEgfHwgJ2FsbCcpLFxuICAgICAgbWVkaWE6IG1lZGlhIHx8ICdhbGwnXG4gICAgfTtcbiAgfVxufSgpKTtcblxuLy8gVGhhbmsgeW91OiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZ1xuZnVuY3Rpb24gcGFyc2VTdHlsZVRvT2JqZWN0KHN0cikge1xuICB2YXIgc3R5bGVPYmplY3QgPSB7fTtcblxuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gIH1cblxuICBzdHIgPSBzdHIudHJpbSgpLnNsaWNlKDEsIC0xKTsgLy8gYnJvd3NlcnMgcmUtcXVvdGUgc3RyaW5nIHN0eWxlIHZhbHVlc1xuXG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG5cbiAgc3R5bGVPYmplY3QgPSBzdHIuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24ocmV0LCBwYXJhbSkge1xuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgdmFyIGtleSA9IHBhcnRzWzBdO1xuICAgIHZhciB2YWwgPSBwYXJ0c1sxXTtcbiAgICBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcblxuICAgIC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG4gICAgLy8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuICAgIHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXG4gICAgaWYgKCFyZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0W2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xuICAgICAgcmV0W2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRba2V5XSA9IFtyZXRba2V5XSwgdmFsXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSwge30pO1xuXG4gIHJldHVybiBzdHlsZU9iamVjdDtcbn1cblxuRm91bmRhdGlvbi5NZWRpYVF1ZXJ5ID0gTWVkaWFRdWVyeTtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIE1vdGlvbiBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ubW90aW9uXG4gKi9cblxuY29uc3QgaW5pdENsYXNzZXMgICA9IFsnbXVpLWVudGVyJywgJ211aS1sZWF2ZSddO1xuY29uc3QgYWN0aXZlQ2xhc3NlcyA9IFsnbXVpLWVudGVyLWFjdGl2ZScsICdtdWktbGVhdmUtYWN0aXZlJ107XG5cbmNvbnN0IE1vdGlvbiA9IHtcbiAgYW5pbWF0ZUluOiBmdW5jdGlvbihlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XG4gICAgYW5pbWF0ZSh0cnVlLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKTtcbiAgfSxcblxuICBhbmltYXRlT3V0OiBmdW5jdGlvbihlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XG4gICAgYW5pbWF0ZShmYWxzZSwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gTW92ZShkdXJhdGlvbiwgZWxlbSwgZm4pe1xuICB2YXIgYW5pbSwgcHJvZywgc3RhcnQgPSBudWxsO1xuICAvLyBjb25zb2xlLmxvZygnY2FsbGVkJyk7XG5cbiAgZnVuY3Rpb24gbW92ZSh0cyl7XG4gICAgaWYoIXN0YXJ0KSBzdGFydCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAvLyBjb25zb2xlLmxvZyhzdGFydCwgdHMpO1xuICAgIHByb2cgPSB0cyAtIHN0YXJ0O1xuICAgIGZuLmFwcGx5KGVsZW0pO1xuXG4gICAgaWYocHJvZyA8IGR1cmF0aW9uKXsgYW5pbSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW92ZSwgZWxlbSk7IH1cbiAgICBlbHNle1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW0pO1xuICAgICAgZWxlbS50cmlnZ2VyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKS50cmlnZ2VySGFuZGxlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSk7XG4gICAgfVxuICB9XG4gIGFuaW0gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdmUpO1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIGFuIGVsZW1lbnQgaW4gb3Igb3V0IHVzaW5nIGEgQ1NTIHRyYW5zaXRpb24gY2xhc3MuXG4gKiBAZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW4gLSBEZWZpbmVzIGlmIHRoZSBhbmltYXRpb24gaXMgaW4gb3Igb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb3IgSFRNTCBvYmplY3QgdG8gYW5pbWF0ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBhbmltYXRpb24gLSBDU1MgY2xhc3MgdG8gdXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBDYWxsYmFjayB0byBydW4gd2hlbiBhbmltYXRpb24gaXMgZmluaXNoZWQuXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGUoaXNJbiwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICBlbGVtZW50ID0gJChlbGVtZW50KS5lcSgwKTtcblxuICBpZiAoIWVsZW1lbnQubGVuZ3RoKSByZXR1cm47XG5cbiAgdmFyIGluaXRDbGFzcyA9IGlzSW4gPyBpbml0Q2xhc3Nlc1swXSA6IGluaXRDbGFzc2VzWzFdO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0luID8gYWN0aXZlQ2xhc3Nlc1swXSA6IGFjdGl2ZUNsYXNzZXNbMV07XG5cbiAgLy8gU2V0IHVwIHRoZSBhbmltYXRpb25cbiAgcmVzZXQoKTtcblxuICBlbGVtZW50XG4gICAgLmFkZENsYXNzKGFuaW1hdGlvbilcbiAgICAuY3NzKCd0cmFuc2l0aW9uJywgJ25vbmUnKTtcblxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGVsZW1lbnQuYWRkQ2xhc3MoaW5pdENsYXNzKTtcbiAgICBpZiAoaXNJbikgZWxlbWVudC5zaG93KCk7XG4gIH0pO1xuXG4gIC8vIFN0YXJ0IHRoZSBhbmltYXRpb25cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBlbGVtZW50WzBdLm9mZnNldFdpZHRoO1xuICAgIGVsZW1lbnRcbiAgICAgIC5jc3MoJ3RyYW5zaXRpb24nLCAnJylcbiAgICAgIC5hZGRDbGFzcyhhY3RpdmVDbGFzcyk7XG4gIH0pO1xuXG4gIC8vIENsZWFuIHVwIHRoZSBhbmltYXRpb24gd2hlbiBpdCBmaW5pc2hlc1xuICBlbGVtZW50Lm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoZWxlbWVudCksIGZpbmlzaCk7XG5cbiAgLy8gSGlkZXMgdGhlIGVsZW1lbnQgKGZvciBvdXQgYW5pbWF0aW9ucyksIHJlc2V0cyB0aGUgZWxlbWVudCwgYW5kIHJ1bnMgYSBjYWxsYmFja1xuICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgaWYgKCFpc0luKSBlbGVtZW50LmhpZGUoKTtcbiAgICByZXNldCgpO1xuICAgIGlmIChjYikgY2IuYXBwbHkoZWxlbWVudCk7XG4gIH1cblxuICAvLyBSZXNldHMgdHJhbnNpdGlvbnMgYW5kIHJlbW92ZXMgbW90aW9uLXNwZWNpZmljIGNsYXNzZXNcbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZWxlbWVudFswXS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAwO1xuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoYCR7aW5pdENsYXNzfSAke2FjdGl2ZUNsYXNzfSAke2FuaW1hdGlvbn1gKTtcbiAgfVxufVxuXG5Gb3VuZGF0aW9uLk1vdmUgPSBNb3ZlO1xuRm91bmRhdGlvbi5Nb3Rpb24gPSBNb3Rpb247XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuY29uc3QgTmVzdCA9IHtcbiAgRmVhdGhlcihtZW51LCB0eXBlID0gJ3pmJykge1xuICAgIG1lbnUuYXR0cigncm9sZScsICdtZW51YmFyJyk7XG5cbiAgICB2YXIgaXRlbXMgPSBtZW51LmZpbmQoJ2xpJykuYXR0cih7J3JvbGUnOiAnbWVudWl0ZW0nfSksXG4gICAgICAgIHN1Yk1lbnVDbGFzcyA9IGBpcy0ke3R5cGV9LXN1Ym1lbnVgLFxuICAgICAgICBzdWJJdGVtQ2xhc3MgPSBgJHtzdWJNZW51Q2xhc3N9LWl0ZW1gLFxuICAgICAgICBoYXNTdWJDbGFzcyA9IGBpcy0ke3R5cGV9LXN1Ym1lbnUtcGFyZW50YDtcblxuICAgIG1lbnUuZmluZCgnYTpmaXJzdCcpLmF0dHIoJ3RhYmluZGV4JywgMCk7XG5cbiAgICBpdGVtcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyICRpdGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAkc3ViID0gJGl0ZW0uY2hpbGRyZW4oJ3VsJyk7XG5cbiAgICAgIGlmICgkc3ViLmxlbmd0aCkge1xuICAgICAgICAkaXRlbVxuICAgICAgICAgIC5hZGRDbGFzcyhoYXNTdWJDbGFzcylcbiAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlLFxuICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiAkaXRlbS5jaGlsZHJlbignYTpmaXJzdCcpLnRleHQoKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICRzdWJcbiAgICAgICAgICAuYWRkQ2xhc3MoYHN1Ym1lbnUgJHtzdWJNZW51Q2xhc3N9YClcbiAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAnZGF0YS1zdWJtZW51JzogJycsXG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgICAgICAgJ3JvbGUnOiAnbWVudSdcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRpdGVtLnBhcmVudCgnW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcbiAgICAgICAgJGl0ZW0uYWRkQ2xhc3MoYGlzLXN1Ym1lbnUtaXRlbSAke3N1Ykl0ZW1DbGFzc31gKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfSxcblxuICBCdXJuKG1lbnUsIHR5cGUpIHtcbiAgICB2YXIgaXRlbXMgPSBtZW51LmZpbmQoJ2xpJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKSxcbiAgICAgICAgc3ViTWVudUNsYXNzID0gYGlzLSR7dHlwZX0tc3VibWVudWAsXG4gICAgICAgIHN1Ykl0ZW1DbGFzcyA9IGAke3N1Yk1lbnVDbGFzc30taXRlbWAsXG4gICAgICAgIGhhc1N1YkNsYXNzID0gYGlzLSR7dHlwZX0tc3VibWVudS1wYXJlbnRgO1xuXG4gICAgbWVudVxuICAgICAgLmZpbmQoJyonKVxuICAgICAgLnJlbW92ZUNsYXNzKGAke3N1Yk1lbnVDbGFzc30gJHtzdWJJdGVtQ2xhc3N9ICR7aGFzU3ViQ2xhc3N9IGlzLXN1Ym1lbnUtaXRlbSBzdWJtZW51IGlzLWFjdGl2ZWApXG4gICAgICAucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51JykuY3NzKCdkaXNwbGF5JywgJycpO1xuXG4gICAgLy8gY29uc29sZS5sb2coICAgICAgbWVudS5maW5kKCcuJyArIHN1Yk1lbnVDbGFzcyArICcsIC4nICsgc3ViSXRlbUNsYXNzICsgJywgLmhhcy1zdWJtZW51LCAuaXMtc3VibWVudS1pdGVtLCAuc3VibWVudSwgW2RhdGEtc3VibWVudV0nKVxuICAgIC8vICAgICAgICAgICAucmVtb3ZlQ2xhc3Moc3ViTWVudUNsYXNzICsgJyAnICsgc3ViSXRlbUNsYXNzICsgJyBoYXMtc3VibWVudSBpcy1zdWJtZW51LWl0ZW0gc3VibWVudScpXG4gICAgLy8gICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXN1Ym1lbnUnKSk7XG4gICAgLy8gaXRlbXMuZWFjaChmdW5jdGlvbigpe1xuICAgIC8vICAgdmFyICRpdGVtID0gJCh0aGlzKSxcbiAgICAvLyAgICAgICAkc3ViID0gJGl0ZW0uY2hpbGRyZW4oJ3VsJyk7XG4gICAgLy8gICBpZigkaXRlbS5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKXtcbiAgICAvLyAgICAgJGl0ZW0ucmVtb3ZlQ2xhc3MoJ2lzLXN1Ym1lbnUtaXRlbSAnICsgc3ViSXRlbUNsYXNzKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIGlmKCRzdWIubGVuZ3RoKXtcbiAgICAvLyAgICAgJGl0ZW0ucmVtb3ZlQ2xhc3MoJ2hhcy1zdWJtZW51Jyk7XG4gICAgLy8gICAgICRzdWIucmVtb3ZlQ2xhc3MoJ3N1Ym1lbnUgJyArIHN1Yk1lbnVDbGFzcykucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51Jyk7XG4gICAgLy8gICB9XG4gICAgLy8gfSk7XG4gIH1cbn1cblxuRm91bmRhdGlvbi5OZXN0ID0gTmVzdDtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG5mdW5jdGlvbiBUaW1lcihlbGVtLCBvcHRpb25zLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uLC8vb3B0aW9ucyBpcyBhbiBvYmplY3QgZm9yIGVhc2lseSBhZGRpbmcgZmVhdHVyZXMgbGF0ZXIuXG4gICAgICBuYW1lU3BhY2UgPSBPYmplY3Qua2V5cyhlbGVtLmRhdGEoKSlbMF0gfHwgJ3RpbWVyJyxcbiAgICAgIHJlbWFpbiA9IC0xLFxuICAgICAgc3RhcnQsXG4gICAgICB0aW1lcjtcblxuICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgdGhpcy5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtYWluID0gLTE7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aGlzLnN0YXJ0KCk7XG4gIH1cblxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuICAgIC8vIGlmKCFlbGVtLmRhdGEoJ3BhdXNlZCcpKXsgcmV0dXJuIGZhbHNlOyB9Ly9tYXliZSBpbXBsZW1lbnQgdGhpcyBzYW5pdHkgY2hlY2sgaWYgdXNlZCBmb3Igb3RoZXIgdGhpbmdzLlxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgcmVtYWluID0gcmVtYWluIDw9IDAgPyBkdXJhdGlvbiA6IHJlbWFpbjtcbiAgICBlbGVtLmRhdGEoJ3BhdXNlZCcsIGZhbHNlKTtcbiAgICBzdGFydCA9IERhdGUubm93KCk7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBpZihvcHRpb25zLmluZmluaXRlKXtcbiAgICAgICAgX3RoaXMucmVzdGFydCgpOy8vcmVydW4gdGhlIHRpbWVyLlxuICAgICAgfVxuICAgICAgY2IoKTtcbiAgICB9LCByZW1haW4pO1xuICAgIGVsZW0udHJpZ2dlcihgdGltZXJzdGFydC56Zi4ke25hbWVTcGFjZX1gKTtcbiAgfVxuXG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICAvL2lmKGVsZW0uZGF0YSgncGF1c2VkJykpeyByZXR1cm4gZmFsc2U7IH0vL21heWJlIGltcGxlbWVudCB0aGlzIHNhbml0eSBjaGVjayBpZiB1c2VkIGZvciBvdGhlciB0aGluZ3MuXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICBlbGVtLmRhdGEoJ3BhdXNlZCcsIHRydWUpO1xuICAgIHZhciBlbmQgPSBEYXRlLm5vdygpO1xuICAgIHJlbWFpbiA9IHJlbWFpbiAtIChlbmQgLSBzdGFydCk7XG4gICAgZWxlbS50cmlnZ2VyKGB0aW1lcnBhdXNlZC56Zi4ke25hbWVTcGFjZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkLlxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlcyAtIEltYWdlKHMpIHRvIGNoZWNrIGlmIGxvYWRlZC5cbiAqIEBwYXJhbSB7RnVuY30gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gaW1hZ2UgaXMgZnVsbHkgbG9hZGVkLlxuICovXG5mdW5jdGlvbiBvbkltYWdlc0xvYWRlZChpbWFnZXMsIGNhbGxiYWNrKXtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgdW5sb2FkZWQgPSBpbWFnZXMubGVuZ3RoO1xuXG4gIGlmICh1bmxvYWRlZCA9PT0gMCkge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBpbWFnZXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb21wbGV0ZSkge1xuICAgICAgc2luZ2xlSW1hZ2VMb2FkZWQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMubmF0dXJhbFdpZHRoICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLm5hdHVyYWxXaWR0aCA+IDApIHtcbiAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJCh0aGlzKS5vbmUoJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2luZ2xlSW1hZ2VMb2FkZWQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gc2luZ2xlSW1hZ2VMb2FkZWQoKSB7XG4gICAgdW5sb2FkZWQtLTtcbiAgICBpZiAodW5sb2FkZWQgPT09IDApIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG59XG5cbkZvdW5kYXRpb24uVGltZXIgPSBUaW1lcjtcbkZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQgPSBvbkltYWdlc0xvYWRlZDtcblxufShqUXVlcnkpO1xuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8qKldvcmsgaW5zcGlyZWQgYnkgbXVsdGlwbGUganF1ZXJ5IHN3aXBlIHBsdWdpbnMqKlxuLy8qKkRvbmUgYnkgWW9oYWkgQXJhcmF0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuKGZ1bmN0aW9uKCQpIHtcblxuICAkLnNwb3RTd2lwZSA9IHtcbiAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgIGVuYWJsZWQ6ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgbW92ZVRocmVzaG9sZDogNzUsXG4gICAgdGltZVRocmVzaG9sZDogMjAwXG4gIH07XG5cbiAgdmFyICAgc3RhcnRQb3NYLFxuICAgICAgICBzdGFydFBvc1ksXG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgZWxhcHNlZFRpbWUsXG4gICAgICAgIGlzTW92aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25Ub3VjaEVuZCgpIHtcbiAgICAvLyAgYWxlcnQodGhpcyk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuICAgIGlzTW92aW5nID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XG4gICAgaWYgKCQuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgIGlmKGlzTW92aW5nKSB7XG4gICAgICB2YXIgeCA9IGUudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgIHZhciB5ID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgdmFyIGR4ID0gc3RhcnRQb3NYIC0geDtcbiAgICAgIHZhciBkeSA9IHN0YXJ0UG9zWSAtIHk7XG4gICAgICB2YXIgZGlyO1xuICAgICAgZWxhcHNlZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZTtcbiAgICAgIGlmKE1hdGguYWJzKGR4KSA+PSAkLnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkICYmIGVsYXBzZWRUaW1lIDw9ICQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQpIHtcbiAgICAgICAgZGlyID0gZHggPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH1cbiAgICAgIC8vIGVsc2UgaWYoTWF0aC5hYnMoZHkpID49ICQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0gJC5zcG90U3dpcGUudGltZVRocmVzaG9sZCkge1xuICAgICAgLy8gICBkaXIgPSBkeSA+IDAgPyAnZG93bicgOiAndXAnO1xuICAgICAgLy8gfVxuICAgICAgaWYoZGlyKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25Ub3VjaEVuZC5jYWxsKHRoaXMpO1xuICAgICAgICAkKHRoaXMpLnRyaWdnZXIoJ3N3aXBlJywgZGlyKS50cmlnZ2VyKGBzd2lwZSR7ZGlyfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgc3RhcnRQb3NYID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgc3RhcnRQb3NZID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyICYmIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVhcmRvd24oKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgfVxuXG4gICQuZXZlbnQuc3BlY2lhbC5zd2lwZSA9IHsgc2V0dXA6IGluaXQgfTtcblxuICAkLmVhY2goWydsZWZ0JywgJ3VwJywgJ2Rvd24nLCAncmlnaHQnXSwgZnVuY3Rpb24gKCkge1xuICAgICQuZXZlbnQuc3BlY2lhbFtgc3dpcGUke3RoaXN9YF0gPSB7IHNldHVwOiBmdW5jdGlvbigpe1xuICAgICAgJCh0aGlzKS5vbignc3dpcGUnLCAkLm5vb3ApO1xuICAgIH0gfTtcbiAgfSk7XG59KShqUXVlcnkpO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1ldGhvZCBmb3IgYWRkaW5nIHBzdWVkbyBkcmFnIGV2ZW50cyB0byBlbGVtZW50cyAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuIWZ1bmN0aW9uKCQpe1xuICAkLmZuLmFkZFRvdWNoID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSxlbCl7XG4gICAgICAkKGVsKS5iaW5kKCd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsZnVuY3Rpb24oKXtcbiAgICAgICAgLy93ZSBwYXNzIHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QgYmVjYXVzZSB0aGUgalF1ZXJ5IGV2ZW50XG4gICAgICAgIC8vb2JqZWN0IGlzIG5vcm1hbGl6ZWQgdG8gdzNjIHNwZWNzIGFuZCBkb2VzIG5vdCBwcm92aWRlIHRoZSBUb3VjaExpc3RcbiAgICAgICAgaGFuZGxlVG91Y2goZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgaGFuZGxlVG91Y2ggPSBmdW5jdGlvbihldmVudCl7XG4gICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICAgIGZpcnN0ID0gdG91Y2hlc1swXSxcbiAgICAgICAgICBldmVudFR5cGVzID0ge1xuICAgICAgICAgICAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gICAgICAgICAgICB0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgdG91Y2hlbmQ6ICdtb3VzZXVwJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHlwZSA9IGV2ZW50VHlwZXNbZXZlbnQudHlwZV0sXG4gICAgICAgICAgc2ltdWxhdGVkRXZlbnRcbiAgICAgICAgO1xuXG4gICAgICBpZignTW91c2VFdmVudCcgaW4gd2luZG93ICYmIHR5cGVvZiB3aW5kb3cuTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IHdpbmRvdy5Nb3VzZUV2ZW50KHR5cGUsIHtcbiAgICAgICAgICAnYnViYmxlcyc6IHRydWUsXG4gICAgICAgICAgJ2NhbmNlbGFibGUnOiB0cnVlLFxuICAgICAgICAgICdzY3JlZW5YJzogZmlyc3Quc2NyZWVuWCxcbiAgICAgICAgICAnc2NyZWVuWSc6IGZpcnN0LnNjcmVlblksXG4gICAgICAgICAgJ2NsaWVudFgnOiBmaXJzdC5jbGllbnRYLFxuICAgICAgICAgICdjbGllbnRZJzogZmlyc3QuY2xpZW50WVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbXVsYXRlZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICAgICAgc2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLCBmaXJzdC5zY3JlZW5YLCBmaXJzdC5zY3JlZW5ZLCBmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMC8qbGVmdCovLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGZpcnN0LnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcbiAgICB9O1xuICB9O1xufShqUXVlcnkpO1xuXG5cbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8qKkZyb20gdGhlIGpRdWVyeSBNb2JpbGUgTGlicmFyeSoqXG4vLyoqbmVlZCB0byByZWNyZWF0ZSBmdW5jdGlvbmFsaXR5Kipcbi8vKiphbmQgdHJ5IHRvIGltcHJvdmUgaWYgcG9zc2libGUqKlxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbi8qIFJlbW92aW5nIHRoZSBqUXVlcnkgZnVuY3Rpb24gKioqKlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbihmdW5jdGlvbiggJCwgd2luZG93LCB1bmRlZmluZWQgKSB7XG5cblx0dmFyICRkb2N1bWVudCA9ICQoIGRvY3VtZW50ICksXG5cdFx0Ly8gc3VwcG9ydFRvdWNoID0gJC5tb2JpbGUuc3VwcG9ydC50b3VjaCxcblx0XHR0b3VjaFN0YXJ0RXZlbnQgPSAndG91Y2hzdGFydCcvL3N1cHBvcnRUb3VjaCA/IFwidG91Y2hzdGFydFwiIDogXCJtb3VzZWRvd25cIixcblx0XHR0b3VjaFN0b3BFdmVudCA9ICd0b3VjaGVuZCcvL3N1cHBvcnRUb3VjaCA/IFwidG91Y2hlbmRcIiA6IFwibW91c2V1cFwiLFxuXHRcdHRvdWNoTW92ZUV2ZW50ID0gJ3RvdWNobW92ZScvL3N1cHBvcnRUb3VjaCA/IFwidG91Y2htb3ZlXCIgOiBcIm1vdXNlbW92ZVwiO1xuXG5cdC8vIHNldHVwIG5ldyBldmVudCBzaG9ydGN1dHNcblx0JC5lYWNoKCAoIFwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgXCIgK1xuXHRcdFwic3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHRcIiApLnNwbGl0KCBcIiBcIiApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHRcdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdHJldHVybiBmbiA/IHRoaXMuYmluZCggbmFtZSwgZm4gKSA6IHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHRcdH07XG5cblx0XHQvLyBqUXVlcnkgPCAxLjhcblx0XHRpZiAoICQuYXR0ckZuICkge1xuXHRcdFx0JC5hdHRyRm5bIG5hbWUgXSA9IHRydWU7XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiB0cmlnZ2VyQ3VzdG9tRXZlbnQoIG9iaiwgZXZlbnRUeXBlLCBldmVudCwgYnViYmxlICkge1xuXHRcdHZhciBvcmlnaW5hbFR5cGUgPSBldmVudC50eXBlO1xuXHRcdGV2ZW50LnR5cGUgPSBldmVudFR5cGU7XG5cdFx0aWYgKCBidWJibGUgKSB7XG5cdFx0XHQkLmV2ZW50LnRyaWdnZXIoIGV2ZW50LCB1bmRlZmluZWQsIG9iaiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkLmV2ZW50LmRpc3BhdGNoLmNhbGwoIG9iaiwgZXZlbnQgKTtcblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IG9yaWdpbmFsVHlwZTtcblx0fVxuXG5cdC8vIGFsc28gaGFuZGxlcyB0YXBob2xkXG5cblx0Ly8gQWxzbyBoYW5kbGVzIHN3aXBlbGVmdCwgc3dpcGVyaWdodFxuXHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUgPSB7XG5cblx0XHQvLyBNb3JlIHRoYW4gdGhpcyBob3Jpem9udGFsIGRpc3BsYWNlbWVudCwgYW5kIHdlIHdpbGwgc3VwcHJlc3Mgc2Nyb2xsaW5nLlxuXHRcdHNjcm9sbFN1cHJlc3Npb25UaHJlc2hvbGQ6IDMwLFxuXG5cdFx0Ly8gTW9yZSB0aW1lIHRoYW4gdGhpcywgYW5kIGl0IGlzbid0IGEgc3dpcGUuXG5cdFx0ZHVyYXRpb25UaHJlc2hvbGQ6IDEwMDAsXG5cblx0XHQvLyBTd2lwZSBob3Jpem9udGFsIGRpc3BsYWNlbWVudCBtdXN0IGJlIG1vcmUgdGhhbiB0aGlzLlxuXHRcdGhvcml6b250YWxEaXN0YW5jZVRocmVzaG9sZDogd2luZG93LmRldmljZVBpeGVsUmF0aW8gPj0gMiA/IDE1IDogMzAsXG5cblx0XHQvLyBTd2lwZSB2ZXJ0aWNhbCBkaXNwbGFjZW1lbnQgbXVzdCBiZSBsZXNzIHRoYW4gdGhpcy5cblx0XHR2ZXJ0aWNhbERpc3RhbmNlVGhyZXNob2xkOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+PSAyID8gMTUgOiAzMCxcblxuXHRcdGdldExvY2F0aW9uOiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0dmFyIHdpblBhZ2VYID0gd2luZG93LnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHR3aW5QYWdlWSA9IHdpbmRvdy5wYWdlWU9mZnNldCxcblx0XHRcdFx0eCA9IGV2ZW50LmNsaWVudFgsXG5cdFx0XHRcdHkgPSBldmVudC5jbGllbnRZO1xuXG5cdFx0XHRpZiAoIGV2ZW50LnBhZ2VZID09PSAwICYmIE1hdGguZmxvb3IoIHkgKSA+IE1hdGguZmxvb3IoIGV2ZW50LnBhZ2VZICkgfHxcblx0XHRcdFx0ZXZlbnQucGFnZVggPT09IDAgJiYgTWF0aC5mbG9vciggeCApID4gTWF0aC5mbG9vciggZXZlbnQucGFnZVggKSApIHtcblxuXHRcdFx0XHQvLyBpT1M0IGNsaWVudFgvY2xpZW50WSBoYXZlIHRoZSB2YWx1ZSB0aGF0IHNob3VsZCBoYXZlIGJlZW5cblx0XHRcdFx0Ly8gaW4gcGFnZVgvcGFnZVkuIFdoaWxlIHBhZ2VYL3BhZ2UvIGhhdmUgdGhlIHZhbHVlIDBcblx0XHRcdFx0eCA9IHggLSB3aW5QYWdlWDtcblx0XHRcdFx0eSA9IHkgLSB3aW5QYWdlWTtcblx0XHRcdH0gZWxzZSBpZiAoIHkgPCAoIGV2ZW50LnBhZ2VZIC0gd2luUGFnZVkpIHx8IHggPCAoIGV2ZW50LnBhZ2VYIC0gd2luUGFnZVggKSApIHtcblxuXHRcdFx0XHQvLyBTb21lIEFuZHJvaWQgYnJvd3NlcnMgaGF2ZSB0b3RhbGx5IGJvZ3VzIHZhbHVlcyBmb3IgY2xpZW50WC9ZXG5cdFx0XHRcdC8vIHdoZW4gc2Nyb2xsaW5nL3pvb21pbmcgYSBwYWdlLiBEZXRlY3RhYmxlIHNpbmNlIGNsaWVudFgvY2xpZW50WVxuXHRcdFx0XHQvLyBzaG91bGQgbmV2ZXIgYmUgc21hbGxlciB0aGFuIHBhZ2VYL3BhZ2VZIG1pbnVzIHBhZ2Ugc2Nyb2xsXG5cdFx0XHRcdHggPSBldmVudC5wYWdlWCAtIHdpblBhZ2VYO1xuXHRcdFx0XHR5ID0gZXZlbnQucGFnZVkgLSB3aW5QYWdlWTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogeCxcblx0XHRcdFx0eTogeVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBkYXRhID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzID9cblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbIDAgXSA6IGV2ZW50LFxuXHRcdFx0XHRsb2NhdGlvbiA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5nZXRMb2NhdGlvbiggZGF0YSApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHRpbWU6ICggbmV3IERhdGUoKSApLmdldFRpbWUoKSxcblx0XHRcdFx0XHRcdGNvb3JkczogWyBsb2NhdGlvbi54LCBsb2NhdGlvbi55IF0sXG5cdFx0XHRcdFx0XHRvcmlnaW46ICQoIGV2ZW50LnRhcmdldCApXG5cdFx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0c3RvcDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGRhdGEgPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgP1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1sgMCBdIDogZXZlbnQsXG5cdFx0XHRcdGxvY2F0aW9uID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLmdldExvY2F0aW9uKCBkYXRhICk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dGltZTogKCBuZXcgRGF0ZSgpICkuZ2V0VGltZSgpLFxuXHRcdFx0XHRcdFx0Y29vcmRzOiBbIGxvY2F0aW9uLngsIGxvY2F0aW9uLnkgXVxuXHRcdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdGhhbmRsZVN3aXBlOiBmdW5jdGlvbiggc3RhcnQsIHN0b3AsIHRoaXNPYmplY3QsIG9yaWdUYXJnZXQgKSB7XG5cdFx0XHRpZiAoIHN0b3AudGltZSAtIHN0YXJ0LnRpbWUgPCAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZHVyYXRpb25UaHJlc2hvbGQgJiZcblx0XHRcdFx0TWF0aC5hYnMoIHN0YXJ0LmNvb3Jkc1sgMCBdIC0gc3RvcC5jb29yZHNbIDAgXSApID4gJC5ldmVudC5zcGVjaWFsLnN3aXBlLmhvcml6b250YWxEaXN0YW5jZVRocmVzaG9sZCAmJlxuXHRcdFx0XHRNYXRoLmFicyggc3RhcnQuY29vcmRzWyAxIF0gLSBzdG9wLmNvb3Jkc1sgMSBdICkgPCAkLmV2ZW50LnNwZWNpYWwuc3dpcGUudmVydGljYWxEaXN0YW5jZVRocmVzaG9sZCApIHtcblx0XHRcdFx0dmFyIGRpcmVjdGlvbiA9IHN0YXJ0LmNvb3Jkc1swXSA+IHN0b3AuY29vcmRzWyAwIF0gPyBcInN3aXBlbGVmdFwiIDogXCJzd2lwZXJpZ2h0XCI7XG5cblx0XHRcdFx0dHJpZ2dlckN1c3RvbUV2ZW50KCB0aGlzT2JqZWN0LCBcInN3aXBlXCIsICQuRXZlbnQoIFwic3dpcGVcIiwgeyB0YXJnZXQ6IG9yaWdUYXJnZXQsIHN3aXBlc3RhcnQ6IHN0YXJ0LCBzd2lwZXN0b3A6IHN0b3AgfSksIHRydWUgKTtcblx0XHRcdFx0dHJpZ2dlckN1c3RvbUV2ZW50KCB0aGlzT2JqZWN0LCBkaXJlY3Rpb24sJC5FdmVudCggZGlyZWN0aW9uLCB7IHRhcmdldDogb3JpZ1RhcmdldCwgc3dpcGVzdGFydDogc3RhcnQsIHN3aXBlc3RvcDogc3RvcCB9ICksIHRydWUgKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9LFxuXG5cdFx0Ly8gVGhpcyBzZXJ2ZXMgYXMgYSBmbGFnIHRvIGVuc3VyZSB0aGF0IGF0IG1vc3Qgb25lIHN3aXBlIGV2ZW50IGV2ZW50IGlzXG5cdFx0Ly8gaW4gd29yayBhdCBhbnkgZ2l2ZW4gdGltZVxuXHRcdGV2ZW50SW5Qcm9ncmVzczogZmFsc2UsXG5cblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZXZlbnRzLFxuXHRcdFx0XHR0aGlzT2JqZWN0ID0gdGhpcyxcblx0XHRcdFx0JHRoaXMgPSAkKCB0aGlzT2JqZWN0ICksXG5cdFx0XHRcdGNvbnRleHQgPSB7fTtcblxuXHRcdFx0Ly8gUmV0cmlldmUgdGhlIGV2ZW50cyBkYXRhIGZvciB0aGlzIGVsZW1lbnQgYW5kIGFkZCB0aGUgc3dpcGUgY29udGV4dFxuXHRcdFx0ZXZlbnRzID0gJC5kYXRhKCB0aGlzLCBcIm1vYmlsZS1ldmVudHNcIiApO1xuXHRcdFx0aWYgKCAhZXZlbnRzICkge1xuXHRcdFx0XHRldmVudHMgPSB7IGxlbmd0aDogMCB9O1xuXHRcdFx0XHQkLmRhdGEoIHRoaXMsIFwibW9iaWxlLWV2ZW50c1wiLCBldmVudHMgKTtcblx0XHRcdH1cblx0XHRcdGV2ZW50cy5sZW5ndGgrKztcblx0XHRcdGV2ZW50cy5zd2lwZSA9IGNvbnRleHQ7XG5cblx0XHRcdGNvbnRleHQuc3RhcnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gQmFpbCBpZiB3ZSdyZSBhbHJlYWR5IHdvcmtpbmcgb24gYSBzd2lwZSBldmVudFxuXHRcdFx0XHRpZiAoICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgPSB0cnVlO1xuXG5cdFx0XHRcdHZhciBzdG9wLFxuXHRcdFx0XHRcdHN0YXJ0ID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLnN0YXJ0KCBldmVudCApLFxuXHRcdFx0XHRcdG9yaWdUYXJnZXQgPSBldmVudC50YXJnZXQsXG5cdFx0XHRcdFx0ZW1pdHRlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGNvbnRleHQubW92ZSA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRpZiAoICFzdGFydCB8fCBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzdG9wID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLnN0b3AoIGV2ZW50ICk7XG5cdFx0XHRcdFx0aWYgKCAhZW1pdHRlZCApIHtcblx0XHRcdFx0XHRcdGVtaXR0ZWQgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuaGFuZGxlU3dpcGUoIHN0YXJ0LCBzdG9wLCB0aGlzT2JqZWN0LCBvcmlnVGFyZ2V0ICk7XG5cdFx0XHRcdFx0XHRpZiAoIGVtaXR0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVzZXQgdGhlIGNvbnRleHQgdG8gbWFrZSB3YXkgZm9yIHRoZSBuZXh0IHN3aXBlIGV2ZW50XG5cdFx0XHRcdFx0XHRcdCQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gcHJldmVudCBzY3JvbGxpbmdcblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBzdGFydC5jb29yZHNbIDAgXSAtIHN0b3AuY29vcmRzWyAwIF0gKSA+ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5zY3JvbGxTdXByZXNzaW9uVGhyZXNob2xkICkge1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Y29udGV4dC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRlbWl0dGVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVzZXQgdGhlIGNvbnRleHQgdG8gbWFrZSB3YXkgZm9yIHRoZSBuZXh0IHN3aXBlIGV2ZW50XG5cdFx0XHRcdFx0XHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHQkZG9jdW1lbnQub2ZmKCB0b3VjaE1vdmVFdmVudCwgY29udGV4dC5tb3ZlICk7XG5cdFx0XHRcdFx0XHRjb250ZXh0Lm1vdmUgPSBudWxsO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdCRkb2N1bWVudC5vbiggdG91Y2hNb3ZlRXZlbnQsIGNvbnRleHQubW92ZSApXG5cdFx0XHRcdFx0Lm9uZSggdG91Y2hTdG9wRXZlbnQsIGNvbnRleHQuc3RvcCApO1xuXHRcdFx0fTtcblx0XHRcdCR0aGlzLm9uKCB0b3VjaFN0YXJ0RXZlbnQsIGNvbnRleHQuc3RhcnQgKTtcblx0XHR9LFxuXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGV2ZW50cywgY29udGV4dDtcblxuXHRcdFx0ZXZlbnRzID0gJC5kYXRhKCB0aGlzLCBcIm1vYmlsZS1ldmVudHNcIiApO1xuXHRcdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBldmVudHMuc3dpcGU7XG5cdFx0XHRcdGRlbGV0ZSBldmVudHMuc3dpcGU7XG5cdFx0XHRcdGV2ZW50cy5sZW5ndGgtLTtcblx0XHRcdFx0aWYgKCBldmVudHMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRcdCQucmVtb3ZlRGF0YSggdGhpcywgXCJtb2JpbGUtZXZlbnRzXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNvbnRleHQgKSB7XG5cdFx0XHRcdGlmICggY29udGV4dC5zdGFydCApIHtcblx0XHRcdFx0XHQkKCB0aGlzICkub2ZmKCB0b3VjaFN0YXJ0RXZlbnQsIGNvbnRleHQuc3RhcnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNvbnRleHQubW92ZSApIHtcblx0XHRcdFx0XHQkZG9jdW1lbnQub2ZmKCB0b3VjaE1vdmVFdmVudCwgY29udGV4dC5tb3ZlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjb250ZXh0LnN0b3AgKSB7XG5cdFx0XHRcdFx0JGRvY3VtZW50Lm9mZiggdG91Y2hTdG9wRXZlbnQsIGNvbnRleHQuc3RvcCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHQkLmVhY2goe1xuXHRcdHN3aXBlbGVmdDogXCJzd2lwZS5sZWZ0XCIsXG5cdFx0c3dpcGVyaWdodDogXCJzd2lwZS5yaWdodFwiXG5cdH0sIGZ1bmN0aW9uKCBldmVudCwgc291cmNlRXZlbnQgKSB7XG5cblx0XHQkLmV2ZW50LnNwZWNpYWxbIGV2ZW50IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5iaW5kKCBzb3VyY2VFdmVudCwgJC5ub29wICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkudW5iaW5kKCBzb3VyY2VFdmVudCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufSkoIGpRdWVyeSwgdGhpcyApO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuY29uc3QgTXV0YXRpb25PYnNlcnZlciA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBwcmVmaXhlcyA9IFsnV2ViS2l0JywgJ01veicsICdPJywgJ01zJywgJyddO1xuICBmb3IgKHZhciBpPTA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChgJHtwcmVmaXhlc1tpXX1NdXRhdGlvbk9ic2VydmVyYCBpbiB3aW5kb3cpIHtcbiAgICAgIHJldHVybiB3aW5kb3dbYCR7cHJlZml4ZXNbaV19TXV0YXRpb25PYnNlcnZlcmBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KCkpO1xuXG5jb25zdCB0cmlnZ2VycyA9IChlbCwgdHlwZSkgPT4ge1xuICBlbC5kYXRhKHR5cGUpLnNwbGl0KCcgJykuZm9yRWFjaChpZCA9PiB7XG4gICAgJChgIyR7aWR9YClbIHR5cGUgPT09ICdjbG9zZScgPyAndHJpZ2dlcicgOiAndHJpZ2dlckhhbmRsZXInXShgJHt0eXBlfS56Zi50cmlnZ2VyYCwgW2VsXSk7XG4gIH0pO1xufTtcbi8vIEVsZW1lbnRzIHdpdGggW2RhdGEtb3Blbl0gd2lsbCByZXZlYWwgYSBwbHVnaW4gdGhhdCBzdXBwb3J0cyBpdCB3aGVuIGNsaWNrZWQuXG4kKGRvY3VtZW50KS5vbignY2xpY2suemYudHJpZ2dlcicsICdbZGF0YS1vcGVuXScsIGZ1bmN0aW9uKCkge1xuICB0cmlnZ2VycygkKHRoaXMpLCAnb3BlbicpO1xufSk7XG5cbi8vIEVsZW1lbnRzIHdpdGggW2RhdGEtY2xvc2VdIHdpbGwgY2xvc2UgYSBwbHVnaW4gdGhhdCBzdXBwb3J0cyBpdCB3aGVuIGNsaWNrZWQuXG4vLyBJZiB1c2VkIHdpdGhvdXQgYSB2YWx1ZSBvbiBbZGF0YS1jbG9zZV0sIHRoZSBldmVudCB3aWxsIGJ1YmJsZSwgYWxsb3dpbmcgaXQgdG8gY2xvc2UgYSBwYXJlbnQgY29tcG9uZW50LlxuJChkb2N1bWVudCkub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtY2xvc2VdJywgZnVuY3Rpb24oKSB7XG4gIGxldCBpZCA9ICQodGhpcykuZGF0YSgnY2xvc2UnKTtcbiAgaWYgKGlkKSB7XG4gICAgdHJpZ2dlcnMoJCh0aGlzKSwgJ2Nsb3NlJyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgJCh0aGlzKS50cmlnZ2VyKCdjbG9zZS56Zi50cmlnZ2VyJyk7XG4gIH1cbn0pO1xuXG4vLyBFbGVtZW50cyB3aXRoIFtkYXRhLXRvZ2dsZV0gd2lsbCB0b2dnbGUgYSBwbHVnaW4gdGhhdCBzdXBwb3J0cyBpdCB3aGVuIGNsaWNrZWQuXG4kKGRvY3VtZW50KS5vbignY2xpY2suemYudHJpZ2dlcicsICdbZGF0YS10b2dnbGVdJywgZnVuY3Rpb24oKSB7XG4gIHRyaWdnZXJzKCQodGhpcyksICd0b2dnbGUnKTtcbn0pO1xuXG4vLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NhYmxlXSB3aWxsIHJlc3BvbmQgdG8gY2xvc2UuemYudHJpZ2dlciBldmVudHMuXG4kKGRvY3VtZW50KS5vbignY2xvc2UuemYudHJpZ2dlcicsICdbZGF0YS1jbG9zYWJsZV0nLCBmdW5jdGlvbihlKXtcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgbGV0IGFuaW1hdGlvbiA9ICQodGhpcykuZGF0YSgnY2xvc2FibGUnKTtcblxuICBpZihhbmltYXRpb24gIT09ICcnKXtcbiAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KCQodGhpcyksIGFuaW1hdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICAkKHRoaXMpLnRyaWdnZXIoJ2Nsb3NlZC56ZicpO1xuICAgIH0pO1xuICB9ZWxzZXtcbiAgICAkKHRoaXMpLmZhZGVPdXQoKS50cmlnZ2VyKCdjbG9zZWQuemYnKTtcbiAgfVxufSk7XG5cbiQoZG9jdW1lbnQpLm9uKCdmb2N1cy56Zi50cmlnZ2VyIGJsdXIuemYudHJpZ2dlcicsICdbZGF0YS10b2dnbGUtZm9jdXNdJywgZnVuY3Rpb24oKSB7XG4gIGxldCBpZCA9ICQodGhpcykuZGF0YSgndG9nZ2xlLWZvY3VzJyk7XG4gICQoYCMke2lkfWApLnRyaWdnZXJIYW5kbGVyKCd0b2dnbGUuemYudHJpZ2dlcicsIFskKHRoaXMpXSk7XG59KTtcblxuLyoqXG4qIEZpcmVzIG9uY2UgYWZ0ZXIgYWxsIG90aGVyIHNjcmlwdHMgaGF2ZSBsb2FkZWRcbiogQGZ1bmN0aW9uXG4qIEBwcml2YXRlXG4qL1xuJCh3aW5kb3cpLmxvYWQoKCkgPT4ge1xuICBjaGVja0xpc3RlbmVycygpO1xufSk7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXJzKCkge1xuICBldmVudHNMaXN0ZW5lcigpO1xuICByZXNpemVMaXN0ZW5lcigpO1xuICBzY3JvbGxMaXN0ZW5lcigpO1xuICBjbG9zZW1lTGlzdGVuZXIoKTtcbn1cblxuLy8qKioqKioqKiBvbmx5IGZpcmVzIHRoaXMgZnVuY3Rpb24gb25jZSBvbiBsb2FkLCBpZiB0aGVyZSdzIHNvbWV0aGluZyB0byB3YXRjaCAqKioqKioqKlxuZnVuY3Rpb24gY2xvc2VtZUxpc3RlbmVyKHBsdWdpbk5hbWUpIHtcbiAgdmFyIHlldGlCb3hlcyA9ICQoJ1tkYXRhLXlldGktYm94XScpLFxuICAgICAgcGx1Z05hbWVzID0gWydkcm9wZG93bicsICd0b29sdGlwJywgJ3JldmVhbCddO1xuXG4gIGlmKHBsdWdpbk5hbWUpe1xuICAgIGlmKHR5cGVvZiBwbHVnaW5OYW1lID09PSAnc3RyaW5nJyl7XG4gICAgICBwbHVnTmFtZXMucHVzaChwbHVnaW5OYW1lKTtcbiAgICB9ZWxzZSBpZih0eXBlb2YgcGx1Z2luTmFtZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBsdWdpbk5hbWVbMF0gPT09ICdzdHJpbmcnKXtcbiAgICAgIHBsdWdOYW1lcy5jb25jYXQocGx1Z2luTmFtZSk7XG4gICAgfWVsc2V7XG4gICAgICBjb25zb2xlLmVycm9yKCdQbHVnaW4gbmFtZXMgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICB9XG4gIGlmKHlldGlCb3hlcy5sZW5ndGgpe1xuICAgIGxldCBsaXN0ZW5lcnMgPSBwbHVnTmFtZXMubWFwKChuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gYGNsb3NlbWUuemYuJHtuYW1lfWA7XG4gICAgfSkuam9pbignICcpO1xuXG4gICAgJCh3aW5kb3cpLm9mZihsaXN0ZW5lcnMpLm9uKGxpc3RlbmVycywgZnVuY3Rpb24oZSwgcGx1Z2luSWQpe1xuICAgICAgbGV0IHBsdWdpbiA9IGUubmFtZXNwYWNlLnNwbGl0KCcuJylbMF07XG4gICAgICBsZXQgcGx1Z2lucyA9ICQoYFtkYXRhLSR7cGx1Z2lufV1gKS5ub3QoYFtkYXRhLXlldGktYm94PVwiJHtwbHVnaW5JZH1cIl1gKTtcblxuICAgICAgcGx1Z2lucy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBfdGhpcyA9ICQodGhpcyk7XG5cbiAgICAgICAgX3RoaXMudHJpZ2dlckhhbmRsZXIoJ2Nsb3NlLnpmLnRyaWdnZXInLCBbX3RoaXNdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZUxpc3RlbmVyKGRlYm91bmNlKXtcbiAgbGV0IHRpbWVyLFxuICAgICAgJG5vZGVzID0gJCgnW2RhdGEtcmVzaXplXScpO1xuICBpZigkbm9kZXMubGVuZ3RoKXtcbiAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUuemYudHJpZ2dlcicpXG4gICAgLm9uKCdyZXNpemUuemYudHJpZ2dlcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aW1lcikgeyBjbGVhclRpbWVvdXQodGltZXIpOyB9XG5cbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXG4gICAgICAgIGlmKCFNdXRhdGlvbk9ic2VydmVyKXsvL2ZhbGxiYWNrIGZvciBJRSA5XG4gICAgICAgICAgJG5vZGVzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICQodGhpcykudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL3RyaWdnZXIgYWxsIGxpc3RlbmluZyBlbGVtZW50cyBhbmQgc2lnbmFsIGEgcmVzaXplIGV2ZW50XG4gICAgICAgICRub2Rlcy5hdHRyKCdkYXRhLWV2ZW50cycsIFwicmVzaXplXCIpO1xuICAgICAgfSwgZGVib3VuY2UgfHwgMTApOy8vZGVmYXVsdCB0aW1lIHRvIGVtaXQgcmVzaXplIGV2ZW50XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsTGlzdGVuZXIoZGVib3VuY2Upe1xuICBsZXQgdGltZXIsXG4gICAgICAkbm9kZXMgPSAkKCdbZGF0YS1zY3JvbGxdJyk7XG4gIGlmKCRub2Rlcy5sZW5ndGgpe1xuICAgICQod2luZG93KS5vZmYoJ3Njcm9sbC56Zi50cmlnZ2VyJylcbiAgICAub24oJ3Njcm9sbC56Zi50cmlnZ2VyJywgZnVuY3Rpb24oZSl7XG4gICAgICBpZih0aW1lcil7IGNsZWFyVGltZW91dCh0aW1lcik7IH1cblxuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgaWYoIU11dGF0aW9uT2JzZXJ2ZXIpey8vZmFsbGJhY2sgZm9yIElFIDlcbiAgICAgICAgICAkbm9kZXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VySGFuZGxlcignc2Nyb2xsbWUuemYudHJpZ2dlcicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSBzY3JvbGwgZXZlbnRcbiAgICAgICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXCJzY3JvbGxcIik7XG4gICAgICB9LCBkZWJvdW5jZSB8fCAxMCk7Ly9kZWZhdWx0IHRpbWUgdG8gZW1pdCBzY3JvbGwgZXZlbnRcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudHNMaXN0ZW5lcigpIHtcbiAgaWYoIU11dGF0aW9uT2JzZXJ2ZXIpeyByZXR1cm4gZmFsc2U7IH1cbiAgbGV0IG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtcmVzaXplXSwgW2RhdGEtc2Nyb2xsXSwgW2RhdGEtbXV0YXRlXScpO1xuXG4gIC8vZWxlbWVudCBjYWxsYmFja1xuICB2YXIgbGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbiA9IGZ1bmN0aW9uKG11dGF0aW9uUmVjb3Jkc0xpc3QpIHtcbiAgICB2YXIgJHRhcmdldCA9ICQobXV0YXRpb25SZWNvcmRzTGlzdFswXS50YXJnZXQpO1xuICAgIC8vdHJpZ2dlciB0aGUgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGVsZW1lbnQgZGVwZW5kaW5nIG9uIHR5cGVcbiAgICBzd2l0Y2ggKCR0YXJnZXQuYXR0cihcImRhdGEtZXZlbnRzXCIpKSB7XG5cbiAgICAgIGNhc2UgXCJyZXNpemVcIiA6XG4gICAgICAkdGFyZ2V0LnRyaWdnZXJIYW5kbGVyKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgWyR0YXJnZXRdKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwic2Nyb2xsXCIgOlxuICAgICAgJHRhcmdldC50cmlnZ2VySGFuZGxlcignc2Nyb2xsbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0LCB3aW5kb3cucGFnZVlPZmZzZXRdKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBjYXNlIFwibXV0YXRlXCIgOlxuICAgICAgLy8gY29uc29sZS5sb2coJ211dGF0ZScsICR0YXJnZXQpO1xuICAgICAgLy8gJHRhcmdldC50cmlnZ2VySGFuZGxlcignbXV0YXRlLnpmLnRyaWdnZXInKTtcbiAgICAgIC8vXG4gICAgICAvLyAvL21ha2Ugc3VyZSB3ZSBkb24ndCBnZXQgc3R1Y2sgaW4gYW4gaW5maW5pdGUgbG9vcCBmcm9tIHNsb3BweSBjb2RlaW5nXG4gICAgICAvLyBpZiAoJHRhcmdldC5pbmRleCgnW2RhdGEtbXV0YXRlXScpID09ICQoXCJbZGF0YS1tdXRhdGVdXCIpLmxlbmd0aC0xKSB7XG4gICAgICAvLyAgIGRvbU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICAgIC8vIH1cbiAgICAgIC8vIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0IDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIC8vbm90aGluZ1xuICAgIH1cbiAgfVxuXG4gIGlmKG5vZGVzLmxlbmd0aCl7XG4gICAgLy9mb3IgZWFjaCBlbGVtZW50IHRoYXQgbmVlZHMgdG8gbGlzdGVuIGZvciByZXNpemluZywgc2Nyb2xsaW5nLCAob3IgY29taW5nIHNvb24gbXV0YXRpb24pIGFkZCBhIHNpbmdsZSBvYnNlcnZlclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG5vZGVzLmxlbmd0aC0xOyBpKyspIHtcbiAgICAgIGxldCBlbGVtZW50T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uKTtcbiAgICAgIGVsZW1lbnRPYnNlcnZlci5vYnNlcnZlKG5vZGVzW2ldLCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogZmFsc2UsIGNoYXJhY3RlckRhdGE6IGZhbHNlLCBzdWJ0cmVlOmZhbHNlLCBhdHRyaWJ1dGVGaWx0ZXI6W1wiZGF0YS1ldmVudHNcIl19KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFtQSF1cbi8vIEZvdW5kYXRpb24uQ2hlY2tXYXRjaGVycyA9IGNoZWNrV2F0Y2hlcnM7XG5Gb3VuZGF0aW9uLklIZWFyWW91ID0gY2hlY2tMaXN0ZW5lcnM7XG4vLyBGb3VuZGF0aW9uLklTZWVZb3UgPSBzY3JvbGxMaXN0ZW5lcjtcbi8vIEZvdW5kYXRpb24uSUZlZWxZb3UgPSBjbG9zZW1lTGlzdGVuZXI7XG5cbn0oalF1ZXJ5KTtcblxuLy8gZnVuY3Rpb24gZG9tTXV0YXRpb25PYnNlcnZlcihkZWJvdW5jZSkge1xuLy8gICAvLyAhISEgVGhpcyBpcyBjb21pbmcgc29vbiBhbmQgbmVlZHMgbW9yZSB3b3JrOyBub3QgYWN0aXZlICAhISEgLy9cbi8vICAgdmFyIHRpbWVyLFxuLy8gICBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW11dGF0ZV0nKTtcbi8vICAgLy9cbi8vICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuLy8gICAgIC8vIHZhciBNdXRhdGlvbk9ic2VydmVyID0gKGZ1bmN0aW9uICgpIHtcbi8vICAgICAvLyAgIHZhciBwcmVmaXhlcyA9IFsnV2ViS2l0JywgJ01veicsICdPJywgJ01zJywgJyddO1xuLy8gICAgIC8vICAgZm9yICh2YXIgaT0wOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbi8vICAgICAvLyAgICAgaWYgKHByZWZpeGVzW2ldICsgJ011dGF0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdykge1xuLy8gICAgIC8vICAgICAgIHJldHVybiB3aW5kb3dbcHJlZml4ZXNbaV0gKyAnTXV0YXRpb25PYnNlcnZlciddO1xuLy8gICAgIC8vICAgICB9XG4vLyAgICAgLy8gICB9XG4vLyAgICAgLy8gICByZXR1cm4gZmFsc2U7XG4vLyAgICAgLy8gfSgpKTtcbi8vXG4vL1xuLy8gICAgIC8vZm9yIHRoZSBib2R5LCB3ZSBuZWVkIHRvIGxpc3RlbiBmb3IgYWxsIGNoYW5nZXMgZWZmZWN0aW5nIHRoZSBzdHlsZSBhbmQgY2xhc3MgYXR0cmlidXRlc1xuLy8gICAgIHZhciBib2R5T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihib2R5TXV0YXRpb24pO1xuLy8gICAgIGJvZHlPYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiBmYWxzZSwgc3VidHJlZTp0cnVlLCBhdHRyaWJ1dGVGaWx0ZXI6W1wic3R5bGVcIiwgXCJjbGFzc1wiXX0pO1xuLy9cbi8vXG4vLyAgICAgLy9ib2R5IGNhbGxiYWNrXG4vLyAgICAgZnVuY3Rpb24gYm9keU11dGF0aW9uKG11dGF0ZSkge1xuLy8gICAgICAgLy90cmlnZ2VyIGFsbCBsaXN0ZW5pbmcgZWxlbWVudHMgYW5kIHNpZ25hbCBhIG11dGF0aW9uIGV2ZW50XG4vLyAgICAgICBpZiAodGltZXIpIHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfVxuLy9cbi8vICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbi8vICAgICAgICAgYm9keU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbi8vICAgICAgICAgJCgnW2RhdGEtbXV0YXRlXScpLmF0dHIoJ2RhdGEtZXZlbnRzJyxcIm11dGF0ZVwiKTtcbi8vICAgICAgIH0sIGRlYm91bmNlIHx8IDE1MCk7XG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG4iLCIvKiFcbiAqIE1hc29ucnkgUEFDS0FHRUQgdjQuMS4xXG4gKiBDYXNjYWRpbmcgZ3JpZCBsYXlvdXQgbGlicmFyeVxuICogaHR0cDovL21hc29ucnkuZGVzYW5kcm8uY29tXG4gKiBNSVQgTGljZW5zZVxuICogYnkgRGF2aWQgRGVTYW5kcm9cbiAqL1xuXG4vKipcbiAqIEJyaWRnZXQgbWFrZXMgalF1ZXJ5IHdpZGdldHNcbiAqIHYyLjAuMVxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKiBqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qanNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggJ2pxdWVyeS1icmlkZ2V0L2pxdWVyeS1icmlkZ2V0JyxbICdqcXVlcnknIF0sIGZ1bmN0aW9uKCBqUXVlcnkgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBqUXVlcnkgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ2pxdWVyeScpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5qUXVlcnlCcmlkZ2V0ID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5qUXVlcnlcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBqUXVlcnkgKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tIHV0aWxzIC0tLS0tIC8vXG5cbnZhciBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vLyBoZWxwZXIgZnVuY3Rpb24gZm9yIGxvZ2dpbmcgZXJyb3JzXG4vLyAkLmVycm9yIGJyZWFrcyBqUXVlcnkgY2hhaW5pbmdcbnZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG52YXIgbG9nRXJyb3IgPSB0eXBlb2YgY29uc29sZSA9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uKCkge30gOlxuICBmdW5jdGlvbiggbWVzc2FnZSApIHtcbiAgICBjb25zb2xlLmVycm9yKCBtZXNzYWdlICk7XG4gIH07XG5cbi8vIC0tLS0tIGpRdWVyeUJyaWRnZXQgLS0tLS0gLy9cblxuZnVuY3Rpb24galF1ZXJ5QnJpZGdldCggbmFtZXNwYWNlLCBQbHVnaW5DbGFzcywgJCApIHtcbiAgJCA9ICQgfHwgalF1ZXJ5IHx8IHdpbmRvdy5qUXVlcnk7XG4gIGlmICggISQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYWRkIG9wdGlvbiBtZXRob2QgLT4gJCgpLnBsdWdpbignb3B0aW9uJywgey4uLn0pXG4gIGlmICggIVBsdWdpbkNsYXNzLnByb3RvdHlwZS5vcHRpb24gKSB7XG4gICAgLy8gb3B0aW9uIHNldHRlclxuICAgIFBsdWdpbkNsYXNzLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiggb3B0cyApIHtcbiAgICAgIC8vIGJhaWwgb3V0IGlmIG5vdCBhbiBvYmplY3RcbiAgICAgIGlmICggISQuaXNQbGFpbk9iamVjdCggb3B0cyApICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKCB0cnVlLCB0aGlzLm9wdGlvbnMsIG9wdHMgKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gbWFrZSBqUXVlcnkgcGx1Z2luXG4gICQuZm5bIG5hbWVzcGFjZSBdID0gZnVuY3Rpb24oIGFyZzAgLyosIGFyZzEgKi8gKSB7XG4gICAgaWYgKCB0eXBlb2YgYXJnMCA9PSAnc3RyaW5nJyApIHtcbiAgICAgIC8vIG1ldGhvZCBjYWxsICQoKS5wbHVnaW4oICdtZXRob2ROYW1lJywgeyBvcHRpb25zIH0gKVxuICAgICAgLy8gc2hpZnQgYXJndW1lbnRzIGJ5IDFcbiAgICAgIHZhciBhcmdzID0gYXJyYXlTbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcbiAgICAgIHJldHVybiBtZXRob2RDYWxsKCB0aGlzLCBhcmcwLCBhcmdzICk7XG4gICAgfVxuICAgIC8vIGp1c3QgJCgpLnBsdWdpbih7IG9wdGlvbnMgfSlcbiAgICBwbGFpbkNhbGwoIHRoaXMsIGFyZzAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyAkKCkucGx1Z2luKCdtZXRob2ROYW1lJylcbiAgZnVuY3Rpb24gbWV0aG9kQ2FsbCggJGVsZW1zLCBtZXRob2ROYW1lLCBhcmdzICkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB2YXIgcGx1Z2luTWV0aG9kU3RyID0gJyQoKS4nICsgbmFtZXNwYWNlICsgJyhcIicgKyBtZXRob2ROYW1lICsgJ1wiKSc7XG5cbiAgICAkZWxlbXMuZWFjaCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG4gICAgICAvLyBnZXQgaW5zdGFuY2VcbiAgICAgIHZhciBpbnN0YW5jZSA9ICQuZGF0YSggZWxlbSwgbmFtZXNwYWNlICk7XG4gICAgICBpZiAoICFpbnN0YW5jZSApIHtcbiAgICAgICAgbG9nRXJyb3IoIG5hbWVzcGFjZSArICcgbm90IGluaXRpYWxpemVkLiBDYW5ub3QgY2FsbCBtZXRob2RzLCBpLmUuICcgK1xuICAgICAgICAgIHBsdWdpbk1ldGhvZFN0ciApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtZXRob2QgPSBpbnN0YW5jZVsgbWV0aG9kTmFtZSBdO1xuICAgICAgaWYgKCAhbWV0aG9kIHx8IG1ldGhvZE5hbWUuY2hhckF0KDApID09ICdfJyApIHtcbiAgICAgICAgbG9nRXJyb3IoIHBsdWdpbk1ldGhvZFN0ciArICcgaXMgbm90IGEgdmFsaWQgbWV0aG9kJyApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IG1ldGhvZCwgZ2V0IHJldHVybiB2YWx1ZVxuICAgICAgdmFyIHZhbHVlID0gbWV0aG9kLmFwcGx5KCBpbnN0YW5jZSwgYXJncyApO1xuICAgICAgLy8gc2V0IHJldHVybiB2YWx1ZSBpZiB2YWx1ZSBpcyByZXR1cm5lZCwgdXNlIG9ubHkgZmlyc3QgdmFsdWVcbiAgICAgIHJldHVyblZhbHVlID0gcmV0dXJuVmFsdWUgPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogcmV0dXJuVmFsdWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWUgIT09IHVuZGVmaW5lZCA/IHJldHVyblZhbHVlIDogJGVsZW1zO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhaW5DYWxsKCAkZWxlbXMsIG9wdGlvbnMgKSB7XG4gICAgJGVsZW1zLmVhY2goIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuICAgICAgdmFyIGluc3RhbmNlID0gJC5kYXRhKCBlbGVtLCBuYW1lc3BhY2UgKTtcbiAgICAgIGlmICggaW5zdGFuY2UgKSB7XG4gICAgICAgIC8vIHNldCBvcHRpb25zICYgaW5pdFxuICAgICAgICBpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgKTtcbiAgICAgICAgaW5zdGFuY2UuX2luaXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgbmV3IGluc3RhbmNlXG4gICAgICAgIGluc3RhbmNlID0gbmV3IFBsdWdpbkNsYXNzKCBlbGVtLCBvcHRpb25zICk7XG4gICAgICAgICQuZGF0YSggZWxlbSwgbmFtZXNwYWNlLCBpbnN0YW5jZSApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlSlF1ZXJ5KCAkICk7XG5cbn1cblxuLy8gLS0tLS0gdXBkYXRlSlF1ZXJ5IC0tLS0tIC8vXG5cbi8vIHNldCAkLmJyaWRnZXQgZm9yIHYxIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5mdW5jdGlvbiB1cGRhdGVKUXVlcnkoICQgKSB7XG4gIGlmICggISQgfHwgKCAkICYmICQuYnJpZGdldCApICkge1xuICAgIHJldHVybjtcbiAgfVxuICAkLmJyaWRnZXQgPSBqUXVlcnlCcmlkZ2V0O1xufVxuXG51cGRhdGVKUXVlcnkoIGpRdWVyeSB8fCB3aW5kb3cualF1ZXJ5ICk7XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG5yZXR1cm4galF1ZXJ5QnJpZGdldDtcblxufSkpO1xuXG4vKipcbiAqIEV2RW1pdHRlciB2MS4wLjNcbiAqIExpbCcgZXZlbnQgZW1pdHRlclxuICogTUlUIExpY2Vuc2VcbiAqL1xuXG4vKiBqc2hpbnQgdW51c2VkOiB0cnVlLCB1bmRlZjogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXG5cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHdpbmRvdyAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRCAtIFJlcXVpcmVKU1xuICAgIGRlZmluZSggJ2V2LWVtaXR0ZXIvZXYtZW1pdHRlcicsZmFjdG9yeSApO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTIC0gQnJvd3NlcmlmeSwgV2VicGFja1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGdsb2JhbC5FdkVtaXR0ZXIgPSBmYWN0b3J5KCk7XG4gIH1cblxufSggdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCkge1xuXG5cblxuZnVuY3Rpb24gRXZFbWl0dGVyKCkge31cblxudmFyIHByb3RvID0gRXZFbWl0dGVyLnByb3RvdHlwZTtcblxucHJvdG8ub24gPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgaWYgKCAhZXZlbnROYW1lIHx8ICFsaXN0ZW5lciApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc2V0IGV2ZW50cyBoYXNoXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIC8vIHNldCBsaXN0ZW5lcnMgYXJyYXlcbiAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1sgZXZlbnROYW1lIF0gPSBldmVudHNbIGV2ZW50TmFtZSBdIHx8IFtdO1xuICAvLyBvbmx5IGFkZCBvbmNlXG4gIGlmICggbGlzdGVuZXJzLmluZGV4T2YoIGxpc3RlbmVyICkgPT0gLTEgKSB7XG4gICAgbGlzdGVuZXJzLnB1c2goIGxpc3RlbmVyICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLm9uY2UgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgaWYgKCAhZXZlbnROYW1lIHx8ICFsaXN0ZW5lciApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gYWRkIGV2ZW50XG4gIHRoaXMub24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKTtcbiAgLy8gc2V0IG9uY2UgZmxhZ1xuICAvLyBzZXQgb25jZUV2ZW50cyBoYXNoXG4gIHZhciBvbmNlRXZlbnRzID0gdGhpcy5fb25jZUV2ZW50cyA9IHRoaXMuX29uY2VFdmVudHMgfHwge307XG4gIC8vIHNldCBvbmNlTGlzdGVuZXJzIG9iamVjdFxuICB2YXIgb25jZUxpc3RlbmVycyA9IG9uY2VFdmVudHNbIGV2ZW50TmFtZSBdID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gfHwge307XG4gIC8vIHNldCBmbGFnXG4gIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF0gPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ub2ZmID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgaWYgKCAhbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZiggbGlzdGVuZXIgKTtcbiAgaWYgKCBpbmRleCAhPSAtMSApIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBhcmdzICkge1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1sgZXZlbnROYW1lIF07XG4gIGlmICggIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGkgPSAwO1xuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAvLyBvbmNlIHN0dWZmXG4gIHZhciBvbmNlTGlzdGVuZXJzID0gdGhpcy5fb25jZUV2ZW50cyAmJiB0aGlzLl9vbmNlRXZlbnRzWyBldmVudE5hbWUgXTtcblxuICB3aGlsZSAoIGxpc3RlbmVyICkge1xuICAgIHZhciBpc09uY2UgPSBvbmNlTGlzdGVuZXJzICYmIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgaWYgKCBpc09uY2UgKSB7XG4gICAgICAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICAgIC8vIHJlbW92ZSBiZWZvcmUgdHJpZ2dlciB0byBwcmV2ZW50IHJlY3Vyc2lvblxuICAgICAgdGhpcy5vZmYoIGV2ZW50TmFtZSwgbGlzdGVuZXIgKTtcbiAgICAgIC8vIHVuc2V0IG9uY2UgZmxhZ1xuICAgICAgZGVsZXRlIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgbGlzdGVuZXJcbiAgICBsaXN0ZW5lci5hcHBseSggdGhpcywgYXJncyApO1xuICAgIC8vIGdldCBuZXh0IGxpc3RlbmVyXG4gICAgaSArPSBpc09uY2UgPyAwIDogMTtcbiAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucmV0dXJuIEV2RW1pdHRlcjtcblxufSkpO1xuXG4vKiFcbiAqIGdldFNpemUgdjIuMC4yXG4gKiBtZWFzdXJlIHNpemUgb2YgZWxlbWVudHNcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXG4vKmdsb2JhbCBkZWZpbmU6IGZhbHNlLCBtb2R1bGU6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggJ2dldC1zaXplL2dldC1zaXplJyxbXSxmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5nZXRTaXplID0gZmFjdG9yeSgpO1xuICB9XG5cbn0pKCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gZ2V0IGEgbnVtYmVyIGZyb20gYSBzdHJpbmcsIG5vdCBhIHBlcmNlbnRhZ2VcbmZ1bmN0aW9uIGdldFN0eWxlU2l6ZSggdmFsdWUgKSB7XG4gIHZhciBudW0gPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuICAvLyBub3QgYSBwZXJjZW50IGxpa2UgJzEwMCUnLCBhbmQgYSBudW1iZXJcbiAgdmFyIGlzVmFsaWQgPSB2YWx1ZS5pbmRleE9mKCclJykgPT0gLTEgJiYgIWlzTmFOKCBudW0gKTtcbiAgcmV0dXJuIGlzVmFsaWQgJiYgbnVtO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIGxvZ0Vycm9yID0gdHlwZW9mIGNvbnNvbGUgPT0gJ3VuZGVmaW5lZCcgPyBub29wIDpcbiAgZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XG4gICAgY29uc29sZS5lcnJvciggbWVzc2FnZSApO1xuICB9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBtZWFzdXJlbWVudHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxudmFyIG1lYXN1cmVtZW50cyA9IFtcbiAgJ3BhZGRpbmdMZWZ0JyxcbiAgJ3BhZGRpbmdSaWdodCcsXG4gICdwYWRkaW5nVG9wJyxcbiAgJ3BhZGRpbmdCb3R0b20nLFxuICAnbWFyZ2luTGVmdCcsXG4gICdtYXJnaW5SaWdodCcsXG4gICdtYXJnaW5Ub3AnLFxuICAnbWFyZ2luQm90dG9tJyxcbiAgJ2JvcmRlckxlZnRXaWR0aCcsXG4gICdib3JkZXJSaWdodFdpZHRoJyxcbiAgJ2JvcmRlclRvcFdpZHRoJyxcbiAgJ2JvcmRlckJvdHRvbVdpZHRoJ1xuXTtcblxudmFyIG1lYXN1cmVtZW50c0xlbmd0aCA9IG1lYXN1cmVtZW50cy5sZW5ndGg7XG5cbmZ1bmN0aW9uIGdldFplcm9TaXplKCkge1xuICB2YXIgc2l6ZSA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgaW5uZXJXaWR0aDogMCxcbiAgICBpbm5lckhlaWdodDogMCxcbiAgICBvdXRlcldpZHRoOiAwLFxuICAgIG91dGVySGVpZ2h0OiAwXG4gIH07XG4gIGZvciAoIHZhciBpPTA7IGkgPCBtZWFzdXJlbWVudHNMZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgc2l6ZVsgbWVhc3VyZW1lbnQgXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGdldFN0eWxlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8qKlxuICogZ2V0U3R5bGUsIGdldCBzdHlsZSBvZiBlbGVtZW50LCBjaGVjayBmb3IgRmlyZWZveCBidWdcbiAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICovXG5mdW5jdGlvbiBnZXRTdHlsZSggZWxlbSApIHtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuICBpZiAoICFzdHlsZSApIHtcbiAgICBsb2dFcnJvciggJ1N0eWxlIHJldHVybmVkICcgKyBzdHlsZSArXG4gICAgICAnLiBBcmUgeW91IHJ1bm5pbmcgdGhpcyBjb2RlIGluIGEgaGlkZGVuIGlmcmFtZSBvbiBGaXJlZm94PyAnICtcbiAgICAgICdTZWUgaHR0cDovL2JpdC5seS9nZXRzaXplYnVnMScgKTtcbiAgfVxuICByZXR1cm4gc3R5bGU7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHNldHVwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnZhciBpc1NldHVwID0gZmFsc2U7XG5cbnZhciBpc0JveFNpemVPdXRlcjtcblxuLyoqXG4gKiBzZXR1cFxuICogY2hlY2sgaXNCb3hTaXplck91dGVyXG4gKiBkbyBvbiBmaXJzdCBnZXRTaXplKCkgcmF0aGVyIHRoYW4gb24gcGFnZSBsb2FkIGZvciBGaXJlZm94IGJ1Z1xuICovXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgLy8gc2V0dXAgb25jZVxuICBpZiAoIGlzU2V0dXAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlzU2V0dXAgPSB0cnVlO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGJveCBzaXppbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAvKipcbiAgICogV2ViS2l0IG1lYXN1cmVzIHRoZSBvdXRlci13aWR0aCBvbiBzdHlsZS53aWR0aCBvbiBib3JkZXItYm94IGVsZW1zXG4gICAqIElFICYgRmlyZWZveDwyOSBtZWFzdXJlcyB0aGUgaW5uZXItd2lkdGhcbiAgICovXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnN0eWxlLndpZHRoID0gJzIwMHB4JztcbiAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMXB4IDJweCAzcHggNHB4JztcbiAgZGl2LnN0eWxlLmJvcmRlclN0eWxlID0gJ3NvbGlkJztcbiAgZGl2LnN0eWxlLmJvcmRlcldpZHRoID0gJzFweCAycHggM3B4IDRweCc7XG4gIGRpdi5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG5cbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgYm9keS5hcHBlbmRDaGlsZCggZGl2ICk7XG4gIHZhciBzdHlsZSA9IGdldFN0eWxlKCBkaXYgKTtcblxuICBnZXRTaXplLmlzQm94U2l6ZU91dGVyID0gaXNCb3hTaXplT3V0ZXIgPSBnZXRTdHlsZVNpemUoIHN0eWxlLndpZHRoICkgPT0gMjAwO1xuICBib2R5LnJlbW92ZUNoaWxkKCBkaXYgKTtcblxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBnZXRTaXplIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIGdldFNpemUoIGVsZW0gKSB7XG4gIHNldHVwKCk7XG5cbiAgLy8gdXNlIHF1ZXJ5U2VsZXRvciBpZiBlbGVtIGlzIHN0cmluZ1xuICBpZiAoIHR5cGVvZiBlbGVtID09ICdzdHJpbmcnICkge1xuICAgIGVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBlbGVtICk7XG4gIH1cblxuICAvLyBkbyBub3QgcHJvY2VlZCBvbiBub24tb2JqZWN0c1xuICBpZiAoICFlbGVtIHx8IHR5cGVvZiBlbGVtICE9ICdvYmplY3QnIHx8ICFlbGVtLm5vZGVUeXBlICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGdldFN0eWxlKCBlbGVtICk7XG5cbiAgLy8gaWYgaGlkZGVuLCBldmVyeXRoaW5nIGlzIDBcbiAgaWYgKCBzdHlsZS5kaXNwbGF5ID09ICdub25lJyApIHtcbiAgICByZXR1cm4gZ2V0WmVyb1NpemUoKTtcbiAgfVxuXG4gIHZhciBzaXplID0ge307XG4gIHNpemUud2lkdGggPSBlbGVtLm9mZnNldFdpZHRoO1xuICBzaXplLmhlaWdodCA9IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuXG4gIHZhciBpc0JvcmRlckJveCA9IHNpemUuaXNCb3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT0gJ2JvcmRlci1ib3gnO1xuXG4gIC8vIGdldCBhbGwgbWVhc3VyZW1lbnRzXG4gIGZvciAoIHZhciBpPTA7IGkgPCBtZWFzdXJlbWVudHNMZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIHZhbHVlID0gc3R5bGVbIG1lYXN1cmVtZW50IF07XG4gICAgdmFyIG51bSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG4gICAgLy8gYW55ICdhdXRvJywgJ21lZGl1bScgdmFsdWUgd2lsbCBiZSAwXG4gICAgc2l6ZVsgbWVhc3VyZW1lbnQgXSA9ICFpc05hTiggbnVtICkgPyBudW0gOiAwO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdXaWR0aCA9IHNpemUucGFkZGluZ0xlZnQgKyBzaXplLnBhZGRpbmdSaWdodDtcbiAgdmFyIHBhZGRpbmdIZWlnaHQgPSBzaXplLnBhZGRpbmdUb3AgKyBzaXplLnBhZGRpbmdCb3R0b207XG4gIHZhciBtYXJnaW5XaWR0aCA9IHNpemUubWFyZ2luTGVmdCArIHNpemUubWFyZ2luUmlnaHQ7XG4gIHZhciBtYXJnaW5IZWlnaHQgPSBzaXplLm1hcmdpblRvcCArIHNpemUubWFyZ2luQm90dG9tO1xuICB2YXIgYm9yZGVyV2lkdGggPSBzaXplLmJvcmRlckxlZnRXaWR0aCArIHNpemUuYm9yZGVyUmlnaHRXaWR0aDtcbiAgdmFyIGJvcmRlckhlaWdodCA9IHNpemUuYm9yZGVyVG9wV2lkdGggKyBzaXplLmJvcmRlckJvdHRvbVdpZHRoO1xuXG4gIHZhciBpc0JvcmRlckJveFNpemVPdXRlciA9IGlzQm9yZGVyQm94ICYmIGlzQm94U2l6ZU91dGVyO1xuXG4gIC8vIG92ZXJ3cml0ZSB3aWR0aCBhbmQgaGVpZ2h0IGlmIHdlIGNhbiBnZXQgaXQgZnJvbSBzdHlsZVxuICB2YXIgc3R5bGVXaWR0aCA9IGdldFN0eWxlU2l6ZSggc3R5bGUud2lkdGggKTtcbiAgaWYgKCBzdHlsZVdpZHRoICE9PSBmYWxzZSApIHtcbiAgICBzaXplLndpZHRoID0gc3R5bGVXaWR0aCArXG4gICAgICAvLyBhZGQgcGFkZGluZyBhbmQgYm9yZGVyIHVubGVzcyBpdCdzIGFscmVhZHkgaW5jbHVkaW5nIGl0XG4gICAgICAoIGlzQm9yZGVyQm94U2l6ZU91dGVyID8gMCA6IHBhZGRpbmdXaWR0aCArIGJvcmRlcldpZHRoICk7XG4gIH1cblxuICB2YXIgc3R5bGVIZWlnaHQgPSBnZXRTdHlsZVNpemUoIHN0eWxlLmhlaWdodCApO1xuICBpZiAoIHN0eWxlSGVpZ2h0ICE9PSBmYWxzZSApIHtcbiAgICBzaXplLmhlaWdodCA9IHN0eWxlSGVpZ2h0ICtcbiAgICAgIC8vIGFkZCBwYWRkaW5nIGFuZCBib3JkZXIgdW5sZXNzIGl0J3MgYWxyZWFkeSBpbmNsdWRpbmcgaXRcbiAgICAgICggaXNCb3JkZXJCb3hTaXplT3V0ZXIgPyAwIDogcGFkZGluZ0hlaWdodCArIGJvcmRlckhlaWdodCApO1xuICB9XG5cbiAgc2l6ZS5pbm5lcldpZHRoID0gc2l6ZS53aWR0aCAtICggcGFkZGluZ1dpZHRoICsgYm9yZGVyV2lkdGggKTtcbiAgc2l6ZS5pbm5lckhlaWdodCA9IHNpemUuaGVpZ2h0IC0gKCBwYWRkaW5nSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICk7XG5cbiAgc2l6ZS5vdXRlcldpZHRoID0gc2l6ZS53aWR0aCArIG1hcmdpbldpZHRoO1xuICBzaXplLm91dGVySGVpZ2h0ID0gc2l6ZS5oZWlnaHQgKyBtYXJnaW5IZWlnaHQ7XG5cbiAgcmV0dXJuIHNpemU7XG59XG5cbnJldHVybiBnZXRTaXplO1xuXG59KTtcblxuLyoqXG4gKiBtYXRjaGVzU2VsZWN0b3IgdjIuMC4xXG4gKiBtYXRjaGVzU2VsZWN0b3IoIGVsZW1lbnQsICcuc2VsZWN0b3InIClcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgbW9kdWxlOiBmYWxzZSAqL1xuICAndXNlIHN0cmljdCc7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggJ2Rlc2FuZHJvLW1hdGNoZXMtc2VsZWN0b3IvbWF0Y2hlcy1zZWxlY3RvcicsZmFjdG9yeSApO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cubWF0Y2hlc1NlbGVjdG9yID0gZmFjdG9yeSgpO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBtYXRjaGVzTWV0aG9kID0gKCBmdW5jdGlvbigpIHtcbiAgICB2YXIgRWxlbVByb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG4gICAgLy8gY2hlY2sgZm9yIHRoZSBzdGFuZGFyZCBtZXRob2QgbmFtZSBmaXJzdFxuICAgIGlmICggRWxlbVByb3RvLm1hdGNoZXMgKSB7XG4gICAgICByZXR1cm4gJ21hdGNoZXMnO1xuICAgIH1cbiAgICAvLyBjaGVjayB1bi1wcmVmaXhlZFxuICAgIGlmICggRWxlbVByb3RvLm1hdGNoZXNTZWxlY3RvciApIHtcbiAgICAgIHJldHVybiAnbWF0Y2hlc1NlbGVjdG9yJztcbiAgICB9XG4gICAgLy8gY2hlY2sgdmVuZG9yIHByZWZpeGVzXG4gICAgdmFyIHByZWZpeGVzID0gWyAnd2Via2l0JywgJ21veicsICdtcycsICdvJyBdO1xuXG4gICAgZm9yICggdmFyIGk9MDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgICAgdmFyIG1ldGhvZCA9IHByZWZpeCArICdNYXRjaGVzU2VsZWN0b3InO1xuICAgICAgaWYgKCBFbGVtUHJvdG9bIG1ldGhvZCBdICkge1xuICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgICAgfVxuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBzZWxlY3RvciApIHtcbiAgICByZXR1cm4gZWxlbVsgbWF0Y2hlc01ldGhvZCBdKCBzZWxlY3RvciApO1xuICB9O1xuXG59KSk7XG5cbi8qKlxuICogRml6enkgVUkgdXRpbHMgdjIuMC4yXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUsIHN0cmljdDogdHJ1ZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKmpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCAnZml6enktdWktdXRpbHMvdXRpbHMnLFtcbiAgICAgICdkZXNhbmRyby1tYXRjaGVzLXNlbGVjdG9yL21hdGNoZXMtc2VsZWN0b3InXG4gICAgXSwgZnVuY3Rpb24oIG1hdGNoZXNTZWxlY3RvciApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIG1hdGNoZXNTZWxlY3RvciApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnZGVzYW5kcm8tbWF0Y2hlcy1zZWxlY3RvcicpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5maXp6eVVJVXRpbHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93Lm1hdGNoZXNTZWxlY3RvclxuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIG1hdGNoZXNTZWxlY3RvciApIHtcblxuXG5cbnZhciB1dGlscyA9IHt9O1xuXG4vLyAtLS0tLSBleHRlbmQgLS0tLS0gLy9cblxuLy8gZXh0ZW5kcyBvYmplY3RzXG51dGlscy5leHRlbmQgPSBmdW5jdGlvbiggYSwgYiApIHtcbiAgZm9yICggdmFyIHByb3AgaW4gYiApIHtcbiAgICBhWyBwcm9wIF0gPSBiWyBwcm9wIF07XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vLyAtLS0tLSBtb2R1bG8gLS0tLS0gLy9cblxudXRpbHMubW9kdWxvID0gZnVuY3Rpb24oIG51bSwgZGl2ICkge1xuICByZXR1cm4gKCAoIG51bSAlIGRpdiApICsgZGl2ICkgJSBkaXY7XG59O1xuXG4vLyAtLS0tLSBtYWtlQXJyYXkgLS0tLS0gLy9cblxuLy8gdHVybiBlbGVtZW50IG9yIG5vZGVMaXN0IGludG8gYW4gYXJyYXlcbnV0aWxzLm1ha2VBcnJheSA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gIHZhciBhcnkgPSBbXTtcbiAgaWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcbiAgICAvLyB1c2Ugb2JqZWN0IGlmIGFscmVhZHkgYW4gYXJyYXlcbiAgICBhcnkgPSBvYmo7XG4gIH0gZWxzZSBpZiAoIG9iaiAmJiB0eXBlb2Ygb2JqLmxlbmd0aCA9PSAnbnVtYmVyJyApIHtcbiAgICAvLyBjb252ZXJ0IG5vZGVMaXN0IHRvIGFycmF5XG4gICAgZm9yICggdmFyIGk9MDsgaSA8IG9iai5sZW5ndGg7IGkrKyApIHtcbiAgICAgIGFyeS5wdXNoKCBvYmpbaV0gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gYXJyYXkgb2Ygc2luZ2xlIGluZGV4XG4gICAgYXJ5LnB1c2goIG9iaiApO1xuICB9XG4gIHJldHVybiBhcnk7XG59O1xuXG4vLyAtLS0tLSByZW1vdmVGcm9tIC0tLS0tIC8vXG5cbnV0aWxzLnJlbW92ZUZyb20gPSBmdW5jdGlvbiggYXJ5LCBvYmogKSB7XG4gIHZhciBpbmRleCA9IGFyeS5pbmRleE9mKCBvYmogKTtcbiAgaWYgKCBpbmRleCAhPSAtMSApIHtcbiAgICBhcnkuc3BsaWNlKCBpbmRleCwgMSApO1xuICB9XG59O1xuXG4vLyAtLS0tLSBnZXRQYXJlbnQgLS0tLS0gLy9cblxudXRpbHMuZ2V0UGFyZW50ID0gZnVuY3Rpb24oIGVsZW0sIHNlbGVjdG9yICkge1xuICB3aGlsZSAoIGVsZW0gIT0gZG9jdW1lbnQuYm9keSApIHtcbiAgICBlbGVtID0gZWxlbS5wYXJlbnROb2RlO1xuICAgIGlmICggbWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBzZWxlY3RvciApICkge1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLSBnZXRRdWVyeUVsZW1lbnQgLS0tLS0gLy9cblxuLy8gdXNlIGVsZW1lbnQgYXMgc2VsZWN0b3Igc3RyaW5nXG51dGlscy5nZXRRdWVyeUVsZW1lbnQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgaWYgKCB0eXBlb2YgZWxlbSA9PSAnc3RyaW5nJyApIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggZWxlbSApO1xuICB9XG4gIHJldHVybiBlbGVtO1xufTtcblxuLy8gLS0tLS0gaGFuZGxlRXZlbnQgLS0tLS0gLy9cblxuLy8gZW5hYmxlIC5vbnR5cGUgdG8gdHJpZ2dlciBmcm9tIC5hZGRFdmVudExpc3RlbmVyKCBlbGVtLCAndHlwZScgKVxudXRpbHMuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBtZXRob2QgPSAnb24nICsgZXZlbnQudHlwZTtcbiAgaWYgKCB0aGlzWyBtZXRob2QgXSApIHtcbiAgICB0aGlzWyBtZXRob2QgXSggZXZlbnQgKTtcbiAgfVxufTtcblxuLy8gLS0tLS0gZmlsdGVyRmluZEVsZW1lbnRzIC0tLS0tIC8vXG5cbnV0aWxzLmZpbHRlckZpbmRFbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVtcywgc2VsZWN0b3IgKSB7XG4gIC8vIG1ha2UgYXJyYXkgb2YgZWxlbXNcbiAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gIHZhciBmZkVsZW1zID0gW107XG5cbiAgZWxlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgLy8gY2hlY2sgdGhhdCBlbGVtIGlzIGFuIGFjdHVhbCBlbGVtZW50XG4gICAgaWYgKCAhKCBlbGVtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYWRkIGVsZW0gaWYgbm8gc2VsZWN0b3JcbiAgICBpZiAoICFzZWxlY3RvciApIHtcbiAgICAgIGZmRWxlbXMucHVzaCggZWxlbSApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBmaWx0ZXIgJiBmaW5kIGl0ZW1zIGlmIHdlIGhhdmUgYSBzZWxlY3RvclxuICAgIC8vIGZpbHRlclxuICAgIGlmICggbWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBzZWxlY3RvciApICkge1xuICAgICAgZmZFbGVtcy5wdXNoKCBlbGVtICk7XG4gICAgfVxuICAgIC8vIGZpbmQgY2hpbGRyZW5cbiAgICB2YXIgY2hpbGRFbGVtcyA9IGVsZW0ucXVlcnlTZWxlY3RvckFsbCggc2VsZWN0b3IgKTtcbiAgICAvLyBjb25jYXQgY2hpbGRFbGVtcyB0byBmaWx0ZXJGb3VuZCBhcnJheVxuICAgIGZvciAoIHZhciBpPTA7IGkgPCBjaGlsZEVsZW1zLmxlbmd0aDsgaSsrICkge1xuICAgICAgZmZFbGVtcy5wdXNoKCBjaGlsZEVsZW1zW2ldICk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmZFbGVtcztcbn07XG5cbi8vIC0tLS0tIGRlYm91bmNlTWV0aG9kIC0tLS0tIC8vXG5cbnV0aWxzLmRlYm91bmNlTWV0aG9kID0gZnVuY3Rpb24oIF9jbGFzcywgbWV0aG9kTmFtZSwgdGhyZXNob2xkICkge1xuICAvLyBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG1ldGhvZCA9IF9jbGFzcy5wcm90b3R5cGVbIG1ldGhvZE5hbWUgXTtcbiAgdmFyIHRpbWVvdXROYW1lID0gbWV0aG9kTmFtZSArICdUaW1lb3V0JztcblxuICBfY2xhc3MucHJvdG90eXBlWyBtZXRob2ROYW1lIF0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXNbIHRpbWVvdXROYW1lIF07XG4gICAgaWYgKCB0aW1lb3V0ICkge1xuICAgICAgY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzWyB0aW1lb3V0TmFtZSBdID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICBtZXRob2QuYXBwbHkoIF90aGlzLCBhcmdzICk7XG4gICAgICBkZWxldGUgX3RoaXNbIHRpbWVvdXROYW1lIF07XG4gICAgfSwgdGhyZXNob2xkIHx8IDEwMCApO1xuICB9O1xufTtcblxuLy8gLS0tLS0gZG9jUmVhZHkgLS0tLS0gLy9cblxudXRpbHMuZG9jUmVhZHkgPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG4gIHZhciByZWFkeVN0YXRlID0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgaWYgKCByZWFkeVN0YXRlID09ICdjb21wbGV0ZScgfHwgcmVhZHlTdGF0ZSA9PSAnaW50ZXJhY3RpdmUnICkge1xuICAgIGNhbGxiYWNrKCk7XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYWxsYmFjayApO1xuICB9XG59O1xuXG4vLyAtLS0tLSBodG1sSW5pdCAtLS0tLSAvL1xuXG4vLyBodHRwOi8vamFtZXNyb2JlcnRzLm5hbWUvYmxvZy8yMDEwLzAyLzIyL3N0cmluZy1mdW5jdGlvbnMtZm9yLWphdmFzY3JpcHQtdHJpbS10by1jYW1lbC1jYXNlLXRvLWRhc2hlZC1hbmQtdG8tdW5kZXJzY29yZS9cbnV0aWxzLnRvRGFzaGVkID0gZnVuY3Rpb24oIHN0ciApIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKCAvKC4pKFtBLVpdKS9nLCBmdW5jdGlvbiggbWF0Y2gsICQxLCAkMiApIHtcbiAgICByZXR1cm4gJDEgKyAnLScgKyAkMjtcbiAgfSkudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG4vKipcbiAqIGFsbG93IHVzZXIgdG8gaW5pdGlhbGl6ZSBjbGFzc2VzIHZpYSBbZGF0YS1uYW1lc3BhY2VdIG9yIC5qcy1uYW1lc3BhY2UgY2xhc3NcbiAqIGh0bWxJbml0KCBXaWRnZXQsICd3aWRnZXROYW1lJyApXG4gKiBvcHRpb25zIGFyZSBwYXJzZWQgZnJvbSBkYXRhLW5hbWVzcGFjZS1vcHRpb25zXG4gKi9cbnV0aWxzLmh0bWxJbml0ID0gZnVuY3Rpb24oIFdpZGdldENsYXNzLCBuYW1lc3BhY2UgKSB7XG4gIHV0aWxzLmRvY1JlYWR5KCBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGFzaGVkTmFtZXNwYWNlID0gdXRpbHMudG9EYXNoZWQoIG5hbWVzcGFjZSApO1xuICAgIHZhciBkYXRhQXR0ciA9ICdkYXRhLScgKyBkYXNoZWROYW1lc3BhY2U7XG4gICAgdmFyIGRhdGFBdHRyRWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCAnWycgKyBkYXRhQXR0ciArICddJyApO1xuICAgIHZhciBqc0Rhc2hFbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICcuanMtJyArIGRhc2hlZE5hbWVzcGFjZSApO1xuICAgIHZhciBlbGVtcyA9IHV0aWxzLm1ha2VBcnJheSggZGF0YUF0dHJFbGVtcyApXG4gICAgICAuY29uY2F0KCB1dGlscy5tYWtlQXJyYXkoIGpzRGFzaEVsZW1zICkgKTtcbiAgICB2YXIgZGF0YU9wdGlvbnNBdHRyID0gZGF0YUF0dHIgKyAnLW9wdGlvbnMnO1xuICAgIHZhciBqUXVlcnkgPSB3aW5kb3cualF1ZXJ5O1xuXG4gICAgZWxlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICB2YXIgYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKCBkYXRhQXR0ciApIHx8XG4gICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlKCBkYXRhT3B0aW9uc0F0dHIgKTtcbiAgICAgIHZhciBvcHRpb25zO1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3B0aW9ucyA9IGF0dHIgJiYgSlNPTi5wYXJzZSggYXR0ciApO1xuICAgICAgfSBjYXRjaCAoIGVycm9yICkge1xuICAgICAgICAvLyBsb2cgZXJyb3IsIGRvIG5vdCBpbml0aWFsaXplXG4gICAgICAgIGlmICggY29uc29sZSApIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCAnRXJyb3IgcGFyc2luZyAnICsgZGF0YUF0dHIgKyAnIG9uICcgKyBlbGVtLmNsYXNzTmFtZSArXG4gICAgICAgICAgJzogJyArIGVycm9yICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IFdpZGdldENsYXNzKCBlbGVtLCBvcHRpb25zICk7XG4gICAgICAvLyBtYWtlIGF2YWlsYWJsZSB2aWEgJCgpLmRhdGEoJ2xheW91dG5hbWUnKVxuICAgICAgaWYgKCBqUXVlcnkgKSB7XG4gICAgICAgIGpRdWVyeS5kYXRhKCBlbGVtLCBuYW1lc3BhY2UsIGluc3RhbmNlICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSk7XG59O1xuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxucmV0dXJuIHV0aWxzO1xuXG59KSk7XG5cbi8qKlxuICogT3V0bGF5ZXIgSXRlbVxuICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTUQgLSBSZXF1aXJlSlNcbiAgICBkZWZpbmUoICdvdXRsYXllci9pdGVtJyxbXG4gICAgICAgICdldi1lbWl0dGVyL2V2LWVtaXR0ZXInLFxuICAgICAgICAnZ2V0LXNpemUvZ2V0LXNpemUnXG4gICAgICBdLFxuICAgICAgZmFjdG9yeVxuICAgICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgcmVxdWlyZSgnZXYtZW1pdHRlcicpLFxuICAgICAgcmVxdWlyZSgnZ2V0LXNpemUnKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuT3V0bGF5ZXIgPSB7fTtcbiAgICB3aW5kb3cuT3V0bGF5ZXIuSXRlbSA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3cuRXZFbWl0dGVyLFxuICAgICAgd2luZG93LmdldFNpemVcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggRXZFbWl0dGVyLCBnZXRTaXplICkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLSBoZWxwZXJzIC0tLS0tIC8vXG5cbmZ1bmN0aW9uIGlzRW1wdHlPYmooIG9iaiApIHtcbiAgZm9yICggdmFyIHByb3AgaW4gb2JqICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwcm9wID0gbnVsbDtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIENTUzMgc3VwcG9ydCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5cbnZhciBkb2NFbGVtU3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cbnZhciB0cmFuc2l0aW9uUHJvcGVydHkgPSB0eXBlb2YgZG9jRWxlbVN0eWxlLnRyYW5zaXRpb24gPT0gJ3N0cmluZycgP1xuICAndHJhbnNpdGlvbicgOiAnV2Via2l0VHJhbnNpdGlvbic7XG52YXIgdHJhbnNmb3JtUHJvcGVydHkgPSB0eXBlb2YgZG9jRWxlbVN0eWxlLnRyYW5zZm9ybSA9PSAnc3RyaW5nJyA/XG4gICd0cmFuc2Zvcm0nIDogJ1dlYmtpdFRyYW5zZm9ybSc7XG5cbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSB7XG4gIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXG59WyB0cmFuc2l0aW9uUHJvcGVydHkgXTtcblxuLy8gY2FjaGUgYWxsIHZlbmRvciBwcm9wZXJ0aWVzIHRoYXQgY291bGQgaGF2ZSB2ZW5kb3IgcHJlZml4XG52YXIgdmVuZG9yUHJvcGVydGllcyA9IHtcbiAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1Qcm9wZXJ0eSxcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvblByb3BlcnR5LFxuICB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25Qcm9wZXJ0eSArICdEdXJhdGlvbicsXG4gIHRyYW5zaXRpb25Qcm9wZXJ0eTogdHJhbnNpdGlvblByb3BlcnR5ICsgJ1Byb3BlcnR5JyxcbiAgdHJhbnNpdGlvbkRlbGF5OiB0cmFuc2l0aW9uUHJvcGVydHkgKyAnRGVsYXknXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBJdGVtIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIEl0ZW0oIGVsZW1lbnQsIGxheW91dCApIHtcbiAgaWYgKCAhZWxlbWVudCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAvLyBwYXJlbnQgbGF5b3V0IGNsYXNzLCBpLmUuIE1hc29ucnksIElzb3RvcGUsIG9yIFBhY2tlcnlcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMucG9zaXRpb24gPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgdGhpcy5fY3JlYXRlKCk7XG59XG5cbi8vIGluaGVyaXQgRXZFbWl0dGVyXG52YXIgcHJvdG8gPSBJdGVtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2RW1pdHRlci5wcm90b3R5cGUgKTtcbnByb3RvLmNvbnN0cnVjdG9yID0gSXRlbTtcblxucHJvdG8uX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyB0cmFuc2l0aW9uIG9iamVjdHNcbiAgdGhpcy5fdHJhbnNuID0ge1xuICAgIGluZ1Byb3BlcnRpZXM6IHt9LFxuICAgIGNsZWFuOiB7fSxcbiAgICBvbkVuZDoge31cbiAgfTtcblxuICB0aGlzLmNzcyh7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgfSk7XG59O1xuXG4vLyB0cmlnZ2VyIHNwZWNpZmllZCBoYW5kbGVyIGZvciBldmVudCB0eXBlXG5wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIG1ldGhvZCA9ICdvbicgKyBldmVudC50eXBlO1xuICBpZiAoIHRoaXNbIG1ldGhvZCBdICkge1xuICAgIHRoaXNbIG1ldGhvZCBdKCBldmVudCApO1xuICB9XG59O1xuXG5wcm90by5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xufTtcblxuLyoqXG4gKiBhcHBseSBDU1Mgc3R5bGVzIHRvIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICovXG5wcm90by5jc3MgPSBmdW5jdGlvbiggc3R5bGUgKSB7XG4gIHZhciBlbGVtU3R5bGUgPSB0aGlzLmVsZW1lbnQuc3R5bGU7XG5cbiAgZm9yICggdmFyIHByb3AgaW4gc3R5bGUgKSB7XG4gICAgLy8gdXNlIHZlbmRvciBwcm9wZXJ0eSBpZiBhdmFpbGFibGVcbiAgICB2YXIgc3VwcG9ydGVkUHJvcCA9IHZlbmRvclByb3BlcnRpZXNbIHByb3AgXSB8fCBwcm9wO1xuICAgIGVsZW1TdHlsZVsgc3VwcG9ydGVkUHJvcCBdID0gc3R5bGVbIHByb3AgXTtcbiAgfVxufTtcblxuIC8vIG1lYXN1cmUgcG9zaXRpb24sIGFuZCBzZXRzIGl0XG5wcm90by5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0aGlzLmVsZW1lbnQgKTtcbiAgdmFyIGlzT3JpZ2luTGVmdCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpbkxlZnQnKTtcbiAgdmFyIGlzT3JpZ2luVG9wID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luVG9wJyk7XG4gIHZhciB4VmFsdWUgPSBzdHlsZVsgaXNPcmlnaW5MZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JyBdO1xuICB2YXIgeVZhbHVlID0gc3R5bGVbIGlzT3JpZ2luVG9wID8gJ3RvcCcgOiAnYm90dG9tJyBdO1xuICAvLyBjb252ZXJ0IHBlcmNlbnQgdG8gcGl4ZWxzXG4gIHZhciBsYXlvdXRTaXplID0gdGhpcy5sYXlvdXQuc2l6ZTtcbiAgdmFyIHggPSB4VmFsdWUuaW5kZXhPZignJScpICE9IC0xID9cbiAgICAoIHBhcnNlRmxvYXQoIHhWYWx1ZSApIC8gMTAwICkgKiBsYXlvdXRTaXplLndpZHRoIDogcGFyc2VJbnQoIHhWYWx1ZSwgMTAgKTtcbiAgdmFyIHkgPSB5VmFsdWUuaW5kZXhPZignJScpICE9IC0xID9cbiAgICAoIHBhcnNlRmxvYXQoIHlWYWx1ZSApIC8gMTAwICkgKiBsYXlvdXRTaXplLmhlaWdodCA6IHBhcnNlSW50KCB5VmFsdWUsIDEwICk7XG5cbiAgLy8gY2xlYW4gdXAgJ2F1dG8nIG9yIG90aGVyIG5vbi1pbnRlZ2VyIHZhbHVlc1xuICB4ID0gaXNOYU4oIHggKSA/IDAgOiB4O1xuICB5ID0gaXNOYU4oIHkgKSA/IDAgOiB5O1xuICAvLyByZW1vdmUgcGFkZGluZyBmcm9tIG1lYXN1cmVtZW50XG4gIHggLT0gaXNPcmlnaW5MZWZ0ID8gbGF5b3V0U2l6ZS5wYWRkaW5nTGVmdCA6IGxheW91dFNpemUucGFkZGluZ1JpZ2h0O1xuICB5IC09IGlzT3JpZ2luVG9wID8gbGF5b3V0U2l6ZS5wYWRkaW5nVG9wIDogbGF5b3V0U2l6ZS5wYWRkaW5nQm90dG9tO1xuXG4gIHRoaXMucG9zaXRpb24ueCA9IHg7XG4gIHRoaXMucG9zaXRpb24ueSA9IHk7XG59O1xuXG4vLyBzZXQgc2V0dGxlZCBwb3NpdGlvbiwgYXBwbHkgcGFkZGluZ1xucHJvdG8ubGF5b3V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxheW91dFNpemUgPSB0aGlzLmxheW91dC5zaXplO1xuICB2YXIgc3R5bGUgPSB7fTtcbiAgdmFyIGlzT3JpZ2luTGVmdCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpbkxlZnQnKTtcbiAgdmFyIGlzT3JpZ2luVG9wID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luVG9wJyk7XG5cbiAgLy8geFxuICB2YXIgeFBhZGRpbmcgPSBpc09yaWdpbkxlZnQgPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gIHZhciB4UHJvcGVydHkgPSBpc09yaWdpbkxlZnQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB2YXIgeFJlc2V0UHJvcGVydHkgPSBpc09yaWdpbkxlZnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuXG4gIHZhciB4ID0gdGhpcy5wb3NpdGlvbi54ICsgbGF5b3V0U2l6ZVsgeFBhZGRpbmcgXTtcbiAgLy8gc2V0IGluIHBlcmNlbnRhZ2Ugb3IgcGl4ZWxzXG4gIHN0eWxlWyB4UHJvcGVydHkgXSA9IHRoaXMuZ2V0WFZhbHVlKCB4ICk7XG4gIC8vIHJlc2V0IG90aGVyIHByb3BlcnR5XG4gIHN0eWxlWyB4UmVzZXRQcm9wZXJ0eSBdID0gJyc7XG5cbiAgLy8geVxuICB2YXIgeVBhZGRpbmcgPSBpc09yaWdpblRvcCA/ICdwYWRkaW5nVG9wJyA6ICdwYWRkaW5nQm90dG9tJztcbiAgdmFyIHlQcm9wZXJ0eSA9IGlzT3JpZ2luVG9wID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHlSZXNldFByb3BlcnR5ID0gaXNPcmlnaW5Ub3AgPyAnYm90dG9tJyA6ICd0b3AnO1xuXG4gIHZhciB5ID0gdGhpcy5wb3NpdGlvbi55ICsgbGF5b3V0U2l6ZVsgeVBhZGRpbmcgXTtcbiAgLy8gc2V0IGluIHBlcmNlbnRhZ2Ugb3IgcGl4ZWxzXG4gIHN0eWxlWyB5UHJvcGVydHkgXSA9IHRoaXMuZ2V0WVZhbHVlKCB5ICk7XG4gIC8vIHJlc2V0IG90aGVyIHByb3BlcnR5XG4gIHN0eWxlWyB5UmVzZXRQcm9wZXJ0eSBdID0gJyc7XG5cbiAgdGhpcy5jc3MoIHN0eWxlICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAnbGF5b3V0JywgWyB0aGlzIF0gKTtcbn07XG5cbnByb3RvLmdldFhWYWx1ZSA9IGZ1bmN0aW9uKCB4ICkge1xuICB2YXIgaXNIb3Jpem9udGFsID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignaG9yaXpvbnRhbCcpO1xuICByZXR1cm4gdGhpcy5sYXlvdXQub3B0aW9ucy5wZXJjZW50UG9zaXRpb24gJiYgIWlzSG9yaXpvbnRhbCA/XG4gICAgKCAoIHggLyB0aGlzLmxheW91dC5zaXplLndpZHRoICkgKiAxMDAgKSArICclJyA6IHggKyAncHgnO1xufTtcblxucHJvdG8uZ2V0WVZhbHVlID0gZnVuY3Rpb24oIHkgKSB7XG4gIHZhciBpc0hvcml6b250YWwgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdob3Jpem9udGFsJyk7XG4gIHJldHVybiB0aGlzLmxheW91dC5vcHRpb25zLnBlcmNlbnRQb3NpdGlvbiAmJiBpc0hvcml6b250YWwgP1xuICAgICggKCB5IC8gdGhpcy5sYXlvdXQuc2l6ZS5oZWlnaHQgKSAqIDEwMCApICsgJyUnIDogeSArICdweCc7XG59O1xuXG5wcm90by5fdHJhbnNpdGlvblRvID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gIHRoaXMuZ2V0UG9zaXRpb24oKTtcbiAgLy8gZ2V0IGN1cnJlbnQgeCAmIHkgZnJvbSB0b3AvbGVmdFxuICB2YXIgY3VyWCA9IHRoaXMucG9zaXRpb24ueDtcbiAgdmFyIGN1clkgPSB0aGlzLnBvc2l0aW9uLnk7XG5cbiAgdmFyIGNvbXBhcmVYID0gcGFyc2VJbnQoIHgsIDEwICk7XG4gIHZhciBjb21wYXJlWSA9IHBhcnNlSW50KCB5LCAxMCApO1xuICB2YXIgZGlkTm90TW92ZSA9IGNvbXBhcmVYID09PSB0aGlzLnBvc2l0aW9uLnggJiYgY29tcGFyZVkgPT09IHRoaXMucG9zaXRpb24ueTtcblxuICAvLyBzYXZlIGVuZCBwb3NpdGlvblxuICB0aGlzLnNldFBvc2l0aW9uKCB4LCB5ICk7XG5cbiAgLy8gaWYgZGlkIG5vdCBtb3ZlIGFuZCBub3QgdHJhbnNpdGlvbmluZywganVzdCBnbyB0byBsYXlvdXRcbiAgaWYgKCBkaWROb3RNb3ZlICYmICF0aGlzLmlzVHJhbnNpdGlvbmluZyApIHtcbiAgICB0aGlzLmxheW91dFBvc2l0aW9uKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRyYW5zWCA9IHggLSBjdXJYO1xuICB2YXIgdHJhbnNZID0geSAtIGN1clk7XG4gIHZhciB0cmFuc2l0aW9uU3R5bGUgPSB7fTtcbiAgdHJhbnNpdGlvblN0eWxlLnRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNsYXRlKCB0cmFuc1gsIHRyYW5zWSApO1xuXG4gIHRoaXMudHJhbnNpdGlvbih7XG4gICAgdG86IHRyYW5zaXRpb25TdHlsZSxcbiAgICBvblRyYW5zaXRpb25FbmQ6IHtcbiAgICAgIHRyYW5zZm9ybTogdGhpcy5sYXlvdXRQb3NpdGlvblxuICAgIH0sXG4gICAgaXNDbGVhbmluZzogdHJ1ZVxuICB9KTtcbn07XG5cbnByb3RvLmdldFRyYW5zbGF0ZSA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuICAvLyBmbGlwIGNvb3JpZGluYXRlcyBpZiBvcmlnaW4gb24gcmlnaHQgb3IgYm90dG9tXG4gIHZhciBpc09yaWdpbkxlZnQgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5MZWZ0Jyk7XG4gIHZhciBpc09yaWdpblRvcCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpblRvcCcpO1xuICB4ID0gaXNPcmlnaW5MZWZ0ID8geCA6IC14O1xuICB5ID0gaXNPcmlnaW5Ub3AgPyB5IDogLXk7XG4gIHJldHVybiAndHJhbnNsYXRlM2QoJyArIHggKyAncHgsICcgKyB5ICsgJ3B4LCAwKSc7XG59O1xuXG4vLyBub24gdHJhbnNpdGlvbiArIHRyYW5zZm9ybSBzdXBwb3J0XG5wcm90by5nb1RvID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gIHRoaXMuc2V0UG9zaXRpb24oIHgsIHkgKTtcbiAgdGhpcy5sYXlvdXRQb3NpdGlvbigpO1xufTtcblxucHJvdG8ubW92ZVRvID0gcHJvdG8uX3RyYW5zaXRpb25UbztcblxucHJvdG8uc2V0UG9zaXRpb24gPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgdGhpcy5wb3NpdGlvbi54ID0gcGFyc2VJbnQoIHgsIDEwICk7XG4gIHRoaXMucG9zaXRpb24ueSA9IHBhcnNlSW50KCB5LCAxMCApO1xufTtcblxuLy8gLS0tLS0gdHJhbnNpdGlvbiAtLS0tLSAvL1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSAtIENTU1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb25UcmFuc2l0aW9uRW5kXG4gKi9cblxuLy8gbm9uIHRyYW5zaXRpb24sIGp1c3QgdHJpZ2dlciBjYWxsYmFja1xucHJvdG8uX25vblRyYW5zaXRpb24gPSBmdW5jdGlvbiggYXJncyApIHtcbiAgdGhpcy5jc3MoIGFyZ3MudG8gKTtcbiAgaWYgKCBhcmdzLmlzQ2xlYW5pbmcgKSB7XG4gICAgdGhpcy5fcmVtb3ZlU3R5bGVzKCBhcmdzLnRvICk7XG4gIH1cbiAgZm9yICggdmFyIHByb3AgaW4gYXJncy5vblRyYW5zaXRpb25FbmQgKSB7XG4gICAgYXJncy5vblRyYW5zaXRpb25FbmRbIHByb3AgXS5jYWxsKCB0aGlzICk7XG4gIH1cbn07XG5cbi8qKlxuICogcHJvcGVyIHRyYW5zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gYXJndW1lbnRzXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSB0byAtIHN0eWxlIHRvIHRyYW5zaXRpb24gdG9cbiAqICAgQHBhcmFtIHtPYmplY3R9IGZyb20gLSBzdHlsZSB0byBzdGFydCB0cmFuc2l0aW9uIGZyb21cbiAqICAgQHBhcmFtIHtCb29sZWFufSBpc0NsZWFuaW5nIC0gcmVtb3ZlcyB0cmFuc2l0aW9uIHN0eWxlcyBhZnRlciB0cmFuc2l0aW9uXG4gKiAgIEBwYXJhbSB7RnVuY3Rpb259IG9uVHJhbnNpdGlvbkVuZCAtIGNhbGxiYWNrXG4gKi9cbnByb3RvLnRyYW5zaXRpb24gPSBmdW5jdGlvbiggYXJncyApIHtcbiAgLy8gcmVkaXJlY3QgdG8gbm9uVHJhbnNpdGlvbiBpZiBubyB0cmFuc2l0aW9uIGR1cmF0aW9uXG4gIGlmICggIXBhcnNlRmxvYXQoIHRoaXMubGF5b3V0Lm9wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uICkgKSB7XG4gICAgdGhpcy5fbm9uVHJhbnNpdGlvbiggYXJncyApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfdHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zbjtcbiAgLy8ga2VlcCB0cmFjayBvZiBvblRyYW5zaXRpb25FbmQgY2FsbGJhY2sgYnkgY3NzIHByb3BlcnR5XG4gIGZvciAoIHZhciBwcm9wIGluIGFyZ3Mub25UcmFuc2l0aW9uRW5kICkge1xuICAgIF90cmFuc2l0aW9uLm9uRW5kWyBwcm9wIF0gPSBhcmdzLm9uVHJhbnNpdGlvbkVuZFsgcHJvcCBdO1xuICB9XG4gIC8vIGtlZXAgdHJhY2sgb2YgcHJvcGVydGllcyB0aGF0IGFyZSB0cmFuc2l0aW9uaW5nXG4gIGZvciAoIHByb3AgaW4gYXJncy50byApIHtcbiAgICBfdHJhbnNpdGlvbi5pbmdQcm9wZXJ0aWVzWyBwcm9wIF0gPSB0cnVlO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgcHJvcGVydGllcyB0byBjbGVhbiB1cCB3aGVuIHRyYW5zaXRpb24gaXMgZG9uZVxuICAgIGlmICggYXJncy5pc0NsZWFuaW5nICkge1xuICAgICAgX3RyYW5zaXRpb24uY2xlYW5bIHByb3AgXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IGZyb20gc3R5bGVzXG4gIGlmICggYXJncy5mcm9tICkge1xuICAgIHRoaXMuY3NzKCBhcmdzLmZyb20gKTtcbiAgICAvLyBmb3JjZSByZWRyYXcuIGh0dHA6Ly9ibG9nLmFsZXhtYWNjYXcuY29tL2Nzcy10cmFuc2l0aW9uc1xuICAgIHZhciBoID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAvLyBoYWNrIGZvciBKU0hpbnQgdG8gaHVzaCBhYm91dCB1bnVzZWQgdmFyXG4gICAgaCA9IG51bGw7XG4gIH1cbiAgLy8gZW5hYmxlIHRyYW5zaXRpb25cbiAgdGhpcy5lbmFibGVUcmFuc2l0aW9uKCBhcmdzLnRvICk7XG4gIC8vIHNldCBzdHlsZXMgdGhhdCBhcmUgdHJhbnNpdGlvbmluZ1xuICB0aGlzLmNzcyggYXJncy50byApO1xuXG4gIHRoaXMuaXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxufTtcblxuLy8gZGFzaCBiZWZvcmUgYWxsIGNhcCBsZXR0ZXJzLCBpbmNsdWRpbmcgZmlyc3QgZm9yXG4vLyBXZWJraXRUcmFuc2Zvcm0gPT4gLXdlYmtpdC10cmFuc2Zvcm1cbmZ1bmN0aW9uIHRvRGFzaGVkQWxsKCBzdHIgKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSggLyhbQS1aXSkvZywgZnVuY3Rpb24oICQxICkge1xuICAgIHJldHVybiAnLScgKyAkMS50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn1cblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9ICdvcGFjaXR5LCcgKyB0b0Rhc2hlZEFsbCggdHJhbnNmb3JtUHJvcGVydHkgKTtcblxucHJvdG8uZW5hYmxlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKC8qIHN0eWxlICovKSB7XG4gIC8vIEhBQ0sgY2hhbmdpbmcgdHJhbnNpdGlvblByb3BlcnR5IGR1cmluZyBhIHRyYW5zaXRpb25cbiAgLy8gd2lsbCBjYXVzZSB0cmFuc2l0aW9uIHRvIGp1bXBcbiAgaWYgKCB0aGlzLmlzVHJhbnNpdGlvbmluZyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBtYWtlIGB0cmFuc2l0aW9uOiBmb28sIGJhciwgYmF6YCBmcm9tIHN0eWxlIG9iamVjdFxuICAvLyBIQUNLIHVuLWNvbW1lbnQgdGhpcyB3aGVuIGVuYWJsZVRyYW5zaXRpb24gY2FuIHdvcmtcbiAgLy8gd2hpbGUgYSB0cmFuc2l0aW9uIGlzIGhhcHBlbmluZ1xuICAvLyB2YXIgdHJhbnNpdGlvblZhbHVlcyA9IFtdO1xuICAvLyBmb3IgKCB2YXIgcHJvcCBpbiBzdHlsZSApIHtcbiAgLy8gICAvLyBkYXNoLWlmeSBjYW1lbENhc2VkIHByb3BlcnRpZXMgbGlrZSBXZWJraXRUcmFuc2l0aW9uXG4gIC8vICAgcHJvcCA9IHZlbmRvclByb3BlcnRpZXNbIHByb3AgXSB8fCBwcm9wO1xuICAvLyAgIHRyYW5zaXRpb25WYWx1ZXMucHVzaCggdG9EYXNoZWRBbGwoIHByb3AgKSApO1xuICAvLyB9XG4gIC8vIG11bmdlIG51bWJlciB0byBtaWxsaXNlY29uZCwgdG8gbWF0Y2ggc3RhZ2dlclxuICB2YXIgZHVyYXRpb24gPSB0aGlzLmxheW91dC5vcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgZHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT0gJ251bWJlcicgPyBkdXJhdGlvbiArICdtcycgOiBkdXJhdGlvbjtcbiAgLy8gZW5hYmxlIHRyYW5zaXRpb24gc3R5bGVzXG4gIHRoaXMuY3NzKHtcbiAgICB0cmFuc2l0aW9uUHJvcGVydHk6IHRyYW5zaXRpb25Qcm9wcyxcbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IGR1cmF0aW9uLFxuICAgIHRyYW5zaXRpb25EZWxheTogdGhpcy5zdGFnZ2VyRGVsYXkgfHwgMFxuICB9KTtcbiAgLy8gbGlzdGVuIGZvciB0cmFuc2l0aW9uIGVuZCBldmVudFxuICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHJhbnNpdGlvbkVuZEV2ZW50LCB0aGlzLCBmYWxzZSApO1xufTtcblxuLy8gLS0tLS0gZXZlbnRzIC0tLS0tIC8vXG5cbnByb3RvLm9ud2Via2l0VHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5vbnRyYW5zaXRpb25lbmQoIGV2ZW50ICk7XG59O1xuXG5wcm90by5vbm90cmFuc2l0aW9uZW5kID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLm9udHJhbnNpdGlvbmVuZCggZXZlbnQgKTtcbn07XG5cbi8vIHByb3BlcnRpZXMgdGhhdCBJIG11bmdlIHRvIG1ha2UgbXkgbGlmZSBlYXNpZXJcbnZhciBkYXNoZWRWZW5kb3JQcm9wZXJ0aWVzID0ge1xuICAnLXdlYmtpdC10cmFuc2Zvcm0nOiAndHJhbnNmb3JtJ1xufTtcblxucHJvdG8ub250cmFuc2l0aW9uZW5kID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICAvLyBkaXNyZWdhcmQgYnViYmxlZCBldmVudHMgZnJvbSBjaGlsZHJlblxuICBpZiAoIGV2ZW50LnRhcmdldCAhPT0gdGhpcy5lbGVtZW50ICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgX3RyYW5zaXRpb24gPSB0aGlzLl90cmFuc247XG4gIC8vIGdldCBwcm9wZXJ0eSBuYW1lIG9mIHRyYW5zaXRpb25lZCBwcm9wZXJ0eSwgY29udmVydCB0byBwcmVmaXgtZnJlZVxuICB2YXIgcHJvcGVydHlOYW1lID0gZGFzaGVkVmVuZG9yUHJvcGVydGllc1sgZXZlbnQucHJvcGVydHlOYW1lIF0gfHwgZXZlbnQucHJvcGVydHlOYW1lO1xuXG4gIC8vIHJlbW92ZSBwcm9wZXJ0eSB0aGF0IGhhcyBjb21wbGV0ZWQgdHJhbnNpdGlvbmluZ1xuICBkZWxldGUgX3RyYW5zaXRpb24uaW5nUHJvcGVydGllc1sgcHJvcGVydHlOYW1lIF07XG4gIC8vIGNoZWNrIGlmIGFueSBwcm9wZXJ0aWVzIGFyZSBzdGlsbCB0cmFuc2l0aW9uaW5nXG4gIGlmICggaXNFbXB0eU9iaiggX3RyYW5zaXRpb24uaW5nUHJvcGVydGllcyApICkge1xuICAgIC8vIGFsbCBwcm9wZXJ0aWVzIGhhdmUgY29tcGxldGVkIHRyYW5zaXRpb25pbmdcbiAgICB0aGlzLmRpc2FibGVUcmFuc2l0aW9uKCk7XG4gIH1cbiAgLy8gY2xlYW4gc3R5bGVcbiAgaWYgKCBwcm9wZXJ0eU5hbWUgaW4gX3RyYW5zaXRpb24uY2xlYW4gKSB7XG4gICAgLy8gY2xlYW4gdXAgc3R5bGVcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGVbIGV2ZW50LnByb3BlcnR5TmFtZSBdID0gJyc7XG4gICAgZGVsZXRlIF90cmFuc2l0aW9uLmNsZWFuWyBwcm9wZXJ0eU5hbWUgXTtcbiAgfVxuICAvLyB0cmlnZ2VyIG9uVHJhbnNpdGlvbkVuZCBjYWxsYmFja1xuICBpZiAoIHByb3BlcnR5TmFtZSBpbiBfdHJhbnNpdGlvbi5vbkVuZCApIHtcbiAgICB2YXIgb25UcmFuc2l0aW9uRW5kID0gX3RyYW5zaXRpb24ub25FbmRbIHByb3BlcnR5TmFtZSBdO1xuICAgIG9uVHJhbnNpdGlvbkVuZC5jYWxsKCB0aGlzICk7XG4gICAgZGVsZXRlIF90cmFuc2l0aW9uLm9uRW5kWyBwcm9wZXJ0eU5hbWUgXTtcbiAgfVxuXG4gIHRoaXMuZW1pdEV2ZW50KCAndHJhbnNpdGlvbkVuZCcsIFsgdGhpcyBdICk7XG59O1xuXG5wcm90by5kaXNhYmxlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZVRyYW5zaXRpb25TdHlsZXMoKTtcbiAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHRyYW5zaXRpb25FbmRFdmVudCwgdGhpcywgZmFsc2UgKTtcbiAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogcmVtb3ZlcyBzdHlsZSBwcm9wZXJ0eSBmcm9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuKiovXG5wcm90by5fcmVtb3ZlU3R5bGVzID0gZnVuY3Rpb24oIHN0eWxlICkge1xuICAvLyBjbGVhbiB1cCB0cmFuc2l0aW9uIHN0eWxlc1xuICB2YXIgY2xlYW5TdHlsZSA9IHt9O1xuICBmb3IgKCB2YXIgcHJvcCBpbiBzdHlsZSApIHtcbiAgICBjbGVhblN0eWxlWyBwcm9wIF0gPSAnJztcbiAgfVxuICB0aGlzLmNzcyggY2xlYW5TdHlsZSApO1xufTtcblxudmFyIGNsZWFuVHJhbnNpdGlvblN0eWxlID0ge1xuICB0cmFuc2l0aW9uUHJvcGVydHk6ICcnLFxuICB0cmFuc2l0aW9uRHVyYXRpb246ICcnLFxuICB0cmFuc2l0aW9uRGVsYXk6ICcnXG59O1xuXG5wcm90by5yZW1vdmVUcmFuc2l0aW9uU3R5bGVzID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJlbW92ZSB0cmFuc2l0aW9uXG4gIHRoaXMuY3NzKCBjbGVhblRyYW5zaXRpb25TdHlsZSApO1xufTtcblxuLy8gLS0tLS0gc3RhZ2dlciAtLS0tLSAvL1xuXG5wcm90by5zdGFnZ2VyID0gZnVuY3Rpb24oIGRlbGF5ICkge1xuICBkZWxheSA9IGlzTmFOKCBkZWxheSApID8gMCA6IGRlbGF5O1xuICB0aGlzLnN0YWdnZXJEZWxheSA9IGRlbGF5ICsgJ21zJztcbn07XG5cbi8vIC0tLS0tIHNob3cvaGlkZS9yZW1vdmUgLS0tLS0gLy9cblxuLy8gcmVtb3ZlIGVsZW1lbnQgZnJvbSBET01cbnByb3RvLnJlbW92ZUVsZW0gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRoaXMuZWxlbWVudCApO1xuICAvLyByZW1vdmUgZGlzcGxheTogbm9uZVxuICB0aGlzLmNzcyh7IGRpc3BsYXk6ICcnIH0pO1xuICB0aGlzLmVtaXRFdmVudCggJ3JlbW92ZScsIFsgdGhpcyBdICk7XG59O1xuXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgLy8ganVzdCByZW1vdmUgZWxlbWVudCBpZiBubyB0cmFuc2l0aW9uIHN1cHBvcnQgb3Igbm8gdHJhbnNpdGlvblxuICBpZiAoICF0cmFuc2l0aW9uUHJvcGVydHkgfHwgIXBhcnNlRmxvYXQoIHRoaXMubGF5b3V0Lm9wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uICkgKSB7XG4gICAgdGhpcy5yZW1vdmVFbGVtKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc3RhcnQgdHJhbnNpdGlvblxuICB0aGlzLm9uY2UoICd0cmFuc2l0aW9uRW5kJywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVFbGVtKCk7XG4gIH0pO1xuICB0aGlzLmhpZGUoKTtcbn07XG5cbnByb3RvLnJldmVhbCA9IGZ1bmN0aW9uKCkge1xuICBkZWxldGUgdGhpcy5pc0hpZGRlbjtcbiAgLy8gcmVtb3ZlIGRpc3BsYXk6IG5vbmVcbiAgdGhpcy5jc3MoeyBkaXNwbGF5OiAnJyB9KTtcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMubGF5b3V0Lm9wdGlvbnM7XG5cbiAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IHt9O1xuICB2YXIgdHJhbnNpdGlvbkVuZFByb3BlcnR5ID0gdGhpcy5nZXRIaWRlUmV2ZWFsVHJhbnNpdGlvbkVuZFByb3BlcnR5KCd2aXNpYmxlU3R5bGUnKTtcbiAgb25UcmFuc2l0aW9uRW5kWyB0cmFuc2l0aW9uRW5kUHJvcGVydHkgXSA9IHRoaXMub25SZXZlYWxUcmFuc2l0aW9uRW5kO1xuXG4gIHRoaXMudHJhbnNpdGlvbih7XG4gICAgZnJvbTogb3B0aW9ucy5oaWRkZW5TdHlsZSxcbiAgICB0bzogb3B0aW9ucy52aXNpYmxlU3R5bGUsXG4gICAgaXNDbGVhbmluZzogdHJ1ZSxcbiAgICBvblRyYW5zaXRpb25FbmQ6IG9uVHJhbnNpdGlvbkVuZFxuICB9KTtcbn07XG5cbnByb3RvLm9uUmV2ZWFsVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKCkge1xuICAvLyBjaGVjayBpZiBzdGlsbCB2aXNpYmxlXG4gIC8vIGR1cmluZyB0cmFuc2l0aW9uLCBpdGVtIG1heSBoYXZlIGJlZW4gaGlkZGVuXG4gIGlmICggIXRoaXMuaXNIaWRkZW4gKSB7XG4gICAgdGhpcy5lbWl0RXZlbnQoJ3JldmVhbCcpO1xuICB9XG59O1xuXG4vKipcbiAqIGdldCBzdHlsZSBwcm9wZXJ0eSB1c2UgZm9yIGhpZGUvcmV2ZWFsIHRyYW5zaXRpb24gZW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gc3R5bGVQcm9wZXJ0eSAtIGhpZGRlblN0eWxlL3Zpc2libGVTdHlsZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xucHJvdG8uZ2V0SGlkZVJldmVhbFRyYW5zaXRpb25FbmRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBzdHlsZVByb3BlcnR5ICkge1xuICB2YXIgb3B0aW9uU3R5bGUgPSB0aGlzLmxheW91dC5vcHRpb25zWyBzdHlsZVByb3BlcnR5IF07XG4gIC8vIHVzZSBvcGFjaXR5XG4gIGlmICggb3B0aW9uU3R5bGUub3BhY2l0eSApIHtcbiAgICByZXR1cm4gJ29wYWNpdHknO1xuICB9XG4gIC8vIGdldCBmaXJzdCBwcm9wZXJ0eVxuICBmb3IgKCB2YXIgcHJvcCBpbiBvcHRpb25TdHlsZSApIHtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxucHJvdG8uaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBzZXQgZmxhZ1xuICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcbiAgLy8gcmVtb3ZlIGRpc3BsYXk6IG5vbmVcbiAgdGhpcy5jc3MoeyBkaXNwbGF5OiAnJyB9KTtcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMubGF5b3V0Lm9wdGlvbnM7XG5cbiAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IHt9O1xuICB2YXIgdHJhbnNpdGlvbkVuZFByb3BlcnR5ID0gdGhpcy5nZXRIaWRlUmV2ZWFsVHJhbnNpdGlvbkVuZFByb3BlcnR5KCdoaWRkZW5TdHlsZScpO1xuICBvblRyYW5zaXRpb25FbmRbIHRyYW5zaXRpb25FbmRQcm9wZXJ0eSBdID0gdGhpcy5vbkhpZGVUcmFuc2l0aW9uRW5kO1xuXG4gIHRoaXMudHJhbnNpdGlvbih7XG4gICAgZnJvbTogb3B0aW9ucy52aXNpYmxlU3R5bGUsXG4gICAgdG86IG9wdGlvbnMuaGlkZGVuU3R5bGUsXG4gICAgLy8ga2VlcCBoaWRkZW4gc3R1ZmYgaGlkZGVuXG4gICAgaXNDbGVhbmluZzogdHJ1ZSxcbiAgICBvblRyYW5zaXRpb25FbmQ6IG9uVHJhbnNpdGlvbkVuZFxuICB9KTtcbn07XG5cbnByb3RvLm9uSGlkZVRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbigpIHtcbiAgLy8gY2hlY2sgaWYgc3RpbGwgaGlkZGVuXG4gIC8vIGR1cmluZyB0cmFuc2l0aW9uLCBpdGVtIG1heSBoYXZlIGJlZW4gdW4taGlkZGVuXG4gIGlmICggdGhpcy5pc0hpZGRlbiApIHtcbiAgICB0aGlzLmNzcyh7IGRpc3BsYXk6ICdub25lJyB9KTtcbiAgICB0aGlzLmVtaXRFdmVudCgnaGlkZScpO1xuICB9XG59O1xuXG5wcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3NzKHtcbiAgICBwb3NpdGlvbjogJycsXG4gICAgbGVmdDogJycsXG4gICAgcmlnaHQ6ICcnLFxuICAgIHRvcDogJycsXG4gICAgYm90dG9tOiAnJyxcbiAgICB0cmFuc2l0aW9uOiAnJyxcbiAgICB0cmFuc2Zvcm06ICcnXG4gIH0pO1xufTtcblxucmV0dXJuIEl0ZW07XG5cbn0pKTtcblxuLyohXG4gKiBPdXRsYXllciB2Mi4xLjBcbiAqIHRoZSBicmFpbnMgYW5kIGd1dHMgb2YgYSBsYXlvdXQgbGlicmFyeVxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTUQgLSBSZXF1aXJlSlNcbiAgICBkZWZpbmUoICdvdXRsYXllci9vdXRsYXllcicsW1xuICAgICAgICAnZXYtZW1pdHRlci9ldi1lbWl0dGVyJyxcbiAgICAgICAgJ2dldC1zaXplL2dldC1zaXplJyxcbiAgICAgICAgJ2Zpenp5LXVpLXV0aWxzL3V0aWxzJyxcbiAgICAgICAgJy4vaXRlbSdcbiAgICAgIF0sXG4gICAgICBmdW5jdGlvbiggRXZFbWl0dGVyLCBnZXRTaXplLCB1dGlscywgSXRlbSApIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyLCBnZXRTaXplLCB1dGlscywgSXRlbSk7XG4gICAgICB9XG4gICAgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KUyAtIEJyb3dzZXJpZnksIFdlYnBhY2tcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCdldi1lbWl0dGVyJyksXG4gICAgICByZXF1aXJlKCdnZXQtc2l6ZScpLFxuICAgICAgcmVxdWlyZSgnZml6enktdWktdXRpbHMnKSxcbiAgICAgIHJlcXVpcmUoJy4vaXRlbScpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5PdXRsYXllciA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuRXZFbWl0dGVyLFxuICAgICAgd2luZG93LmdldFNpemUsXG4gICAgICB3aW5kb3cuZml6enlVSVV0aWxzLFxuICAgICAgd2luZG93Lk91dGxheWVyLkl0ZW1cbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIsIGdldFNpemUsIHV0aWxzLCBJdGVtICkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLSB2YXJzIC0tLS0tIC8vXG5cbnZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG52YXIgalF1ZXJ5ID0gd2luZG93LmpRdWVyeTtcbnZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gT3V0bGF5ZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gZ2xvYmFsbHkgdW5pcXVlIGlkZW50aWZpZXJzXG52YXIgR1VJRCA9IDA7XG4vLyBpbnRlcm5hbCBzdG9yZSBvZiBhbGwgT3V0bGF5ZXIgaW50YW5jZXNcbnZhciBpbnN0YW5jZXMgPSB7fTtcblxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCwgU3RyaW5nfSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE91dGxheWVyKCBlbGVtZW50LCBvcHRpb25zICkge1xuICB2YXIgcXVlcnlFbGVtZW50ID0gdXRpbHMuZ2V0UXVlcnlFbGVtZW50KCBlbGVtZW50ICk7XG4gIGlmICggIXF1ZXJ5RWxlbWVudCApIHtcbiAgICBpZiAoIGNvbnNvbGUgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCAnQmFkIGVsZW1lbnQgZm9yICcgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWVzcGFjZSArXG4gICAgICAgICc6ICcgKyAoIHF1ZXJ5RWxlbWVudCB8fCBlbGVtZW50ICkgKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuZWxlbWVudCA9IHF1ZXJ5RWxlbWVudDtcbiAgLy8gYWRkIGpRdWVyeVxuICBpZiAoIGpRdWVyeSApIHtcbiAgICB0aGlzLiRlbGVtZW50ID0galF1ZXJ5KCB0aGlzLmVsZW1lbnQgKTtcbiAgfVxuXG4gIC8vIG9wdGlvbnNcbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuZXh0ZW5kKCB7fSwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cyApO1xuICB0aGlzLm9wdGlvbiggb3B0aW9ucyApO1xuXG4gIC8vIGFkZCBpZCBmb3IgT3V0bGF5ZXIuZ2V0RnJvbUVsZW1lbnRcbiAgdmFyIGlkID0gKytHVUlEO1xuICB0aGlzLmVsZW1lbnQub3V0bGF5ZXJHVUlEID0gaWQ7IC8vIGV4cGFuZG9cbiAgaW5zdGFuY2VzWyBpZCBdID0gdGhpczsgLy8gYXNzb2NpYXRlIHZpYSBpZFxuXG4gIC8vIGtpY2sgaXQgb2ZmXG4gIHRoaXMuX2NyZWF0ZSgpO1xuXG4gIHZhciBpc0luaXRMYXlvdXQgPSB0aGlzLl9nZXRPcHRpb24oJ2luaXRMYXlvdXQnKTtcbiAgaWYgKCBpc0luaXRMYXlvdXQgKSB7XG4gICAgdGhpcy5sYXlvdXQoKTtcbiAgfVxufVxuXG4vLyBzZXR0aW5ncyBhcmUgZm9yIGludGVybmFsIHVzZSBvbmx5XG5PdXRsYXllci5uYW1lc3BhY2UgPSAnb3V0bGF5ZXInO1xuT3V0bGF5ZXIuSXRlbSA9IEl0ZW07XG5cbi8vIGRlZmF1bHQgb3B0aW9uc1xuT3V0bGF5ZXIuZGVmYXVsdHMgPSB7XG4gIGNvbnRhaW5lclN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgfSxcbiAgaW5pdExheW91dDogdHJ1ZSxcbiAgb3JpZ2luTGVmdDogdHJ1ZSxcbiAgb3JpZ2luVG9wOiB0cnVlLFxuICByZXNpemU6IHRydWUsXG4gIHJlc2l6ZUNvbnRhaW5lcjogdHJ1ZSxcbiAgLy8gaXRlbSBvcHRpb25zXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogJzAuNHMnLFxuICBoaWRkZW5TdHlsZToge1xuICAgIG9wYWNpdHk6IDAsXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMC4wMDEpJ1xuICB9LFxuICB2aXNpYmxlU3R5bGU6IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJ1xuICB9XG59O1xuXG52YXIgcHJvdG8gPSBPdXRsYXllci5wcm90b3R5cGU7XG4vLyBpbmhlcml0IEV2RW1pdHRlclxudXRpbHMuZXh0ZW5kKCBwcm90bywgRXZFbWl0dGVyLnByb3RvdHlwZSApO1xuXG4vKipcbiAqIHNldCBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5wcm90by5vcHRpb24gPSBmdW5jdGlvbiggb3B0cyApIHtcbiAgdXRpbHMuZXh0ZW5kKCB0aGlzLm9wdGlvbnMsIG9wdHMgKTtcbn07XG5cbi8qKlxuICogZ2V0IGJhY2t3YXJkcyBjb21wYXRpYmxlIG9wdGlvbiB2YWx1ZSwgY2hlY2sgb2xkIG5hbWVcbiAqL1xucHJvdG8uX2dldE9wdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb24gKSB7XG4gIHZhciBvbGRPcHRpb24gPSB0aGlzLmNvbnN0cnVjdG9yLmNvbXBhdE9wdGlvbnNbIG9wdGlvbiBdO1xuICByZXR1cm4gb2xkT3B0aW9uICYmIHRoaXMub3B0aW9uc1sgb2xkT3B0aW9uIF0gIT09IHVuZGVmaW5lZCA/XG4gICAgdGhpcy5vcHRpb25zWyBvbGRPcHRpb24gXSA6IHRoaXMub3B0aW9uc1sgb3B0aW9uIF07XG59O1xuXG5PdXRsYXllci5jb21wYXRPcHRpb25zID0ge1xuICAvLyBjdXJyZW50TmFtZTogb2xkTmFtZVxuICBpbml0TGF5b3V0OiAnaXNJbml0TGF5b3V0JyxcbiAgaG9yaXpvbnRhbDogJ2lzSG9yaXpvbnRhbCcsXG4gIGxheW91dEluc3RhbnQ6ICdpc0xheW91dEluc3RhbnQnLFxuICBvcmlnaW5MZWZ0OiAnaXNPcmlnaW5MZWZ0JyxcbiAgb3JpZ2luVG9wOiAnaXNPcmlnaW5Ub3AnLFxuICByZXNpemU6ICdpc1Jlc2l6ZUJvdW5kJyxcbiAgcmVzaXplQ29udGFpbmVyOiAnaXNSZXNpemluZ0NvbnRhaW5lcidcbn07XG5cbnByb3RvLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gZ2V0IGl0ZW1zIGZyb20gY2hpbGRyZW5cbiAgdGhpcy5yZWxvYWRJdGVtcygpO1xuICAvLyBlbGVtZW50cyB0aGF0IGFmZmVjdCBsYXlvdXQsIGJ1dCBhcmUgbm90IGxhaWQgb3V0XG4gIHRoaXMuc3RhbXBzID0gW107XG4gIHRoaXMuc3RhbXAoIHRoaXMub3B0aW9ucy5zdGFtcCApO1xuICAvLyBzZXQgY29udGFpbmVyIHN0eWxlXG4gIHV0aWxzLmV4dGVuZCggdGhpcy5lbGVtZW50LnN0eWxlLCB0aGlzLm9wdGlvbnMuY29udGFpbmVyU3R5bGUgKTtcblxuICAvLyBiaW5kIHJlc2l6ZSBtZXRob2RcbiAgdmFyIGNhbkJpbmRSZXNpemUgPSB0aGlzLl9nZXRPcHRpb24oJ3Jlc2l6ZScpO1xuICBpZiAoIGNhbkJpbmRSZXNpemUgKSB7XG4gICAgdGhpcy5iaW5kUmVzaXplKCk7XG4gIH1cbn07XG5cbi8vIGdvZXMgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYWdhaW4gYW5kIGdldHMgYnJpY2tzIGluIHByb3BlciBvcmRlclxucHJvdG8ucmVsb2FkSXRlbXMgPSBmdW5jdGlvbigpIHtcbiAgLy8gY29sbGVjdGlvbiBvZiBpdGVtIGVsZW1lbnRzXG4gIHRoaXMuaXRlbXMgPSB0aGlzLl9pdGVtaXplKCB0aGlzLmVsZW1lbnQuY2hpbGRyZW4gKTtcbn07XG5cblxuLyoqXG4gKiB0dXJuIGVsZW1lbnRzIGludG8gT3V0bGF5ZXIuSXRlbXMgdG8gYmUgdXNlZCBpbiBsYXlvdXRcbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgSFRNTEVsZW1lbnR9IGVsZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zIC0gY29sbGVjdGlvbiBvZiBuZXcgT3V0bGF5ZXIgSXRlbXNcbiAqL1xucHJvdG8uX2l0ZW1pemUgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG5cbiAgdmFyIGl0ZW1FbGVtcyA9IHRoaXMuX2ZpbHRlckZpbmRJdGVtRWxlbWVudHMoIGVsZW1zICk7XG4gIHZhciBJdGVtID0gdGhpcy5jb25zdHJ1Y3Rvci5JdGVtO1xuXG4gIC8vIGNyZWF0ZSBuZXcgT3V0bGF5ZXIgSXRlbXMgZm9yIGNvbGxlY3Rpb25cbiAgdmFyIGl0ZW1zID0gW107XG4gIGZvciAoIHZhciBpPTA7IGkgPCBpdGVtRWxlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIGVsZW0gPSBpdGVtRWxlbXNbaV07XG4gICAgdmFyIGl0ZW0gPSBuZXcgSXRlbSggZWxlbSwgdGhpcyApO1xuICAgIGl0ZW1zLnB1c2goIGl0ZW0gKTtcbiAgfVxuXG4gIHJldHVybiBpdGVtcztcbn07XG5cbi8qKlxuICogZ2V0IGl0ZW0gZWxlbWVudHMgdG8gYmUgdXNlZCBpbiBsYXlvdXRcbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgSFRNTEVsZW1lbnR9IGVsZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zIC0gaXRlbSBlbGVtZW50c1xuICovXG5wcm90by5fZmlsdGVyRmluZEl0ZW1FbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgcmV0dXJuIHV0aWxzLmZpbHRlckZpbmRFbGVtZW50cyggZWxlbXMsIHRoaXMub3B0aW9ucy5pdGVtU2VsZWN0b3IgKTtcbn07XG5cbi8qKlxuICogZ2V0dGVyIG1ldGhvZCBmb3IgZ2V0dGluZyBpdGVtIGVsZW1lbnRzXG4gKiBAcmV0dXJucyB7QXJyYXl9IGVsZW1zIC0gY29sbGVjdGlvbiBvZiBpdGVtIGVsZW1lbnRzXG4gKi9cbnByb3RvLmdldEl0ZW1FbGVtZW50cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIHJldHVybiBpdGVtLmVsZW1lbnQ7XG4gIH0pO1xufTtcblxuLy8gLS0tLS0gaW5pdCAmIGxheW91dCAtLS0tLSAvL1xuXG4vKipcbiAqIGxheXMgb3V0IGFsbCBpdGVtc1xuICovXG5wcm90by5sYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcmVzZXRMYXlvdXQoKTtcbiAgdGhpcy5fbWFuYWdlU3RhbXBzKCk7XG5cbiAgLy8gZG9uJ3QgYW5pbWF0ZSBmaXJzdCBsYXlvdXRcbiAgdmFyIGxheW91dEluc3RhbnQgPSB0aGlzLl9nZXRPcHRpb24oJ2xheW91dEluc3RhbnQnKTtcbiAgdmFyIGlzSW5zdGFudCA9IGxheW91dEluc3RhbnQgIT09IHVuZGVmaW5lZCA/XG4gICAgbGF5b3V0SW5zdGFudCA6ICF0aGlzLl9pc0xheW91dEluaXRlZDtcbiAgdGhpcy5sYXlvdXRJdGVtcyggdGhpcy5pdGVtcywgaXNJbnN0YW50ICk7XG5cbiAgLy8gZmxhZyBmb3IgaW5pdGFsaXplZFxuICB0aGlzLl9pc0xheW91dEluaXRlZCA9IHRydWU7XG59O1xuXG4vLyBfaW5pdCBpcyBhbGlhcyBmb3IgbGF5b3V0XG5wcm90by5faW5pdCA9IHByb3RvLmxheW91dDtcblxuLyoqXG4gKiBsb2dpYyBiZWZvcmUgYW55IG5ldyBsYXlvdXRcbiAqL1xucHJvdG8uX3Jlc2V0TGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ2V0U2l6ZSgpO1xufTtcblxuXG5wcm90by5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xufTtcblxuLyoqXG4gKiBnZXQgbWVhc3VyZW1lbnQgZnJvbSBvcHRpb24sIGZvciBjb2x1bW5XaWR0aCwgcm93SGVpZ2h0LCBndXR0ZXJcbiAqIGlmIG9wdGlvbiBpcyBTdHJpbmcgLT4gZ2V0IGVsZW1lbnQgZnJvbSBzZWxlY3RvciBzdHJpbmcsICYgZ2V0IHNpemUgb2YgZWxlbWVudFxuICogaWYgb3B0aW9uIGlzIEVsZW1lbnQgLT4gZ2V0IHNpemUgb2YgZWxlbWVudFxuICogZWxzZSB1c2Ugb3B0aW9uIGFzIGEgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lYXN1cmVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIHdpZHRoIG9yIGhlaWdodFxuICogQHByaXZhdGVcbiAqL1xucHJvdG8uX2dldE1lYXN1cmVtZW50ID0gZnVuY3Rpb24oIG1lYXN1cmVtZW50LCBzaXplICkge1xuICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb25zWyBtZWFzdXJlbWVudCBdO1xuICB2YXIgZWxlbTtcbiAgaWYgKCAhb3B0aW9uICkge1xuICAgIC8vIGRlZmF1bHQgdG8gMFxuICAgIHRoaXNbIG1lYXN1cmVtZW50IF0gPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBvcHRpb24gYXMgYW4gZWxlbWVudFxuICAgIGlmICggdHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyApIHtcbiAgICAgIGVsZW0gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3Rvciggb3B0aW9uICk7XG4gICAgfSBlbHNlIGlmICggb3B0aW9uIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgKSB7XG4gICAgICBlbGVtID0gb3B0aW9uO1xuICAgIH1cbiAgICAvLyB1c2Ugc2l6ZSBvZiBlbGVtZW50LCBpZiBlbGVtZW50XG4gICAgdGhpc1sgbWVhc3VyZW1lbnQgXSA9IGVsZW0gPyBnZXRTaXplKCBlbGVtIClbIHNpemUgXSA6IG9wdGlvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBsYXlvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW0gZWxlbWVudHNcbiAqIEBhcGkgcHVibGljXG4gKi9cbnByb3RvLmxheW91dEl0ZW1zID0gZnVuY3Rpb24oIGl0ZW1zLCBpc0luc3RhbnQgKSB7XG4gIGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNGb3JMYXlvdXQoIGl0ZW1zICk7XG5cbiAgdGhpcy5fbGF5b3V0SXRlbXMoIGl0ZW1zLCBpc0luc3RhbnQgKTtcblxuICB0aGlzLl9wb3N0TGF5b3V0KCk7XG59O1xuXG4vKipcbiAqIGdldCB0aGUgaXRlbXMgdG8gYmUgbGFpZCBvdXRcbiAqIHlvdSBtYXkgd2FudCB0byBza2lwIG92ZXIgc29tZSBpdGVtc1xuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXNcbiAqL1xucHJvdG8uX2dldEl0ZW1zRm9yTGF5b3V0ID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuICByZXR1cm4gaXRlbXMuZmlsdGVyKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICByZXR1cm4gIWl0ZW0uaXNJZ25vcmVkO1xuICB9KTtcbn07XG5cbi8qKlxuICogbGF5b3V0IGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICogQHBhcmFtIHtCb29sZWFufSBpc0luc3RhbnRcbiAqL1xucHJvdG8uX2xheW91dEl0ZW1zID0gZnVuY3Rpb24oIGl0ZW1zLCBpc0luc3RhbnQgKSB7XG4gIHRoaXMuX2VtaXRDb21wbGV0ZU9uSXRlbXMoICdsYXlvdXQnLCBpdGVtcyApO1xuXG4gIGlmICggIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGggKSB7XG4gICAgLy8gbm8gaXRlbXMsIGVtaXQgZXZlbnQgd2l0aCBlbXB0eSBhcnJheVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBxdWV1ZSA9IFtdO1xuXG4gIGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIC8vIGdldCB4L3kgb2JqZWN0IGZyb20gbWV0aG9kXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0SXRlbUxheW91dFBvc2l0aW9uKCBpdGVtICk7XG4gICAgLy8gZW5xdWV1ZVxuICAgIHBvc2l0aW9uLml0ZW0gPSBpdGVtO1xuICAgIHBvc2l0aW9uLmlzSW5zdGFudCA9IGlzSW5zdGFudCB8fCBpdGVtLmlzTGF5b3V0SW5zdGFudDtcbiAgICBxdWV1ZS5wdXNoKCBwb3NpdGlvbiApO1xuICB9LCB0aGlzICk7XG5cbiAgdGhpcy5fcHJvY2Vzc0xheW91dFF1ZXVlKCBxdWV1ZSApO1xufTtcblxuLyoqXG4gKiBnZXQgaXRlbSBsYXlvdXQgcG9zaXRpb25cbiAqIEBwYXJhbSB7T3V0bGF5ZXIuSXRlbX0gaXRlbVxuICogQHJldHVybnMge09iamVjdH0geCBhbmQgeSBwb3NpdGlvblxuICovXG5wcm90by5fZ2V0SXRlbUxheW91dFBvc2l0aW9uID0gZnVuY3Rpb24oIC8qIGl0ZW0gKi8gKSB7XG4gIHJldHVybiB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG59O1xuXG4vKipcbiAqIGl0ZXJhdGUgb3ZlciBhcnJheSBhbmQgcG9zaXRpb24gZWFjaCBpdGVtXG4gKiBSZWFzb24gYmVpbmcgLSBzZXBhcmF0aW5nIHRoaXMgbG9naWMgcHJldmVudHMgJ2xheW91dCBpbnZhbGlkYXRpb24nXG4gKiB0aHggQHBhdWxfaXJpc2hcbiAqIEBwYXJhbSB7QXJyYXl9IHF1ZXVlXG4gKi9cbnByb3RvLl9wcm9jZXNzTGF5b3V0UXVldWUgPSBmdW5jdGlvbiggcXVldWUgKSB7XG4gIHRoaXMudXBkYXRlU3RhZ2dlcigpO1xuICBxdWV1ZS5mb3JFYWNoKCBmdW5jdGlvbiggb2JqLCBpICkge1xuICAgIHRoaXMuX3Bvc2l0aW9uSXRlbSggb2JqLml0ZW0sIG9iai54LCBvYmoueSwgb2JqLmlzSW5zdGFudCwgaSApO1xuICB9LCB0aGlzICk7XG59O1xuXG4vLyBzZXQgc3RhZ2dlciBmcm9tIG9wdGlvbiBpbiBtaWxsaXNlY29uZHMgbnVtYmVyXG5wcm90by51cGRhdGVTdGFnZ2VyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFnZ2VyID0gdGhpcy5vcHRpb25zLnN0YWdnZXI7XG4gIGlmICggc3RhZ2dlciA9PT0gbnVsbCB8fCBzdGFnZ2VyID09PSB1bmRlZmluZWQgKSB7XG4gICAgdGhpcy5zdGFnZ2VyID0gMDtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5zdGFnZ2VyID0gZ2V0TWlsbGlzZWNvbmRzKCBzdGFnZ2VyICk7XG4gIHJldHVybiB0aGlzLnN0YWdnZXI7XG59O1xuXG4vKipcbiAqIFNldHMgcG9zaXRpb24gb2YgaXRlbSBpbiBET01cbiAqIEBwYXJhbSB7T3V0bGF5ZXIuSXRlbX0gaXRlbVxuICogQHBhcmFtIHtOdW1iZXJ9IHggLSBob3Jpem9udGFsIHBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0geSAtIHZlcnRpY2FsIHBvc2l0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW5zdGFudCAtIGRpc2FibGVzIHRyYW5zaXRpb25zXG4gKi9cbnByb3RvLl9wb3NpdGlvbkl0ZW0gPSBmdW5jdGlvbiggaXRlbSwgeCwgeSwgaXNJbnN0YW50LCBpICkge1xuICBpZiAoIGlzSW5zdGFudCApIHtcbiAgICAvLyBpZiBub3QgdHJhbnNpdGlvbiwganVzdCBzZXQgQ1NTXG4gICAgaXRlbS5nb1RvKCB4LCB5ICk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbS5zdGFnZ2VyKCBpICogdGhpcy5zdGFnZ2VyICk7XG4gICAgaXRlbS5tb3ZlVG8oIHgsIHkgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBbnkgbG9naWMgeW91IHdhbnQgdG8gZG8gYWZ0ZXIgZWFjaCBsYXlvdXQsXG4gKiBpLmUuIHNpemUgdGhlIGNvbnRhaW5lclxuICovXG5wcm90by5fcG9zdExheW91dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlc2l6ZUNvbnRhaW5lcigpO1xufTtcblxucHJvdG8ucmVzaXplQ29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc1Jlc2l6aW5nQ29udGFpbmVyID0gdGhpcy5fZ2V0T3B0aW9uKCdyZXNpemVDb250YWluZXInKTtcbiAgaWYgKCAhaXNSZXNpemluZ0NvbnRhaW5lciApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHNpemUgPSB0aGlzLl9nZXRDb250YWluZXJTaXplKCk7XG4gIGlmICggc2l6ZSApIHtcbiAgICB0aGlzLl9zZXRDb250YWluZXJNZWFzdXJlKCBzaXplLndpZHRoLCB0cnVlICk7XG4gICAgdGhpcy5fc2V0Q29udGFpbmVyTWVhc3VyZSggc2l6ZS5oZWlnaHQsIGZhbHNlICk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB3aWR0aCBvciBoZWlnaHQgb2YgY29udGFpbmVyIGlmIHJldHVybmVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBzaXplXG4gKiAgIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogICBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gKi9cbnByb3RvLl9nZXRDb250YWluZXJTaXplID0gbm9vcDtcblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gbWVhc3VyZSAtIHNpemUgb2Ygd2lkdGggb3IgaGVpZ2h0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzV2lkdGhcbiAqL1xucHJvdG8uX3NldENvbnRhaW5lck1lYXN1cmUgPSBmdW5jdGlvbiggbWVhc3VyZSwgaXNXaWR0aCApIHtcbiAgaWYgKCBtZWFzdXJlID09PSB1bmRlZmluZWQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVsZW1TaXplID0gdGhpcy5zaXplO1xuICAvLyBhZGQgcGFkZGluZyBhbmQgYm9yZGVyIHdpZHRoIGlmIGJvcmRlciBib3hcbiAgaWYgKCBlbGVtU2l6ZS5pc0JvcmRlckJveCApIHtcbiAgICBtZWFzdXJlICs9IGlzV2lkdGggPyBlbGVtU2l6ZS5wYWRkaW5nTGVmdCArIGVsZW1TaXplLnBhZGRpbmdSaWdodCArXG4gICAgICBlbGVtU2l6ZS5ib3JkZXJMZWZ0V2lkdGggKyBlbGVtU2l6ZS5ib3JkZXJSaWdodFdpZHRoIDpcbiAgICAgIGVsZW1TaXplLnBhZGRpbmdCb3R0b20gKyBlbGVtU2l6ZS5wYWRkaW5nVG9wICtcbiAgICAgIGVsZW1TaXplLmJvcmRlclRvcFdpZHRoICsgZWxlbVNpemUuYm9yZGVyQm90dG9tV2lkdGg7XG4gIH1cblxuICBtZWFzdXJlID0gTWF0aC5tYXgoIG1lYXN1cmUsIDAgKTtcbiAgdGhpcy5lbGVtZW50LnN0eWxlWyBpc1dpZHRoID8gJ3dpZHRoJyA6ICdoZWlnaHQnIF0gPSBtZWFzdXJlICsgJ3B4Jztcbn07XG5cbi8qKlxuICogZW1pdCBldmVudENvbXBsZXRlIG9uIGEgY29sbGVjdGlvbiBvZiBpdGVtcyBldmVudHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIC0gT3V0bGF5ZXIuSXRlbXNcbiAqL1xucHJvdG8uX2VtaXRDb21wbGV0ZU9uSXRlbXMgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBpdGVtcyApIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KCBldmVudE5hbWUgKyAnQ29tcGxldGUnLCBudWxsLCBbIGl0ZW1zIF0gKTtcbiAgfVxuXG4gIHZhciBjb3VudCA9IGl0ZW1zLmxlbmd0aDtcbiAgaWYgKCAhaXRlbXMgfHwgIWNvdW50ICkge1xuICAgIG9uQ29tcGxldGUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZG9uZUNvdW50ID0gMDtcbiAgZnVuY3Rpb24gdGljaygpIHtcbiAgICBkb25lQ291bnQrKztcbiAgICBpZiAoIGRvbmVDb3VudCA9PSBjb3VudCApIHtcbiAgICAgIG9uQ29tcGxldGUoKTtcbiAgICB9XG4gIH1cblxuICAvLyBiaW5kIGNhbGxiYWNrXG4gIGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIGl0ZW0ub25jZSggZXZlbnROYW1lLCB0aWNrICk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBlbWl0cyBldmVudHMgdmlhIEV2RW1pdHRlciBhbmQgalF1ZXJ5IGV2ZW50c1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBuYW1lIG9mIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIG9yaWdpbmFsIGV2ZW50XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gZXh0cmEgYXJndW1lbnRzXG4gKi9cbnByb3RvLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGFyZ3MgKSB7XG4gIC8vIGFkZCBvcmlnaW5hbCBldmVudCB0byBhcmd1bWVudHNcbiAgdmFyIGVtaXRBcmdzID0gZXZlbnQgPyBbIGV2ZW50IF0uY29uY2F0KCBhcmdzICkgOiBhcmdzO1xuICB0aGlzLmVtaXRFdmVudCggdHlwZSwgZW1pdEFyZ3MgKTtcblxuICBpZiAoIGpRdWVyeSApIHtcbiAgICAvLyBzZXQgdGhpcy4kZWxlbWVudFxuICAgIHRoaXMuJGVsZW1lbnQgPSB0aGlzLiRlbGVtZW50IHx8IGpRdWVyeSggdGhpcy5lbGVtZW50ICk7XG4gICAgaWYgKCBldmVudCApIHtcbiAgICAgIC8vIGNyZWF0ZSBqUXVlcnkgZXZlbnRcbiAgICAgIHZhciAkZXZlbnQgPSBqUXVlcnkuRXZlbnQoIGV2ZW50ICk7XG4gICAgICAkZXZlbnQudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoICRldmVudCwgYXJncyApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBqdXN0IHRyaWdnZXIgd2l0aCB0eXBlIGlmIG5vIGV2ZW50IGF2YWlsYWJsZVxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCB0eXBlLCBhcmdzICk7XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBpZ25vcmUgJiBzdGFtcHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuXG4vKipcbiAqIGtlZXAgaXRlbSBpbiBjb2xsZWN0aW9uLCBidXQgZG8gbm90IGxheSBpdCBvdXRcbiAqIGlnbm9yZWQgaXRlbXMgZG8gbm90IGdldCBza2lwcGVkIGluIGxheW91dFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKi9cbnByb3RvLmlnbm9yZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbSggZWxlbSApO1xuICBpZiAoIGl0ZW0gKSB7XG4gICAgaXRlbS5pc0lnbm9yZWQgPSB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIHJldHVybiBpdGVtIHRvIGxheW91dCBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqL1xucHJvdG8udW5pZ25vcmUgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oIGVsZW0gKTtcbiAgaWYgKCBpdGVtICkge1xuICAgIGRlbGV0ZSBpdGVtLmlzSWdub3JlZDtcbiAgfVxufTtcblxuLyoqXG4gKiBhZGRzIGVsZW1lbnRzIHRvIHN0YW1wc1xuICogQHBhcmFtIHtOb2RlTGlzdCwgQXJyYXksIEVsZW1lbnQsIG9yIFN0cmluZ30gZWxlbXNcbiAqL1xucHJvdG8uc3RhbXAgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIGVsZW1zID0gdGhpcy5fZmluZCggZWxlbXMgKTtcbiAgaWYgKCAhZWxlbXMgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5zdGFtcHMgPSB0aGlzLnN0YW1wcy5jb25jYXQoIGVsZW1zICk7XG4gIC8vIGlnbm9yZVxuICBlbGVtcy5mb3JFYWNoKCB0aGlzLmlnbm9yZSwgdGhpcyApO1xufTtcblxuLyoqXG4gKiByZW1vdmVzIGVsZW1lbnRzIHRvIHN0YW1wc1xuICogQHBhcmFtIHtOb2RlTGlzdCwgQXJyYXksIG9yIEVsZW1lbnR9IGVsZW1zXG4gKi9cbnByb3RvLnVuc3RhbXAgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIGVsZW1zID0gdGhpcy5fZmluZCggZWxlbXMgKTtcbiAgaWYgKCAhZWxlbXMgKXtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAvLyBmaWx0ZXIgb3V0IHJlbW92ZWQgc3RhbXAgZWxlbWVudHNcbiAgICB1dGlscy5yZW1vdmVGcm9tKCB0aGlzLnN0YW1wcywgZWxlbSApO1xuICAgIHRoaXMudW5pZ25vcmUoIGVsZW0gKTtcbiAgfSwgdGhpcyApO1xufTtcblxuLyoqXG4gKiBmaW5kcyBjaGlsZCBlbGVtZW50c1xuICogQHBhcmFtIHtOb2RlTGlzdCwgQXJyYXksIEVsZW1lbnQsIG9yIFN0cmluZ30gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gZWxlbXNcbiAqL1xucHJvdG8uX2ZpbmQgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIGlmICggIWVsZW1zICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBpZiBzdHJpbmcsIHVzZSBhcmd1bWVudCBhcyBzZWxlY3RvciBzdHJpbmdcbiAgaWYgKCB0eXBlb2YgZWxlbXMgPT0gJ3N0cmluZycgKSB7XG4gICAgZWxlbXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCggZWxlbXMgKTtcbiAgfVxuICBlbGVtcyA9IHV0aWxzLm1ha2VBcnJheSggZWxlbXMgKTtcbiAgcmV0dXJuIGVsZW1zO1xufTtcblxucHJvdG8uX21hbmFnZVN0YW1wcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoICF0aGlzLnN0YW1wcyB8fCAhdGhpcy5zdGFtcHMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2dldEJvdW5kaW5nUmVjdCgpO1xuXG4gIHRoaXMuc3RhbXBzLmZvckVhY2goIHRoaXMuX21hbmFnZVN0YW1wLCB0aGlzICk7XG59O1xuXG4vLyB1cGRhdGUgYm91bmRpbmdMZWZ0IC8gVG9wXG5wcm90by5fZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIGdldCBib3VuZGluZyByZWN0IGZvciBjb250YWluZXIgZWxlbWVudFxuICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgdGhpcy5fYm91bmRpbmdSZWN0ID0ge1xuICAgIGxlZnQ6IGJvdW5kaW5nUmVjdC5sZWZ0ICsgc2l6ZS5wYWRkaW5nTGVmdCArIHNpemUuYm9yZGVyTGVmdFdpZHRoLFxuICAgIHRvcDogYm91bmRpbmdSZWN0LnRvcCArIHNpemUucGFkZGluZ1RvcCArIHNpemUuYm9yZGVyVG9wV2lkdGgsXG4gICAgcmlnaHQ6IGJvdW5kaW5nUmVjdC5yaWdodCAtICggc2l6ZS5wYWRkaW5nUmlnaHQgKyBzaXplLmJvcmRlclJpZ2h0V2lkdGggKSxcbiAgICBib3R0b206IGJvdW5kaW5nUmVjdC5ib3R0b20gLSAoIHNpemUucGFkZGluZ0JvdHRvbSArIHNpemUuYm9yZGVyQm90dG9tV2lkdGggKVxuICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHN0YW1wXG4qKi9cbnByb3RvLl9tYW5hZ2VTdGFtcCA9IG5vb3A7XG5cbi8qKlxuICogZ2V0IHgveSBwb3NpdGlvbiBvZiBlbGVtZW50IHJlbGF0aXZlIHRvIGNvbnRhaW5lciBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqIEByZXR1cm5zIHtPYmplY3R9IG9mZnNldCAtIGhhcyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAqL1xucHJvdG8uX2dldEVsZW1lbnRPZmZzZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgdmFyIGJvdW5kaW5nUmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciB0aGlzUmVjdCA9IHRoaXMuX2JvdW5kaW5nUmVjdDtcbiAgdmFyIHNpemUgPSBnZXRTaXplKCBlbGVtICk7XG4gIHZhciBvZmZzZXQgPSB7XG4gICAgbGVmdDogYm91bmRpbmdSZWN0LmxlZnQgLSB0aGlzUmVjdC5sZWZ0IC0gc2l6ZS5tYXJnaW5MZWZ0LFxuICAgIHRvcDogYm91bmRpbmdSZWN0LnRvcCAtIHRoaXNSZWN0LnRvcCAtIHNpemUubWFyZ2luVG9wLFxuICAgIHJpZ2h0OiB0aGlzUmVjdC5yaWdodCAtIGJvdW5kaW5nUmVjdC5yaWdodCAtIHNpemUubWFyZ2luUmlnaHQsXG4gICAgYm90dG9tOiB0aGlzUmVjdC5ib3R0b20gLSBib3VuZGluZ1JlY3QuYm90dG9tIC0gc2l6ZS5tYXJnaW5Cb3R0b21cbiAgfTtcbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHJlc2l6ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBlbmFibGUgZXZlbnQgaGFuZGxlcnMgZm9yIGxpc3RlbmVyc1xuLy8gaS5lLiByZXNpemUgLT4gb25yZXNpemVcbnByb3RvLmhhbmRsZUV2ZW50ID0gdXRpbHMuaGFuZGxlRXZlbnQ7XG5cbi8qKlxuICogQmluZCBsYXlvdXQgdG8gd2luZG93IHJlc2l6aW5nXG4gKi9cbnByb3RvLmJpbmRSZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzICk7XG4gIHRoaXMuaXNSZXNpemVCb3VuZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIFVuYmluZCBsYXlvdXQgdG8gd2luZG93IHJlc2l6aW5nXG4gKi9cbnByb3RvLnVuYmluZFJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3Jlc2l6ZScsIHRoaXMgKTtcbiAgdGhpcy5pc1Jlc2l6ZUJvdW5kID0gZmFsc2U7XG59O1xuXG5wcm90by5vbnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlc2l6ZSgpO1xufTtcblxudXRpbHMuZGVib3VuY2VNZXRob2QoIE91dGxheWVyLCAnb25yZXNpemUnLCAxMDAgKTtcblxucHJvdG8ucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gIC8vIGRvbid0IHRyaWdnZXIgaWYgc2l6ZSBkaWQgbm90IGNoYW5nZVxuICAvLyBvciBpZiByZXNpemUgd2FzIHVuYm91bmQuIFNlZSAjOVxuICBpZiAoICF0aGlzLmlzUmVzaXplQm91bmQgfHwgIXRoaXMubmVlZHNSZXNpemVMYXlvdXQoKSApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmxheW91dCgpO1xufTtcblxuLyoqXG4gKiBjaGVjayBpZiBsYXlvdXQgaXMgbmVlZGVkIHBvc3QgbGF5b3V0XG4gKiBAcmV0dXJucyBCb29sZWFuXG4gKi9cbnByb3RvLm5lZWRzUmVzaXplTGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50ICk7XG4gIC8vIGNoZWNrIHRoYXQgdGhpcy5zaXplIGFuZCBzaXplIGFyZSB0aGVyZVxuICAvLyBJRTggdHJpZ2dlcnMgcmVzaXplIG9uIGJvZHkgc2l6ZSBjaGFuZ2UsIHNvIHRoZXkgbWlnaHQgbm90IGJlXG4gIHZhciBoYXNTaXplcyA9IHRoaXMuc2l6ZSAmJiBzaXplO1xuICByZXR1cm4gaGFzU2l6ZXMgJiYgc2l6ZS5pbm5lcldpZHRoICE9PSB0aGlzLnNpemUuaW5uZXJXaWR0aDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBhZGQgaXRlbXMgdG8gT3V0bGF5ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgRWxlbWVudH0gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXMgLSBPdXRsYXllci5JdGVtc1xuKiovXG5wcm90by5hZGRJdGVtcyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIGl0ZW1zID0gdGhpcy5faXRlbWl6ZSggZWxlbXMgKTtcbiAgLy8gYWRkIGl0ZW1zIHRvIGNvbGxlY3Rpb25cbiAgaWYgKCBpdGVtcy5sZW5ndGggKSB7XG4gICAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXMuY29uY2F0KCBpdGVtcyApO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn07XG5cbi8qKlxuICogTGF5b3V0IG5ld2x5LWFwcGVuZGVkIGl0ZW0gZWxlbWVudHNcbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgRWxlbWVudH0gZWxlbXNcbiAqL1xucHJvdG8uYXBwZW5kZWQgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuYWRkSXRlbXMoIGVsZW1zICk7XG4gIGlmICggIWl0ZW1zLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gbGF5b3V0IGFuZCByZXZlYWwganVzdCB0aGUgbmV3IGl0ZW1zXG4gIHRoaXMubGF5b3V0SXRlbXMoIGl0ZW1zLCB0cnVlICk7XG4gIHRoaXMucmV2ZWFsKCBpdGVtcyApO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgcHJlcGVuZGVkIGVsZW1lbnRzXG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEVsZW1lbnR9IGVsZW1zXG4gKi9cbnByb3RvLnByZXBlbmRlZCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIGl0ZW1zID0gdGhpcy5faXRlbWl6ZSggZWxlbXMgKTtcbiAgaWYgKCAhaXRlbXMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBhZGQgaXRlbXMgdG8gYmVnaW5uaW5nIG9mIGNvbGxlY3Rpb25cbiAgdmFyIHByZXZpb3VzSXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKDApO1xuICB0aGlzLml0ZW1zID0gaXRlbXMuY29uY2F0KCBwcmV2aW91c0l0ZW1zICk7XG4gIC8vIHN0YXJ0IG5ldyBsYXlvdXRcbiAgdGhpcy5fcmVzZXRMYXlvdXQoKTtcbiAgdGhpcy5fbWFuYWdlU3RhbXBzKCk7XG4gIC8vIGxheW91dCBuZXcgc3R1ZmYgd2l0aG91dCB0cmFuc2l0aW9uXG4gIHRoaXMubGF5b3V0SXRlbXMoIGl0ZW1zLCB0cnVlICk7XG4gIHRoaXMucmV2ZWFsKCBpdGVtcyApO1xuICAvLyBsYXlvdXQgcHJldmlvdXMgaXRlbXNcbiAgdGhpcy5sYXlvdXRJdGVtcyggcHJldmlvdXNJdGVtcyApO1xufTtcblxuLyoqXG4gKiByZXZlYWwgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5IG9mIE91dGxheWVyLkl0ZW1zfSBpdGVtc1xuICovXG5wcm90by5yZXZlYWwgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG4gIHRoaXMuX2VtaXRDb21wbGV0ZU9uSXRlbXMoICdyZXZlYWwnLCBpdGVtcyApO1xuICBpZiAoICFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc3RhZ2dlciA9IHRoaXMudXBkYXRlU3RhZ2dlcigpO1xuICBpdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSwgaSApIHtcbiAgICBpdGVtLnN0YWdnZXIoIGkgKiBzdGFnZ2VyICk7XG4gICAgaXRlbS5yZXZlYWwoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIGhpZGUgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5IG9mIE91dGxheWVyLkl0ZW1zfSBpdGVtc1xuICovXG5wcm90by5oaWRlID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuICB0aGlzLl9lbWl0Q29tcGxldGVPbkl0ZW1zKCAnaGlkZScsIGl0ZW1zICk7XG4gIGlmICggIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzdGFnZ2VyID0gdGhpcy51cGRhdGVTdGFnZ2VyKCk7XG4gIGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtLCBpICkge1xuICAgIGl0ZW0uc3RhZ2dlciggaSAqIHN0YWdnZXIgKTtcbiAgICBpdGVtLmhpZGUoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIHJldmVhbCBpdGVtIGVsZW1lbnRzXG4gKiBAcGFyYW0ge0FycmF5fSwge0VsZW1lbnR9LCB7Tm9kZUxpc3R9IGl0ZW1zXG4gKi9cbnByb3RvLnJldmVhbEl0ZW1FbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIGl0ZW1zID0gdGhpcy5nZXRJdGVtcyggZWxlbXMgKTtcbiAgdGhpcy5yZXZlYWwoIGl0ZW1zICk7XG59O1xuXG4vKipcbiAqIGhpZGUgaXRlbSBlbGVtZW50c1xuICogQHBhcmFtIHtBcnJheX0sIHtFbGVtZW50fSwge05vZGVMaXN0fSBpdGVtc1xuICovXG5wcm90by5oaWRlSXRlbUVsZW1lbnRzID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgaXRlbXMgPSB0aGlzLmdldEl0ZW1zKCBlbGVtcyApO1xuICB0aGlzLmhpZGUoIGl0ZW1zICk7XG59O1xuXG4vKipcbiAqIGdldCBPdXRsYXllci5JdGVtLCBnaXZlbiBhbiBFbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7T3V0bGF5ZXIuSXRlbX0gaXRlbVxuICovXG5wcm90by5nZXRJdGVtID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIC8vIGxvb3AgdGhyb3VnaCBpdGVtcyB0byBnZXQgdGhlIG9uZSB0aGF0IG1hdGNoZXNcbiAgZm9yICggdmFyIGk9MDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuICAgIGlmICggaXRlbS5lbGVtZW50ID09IGVsZW0gKSB7XG4gICAgICAvLyByZXR1cm4gaXRlbVxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIGdldCBjb2xsZWN0aW9uIG9mIE91dGxheWVyLkl0ZW1zLCBnaXZlbiBFbGVtZW50c1xuICogQHBhcmFtIHtBcnJheX0gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXMgLSBPdXRsYXllci5JdGVtc1xuICovXG5wcm90by5nZXRJdGVtcyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gIHZhciBpdGVtcyA9IFtdO1xuICBlbGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbSggZWxlbSApO1xuICAgIGlmICggaXRlbSApIHtcbiAgICAgIGl0ZW1zLnB1c2goIGl0ZW0gKTtcbiAgICB9XG4gIH0sIHRoaXMgKTtcblxuICByZXR1cm4gaXRlbXM7XG59O1xuXG4vKipcbiAqIHJlbW92ZSBlbGVtZW50KHMpIGZyb20gaW5zdGFuY2UgYW5kIERPTVxuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBFbGVtZW50fSBlbGVtc1xuICovXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciByZW1vdmVJdGVtcyA9IHRoaXMuZ2V0SXRlbXMoIGVsZW1zICk7XG5cbiAgdGhpcy5fZW1pdENvbXBsZXRlT25JdGVtcyggJ3JlbW92ZScsIHJlbW92ZUl0ZW1zICk7XG5cbiAgLy8gYmFpbCBpZiBubyBpdGVtcyB0byByZW1vdmVcbiAgaWYgKCAhcmVtb3ZlSXRlbXMgfHwgIXJlbW92ZUl0ZW1zLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZW1vdmVJdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICBpdGVtLnJlbW92ZSgpO1xuICAgIC8vIHJlbW92ZSBpdGVtIGZyb20gY29sbGVjdGlvblxuICAgIHV0aWxzLnJlbW92ZUZyb20oIHRoaXMuaXRlbXMsIGl0ZW0gKTtcbiAgfSwgdGhpcyApO1xufTtcblxuLy8gLS0tLS0gZGVzdHJveSAtLS0tLSAvL1xuXG4vLyByZW1vdmUgYW5kIGRpc2FibGUgT3V0bGF5ZXIgaW5zdGFuY2VcbnByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgLy8gY2xlYW4gdXAgZHluYW1pYyBzdHlsZXNcbiAgdmFyIHN0eWxlID0gdGhpcy5lbGVtZW50LnN0eWxlO1xuICBzdHlsZS5oZWlnaHQgPSAnJztcbiAgc3R5bGUucG9zaXRpb24gPSAnJztcbiAgc3R5bGUud2lkdGggPSAnJztcbiAgLy8gZGVzdHJveSBpdGVtc1xuICB0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIGl0ZW0uZGVzdHJveSgpO1xuICB9KTtcblxuICB0aGlzLnVuYmluZFJlc2l6ZSgpO1xuXG4gIHZhciBpZCA9IHRoaXMuZWxlbWVudC5vdXRsYXllckdVSUQ7XG4gIGRlbGV0ZSBpbnN0YW5jZXNbIGlkIF07IC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gaW5zdGFuY2UgYnkgaWRcbiAgZGVsZXRlIHRoaXMuZWxlbWVudC5vdXRsYXllckdVSUQ7XG4gIC8vIHJlbW92ZSBkYXRhIGZvciBqUXVlcnlcbiAgaWYgKCBqUXVlcnkgKSB7XG4gICAgalF1ZXJ5LnJlbW92ZURhdGEoIHRoaXMuZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lc3BhY2UgKTtcbiAgfVxuXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkYXRhIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8qKlxuICogZ2V0IE91dGxheWVyIGluc3RhbmNlIGZyb20gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcmV0dXJucyB7T3V0bGF5ZXJ9XG4gKi9cbk91dGxheWVyLmRhdGEgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgZWxlbSA9IHV0aWxzLmdldFF1ZXJ5RWxlbWVudCggZWxlbSApO1xuICB2YXIgaWQgPSBlbGVtICYmIGVsZW0ub3V0bGF5ZXJHVUlEO1xuICByZXR1cm4gaWQgJiYgaW5zdGFuY2VzWyBpZCBdO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBjcmVhdGUgT3V0bGF5ZXIgY2xhc3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBjcmVhdGUgYSBsYXlvdXQgY2xhc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqL1xuT3V0bGF5ZXIuY3JlYXRlID0gZnVuY3Rpb24oIG5hbWVzcGFjZSwgb3B0aW9ucyApIHtcbiAgLy8gc3ViLWNsYXNzIE91dGxheWVyXG4gIHZhciBMYXlvdXQgPSBzdWJjbGFzcyggT3V0bGF5ZXIgKTtcbiAgLy8gYXBwbHkgbmV3IG9wdGlvbnMgYW5kIGNvbXBhdE9wdGlvbnNcbiAgTGF5b3V0LmRlZmF1bHRzID0gdXRpbHMuZXh0ZW5kKCB7fSwgT3V0bGF5ZXIuZGVmYXVsdHMgKTtcbiAgdXRpbHMuZXh0ZW5kKCBMYXlvdXQuZGVmYXVsdHMsIG9wdGlvbnMgKTtcbiAgTGF5b3V0LmNvbXBhdE9wdGlvbnMgPSB1dGlscy5leHRlbmQoIHt9LCBPdXRsYXllci5jb21wYXRPcHRpb25zICApO1xuXG4gIExheW91dC5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgTGF5b3V0LmRhdGEgPSBPdXRsYXllci5kYXRhO1xuXG4gIC8vIHN1Yi1jbGFzcyBJdGVtXG4gIExheW91dC5JdGVtID0gc3ViY2xhc3MoIEl0ZW0gKTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkZWNsYXJhdGl2ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gIHV0aWxzLmh0bWxJbml0KCBMYXlvdXQsIG5hbWVzcGFjZSApO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGpRdWVyeSBicmlkZ2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAvLyBtYWtlIGludG8galF1ZXJ5IHBsdWdpblxuICBpZiAoIGpRdWVyeSAmJiBqUXVlcnkuYnJpZGdldCApIHtcbiAgICBqUXVlcnkuYnJpZGdldCggbmFtZXNwYWNlLCBMYXlvdXQgKTtcbiAgfVxuXG4gIHJldHVybiBMYXlvdXQ7XG59O1xuXG5mdW5jdGlvbiBzdWJjbGFzcyggUGFyZW50ICkge1xuICBmdW5jdGlvbiBTdWJDbGFzcygpIHtcbiAgICBQYXJlbnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICB9XG5cbiAgU3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuICBTdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWJDbGFzcztcblxuICByZXR1cm4gU3ViQ2xhc3M7XG59XG5cbi8vIC0tLS0tIGhlbHBlcnMgLS0tLS0gLy9cblxuLy8gaG93IG1hbnkgbWlsbGlzZWNvbmRzIGFyZSBpbiBlYWNoIHVuaXRcbnZhciBtc1VuaXRzID0ge1xuICBtczogMSxcbiAgczogMTAwMFxufTtcblxuLy8gbXVuZ2UgdGltZS1saWtlIHBhcmFtZXRlciBpbnRvIG1pbGxpc2Vjb25kIG51bWJlclxuLy8gJzAuNHMnIC0+IDQwXG5mdW5jdGlvbiBnZXRNaWxsaXNlY29uZHMoIHRpbWUgKSB7XG4gIGlmICggdHlwZW9mIHRpbWUgPT0gJ251bWJlcicgKSB7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgdmFyIG1hdGNoZXMgPSB0aW1lLm1hdGNoKCAvKF5cXGQqXFwuP1xcZCopKFxcdyopLyApO1xuICB2YXIgbnVtID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdO1xuICB2YXIgdW5pdCA9IG1hdGNoZXMgJiYgbWF0Y2hlc1syXTtcbiAgaWYgKCAhbnVtLmxlbmd0aCApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBudW0gPSBwYXJzZUZsb2F0KCBudW0gKTtcbiAgdmFyIG11bHQgPSBtc1VuaXRzWyB1bml0IF0gfHwgMTtcbiAgcmV0dXJuIG51bSAqIG11bHQ7XG59XG5cbi8vIC0tLS0tIGZpbiAtLS0tLSAvL1xuXG4vLyBiYWNrIGluIGdsb2JhbFxuT3V0bGF5ZXIuSXRlbSA9IEl0ZW07XG5cbnJldHVybiBPdXRsYXllcjtcblxufSkpO1xuXG4vKiFcbiAqIE1hc29ucnkgdjQuMS4xXG4gKiBDYXNjYWRpbmcgZ3JpZCBsYXlvdXQgbGlicmFyeVxuICogaHR0cDovL21hc29ucnkuZGVzYW5kcm8uY29tXG4gKiBNSVQgTGljZW5zZVxuICogYnkgRGF2aWQgRGVTYW5kcm9cbiAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICAgJ291dGxheWVyL291dGxheWVyJyxcbiAgICAgICAgJ2dldC1zaXplL2dldC1zaXplJ1xuICAgICAgXSxcbiAgICAgIGZhY3RvcnkgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHJlcXVpcmUoJ291dGxheWVyJyksXG4gICAgICByZXF1aXJlKCdnZXQtc2l6ZScpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5NYXNvbnJ5ID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdy5PdXRsYXllcixcbiAgICAgIHdpbmRvdy5nZXRTaXplXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIE91dGxheWVyLCBnZXRTaXplICkge1xuXG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gbWFzb25yeURlZmluaXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAvLyBjcmVhdGUgYW4gT3V0bGF5ZXIgbGF5b3V0IGNsYXNzXG4gIHZhciBNYXNvbnJ5ID0gT3V0bGF5ZXIuY3JlYXRlKCdtYXNvbnJ5Jyk7XG4gIC8vIGlzRml0V2lkdGggLT4gZml0V2lkdGhcbiAgTWFzb25yeS5jb21wYXRPcHRpb25zLmZpdFdpZHRoID0gJ2lzRml0V2lkdGgnO1xuXG4gIE1hc29ucnkucHJvdG90eXBlLl9yZXNldExheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0U2l6ZSgpO1xuICAgIHRoaXMuX2dldE1lYXN1cmVtZW50KCAnY29sdW1uV2lkdGgnLCAnb3V0ZXJXaWR0aCcgKTtcbiAgICB0aGlzLl9nZXRNZWFzdXJlbWVudCggJ2d1dHRlcicsICdvdXRlcldpZHRoJyApO1xuICAgIHRoaXMubWVhc3VyZUNvbHVtbnMoKTtcblxuICAgIC8vIHJlc2V0IGNvbHVtbiBZXG4gICAgdGhpcy5jb2xZcyA9IFtdO1xuICAgIGZvciAoIHZhciBpPTA7IGkgPCB0aGlzLmNvbHM7IGkrKyApIHtcbiAgICAgIHRoaXMuY29sWXMucHVzaCggMCApO1xuICAgIH1cblxuICAgIHRoaXMubWF4WSA9IDA7XG4gIH07XG5cbiAgTWFzb25yeS5wcm90b3R5cGUubWVhc3VyZUNvbHVtbnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmdldENvbnRhaW5lcldpZHRoKCk7XG4gICAgLy8gaWYgY29sdW1uV2lkdGggaXMgMCwgZGVmYXVsdCB0byBvdXRlcldpZHRoIG9mIGZpcnN0IGl0ZW1cbiAgICBpZiAoICF0aGlzLmNvbHVtbldpZHRoICkge1xuICAgICAgdmFyIGZpcnN0SXRlbSA9IHRoaXMuaXRlbXNbMF07XG4gICAgICB2YXIgZmlyc3RJdGVtRWxlbSA9IGZpcnN0SXRlbSAmJiBmaXJzdEl0ZW0uZWxlbWVudDtcbiAgICAgIC8vIGNvbHVtbldpZHRoIGZhbGwgYmFjayB0byBpdGVtIG9mIGZpcnN0IGVsZW1lbnRcbiAgICAgIHRoaXMuY29sdW1uV2lkdGggPSBmaXJzdEl0ZW1FbGVtICYmIGdldFNpemUoIGZpcnN0SXRlbUVsZW0gKS5vdXRlcldpZHRoIHx8XG4gICAgICAgIC8vIGlmIGZpcnN0IGVsZW0gaGFzIG5vIHdpZHRoLCBkZWZhdWx0IHRvIHNpemUgb2YgY29udGFpbmVyXG4gICAgICAgIHRoaXMuY29udGFpbmVyV2lkdGg7XG4gICAgfVxuXG4gICAgdmFyIGNvbHVtbldpZHRoID0gdGhpcy5jb2x1bW5XaWR0aCArPSB0aGlzLmd1dHRlcjtcblxuICAgIC8vIGNhbGN1bGF0ZSBjb2x1bW5zXG4gICAgdmFyIGNvbnRhaW5lcldpZHRoID0gdGhpcy5jb250YWluZXJXaWR0aCArIHRoaXMuZ3V0dGVyO1xuICAgIHZhciBjb2xzID0gY29udGFpbmVyV2lkdGggLyBjb2x1bW5XaWR0aDtcbiAgICAvLyBmaXggcm91bmRpbmcgZXJyb3JzLCB0eXBpY2FsbHkgd2l0aCBndXR0ZXJzXG4gICAgdmFyIGV4Y2VzcyA9IGNvbHVtbldpZHRoIC0gY29udGFpbmVyV2lkdGggJSBjb2x1bW5XaWR0aDtcbiAgICAvLyBpZiBvdmVyc2hvb3QgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIHJvdW5kIHVwLCBvdGhlcndpc2UgZmxvb3IgaXRcbiAgICB2YXIgbWF0aE1ldGhvZCA9IGV4Y2VzcyAmJiBleGNlc3MgPCAxID8gJ3JvdW5kJyA6ICdmbG9vcic7XG4gICAgY29scyA9IE1hdGhbIG1hdGhNZXRob2QgXSggY29scyApO1xuICAgIHRoaXMuY29scyA9IE1hdGgubWF4KCBjb2xzLCAxICk7XG4gIH07XG5cbiAgTWFzb25yeS5wcm90b3R5cGUuZ2V0Q29udGFpbmVyV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICAvLyBjb250YWluZXIgaXMgcGFyZW50IGlmIGZpdCB3aWR0aFxuICAgIHZhciBpc0ZpdFdpZHRoID0gdGhpcy5fZ2V0T3B0aW9uKCdmaXRXaWR0aCcpO1xuICAgIHZhciBjb250YWluZXIgPSBpc0ZpdFdpZHRoID8gdGhpcy5lbGVtZW50LnBhcmVudE5vZGUgOiB0aGlzLmVsZW1lbnQ7XG4gICAgLy8gY2hlY2sgdGhhdCB0aGlzLnNpemUgYW5kIHNpemUgYXJlIHRoZXJlXG4gICAgLy8gSUU4IHRyaWdnZXJzIHJlc2l6ZSBvbiBib2R5IHNpemUgY2hhbmdlLCBzbyB0aGV5IG1pZ2h0IG5vdCBiZVxuICAgIHZhciBzaXplID0gZ2V0U2l6ZSggY29udGFpbmVyICk7XG4gICAgdGhpcy5jb250YWluZXJXaWR0aCA9IHNpemUgJiYgc2l6ZS5pbm5lcldpZHRoO1xuICB9O1xuXG4gIE1hc29ucnkucHJvdG90eXBlLl9nZXRJdGVtTGF5b3V0UG9zaXRpb24gPSBmdW5jdGlvbiggaXRlbSApIHtcbiAgICBpdGVtLmdldFNpemUoKTtcbiAgICAvLyBob3cgbWFueSBjb2x1bW5zIGRvZXMgdGhpcyBicmljayBzcGFuXG4gICAgdmFyIHJlbWFpbmRlciA9IGl0ZW0uc2l6ZS5vdXRlcldpZHRoICUgdGhpcy5jb2x1bW5XaWR0aDtcbiAgICB2YXIgbWF0aE1ldGhvZCA9IHJlbWFpbmRlciAmJiByZW1haW5kZXIgPCAxID8gJ3JvdW5kJyA6ICdjZWlsJztcbiAgICAvLyByb3VuZCBpZiBvZmYgYnkgMSBwaXhlbCwgb3RoZXJ3aXNlIHVzZSBjZWlsXG4gICAgdmFyIGNvbFNwYW4gPSBNYXRoWyBtYXRoTWV0aG9kIF0oIGl0ZW0uc2l6ZS5vdXRlcldpZHRoIC8gdGhpcy5jb2x1bW5XaWR0aCApO1xuICAgIGNvbFNwYW4gPSBNYXRoLm1pbiggY29sU3BhbiwgdGhpcy5jb2xzICk7XG5cbiAgICB2YXIgY29sR3JvdXAgPSB0aGlzLl9nZXRDb2xHcm91cCggY29sU3BhbiApO1xuICAgIC8vIGdldCB0aGUgbWluaW11bSBZIHZhbHVlIGZyb20gdGhlIGNvbHVtbnNcbiAgICB2YXIgbWluaW11bVkgPSBNYXRoLm1pbi5hcHBseSggTWF0aCwgY29sR3JvdXAgKTtcbiAgICB2YXIgc2hvcnRDb2xJbmRleCA9IGNvbEdyb3VwLmluZGV4T2YoIG1pbmltdW1ZICk7XG5cbiAgICAvLyBwb3NpdGlvbiB0aGUgYnJpY2tcbiAgICB2YXIgcG9zaXRpb24gPSB7XG4gICAgICB4OiB0aGlzLmNvbHVtbldpZHRoICogc2hvcnRDb2xJbmRleCxcbiAgICAgIHk6IG1pbmltdW1ZXG4gICAgfTtcblxuICAgIC8vIGFwcGx5IHNldEhlaWdodCB0byBuZWNlc3NhcnkgY29sdW1uc1xuICAgIHZhciBzZXRIZWlnaHQgPSBtaW5pbXVtWSArIGl0ZW0uc2l6ZS5vdXRlckhlaWdodDtcbiAgICB2YXIgc2V0U3BhbiA9IHRoaXMuY29scyArIDEgLSBjb2xHcm91cC5sZW5ndGg7XG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc2V0U3BhbjsgaSsrICkge1xuICAgICAgdGhpcy5jb2xZc1sgc2hvcnRDb2xJbmRleCArIGkgXSA9IHNldEhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xTcGFuIC0gbnVtYmVyIG9mIGNvbHVtbnMgdGhlIGVsZW1lbnQgc3BhbnNcbiAgICogQHJldHVybnMge0FycmF5fSBjb2xHcm91cFxuICAgKi9cbiAgTWFzb25yeS5wcm90b3R5cGUuX2dldENvbEdyb3VwID0gZnVuY3Rpb24oIGNvbFNwYW4gKSB7XG4gICAgaWYgKCBjb2xTcGFuIDwgMiApIHtcbiAgICAgIC8vIGlmIGJyaWNrIHNwYW5zIG9ubHkgb25lIGNvbHVtbiwgdXNlIGFsbCB0aGUgY29sdW1uIFlzXG4gICAgICByZXR1cm4gdGhpcy5jb2xZcztcbiAgICB9XG5cbiAgICB2YXIgY29sR3JvdXAgPSBbXTtcbiAgICAvLyBob3cgbWFueSBkaWZmZXJlbnQgcGxhY2VzIGNvdWxkIHRoaXMgYnJpY2sgZml0IGhvcml6b250YWxseVxuICAgIHZhciBncm91cENvdW50ID0gdGhpcy5jb2xzICsgMSAtIGNvbFNwYW47XG4gICAgLy8gZm9yIGVhY2ggZ3JvdXAgcG90ZW50aWFsIGhvcml6b250YWwgcG9zaXRpb25cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBncm91cENvdW50OyBpKysgKSB7XG4gICAgICAvLyBtYWtlIGFuIGFycmF5IG9mIGNvbFkgdmFsdWVzIGZvciB0aGF0IG9uZSBncm91cFxuICAgICAgdmFyIGdyb3VwQ29sWXMgPSB0aGlzLmNvbFlzLnNsaWNlKCBpLCBpICsgY29sU3BhbiApO1xuICAgICAgLy8gYW5kIGdldCB0aGUgbWF4IHZhbHVlIG9mIHRoZSBhcnJheVxuICAgICAgY29sR3JvdXBbaV0gPSBNYXRoLm1heC5hcHBseSggTWF0aCwgZ3JvdXBDb2xZcyApO1xuICAgIH1cbiAgICByZXR1cm4gY29sR3JvdXA7XG4gIH07XG5cbiAgTWFzb25yeS5wcm90b3R5cGUuX21hbmFnZVN0YW1wID0gZnVuY3Rpb24oIHN0YW1wICkge1xuICAgIHZhciBzdGFtcFNpemUgPSBnZXRTaXplKCBzdGFtcCApO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9nZXRFbGVtZW50T2Zmc2V0KCBzdGFtcCApO1xuICAgIC8vIGdldCB0aGUgY29sdW1ucyB0aGF0IHRoaXMgc3RhbXAgYWZmZWN0c1xuICAgIHZhciBpc09yaWdpbkxlZnQgPSB0aGlzLl9nZXRPcHRpb24oJ29yaWdpbkxlZnQnKTtcbiAgICB2YXIgZmlyc3RYID0gaXNPcmlnaW5MZWZ0ID8gb2Zmc2V0LmxlZnQgOiBvZmZzZXQucmlnaHQ7XG4gICAgdmFyIGxhc3RYID0gZmlyc3RYICsgc3RhbXBTaXplLm91dGVyV2lkdGg7XG4gICAgdmFyIGZpcnN0Q29sID0gTWF0aC5mbG9vciggZmlyc3RYIC8gdGhpcy5jb2x1bW5XaWR0aCApO1xuICAgIGZpcnN0Q29sID0gTWF0aC5tYXgoIDAsIGZpcnN0Q29sICk7XG4gICAgdmFyIGxhc3RDb2wgPSBNYXRoLmZsb29yKCBsYXN0WCAvIHRoaXMuY29sdW1uV2lkdGggKTtcbiAgICAvLyBsYXN0Q29sIHNob3VsZCBub3QgZ28gb3ZlciBpZiBtdWx0aXBsZSBvZiBjb2x1bW5XaWR0aCAjNDI1XG4gICAgbGFzdENvbCAtPSBsYXN0WCAlIHRoaXMuY29sdW1uV2lkdGggPyAwIDogMTtcbiAgICBsYXN0Q29sID0gTWF0aC5taW4oIHRoaXMuY29scyAtIDEsIGxhc3RDb2wgKTtcbiAgICAvLyBzZXQgY29sWXMgdG8gYm90dG9tIG9mIHRoZSBzdGFtcFxuXG4gICAgdmFyIGlzT3JpZ2luVG9wID0gdGhpcy5fZ2V0T3B0aW9uKCdvcmlnaW5Ub3AnKTtcbiAgICB2YXIgc3RhbXBNYXhZID0gKCBpc09yaWdpblRvcCA/IG9mZnNldC50b3AgOiBvZmZzZXQuYm90dG9tICkgK1xuICAgICAgc3RhbXBTaXplLm91dGVySGVpZ2h0O1xuICAgIGZvciAoIHZhciBpID0gZmlyc3RDb2w7IGkgPD0gbGFzdENvbDsgaSsrICkge1xuICAgICAgdGhpcy5jb2xZc1tpXSA9IE1hdGgubWF4KCBzdGFtcE1heFksIHRoaXMuY29sWXNbaV0gKTtcbiAgICB9XG4gIH07XG5cbiAgTWFzb25yeS5wcm90b3R5cGUuX2dldENvbnRhaW5lclNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heC5hcHBseSggTWF0aCwgdGhpcy5jb2xZcyApO1xuICAgIHZhciBzaXplID0ge1xuICAgICAgaGVpZ2h0OiB0aGlzLm1heFlcbiAgICB9O1xuXG4gICAgaWYgKCB0aGlzLl9nZXRPcHRpb24oJ2ZpdFdpZHRoJykgKSB7XG4gICAgICBzaXplLndpZHRoID0gdGhpcy5fZ2V0Q29udGFpbmVyRml0V2lkdGgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZTtcbiAgfTtcblxuICBNYXNvbnJ5LnByb3RvdHlwZS5fZ2V0Q29udGFpbmVyRml0V2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdW51c2VkQ29scyA9IDA7XG4gICAgLy8gY291bnQgdW51c2VkIGNvbHVtbnNcbiAgICB2YXIgaSA9IHRoaXMuY29scztcbiAgICB3aGlsZSAoIC0taSApIHtcbiAgICAgIGlmICggdGhpcy5jb2xZc1tpXSAhPT0gMCApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB1bnVzZWRDb2xzKys7XG4gICAgfVxuICAgIC8vIGZpdCBjb250YWluZXIgdG8gY29sdW1ucyB0aGF0IGhhdmUgYmVlbiB1c2VkXG4gICAgcmV0dXJuICggdGhpcy5jb2xzIC0gdW51c2VkQ29scyApICogdGhpcy5jb2x1bW5XaWR0aCAtIHRoaXMuZ3V0dGVyO1xuICB9O1xuXG4gIE1hc29ucnkucHJvdG90eXBlLm5lZWRzUmVzaXplTGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByZXZpb3VzV2lkdGggPSB0aGlzLmNvbnRhaW5lcldpZHRoO1xuICAgIHRoaXMuZ2V0Q29udGFpbmVyV2lkdGgoKTtcbiAgICByZXR1cm4gcHJldmlvdXNXaWR0aCAhPSB0aGlzLmNvbnRhaW5lcldpZHRoO1xuICB9O1xuXG4gIHJldHVybiBNYXNvbnJ5O1xuXG59KSk7XG5cbiIsIi8vICQoZG9jdW1lbnQpLmZvdW5kYXRpb24oKTtcblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcblx0U2l0ZS5pbml0KCk7XG59KTtcblxudmFyIFNpdGUgPSB7XG5cdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggJCh3aW5kb3cpLndpZHRoKCkgPiA2NDAgKSB7XG5cdFx0XHRTaXRlLnNjcm9sbG1hZ2ljKCk7XG5cdFx0fVxuXHRcdFNpdGUuZ3JpZCgpO1xuXHR9LFxuXHRzY3JvbGxtYWdpYzogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gaW5pdCBjb250cm9sbGVyXG5cdFx0dmFyIGNvbnRyb2xsZXIgPSBuZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcigpO1xuXHRcdHZhciBpbWFnZXMgPSAkKCcucGFyYWxsYXgnKTtcblx0XHR2YXIgd2luZG93SGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuXG5cdFx0JC5lYWNoKGltYWdlcywgZnVuY3Rpb24oaW5kZXgsIGltYWdlKXtcblx0XHRcdC8vIHZhciB0d2VlbiA9IG5ldyBUd2Vlbk1heC5mcm9tVG8oaW1hZ2UsIDEsIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgxMmVtKScgfSwgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC04ZW0pJyB9KVxuXHRcdFx0dmFyIHR3ZWVuID0gbmV3IFR3ZWVuTWF4LmZyb21UbyhpbWFnZSwgMSwgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC00ZW0pJyB9LCB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMTJlbSknIH0pXG5cblx0XHRcdHZhciBzY2VuZSA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7XG5cdFx0XHRcdFx0ZHVyYXRpb246IHdpbmRvd0hlaWdodCoyLFxuXHRcdFx0XHRcdHRyaWdnZXJFbGVtZW50OiBpbWFnZSxcblx0XHRcdFx0XHR0cmlnZ2VySG9vazogMSxcblx0XHRcdFx0XHQvLyBvZmZzZXQ6IDUwKmluZGV4XG5cdFx0XHRcdFx0Ly8gb2Zmc2V0OiAwXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5zZXRUd2VlbiggdHdlZW4gKVxuXHRcdFx0XHQuYWRkVG8oY29udHJvbGxlcilcblx0XHR9KTtcblx0fVxufSJdfQ==
