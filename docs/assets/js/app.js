"use strict";

/*!
 * jQuery JavaScript Library v2.2.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-04-05T19:26Z
 */

(function (global, factory) {

	if (typeof module === "object" && typeof module.exports === "object") {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ? factory(global, true) : function (w) {
			if (!w.document) {
				throw new Error("jQuery requires a window with a document");
			}
			return factory(w);
		};
	} else {
		factory(global);
	}

	// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};

	var version = "2.2.3",


	// Define a local copy of jQuery
	jQuery = function (selector, context) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init(selector, context);
	},


	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	    rdashAlpha = /-([\da-z])/gi,


	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function (all, letter) {
		return letter.toUpperCase();
	};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function () {
			return slice.call(this);
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function (num) {
			return num != null ?

			// Return just the one element from the set
			num < 0 ? this[num + this.length] : this[num] :

			// Return all the elements in a clean array
			slice.call(this);
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function (elems) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge(this.constructor(), elems);

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function (callback) {
			return jQuery.each(this, callback);
		},

		map: function (callback) {
			return this.pushStack(jQuery.map(this, function (elem, i) {
				return callback.call(elem, i, elem);
			}));
		},

		slice: function () {
			return this.pushStack(slice.apply(this, arguments));
		},

		first: function () {
			return this.eq(0);
		},

		last: function () {
			return this.eq(-1);
		},

		eq: function (i) {
			var len = this.length,
			    j = +i + (i < 0 ? len : 0);
			return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
		},

		end: function () {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function () {
		var options,
		    name,
		    src,
		    copy,
		    copyIsArray,
		    clone,
		    target = arguments[0] || {},
		    i = 1,
		    length = arguments.length,
		    deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// Skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !jQuery.isFunction(target)) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {

			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {

				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {

						if (copyIsArray) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = jQuery.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function (msg) {
			throw new Error(msg);
		},

		noop: function () {},

		isFunction: function (obj) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function (obj) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function (obj) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;
		},

		isPlainObject: function (obj) {
			var key;

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for (key in obj) {}

			return key === undefined || hasOwn.call(obj, key);
		},

		isEmptyObject: function (obj) {
			var name;
			for (name in obj) {
				return false;
			}
			return true;
		},

		type: function (obj) {
			if (obj == null) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function (code) {
			var script,
			    indirect = eval;

			code = jQuery.trim(code);

			if (code) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if (code.indexOf("use strict") === 1) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild(script).parentNode.removeChild(script);
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect(code);
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function (string) {
			return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
		},

		nodeName: function (elem, name) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function (obj, callback) {
			var length,
			    i = 0;

			if (isArrayLike(obj)) {
				length = obj.length;
				for (; i < length; i++) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function (text) {
			return text == null ? "" : (text + "").replace(rtrim, "");
		},

		// results is for internal usage only
		makeArray: function (arr, results) {
			var ret = results || [];

			if (arr != null) {
				if (isArrayLike(Object(arr))) {
					jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					push.call(ret, arr);
				}
			}

			return ret;
		},

		inArray: function (elem, arr, i) {
			return arr == null ? -1 : indexOf.call(arr, elem, i);
		},

		merge: function (first, second) {
			var len = +second.length,
			    j = 0,
			    i = first.length;

			for (; j < len; j++) {
				first[i++] = second[j];
			}

			first.length = i;

			return first;
		},

		grep: function (elems, callback, invert) {
			var callbackInverse,
			    matches = [],
			    i = 0,
			    length = elems.length,
			    callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for (; i < length; i++) {
				callbackInverse = !callback(elems[i], i);
				if (callbackInverse !== callbackExpect) {
					matches.push(elems[i]);
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function (elems, callback, arg) {
			var length,
			    value,
			    i = 0,
			    ret = [];

			// Go through the array, translating each of the items to their new values
			if (isArrayLike(elems)) {
				length = elems.length;
				for (; i < length; i++) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}

				// Go through every key on the object,
			} else {
				for (i in elems) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply([], ret);
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function (fn, context) {
			var tmp, args, proxy;

			if (typeof context === "string") {
				tmp = fn[context];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if (!jQuery.isFunction(fn)) {
				return undefined;
			}

			// Simulated bind
			args = slice.call(arguments, 2);
			proxy = function () {
				return fn.apply(context || this, args.concat(slice.call(arguments)));
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if (typeof Symbol === "function") {
		jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
		class2type["[object " + name + "]"] = name.toLowerCase();
	});

	function isArrayLike(obj) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
		    type = jQuery.type(obj);

		if (type === "function" || jQuery.isWindow(obj)) {
			return false;
		}

		return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	}
	var Sizzle =
	/*!
  * Sizzle CSS Selector Engine v2.2.1
  * http://sizzlejs.com/
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2015-10-17
  */
	function (window) {

		var i,
		    support,
		    Expr,
		    getText,
		    isXML,
		    tokenize,
		    compile,
		    select,
		    outermostContext,
		    sortInput,
		    hasDuplicate,


		// Local document vars
		setDocument,
		    document,
		    docElem,
		    documentIsHTML,
		    rbuggyQSA,
		    rbuggyMatches,
		    matches,
		    contains,


		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		    preferredDoc = window.document,
		    dirruns = 0,
		    done = 0,
		    classCache = createCache(),
		    tokenCache = createCache(),
		    compilerCache = createCache(),
		    sortOrder = function (a, b) {
			if (a === b) {
				hasDuplicate = true;
			}
			return 0;
		},


		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,


		// Instance methods
		hasOwn = {}.hasOwnProperty,
		    arr = [],
		    pop = arr.pop,
		    push_native = arr.push,
		    push = arr.push,
		    slice = arr.slice,

		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function (list, elem) {
			var i = 0,
			    len = list.length;
			for (; i < len; i++) {
				if (list[i] === elem) {
					return i;
				}
			}
			return -1;
		},
		    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",


		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",


		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
		    pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" + ")\\)|)",


		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp(whitespace + "+", "g"),
		    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
		    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
		    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
		    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
		    rpseudo = new RegExp(pseudos),
		    ridentifier = new RegExp("^" + identifier + "$"),
		    matchExpr = {
			"ID": new RegExp("^#(" + identifier + ")"),
			"CLASS": new RegExp("^\\.(" + identifier + ")"),
			"TAG": new RegExp("^(" + identifier + "|[*])"),
			"ATTR": new RegExp("^" + attributes),
			"PSEUDO": new RegExp("^" + pseudos),
			"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
			"bool": new RegExp("^(?:" + booleans + ")$", "i"),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
		},
		    rinputs = /^(?:input|select|textarea|button)$/i,
		    rheader = /^h\d$/i,
		    rnative = /^[^{]+\{\s*\[native \w/,


		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
		    rsibling = /[+~]/,
		    rescape = /'|\\/g,


		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
		    funescape = function (_, escaped, escapedWhitespace) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ? escaped : high < 0 ?
			// BMP codepoint
			String.fromCharCode(high + 0x10000) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
		},


		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function () {
			setDocument();
		};

		// Optimize for push.apply( _, NodeList )
		try {
			push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
			// Support: Android<4.0
			// Detect silently failing push.apply
			arr[preferredDoc.childNodes.length].nodeType;
		} catch (e) {
			push = { apply: arr.length ?

				// Leverage slice if possible
				function (target, els) {
					push_native.apply(target, slice.call(els));
				} :

				// Support: IE<9
				// Otherwise append directly
				function (target, els) {
					var j = target.length,
					    i = 0;
					// Can't trust NodeList.length
					while (target[j++] = els[i++]) {}
					target.length = j - 1;
				}
			};
		}

		function Sizzle(selector, context, results, seed) {
			var m,
			    i,
			    elem,
			    nid,
			    nidselect,
			    match,
			    groups,
			    newSelector,
			    newContext = context && context.ownerDocument,


			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

			results = results || [];

			// Return early from calls with invalid selector or context
			if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

				return results;
			}

			// Try to shortcut find operations (as opposed to filters) in HTML documents
			if (!seed) {

				if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
					setDocument(context);
				}
				context = context || document;

				if (documentIsHTML) {

					// If the selector is sufficiently simple, try using a "get*By*" DOM method
					// (excepting DocumentFragment context, where the methods don't exist)
					if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

						// ID selector
						if (m = match[1]) {

							// Document context
							if (nodeType === 9) {
								if (elem = context.getElementById(m)) {

									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if (elem.id === m) {
										results.push(elem);
										return results;
									}
								} else {
									return results;
								}

								// Element context
							} else {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {

									results.push(elem);
									return results;
								}
							}

							// Type selector
						} else if (match[2]) {
							push.apply(results, context.getElementsByTagName(selector));
							return results;

							// Class selector
						} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {

							push.apply(results, context.getElementsByClassName(m));
							return results;
						}
					}

					// Take advantage of querySelectorAll
					if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {

						if (nodeType !== 1) {
							newContext = context;
							newSelector = selector;

							// qSA looks outside Element context, which is not what we want
							// Thanks to Andrew Dupont for this workaround technique
							// Support: IE <=8
							// Exclude object elements
						} else if (context.nodeName.toLowerCase() !== "object") {

							// Capture the context ID, setting it first if necessary
							if (nid = context.getAttribute("id")) {
								nid = nid.replace(rescape, "\\$&");
							} else {
								context.setAttribute("id", nid = expando);
							}

							// Prefix every selector in the list
							groups = tokenize(selector);
							i = groups.length;
							nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
							while (i--) {
								groups[i] = nidselect + " " + toSelector(groups[i]);
							}
							newSelector = groups.join(",");

							// Expand context for sibling selectors
							newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
						}

						if (newSelector) {
							try {
								push.apply(results, newContext.querySelectorAll(newSelector));
								return results;
							} catch (qsaError) {} finally {
								if (nid === expando) {
									context.removeAttribute("id");
								}
							}
						}
					}
				}
			}

			// All others
			return select(selector.replace(rtrim, "$1"), context, results, seed);
		}

		/**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
		function createCache() {
			var keys = [];

			function cache(key, value) {
				// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
				if (keys.push(key + " ") > Expr.cacheLength) {
					// Only keep the most recent entries
					delete cache[keys.shift()];
				}
				return cache[key + " "] = value;
			}
			return cache;
		}

		/**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
		function markFunction(fn) {
			fn[expando] = true;
			return fn;
		}

		/**
   * Support testing using an element
   * @param {Function} fn Passed the created div and expects a boolean result
   */
		function assert(fn) {
			var div = document.createElement("div");

			try {
				return !!fn(div);
			} catch (e) {
				return false;
			} finally {
				// Remove from its parent by default
				if (div.parentNode) {
					div.parentNode.removeChild(div);
				}
				// release memory in IE
				div = null;
			}
		}

		/**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
		function addHandle(attrs, handler) {
			var arr = attrs.split("|"),
			    i = arr.length;

			while (i--) {
				Expr.attrHandle[arr[i]] = handler;
			}
		}

		/**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
		function siblingCheck(a, b) {
			var cur = b && a,
			    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

			// Use IE sourceIndex if available on both nodes
			if (diff) {
				return diff;
			}

			// Check if b follows a
			if (cur) {
				while (cur = cur.nextSibling) {
					if (cur === b) {
						return -1;
					}
				}
			}

			return a ? 1 : -1;
		}

		/**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
		function createInputPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
		function createButtonPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return (name === "input" || name === "button") && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
		function createPositionalPseudo(fn) {
			return markFunction(function (argument) {
				argument = +argument;
				return markFunction(function (seed, matches) {
					var j,
					    matchIndexes = fn([], seed.length, argument),
					    i = matchIndexes.length;

					// Match elements found at the specified indexes
					while (i--) {
						if (seed[j = matchIndexes[i]]) {
							seed[j] = !(matches[j] = seed[j]);
						}
					}
				});
			});
		}

		/**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
		function testContext(context) {
			return context && typeof context.getElementsByTagName !== "undefined" && context;
		}

		// Expose support vars for convenience
		support = Sizzle.support = {};

		/**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
		isXML = Sizzle.isXML = function (elem) {
			// documentElement is verified for cases where it doesn't yet exist
			// (such as loading iframes in IE - #4833)
			var documentElement = elem && (elem.ownerDocument || elem).documentElement;
			return documentElement ? documentElement.nodeName !== "HTML" : false;
		};

		/**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
		setDocument = Sizzle.setDocument = function (node) {
			var hasCompare,
			    parent,
			    doc = node ? node.ownerDocument || node : preferredDoc;

			// Return early if doc is invalid or already selected
			if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
				return document;
			}

			// Update global variables
			document = doc;
			docElem = document.documentElement;
			documentIsHTML = !isXML(document);

			// Support: IE 9-11, Edge
			// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
			if ((parent = document.defaultView) && parent.top !== parent) {
				// Support: IE 11
				if (parent.addEventListener) {
					parent.addEventListener("unload", unloadHandler, false);

					// Support: IE 9 - 10 only
				} else if (parent.attachEvent) {
					parent.attachEvent("onunload", unloadHandler);
				}
			}

			/* Attributes
   ---------------------------------------------------------------------- */

			// Support: IE<8
			// Verify that getAttribute really returns attributes and not properties
			// (excepting IE8 booleans)
			support.attributes = assert(function (div) {
				div.className = "i";
				return !div.getAttribute("className");
			});

			/* getElement(s)By*
   ---------------------------------------------------------------------- */

			// Check if getElementsByTagName("*") returns only elements
			support.getElementsByTagName = assert(function (div) {
				div.appendChild(document.createComment(""));
				return !div.getElementsByTagName("*").length;
			});

			// Support: IE<9
			support.getElementsByClassName = rnative.test(document.getElementsByClassName);

			// Support: IE<10
			// Check if getElementById returns elements by name
			// The broken getElementById methods don't pick up programatically-set names,
			// so use a roundabout getElementsByName test
			support.getById = assert(function (div) {
				docElem.appendChild(div).id = expando;
				return !document.getElementsByName || !document.getElementsByName(expando).length;
			});

			// ID find and filter
			if (support.getById) {
				Expr.find["ID"] = function (id, context) {
					if (typeof context.getElementById !== "undefined" && documentIsHTML) {
						var m = context.getElementById(id);
						return m ? [m] : [];
					}
				};
				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						return elem.getAttribute("id") === attrId;
					};
				};
			} else {
				// Support: IE6/7
				// getElementById is not reliable as a find shortcut
				delete Expr.find["ID"];

				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
						return node && node.value === attrId;
					};
				};
			}

			// Tag
			Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
				if (typeof context.getElementsByTagName !== "undefined") {
					return context.getElementsByTagName(tag);

					// DocumentFragment nodes don't have gEBTN
				} else if (support.qsa) {
					return context.querySelectorAll(tag);
				}
			} : function (tag, context) {
				var elem,
				    tmp = [],
				    i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName(tag);

				// Filter out possible comments
				if (tag === "*") {
					while (elem = results[i++]) {
						if (elem.nodeType === 1) {
							tmp.push(elem);
						}
					}

					return tmp;
				}
				return results;
			};

			// Class
			Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
				if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
					return context.getElementsByClassName(className);
				}
			};

			/* QSA/matchesSelector
   ---------------------------------------------------------------------- */

			// QSA and matchesSelector support

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			rbuggyMatches = [];

			// qSa(:focus) reports false when true (Chrome 21)
			// We allow this because of a bug in IE8/9 that throws an error
			// whenever `document.activeElement` is accessed on an iframe
			// So, we allow :focus to pass through QSA all the time to avoid the IE error
			// See http://bugs.jquery.com/ticket/13378
			rbuggyQSA = [];

			if (support.qsa = rnative.test(document.querySelectorAll)) {
				// Build QSA regex
				// Regex strategy adopted from Diego Perini
				assert(function (div) {
					// Select is set to empty string on purpose
					// This is to test IE's treatment of not explicitly
					// setting a boolean content attribute,
					// since its presence should be enough
					// http://bugs.jquery.com/ticket/12359
					docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";

					// Support: IE8, Opera 11-12.16
					// Nothing should be selected when empty strings follow ^= or $= or *=
					// The test attribute must be unknown in Opera but "safe" for WinRT
					// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
					if (div.querySelectorAll("[msallowcapture^='']").length) {
						rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
					}

					// Support: IE8
					// Boolean attributes and "value" are not treated correctly
					if (!div.querySelectorAll("[selected]").length) {
						rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
					}

					// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
					if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
						rbuggyQSA.push("~=");
					}

					// Webkit/Opera - :checked should return selected option elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":checked").length) {
						rbuggyQSA.push(":checked");
					}

					// Support: Safari 8+, iOS 8+
					// https://bugs.webkit.org/show_bug.cgi?id=136851
					// In-page `selector#id sibing-combinator selector` fails
					if (!div.querySelectorAll("a#" + expando + "+*").length) {
						rbuggyQSA.push(".#.+[+~]");
					}
				});

				assert(function (div) {
					// Support: Windows 8 Native Apps
					// The type and name attributes are restricted during .innerHTML assignment
					var input = document.createElement("input");
					input.setAttribute("type", "hidden");
					div.appendChild(input).setAttribute("name", "D");

					// Support: IE8
					// Enforce case-sensitivity of name attribute
					if (div.querySelectorAll("[name=d]").length) {
						rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
					}

					// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":enabled").length) {
						rbuggyQSA.push(":enabled", ":disabled");
					}

					// Opera 10-11 does not throw on post-comma invalid pseudos
					div.querySelectorAll("*,:x");
					rbuggyQSA.push(",.*:");
				});
			}

			if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {

				assert(function (div) {
					// Check to see if it's possible to do matchesSelector
					// on a disconnected node (IE 9)
					support.disconnectedMatch = matches.call(div, "div");

					// This should fail with an exception
					// Gecko does not error, returns false instead
					matches.call(div, "[s!='']:x");
					rbuggyMatches.push("!=", pseudos);
				});
			}

			rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
			rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

			/* Contains
   ---------------------------------------------------------------------- */
			hasCompare = rnative.test(docElem.compareDocumentPosition);

			// Element contains another
			// Purposefully self-exclusive
			// As in, an element does not contain itself
			contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
				    bup = b && b.parentNode;
				return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
			} : function (a, b) {
				if (b) {
					while (b = b.parentNode) {
						if (b === a) {
							return true;
						}
					}
				}
				return false;
			};

			/* Sorting
   ---------------------------------------------------------------------- */

			// Document order sorting
			sortOrder = hasCompare ? function (a, b) {

				// Flag for duplicate removal
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				// Sort on method existence if only one input has compareDocumentPosition
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if (compare) {
					return compare;
				}

				// Calculate position if both inputs belong to the same document
				compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

				// Otherwise we know they are disconnected
				1;

				// Disconnected nodes
				if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {

					// Choose the first element that is related to our preferred document
					if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
						return -1;
					}
					if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
						return 1;
					}

					// Maintain original order
					return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
				}

				return compare & 4 ? -1 : 1;
			} : function (a, b) {
				// Exit early if the nodes are identical
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				var cur,
				    i = 0,
				    aup = a.parentNode,
				    bup = b.parentNode,
				    ap = [a],
				    bp = [b];

				// Parentless nodes are either documents or disconnected
				if (!aup || !bup) {
					return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

					// If the nodes are siblings, we can do a quick check
				} else if (aup === bup) {
					return siblingCheck(a, b);
				}

				// Otherwise we need full lists of their ancestors for comparison
				cur = a;
				while (cur = cur.parentNode) {
					ap.unshift(cur);
				}
				cur = b;
				while (cur = cur.parentNode) {
					bp.unshift(cur);
				}

				// Walk down the tree looking for a discrepancy
				while (ap[i] === bp[i]) {
					i++;
				}

				return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck(ap[i], bp[i]) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
			};

			return document;
		};

		Sizzle.matches = function (expr, elements) {
			return Sizzle(expr, null, null, elements);
		};

		Sizzle.matchesSelector = function (elem, expr) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			// Make sure that attribute selectors are quoted
			expr = expr.replace(rattributeQuotes, "='$1']");

			if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

				try {
					var ret = matches.call(elem, expr);

					// IE 9's matchesSelector returns false on disconnected nodes
					if (ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11) {
						return ret;
					}
				} catch (e) {}
			}

			return Sizzle(expr, document, null, [elem]).length > 0;
		};

		Sizzle.contains = function (context, elem) {
			// Set document vars if needed
			if ((context.ownerDocument || context) !== document) {
				setDocument(context);
			}
			return contains(context, elem);
		};

		Sizzle.attr = function (elem, name) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			var fn = Expr.attrHandle[name.toLowerCase()],

			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

			return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
		};

		Sizzle.error = function (msg) {
			throw new Error("Syntax error, unrecognized expression: " + msg);
		};

		/**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
		Sizzle.uniqueSort = function (results) {
			var elem,
			    duplicates = [],
			    j = 0,
			    i = 0;

			// Unless we *know* we can detect duplicates, assume their presence
			hasDuplicate = !support.detectDuplicates;
			sortInput = !support.sortStable && results.slice(0);
			results.sort(sortOrder);

			if (hasDuplicate) {
				while (elem = results[i++]) {
					if (elem === results[i]) {
						j = duplicates.push(i);
					}
				}
				while (j--) {
					results.splice(duplicates[j], 1);
				}
			}

			// Clear input after sorting to release objects
			// See https://github.com/jquery/sizzle/pull/225
			sortInput = null;

			return results;
		};

		/**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
		getText = Sizzle.getText = function (elem) {
			var node,
			    ret = "",
			    i = 0,
			    nodeType = elem.nodeType;

			if (!nodeType) {
				// If no nodeType, this is expected to be an array
				while (node = elem[i++]) {
					// Do not traverse comment nodes
					ret += getText(node);
				}
			} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
				// Use textContent for elements
				// innerText usage removed for consistency of new lines (jQuery #11153)
				if (typeof elem.textContent === "string") {
					return elem.textContent;
				} else {
					// Traverse its children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						ret += getText(elem);
					}
				}
			} else if (nodeType === 3 || nodeType === 4) {
				return elem.nodeValue;
			}
			// Do not include comment or processing instruction nodes

			return ret;
		};

		Expr = Sizzle.selectors = {

			// Can be adjusted by the user
			cacheLength: 50,

			createPseudo: markFunction,

			match: matchExpr,

			attrHandle: {},

			find: {},

			relative: {
				">": { dir: "parentNode", first: true },
				" ": { dir: "parentNode" },
				"+": { dir: "previousSibling", first: true },
				"~": { dir: "previousSibling" }
			},

			preFilter: {
				"ATTR": function (match) {
					match[1] = match[1].replace(runescape, funescape);

					// Move the given value to match[3] whether quoted or unquoted
					match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

					if (match[2] === "~=") {
						match[3] = " " + match[3] + " ";
					}

					return match.slice(0, 4);
				},

				"CHILD": function (match) {
					/* matches from matchExpr["CHILD"]
     	1 type (only|nth|...)
     	2 what (child|of-type)
     	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
     	4 xn-component of xn+y argument ([+-]?\d*n|)
     	5 sign of xn-component
     	6 x of xn-component
     	7 sign of y-component
     	8 y of y-component
     */
					match[1] = match[1].toLowerCase();

					if (match[1].slice(0, 3) === "nth") {
						// nth-* requires argument
						if (!match[3]) {
							Sizzle.error(match[0]);
						}

						// numeric x and y parameters for Expr.filter.CHILD
						// remember that false/true cast respectively to 0/1
						match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
						match[5] = +(match[7] + match[8] || match[3] === "odd");

						// other types prohibit arguments
					} else if (match[3]) {
						Sizzle.error(match[0]);
					}

					return match;
				},

				"PSEUDO": function (match) {
					var excess,
					    unquoted = !match[6] && match[2];

					if (matchExpr["CHILD"].test(match[0])) {
						return null;
					}

					// Accept quoted arguments as-is
					if (match[3]) {
						match[2] = match[4] || match[5] || "";

						// Strip excess characters from unquoted arguments
					} else if (unquoted && rpseudo.test(unquoted) && (
					// Get excess from tokenize (recursively)
					excess = tokenize(unquoted, true)) && (
					// advance to the next closing parenthesis
					excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

						// excess is a negative index
						match[0] = match[0].slice(0, excess);
						match[2] = unquoted.slice(0, excess);
					}

					// Return only captures needed by the pseudo filter method (type and argument)
					return match.slice(0, 3);
				}
			},

			filter: {

				"TAG": function (nodeNameSelector) {
					var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
					return nodeNameSelector === "*" ? function () {
						return true;
					} : function (elem) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
				},

				"CLASS": function (className) {
					var pattern = classCache[className + " "];

					return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
						return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
					});
				},

				"ATTR": function (name, operator, check) {
					return function (elem) {
						var result = Sizzle.attr(elem, name);

						if (result == null) {
							return operator === "!=";
						}
						if (!operator) {
							return true;
						}

						result += "";

						return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
					};
				},

				"CHILD": function (type, what, argument, first, last) {
					var simple = type.slice(0, 3) !== "nth",
					    forward = type.slice(-4) !== "last",
					    ofType = what === "of-type";

					return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function (elem) {
						return !!elem.parentNode;
					} : function (elem, context, xml) {
						var cache,
						    uniqueCache,
						    outerCache,
						    node,
						    nodeIndex,
						    start,
						    dir = simple !== forward ? "nextSibling" : "previousSibling",
						    parent = elem.parentNode,
						    name = ofType && elem.nodeName.toLowerCase(),
						    useCache = !xml && !ofType,
						    diff = false;

						if (parent) {

							// :(first|last|only)-(child|of-type)
							if (simple) {
								while (dir) {
									node = elem;
									while (node = node[dir]) {
										if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [forward ? parent.firstChild : parent.lastChild];

							// non-xml :nth-child(...) stores cache data on `parent`
							if (forward && useCache) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[expando] || (node[expando] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

								cache = uniqueCache[type] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = nodeIndex && cache[2];
								node = nodeIndex && parent.childNodes[nodeIndex];

								while (node = ++nodeIndex && node && node[dir] || (

								// Fallback to seeking `elem` from the start
								diff = nodeIndex = 0) || start.pop()) {

									// When found, cache indexes on `parent` and break
									if (node.nodeType === 1 && ++diff && node === elem) {
										uniqueCache[type] = [dirruns, nodeIndex, diff];
										break;
									}
								}
							} else {
								// Use previously-cached element index if available
								if (useCache) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[expando] || (node[expando] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

									cache = uniqueCache[type] || [];
									nodeIndex = cache[0] === dirruns && cache[1];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if (diff === false) {
									// Use the same loop as above to seek `elem` from the start
									while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {

										if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {

											// Cache the index of each encountered element
											if (useCache) {
												outerCache = node[expando] || (node[expando] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

												uniqueCache[type] = [dirruns, diff];
											}

											if (node === elem) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || diff % first === 0 && diff / first >= 0;
						}
					};
				},

				"PSEUDO": function (pseudo, argument) {
					// pseudo-class names are case-insensitive
					// http://www.w3.org/TR/selectors/#pseudo-classes
					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
					// Remember that setFilters inherits from pseudos
					var args,
					    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

					// The user may use createPseudo to indicate that
					// arguments are needed to create the filter function
					// just as Sizzle does
					if (fn[expando]) {
						return fn(argument);
					}

					// But maintain support for old signatures
					if (fn.length > 1) {
						args = [pseudo, pseudo, "", argument];
						return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
							var idx,
							    matched = fn(seed, argument),
							    i = matched.length;
							while (i--) {
								idx = indexOf(seed, matched[i]);
								seed[idx] = !(matches[idx] = matched[i]);
							}
						}) : function (elem) {
							return fn(elem, 0, args);
						};
					}

					return fn;
				}
			},

			pseudos: {
				// Potentially complex pseudos
				"not": markFunction(function (selector) {
					// Trim the selector passed to compile
					// to avoid treating leading and trailing
					// spaces as combinators
					var input = [],
					    results = [],
					    matcher = compile(selector.replace(rtrim, "$1"));

					return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
						var elem,
						    unmatched = matcher(seed, null, xml, []),
						    i = seed.length;

						// Match elements unmatched by `matcher`
						while (i--) {
							if (elem = unmatched[i]) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) : function (elem, context, xml) {
						input[0] = elem;
						matcher(input, null, xml, results);
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
				}),

				"has": markFunction(function (selector) {
					return function (elem) {
						return Sizzle(selector, elem).length > 0;
					};
				}),

				"contains": markFunction(function (text) {
					text = text.replace(runescape, funescape);
					return function (elem) {
						return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
					};
				}),

				// "Whether an element is represented by a :lang() selector
				// is based solely on the element's language value
				// being equal to the identifier C,
				// or beginning with the identifier C immediately followed by "-".
				// The matching of C against the element's language value is performed case-insensitively.
				// The identifier C does not have to be a valid language name."
				// http://www.w3.org/TR/selectors/#lang-pseudo
				"lang": markFunction(function (lang) {
					// lang value must be a valid identifier
					if (!ridentifier.test(lang || "")) {
						Sizzle.error("unsupported lang: " + lang);
					}
					lang = lang.replace(runescape, funescape).toLowerCase();
					return function (elem) {
						var elemLang;
						do {
							if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {

								elemLang = elemLang.toLowerCase();
								return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
							}
						} while ((elem = elem.parentNode) && elem.nodeType === 1);
						return false;
					};
				}),

				// Miscellaneous
				"target": function (elem) {
					var hash = window.location && window.location.hash;
					return hash && hash.slice(1) === elem.id;
				},

				"root": function (elem) {
					return elem === docElem;
				},

				"focus": function (elem) {
					return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
				},

				// Boolean properties
				"enabled": function (elem) {
					return elem.disabled === false;
				},

				"disabled": function (elem) {
					return elem.disabled === true;
				},

				"checked": function (elem) {
					// In CSS3, :checked should return both checked and selected elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					var nodeName = elem.nodeName.toLowerCase();
					return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
				},

				"selected": function (elem) {
					// Accessing this property makes selected-by-default
					// options in Safari work properly
					if (elem.parentNode) {
						elem.parentNode.selectedIndex;
					}

					return elem.selected === true;
				},

				// Contents
				"empty": function (elem) {
					// http://www.w3.org/TR/selectors/#empty-pseudo
					// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
					//   but not by others (comment: 8; processing instruction: 7; etc.)
					// nodeType < 6 works because attributes (2) do not appear as children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						if (elem.nodeType < 6) {
							return false;
						}
					}
					return true;
				},

				"parent": function (elem) {
					return !Expr.pseudos["empty"](elem);
				},

				// Element/input types
				"header": function (elem) {
					return rheader.test(elem.nodeName);
				},

				"input": function (elem) {
					return rinputs.test(elem.nodeName);
				},

				"button": function (elem) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === "button" || name === "button";
				},

				"text": function (elem) {
					var attr;
					return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
				},

				// Position-in-collection
				"first": createPositionalPseudo(function () {
					return [0];
				}),

				"last": createPositionalPseudo(function (matchIndexes, length) {
					return [length - 1];
				}),

				"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
					return [argument < 0 ? argument + length : argument];
				}),

				"even": createPositionalPseudo(function (matchIndexes, length) {
					var i = 0;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"odd": createPositionalPseudo(function (matchIndexes, length) {
					var i = 1;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; --i >= 0;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; ++i < length;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				})
			}
		};

		Expr.pseudos["nth"] = Expr.pseudos["eq"];

		// Add button/input type pseudos
		for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
			Expr.pseudos[i] = createInputPseudo(i);
		}
		for (i in { submit: true, reset: true }) {
			Expr.pseudos[i] = createButtonPseudo(i);
		}

		// Easy API for creating new setFilters
		function setFilters() {}
		setFilters.prototype = Expr.filters = Expr.pseudos;
		Expr.setFilters = new setFilters();

		tokenize = Sizzle.tokenize = function (selector, parseOnly) {
			var matched,
			    match,
			    tokens,
			    type,
			    soFar,
			    groups,
			    preFilters,
			    cached = tokenCache[selector + " "];

			if (cached) {
				return parseOnly ? 0 : cached.slice(0);
			}

			soFar = selector;
			groups = [];
			preFilters = Expr.preFilter;

			while (soFar) {

				// Comma and first run
				if (!matched || (match = rcomma.exec(soFar))) {
					if (match) {
						// Don't consume trailing commas as valid
						soFar = soFar.slice(match[0].length) || soFar;
					}
					groups.push(tokens = []);
				}

				matched = false;

				// Combinators
				if (match = rcombinators.exec(soFar)) {
					matched = match.shift();
					tokens.push({
						value: matched,
						// Cast descendant combinators to space
						type: match[0].replace(rtrim, " ")
					});
					soFar = soFar.slice(matched.length);
				}

				// Filters
				for (type in Expr.filter) {
					if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
						matched = match.shift();
						tokens.push({
							value: matched,
							type: type,
							matches: match
						});
						soFar = soFar.slice(matched.length);
					}
				}

				if (!matched) {
					break;
				}
			}

			// Return the length of the invalid excess
			// if we're just parsing
			// Otherwise, throw an error or return tokens
			return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
			// Cache the tokens
			tokenCache(selector, groups).slice(0);
		};

		function toSelector(tokens) {
			var i = 0,
			    len = tokens.length,
			    selector = "";
			for (; i < len; i++) {
				selector += tokens[i].value;
			}
			return selector;
		}

		function addCombinator(matcher, combinator, base) {
			var dir = combinator.dir,
			    checkNonElements = base && dir === "parentNode",
			    doneName = done++;

			return combinator.first ?
			// Check against closest ancestor/preceding element
			function (elem, context, xml) {
				while (elem = elem[dir]) {
					if (elem.nodeType === 1 || checkNonElements) {
						return matcher(elem, context, xml);
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function (elem, context, xml) {
				var oldCache,
				    uniqueCache,
				    outerCache,
				    newCache = [dirruns, doneName];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if (xml) {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							if (matcher(elem, context, xml)) {
								return true;
							}
						}
					}
				} else {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							outerCache = elem[expando] || (elem[expando] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

							if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

								// Assign to newCache so results back-propagate to previous elements
								return newCache[2] = oldCache[2];
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[dir] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if (newCache[2] = matcher(elem, context, xml)) {
									return true;
								}
							}
						}
					}
				}
			};
		}

		function elementMatcher(matchers) {
			return matchers.length > 1 ? function (elem, context, xml) {
				var i = matchers.length;
				while (i--) {
					if (!matchers[i](elem, context, xml)) {
						return false;
					}
				}
				return true;
			} : matchers[0];
		}

		function multipleContexts(selector, contexts, results) {
			var i = 0,
			    len = contexts.length;
			for (; i < len; i++) {
				Sizzle(selector, contexts[i], results);
			}
			return results;
		}

		function condense(unmatched, map, filter, context, xml) {
			var elem,
			    newUnmatched = [],
			    i = 0,
			    len = unmatched.length,
			    mapped = map != null;

			for (; i < len; i++) {
				if (elem = unmatched[i]) {
					if (!filter || filter(elem, context, xml)) {
						newUnmatched.push(elem);
						if (mapped) {
							map.push(i);
						}
					}
				}
			}

			return newUnmatched;
		}

		function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
			if (postFilter && !postFilter[expando]) {
				postFilter = setMatcher(postFilter);
			}
			if (postFinder && !postFinder[expando]) {
				postFinder = setMatcher(postFinder, postSelector);
			}
			return markFunction(function (seed, results, context, xml) {
				var temp,
				    i,
				    elem,
				    preMap = [],
				    postMap = [],
				    preexisting = results.length,


				// Get initial elements from seed or context
				elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),


				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
				    matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || (seed ? preFilter : preexisting || postFilter) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results : matcherIn;

				// Find primary matches
				if (matcher) {
					matcher(matcherIn, matcherOut, context, xml);
				}

				// Apply postFilter
				if (postFilter) {
					temp = condense(matcherOut, postMap);
					postFilter(temp, [], context, xml);

					// Un-match failing elements by moving them back to matcherIn
					i = temp.length;
					while (i--) {
						if (elem = temp[i]) {
							matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
						}
					}
				}

				if (seed) {
					if (postFinder || preFilter) {
						if (postFinder) {
							// Get the final matcherOut by condensing this intermediate into postFinder contexts
							temp = [];
							i = matcherOut.length;
							while (i--) {
								if (elem = matcherOut[i]) {
									// Restore matcherIn since elem is not yet a final match
									temp.push(matcherIn[i] = elem);
								}
							}
							postFinder(null, matcherOut = [], temp, xml);
						}

						// Move matched elements from seed to results to keep them synchronized
						i = matcherOut.length;
						while (i--) {
							if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

								seed[temp] = !(results[temp] = elem);
							}
						}
					}

					// Add elements to results, through postFinder if defined
				} else {
					matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
					if (postFinder) {
						postFinder(null, results, matcherOut, xml);
					} else {
						push.apply(results, matcherOut);
					}
				}
			});
		}

		function matcherFromTokens(tokens) {
			var checkContext,
			    matcher,
			    j,
			    len = tokens.length,
			    leadingRelative = Expr.relative[tokens[0].type],
			    implicitRelative = leadingRelative || Expr.relative[" "],
			    i = leadingRelative ? 1 : 0,


			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator(function (elem) {
				return elem === checkContext;
			}, implicitRelative, true),
			    matchAnyContext = addCombinator(function (elem) {
				return indexOf(checkContext, elem) > -1;
			}, implicitRelative, true),
			    matchers = [function (elem, context, xml) {
				var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			}];

			for (; i < len; i++) {
				if (matcher = Expr.relative[tokens[i].type]) {
					matchers = [addCombinator(elementMatcher(matchers), matcher)];
				} else {
					matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

					// Return special upon seeing a positional matcher
					if (matcher[expando]) {
						// Find the next relative operator (if any) for proper handling
						j = ++i;
						for (; j < len; j++) {
							if (Expr.relative[tokens[j].type]) {
								break;
							}
						}
						return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
					}
					matchers.push(matcher);
				}
			}

			return elementMatcher(matchers);
		}

		function matcherFromGroupMatchers(elementMatchers, setMatchers) {
			var bySet = setMatchers.length > 0,
			    byElement = elementMatchers.length > 0,
			    superMatcher = function (seed, context, xml, results, outermost) {
				var elem,
				    j,
				    matcher,
				    matchedCount = 0,
				    i = "0",
				    unmatched = seed && [],
				    setMatched = [],
				    contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]("*", outermost),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
				    len = elems.length;

				if (outermost) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for (; i !== len && (elem = elems[i]) != null; i++) {
					if (byElement && elem) {
						j = 0;
						if (!context && elem.ownerDocument !== document) {
							setDocument(elem);
							xml = !documentIsHTML;
						}
						while (matcher = elementMatchers[j++]) {
							if (matcher(elem, context || document, xml)) {
								results.push(elem);
								break;
							}
						}
						if (outermost) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if (bySet) {
						// They will have gone through all possible matchers
						if (elem = !matcher && elem) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if (seed) {
							unmatched.push(elem);
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if (bySet && i !== matchedCount) {
					j = 0;
					while (matcher = setMatchers[j++]) {
						matcher(unmatched, setMatched, context, xml);
					}

					if (seed) {
						// Reintegrate element matches to eliminate the need for sorting
						if (matchedCount > 0) {
							while (i--) {
								if (!(unmatched[i] || setMatched[i])) {
									setMatched[i] = pop.call(results);
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense(setMatched);
					}

					// Add matches to results
					push.apply(results, setMatched);

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {

						Sizzle.uniqueSort(results);
					}
				}

				// Override manipulation of globals by nested matchers
				if (outermost) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

			return bySet ? markFunction(superMatcher) : superMatcher;
		}

		compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
			var i,
			    setMatchers = [],
			    elementMatchers = [],
			    cached = compilerCache[selector + " "];

			if (!cached) {
				// Generate a function of recursive functions that can be used to check each element
				if (!match) {
					match = tokenize(selector);
				}
				i = match.length;
				while (i--) {
					cached = matcherFromTokens(match[i]);
					if (cached[expando]) {
						setMatchers.push(cached);
					} else {
						elementMatchers.push(cached);
					}
				}

				// Cache the compiled function
				cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

				// Save selector and tokenization
				cached.selector = selector;
			}
			return cached;
		};

		/**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
		select = Sizzle.select = function (selector, context, results, seed) {
			var i,
			    tokens,
			    token,
			    type,
			    find,
			    compiled = typeof selector === "function" && selector,
			    match = !seed && tokenize(selector = compiled.selector || selector);

			results = results || [];

			// Try to minimize operations if there is only one selector in the list and no seed
			// (the latter of which guarantees us context)
			if (match.length === 1) {

				// Reduce context if the leading compound selector is an ID
				tokens = match[0] = match[0].slice(0);
				if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

					context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
					if (!context) {
						return results;

						// Precompiled matchers will still verify ancestry, so step up a level
					} else if (compiled) {
						context = context.parentNode;
					}

					selector = selector.slice(tokens.shift().value.length);
				}

				// Fetch a seed set for right-to-left matching
				i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
				while (i--) {
					token = tokens[i];

					// Abort if we hit a combinator
					if (Expr.relative[type = token.type]) {
						break;
					}
					if (find = Expr.find[type]) {
						// Search, expanding context for leading sibling combinators
						if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice(i, 1);
							selector = seed.length && toSelector(tokens);
							if (!selector) {
								push.apply(results, seed);
								return results;
							}

							break;
						}
					}
				}
			}

			// Compile and execute a filtering function if one is not provided
			// Provide `match` to avoid retokenization if we modified the selector above
			(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
			return results;
		};

		// One-time assignments

		// Sort stability
		support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

		// Support: Chrome 14-35+
		// Always assume duplicates if they aren't passed to the comparison function
		support.detectDuplicates = !!hasDuplicate;

		// Initialize against the default document
		setDocument();

		// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
		// Detached nodes confoundingly follow *each other*
		support.sortDetached = assert(function (div1) {
			// Should return 1, but returns 4 (following)
			return div1.compareDocumentPosition(document.createElement("div")) & 1;
		});

		// Support: IE<8
		// Prevent attribute/property "interpolation"
		// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
		if (!assert(function (div) {
			div.innerHTML = "<a href='#'></a>";
			return div.firstChild.getAttribute("href") === "#";
		})) {
			addHandle("type|href|height|width", function (elem, name, isXML) {
				if (!isXML) {
					return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
				}
			});
		}

		// Support: IE<9
		// Use defaultValue in place of getAttribute("value")
		if (!support.attributes || !assert(function (div) {
			div.innerHTML = "<input/>";
			div.firstChild.setAttribute("value", "");
			return div.firstChild.getAttribute("value") === "";
		})) {
			addHandle("value", function (elem, name, isXML) {
				if (!isXML && elem.nodeName.toLowerCase() === "input") {
					return elem.defaultValue;
				}
			});
		}

		// Support: IE<9
		// Use getAttributeNode to fetch booleans when getAttribute lies
		if (!assert(function (div) {
			return div.getAttribute("disabled") == null;
		})) {
			addHandle(booleans, function (elem, name, isXML) {
				var val;
				if (!isXML) {
					return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
				}
			});
		}

		return Sizzle;
	}(window);

	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;

	var dir = function (elem, dir, until) {
		var matched = [],
		    truncate = until !== undefined;

		while ((elem = elem[dir]) && elem.nodeType !== 9) {
			if (elem.nodeType === 1) {
				if (truncate && jQuery(elem).is(until)) {
					break;
				}
				matched.push(elem);
			}
		}
		return matched;
	};

	var siblings = function (n, elem) {
		var matched = [];

		for (; n; n = n.nextSibling) {
			if (n.nodeType === 1 && n !== elem) {
				matched.push(n);
			}
		}

		return matched;
	};

	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;

	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow(elements, qualifier, not) {
		if (jQuery.isFunction(qualifier)) {
			return jQuery.grep(elements, function (elem, i) {
				/* jshint -W018 */
				return !!qualifier.call(elem, i, elem) !== not;
			});
		}

		if (qualifier.nodeType) {
			return jQuery.grep(elements, function (elem) {
				return elem === qualifier !== not;
			});
		}

		if (typeof qualifier === "string") {
			if (risSimple.test(qualifier)) {
				return jQuery.filter(qualifier, elements, not);
			}

			qualifier = jQuery.filter(qualifier, elements);
		}

		return jQuery.grep(elements, function (elem) {
			return indexOf.call(qualifier, elem) > -1 !== not;
		});
	}

	jQuery.filter = function (expr, elems, not) {
		var elem = elems[0];

		if (not) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
			return elem.nodeType === 1;
		}));
	};

	jQuery.fn.extend({
		find: function (selector) {
			var i,
			    len = this.length,
			    ret = [],
			    self = this;

			if (typeof selector !== "string") {
				return this.pushStack(jQuery(selector).filter(function () {
					for (i = 0; i < len; i++) {
						if (jQuery.contains(self[i], this)) {
							return true;
						}
					}
				}));
			}

			for (i = 0; i < len; i++) {
				jQuery.find(selector, self[i], ret);
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function (selector) {
			return this.pushStack(winnow(this, selector || [], false));
		},
		not: function (selector) {
			return this.pushStack(winnow(this, selector || [], true));
		},
		is: function (selector) {
			return !!winnow(this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
		}
	});

	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,


	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	    init = jQuery.fn.init = function (selector, context, root) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if (!selector) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if (typeof selector === "string") {
			if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [null, selector, null];
			} else {
				match = rquickExpr.exec(selector);
			}

			// Match html or make sure no context is specified for #id
			if (match && (match[1] || !context)) {

				// HANDLE: $(html) -> $(array)
				if (match[1]) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

					// HANDLE: $(html, props)
					if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
						for (match in context) {

							// Properties of context are called as methods if possible
							if (jQuery.isFunction(this[match])) {
								this[match](context[match]);

								// ...and otherwise set as attributes
							} else {
								this.attr(match, context[match]);
							}
						}
					}

					return this;

					// HANDLE: $(#id)
				} else {
					elem = document.getElementById(match[2]);

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if (elem && elem.parentNode) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

				// HANDLE: $(expr, $(...))
			} else if (!context || context.jquery) {
				return (context || root).find(selector);

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor(context).find(selector);
			}

			// HANDLE: $(DOMElement)
		} else if (selector.nodeType) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

			// HANDLE: $(function)
			// Shortcut for document ready
		} else if (jQuery.isFunction(selector)) {
			return root.ready !== undefined ? root.ready(selector) :

			// Execute immediately if ready is not present
			selector(jQuery);
		}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray(selector, this);
	};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery(document);

	var rparentsprev = /^(?:parents|prev(?:Until|All))/,


	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

	jQuery.fn.extend({
		has: function (target) {
			var targets = jQuery(target, this),
			    l = targets.length;

			return this.filter(function () {
				var i = 0;
				for (; i < l; i++) {
					if (jQuery.contains(this, targets[i])) {
						return true;
					}
				}
			});
		},

		closest: function (selectors, context) {
			var cur,
			    i = 0,
			    l = this.length,
			    matched = [],
			    pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

			for (; i < l; i++) {
				for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

					// Always skip document fragments
					if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

						matched.push(cur);
						break;
					}
				}
			}

			return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
		},

		// Determine the position of an element within the set
		index: function (elem) {

			// No argument, return index in parent
			if (!elem) {
				return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if (typeof elem === "string") {
				return indexOf.call(jQuery(elem), this[0]);
			}

			// Locate the position of the desired element
			return indexOf.call(this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem);
		},

		add: function (selector, context) {
			return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
		},

		addBack: function (selector) {
			return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
		}
	});

	function sibling(cur, dir) {
		while ((cur = cur[dir]) && cur.nodeType !== 1) {}
		return cur;
	}

	jQuery.each({
		parent: function (elem) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function (elem) {
			return dir(elem, "parentNode");
		},
		parentsUntil: function (elem, i, until) {
			return dir(elem, "parentNode", until);
		},
		next: function (elem) {
			return sibling(elem, "nextSibling");
		},
		prev: function (elem) {
			return sibling(elem, "previousSibling");
		},
		nextAll: function (elem) {
			return dir(elem, "nextSibling");
		},
		prevAll: function (elem) {
			return dir(elem, "previousSibling");
		},
		nextUntil: function (elem, i, until) {
			return dir(elem, "nextSibling", until);
		},
		prevUntil: function (elem, i, until) {
			return dir(elem, "previousSibling", until);
		},
		siblings: function (elem) {
			return siblings((elem.parentNode || {}).firstChild, elem);
		},
		children: function (elem) {
			return siblings(elem.firstChild);
		},
		contents: function (elem) {
			return elem.contentDocument || jQuery.merge([], elem.childNodes);
		}
	}, function (name, fn) {
		jQuery.fn[name] = function (until, selector) {
			var matched = jQuery.map(this, fn, until);

			if (name.slice(-5) !== "Until") {
				selector = until;
			}

			if (selector && typeof selector === "string") {
				matched = jQuery.filter(selector, matched);
			}

			if (this.length > 1) {

				// Remove duplicates
				if (!guaranteedUnique[name]) {
					jQuery.uniqueSort(matched);
				}

				// Reverse order for parents* and prev-derivatives
				if (rparentsprev.test(name)) {
					matched.reverse();
				}
			}

			return this.pushStack(matched);
		};
	});
	var rnotwhite = /\S+/g;

	// Convert String-formatted options into Object-formatted ones
	function createOptions(options) {
		var object = {};
		jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
			object[flag] = true;
		});
		return object;
	}

	/*
  * Create a callback list using the following parameters:
  *
  *	options: an optional list of space-separated options that will change how
  *			the callback list behaves or a more traditional option object
  *
  * By default a callback list will act like an event callback list and can be
  * "fired" multiple times.
  *
  * Possible options:
  *
  *	once:			will ensure the callback list can only be fired once (like a Deferred)
  *
  *	memory:			will keep track of previous values and will call any callback added
  *					after the list has been fired right away with the latest "memorized"
  *					values (like a Deferred)
  *
  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  *
  *	stopOnFalse:	interrupt callings when a callback returns false
  *
  */
	jQuery.Callbacks = function (options) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

		var // Flag to know if list is currently firing
		firing,


		// Last fire value for non-forgettable lists
		memory,


		// Flag to know if list was already fired
		fired,


		// Flag to prevent firing
		locked,


		// Actual callback list
		list = [],


		// Queue of execution data for repeatable lists
		queue = [],


		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,


		// Fire callbacks
		fire = function () {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for (; queue.length; firingIndex = -1) {
				memory = queue.shift();
				while (++firingIndex < list.length) {

					// Run callback and check for early termination
					if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if (!options.memory) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if (locked) {

				// Keep an empty list if we have data for future add calls
				if (memory) {
					list = [];

					// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},


		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function () {
				if (list) {

					// If we have memory from a past run, we should fire after adding
					if (memory && !firing) {
						firingIndex = list.length - 1;
						queue.push(memory);
					}

					(function add(args) {
						jQuery.each(args, function (_, arg) {
							if (jQuery.isFunction(arg)) {
								if (!options.unique || !self.has(arg)) {
									list.push(arg);
								}
							} else if (arg && arg.length && jQuery.type(arg) !== "string") {

								// Inspect recursively
								add(arg);
							}
						});
					})(arguments);

					if (memory && !firing) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function () {
				jQuery.each(arguments, function (_, arg) {
					var index;
					while ((index = jQuery.inArray(arg, list, index)) > -1) {
						list.splice(index, 1);

						// Handle firing indexes
						if (index <= firingIndex) {
							firingIndex--;
						}
					}
				});
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function (fn) {
				return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function () {
				if (list) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function () {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function () {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function () {
				locked = queue = [];
				if (!memory) {
					list = memory = "";
				}
				return this;
			},
			locked: function () {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function (context, args) {
				if (!locked) {
					args = args || [];
					args = [context, args.slice ? args.slice() : args];
					queue.push(args);
					if (!firing) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function () {
				self.fireWith(this, arguments);
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function () {
				return !!fired;
			}
		};

		return self;
	};

	jQuery.extend({

		Deferred: function (func) {
			var tuples = [

			// action, add listener, listener list, final state
			["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
			    state = "pending",
			    promise = {
				state: function () {
					return state;
				},
				always: function () {
					deferred.done(arguments).fail(arguments);
					return this;
				},
				then: function () /* fnDone, fnFail, fnProgress */{
					var fns = arguments;
					return jQuery.Deferred(function (newDefer) {
						jQuery.each(tuples, function (i, tuple) {
							var fn = jQuery.isFunction(fns[i]) && fns[i];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[tuple[1]](function () {
								var returned = fn && fn.apply(this, arguments);
								if (returned && jQuery.isFunction(returned.promise)) {
									returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
								} else {
									newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
								}
							});
						});
						fns = null;
					}).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function (obj) {
					return obj != null ? jQuery.extend(obj, promise) : promise;
				}
			},
			    deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each(tuples, function (i, tuple) {
				var list = tuple[2],
				    stateString = tuple[3];

				// promise[ done | fail | progress ] = list.add
				promise[tuple[1]] = list.add;

				// Handle state
				if (stateString) {
					list.add(function () {

						// state = [ resolved | rejected ]
						state = stateString;

						// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
				}

				// deferred[ resolve | reject | notify ]
				deferred[tuple[0]] = function () {
					deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
					return this;
				};
				deferred[tuple[0] + "With"] = list.fireWith;
			});

			// Make the deferred a promise
			promise.promise(deferred);

			// Call given func if any
			if (func) {
				func.call(deferred, deferred);
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function (subordinate /* , ..., subordinateN */) {
			var i = 0,
			    resolveValues = slice.call(arguments),
			    length = resolveValues.length,


			// the count of uncompleted subordinates
			remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,


			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),


			// Update function for both resolve and progress values
			updateFunc = function (i, contexts, values) {
				return function (value) {
					contexts[i] = this;
					values[i] = arguments.length > 1 ? slice.call(arguments) : value;
					if (values === progressValues) {
						deferred.notifyWith(contexts, values);
					} else if (! --remaining) {
						deferred.resolveWith(contexts, values);
					}
				};
			},
			    progressValues,
			    progressContexts,
			    resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if (length > 1) {
				progressValues = new Array(length);
				progressContexts = new Array(length);
				resolveContexts = new Array(length);
				for (; i < length; i++) {
					if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
						resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if (!remaining) {
				deferred.resolveWith(resolveContexts, resolveValues);
			}

			return deferred.promise();
		}
	});

	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function (fn) {

		// Add the callback
		jQuery.ready.promise().done(fn);

		return this;
	};

	jQuery.extend({

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function (hold) {
			if (hold) {
				jQuery.readyWait++;
			} else {
				jQuery.ready(true);
			}
		},

		// Handle when the DOM is ready
		ready: function (wait) {

			// Abort if there are pending holds or we're already ready
			if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if (wait !== true && --jQuery.readyWait > 0) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith(document, [jQuery]);

			// Trigger any bound ready events
			if (jQuery.fn.triggerHandler) {
				jQuery(document).triggerHandler("ready");
				jQuery(document).off("ready");
			}
		}
	});

	/**
  * The ready event handler and self cleanup method
  */
	function completed() {
		document.removeEventListener("DOMContentLoaded", completed);
		window.removeEventListener("load", completed);
		jQuery.ready();
	}

	jQuery.ready.promise = function (obj) {
		if (!readyList) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout(jQuery.ready);
			} else {

				// Use the handy event callback
				document.addEventListener("DOMContentLoaded", completed);

				// A fallback to window.onload, that will always work
				window.addEventListener("load", completed);
			}
		}
		return readyList.promise(obj);
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
		var i = 0,
		    len = elems.length,
		    bulk = key == null;

		// Sets many values
		if (jQuery.type(key) === "object") {
			chainable = true;
			for (i in key) {
				access(elems, fn, i, key[i], true, emptyGet, raw);
			}

			// Sets one value
		} else if (value !== undefined) {
			chainable = true;

			if (!jQuery.isFunction(value)) {
				raw = true;
			}

			if (bulk) {

				// Bulk operations run against the entire set
				if (raw) {
					fn.call(elems, value);
					fn = null;

					// ...except when executing function values
				} else {
					bulk = fn;
					fn = function (elem, key, value) {
						return bulk.call(jQuery(elem), value);
					};
				}
			}

			if (fn) {
				for (; i < len; i++) {
					fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
				}
			}
		}

		return chainable ? elems :

		// Gets
		bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
	};
	var acceptData = function (owner) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	};

	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function (owner, initial) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if (owner.nodeType) {
				owner[this.expando] = value;

				// Otherwise secure it in a non-enumerable, non-writable property
				// configurability must be true to allow the property to be
				// deleted with the delete operator
			} else {
				Object.defineProperty(owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				});
			}
			return owner[this.expando];
		},
		cache: function (owner) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if (!acceptData(owner)) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[this.expando];

			// If not, create one
			if (!value) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if (acceptData(owner)) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if (owner.nodeType) {
						owner[this.expando] = value;

						// Otherwise secure it in a non-enumerable property
						// configurable must be true to allow the property to be
						// deleted when data is removed
					} else {
						Object.defineProperty(owner, this.expando, {
							value: value,
							configurable: true
						});
					}
				}
			}

			return value;
		},
		set: function (owner, data, value) {
			var prop,
			    cache = this.cache(owner);

			// Handle: [ owner, key, value ] args
			if (typeof data === "string") {
				cache[data] = value;

				// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for (prop in data) {
					cache[prop] = data[prop];
				}
			}
			return cache;
		},
		get: function (owner, key) {
			return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
		},
		access: function (owner, key, value) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if (key === undefined || key && typeof key === "string" && value === undefined) {

				stored = this.get(owner, key);

				return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set(owner, key, value);

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function (owner, key) {
			var i,
			    name,
			    camel,
			    cache = owner[this.expando];

			if (cache === undefined) {
				return;
			}

			if (key === undefined) {
				this.register(owner);
			} else {

				// Support array or space separated string of keys
				if (jQuery.isArray(key)) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat(key.map(jQuery.camelCase));
				} else {
					camel = jQuery.camelCase(key);

					// Try the string as a key before any manipulation
					if (key in cache) {
						name = [key, camel];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ? [name] : name.match(rnotwhite) || [];
					}
				}

				i = name.length;

				while (i--) {
					delete cache[name[i]];
				}
			}

			// Remove the expando if there's no more data
			if (key === undefined || jQuery.isEmptyObject(cache)) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if (owner.nodeType) {
					owner[this.expando] = undefined;
				} else {
					delete owner[this.expando];
				}
			}
		},
		hasData: function (owner) {
			var cache = owner[this.expando];
			return cache !== undefined && !jQuery.isEmptyObject(cache);
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();

	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	    rmultiDash = /[A-Z]/g;

	function dataAttr(elem, key, data) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if (data === undefined && elem.nodeType === 1) {
			name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
			data = elem.getAttribute(name);

			if (typeof data === "string") {
				try {
					data = data === "true" ? true : data === "false" ? false : data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
				} catch (e) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set(elem, key, data);
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function (elem) {
			return dataUser.hasData(elem) || dataPriv.hasData(elem);
		},

		data: function (elem, name, data) {
			return dataUser.access(elem, name, data);
		},

		removeData: function (elem, name) {
			dataUser.remove(elem, name);
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function (elem, name, data) {
			return dataPriv.access(elem, name, data);
		},

		_removeData: function (elem, name) {
			dataPriv.remove(elem, name);
		}
	});

	jQuery.fn.extend({
		data: function (key, value) {
			var i,
			    name,
			    data,
			    elem = this[0],
			    attrs = elem && elem.attributes;

			// Gets all values
			if (key === undefined) {
				if (this.length) {
					data = dataUser.get(elem);

					if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
						i = attrs.length;
						while (i--) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if (attrs[i]) {
								name = attrs[i].name;
								if (name.indexOf("data-") === 0) {
									name = jQuery.camelCase(name.slice(5));
									dataAttr(elem, name, data[name]);
								}
							}
						}
						dataPriv.set(elem, "hasDataAttrs", true);
					}
				}

				return data;
			}

			// Sets multiple values
			if (typeof key === "object") {
				return this.each(function () {
					dataUser.set(this, key);
				});
			}

			return access(this, function (value) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if (elem && value === undefined) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get(elem, key) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());

					if (data !== undefined) {
						return data;
					}

					camelKey = jQuery.camelCase(key);

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get(elem, camelKey);
					if (data !== undefined) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr(elem, camelKey, undefined);
					if (data !== undefined) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase(key);
				this.each(function () {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get(this, camelKey);

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set(this, camelKey, value);

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if (key.indexOf("-") > -1 && data !== undefined) {
						dataUser.set(this, key, value);
					}
				});
			}, null, value, arguments.length > 1, null, true);
		},

		removeData: function (key) {
			return this.each(function () {
				dataUser.remove(this, key);
			});
		}
	});

	jQuery.extend({
		queue: function (elem, type, data) {
			var queue;

			if (elem) {
				type = (type || "fx") + "queue";
				queue = dataPriv.get(elem, type);

				// Speed up dequeue by getting out quickly if this is just a lookup
				if (data) {
					if (!queue || jQuery.isArray(data)) {
						queue = dataPriv.access(elem, type, jQuery.makeArray(data));
					} else {
						queue.push(data);
					}
				}
				return queue || [];
			}
		},

		dequeue: function (elem, type) {
			type = type || "fx";

			var queue = jQuery.queue(elem, type),
			    startLength = queue.length,
			    fn = queue.shift(),
			    hooks = jQuery._queueHooks(elem, type),
			    next = function () {
				jQuery.dequeue(elem, type);
			};

			// If the fx queue is dequeued, always remove the progress sentinel
			if (fn === "inprogress") {
				fn = queue.shift();
				startLength--;
			}

			if (fn) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call(elem, next, hooks);
			}

			if (!startLength && hooks) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function (elem, type) {
			var key = type + "queueHooks";
			return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
				empty: jQuery.Callbacks("once memory").add(function () {
					dataPriv.remove(elem, [type + "queue", key]);
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function (type, data) {
			var setter = 2;

			if (typeof type !== "string") {
				data = type;
				type = "fx";
				setter--;
			}

			if (arguments.length < setter) {
				return jQuery.queue(this[0], type);
			}

			return data === undefined ? this : this.each(function () {
				var queue = jQuery.queue(this, type, data);

				// Ensure a hooks for this queue
				jQuery._queueHooks(this, type);

				if (type === "fx" && queue[0] !== "inprogress") {
					jQuery.dequeue(this, type);
				}
			});
		},
		dequeue: function (type) {
			return this.each(function () {
				jQuery.dequeue(this, type);
			});
		},
		clearQueue: function (type) {
			return this.queue(type || "fx", []);
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function (type, obj) {
			var tmp,
			    count = 1,
			    defer = jQuery.Deferred(),
			    elements = this,
			    i = this.length,
			    resolve = function () {
				if (! --count) {
					defer.resolveWith(elements, [elements]);
				}
			};

			if (typeof type !== "string") {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while (i--) {
				tmp = dataPriv.get(elements[i], type + "queueHooks");
				if (tmp && tmp.empty) {
					count++;
					tmp.empty.add(resolve);
				}
			}
			resolve();
			return defer.promise(obj);
		}
	});
	var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

	var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

	var cssExpand = ["Top", "Right", "Bottom", "Left"];

	var isHidden = function (elem, el) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
	};

	function adjustCSS(elem, prop, valueParts, tween) {
		var adjusted,
		    scale = 1,
		    maxIterations = 20,
		    currentValue = tween ? function () {
			return tween.cur();
		} : function () {
			return jQuery.css(elem, prop, "");
		},
		    initial = currentValue(),
		    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),


		// Starting value computation is required for potential unit mismatches
		initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

		if (initialInUnit && initialInUnit[3] !== unit) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[3];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style(elem, prop, initialInUnit + unit);

				// Update scale, tolerating zero or NaN from tween.cur()
				// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
		}

		if (valueParts) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
			if (tween) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = /^(?:checkbox|radio)$/i;

	var rtagName = /<([\w:-]+)/;

	var rscriptType = /^$|\/(?:java|ecma)script/i;

	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [1, "<select multiple='multiple'>", "</select>"],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [1, "<table>", "</table>"],
		col: [2, "<table><colgroup>", "</colgroup></table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

		_default: [0, "", ""]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	function getAll(context, tag) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];

		return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval(elems, refElements) {
		var i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
		}
	}

	var rhtml = /<|&#?\w+;/;

	function buildFragment(elems, context, scripts, selection, ignored) {
		var elem,
		    tmp,
		    tag,
		    wrap,
		    contains,
		    j,
		    fragment = context.createDocumentFragment(),
		    nodes = [],
		    i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			elem = elems[i];

			if (elem || elem === 0) {

				// Add nodes directly
				if (jQuery.type(elem) === "object") {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

					// Convert non-html into a text node
				} else if (!rhtml.test(elem)) {
					nodes.push(context.createTextNode(elem));

					// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild(context.createElement("div"));

					// Deserialize a standard representation
					tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
					wrap = wrapMap[tag] || wrapMap._default;
					tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while (j--) {
						tmp = tmp.lastChild;
					}

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, tmp.childNodes);

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while (elem = nodes[i++]) {

			// Skip elements already in the context collection (trac-4087)
			if (selection && jQuery.inArray(elem, selection) > -1) {
				if (ignored) {
					ignored.push(elem);
				}
				continue;
			}

			contains = jQuery.contains(elem.ownerDocument, elem);

			// Append to fragment
			tmp = getAll(fragment.appendChild(elem), "script");

			// Preserve script evaluation history
			if (contains) {
				setGlobalEval(tmp);
			}

			// Capture executables
			if (scripts) {
				j = 0;
				while (elem = tmp[j++]) {
					if (rscriptType.test(elem.type || "")) {
						scripts.push(elem);
					}
				}
			}
		}

		return fragment;
	}

	(function () {
		var fragment = document.createDocumentFragment(),
		    div = fragment.appendChild(document.createElement("div")),
		    input = document.createElement("input");

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute("type", "radio");
		input.setAttribute("checked", "checked");
		input.setAttribute("name", "t");

		div.appendChild(input);

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
	})();

	var rkeyEvent = /^key/,
	    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch (err) {}
	}

	function on(elem, types, selector, data, fn, one) {
		var origFn, type;

		// Types can be a map of types/handlers
		if (typeof types === "object") {

			// ( types-Object, selector, data )
			if (typeof selector !== "string") {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for (type in types) {
				on(elem, type, selector, data, types[type], one);
			}
			return elem;
		}

		if (data == null && fn == null) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if (fn == null) {
			if (typeof selector === "string") {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if (fn === false) {
			fn = returnFalse;
		} else if (!fn) {
			return elem;
		}

		if (one === 1) {
			origFn = fn;
			fn = function (event) {

				// Can use an empty set, since event contains the info
				jQuery().off(event);
				return origFn.apply(this, arguments);
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
		}
		return elem.each(function () {
			jQuery.event.add(this, types, fn, data, selector);
		});
	}

	/*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
	jQuery.event = {

		global: {},

		add: function (elem, types, handler, data, selector) {

			var handleObjIn,
			    eventHandle,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.get(elem);

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if (!elemData) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if (handler.handler) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if (!handler.guid) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if (!(events = elemData.events)) {
				events = elemData.events = {};
			}
			if (!(eventHandle = elemData.handle)) {
				eventHandle = elemData.handle = function (e) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// There *must* be a type, no attaching namespace-only handlers
				if (!type) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[type] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = (selector ? special.delegateType : special.bindType) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[type] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test(selector),
					namespace: namespaces.join(".")
				}, handleObjIn);

				// Init the event handler queue if we're the first
				if (!(handlers = events[type])) {
					handlers = events[type] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {

						if (elem.addEventListener) {
							elem.addEventListener(type, eventHandle);
						}
					}
				}

				if (special.add) {
					special.add.call(elem, handleObj);

					if (!handleObj.handler.guid) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if (selector) {
					handlers.splice(handlers.delegateCount++, 0, handleObj);
				} else {
					handlers.push(handleObj);
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[type] = true;
			}
		},

		// Detach an event or set of events from an element
		remove: function (elem, types, handler, selector, mappedTypes) {

			var j,
			    origCount,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

			if (!elemData || !(events = elemData.events)) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// Unbind all events (on this namespace, if provided) for the element
				if (!type) {
					for (type in events) {
						jQuery.event.remove(elem, type + types[t], handler, selector, true);
					}
					continue;
				}

				special = jQuery.event.special[type] || {};
				type = (selector ? special.delegateType : special.bindType) || type;
				handlers = events[type] || [];
				tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

				// Remove matching events
				origCount = j = handlers.length;
				while (j--) {
					handleObj = handlers[j];

					if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
						handlers.splice(j, 1);

						if (handleObj.selector) {
							handlers.delegateCount--;
						}
						if (special.remove) {
							special.remove.call(elem, handleObj);
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if (origCount && !handlers.length) {
					if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {

						jQuery.removeEvent(elem, type, elemData.handle);
					}

					delete events[type];
				}
			}

			// Remove data and the expando if it's no longer used
			if (jQuery.isEmptyObject(events)) {
				dataPriv.remove(elem, "handle events");
			}
		},

		dispatch: function (event) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix(event);

			var i,
			    j,
			    ret,
			    matched,
			    handleObj,
			    handlerQueue = [],
			    args = slice.call(arguments),
			    handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
			    special = jQuery.event.special[event.type] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if (special.preDispatch && special.preDispatch.call(this, event) === false) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call(this, event, handlers);

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
				event.currentTarget = matched.elem;

				j = 0;
				while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

						if (ret !== undefined) {
							if ((event.result = ret) === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if (special.postDispatch) {
				special.postDispatch.call(this, event);
			}

			return event.result;
		},

		handlers: function (event, handlers) {
			var i,
			    matches,
			    sel,
			    handleObj,
			    handlerQueue = [],
			    delegateCount = handlers.delegateCount,
			    cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {

				for (; cur !== this; cur = cur.parentNode || this) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
						matches = [];
						for (i = 0; i < delegateCount; i++) {
							handleObj = handlers[i];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if (matches[sel] === undefined) {
								matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
							}
							if (matches[sel]) {
								matches.push(handleObj);
							}
						}
						if (matches.length) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if (delegateCount < handlers.length) {
				handlerQueue.push({ elem: this, handlers: handlers.slice(delegateCount) });
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function (event, original) {

				// Add which for key events
				if (event.which == null) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
			filter: function (event, original) {
				var eventDoc,
				    doc,
				    body,
				    button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if (event.pageX == null && original.clientX != null) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
					event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if (!event.which && button !== undefined) {
					event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
				}

				return event;
			}
		},

		fix: function (event) {
			if (event[jQuery.expando]) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i,
			    prop,
			    copy,
			    type = event.type,
			    originalEvent = event,
			    fixHook = this.fixHooks[type];

			if (!fixHook) {
				this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
			}
			copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

			event = new jQuery.Event(originalEvent);

			i = copy.length;
			while (i--) {
				prop = copy[i];
				event[prop] = originalEvent[prop];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if (!event.target) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if (event.target.nodeType === 3) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function () {
					if (this !== safeActiveElement() && this.focus) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function () {
					if (this === safeActiveElement() && this.blur) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function () {
					if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function (event) {
					return jQuery.nodeName(event.target, "a");
				}
			},

			beforeunload: {
				postDispatch: function (event) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if (event.result !== undefined && event.originalEvent) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function (elem, type, handle) {

		// This "if" is needed for plain objects
		if (elem.removeEventListener) {
			elem.removeEventListener(type, handle);
		}
	};

	jQuery.Event = function (src, props) {

		// Allow instantiation without the 'new' keyword
		if (!(this instanceof jQuery.Event)) {
			return new jQuery.Event(src, props);
		}

		// Event object
		if (src && src.type) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&

			// Support: Android<4.0
			src.returnValue === false ? returnTrue : returnFalse;

			// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if (props) {
			jQuery.extend(this, props);
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[jQuery.expando] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function () {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if (e) {
				e.preventDefault();
			}
		},
		stopPropagation: function () {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if (e) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function () {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if (e) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function (orig, fix) {
		jQuery.event.special[orig] = {
			delegateType: fix,
			bindType: fix,

			handle: function (event) {
				var ret,
				    target = this,
				    related = event.relatedTarget,
				    handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if (!related || related !== target && !jQuery.contains(target, related)) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply(this, arguments);
					event.type = fix;
				}
				return ret;
			}
		};
	});

	jQuery.fn.extend({
		on: function (types, selector, data, fn) {
			return on(this, types, selector, data, fn);
		},
		one: function (types, selector, data, fn) {
			return on(this, types, selector, data, fn, 1);
		},
		off: function (types, selector, fn) {
			var handleObj, type;
			if (types && types.preventDefault && types.handleObj) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
				return this;
			}
			if (typeof types === "object") {

				// ( types-object [, selector] )
				for (type in types) {
					this.off(type, selector, types[type]);
				}
				return this;
			}
			if (selector === false || typeof selector === "function") {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if (fn === false) {
				fn = returnFalse;
			}
			return this.each(function () {
				jQuery.event.remove(this, types, fn, selector);
			});
		}
	});

	var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,


	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,


	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	    rscriptTypeMasked = /^true\/(.*)/,
	    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Manipulating tables requires a tbody
	function manipulationTarget(elem, content) {
		return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript(elem) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript(elem) {
		var match = rscriptTypeMasked.exec(elem.type);

		if (match) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	function cloneCopyEvent(src, dest) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if (dest.nodeType !== 1) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if (dataPriv.hasData(src)) {
			pdataOld = dataPriv.access(src);
			pdataCur = dataPriv.set(dest, pdataOld);
			events = pdataOld.events;

			if (events) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for (type in events) {
					for (i = 0, l = events[type].length; i < l; i++) {
						jQuery.event.add(dest, type, events[type][i]);
					}
				}
			}
		}

		// 2. Copy user data
		if (dataUser.hasData(src)) {
			udataOld = dataUser.access(src);
			udataCur = jQuery.extend({}, udataOld);

			dataUser.set(dest, udataCur);
		}
	}

	// Fix IE bugs, see support tests
	function fixInput(src, dest) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if (nodeName === "input" && rcheckableType.test(src.type)) {
			dest.checked = src.checked;

			// Fails to return the selected option to the default selected state when cloning options
		} else if (nodeName === "input" || nodeName === "textarea") {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip(collection, args, callback, ignored) {

		// Flatten any nested arrays
		args = concat.apply([], args);

		var fragment,
		    first,
		    scripts,
		    hasScripts,
		    node,
		    doc,
		    i = 0,
		    l = collection.length,
		    iNoClone = l - 1,
		    value = args[0],
		    isFunction = jQuery.isFunction(value);

		// We can't cloneNode fragments that contain checked, in WebKit
		if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
			return collection.each(function (index) {
				var self = collection.eq(index);
				if (isFunction) {
					args[0] = value.call(this, index, self.html());
				}
				domManip(self, args, callback, ignored);
			});
		}

		if (l) {
			fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
			first = fragment.firstChild;

			if (fragment.childNodes.length === 1) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if (first || ignored) {
				scripts = jQuery.map(getAll(fragment, "script"), disableScript);
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for (; i < l; i++) {
					node = fragment;

					if (i !== iNoClone) {
						node = jQuery.clone(node, true, true);

						// Keep references to cloned scripts for later restoration
						if (hasScripts) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(scripts, getAll(node, "script"));
						}
					}

					callback.call(collection[i], node, i);
				}

				if (hasScripts) {
					doc = scripts[scripts.length - 1].ownerDocument;

					// Reenable scripts
					jQuery.map(scripts, restoreScript);

					// Evaluate executable scripts on first document insertion
					for (i = 0; i < hasScripts; i++) {
						node = scripts[i];
						if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {

							if (node.src) {

								// Optional AJAX dependency, but won't run scripts if not present
								if (jQuery._evalUrl) {
									jQuery._evalUrl(node.src);
								}
							} else {
								jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove(elem, selector, keepData) {
		var node,
		    nodes = selector ? jQuery.filter(selector, elem) : elem,
		    i = 0;

		for (; (node = nodes[i]) != null; i++) {
			if (!keepData && node.nodeType === 1) {
				jQuery.cleanData(getAll(node));
			}

			if (node.parentNode) {
				if (keepData && jQuery.contains(node.ownerDocument, node)) {
					setGlobalEval(getAll(node, "script"));
				}
				node.parentNode.removeChild(node);
			}
		}

		return elem;
	}

	jQuery.extend({
		htmlPrefilter: function (html) {
			return html.replace(rxhtmlTag, "<$1></$2>");
		},

		clone: function (elem, dataAndEvents, deepDataAndEvents) {
			var i,
			    l,
			    srcElements,
			    destElements,
			    clone = elem.cloneNode(true),
			    inPage = jQuery.contains(elem.ownerDocument, elem);

			// Fix IE cloning issues
			if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll(clone);
				srcElements = getAll(elem);

				for (i = 0, l = srcElements.length; i < l; i++) {
					fixInput(srcElements[i], destElements[i]);
				}
			}

			// Copy the events from the original to the clone
			if (dataAndEvents) {
				if (deepDataAndEvents) {
					srcElements = srcElements || getAll(elem);
					destElements = destElements || getAll(clone);

					for (i = 0, l = srcElements.length; i < l; i++) {
						cloneCopyEvent(srcElements[i], destElements[i]);
					}
				} else {
					cloneCopyEvent(elem, clone);
				}
			}

			// Preserve script evaluation history
			destElements = getAll(clone, "script");
			if (destElements.length > 0) {
				setGlobalEval(destElements, !inPage && getAll(elem, "script"));
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function (elems) {
			var data,
			    elem,
			    type,
			    special = jQuery.event.special,
			    i = 0;

			for (; (elem = elems[i]) !== undefined; i++) {
				if (acceptData(elem)) {
					if (data = elem[dataPriv.expando]) {
						if (data.events) {
							for (type in data.events) {
								if (special[type]) {
									jQuery.event.remove(elem, type);

									// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent(elem, type, data.handle);
								}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataPriv.expando] = undefined;
					}
					if (elem[dataUser.expando]) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataUser.expando] = undefined;
					}
				}
			}
		}
	});

	jQuery.fn.extend({

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function (selector) {
			return remove(this, selector, true);
		},

		remove: function (selector) {
			return remove(this, selector);
		},

		text: function (value) {
			return access(this, function (value) {
				return value === undefined ? jQuery.text(this) : this.empty().each(function () {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						this.textContent = value;
					}
				});
			}, null, value, arguments.length);
		},

		append: function () {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.appendChild(elem);
				}
			});
		},

		prepend: function () {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.insertBefore(elem, target.firstChild);
				}
			});
		},

		before: function () {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this);
				}
			});
		},

		after: function () {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this.nextSibling);
				}
			});
		},

		empty: function () {
			var elem,
			    i = 0;

			for (; (elem = this[i]) != null; i++) {
				if (elem.nodeType === 1) {

					// Prevent memory leaks
					jQuery.cleanData(getAll(elem, false));

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function (dataAndEvents, deepDataAndEvents) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function () {
				return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
			});
		},

		html: function (value) {
			return access(this, function (value) {
				var elem = this[0] || {},
				    i = 0,
				    l = this.length;

				if (value === undefined && elem.nodeType === 1) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

					value = jQuery.htmlPrefilter(value);

					try {
						for (; i < l; i++) {
							elem = this[i] || {};

							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
								elem.innerHTML = value;
							}
						}

						elem = 0;

						// If using innerHTML throws an exception, use the fallback method
					} catch (e) {}
				}

				if (elem) {
					this.empty().append(value);
				}
			}, null, value, arguments.length);
		},

		replaceWith: function () {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip(this, arguments, function (elem) {
				var parent = this.parentNode;

				if (jQuery.inArray(this, ignored) < 0) {
					jQuery.cleanData(getAll(this));
					if (parent) {
						parent.replaceChild(elem, this);
					}
				}

				// Force callback invocation
			}, ignored);
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function (name, original) {
		jQuery.fn[name] = function (selector) {
			var elems,
			    ret = [],
			    insert = jQuery(selector),
			    last = insert.length - 1,
			    i = 0;

			for (; i <= last; i++) {
				elems = i === last ? this : this.clone(true);
				jQuery(insert[i])[original](elems);

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply(ret, elems.get());
			}

			return this.pushStack(ret);
		};
	});

	var iframe,
	    elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

	/**
  * Retrieve the actual display of a element
  * @param {String} name nodeName of the element
  * @param {Object} doc Document object
  */

	// Called only from within defaultDisplay
	function actualDisplay(name, doc) {
		var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
		    display = jQuery.css(elem[0], "display");

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
  * Try to determine the default display value of an element
  * @param {String} nodeName
  */
	function defaultDisplay(nodeName) {
		var doc = document,
		    display = elemdisplay[nodeName];

		if (!display) {
			display = actualDisplay(nodeName, doc);

			// If the simple way fails, read from inside an iframe
			if (display === "none" || !display) {

				// Use the already-created iframe if possible
				iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[0].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay(nodeName, doc);
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[nodeName] = display;
		}

		return display;
	}
	var rmargin = /^margin/;

	var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	var getStyles = function (elem) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if (!view || !view.opener) {
			view = window;
		}

		return view.getComputedStyle(elem);
	};

	var swap = function (elem, options, callback, args) {
		var ret,
		    name,
		    old = {};

		// Remember the old values, and insert the new ones
		for (name in options) {
			old[name] = elem.style[name];
			elem.style[name] = options[name];
		}

		ret = callback.apply(elem, args || []);

		// Revert the old values
		for (name in options) {
			elem.style[name] = old[name];
		}

		return ret;
	};

	var documentElement = document.documentElement;

	(function () {
		var pixelPositionVal,
		    boxSizingReliableVal,
		    pixelMarginRightVal,
		    reliableMarginLeftVal,
		    container = document.createElement("div"),
		    div = document.createElement("div");

		// Finish early in limited (non-browser) environments
		if (!div.style) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode(true).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
		container.appendChild(div);

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild(container);

			var divStyle = window.getComputedStyle(div);
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild(container);
		}

		jQuery.extend(support, {
			pixelPosition: function () {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function () {
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function () {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function () {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function () {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
				    marginDiv = div.appendChild(document.createElement("div"));

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild(container);

				ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);

				documentElement.removeChild(container);
				div.removeChild(marginDiv);

				return ret;
			}
		});
	})();

	function curCSS(elem, name, computed) {
		var width,
		    minWidth,
		    maxWidth,
		    ret,
		    style = elem.style;

		computed = computed || getStyles(elem);
		ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
			ret = jQuery.style(elem, name);
		}

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if (computed) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" : ret;
	}

	function addGetHookIf(conditionFn, hookFn) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function () {
				if (conditionFn()) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply(this, arguments);
			}
		};
	}

	var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	    cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},
	    cssPrefixes = ["Webkit", "O", "Moz", "ms"],
	    emptyStyle = document.createElement("div").style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName(name) {

		// Shortcut for names that are not vendor prefixed
		if (name in emptyStyle) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
		    i = cssPrefixes.length;

		while (i--) {
			name = cssPrefixes[i] + capName;
			if (name in emptyStyle) {
				return name;
			}
		}
	}

	function setPositiveNumber(elem, value, subtract) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec(value);
		return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
	}

	function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
		var i = extra === (isBorderBox ? "border" : "content") ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,
		    val = 0;

		for (; i < 4; i += 2) {

			// Both box models exclude margin, so add it if we want it
			if (extra === "margin") {
				val += jQuery.css(elem, extra + cssExpand[i], true, styles);
			}

			if (isBorderBox) {

				// border-box includes padding, so remove it if we want content
				if (extra === "content") {
					val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
				}

				// At this point, extra isn't border nor margin, so remove border
				if (extra !== "margin") {
					val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

				// At this point, extra isn't content nor padding, so add border
				if (extra !== "padding") {
					val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			}
		}

		return val;
	}

	function getWidthOrHeight(elem, name, extra) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
		    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		    styles = getStyles(elem),
		    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

		// Support: IE11 only
		// In IE 11 fullscreen elements inside of an iframe have
		// 100x too small dimensions (gh-1764).
		if (document.msFullscreenElement && window.top !== window) {

			// Support: IE11 only
			// Running getBoundingClientRect on a disconnected node
			// in IE throws an error.
			if (elem.getClientRects().length) {
				val = Math.round(elem.getBoundingClientRect()[name] * 100);
			}
		}

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if (val <= 0 || val == null) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS(elem, name, styles);
			if (val < 0 || val == null) {
				val = elem.style[name];
			}

			// Computed unit is not pixels. Stop here and return.
			if (rnumnonpx.test(val)) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

			// Normalize "", auto, and prepare for extra
			val = parseFloat(val) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
	}

	function showHide(elements, show) {
		var display,
		    elem,
		    hidden,
		    values = [],
		    index = 0,
		    length = elements.length;

		for (; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}

			values[index] = dataPriv.get(elem, "olddisplay");
			display = elem.style.display;
			if (show) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if (!values[index] && display === "none") {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if (elem.style.display === "" && isHidden(elem)) {
					values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
				}
			} else {
				hidden = isHidden(elem);

				if (display !== "none" || !hidden) {
					dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for (index = 0; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}
			if (!show || elem.style.display === "none" || elem.style.display === "") {
				elem.style.display = show ? values[index] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function (elem, computed) {
					if (computed) {

						// We should always get a number back from opacity
						var ret = curCSS(elem, "opacity");
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function (elem, name, value, extra) {

			// Don't set styles on text and comment nodes
			if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
				return;
			}

			// Make sure that we're working with the right name
			var ret,
			    type,
			    hooks,
			    origName = jQuery.camelCase(name),
			    style = elem.style;

			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// Check if we're setting a value
			if (value !== undefined) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
					value = adjustCSS(elem, name, ret);

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if (value == null || value !== value) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if (type === "number") {
					value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
					style[name] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {

					style[name] = value;
				}
			} else {

				// If a hook was provided get the non-computed value from there
				if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[name];
			}
		},

		css: function (elem, name, extra, styles) {
			var val,
			    num,
			    hooks,
			    origName = jQuery.camelCase(name);

			// Make sure that we're working with the right name
			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// If a hook was provided get the computed value from there
			if (hooks && "get" in hooks) {
				val = hooks.get(elem, true, extra);
			}

			// Otherwise, if a way to get the computed value exists, use that
			if (val === undefined) {
				val = curCSS(elem, name, styles);
			}

			// Convert "normal" to computed value
			if (val === "normal" && name in cssNormalTransform) {
				val = cssNormalTransform[name];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if (extra === "" || extra) {
				num = parseFloat(val);
				return extra === true || isFinite(num) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each(["height", "width"], function (i, name) {
		jQuery.cssHooks[name] = {
			get: function (elem, computed, extra) {
				if (computed) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function () {
						return getWidthOrHeight(elem, name, extra);
					}) : getWidthOrHeight(elem, name, extra);
				}
			},

			set: function (elem, value, extra) {
				var matches,
				    styles = extra && getStyles(elem),
				    subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);

				// Convert to pixels if value adjustment is needed
				if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {

					elem.style[name] = value;
					value = jQuery.css(elem, name);
				}

				return setPositiveNumber(elem, value, subtract);
			}
		};
	});

	jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
		if (computed) {
			return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
				return elem.getBoundingClientRect().left;
			})) + "px";
		}
	});

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
		if (computed) {
			return swap(elem, { "display": "inline-block" }, curCSS, [elem, "marginRight"]);
		}
	});

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function (prefix, suffix) {
		jQuery.cssHooks[prefix + suffix] = {
			expand: function (value) {
				var i = 0,
				    expanded = {},


				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [value];

				for (; i < 4; i++) {
					expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
				}

				return expanded;
			}
		};

		if (!rmargin.test(prefix)) {
			jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function (name, value) {
			return access(this, function (elem, name, value) {
				var styles,
				    len,
				    map = {},
				    i = 0;

				if (jQuery.isArray(name)) {
					styles = getStyles(elem);
					len = name.length;

					for (; i < len; i++) {
						map[name[i]] = jQuery.css(elem, name[i], false, styles);
					}

					return map;
				}

				return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
			}, name, value, arguments.length > 1);
		},
		show: function () {
			return showHide(this, true);
		},
		hide: function () {
			return showHide(this);
		},
		toggle: function (state) {
			if (typeof state === "boolean") {
				return state ? this.show() : this.hide();
			}

			return this.each(function () {
				if (isHidden(this)) {
					jQuery(this).show();
				} else {
					jQuery(this).hide();
				}
			});
		}
	});

	function Tween(elem, options, prop, end, easing) {
		return new Tween.prototype.init(elem, options, prop, end, easing);
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function (elem, options, prop, end, easing, unit) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
		},
		cur: function () {
			var hooks = Tween.propHooks[this.prop];

			return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
		},
		run: function (percent) {
			var eased,
			    hooks = Tween.propHooks[this.prop];

			if (this.options.duration) {
				this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
			} else {
				this.pos = eased = percent;
			}
			this.now = (this.end - this.start) * eased + this.start;

			if (this.options.step) {
				this.options.step.call(this.elem, this.now, this);
			}

			if (hooks && hooks.set) {
				hooks.set(this);
			} else {
				Tween.propHooks._default.set(this);
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function (tween) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
					return tween.elem[tween.prop];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css(tween.elem, tween.prop, "");

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function (tween) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if (jQuery.fx.step[tween.prop]) {
					jQuery.fx.step[tween.prop](tween);
				} else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
					jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
				} else {
					tween.elem[tween.prop] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function (tween) {
			if (tween.elem.nodeType && tween.elem.parentNode) {
				tween.elem[tween.prop] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function (p) {
			return p;
		},
		swing: function (p) {
			return 0.5 - Math.cos(p * Math.PI) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};

	var fxNow,
	    timerId,
	    rfxtypes = /^(?:toggle|show|hide)$/,
	    rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout(function () {
			fxNow = undefined;
		});
		return fxNow = jQuery.now();
	}

	// Generate parameters to create a standard animation
	function genFx(type, includeWidth) {
		var which,
		    i = 0,
		    attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for (; i < 4; i += 2 - includeWidth) {
			which = cssExpand[i];
			attrs["margin" + which] = attrs["padding" + which] = type;
		}

		if (includeWidth) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween(value, prop, animation) {
		var tween,
		    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
		    index = 0,
		    length = collection.length;
		for (; index < length; index++) {
			if (tween = collection[index].call(animation, prop, value)) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter(elem, props, opts) {
		/* jshint validthis: true */
		var prop,
		    value,
		    toggle,
		    tween,
		    hooks,
		    oldfire,
		    display,
		    checkDisplay,
		    anim = this,
		    orig = {},
		    style = elem.style,
		    hidden = elem.nodeType && isHidden(elem),
		    dataShow = dataPriv.get(elem, "fxshow");

		// Handle queue: false promises
		if (!opts.queue) {
			hooks = jQuery._queueHooks(elem, "fx");
			if (hooks.unqueued == null) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function () {
					if (!hooks.unqueued) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function () {

				// Ensure the complete handler is called before this completes
				anim.always(function () {
					hooks.unqueued--;
					if (!jQuery.queue(elem, "fx").length) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Height/width overflow pass
		if (elem.nodeType === 1 && ("height" in props || "width" in props)) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [style.overflow, style.overflowX, style.overflowY];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css(elem, "display");

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

			if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
				style.display = "inline-block";
			}
		}

		if (opts.overflow) {
			style.overflow = "hidden";
			anim.always(function () {
				style.overflow = opts.overflow[0];
				style.overflowX = opts.overflow[1];
				style.overflowY = opts.overflow[2];
			});
		}

		// show/hide pass
		for (prop in props) {
			value = props[prop];
			if (rfxtypes.exec(value)) {
				delete props[prop];
				toggle = toggle || value === "toggle";
				if (value === (hidden ? "hide" : "show")) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if (value === "show" && dataShow && dataShow[prop] !== undefined) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

				// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if (!jQuery.isEmptyObject(orig)) {
			if (dataShow) {
				if ("hidden" in dataShow) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access(elem, "fxshow", {});
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if (toggle) {
				dataShow.hidden = !hidden;
			}
			if (hidden) {
				jQuery(elem).show();
			} else {
				anim.done(function () {
					jQuery(elem).hide();
				});
			}
			anim.done(function () {
				var prop;

				dataPriv.remove(elem, "fxshow");
				for (prop in orig) {
					jQuery.style(elem, prop, orig[prop]);
				}
			});
			for (prop in orig) {
				tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

				if (!(prop in dataShow)) {
					dataShow[prop] = tween.start;
					if (hidden) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

			// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
			style.display = display;
		}
	}

	function propFilter(props, specialEasing) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for (index in props) {
			name = jQuery.camelCase(index);
			easing = specialEasing[name];
			value = props[index];
			if (jQuery.isArray(value)) {
				easing = value[1];
				value = props[index] = value[0];
			}

			if (index !== name) {
				props[name] = value;
				delete props[index];
			}

			hooks = jQuery.cssHooks[name];
			if (hooks && "expand" in hooks) {
				value = hooks.expand(value);
				delete props[name];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for (index in value) {
					if (!(index in props)) {
						props[index] = value[index];
						specialEasing[index] = easing;
					}
				}
			} else {
				specialEasing[name] = easing;
			}
		}
	}

	function Animation(elem, properties, options) {
		var result,
		    stopped,
		    index = 0,
		    length = Animation.prefilters.length,
		    deferred = jQuery.Deferred().always(function () {

			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		    tick = function () {
			if (stopped) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
			    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),


			// Support: Android 2.3
			// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
			temp = remaining / animation.duration || 0,
			    percent = 1 - temp,
			    index = 0,
			    length = animation.tweens.length;

			for (; index < length; index++) {
				animation.tweens[index].run(percent);
			}

			deferred.notifyWith(elem, [animation, percent, remaining]);

			if (percent < 1 && length) {
				return remaining;
			} else {
				deferred.resolveWith(elem, [animation]);
				return false;
			}
		},
		    animation = deferred.promise({
			elem: elem,
			props: jQuery.extend({}, properties),
			opts: jQuery.extend(true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function (prop, end) {
				var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
				animation.tweens.push(tween);
				return tween;
			},
			stop: function (gotoEnd) {
				var index = 0,


				// If we are going to the end, we want to run all the tweens
				// otherwise we skip this part
				length = gotoEnd ? animation.tweens.length : 0;
				if (stopped) {
					return this;
				}
				stopped = true;
				for (; index < length; index++) {
					animation.tweens[index].run(1);
				}

				// Resolve when we played the last frame; otherwise, reject
				if (gotoEnd) {
					deferred.notifyWith(elem, [animation, 1, 0]);
					deferred.resolveWith(elem, [animation, gotoEnd]);
				} else {
					deferred.rejectWith(elem, [animation, gotoEnd]);
				}
				return this;
			}
		}),
		    props = animation.props;

		propFilter(props, animation.opts.specialEasing);

		for (; index < length; index++) {
			result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
			if (result) {
				if (jQuery.isFunction(result.stop)) {
					jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
				}
				return result;
			}
		}

		jQuery.map(props, createTween, animation);

		if (jQuery.isFunction(animation.opts.start)) {
			animation.opts.start.call(elem, animation);
		}

		jQuery.fx.timer(jQuery.extend(tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		}));

		// attach callbacks from options
		return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	}

	jQuery.Animation = jQuery.extend(Animation, {
		tweeners: {
			"*": [function (prop, value) {
				var tween = this.createTween(prop, value);
				adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
				return tween;
			}]
		},

		tweener: function (props, callback) {
			if (jQuery.isFunction(props)) {
				callback = props;
				props = ["*"];
			} else {
				props = props.match(rnotwhite);
			}

			var prop,
			    index = 0,
			    length = props.length;

			for (; index < length; index++) {
				prop = props[index];
				Animation.tweeners[prop] = Animation.tweeners[prop] || [];
				Animation.tweeners[prop].unshift(callback);
			}
		},

		prefilters: [defaultPrefilter],

		prefilter: function (callback, prepend) {
			if (prepend) {
				Animation.prefilters.unshift(callback);
			} else {
				Animation.prefilters.push(callback);
			}
		}
	});

	jQuery.speed = function (speed, easing, fn) {
		var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if (opt.queue == null || opt.queue === true) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function () {
			if (jQuery.isFunction(opt.old)) {
				opt.old.call(this);
			}

			if (opt.queue) {
				jQuery.dequeue(this, opt.queue);
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function (speed, to, easing, callback) {

			// Show any hidden elements after setting opacity to 0
			return this.filter(isHidden).css("opacity", 0).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback);
		},
		animate: function (prop, speed, easing, callback) {
			var empty = jQuery.isEmptyObject(prop),
			    optall = jQuery.speed(speed, easing, callback),
			    doAnimation = function () {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation(this, jQuery.extend({}, prop), optall);

				// Empty animations, or finishing resolves immediately
				if (empty || dataPriv.get(this, "finish")) {
					anim.stop(true);
				}
			};
			doAnimation.finish = doAnimation;

			return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
		},
		stop: function (type, clearQueue, gotoEnd) {
			var stopQueue = function (hooks) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop(gotoEnd);
			};

			if (typeof type !== "string") {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if (clearQueue && type !== false) {
				this.queue(type || "fx", []);
			}

			return this.each(function () {
				var dequeue = true,
				    index = type != null && type + "queueHooks",
				    timers = jQuery.timers,
				    data = dataPriv.get(this);

				if (index) {
					if (data[index] && data[index].stop) {
						stopQueue(data[index]);
					}
				} else {
					for (index in data) {
						if (data[index] && data[index].stop && rrun.test(index)) {
							stopQueue(data[index]);
						}
					}
				}

				for (index = timers.length; index--;) {
					if (timers[index].elem === this && (type == null || timers[index].queue === type)) {

						timers[index].anim.stop(gotoEnd);
						dequeue = false;
						timers.splice(index, 1);
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if (dequeue || !gotoEnd) {
					jQuery.dequeue(this, type);
				}
			});
		},
		finish: function (type) {
			if (type !== false) {
				type = type || "fx";
			}
			return this.each(function () {
				var index,
				    data = dataPriv.get(this),
				    queue = data[type + "queue"],
				    hooks = data[type + "queueHooks"],
				    timers = jQuery.timers,
				    length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue(this, type, []);

				if (hooks && hooks.stop) {
					hooks.stop.call(this, true);
				}

				// Look for any active animations, and finish them
				for (index = timers.length; index--;) {
					if (timers[index].elem === this && timers[index].queue === type) {
						timers[index].anim.stop(true);
						timers.splice(index, 1);
					}
				}

				// Look for any animations in the old queue and finish them
				for (index = 0; index < length; index++) {
					if (queue[index] && queue[index].finish) {
						queue[index].finish.call(this);
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each(["toggle", "show", "hide"], function (i, name) {
		var cssFn = jQuery.fn[name];
		jQuery.fn[name] = function (speed, easing, callback) {
			return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function (name, props) {
		jQuery.fn[name] = function (speed, easing, callback) {
			return this.animate(props, speed, easing, callback);
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function () {
		var timer,
		    i = 0,
		    timers = jQuery.timers;

		fxNow = jQuery.now();

		for (; i < timers.length; i++) {
			timer = timers[i];

			// Checks the timer has not already been removed
			if (!timer() && timers[i] === timer) {
				timers.splice(i--, 1);
			}
		}

		if (!timers.length) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function (timer) {
		jQuery.timers.push(timer);
		if (timer()) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function () {
		if (!timerId) {
			timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
		}
	};

	jQuery.fx.stop = function () {
		window.clearInterval(timerId);

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};

	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function (time, type) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue(type, function (next, hooks) {
			var timeout = window.setTimeout(next, time);
			hooks.stop = function () {
				window.clearTimeout(timeout);
			};
		});
	};

	(function () {
		var input = document.createElement("input"),
		    select = document.createElement("select"),
		    opt = select.appendChild(document.createElement("option"));

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement("input");
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();

	var boolHook,
	    attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function (name, value) {
			return access(this, jQuery.attr, name, value, arguments.length > 1);
		},

		removeAttr: function (name) {
			return this.each(function () {
				jQuery.removeAttr(this, name);
			});
		}
	});

	jQuery.extend({
		attr: function (elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if (typeof elem.getAttribute === "undefined") {
				return jQuery.prop(elem, name, value);
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
			}

			if (value !== undefined) {
				if (value === null) {
					jQuery.removeAttr(elem, name);
					return;
				}

				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				elem.setAttribute(name, value + "");
				return value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			ret = jQuery.find.attr(elem, name);

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function (elem, value) {
					if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
						var val = elem.value;
						elem.setAttribute("type", value);
						if (val) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function (elem, value) {
			var name,
			    propName,
			    i = 0,
			    attrNames = value && value.match(rnotwhite);

			if (attrNames && elem.nodeType === 1) {
				while (name = attrNames[i++]) {
					propName = jQuery.propFix[name] || name;

					// Boolean attributes get special treatment (#10870)
					if (jQuery.expr.match.bool.test(name)) {

						// Set corresponding property to false
						elem[propName] = false;
					}

					elem.removeAttribute(name);
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function (elem, value, name) {
			if (value === false) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr(elem, name);
			} else {
				elem.setAttribute(name, name);
			}
			return name;
		}
	};
	jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
		var getter = attrHandle[name] || jQuery.find.attr;

		attrHandle[name] = function (elem, name, isXML) {
			var ret, handle;
			if (!isXML) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[name];
				attrHandle[name] = ret;
				ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
				attrHandle[name] = handle;
			}
			return ret;
		};
	});

	var rfocusable = /^(?:input|select|textarea|button)$/i,
	    rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend({
		prop: function (name, value) {
			return access(this, jQuery.prop, name, value, arguments.length > 1);
		},

		removeProp: function (name) {
			return this.each(function () {
				delete this[jQuery.propFix[name] || name];
			});
		}
	});

	jQuery.extend({
		prop: function (elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

				// Fix name and attach hooks
				name = jQuery.propFix[name] || name;
				hooks = jQuery.propHooks[name];
			}

			if (value !== undefined) {
				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				return elem[name] = value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			return elem[name];
		},

		propHooks: {
			tabIndex: {
				get: function (elem) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr(elem, "tabindex");

					return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	});

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if (!support.optSelected) {
		jQuery.propHooks.selected = {
			get: function (elem) {
				var parent = elem.parentNode;
				if (parent && parent.parentNode) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function (elem) {
				var parent = elem.parentNode;
				if (parent) {
					parent.selectedIndex;

					if (parent.parentNode) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		jQuery.propFix[this.toLowerCase()] = this;
	});

	var rclass = /[\t\r\n\f]/g;

	function getClass(elem) {
		return elem.getAttribute && elem.getAttribute("class") || "";
	}

	jQuery.fn.extend({
		addClass: function (value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).addClass(value.call(this, j, getClass(this)));
				});
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);
					cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {
							if (cur.indexOf(" " + clazz + " ") < 0) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		removeClass: function (value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).removeClass(value.call(this, j, getClass(this)));
				});
			}

			if (!arguments.length) {
				return this.attr("class", "");
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {

							// Remove *all* instances
							while (cur.indexOf(" " + clazz + " ") > -1) {
								cur = cur.replace(" " + clazz + " ", " ");
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		toggleClass: function (value, stateVal) {
			var type = typeof value;

			if (typeof stateVal === "boolean" && type === "string") {
				return stateVal ? this.addClass(value) : this.removeClass(value);
			}

			if (jQuery.isFunction(value)) {
				return this.each(function (i) {
					jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
				});
			}

			return this.each(function () {
				var className, i, self, classNames;

				if (type === "string") {

					// Toggle individual class names
					i = 0;
					self = jQuery(this);
					classNames = value.match(rnotwhite) || [];

					while (className = classNames[i++]) {

						// Check each className given, space separated list
						if (self.hasClass(className)) {
							self.removeClass(className);
						} else {
							self.addClass(className);
						}
					}

					// Toggle whole class name
				} else if (value === undefined || type === "boolean") {
					className = getClass(this);
					if (className) {

						// Store className if set
						dataPriv.set(this, "__className__", className);
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if (this.setAttribute) {
						this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
					}
				}
			});
		},

		hasClass: function (selector) {
			var className,
			    elem,
			    i = 0;

			className = " " + selector + " ";
			while (elem = this[i++]) {
				if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
					return true;
				}
			}

			return false;
		}
	});

	var rreturn = /\r/g,
	    rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend({
		val: function (value) {
			var hooks,
			    ret,
			    isFunction,
			    elem = this[0];

			if (!arguments.length) {
				if (elem) {
					hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

					if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace(rreturn, "") :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction(value);

			return this.each(function (i) {
				var val;

				if (this.nodeType !== 1) {
					return;
				}

				if (isFunction) {
					val = value.call(this, i, jQuery(this).val());
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if (val == null) {
					val = "";
				} else if (typeof val === "number") {
					val += "";
				} else if (jQuery.isArray(val)) {
					val = jQuery.map(val, function (value) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

				// If set returns undefined, fall back to normal setting
				if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function (elem) {

					var val = jQuery.find.attr(elem, "value");
					return val != null ? val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
				}
			},
			select: {
				get: function (elem) {
					var value,
					    option,
					    options = elem.options,
					    index = elem.selectedIndex,
					    one = elem.type === "select-one" || index < 0,
					    values = one ? null : [],
					    max = one ? index + 1 : options.length,
					    i = index < 0 ? max : one ? index : 0;

					// Loop through all the selected options
					for (; i < max; i++) {
						option = options[i];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ((option.selected || i === index) && (

						// Don't return options that are disabled or in a disabled optgroup
						support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if (one) {
								return value;
							}

							// Multi-Selects return an array
							values.push(value);
						}
					}

					return values;
				},

				set: function (elem, value) {
					var optionSet,
					    option,
					    options = elem.options,
					    values = jQuery.makeArray(value),
					    i = options.length;

					while (i--) {
						option = options[i];
						if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if (!optionSet) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each(["radio", "checkbox"], function () {
		jQuery.valHooks[this] = {
			set: function (elem, value) {
				if (jQuery.isArray(value)) {
					return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
				}
			}
		};
		if (!support.checkOn) {
			jQuery.valHooks[this].get = function (elem) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});

	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend(jQuery.event, {

		trigger: function (event, data, elem, onlyHandlers) {

			var i,
			    cur,
			    tmp,
			    bubbleType,
			    ontype,
			    handle,
			    special,
			    eventPath = [elem || document],
			    type = hasOwn.call(event, "type") ? event.type : event,
			    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if (elem.nodeType === 3 || elem.nodeType === 8) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if (rfocusMorph.test(type + jQuery.event.triggered)) {
				return;
			}

			if (type.indexOf(".") > -1) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if (!event.target) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ? [event] : jQuery.makeArray(data, [event]);

			// Allow special events to draw outside the lines
			special = jQuery.event.special[type] || {};
			if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

				bubbleType = special.delegateType || type;
				if (!rfocusMorph.test(bubbleType + type)) {
					cur = cur.parentNode;
				}
				for (; cur; cur = cur.parentNode) {
					eventPath.push(cur);
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if (tmp === (elem.ownerDocument || document)) {
					eventPath.push(tmp.defaultView || tmp.parentWindow || window);
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

				event.type = i > 1 ? bubbleType : special.bindType || type;

				// jQuery handler
				handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
				if (handle) {
					handle.apply(cur, data);
				}

				// Native handler
				handle = ontype && cur[ontype];
				if (handle && handle.apply && acceptData(cur)) {
					event.result = handle.apply(cur, data);
					if (event.result === false) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if (!onlyHandlers && !event.isDefaultPrevented()) {

				if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ontype];

						if (tmp) {
							elem[ontype] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[type]();
						jQuery.event.triggered = undefined;

						if (tmp) {
							elem[ontype] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		simulate: function (type, elem, event) {
			var e = jQuery.extend(new jQuery.Event(), event, {
				type: type,
				isSimulated: true

				// Previously, `originalEvent: {}` was set here, so stopPropagation call
				// would not be triggered on donor event, since in our own
				// jQuery.event.stopPropagation function we had a check for existence of
				// originalEvent.stopPropagation method, so, consequently it would be a noop.
				//
				// But now, this "simulate" function is used only for events
				// for which stopPropagation() is noop, so there is no need for that anymore.
				//
				// For the 1.x branch though, guard for "click" and "submit"
				// events is still used, but was moved to jQuery.event.stopPropagation function
				// because `originalEvent` should point to the original event for the constancy
				// with other events and for more focused logic
			});

			jQuery.event.trigger(e, null, elem);

			if (e.isDefaultPrevented()) {
				event.preventDefault();
			}
		}

	});

	jQuery.fn.extend({

		trigger: function (type, data) {
			return this.each(function () {
				jQuery.event.trigger(type, data, this);
			});
		},
		triggerHandler: function (type, data) {
			var elem = this[0];
			if (elem) {
				return jQuery.event.trigger(type, data, elem, true);
			}
		}
	});

	jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

		// Handle event binding
		jQuery.fn[name] = function (data, fn) {
			return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
		};
	});

	jQuery.fn.extend({
		hover: function (fnOver, fnOut) {
			return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
		}
	});

	support.focusin = "onfocusin" in window;

	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if (!support.focusin) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function (event) {
				jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
			};

			jQuery.event.special[fix] = {
				setup: function () {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix);

					if (!attaches) {
						doc.addEventListener(orig, handler, true);
					}
					dataPriv.access(doc, fix, (attaches || 0) + 1);
				},
				teardown: function () {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix) - 1;

					if (!attaches) {
						doc.removeEventListener(orig, handler, true);
						dataPriv.remove(doc, fix);
					} else {
						dataPriv.access(doc, fix, attaches);
					}
				}
			};
		});
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = /\?/;

	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function (data) {
		return JSON.parse(data + "");
	};

	// Cross-browser xml parsing
	jQuery.parseXML = function (data) {
		var xml;
		if (!data || typeof data !== "string") {
			return null;
		}

		// Support: IE9
		try {
			xml = new window.DOMParser().parseFromString(data, "text/xml");
		} catch (e) {
			xml = undefined;
		}

		if (!xml || xml.getElementsByTagName("parsererror").length) {
			jQuery.error("Invalid XML: " + data);
		}
		return xml;
	};

	var rhash = /#.*$/,
	    rts = /([?&])_=[^&]*/,
	    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,


	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	    rnoContent = /^(?:GET|HEAD)$/,
	    rprotocol = /^\/\//,


	/* Prefilters
  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  * 2) These are called:
  *    - BEFORE asking for a transport
  *    - AFTER param serialization (s.data is a string if s.processData is true)
  * 3) key is the dataType
  * 4) the catchall symbol "*" can be used
  * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  */
	prefilters = {},


	/* Transports bindings
  * 1) key is the dataType
  * 2) the catchall symbol "*" can be used
  * 3) selection will start with transport dataType and THEN go to "*" if needed
  */
	transports = {},


	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*"),


	// Anchor tag for parsing the document origin
	originAnchor = document.createElement("a");
	originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports(structure) {

		// dataTypeExpression is optional and defaults to "*"
		return function (dataTypeExpression, func) {

			if (typeof dataTypeExpression !== "string") {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
			    i = 0,
			    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

			if (jQuery.isFunction(func)) {

				// For each dataType in the dataTypeExpression
				while (dataType = dataTypes[i++]) {

					// Prepend if requested
					if (dataType[0] === "+") {
						dataType = dataType.slice(1) || "*";
						(structure[dataType] = structure[dataType] || []).unshift(func);

						// Otherwise append
					} else {
						(structure[dataType] = structure[dataType] || []).push(func);
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

		var inspected = {},
		    seekingTransport = structure === transports;

		function inspect(dataType) {
			var selected;
			inspected[dataType] = true;
			jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
				var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
				if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {

					options.dataTypes.unshift(dataTypeOrTransport);
					inspect(dataTypeOrTransport);
					return false;
				} else if (seekingTransport) {
					return !(selected = dataTypeOrTransport);
				}
			});
			return selected;
		}

		return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend(target, src) {
		var key,
		    deep,
		    flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for (key in src) {
			if (src[key] !== undefined) {
				(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
			}
		}
		if (deep) {
			jQuery.extend(true, target, deep);
		}

		return target;
	}

	/* Handles responses to an ajax request:
  * - finds the right dataType (mediates between content-type and expected dataType)
  * - returns the corresponding response
  */
	function ajaxHandleResponses(s, jqXHR, responses) {

		var ct,
		    type,
		    finalDataType,
		    firstDataType,
		    contents = s.contents,
		    dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while (dataTypes[0] === "*") {
			dataTypes.shift();
			if (ct === undefined) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if (ct) {
			for (type in contents) {
				if (contents[type] && contents[type].test(ct)) {
					dataTypes.unshift(type);
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if (dataTypes[0] in responses) {
			finalDataType = dataTypes[0];
		} else {

			// Try convertible dataTypes
			for (type in responses) {
				if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
					finalDataType = type;
					break;
				}
				if (!firstDataType) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if (finalDataType) {
			if (finalDataType !== dataTypes[0]) {
				dataTypes.unshift(finalDataType);
			}
			return responses[finalDataType];
		}
	}

	/* Chain conversions given the request and the original response
  * Also sets the responseXXX fields on the jqXHR instance
  */
	function ajaxConvert(s, response, jqXHR, isSuccess) {
		var conv2,
		    current,
		    conv,
		    tmp,
		    prev,
		    converters = {},


		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if (dataTypes[1]) {
			for (conv in s.converters) {
				converters[conv.toLowerCase()] = s.converters[conv];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while (current) {

			if (s.responseFields[current]) {
				jqXHR[s.responseFields[current]] = response;
			}

			// Apply the dataFilter if provided
			if (!prev && isSuccess && s.dataFilter) {
				response = s.dataFilter(response, s.dataType);
			}

			prev = current;
			current = dataTypes.shift();

			if (current) {

				// There's only work to do if current dataType is non-auto
				if (current === "*") {

					current = prev;

					// Convert response if prev dataType is non-auto and differs from current
				} else if (prev !== "*" && prev !== current) {

					// Seek a direct converter
					conv = converters[prev + " " + current] || converters["* " + current];

					// If none found, seek a pair
					if (!conv) {
						for (conv2 in converters) {

							// If conv2 outputs current
							tmp = conv2.split(" ");
							if (tmp[1] === current) {

								// If prev can be converted to accepted input
								conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
								if (conv) {

									// Condense equivalence converters
									if (conv === true) {
										conv = converters[conv2];

										// Otherwise, insert the intermediate dataType
									} else if (converters[conv2] !== true) {
										current = tmp[0];
										dataTypes.unshift(tmp[1]);
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if (conv !== true) {

						// Unless errors are allowed to bubble, catch and return them
						if (conv && s.throws) {
							response = conv(response);
						} else {
							try {
								response = conv(response);
							} catch (e) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test(location.protocol),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
   timeout: 0,
   data: null,
   dataType: null,
   username: null,
   password: null,
   cache: null,
   throws: false,
   traditional: false,
   headers: {},
   */

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function (target, settings) {
			return settings ?

			// Building a settings object
			ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

			// Extending ajaxSettings
			ajaxExtend(jQuery.ajaxSettings, target);
		},

		ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
		ajaxTransport: addToPrefiltersOrTransports(transports),

		// Main method
		ajax: function (url, options) {

			// If url is an object, simulate pre-1.5 signature
			if (typeof url === "object") {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,


			// URL without anti-cache param
			cacheURL,


			// Response headers
			responseHeadersString,
			    responseHeaders,


			// timeout handle
			timeoutTimer,


			// Url cleanup var
			urlAnchor,


			// To know if global events are to be dispatched
			fireGlobals,


			// Loop variable
			i,


			// Create the final options object
			s = jQuery.ajaxSetup({}, options),


			// Callbacks context
			callbackContext = s.context || s,


			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,


			// Deferreds
			deferred = jQuery.Deferred(),
			    completeDeferred = jQuery.Callbacks("once memory"),


			// Status-dependent callbacks
			statusCode = s.statusCode || {},


			// Headers (they are sent all at once)
			requestHeaders = {},
			    requestHeadersNames = {},


			// The jqXHR state
			state = 0,


			// Default abort message
			strAbort = "canceled",


			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function (key) {
					var match;
					if (state === 2) {
						if (!responseHeaders) {
							responseHeaders = {};
							while (match = rheaders.exec(responseHeadersString)) {
								responseHeaders[match[1].toLowerCase()] = match[2];
							}
						}
						match = responseHeaders[key.toLowerCase()];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function () {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function (name, value) {
					var lname = name.toLowerCase();
					if (!state) {
						name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
						requestHeaders[name] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function (type) {
					if (!state) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function (map) {
					var code;
					if (map) {
						if (state < 2) {
							for (code in map) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[code] = [statusCode[code], map[code]];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always(map[jqXHR.status]);
						}
					}
					return this;
				},

				// Cancel the request
				abort: function (statusText) {
					var finalText = statusText || strAbort;
					if (transport) {
						transport.abort(finalText);
					}
					done(0, finalText);
					return this;
				}
			};

			// Attach deferreds
			deferred.promise(jqXHR).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if (s.crossDomain == null) {
				urlAnchor = document.createElement("a");

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
				} catch (e) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if (s.data && s.processData && typeof s.data !== "string") {
				s.data = jQuery.param(s.data, s.traditional);
			}

			// Apply prefilters
			inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

			// If request was aborted inside a prefilter, stop there
			if (state === 2) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if (fireGlobals && jQuery.active++ === 0) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test(s.type);

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if (!s.hasContent) {

				// If data is available, append data to url
				if (s.data) {
					cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if (s.cache === false) {
					s.url = rts.test(cacheURL) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace(rts, "$1_=" + nonce++) :

					// Otherwise add one to the end
					cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if (s.ifModified) {
				if (jQuery.lastModified[cacheURL]) {
					jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
				}
				if (jQuery.etag[cacheURL]) {
					jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
				}
			}

			// Set the correct header, if data is being sent
			if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
				jqXHR.setRequestHeader("Content-Type", s.contentType);
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

			// Check for headers option
			for (i in s.headers) {
				jqXHR.setRequestHeader(i, s.headers[i]);
			}

			// Allow custom headers/mimetypes and early abort
			if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for (i in { success: 1, error: 1, complete: 1 }) {
				jqXHR[i](s[i]);
			}

			// Get transport
			transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

			// If no transport, we auto-abort
			if (!transport) {
				done(-1, "No Transport");
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if (fireGlobals) {
					globalEventContext.trigger("ajaxSend", [jqXHR, s]);
				}

				// If request was aborted inside ajaxSend, stop there
				if (state === 2) {
					return jqXHR;
				}

				// Timeout
				if (s.async && s.timeout > 0) {
					timeoutTimer = window.setTimeout(function () {
						jqXHR.abort("timeout");
					}, s.timeout);
				}

				try {
					state = 1;
					transport.send(requestHeaders, done);
				} catch (e) {

					// Propagate exception as error if not done
					if (state < 2) {
						done(-1, e);

						// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done(status, nativeStatusText, responses, headers) {
				var isSuccess,
				    success,
				    error,
				    response,
				    modified,
				    statusText = nativeStatusText;

				// Called once
				if (state === 2) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if (timeoutTimer) {
					window.clearTimeout(timeoutTimer);
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if (responses) {
					response = ajaxHandleResponses(s, jqXHR, responses);
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert(s, response, jqXHR, isSuccess);

				// If successful, handle type chaining
				if (isSuccess) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if (s.ifModified) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if (modified) {
							jQuery.lastModified[cacheURL] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if (modified) {
							jQuery.etag[cacheURL] = modified;
						}
					}

					// if no content
					if (status === 204 || s.type === "HEAD") {
						statusText = "nocontent";

						// if not modified
					} else if (status === 304) {
						statusText = "notmodified";

						// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if (status || !statusText) {
						statusText = "error";
						if (status < 0) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = (nativeStatusText || statusText) + "";

				// Success/Error
				if (isSuccess) {
					deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
				} else {
					deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
				}

				// Status-dependent callbacks
				jqXHR.statusCode(statusCode);
				statusCode = undefined;

				if (fireGlobals) {
					globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
				}

				// Complete
				completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

				if (fireGlobals) {
					globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

					// Handle the global AJAX counter
					if (! --jQuery.active) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function (url, data, callback) {
			return jQuery.get(url, data, callback, "json");
		},

		getScript: function (url, callback) {
			return jQuery.get(url, undefined, callback, "script");
		}
	});

	jQuery.each(["get", "post"], function (i, method) {
		jQuery[method] = function (url, data, callback, type) {

			// Shift arguments if data argument was omitted
			if (jQuery.isFunction(data)) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax(jQuery.extend({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject(url) && url));
		};
	});

	jQuery._evalUrl = function (url) {
		return jQuery.ajax({
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};

	jQuery.fn.extend({
		wrapAll: function (html) {
			var wrap;

			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapAll(html.call(this, i));
				});
			}

			if (this[0]) {

				// The elements to wrap the target around
				wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

				if (this[0].parentNode) {
					wrap.insertBefore(this[0]);
				}

				wrap.map(function () {
					var elem = this;

					while (elem.firstElementChild) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append(this);
			}

			return this;
		},

		wrapInner: function (html) {
			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapInner(html.call(this, i));
				});
			}

			return this.each(function () {
				var self = jQuery(this),
				    contents = self.contents();

				if (contents.length) {
					contents.wrapAll(html);
				} else {
					self.append(html);
				}
			});
		},

		wrap: function (html) {
			var isFunction = jQuery.isFunction(html);

			return this.each(function (i) {
				jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
			});
		},

		unwrap: function () {
			return this.parent().each(function () {
				if (!jQuery.nodeName(this, "body")) {
					jQuery(this).replaceWith(this.childNodes);
				}
			}).end();
		}
	});

	jQuery.expr.filters.hidden = function (elem) {
		return !jQuery.expr.filters.visible(elem);
	};
	jQuery.expr.filters.visible = function (elem) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};

	var r20 = /%20/g,
	    rbracket = /\[\]$/,
	    rCRLF = /\r?\n/g,
	    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	    rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams(prefix, obj, traditional, add) {
		var name;

		if (jQuery.isArray(obj)) {

			// Serialize array item.
			jQuery.each(obj, function (i, v) {
				if (traditional || rbracket.test(prefix)) {

					// Treat each array item as a scalar.
					add(prefix, v);
				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
				}
			});
		} else if (!traditional && jQuery.type(obj) === "object") {

			// Serialize object item.
			for (name in obj) {
				buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
			}
		} else {

			// Serialize scalar item.
			add(prefix, obj);
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function (a, traditional) {
		var prefix,
		    s = [],
		    add = function (key, value) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
			s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
		};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if (traditional === undefined) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {

			// Serialize the form elements
			jQuery.each(a, function () {
				add(this.name, this.value);
			});
		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for (prefix in a) {
				buildParams(prefix, a[prefix], traditional, add);
			}
		}

		// Return the resulting serialization
		return s.join("&").replace(r20, "+");
	};

	jQuery.fn.extend({
		serialize: function () {
			return jQuery.param(this.serializeArray());
		},
		serializeArray: function () {
			return this.map(function () {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop(this, "elements");
				return elements ? jQuery.makeArray(elements) : this;
			}).filter(function () {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
			}).map(function (i, elem) {
				var val = jQuery(this).val();

				return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
					return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
				}) : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
			}).get();
		}
	});

	jQuery.ajaxSettings.xhr = function () {
		try {
			return new window.XMLHttpRequest();
		} catch (e) {}
	};

	var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	    xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function (options) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if (support.cors || xhrSupported && !options.crossDomain) {
			return {
				send: function (headers, complete) {
					var i,
					    xhr = options.xhr();

					xhr.open(options.type, options.url, options.async, options.username, options.password);

					// Apply custom fields if provided
					if (options.xhrFields) {
						for (i in options.xhrFields) {
							xhr[i] = options.xhrFields[i];
						}
					}

					// Override mime type if needed
					if (options.mimeType && xhr.overrideMimeType) {
						xhr.overrideMimeType(options.mimeType);
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if (!options.crossDomain && !headers["X-Requested-With"]) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for (i in headers) {
						xhr.setRequestHeader(i, headers[i]);
					}

					// Callback
					callback = function (type) {
						return function () {
							if (callback) {
								callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if (type === "abort") {
									xhr.abort();
								} else if (type === "error") {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if (typeof xhr.status !== "number") {
										complete(0, "error");
									} else {
										complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status, xhr.statusText);
									}
								} else {
									complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback("error");

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if (xhr.onabort !== undefined) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function () {

							// Check readyState before timeout as it changes
							if (xhr.readyState === 4) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout(function () {
									if (callback) {
										errorCallback();
									}
								});
							}
						};
					}

					// Create the abort callback
					callback = callback("abort");

					try {

						// Do send the request (this may raise an exception)
						xhr.send(options.hasContent && options.data || null);
					} catch (e) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if (callback) {
							throw e;
						}
					}
				},

				abort: function () {
					if (callback) {
						callback();
					}
				}
			};
		}
	});

	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function (text) {
				jQuery.globalEval(text);
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter("script", function (s) {
		if (s.cache === undefined) {
			s.cache = false;
		}
		if (s.crossDomain) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport("script", function (s) {

		// This transport only deals with cross domain requests
		if (s.crossDomain) {
			var script, callback;
			return {
				send: function (_, complete) {
					script = jQuery("<script>").prop({
						charset: s.scriptCharset,
						src: s.url
					}).on("load error", callback = function (evt) {
						script.remove();
						callback = null;
						if (evt) {
							complete(evt.type === "error" ? 404 : 200, evt.type);
						}
					});

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild(script[0]);
				},
				abort: function () {
					if (callback) {
						callback();
					}
				}
			};
		}
	});

	var oldCallbacks = [],
	    rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function () {
			var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
			this[callback] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

		var callbackName,
		    overwritten,
		    responseContainer,
		    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if (jsonProp || s.dataTypes[0] === "jsonp") {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

			// Insert callback into url or form data
			if (jsonProp) {
				s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
			} else if (s.jsonp !== false) {
				s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function () {
				if (!responseContainer) {
					jQuery.error(callbackName + " was not called");
				}
				return responseContainer[0];
			};

			// Force json dataType
			s.dataTypes[0] = "json";

			// Install callback
			overwritten = window[callbackName];
			window[callbackName] = function () {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function () {

				// If previous value didn't exist - remove it
				if (overwritten === undefined) {
					jQuery(window).removeProp(callbackName);

					// Otherwise restore preexisting value
				} else {
					window[callbackName] = overwritten;
				}

				// Save back as free
				if (s[callbackName]) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push(callbackName);
				}

				// Call if it was a function and we have a response
				if (responseContainer && jQuery.isFunction(overwritten)) {
					overwritten(responseContainer[0]);
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});

	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function (data, context, keepScripts) {
		if (!data || typeof data !== "string") {
			return null;
		}
		if (typeof context === "boolean") {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec(data),
		    scripts = !keepScripts && [];

		// Single tag
		if (parsed) {
			return [context.createElement(parsed[1])];
		}

		parsed = buildFragment([data], context, scripts);

		if (scripts && scripts.length) {
			jQuery(scripts).remove();
		}

		return jQuery.merge([], parsed.childNodes);
	};

	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
  * Load a url into a page
  */
	jQuery.fn.load = function (url, params, callback) {
		if (typeof url !== "string" && _load) {
			return _load.apply(this, arguments);
		}

		var selector,
		    type,
		    response,
		    self = this,
		    off = url.indexOf(" ");

		if (off > -1) {
			selector = jQuery.trim(url.slice(off));
			url = url.slice(0, off);
		}

		// If it's a function
		if (jQuery.isFunction(params)) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

			// Otherwise, build a param string
		} else if (params && typeof params === "object") {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if (self.length > 0) {
			jQuery.ajax({
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			}).done(function (responseText) {

				// Save response for use in complete callback
				response = arguments;

				self.html(selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

				// Otherwise use the full result
				responseText);

				// If the request succeeds, this function gets "data", "status", "jqXHR"
				// but they are ignored because response was set above.
				// If it fails, this function gets "jqXHR", "status", "error"
			}).always(callback && function (jqXHR, status) {
				self.each(function () {
					callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
				});
			});
		}

		return this;
	};

	// Attach a bunch of functions for handling common AJAX events
	jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
		jQuery.fn[type] = function (fn) {
			return this.on(type, fn);
		};
	});

	jQuery.expr.filters.animated = function (elem) {
		return jQuery.grep(jQuery.timers, function (fn) {
			return elem === fn.elem;
		}).length;
	};

	/**
  * Gets a window from an element
  */
	function getWindow(elem) {
		return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function (elem, options, i) {
			var curPosition,
			    curLeft,
			    curCSSTop,
			    curTop,
			    curOffset,
			    curCSSLeft,
			    calculatePosition,
			    position = jQuery.css(elem, "position"),
			    curElem = jQuery(elem),
			    props = {};

			// Set position first, in-case top/left are set even on static elem
			if (position === "static") {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css(elem, "top");
			curCSSLeft = jQuery.css(elem, "left");
			calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if (calculatePosition) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat(curCSSTop) || 0;
				curLeft = parseFloat(curCSSLeft) || 0;
			}

			if (jQuery.isFunction(options)) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call(elem, i, jQuery.extend({}, curOffset));
			}

			if (options.top != null) {
				props.top = options.top - curOffset.top + curTop;
			}
			if (options.left != null) {
				props.left = options.left - curOffset.left + curLeft;
			}

			if ("using" in options) {
				options.using.call(elem, props);
			} else {
				curElem.css(props);
			}
		}
	};

	jQuery.fn.extend({
		offset: function (options) {
			if (arguments.length) {
				return options === undefined ? this : this.each(function (i) {
					jQuery.offset.setOffset(this, options, i);
				});
			}

			var docElem,
			    win,
			    elem = this[0],
			    box = { top: 0, left: 0 },
			    doc = elem && elem.ownerDocument;

			if (!doc) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if (!jQuery.contains(docElem, elem)) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow(doc);
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function () {
			if (!this[0]) {
				return;
			}

			var offsetParent,
			    offset,
			    elem = this[0],
			    parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if (jQuery.css(elem, "position") === "fixed") {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if (!jQuery.nodeName(offsetParent[0], "html")) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
				parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
				left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function () {
			return this.map(function () {
				var offsetParent = this.offsetParent;

				while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
		var top = "pageYOffset" === prop;

		jQuery.fn[method] = function (val) {
			return access(this, function (elem, method, val) {
				var win = getWindow(elem);

				if (val === undefined) {
					return win ? win[prop] : elem[method];
				}

				if (win) {
					win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
				} else {
					elem[method] = val;
				}
			}, method, val, arguments.length);
		};
	});

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each(["top", "left"], function (i, prop) {
		jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
			if (computed) {
				computed = curCSS(elem, prop);

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
			}
		});
	});

	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
		jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[funcName] = function (margin, value) {
				var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
				    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

				return access(this, function (elem, type, value) {
					var doc;

					if (jQuery.isWindow(elem)) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement["client" + name];
					}

					// Get document width or height
					if (elem.nodeType === 9) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
					}

					return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css(elem, type, extra) :

					// Set width or height on the element
					jQuery.style(elem, type, value, extra);
				}, type, chainable ? margin : undefined, chainable, null);
			};
		});
	});

	jQuery.fn.extend({

		bind: function (types, data, fn) {
			return this.on(types, null, data, fn);
		},
		unbind: function (types, fn) {
			return this.off(types, null, fn);
		},

		delegate: function (selector, types, data, fn) {
			return this.on(types, selector, data, fn);
		},
		undelegate: function (selector, types, fn) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
		},
		size: function () {
			return this.length;
		}
	});

	jQuery.fn.andSelf = jQuery.fn.addBack;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if (typeof define === "function" && define.amd) {
		define("jquery", [], function () {
			return jQuery;
		});
	}

	var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,


	// Map over the $ in case of overwrite
	_$ = window.$;

	jQuery.noConflict = function (deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}

		if (deep && window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if (!noGlobal) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
});
"use strict";

/*!
 * VERSION: 1.18.4
 * DATE: 2016-04-26
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {

	"use strict";

	_gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {

		var _slice = function (a) {
			//don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			var b = [],
			    l = a.length,
			    i;
			for (i = 0; i !== l; b.push(a[i++])) {}
			return b;
		},
		    _applyCycle = function (vars, targets, i) {
			var alt = vars.cycle,
			    p,
			    val;
			for (p in alt) {
				val = alt[p];
				vars[p] = typeof val === "function" ? val.call(targets[i], i) : val[i % val.length];
			}
			delete vars.cycle;
		},
		    TweenMax = function (target, duration, vars) {
			TweenLite.call(this, target, duration, vars);
			this._cycle = 0;
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
			this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _isSelector = TweenLiteInternals.isSelector,
		    _isArray = TweenLiteInternals.isArray,
		    p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
		    _blankArray = [];

		TweenMax.version = "1.18.4";
		p.constructor = TweenMax;
		p.kill()._gc = false;
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
		TweenMax.getTweensOf = TweenLite.getTweensOf;
		TweenMax.lagSmoothing = TweenLite.lagSmoothing;
		TweenMax.ticker = TweenLite.ticker;
		TweenMax.render = TweenLite.render;

		p.invalidate = function () {
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TweenLite.prototype.invalidate.call(this);
		};

		p.updateTo = function (vars, resetDuration) {
			var curRatio = this.ratio,
			    immediate = this.vars.immediateRender || vars.immediateRender,
			    p;
			if (resetDuration && this._startTime < this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled && this._firstPT) {
						TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration > 0.998) {
						//if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
						var prevTime = this._totalTime;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else {
						this._initted = false;
						this._init();
						if (this._time > 0 || immediate) {
							var inv = 1 / (1 - curRatio),
							    pt = this._firstPT,
							    endValue;
							while (pt) {
								endValue = pt.s + pt.c;
								pt.c *= inv;
								pt.s = endValue - pt.c;
								pt = pt._next;
							}
						}
					}
				}
			}
			return this;
		};

		p.render = function (time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) {
				//zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    prevTime = this._time,
			    prevTotalTime = this._totalTime,
			    prevCycle = this._cycle,
			    duration = this._duration,
			    prevRawPrevTime = this._rawPrevTime,
			    isComplete,
			    callback,
			    pt,
			    cycleDuration,
			    r,
			    type,
			    pow,
			    rawPrevTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = "onComplete";
					force = force || this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) {
					//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) {
						//if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause") if (prevRawPrevTime !== time) {
						//note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
			} else if (time < 0.0000001) {
				//to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = this._cycle = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTotalTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) {
						//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) {
					//if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;
				if (this._repeat !== 0) {
					cycleDuration = duration + this._repeatDelay;
					this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
					if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
						this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
					}
					this._time = this._totalTime - this._cycle * cycleDuration;
					if (this._yoyo) if ((this._cycle & 1) !== 0) {
						this._time = duration - this._time;
					}
					if (this._time > duration) {
						this._time = duration;
					} else if (this._time < 0) {
						this._time = 0;
					}
				}

				if (this._easeType) {
					r = this._time / duration;
					type = this._easeType;
					pow = this._easePower;
					if (type === 1 || type === 3 && r >= 0.5) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (this._time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - r / 2;
					}
				} else {
					this.ratio = this._ease.getRatio(this._time / duration);
				}
			}

			if (prevTime === this._time && !force && prevCycle === this._cycle) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
					//so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) {
					//immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
					//we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;
					this._totalTime = prevTotalTime;
					this._rawPrevTime = prevRawPrevTime;
					this._cycle = prevCycle;
					TweenLiteInternals.lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
				}
			}
			if (this._lazy !== false) {
				this._lazy = false;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTotalTime === 0) {
				if (this._initted === 2 && time > 0) {
					//this.invalidate();
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}

			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && this._startTime) {
					//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || callback) {
					this._callback("onUpdate");
				}
			}
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
				this._callback("onRepeat");
			}
			if (callback) if (!this._gc || force) {
				//check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
					//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
					//the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------

		TweenMax.to = function (target, duration, vars) {
			return new TweenMax(target, duration, vars);
		};

		TweenMax.from = function (target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = vars.immediateRender != false;
			return new TweenMax(target, duration, vars);
		};

		TweenMax.fromTo = function (target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return new TweenMax(target, duration, toVars);
		};

		TweenMax.staggerTo = TweenMax.allTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
			    a = [],
			    finalComplete = function () {
				if (vars.onComplete) {
					vars.onComplete.apply(vars.onCompleteScope || this, arguments);
				}
				onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
			},
			    cycle = vars.cycle,
			    fromCycle = vars.startAt && vars.startAt.cycle,
			    l,
			    copy,
			    i,
			    p;
			if (!_isArray(targets)) {
				if (typeof targets === "string") {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i <= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l && onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		};

		TweenMax.staggerFrom = TweenMax.allFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = vars.immediateRender != false;
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		TweenMax.staggerFromTo = TweenMax.allFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		TweenMax.delayedCall = function (delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, { delay: delay, onComplete: callback, onCompleteParams: params, callbackScope: scope, onReverseComplete: callback, onReverseCompleteParams: params, immediateRender: false, useFrames: useFrames, overwrite: 0 });
		};

		TweenMax.set = function (target, vars) {
			return new TweenMax(target, 0, vars);
		};

		TweenMax.isTweening = function (target) {
			return TweenLite.getTweensOf(target, true).length > 0;
		};

		var _getChildrenOf = function (timeline, includeTimelines) {
			var a = [],
			    cnt = 0,
			    tween = timeline._first;
			while (tween) {
				if (tween instanceof TweenLite) {
					a[cnt++] = tween;
				} else {
					if (includeTimelines) {
						a[cnt++] = tween;
					}
					a = a.concat(_getChildrenOf(tween, includeTimelines));
					cnt = a.length;
				}
				tween = tween._next;
			}
			return a;
		},
		    getAllTweens = TweenMax.getAllTweens = function (includeTimelines) {
			return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines));
		};

		TweenMax.killAll = function (complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens(timelines != false),
			    l = a.length,
			    allTrue = tweens && delayedCalls && timelines,
			    isDC,
			    tween,
			    i;
			for (i = 0; i < l; i++) {
				tween = a[i];
				if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		};

		TweenMax.killChildTweensOf = function (parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
			    a,
			    curParent,
			    p,
			    i,
			    l;
			if (typeof parent === "string") {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i > -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		};

		var _changePause = function (pause, tweens, delayedCalls, timelines) {
			tweens = tweens !== false;
			delayedCalls = delayedCalls !== false;
			timelines = timelines !== false;
			var a = getAllTweens(timelines),
			    allTrue = tweens && delayedCalls && timelines,
			    i = a.length,
			    isDC,
			    tween;
			while (--i > -1) {
				tween = a[i];
				if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
					tween.paused(pause);
				}
			}
		};

		TweenMax.pauseAll = function (tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		};

		TweenMax.resumeAll = function (tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		};

		TweenMax.globalTimeScale = function (value) {
			var tl = Animation._rootTimeline,
			    t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		};

		//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------

		p.progress = function (value, suppressEvents) {
			return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
		};

		p.totalProgress = function (value, suppressEvents) {
			return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
		};

		p.time = function (value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.duration = function (value) {
			if (!arguments.length) {
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}
			return Animation.prototype.duration.call(this, value);
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1));
		};

		p.repeat = function (value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function (value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function (value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		return TweenMax;
	}, true);

	/*
  * ----------------------------------------------------------------
  * TimelineLite
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function (vars) {
			SimpleTimeline.call(this, vars);
			this._labels = {};
			this.autoRemoveChildren = this.vars.autoRemoveChildren === true;
			this.smoothChildTiming = this.vars.smoothChildTiming === true;
			this._sortChildren = true;
			this._onUpdate = this.vars.onUpdate;
			var v = this.vars,
			    val,
			    p;
			for (p in v) {
				val = v[p];
				if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
					v[p] = this._swapSelfInParams(val);
				}
			}
			if (_isArray(v.tweens)) {
				this.add(v.tweens, 0, v.align, v.stagger);
			}
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _internals = TimelineLite._internals = {},
		    _isSelector = TweenLiteInternals.isSelector,
		    _isArray = TweenLiteInternals.isArray,
		    _lazyTweens = TweenLiteInternals.lazyTweens,
		    _lazyRender = TweenLiteInternals.lazyRender,
		    _globals = _gsScope._gsDefine.globals,
		    _copy = function (vars) {
			var copy = {},
			    p;
			for (p in vars) {
				copy[p] = vars[p];
			}
			return copy;
		},
		    _applyCycle = function (vars, targets, i) {
			var alt = vars.cycle,
			    p,
			    val;
			for (p in alt) {
				val = alt[p];
				vars[p] = typeof val === "function" ? val.call(targets[i], i) : val[i % val.length];
			}
			delete vars.cycle;
		},
		    _pauseCallback = _internals.pauseCallback = function () {},
		    _slice = function (a) {
			//don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			var b = [],
			    l = a.length,
			    i;
			for (i = 0; i !== l; b.push(a[i++])) {}
			return b;
		},
		    p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.18.4";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = p._hasPause = false;

		/* might use later...
  //translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
  function localToGlobal(time, animation) {
  	while (animation) {
  		time = (time / animation._timeScale) + animation._startTime;
  		animation = animation.timeline;
  	}
  	return time;
  }
  	//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
  function globalToLocal(time, animation) {
  	var scale = 1;
  	time -= localToGlobal(0, animation);
  	while (animation) {
  		scale *= animation._timeScale;
  		animation = animation.timeline;
  	}
  	return time * scale;
  }
  */

		p.to = function (target, duration, vars, position) {
			var Engine = vars.repeat && _globals.TweenMax || TweenLite;
			return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function (target, duration, vars, position) {
			return this.add((vars.repeat && _globals.TweenMax || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function (target, duration, fromVars, toVars, position) {
			var Engine = toVars.repeat && _globals.TweenMax || TweenLite;
			return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({ onComplete: onCompleteAll, onCompleteParams: onCompleteAllParams, callbackScope: onCompleteAllScope, smoothChildTiming: this.smoothChildTiming }),
			    cycle = vars.cycle,
			    copy,
			    i;
			if (typeof targets === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) {
				//senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				copy = _copy(vars);
				if (copy.startAt) {
					copy.startAt = _copy(copy.startAt);
					if (copy.startAt.cycle) {
						_applyCycle(copy.startAt, targets, i);
					}
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
				}
				tl.to(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = vars.immediateRender != false;
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function (targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function (callback, params, scope, position) {
			return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function (target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = position === this._time && !this._paused;
			}
			return this.add(new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function (vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
			    root = tl._timeline,
			    tween,
			    next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		};

		p.add = function (value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof position !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if (value instanceof Array || value && value.push && _isArray(value)) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({ tweens: child });
						}
						this.add(child, curTime);
						if (typeof child !== "string" && typeof child !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + child.totalDuration() / child._timeScale;
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof value === "string") {
					return this.addLabel(value, position);
				} else if (typeof value === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw "Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.";
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = tl.rawTime() > value._startTime; //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function (value) {
			if (value instanceof Animation) {
				this._remove(value, false);
				var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline; //now that it's removed, default it to the root timeline so that if it gets played again, it doesn't jump back into this timeline.
				value._startTime = (value._paused ? value._pauseTime : tl._time) - (!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale; //ensure that if it gets played again, the timing is correct.
				return this;
			} else if (value instanceof Array || value && value.push && _isArray(value)) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof value === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function (tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
				this._time = this.duration();
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function (value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function (value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function (tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function (label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function (position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
			t.vars.onComplete = t.vars.onReverseComplete = callback;
			t.data = "isPause";
			this._hasPause = true;
			return this.add(t, position);
		};

		p.removeLabel = function (label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function (label) {
			return this._labels[label] != null ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function (timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof offsetOrLabel === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && typeof timeOrLabel === "number" && this._labels[offsetOrLabel] == null ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof timeOrLabel === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
				//if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? this._labels[timeOrLabel] = this.duration() + offsetOrLabel : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
				timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function (position, suppressEvents) {
			return this.totalTime(typeof position === "number" ? position : this._parseTimeOrLabel(position), suppressEvents !== false);
		};

		p.stop = function () {
			return this.paused(true);
		};

		p.gotoAndPlay = function (position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function (position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function (time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    prevTime = this._time,
			    prevStart = this._startTime,
			    prevTimeScale = this._timeScale,
			    prevPaused = this._paused,
			    tween,
			    isComplete,
			    next,
			    callback,
			    internalForce,
			    pauseTween,
			    curTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time <= 0 && time >= -0.0000001 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.
			} else if (time < 0.0000001) {
				//to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || time < 0 && this._rawPrevTime >= 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						//ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) {
						//when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) {
						//if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}
			} else {

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					if (time >= prevTime) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
					}
				}

				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= curTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
				//if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) {
						//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p._hasPausedChild = function () {
			var tween = this._first;
			while (tween) {
				if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild()) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function (nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
			    tween = this._first,
			    cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function (target, nested) {
			var disabled = this._gc,
			    a = [],
			    cnt = 0,
			    tweens,
			    i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || nested && this._contains(tweens[i])) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function () {
			return this._recent;
		};

		p._contains = function (tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function (amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
			    labels = this._labels,
			    p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function (vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = !target ? this.getChildren(true, true, false) : this.getTweensOf(target),
			    i = tweens.length,
			    changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function (labels) {
			var tweens = this.getChildren(false, true, true),
			    i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function () {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function (time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
					    tween = this._last,
					    prevStart = 999999999999,
					    prev,
					    end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) {
							//in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) {
							//children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + tween._totalDuration / tween._timeScale;
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return value && this.totalDuration() ? this.timeScale(this._totalDuration / value) : this;
		};

		p.paused = function (value) {
			if (!value) {
				//if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
				    time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function () {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return tl === Animation._rootFramesTimeline;
		};

		p.rawTime = function () {
			return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
		};

		return TimelineLite;
	}, true);

	/*
  * ----------------------------------------------------------------
  * TimelineMax
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (TimelineLite, TweenLite, Ease) {

		var TimelineMax = function (vars) {
			TimelineLite.call(this, vars);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._cycle = 0;
			this._yoyo = this.vars.yoyo === true;
			this._dirty = true;
		},
		    _tinyNum = 0.0000000001,
		    TweenLiteInternals = TweenLite._internals,
		    _lazyTweens = TweenLiteInternals.lazyTweens,
		    _lazyRender = TweenLiteInternals.lazyRender,
		    _easeNone = new Ease(null, null, 1, 0),
		    p = TimelineMax.prototype = new TimelineLite();

		p.constructor = TimelineMax;
		p.kill()._gc = false;
		TimelineMax.version = "1.18.4";

		p.invalidate = function () {
			this._yoyo = this.vars.yoyo === true;
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TimelineLite.prototype.invalidate.call(this);
		};

		p.addCallback = function (callback, position, params, scope) {
			return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.removeCallback = function (callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
					    i = a.length,
					    time = this._parseTimeOrLabel(position);
					while (--i > -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		};

		p.removePause = function (position) {
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);
		};

		p.tweenTo = function (position, vars) {
			vars = vars || {};
			var copy = { ease: _easeNone, useFrames: this.usesFrames(), immediateRender: false },
			    duration,
			    p,
			    t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = Math.abs(Number(copy.time) - this._time) / this._timeScale || 0.001;
			t = new TweenLite(this, duration, copy);
			copy.onStart = function () {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() && duration === t.duration()) {
					//don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale);
				}
				if (vars.onStart) {
					//in case the user had an onStart in the vars - we don't want to overwrite it.
					t._callback("onStart");
				}
			};
			return t;
		};

		p.tweenFromTo = function (fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = { onComplete: this.seek, onCompleteParams: [fromPosition], callbackScope: this };
			vars.immediateRender = vars.immediateRender !== false;
			var t = this.tweenTo(toPosition, vars);
			return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || 0.001);
		};

		p.render = function (time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
			    dur = this._duration,
			    prevTime = this._time,
			    prevTotalTime = this._totalTime,
			    prevStart = this._startTime,
			    prevTimeScale = this._timeScale,
			    prevRawPrevTime = this._rawPrevTime,
			    prevPaused = this._paused,
			    prevCycle = this._cycle,
			    tween,
			    isComplete,
			    next,
			    callback,
			    internalForce,
			    cycleDuration,
			    pauseTween,
			    curTime;
			if (time >= totalDur - 0.0000001) {
				//to work around occasional floating point math artifacts.
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time <= 0 && time >= -0.0000001 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}
			} else if (time < 0.0000001) {
				//to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {
					this._totalTime = this._cycle = 0;
				}
				this._time = 0;
				if (prevTime !== 0 || dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || time < 0 && prevRawPrevTime >= 0) && !this._locked) {
					//edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (prevRawPrevTime >= 0 && this._first) {
						//when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = dur || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) {
						//if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}
			} else {
				if (dur === 0 && prevRawPrevTime < 0) {
					//without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
					internalForce = true;
				}
				this._time = this._rawPrevTime = time;
				if (!this._locked) {
					this._totalTime = time;
					if (this._repeat !== 0) {
						cycleDuration = dur + this._repeatDelay;
						this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						this._time = this._totalTime - this._cycle * cycleDuration;
						if (this._yoyo) if ((this._cycle & 1) !== 0) {
							this._time = dur - this._time;
						}
						if (this._time > dur) {
							this._time = dur;
							time = dur + 0.0001; //to avoid occasional floating point rounding error
						} else if (this._time < 0) {
							this._time = time = 0;
						} else {
							time = this._time;
						}
					}
				}

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					time = this._time;
					if (time >= prevTime) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
					}
				}
			}

			if (this._cycle !== prevCycle) if (!this._locked) {
				/*
    make sure children at the end/beginning of the timeline are rendered properly. If, for example,
    a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
    would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
    could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
    we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
    ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
    */
				var backwards = this._yoyo && (prevCycle & 1) !== 0,
				    wrap = backwards === (this._yoyo && (this._cycle & 1) !== 0),
				    recTotalTime = this._totalTime,
				    recCycle = this._cycle,
				    recRawPrevTime = this._rawPrevTime,
				    recTime = this._time;

				this._totalTime = prevCycle * dur;
				if (this._cycle < prevCycle) {
					backwards = !backwards;
				} else {
					this._totalTime += dur;
				}
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

				this._rawPrevTime = dur === 0 ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
				this._cycle = prevCycle;
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = backwards ? 0 : dur;
				this.render(prevTime, suppressEvents, dur === 0);
				if (!suppressEvents) if (!this._gc) {
					if (this.vars.onRepeat) {
						this._callback("onRepeat");
					}
				}
				if (prevTime !== this._time) {
					//in case there's a callback like onComplete in a nested tween/timeline that changes the playhead position, like via seek(), we should just abort.
					return;
				}
				if (wrap) {
					prevTime = backwards ? dur + 0.0001 : -0.0001;
					this.render(prevTime, true, false);
				}
				this._locked = false;
				if (this._paused && !prevPaused) {
					//if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;
				}
				this._time = recTime;
				this._totalTime = recTotalTime;
				this._cycle = recCycle;
				this._rawPrevTime = recRawPrevTime;
			}

			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
					//so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
				this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || this._paused && !prevPaused) {
						//in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
				//if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) {
						//in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p.getActive = function (nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [],
			    all = this.getChildren(nested, tweens, timelines),
			    cnt = 0,
			    l = all.length,
			    i,
			    tween;
			for (i = 0; i < l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		};

		p.getLabelAfter = function (time) {
			if (!time) if (time !== 0) {
				//faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
			    l = labels.length,
			    i;
			for (i = 0; i < l; i++) {
				if (labels[i].time > time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelBefore = function (time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
			    i = labels.length;
			while (--i > -1) {
				if (labels[i].time < time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelsArray = function () {
			var a = [],
			    cnt = 0,
			    p;
			for (p in this._labels) {
				a[cnt++] = { time: this._labels[p], name: p };
			}
			a.sort(function (a, b) {
				return a.time - b.time;
			});
			return a;
		};

		//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

		p.progress = function (value, suppressEvents) {
			return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
		};

		p.totalProgress = function (value, suppressEvents) {
			return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
		};

		p.totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
				}
				return this._totalDuration;
			}
			return this._repeat === -1 || !value ? this : this.timeScale(this.totalDuration() / value);
		};

		p.time = function (value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.repeat = function (value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function (value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function (value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		p.currentLabel = function (value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		};

		return TimelineMax;
	}, true);

	/*
  * ----------------------------------------------------------------
  * BezierPlugin
  * ----------------------------------------------------------------
  */
	(function () {

		var _RAD2DEG = 180 / Math.PI,
		    _r1 = [],
		    _r2 = [],
		    _r3 = [],
		    _corProps = {},
		    _globals = _gsScope._gsDefine.globals,
		    Segment = function (a, b, c, d) {
			this.a = a;
			this.b = b;
			this.c = c;
			this.d = d;
			this.da = d - a;
			this.ca = c - a;
			this.ba = b - a;
		},
		    _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
		    cubicToQuadratic = function (a, b, c, d) {
			var q1 = { a: a },
			    q2 = {},
			    q3 = {},
			    q4 = { c: d },
			    mab = (a + b) / 2,
			    mbc = (b + c) / 2,
			    mcd = (c + d) / 2,
			    mabc = (mab + mbc) / 2,
			    mbcd = (mbc + mcd) / 2,
			    m8 = (mbcd - mabc) / 8;
			q1.b = mab + (a - mab) / 4;
			q2.b = mabc + m8;
			q1.c = q2.a = (q1.b + q2.b) / 2;
			q2.c = q3.a = (mabc + mbcd) / 2;
			q3.b = mbcd - m8;
			q4.b = mcd + (d - mcd) / 4;
			q3.c = q4.a = (q3.b + q4.b) / 2;
			return [q1, q2, q3, q4];
		},
		    _calculateControlPoints = function (a, curviness, quad, basic, correlate) {
			var l = a.length - 1,
			    ii = 0,
			    cp1 = a[0].a,
			    i,
			    p1,
			    p2,
			    p3,
			    seg,
			    m1,
			    m2,
			    mm,
			    cp2,
			    qb,
			    r1,
			    r2,
			    tl;
			for (i = 0; i < l; i++) {
				seg = a[ii];
				p1 = seg.a;
				p2 = seg.d;
				p3 = a[ii + 1].d;

				if (correlate) {
					r1 = _r1[i];
					r2 = _r2[i];
					tl = (r2 + r1) * curviness * 0.25 / (basic ? 0.5 : _r3[i] || 0.5);
					m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : r1 !== 0 ? tl / r1 : 0);
					m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : r2 !== 0 ? tl / r2 : 0);
					mm = p2 - (m1 + ((m2 - m1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));
				} else {
					m1 = p2 - (p2 - p1) * curviness * 0.5;
					m2 = p2 + (p3 - p2) * curviness * 0.5;
					mm = p2 - (m1 + m2) / 2;
				}
				m1 += mm;
				m2 += mm;

				seg.c = cp2 = m1;
				if (i !== 0) {
					seg.b = cp1;
				} else {
					seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
				}

				seg.da = p2 - p1;
				seg.ca = cp2 - p1;
				seg.ba = cp1 - p1;

				if (quad) {
					qb = cubicToQuadratic(p1, cp1, cp2, p2);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
					ii += 4;
				} else {
					ii++;
				}

				cp1 = m2;
			}
			seg = a[ii];
			seg.b = cp1;
			seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
			seg.da = seg.d - seg.a;
			seg.ca = seg.c - seg.a;
			seg.ba = cp1 - seg.a;
			if (quad) {
				qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
				a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
			}
		},
		    _parseAnchors = function (values, p, correlate, prepend) {
			var a = [],
			    l,
			    i,
			    p1,
			    p2,
			    p3,
			    tmp;
			if (prepend) {
				values = [prepend].concat(values);
				i = values.length;
				while (--i > -1) {
					if (typeof (tmp = values[i][p]) === "string") if (tmp.charAt(1) === "=") {
						values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
					}
				}
			}
			l = values.length - 2;
			if (l < 0) {
				a[0] = new Segment(values[0][p], 0, 0, values[l < -1 ? 0 : 1][p]);
				return a;
			}
			for (i = 0; i < l; i++) {
				p1 = values[i][p];
				p2 = values[i + 1][p];
				a[i] = new Segment(p1, 0, 0, p2);
				if (correlate) {
					p3 = values[i + 2][p];
					_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
					_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
				}
			}
			a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]);
			return a;
		},
		    bezierThrough = function (values, curviness, quadratic, basic, correlate, prepend) {
			var obj = {},
			    props = [],
			    first = prepend || values[0],
			    i,
			    p,
			    a,
			    j,
			    r,
			    l,
			    seamless,
			    last;
			correlate = typeof correlate === "string" ? "," + correlate + "," : _correlate;
			if (curviness == null) {
				curviness = 1;
			}
			for (p in values[0]) {
				props.push(p);
			}
			//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
			if (values.length > 1) {
				last = values[values.length - 1];
				seamless = true;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					if (Math.abs(first[p] - last[p]) > 0.05) {
						//build in a tolerance of +/-0.05 to accommodate rounding errors.
						seamless = false;
						break;
					}
				}
				if (seamless) {
					values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
					if (prepend) {
						values.unshift(prepend);
					}
					values.push(values[1]);
					prepend = values[values.length - 3];
				}
			}
			_r1.length = _r2.length = _r3.length = 0;
			i = props.length;
			while (--i > -1) {
				p = props[i];
				_corProps[p] = correlate.indexOf("," + p + ",") !== -1;
				obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
			}
			i = _r1.length;
			while (--i > -1) {
				_r1[i] = Math.sqrt(_r1[i]);
				_r2[i] = Math.sqrt(_r2[i]);
			}
			if (!basic) {
				i = props.length;
				while (--i > -1) {
					if (_corProps[p]) {
						a = obj[props[i]];
						l = a.length - 1;
						for (j = 0; j < l; j++) {
							r = a[j + 1].da / _r2[j] + a[j].da / _r1[j] || 0;
							_r3[j] = (_r3[j] || 0) + r * r;
						}
					}
				}
				i = _r3.length;
				while (--i > -1) {
					_r3[i] = Math.sqrt(_r3[i]);
				}
			}
			i = props.length;
			j = quadratic ? 4 : 1;
			while (--i > -1) {
				p = props[i];
				a = obj[p];
				_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
				if (seamless) {
					a.splice(0, j);
					a.splice(a.length - j, j);
				}
			}
			return obj;
		},
		    _parseBezierData = function (values, type, prepend) {
			type = type || "soft";
			var obj = {},
			    inc = type === "cubic" ? 3 : 2,
			    soft = type === "soft",
			    props = [],
			    a,
			    b,
			    c,
			    d,
			    cur,
			    i,
			    j,
			    l,
			    p,
			    cnt,
			    tmp;
			if (soft && prepend) {
				values = [prepend].concat(values);
			}
			if (values == null || values.length < inc + 1) {
				throw "invalid Bezier data";
			}
			for (p in values[0]) {
				props.push(p);
			}
			i = props.length;
			while (--i > -1) {
				p = props[i];
				obj[p] = cur = [];
				cnt = 0;
				l = values.length;
				for (j = 0; j < l; j++) {
					a = prepend == null ? values[j][p] : typeof (tmp = values[j][p]) === "string" && tmp.charAt(1) === "=" ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
					if (soft) if (j > 1) if (j < l - 1) {
						cur[cnt++] = (a + cur[cnt - 2]) / 2;
					}
					cur[cnt++] = a;
				}
				l = cnt - inc + 1;
				cnt = 0;
				for (j = 0; j < l; j += inc) {
					a = cur[j];
					b = cur[j + 1];
					c = cur[j + 2];
					d = inc === 2 ? 0 : cur[j + 3];
					cur[cnt++] = tmp = inc === 3 ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
				}
				cur.length = cnt;
			}
			return obj;
		},
		    _addCubicLengths = function (a, steps, resolution) {
			var inc = 1 / resolution,
			    j = a.length,
			    d,
			    d1,
			    s,
			    da,
			    ca,
			    ba,
			    p,
			    i,
			    inv,
			    bez,
			    index;
			while (--j > -1) {
				bez = a[j];
				s = bez.a;
				da = bez.d - s;
				ca = bez.c - s;
				ba = bez.b - s;
				d = d1 = 0;
				for (i = 1; i <= resolution; i++) {
					p = inc * i;
					inv = 1 - p;
					d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
					index = j * resolution + i - 1;
					steps[index] = (steps[index] || 0) + d * d;
				}
			}
		},
		    _parseLengthData = function (obj, resolution) {
			resolution = resolution >> 0 || 6;
			var a = [],
			    lengths = [],
			    d = 0,
			    total = 0,
			    threshold = resolution - 1,
			    segments = [],
			    curLS = [],
			    //current length segments array
			p,
			    i,
			    l,
			    index;
			for (p in obj) {
				_addCubicLengths(obj[p], a, resolution);
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				d += Math.sqrt(a[i]);
				index = i % resolution;
				curLS[index] = d;
				if (index === threshold) {
					total += d;
					index = i / resolution >> 0;
					segments[index] = curLS;
					lengths[index] = total;
					d = 0;
					curLS = [];
				}
			}
			return { length: total, lengths: lengths, segments: segments };
		},
		    BezierPlugin = _gsScope._gsDefine.plugin({
			propName: "bezier",
			priority: -1,
			version: "1.3.5",
			API: 2,
			global: true,

			//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function (target, vars, tween) {
				this._target = target;
				if (vars instanceof Array) {
					vars = { values: vars };
				}
				this._func = {};
				this._round = {};
				this._props = [];
				this._timeRes = vars.timeResolution == null ? 6 : parseInt(vars.timeResolution, 10);
				var values = vars.values || [],
				    first = {},
				    second = values[0],
				    autoRotate = vars.autoRotate || tween.vars.orientToBezier,
				    p,
				    isFunc,
				    i,
				    j,
				    prepend;

				this._autoRotate = autoRotate ? autoRotate instanceof Array ? autoRotate : [["x", "y", "rotation", autoRotate === true ? 0 : Number(autoRotate) || 0]] : null;
				for (p in second) {
					this._props.push(p);
				}

				i = this._props.length;
				while (--i > -1) {
					p = this._props[i];

					this._overwriteProps.push(p);
					isFunc = this._func[p] = typeof target[p] === "function";
					first[p] = !isFunc ? parseFloat(target[p]) : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]();
					if (!prepend) if (first[p] !== values[0][p]) {
						prepend = first;
					}
				}
				this._beziers = vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft" ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, vars.type === "thruBasic", vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
				this._segCount = this._beziers[p].length;

				if (this._timeRes) {
					var ld = _parseLengthData(this._beziers, this._timeRes);
					this._length = ld.length;
					this._lengths = ld.lengths;
					this._segments = ld.segments;
					this._l1 = this._li = this._s1 = this._si = 0;
					this._l2 = this._lengths[0];
					this._curSeg = this._segments[0];
					this._s2 = this._curSeg[0];
					this._prec = 1 / this._curSeg.length;
				}

				if (autoRotate = this._autoRotate) {
					this._initialRotations = [];
					if (!(autoRotate[0] instanceof Array)) {
						this._autoRotate = autoRotate = [autoRotate];
					}
					i = autoRotate.length;
					while (--i > -1) {
						for (j = 0; j < 3; j++) {
							p = autoRotate[i][j];
							this._func[p] = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)] : false;
						}
						p = autoRotate[i][2];
						this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
					}
				}
				this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
				return true;
			},

			//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
			set: function (v) {
				var segments = this._segCount,
				    func = this._func,
				    target = this._target,
				    notStart = v !== this._startRatio,
				    curIndex,
				    inv,
				    i,
				    p,
				    b,
				    t,
				    val,
				    l,
				    lengths,
				    curSeg;
				if (!this._timeRes) {
					curIndex = v < 0 ? 0 : v >= 1 ? segments - 1 : segments * v >> 0;
					t = (v - curIndex * (1 / segments)) * segments;
				} else {
					lengths = this._lengths;
					curSeg = this._curSeg;
					v *= this._length;
					i = this._li;
					//find the appropriate segment (if the currently cached one isn't correct)
					if (v > this._l2 && i < segments - 1) {
						l = segments - 1;
						while (i < l && (this._l2 = lengths[++i]) <= v) {}
						this._l1 = lengths[i - 1];
						this._li = i;
						this._curSeg = curSeg = this._segments[i];
						this._s2 = curSeg[this._s1 = this._si = 0];
					} else if (v < this._l1 && i > 0) {
						while (i > 0 && (this._l1 = lengths[--i]) >= v) {}
						if (i === 0 && v < this._l1) {
							this._l1 = 0;
						} else {
							i++;
						}
						this._l2 = lengths[i];
						this._li = i;
						this._curSeg = curSeg = this._segments[i];
						this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
						this._s2 = curSeg[this._si];
					}
					curIndex = i;
					//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
					v -= this._l1;
					i = this._si;
					if (v > this._s2 && i < curSeg.length - 1) {
						l = curSeg.length - 1;
						while (i < l && (this._s2 = curSeg[++i]) <= v) {}
						this._s1 = curSeg[i - 1];
						this._si = i;
					} else if (v < this._s1 && i > 0) {
						while (i > 0 && (this._s1 = curSeg[--i]) >= v) {}
						if (i === 0 && v < this._s1) {
							this._s1 = 0;
						} else {
							i++;
						}
						this._s2 = curSeg[i];
						this._si = i;
					}
					t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec || 0;
				}
				inv = 1 - t;

				i = this._props.length;
				while (--i > -1) {
					p = this._props[i];
					b = this._beziers[p][curIndex];
					val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
					if (this._round[p]) {
						val = Math.round(val);
					}
					if (func[p]) {
						target[p](val);
					} else {
						target[p] = val;
					}
				}

				if (this._autoRotate) {
					var ar = this._autoRotate,
					    b2,
					    x1,
					    y1,
					    x2,
					    y2,
					    add,
					    conv;
					i = ar.length;
					while (--i > -1) {
						p = ar[i][2];
						add = ar[i][3] || 0;
						conv = ar[i][4] === true ? 1 : _RAD2DEG;
						b = this._beziers[ar[i][0]];
						b2 = this._beziers[ar[i][1]];

						if (b && b2) {
							//in case one of the properties got overwritten.
							b = b[curIndex];
							b2 = b2[curIndex];

							x1 = b.a + (b.b - b.a) * t;
							x2 = b.b + (b.c - b.b) * t;
							x1 += (x2 - x1) * t;
							x2 += (b.c + (b.d - b.c) * t - x2) * t;

							y1 = b2.a + (b2.b - b2.a) * t;
							y2 = b2.b + (b2.c - b2.b) * t;
							y1 += (y2 - y1) * t;
							y2 += (b2.c + (b2.d - b2.c) * t - y2) * t;

							val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}
					}
				}
			}
		}),
		    p = BezierPlugin.prototype;

		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function (a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function () {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
			    _parseToProxy = _internals._parseToProxy,
			    _setPluginRatio = _internals._setPluginRatio,
			    CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", { parser: function (t, e, prop, cssp, pt, plugin) {
					if (e instanceof Array) {
						e = { values: e };
					}
					plugin = new BezierPlugin();
					var values = e.values,
					    l = values.length - 1,
					    pluginValues = [],
					    v = {},
					    i,
					    p,
					    data;
					if (l < 0) {
						return pt;
					}
					for (i = 0; i <= l; i++) {
						data = _parseToProxy(t, values[i], cssp, pt, plugin, l !== i);
						pluginValues[i] = data.end;
					}
					for (p in e) {
						v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
					}
					v.values = pluginValues;
					pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
					pt.data = data;
					pt.plugin = plugin;
					pt.setRatio = _setPluginRatio;
					if (v.autoRotate === 0) {
						v.autoRotate = true;
					}
					if (v.autoRotate && !(v.autoRotate instanceof Array)) {
						i = v.autoRotate === true ? 0 : Number(v.autoRotate);
						v.autoRotate = data.end.left != null ? [["left", "top", "rotation", i, false]] : data.end.x != null ? [["x", "y", "rotation", i, false]] : false;
					}
					if (v.autoRotate) {
						if (!cssp._transform) {
							cssp._enableTransforms(false);
						}
						data.autoRotate = cssp._target._gsTransform;
					}
					plugin._onInitTween(data.proxy, v, cssp._tween);
					return pt;
				} });
		};

		p._roundProps = function (lookup, value) {
			var op = this._overwriteProps,
			    i = op.length;
			while (--i > -1) {
				if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
					this._round[op[i]] = value;
				}
			}
		};

		p._kill = function (lookup) {
			var a = this._props,
			    p,
			    i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};
	})();

	/*
  * ----------------------------------------------------------------
  * CSSPlugin
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (TweenPlugin, TweenLite) {

		/** @constructor **/
		var CSSPlugin = function () {
			TweenPlugin.call(this, "css");
			this._overwriteProps.length = 0;
			this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
		},
		    _globals = _gsScope._gsDefine.globals,
		    _hasPriority,
		    //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
		_suffixMap,
		    //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
		_cs,
		    //computed style (we store this in a shared variable to conserve memory and make minification tighter
		_overwriteProps,
		    //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
		_specialProps = {},
		    p = CSSPlugin.prototype = new TweenPlugin("css");

		p.constructor = CSSPlugin;
		CSSPlugin.version = "1.18.4";
		CSSPlugin.API = 2;
		CSSPlugin.defaultTransformPerspective = 0;
		CSSPlugin.defaultSkewType = "compensated";
		CSSPlugin.defaultSmoothOrigin = true;
		p = "px"; //we'll reuse the "p" variable to keep file size down
		CSSPlugin.suffixMap = { top: p, right: p, bottom: p, left: p, width: p, height: p, fontSize: p, padding: p, margin: p, perspective: p, lineHeight: "" };

		var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
		    _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
		    _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
		    //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
		_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
		    //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
		_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
		    _opacityExp = /opacity *= *([^)]*)/i,
		    _opacityValExp = /opacity:([^;]*)/i,
		    _alphaFilterExp = /alpha\(opacity *=.+?\)/i,
		    _rgbhslExp = /^(rgb|hsl)/,
		    _capsExp = /([A-Z])/g,
		    _camelExp = /-([a-z])/gi,
		    _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
		    //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
		_camelFunc = function (s, g) {
			return g.toUpperCase();
		},
		    _horizExp = /(?:Left|Right|Width)/i,
		    _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
		    _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
		    _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi,
		    //finds any commas that are not within parenthesis
		_complexExp = /[\s,\(]/i,
		    //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
		_DEG2RAD = Math.PI / 180,
		    _RAD2DEG = 180 / Math.PI,
		    _forcePT = {},
		    _doc = document,
		    _createElement = function (type) {
			return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
		},
		    _tempDiv = _createElement("div"),
		    _tempImg = _createElement("img"),
		    _internals = CSSPlugin._internals = { _specialProps: _specialProps },
		    //provides a hook to a few internal methods that we need to access from inside other plugins
		_agent = navigator.userAgent,
		    _autoRound,
		    _reqSafariFix,
		    //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

		_isSafari,
		    _isFirefox,
		    //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
		_isSafariLT6,
		    //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
		_ieVers,
		    _supportsOpacity = function () {
			//we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
			var i = _agent.indexOf("Android"),
			    a = _createElement("a");
			_isSafari = _agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i + 8, 1)) > 3);
			_isSafariLT6 = _isSafari && Number(_agent.substr(_agent.indexOf("Version/") + 8, 1)) < 6;
			_isFirefox = _agent.indexOf("Firefox") !== -1;
			if (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(_agent)) {
				_ieVers = parseFloat(RegExp.$1);
			}
			if (!a) {
				return false;
			}
			a.style.cssText = "top:1px;opacity:.55;";
			return (/^0.55/.test(a.style.opacity)
			);
		}(),
		    _getIEOpacity = function (v) {
			return _opacityExp.test(typeof v === "string" ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
		},
		    _log = function (s) {
			//for logging messages, but in a way that won't throw errors in old versions of IE.
			if (window.console) {
				console.log(s);
			}
		},
		    _prefixCSS = "",
		    //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
		_prefix = "",
		    //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

		// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
		_checkPropPrefix = function (p, e) {
			e = e || _tempDiv;
			var s = e.style,
			    a,
			    i;
			if (s[p] !== undefined) {
				return p;
			}
			p = p.charAt(0).toUpperCase() + p.substr(1);
			a = ["O", "Moz", "ms", "Ms", "Webkit"];
			i = 5;
			while (--i > -1 && s[a[i] + p] === undefined) {}
			if (i >= 0) {
				_prefix = i === 3 ? "ms" : a[i];
				_prefixCSS = "-" + _prefix.toLowerCase() + "-";
				return _prefix + p;
			}
			return null;
		},
		    _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function () {},


		/**
   * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
   * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
   *
   * @param {!Object} t Target element whose style property you want to query
   * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
   * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
   * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
   * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
   * @return {?string} The current property value
   */
		_getStyle = CSSPlugin.getStyle = function (t, p, cs, calc, dflt) {
			var rv;
			if (!_supportsOpacity) if (p === "opacity") {
				//several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
				return _getIEOpacity(t);
			}
			if (!calc && t.style[p]) {
				rv = t.style[p];
			} else if (cs = cs || _getComputedStyle(t)) {
				rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
			} else if (t.currentStyle) {
				rv = t.currentStyle[p];
			}
			return dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto") ? dflt : rv;
		},


		/**
   * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
   * @param {!Object} t Target element
   * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
   * @param {!number} v Value
   * @param {string=} sfx Suffix (like "px" or "%" or "em")
   * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
   * @return {number} value in pixels
   */
		_convertToPixels = _internals.convertToPixels = function (t, p, v, sfx, recurse) {
			if (sfx === "px" || !sfx) {
				return v;
			}
			if (sfx === "auto" || !v) {
				return 0;
			}
			var horiz = _horizExp.test(p),
			    node = t,
			    style = _tempDiv.style,
			    neg = v < 0,
			    pix,
			    cache,
			    time;
			if (neg) {
				v = -v;
			}
			if (sfx === "%" && p.indexOf("border") !== -1) {
				pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight);
			} else {
				style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
				if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
					node = t.parentNode || _doc.body;
					cache = node._gsCache;
					time = TweenLite.ticker.frame;
					if (cache && horiz && cache.time === time) {
						//performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
						return cache.width * v / 100;
					}
					style[horiz ? "width" : "height"] = v + sfx;
				} else {
					style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx;
				}
				node.appendChild(_tempDiv);
				pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]);
				node.removeChild(_tempDiv);
				if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
					cache = node._gsCache = node._gsCache || {};
					cache.time = time;
					cache.width = pix / v * 100;
				}
				if (pix === 0 && !recurse) {
					pix = _convertToPixels(t, p, v, sfx, true);
				}
			}
			return neg ? -pix : pix;
		},
		    _calculateOffset = _internals.calculateOffset = function (t, p, cs) {
			//for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
			if (_getStyle(t, "position", cs) !== "absolute") {
				return 0;
			}
			var dim = p === "left" ? "Left" : "Top",
			    v = _getStyle(t, "margin" + dim, cs);
			return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
		},


		// @private returns at object containing ALL of the style properties in camelCase and their associated values.
		_getAllStyles = function (t, cs) {
			var s = {},
			    i,
			    tr,
			    p;
			if (cs = cs || _getComputedStyle(t, null)) {
				if (i = cs.length) {
					while (--i > -1) {
						p = cs[i];
						if (p.indexOf("-transform") === -1 || _transformPropCSS === p) {
							//Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
							s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
						}
					}
				} else {
					//some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
					for (i in cs) {
						if (i.indexOf("Transform") === -1 || _transformProp === i) {
							//Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
							s[i] = cs[i];
						}
					}
				}
			} else if (cs = t.currentStyle || t.style) {
				for (i in cs) {
					if (typeof i === "string" && s[i] === undefined) {
						s[i.replace(_camelExp, _camelFunc)] = cs[i];
					}
				}
			}
			if (!_supportsOpacity) {
				s.opacity = _getIEOpacity(t);
			}
			tr = _getTransform(t, cs, false);
			s.rotation = tr.rotation;
			s.skewX = tr.skewX;
			s.scaleX = tr.scaleX;
			s.scaleY = tr.scaleY;
			s.x = tr.x;
			s.y = tr.y;
			if (_supports3D) {
				s.z = tr.z;
				s.rotationX = tr.rotationX;
				s.rotationY = tr.rotationY;
				s.scaleZ = tr.scaleZ;
			}
			if (s.filters) {
				delete s.filters;
			}
			return s;
		},


		// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
		_cssDif = function (t, s1, s2, vars, forceLookup) {
			var difs = {},
			    style = t.style,
			    val,
			    p,
			    mpt;
			for (p in s2) {
				if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p]) if (p.indexOf("Origin") === -1) if (typeof val === "number" || typeof val === "string") {
					difs[p] = val === "auto" && (p === "left" || p === "top") ? _calculateOffset(t, p) : (val === "" || val === "auto" || val === "none") && typeof s1[p] === "string" && s1[p].replace(_NaNExp, "") !== "" ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
					if (style[p] !== undefined) {
						//for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
						mpt = new MiniPropTween(style, p, style[p], mpt);
					}
				}
			}
			if (vars) {
				for (p in vars) {
					//copy properties (except className)
					if (p !== "className") {
						difs[p] = vars[p];
					}
				}
			}
			return { difs: difs, firstMPT: mpt };
		},
		    _dimensions = { width: ["Left", "Right"], height: ["Top", "Bottom"] },
		    _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"],


		/**
   * @private Gets the width or height of an element
   * @param {!Object} t Target element
   * @param {!string} p Property name ("width" or "height")
   * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
   * @return {number} Dimension (in pixels)
   */
		_getDimension = function (t, p, cs) {
			if ((t.nodeName + "").toLowerCase() === "svg") {
				//Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
				return (cs || _getComputedStyle(t))[p] || 0;
			} else if (t.getBBox && _isSVG(t)) {
				return t.getBBox()[p] || 0;
			}
			var v = parseFloat(p === "width" ? t.offsetWidth : t.offsetHeight),
			    a = _dimensions[p],
			    i = a.length;
			cs = cs || _getComputedStyle(t, null);
			while (--i > -1) {
				v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0;
				v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0;
			}
			return v;
		},


		// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
		_parsePosition = function (v, recObj) {
			if (v === "contain" || v === "auto" || v === "auto auto") {
				return v + " ";
			}
			if (v == null || v === "") {
				//note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
				v = "0 0";
			}
			var a = v.split(" "),
			    x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0],
			    y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1],
			    i;
			if (a.length > 3 && !recObj) {
				//multiple positions
				a = v.split(", ").join(",").split(",");
				v = [];
				for (i = 0; i < a.length; i++) {
					v.push(_parsePosition(a[i]));
				}
				return v.join(",");
			}
			if (y == null) {
				y = x === "center" ? "50%" : "0";
			} else if (y === "center") {
				y = "50%";
			}
			if (x === "center" || isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1) {
				//remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
				x = "50%";
			}
			v = x + " " + y + (a.length > 2 ? " " + a[2] : "");
			if (recObj) {
				recObj.oxp = x.indexOf("%") !== -1;
				recObj.oyp = y.indexOf("%") !== -1;
				recObj.oxr = x.charAt(1) === "=";
				recObj.oyr = y.charAt(1) === "=";
				recObj.ox = parseFloat(x.replace(_NaNExp, ""));
				recObj.oy = parseFloat(y.replace(_NaNExp, ""));
				recObj.v = v;
			}
			return recObj || v;
		},


		/**
   * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
   * @param {(number|string)} e End value which is typically a string, but could be a number
   * @param {(number|string)} b Beginning value which is typically a string but could be a number
   * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
   */
		_parseChange = function (e, b) {
			return typeof e === "string" && e.charAt(1) === "=" ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b) || 0;
		},


		/**
   * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
   * @param {Object} v Value to be parsed
   * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
   * @return {number} Parsed value
   */
		_parseVal = function (v, d) {
			return v == null ? d : typeof v === "string" && v.charAt(1) === "=" ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
		},


		/**
   * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
   * @param {Object} v Value to be parsed
   * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
   * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
   * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
   * @return {number} parsed angle in radians
   */
		_parseAngle = function (v, d, p, directionalEnd) {
			var min = 0.000001,
			    cap,
			    split,
			    dif,
			    result,
			    isRelative;
			if (v == null) {
				result = d;
			} else if (typeof v === "number") {
				result = v;
			} else {
				cap = 360;
				split = v.split("_");
				isRelative = v.charAt(1) === "=";
				dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * (v.indexOf("rad") === -1 ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
				if (split.length) {
					if (directionalEnd) {
						directionalEnd[p] = d + dif;
					}
					if (v.indexOf("short") !== -1) {
						dif = dif % cap;
						if (dif !== dif % (cap / 2)) {
							dif = dif < 0 ? dif + cap : dif - cap;
						}
					}
					if (v.indexOf("_cw") !== -1 && dif < 0) {
						dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
					} else if (v.indexOf("ccw") !== -1 && dif > 0) {
						dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
					}
				}
				result = d + dif;
			}
			if (result < min && result > -min) {
				result = 0;
			}
			return result;
		},
		    _colorLookup = { aqua: [0, 255, 255],
			lime: [0, 255, 0],
			silver: [192, 192, 192],
			black: [0, 0, 0],
			maroon: [128, 0, 0],
			teal: [0, 128, 128],
			blue: [0, 0, 255],
			navy: [0, 0, 128],
			white: [255, 255, 255],
			fuchsia: [255, 0, 255],
			olive: [128, 128, 0],
			yellow: [255, 255, 0],
			orange: [255, 165, 0],
			gray: [128, 128, 128],
			purple: [128, 0, 128],
			green: [0, 128, 0],
			red: [255, 0, 0],
			pink: [255, 192, 203],
			cyan: [0, 255, 255],
			transparent: [255, 255, 255, 0] },
		    _hue = function (h, m1, m2) {
			h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
			return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + 0.5 | 0;
		},


		/**
   * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
   * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
   * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
   * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
   */
		_parseColor = CSSPlugin.parseColor = function (v, toHSL) {
			var a, r, g, b, h, s, l, max, min, d, wasHSL;
			if (!v) {
				a = _colorLookup.black;
			} else if (typeof v === "number") {
				a = [v >> 16, v >> 8 & 255, v & 255];
			} else {
				if (v.charAt(v.length - 1) === ",") {
					//sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
					v = v.substr(0, v.length - 1);
				}
				if (_colorLookup[v]) {
					a = _colorLookup[v];
				} else if (v.charAt(0) === "#") {
					if (v.length === 4) {
						//for shorthand like #9F0
						r = v.charAt(1);
						g = v.charAt(2);
						b = v.charAt(3);
						v = "#" + r + r + g + g + b + b;
					}
					v = parseInt(v.substr(1), 16);
					a = [v >> 16, v >> 8 & 255, v & 255];
				} else if (v.substr(0, 3) === "hsl") {
					a = wasHSL = v.match(_numExp);
					if (!toHSL) {
						h = Number(a[0]) % 360 / 360;
						s = Number(a[1]) / 100;
						l = Number(a[2]) / 100;
						g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
						r = l * 2 - g;
						if (a.length > 3) {
							a[3] = Number(v[3]);
						}
						a[0] = _hue(h + 1 / 3, r, g);
						a[1] = _hue(h, r, g);
						a[2] = _hue(h - 1 / 3, r, g);
					} else if (v.indexOf("=") !== -1) {
						//if relative values are found, just return the raw strings with the relative prefixes in place.
						return v.match(_relNumExp);
					}
				} else {
					a = v.match(_numExp) || _colorLookup.transparent;
				}
				a[0] = Number(a[0]);
				a[1] = Number(a[1]);
				a[2] = Number(a[2]);
				if (a.length > 3) {
					a[3] = Number(a[3]);
				}
			}
			if (toHSL && !wasHSL) {
				r = a[0] / 255;
				g = a[1] / 255;
				b = a[2] / 255;
				max = Math.max(r, g, b);
				min = Math.min(r, g, b);
				l = (max + min) / 2;
				if (max === min) {
					h = s = 0;
				} else {
					d = max - min;
					s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
					h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
					h *= 60;
				}
				a[0] = h + 0.5 | 0;
				a[1] = s * 100 + 0.5 | 0;
				a[2] = l * 100 + 0.5 | 0;
			}
			return a;
		},
		    _formatColors = function (s, toHSL) {
			var colors = s.match(_colorExp) || [],
			    charIndex = 0,
			    parsed = colors.length ? "" : s,
			    i,
			    color,
			    temp;
			for (i = 0; i < colors.length; i++) {
				color = colors[i];
				temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
				charIndex += temp.length + color.length;
				color = _parseColor(color, toHSL);
				if (color.length === 3) {
					color.push(1);
				}
				parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
			}
			return parsed + s.substr(charIndex);
		},
		    _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

		for (p in _colorLookup) {
			_colorExp += "|" + p + "\\b";
		}
		_colorExp = new RegExp(_colorExp + ")", "gi");

		CSSPlugin.colorStringFilter = function (a) {
			var combined = a[0] + a[1],
			    toHSL;
			if (_colorExp.test(combined)) {
				toHSL = combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1;
				a[0] = _formatColors(a[0], toHSL);
				a[1] = _formatColors(a[1], toHSL);
			}
			_colorExp.lastIndex = 0;
		};

		if (!TweenLite.defaultStringFilter) {
			TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter;
		}

		/**
   * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
   * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
   * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
   * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
   * @return {Function} formatter function
   */
		var _getFormatter = function (dflt, clr, collapsible, multi) {
			if (dflt == null) {
				return function (v) {
					return v;
				};
			}
			var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
			    dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
			    pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
			    sfx = dflt.charAt(dflt.length - 1) === ")" ? ")" : "",
			    delim = dflt.indexOf(" ") !== -1 ? " " : ",",
			    numVals = dVals.length,
			    dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "",
			    formatter;
			if (!numVals) {
				return function (v) {
					return v;
				};
			}
			if (clr) {
				formatter = function (v) {
					var color, vals, i, a;
					if (typeof v === "number") {
						v += dSfx;
					} else if (multi && _commasOutsideParenExp.test(v)) {
						a = v.replace(_commasOutsideParenExp, "|").split("|");
						for (i = 0; i < a.length; i++) {
							a[i] = formatter(a[i]);
						}
						return a.join(",");
					}
					color = (v.match(_colorExp) || [dColor])[0];
					vals = v.split(color).join("").match(_valuesExp) || [];
					i = vals.length;
					if (numVals > i--) {
						while (++i < numVals) {
							vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
						}
					}
					return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
				};
				return formatter;
			}
			formatter = function (v) {
				var vals, a, i;
				if (typeof v === "number") {
					v += dSfx;
				} else if (multi && _commasOutsideParenExp.test(v)) {
					a = v.replace(_commasOutsideParenExp, "|").split("|");
					for (i = 0; i < a.length; i++) {
						a[i] = formatter(a[i]);
					}
					return a.join(",");
				}
				vals = v.match(_valuesExp) || [];
				i = vals.length;
				if (numVals > i--) {
					while (++i < numVals) {
						vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
					}
				}
				return pfx + vals.join(delim) + sfx;
			};
			return formatter;
		},


		/**
   * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
   * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
   * @return {Function} a formatter function
   */
		_getEdgeParser = function (props) {
			props = props.split(",");
			return function (t, e, p, cssp, pt, plugin, vars) {
				var a = (e + "").split(" "),
				    i;
				vars = {};
				for (i = 0; i < 4; i++) {
					vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0];
				}
				return cssp.parse(t, vars, pt, plugin);
			};
		},


		// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens  which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
		_setPluginRatio = _internals._setPluginRatio = function (v) {
			this.plugin.setRatio(v);
			var d = this.data,
			    proxy = d.proxy,
			    mpt = d.firstMPT,
			    min = 0.000001,
			    val,
			    pt,
			    i,
			    str,
			    p;
			while (mpt) {
				val = proxy[mpt.v];
				if (mpt.r) {
					val = Math.round(val);
				} else if (val < min && val > -min) {
					val = 0;
				}
				mpt.t[mpt.p] = val;
				mpt = mpt._next;
			}
			if (d.autoRotate) {
				d.autoRotate.rotation = proxy.rotation;
			}
			//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.
			if (v === 1 || v === 0) {
				mpt = d.firstMPT;
				p = v === 1 ? "e" : "b";
				while (mpt) {
					pt = mpt.t;
					if (!pt.type) {
						pt[p] = pt.s + pt.xs0;
					} else if (pt.type === 1) {
						str = pt.xs0 + pt.s + pt.xs1;
						for (i = 1; i < pt.l; i++) {
							str += pt["xn" + i] + pt["xs" + (i + 1)];
						}
						pt[p] = str;
					}
					mpt = mpt._next;
				}
			}
		},


		/**
   * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
   * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
   * @param {!string} p property name
   * @param {(number|string|object)} v value
   * @param {MiniPropTween=} next next MiniPropTween in the linked list
   * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
   */
		MiniPropTween = function (t, p, v, next, r) {
			this.t = t;
			this.p = p;
			this.v = v;
			this.r = r;
			if (next) {
				next._prev = this;
				this._next = next;
			}
		},


		/**
   * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
   * This method returns an object that has the following properties:
   *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
   *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
   *  - firstMPT: the first MiniPropTween in the linked list
   *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
   * @param {!Object} t target object to be tweened
   * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
   * @param {!CSSPlugin} cssp The CSSPlugin instance
   * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
   * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
   * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
   * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
   */
		_parseToProxy = _internals._parseToProxy = function (t, vars, cssp, pt, plugin, shallow) {
			var bpt = pt,
			    start = {},
			    end = {},
			    transform = cssp._transform,
			    oldForce = _forcePT,
			    i,
			    p,
			    xp,
			    mpt,
			    firstPT;
			cssp._transform = null;
			_forcePT = vars;
			pt = firstPT = cssp.parse(t, vars, pt, plugin);
			_forcePT = oldForce;
			//break off from the linked list so the new ones are isolated.
			if (shallow) {
				cssp._transform = transform;
				if (bpt) {
					bpt._prev = null;
					if (bpt._prev) {
						bpt._prev._next = null;
					}
				}
			}
			while (pt && pt !== bpt) {
				if (pt.type <= 1) {
					p = pt.p;
					end[p] = pt.s + pt.c;
					start[p] = pt.s;
					if (!shallow) {
						mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
						pt.c = 0;
					}
					if (pt.type === 1) {
						i = pt.l;
						while (--i > 0) {
							xp = "xn" + i;
							p = pt.p + "_" + xp;
							end[p] = pt.data[xp];
							start[p] = pt[xp];
							if (!shallow) {
								mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
							}
						}
					}
				}
				pt = pt._next;
			}
			return { proxy: start, end: end, firstMPT: mpt, pt: firstPT };
		},


		/**
   * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
   * CSSPropTweens have the following optional properties as well (not defined through the constructor):
   *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
   *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
   *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
   *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
   *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
   * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
   * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
   * @param {number} s Starting numeric value
   * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
   * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
   * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
   * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
   * @param {boolean=} r If true, the value(s) should be rounded
   * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
   * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
   * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
   */
		CSSPropTween = _internals.CSSPropTween = function (t, p, s, c, next, type, n, r, pr, b, e) {
			this.t = t; //target
			this.p = p; //property
			this.s = s; //starting value
			this.c = c; //change value
			this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
			if (!(t instanceof CSSPropTween)) {
				_overwriteProps.push(this.n);
			}
			this.r = r; //round (boolean)
			this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
			if (pr) {
				this.pr = pr;
				_hasPriority = true;
			}
			this.b = b === undefined ? s : b;
			this.e = e === undefined ? s + c : e;
			if (next) {
				this._next = next;
				next._prev = this;
			}
		},
		    _addNonTweeningNumericPT = function (target, prop, start, end, next, overwriteProp) {
			//cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
			var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
			pt.b = start;
			pt.e = pt.xs0 = end;
			return pt;
		},


		/**
   * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
   * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
   * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
   * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
   *
   * @param {!Object} t Target whose property will be tweened
   * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
   * @param {string} b Beginning value
   * @param {string} e Ending value
   * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
   * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
   * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
   * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
   * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
   * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
   * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
   */
		_parseComplex = CSSPlugin.parseComplex = function (t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
			//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
			b = b || dflt || "";
			pt = new CSSPropTween(t, p, 0, 0, pt, setRatio ? 2 : 1, null, false, pr, b, e);
			e += ""; //ensures it's a string
			if (clrs && _colorExp.test(e + b)) {
				//if colors are found, normalize the formatting to rgba() or hsla().
				e = [b, e];
				CSSPlugin.colorStringFilter(e);
				b = e[0];
				e = e[1];
			}
			var ba = b.split(", ").join(",").split(" "),
			    //beginning array
			ea = e.split(", ").join(",").split(" "),
			    //ending array
			l = ba.length,
			    autoRound = _autoRound !== false,
			    i,
			    xi,
			    ni,
			    bv,
			    ev,
			    bnums,
			    enums,
			    bn,
			    hasAlpha,
			    temp,
			    cv,
			    str,
			    useHSL;
			if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
				ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
				ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
				l = ba.length;
			}
			if (l !== ea.length) {
				//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
				ba = (dflt || "").split(" ");
				l = ba.length;
			}
			pt.plugin = plugin;
			pt.setRatio = setRatio;
			_colorExp.lastIndex = 0;
			for (i = 0; i < l; i++) {
				bv = ba[i];
				ev = ea[i];
				bn = parseFloat(bv);
				//if the value begins with a number (most common). It's fine if it has a suffix like px
				if (bn || bn === 0) {
					pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && ev.indexOf("px") !== -1, true);

					//if the value is a color
				} else if (clrs && _colorExp.test(bv)) {
					str = ev.indexOf(")") + 1;
					str = ")" + (str ? ev.substr(str) : ""); //if there's a comma or ) at the end, retain it.
					useHSL = ev.indexOf("hsl") !== -1 && _supportsOpacity;
					bv = _parseColor(bv, useHSL);
					ev = _parseColor(ev, useHSL);
					hasAlpha = bv.length + ev.length > 6;
					if (hasAlpha && !_supportsOpacity && ev[3] === 0) {
						//older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
						pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
						pt.e = pt.e.split(ea[i]).join("transparent");
					} else {
						if (!_supportsOpacity) {
							//old versions of IE don't support rgba().
							hasAlpha = false;
						}
						if (useHSL) {
							pt.appendXtra(hasAlpha ? "hsla(" : "hsl(", bv[0], _parseChange(ev[0], bv[0]), ",", false, true).appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false).appendXtra("", bv[2], _parseChange(ev[2], bv[2]), hasAlpha ? "%," : "%" + str, false);
						} else {
							pt.appendXtra(hasAlpha ? "rgba(" : "rgb(", bv[0], ev[0] - bv[0], ",", true, true).appendXtra("", bv[1], ev[1] - bv[1], ",", true).appendXtra("", bv[2], ev[2] - bv[2], hasAlpha ? "," : str, true);
						}

						if (hasAlpha) {
							bv = bv.length < 4 ? 1 : bv[3];
							pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, false);
						}
					}
					_colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.
				} else {
					bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

					//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
					if (!bnums) {
						pt["xs" + pt.l] += pt.l || pt["xs" + pt.l] ? " " + ev : ev;

						//loop through all the numbers that are found and construct the extra values on the pt.
					} else {
						enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
						if (!enums || enums.length !== bnums.length) {
							//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
							return pt;
						}
						ni = 0;
						for (xi = 0; xi < bnums.length; xi++) {
							cv = bnums[xi];
							temp = bv.indexOf(cv, ni);
							pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && bv.substr(temp + cv.length, 2) === "px", xi === 0);
							ni = temp + cv.length;
						}
						pt["xs" + pt.l] += bv.substr(ni);
					}
				}
			}
			//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
			if (e.indexOf("=") !== -1) if (pt.data) {
				str = pt.xs0 + pt.data.s;
				for (i = 1; i < pt.l; i++) {
					str += pt["xs" + i] + pt.data["xn" + i];
				}
				pt.e = str + pt["xs" + i];
			}
			if (!pt.l) {
				pt.type = -1;
				pt.xs0 = pt.e;
			}
			return pt.xfirst || pt;
		},
		    i = 9;

		p = CSSPropTween.prototype;
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
		while (--i > 0) {
			p["xn" + i] = 0;
			p["xs" + i] = "";
		}
		p.xs0 = "";
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;

		/**
   * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
   * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
   * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
   * @param {string=} pfx Prefix (if any)
   * @param {!number} s Starting value
   * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
   * @param {string=} sfx Suffix (if any)
   * @param {boolean=} r Round (if true).
   * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
   * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
   */
		p.appendXtra = function (pfx, s, c, sfx, r, pad) {
			var pt = this,
			    l = pt.l;
			pt["xs" + l] += pad && (l || pt["xs" + l]) ? " " + pfx : pfx || "";
			if (!c) if (l !== 0 && !pt.plugin) {
				//typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt["xs" + pt.l] = sfx || "";
			if (l > 0) {
				pt.data["xn" + l] = s + c;
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt["xn" + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}
				return pt;
			}
			pt.data = { s: s + c };
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		};

		/**
   * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
   * @param {!string} p Property name (like "boxShadow" or "throwProps")
   * @param {Object=} options An object containing any of the following configuration options:
   *                      - defaultValue: the default value
   *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
   *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
   *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
   *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
   *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
   *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
   *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
   *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
   */
		var SpecialProp = function (p, options) {
			options = options || {};
			this.p = options.prefix ? _checkPropPrefix(p) || p : p;
			_specialProps[p] = _specialProps[this.p] = this;
			this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
			if (options.parser) {
				this.parse = options.parser;
			}
			this.clrs = options.color;
			this.multi = options.multi;
			this.keyword = options.keyword;
			this.dflt = options.defaultValue;
			this.pr = options.priority || 0;
		},


		//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
		_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function (p, options, defaults) {
			if (typeof options !== "object") {
				options = { parser: defaults }; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
			}
			var a = p.split(","),
			    d = options.defaultValue,
			    i,
			    temp;
			defaults = defaults || [d];
			for (i = 0; i < a.length; i++) {
				options.prefix = i === 0 && options.prefix;
				options.defaultValue = defaults[i] || d;
				temp = new SpecialProp(a[i], options);
			}
		},


		//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
		_registerPluginProp = function (p) {
			if (!_specialProps[p]) {
				var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
				_registerComplexSpecialProp(p, { parser: function (t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log("Error: " + pluginName + " js file not loaded.");
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					} });
			}
		};

		p = SpecialProp.prototype;

		/**
   * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
   * @param {!Object} t target element
   * @param {(string|number|object)} b beginning value
   * @param {(string|number|object)} e ending (destination) value
   * @param {CSSPropTween=} pt next CSSPropTween in the linked list
   * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
   * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
   * @return {CSSPropTween=} First CSSPropTween in the linked list
   */
		p.parseComplex = function (t, b, e, pt, plugin, setRatio) {
			var kwd = this.keyword,
			    i,
			    ba,
			    ea,
			    l,
			    bi,
			    ei;
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
				ba = b.replace(_commasOutsideParenExp, "|").split("|");
				ea = e.replace(_commasOutsideParenExp, "|").split("|");
			} else if (kwd) {
				ba = [b];
				ea = [e];
			}
			if (ea) {
				l = ea.length > ba.length ? ea.length : ba.length;
				for (i = 0; i < l; i++) {
					b = ba[i] = ba[i] || this.dflt;
					e = ea[i] = ea[i] || this.dflt;
					if (kwd) {
						bi = b.indexOf(kwd);
						ei = e.indexOf(kwd);
						if (bi !== ei) {
							if (ei === -1) {
								//if the keyword isn't in the end value, remove it from the beginning one.
								ba[i] = ba[i].split(kwd).join("");
							} else if (bi === -1) {
								//if the keyword isn't in the beginning, add it.
								ba[i] += " " + kwd;
							}
						}
					}
				}
				b = ba.join(", ");
				e = ea.join(", ");
			}
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
		};

		/**
   * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
   * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
   * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
   * @param {!Object} t Target object whose property is being tweened
   * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
   * @param {!string} p Property name
   * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
   * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
   * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
   * @param {Object=} vars Original vars object that contains the data for parsing.
   * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
   */
		p.parse = function (t, e, p, cssp, pt, plugin, vars) {
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};

		/**
   * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
   *  1) Target object whose property should be tweened (typically a DOM element)
   *  2) The end/destination value (could be a string, number, object, or whatever you want)
   *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
   *
   * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
   *
   * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
   *      var start = target.style.width;
   *      return function(ratio) {
   *              target.style.width = (start + value * ratio) + "px";
   *              console.log("set width to " + target.style.width);
   *          }
   * }, 0);
   *
   * Then, when I do this tween, it will trigger my special property:
   *
   * TweenLite.to(element, 1, {css:{myCustomProp:100}});
   *
   * In the example, of course, we're just changing the width, but you can do anything you want.
   *
   * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
   * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
   * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
   */
		CSSPlugin.registerSpecialProp = function (name, onInitTween, priority) {
			_registerComplexSpecialProp(name, { parser: function (t, e, p, cssp, pt, plugin, vars) {
					var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
					rv.plugin = plugin;
					rv.setRatio = onInitTween(t, e, cssp._tween, p);
					return rv;
				}, priority: priority });
		};

		//transform-related methods and properties
		CSSPlugin.useSVGTransformAttr = _isSafari || _isFirefox; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).
		var _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
		    _transformProp = _checkPropPrefix("transform"),
		    //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
		_transformPropCSS = _prefixCSS + "transform",
		    _transformOriginProp = _checkPropPrefix("transformOrigin"),
		    _supports3D = _checkPropPrefix("perspective") !== null,
		    Transform = _internals.Transform = function () {
			this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
			this.force3D = CSSPlugin.defaultForce3D === false || !_supports3D ? false : CSSPlugin.defaultForce3D || "auto";
		},
		    _SVGElement = window.SVGElement,
		    _useSVGTransformAttr,

		//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

		_createSVG = function (type, container, attributes) {
			var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
			    reg = /([a-z])([A-Z])/g,
			    p;
			for (p in attributes) {
				element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
			}
			container.appendChild(element);
			return element;
		},
		    _docElement = _doc.documentElement,
		    _forceSVGTransformAttr = function () {
			//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
			var force = _ieVers || /Android/i.test(_agent) && !window.chrome,
			    svg,
			    rect,
			    width;
			if (_doc.createElementNS && !force) {
				//IE8 and earlier doesn't support SVG anyway
				svg = _createSVG("svg", _docElement);
				rect = _createSVG("rect", svg, { width: 100, height: 50, x: 100 });
				width = rect.getBoundingClientRect().width;
				rect.style[_transformOriginProp] = "50% 50%";
				rect.style[_transformProp] = "scaleX(0.5)";
				force = width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
				_docElement.removeChild(svg);
			}
			return force;
		}(),
		    _parseSVGOrigin = function (e, local, decoratee, absolute, smoothOrigin, skipRecord) {
			var tm = e._gsTransform,
			    m = _getMatrix(e, true),
			    v,
			    x,
			    y,
			    xOrigin,
			    yOrigin,
			    a,
			    b,
			    c,
			    d,
			    tx,
			    ty,
			    determinant,
			    xOriginOld,
			    yOriginOld;
			if (tm) {
				xOriginOld = tm.xOrigin; //record the original values before we alter them.
				yOriginOld = tm.yOrigin;
			}
			if (!absolute || (v = absolute.split(" ")).length < 2) {
				b = e.getBBox();
				local = _parsePosition(local).split(" ");
				v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x, (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
			}
			decoratee.xOrigin = xOrigin = parseFloat(v[0]);
			decoratee.yOrigin = yOrigin = parseFloat(v[1]);
			if (absolute && m !== _identity2DMatrix) {
				//if svgOrigin is being set, we must invert the matrix and determine where the absolute point is, factoring in the current transforms. Otherwise, the svgOrigin would be based on the element's non-transformed position on the canvas.
				a = m[0];
				b = m[1];
				c = m[2];
				d = m[3];
				tx = m[4];
				ty = m[5];
				determinant = a * d - b * c;
				x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
				y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
				xOrigin = decoratee.xOrigin = v[0] = x;
				yOrigin = decoratee.yOrigin = v[1] = y;
			}
			if (tm) {
				//avoid jump when transformOrigin is changed - adjust the x/y values accordingly
				if (skipRecord) {
					decoratee.xOffset = tm.xOffset;
					decoratee.yOffset = tm.yOffset;
					tm = decoratee;
				}
				if (smoothOrigin || smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false) {
					x = xOrigin - xOriginOld;
					y = yOrigin - yOriginOld;
					//originally, we simply adjusted the x and y values, but that would cause problems if, for example, you created a rotational tween part-way through an x/y tween. Managing the offset in a separate variable gives us ultimate flexibility.
					//tm.x -= x - (x * m[0] + y * m[2]);
					//tm.y -= y - (x * m[1] + y * m[3]);
					tm.xOffset += x * m[0] + y * m[2] - x;
					tm.yOffset += x * m[1] + y * m[3] - y;
				} else {
					tm.xOffset = tm.yOffset = 0;
				}
			}
			if (!skipRecord) {
				e.setAttribute("data-svg-origin", v.join(" "));
			}
		},
		    _canGetBBox = function (e) {
			try {
				return e.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
			} catch (e) {}
		},
		    _isSVG = function (e) {
			//reports if the element is an SVG on which getBBox() actually works
			return !!(_SVGElement && e.getBBox && e.getCTM && _canGetBBox(e) && (!e.parentNode || e.parentNode.getBBox && e.parentNode.getCTM));
		},
		    _identity2DMatrix = [1, 0, 0, 1, 0, 0],
		    _getMatrix = function (e, force2D) {
			var tm = e._gsTransform || new Transform(),
			    rnd = 100000,
			    isDefault,
			    s,
			    m,
			    n,
			    dec;
			if (_transformProp) {
				s = _getStyle(e, _transformPropCSS, null, true);
			} else if (e.currentStyle) {
				//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
				s = e.currentStyle.filter.match(_ieGetMatrixExp);
				s = s && s.length === 4 ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0].join(",") : "";
			}
			isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)";
			if (tm.svg || e.getBBox && _isSVG(e)) {
				if (isDefault && (e.style[_transformProp] + "").indexOf("matrix") !== -1) {
					//some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
					s = e.style[_transformProp];
					isDefault = 0;
				}
				m = e.getAttribute("transform");
				if (isDefault && m) {
					if (m.indexOf("matrix") !== -1) {
						//just in case there's a "transform" value specified as an attribute instead of CSS style. Accept either a matrix() or simple translate() value though.
						s = m;
						isDefault = 0;
					} else if (m.indexOf("translate") !== -1) {
						s = "matrix(1,0,0,1," + m.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")";
						isDefault = 0;
					}
				}
			}
			if (isDefault) {
				return _identity2DMatrix;
			}
			//split the matrix values out into an array (m for matrix)
			m = (s || "").match(_numExp) || [];
			i = m.length;
			while (--i > -1) {
				n = Number(m[i]);
				m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (dec < 0 ? -0.5 : 0.5) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
			}
			return force2D && m.length > 6 ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
		},


		/**
   * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
   * @param {!Object} t target element
   * @param {Object=} cs computed style object (optional)
   * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
   * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
   * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
   */
		_getTransform = _internals.getTransform = function (t, cs, rec, parse) {
			if (t._gsTransform && rec && !parse) {
				return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
			}
			var tm = rec ? t._gsTransform || new Transform() : new Transform(),
			    invX = tm.scaleX < 0,
			    //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
			min = 0.00002,
			    rnd = 100000,
			    zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
			    defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
			    m,
			    i,
			    scaleX,
			    scaleY,
			    rotation,
			    skewX;

			tm.svg = !!(t.getBBox && _isSVG(t));
			if (tm.svg) {
				_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, _cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
				_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
			}
			m = _getMatrix(t);
			if (m !== _identity2DMatrix) {

				if (m.length === 16) {
					//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
					var a11 = m[0],
					    a21 = m[1],
					    a31 = m[2],
					    a41 = m[3],
					    a12 = m[4],
					    a22 = m[5],
					    a32 = m[6],
					    a42 = m[7],
					    a13 = m[8],
					    a23 = m[9],
					    a33 = m[10],
					    a14 = m[12],
					    a24 = m[13],
					    a34 = m[14],
					    a43 = m[11],
					    angle = Math.atan2(a32, a33),
					    t1,
					    t2,
					    t3,
					    t4,
					    cos,
					    sin;

					//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
					if (tm.zOrigin) {
						a34 = -tm.zOrigin;
						a14 = a13 * a34 - m[12];
						a24 = a23 * a34 - m[13];
						a34 = a33 * a34 + tm.zOrigin - m[14];
					}
					tm.rotationX = angle * _RAD2DEG;
					//rotationX
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						t1 = a12 * cos + a13 * sin;
						t2 = a22 * cos + a23 * sin;
						t3 = a32 * cos + a33 * sin;
						a13 = a12 * -sin + a13 * cos;
						a23 = a22 * -sin + a23 * cos;
						a33 = a32 * -sin + a33 * cos;
						a43 = a42 * -sin + a43 * cos;
						a12 = t1;
						a22 = t2;
						a32 = t3;
					}
					//rotationY
					angle = Math.atan2(-a31, a33);
					tm.rotationY = angle * _RAD2DEG;
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						t1 = a11 * cos - a13 * sin;
						t2 = a21 * cos - a23 * sin;
						t3 = a31 * cos - a33 * sin;
						a23 = a21 * sin + a23 * cos;
						a33 = a31 * sin + a33 * cos;
						a43 = a41 * sin + a43 * cos;
						a11 = t1;
						a21 = t2;
						a31 = t3;
					}
					//rotationZ
					angle = Math.atan2(a21, a11);
					tm.rotation = angle * _RAD2DEG;
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						a11 = a11 * cos + a12 * sin;
						t2 = a21 * cos + a22 * sin;
						a22 = a21 * -sin + a22 * cos;
						a32 = a31 * -sin + a32 * cos;
						a21 = t2;
					}

					if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) {
						//when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
						tm.rotationX = tm.rotation = 0;
						tm.rotationY = 180 - tm.rotationY;
					}

					tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5 | 0) / rnd;
					tm.scaleY = (Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5 | 0) / rnd;
					tm.scaleZ = (Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5 | 0) / rnd;
					tm.skewX = a12 || a22 ? Math.atan2(a12, a22) * _RAD2DEG + tm.rotation : tm.skewX || 0;
					if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
						if (invX) {
							tm.scaleX *= -1;
							tm.skewX += tm.rotation <= 0 ? 180 : -180;
							tm.rotation += tm.rotation <= 0 ? 180 : -180;
						} else {
							tm.scaleY *= -1;
							tm.skewX += tm.skewX <= 0 ? 180 : -180;
						}
					}
					tm.perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
					tm.x = a14;
					tm.y = a24;
					tm.z = a34;
					if (tm.svg) {
						tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
						tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
					}
				} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || !tm.rotationX && !tm.rotationY) && !(tm.x !== undefined && _getStyle(t, "display", cs) === "none")) {
					//sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
					var k = m.length >= 6,
					    a = k ? m[0] : 1,
					    b = m[1] || 0,
					    c = m[2] || 0,
					    d = k ? m[3] : 1;
					tm.x = m[4] || 0;
					tm.y = m[5] || 0;
					scaleX = Math.sqrt(a * a + b * b);
					scaleY = Math.sqrt(d * d + c * c);
					rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
					skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
					if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
						if (invX) {
							scaleX *= -1;
							skewX += rotation <= 0 ? 180 : -180;
							rotation += rotation <= 0 ? 180 : -180;
						} else {
							scaleY *= -1;
							skewX += skewX <= 0 ? 180 : -180;
						}
					}
					tm.scaleX = scaleX;
					tm.scaleY = scaleY;
					tm.rotation = rotation;
					tm.skewX = skewX;
					if (_supports3D) {
						tm.rotationX = tm.rotationY = tm.z = 0;
						tm.perspective = defaultTransformPerspective;
						tm.scaleZ = 1;
					}
					if (tm.svg) {
						tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
						tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
					}
				}
				tm.zOrigin = zOrigin;
				//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
				for (i in tm) {
					if (tm[i] < min) if (tm[i] > -min) {
						tm[i] = 0;
					}
				}
			}
			//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);
			if (rec) {
				t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
				if (tm.svg) {
					//if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
					if (_useSVGTransformAttr && t.style[_transformProp]) {
						TweenLite.delayedCall(0.001, function () {
							//if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
							_removeProp(t.style, _transformProp);
						});
					} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
						TweenLite.delayedCall(0.001, function () {
							t.removeAttribute("transform");
						});
					}
				}
			}
			return tm;
		},


		//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
		_setIETransformRatio = function (v) {
			var t = this.data,
			    //refers to the element's _gsTransform object
			ang = -t.rotation * _DEG2RAD,
			    skew = ang + t.skewX * _DEG2RAD,
			    rnd = 100000,
			    a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd,
			    b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd,
			    c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd,
			    d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd,
			    style = this.t.style,
			    cs = this.t.currentStyle,
			    filters,
			    val;
			if (!cs) {
				return;
			}
			val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
			b = -c;
			c = -val;
			filters = cs.filter;
			style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
			var w = this.t.offsetWidth,
			    h = this.t.offsetHeight,
			    clip = cs.position !== "absolute",
			    m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
			    ox = t.x + w * t.xPercent / 100,
			    oy = t.y + h * t.yPercent / 100,
			    dx,
			    dy;

			//if transformOrigin is being used, adjust the offset x and y
			if (t.ox != null) {
				dx = (t.oxp ? w * t.ox * 0.01 : t.ox) - w / 2;
				dy = (t.oyp ? h * t.oy * 0.01 : t.oy) - h / 2;
				ox += dx - (dx * a + dy * b);
				oy += dy - (dx * c + dy * d);
			}

			if (!clip) {
				m += ", sizingMethod='auto expand')";
			} else {
				dx = w / 2;
				dy = h / 2;
				//translate to ensure that transformations occur around the correct origin (default is center).
				m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
			}
			if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
				style.filter = filters.replace(_ieSetMatrixExp, m);
			} else {
				style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
			}

			//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
			if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
				style.removeAttribute("filter");
			}

			//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
			if (!clip) {
				var mult = _ieVers < 8 ? 1 : -1,
				    //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
				marg,
				    prop,
				    dif;
				dx = t.ieOffsetX || 0;
				dy = t.ieOffsetY || 0;
				t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
				t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
				for (i = 0; i < 4; i++) {
					prop = _margins[i];
					marg = cs[prop];
					//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
					val = marg.indexOf("px") !== -1 ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
					if (val !== t[prop]) {
						dif = i < 2 ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
					} else {
						dif = i < 2 ? dx - t.ieOffsetX : dy - t.ieOffsetY;
					}
					style[prop] = (t[prop] = Math.round(val - dif * (i === 0 || i === 2 ? 1 : mult))) + "px";
				}
			}
		},


		/* translates a super small decimal to a string WITHOUT scientific notation
  _safeDecimal = function(n) {
  	var s = (n < 0 ? -n : n) + "",
  		a = s.split("e-");
  	return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
  },
  */

		_setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function (v) {
			var t = this.data,
			    //refers to the element's _gsTransform object
			style = this.t.style,
			    angle = t.rotation,
			    rotationX = t.rotationX,
			    rotationY = t.rotationY,
			    sx = t.scaleX,
			    sy = t.scaleY,
			    sz = t.scaleZ,
			    x = t.x,
			    y = t.y,
			    z = t.z,
			    isSVG = t.svg,
			    perspective = t.perspective,
			    force3D = t.force3D,
			    a11,
			    a12,
			    a13,
			    a21,
			    a22,
			    a23,
			    a31,
			    a32,
			    a33,
			    a41,
			    a42,
			    a43,
			    zOrigin,
			    min,
			    cos,
			    sin,
			    t1,
			    t2,
			    transform,
			    comma,
			    zero,
			    skew,
			    rnd;
			//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
			if (((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1 || _useSVGTransformAttr && isSVG || !_supports3D) {
				//on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.

				//2D
				if (angle || t.skewX || isSVG) {
					angle *= _DEG2RAD;
					skew = t.skewX * _DEG2RAD;
					rnd = 100000;
					a11 = Math.cos(angle) * sx;
					a21 = Math.sin(angle) * sx;
					a12 = Math.sin(angle - skew) * -sy;
					a22 = Math.cos(angle - skew) * sy;
					if (skew && t.skewType === "simple") {
						//by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
						t1 = Math.tan(skew);
						t1 = Math.sqrt(1 + t1 * t1);
						a12 *= t1;
						a22 *= t1;
						if (t.skewY) {
							a11 *= t1;
							a21 *= t1;
						}
					}
					if (isSVG) {
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
						if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) {
							//The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
							min = this.t.getBBox();
							x += t.xPercent * 0.01 * min.width;
							y += t.yPercent * 0.01 * min.height;
						}
						min = 0.000001;
						if (x < min) if (x > -min) {
							x = 0;
						}
						if (y < min) if (y > -min) {
							y = 0;
						}
					}
					transform = (a11 * rnd | 0) / rnd + "," + (a21 * rnd | 0) / rnd + "," + (a12 * rnd | 0) / rnd + "," + (a22 * rnd | 0) / rnd + "," + x + "," + y + ")";
					if (isSVG && _useSVGTransformAttr) {
						this.t.setAttribute("transform", "matrix(" + transform);
					} else {
						//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
						style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
					}
				} else {
					style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
				}
				return;
			}
			if (_isFirefox) {
				//Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
				min = 0.0001;
				if (sx < min && sx > -min) {
					sx = sz = 0.00002;
				}
				if (sy < min && sy > -min) {
					sy = sz = 0.00002;
				}
				if (perspective && !t.z && !t.rotationX && !t.rotationY) {
					//Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
					perspective = 0;
				}
			}
			if (angle || t.skewX) {
				angle *= _DEG2RAD;
				cos = a11 = Math.cos(angle);
				sin = a21 = Math.sin(angle);
				if (t.skewX) {
					angle -= t.skewX * _DEG2RAD;
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					if (t.skewType === "simple") {
						//by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
						t1 = Math.tan(t.skewX * _DEG2RAD);
						t1 = Math.sqrt(1 + t1 * t1);
						cos *= t1;
						sin *= t1;
						if (t.skewY) {
							a11 *= t1;
							a21 *= t1;
						}
					}
				}
				a12 = -sin;
				a22 = cos;
			} else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) {
				//if we're only translating and/or 2D scaling, this is faster...
				style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + (sx !== 1 || sy !== 1 ? " scale(" + sx + "," + sy + ")" : "");
				return;
			} else {
				a11 = a22 = 1;
				a12 = a21 = 0;
			}
			// KEY  INDEX   AFFECTS
			// a11  0       rotation, rotationY, scaleX
			// a21  1       rotation, rotationY, scaleX
			// a31  2       rotationY, scaleX
			// a41  3       rotationY, scaleX
			// a12  4       rotation, skewX, rotationX, scaleY
			// a22  5       rotation, skewX, rotationX, scaleY
			// a32  6       rotationX, scaleY
			// a42  7       rotationX, scaleY
			// a13  8       rotationY, rotationX, scaleZ
			// a23  9       rotationY, rotationX, scaleZ
			// a33  10      rotationY, rotationX, scaleZ
			// a43  11      rotationY, rotationX, perspective, scaleZ
			// a14  12      x, zOrigin, svgOrigin
			// a24  13      y, zOrigin, svgOrigin
			// a34  14      z, zOrigin
			// a44  15
			// rotation: Math.atan2(a21, a11)
			// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
			// rotationX: Math.atan2(a32, a33)
			a33 = 1;
			a13 = a23 = a31 = a32 = a41 = a42 = 0;
			a43 = perspective ? -1 / perspective : 0;
			zOrigin = t.zOrigin;
			min = 0.000001; //threshold below which browsers use scientific notation which won't work.
			comma = ",";
			zero = "0";
			angle = rotationY * _DEG2RAD;
			if (angle) {
				cos = Math.cos(angle);
				sin = Math.sin(angle);
				a31 = -sin;
				a41 = a43 * -sin;
				a13 = a11 * sin;
				a23 = a21 * sin;
				a33 = cos;
				a43 *= cos;
				a11 *= cos;
				a21 *= cos;
			}
			angle = rotationX * _DEG2RAD;
			if (angle) {
				cos = Math.cos(angle);
				sin = Math.sin(angle);
				t1 = a12 * cos + a13 * sin;
				t2 = a22 * cos + a23 * sin;
				a32 = a33 * sin;
				a42 = a43 * sin;
				a13 = a12 * -sin + a13 * cos;
				a23 = a22 * -sin + a23 * cos;
				a33 = a33 * cos;
				a43 = a43 * cos;
				a12 = t1;
				a22 = t2;
			}
			if (sz !== 1) {
				a13 *= sz;
				a23 *= sz;
				a33 *= sz;
				a43 *= sz;
			}
			if (sy !== 1) {
				a12 *= sy;
				a22 *= sy;
				a32 *= sy;
				a42 *= sy;
			}
			if (sx !== 1) {
				a11 *= sx;
				a21 *= sx;
				a31 *= sx;
				a41 *= sx;
			}

			if (zOrigin || isSVG) {
				if (zOrigin) {
					x += a13 * -zOrigin;
					y += a23 * -zOrigin;
					z += a33 * -zOrigin + zOrigin;
				}
				if (isSVG) {
					//due to bugs in some browsers, we need to manage the transform-origin of SVG manually
					x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
					y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
				}
				if (x < min && x > -min) {
					x = zero;
				}
				if (y < min && y > -min) {
					y = zero;
				}
				if (z < min && z > -min) {
					z = 0; //don't use string because we calculate perspective later and need the number.
				}
			}

			//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
			transform = t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(";
			transform += (a11 < min && a11 > -min ? zero : a11) + comma + (a21 < min && a21 > -min ? zero : a21) + comma + (a31 < min && a31 > -min ? zero : a31);
			transform += comma + (a41 < min && a41 > -min ? zero : a41) + comma + (a12 < min && a12 > -min ? zero : a12) + comma + (a22 < min && a22 > -min ? zero : a22);
			if (rotationX || rotationY || sz !== 1) {
				//performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
				transform += comma + (a32 < min && a32 > -min ? zero : a32) + comma + (a42 < min && a42 > -min ? zero : a42) + comma + (a13 < min && a13 > -min ? zero : a13);
				transform += comma + (a23 < min && a23 > -min ? zero : a23) + comma + (a33 < min && a33 > -min ? zero : a33) + comma + (a43 < min && a43 > -min ? zero : a43) + comma;
			} else {
				transform += ",0,0,0,0,1,0,";
			}
			transform += x + comma + y + comma + z + comma + (perspective ? 1 + -z / perspective : 1) + ")";

			style[_transformProp] = transform;
		};

		p = Transform.prototype;
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;

		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", { parser: function (t, e, p, cssp, pt, plugin, vars) {
				if (cssp._lastParsedTransform === vars) {
					return pt;
				} //only need to parse the transform once, and only if the browser supports it.
				cssp._lastParsedTransform = vars;
				var originalGSTransform = t._gsTransform,
				    style = t.style,
				    min = 0.000001,
				    i = _transformProps.length,
				    v = vars,
				    endRotations = {},
				    transformOriginString = "transformOrigin",
				    m1,
				    m2,
				    copy,
				    orig,
				    has3D,
				    hasChange,
				    dr,
				    x,
				    y,
				    matrix;
				if (vars.display) {
					//if the user is setting display during this tween, it may not be instantiated yet but we must force it here in order to get accurate readings. If display is "none", some browsers refuse to report the transform properties correctly.
					copy = _getStyle(t, "display");
					style.display = "block";
					m1 = _getTransform(t, _cs, true, vars.parseTransform);
					style.display = copy;
				} else {
					m1 = _getTransform(t, _cs, true, vars.parseTransform);
				}
				cssp._transform = m1;
				if (typeof v.transform === "string" && _transformProp) {
					//for values like transform:"rotate(60deg) scale(0.5, 0.8)"
					copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
					copy[_transformProp] = v.transform;
					copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
					copy.position = "absolute";
					_doc.body.appendChild(_tempDiv);
					m2 = _getTransform(_tempDiv, null, false);
					if (m1.svg) {
						//if it's an SVG element, x/y part of the matrix will be affected by whatever we use as the origin and the offsets, so compensate here...
						x = m1.xOrigin;
						y = m1.yOrigin;
						m2.x -= m1.xOffset;
						m2.y -= m1.yOffset;
						if (v.transformOrigin || v.svgOrigin) {
							//if this tween is altering the origin, we must factor that in here. The actual work of recording the transformOrigin values and setting up the PropTween is done later (still inside this function) so we cannot leave the changes intact here - we only want to update the x/y accordingly.
							orig = {};
							_parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
							x = orig.xOrigin;
							y = orig.yOrigin;
							m2.x -= orig.xOffset - m1.xOffset;
							m2.y -= orig.yOffset - m1.yOffset;
						}
						if (x || y) {
							matrix = _getMatrix(_tempDiv);
							m2.x -= x - (x * matrix[0] + y * matrix[2]);
							m2.y -= y - (x * matrix[1] + y * matrix[3]);
						}
					}
					_doc.body.removeChild(_tempDiv);
					if (!m2.perspective) {
						m2.perspective = m1.perspective; //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
					}
					if (v.xPercent != null) {
						m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
					}
					if (v.yPercent != null) {
						m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
					}
				} else if (typeof v === "object") {
					//for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
					m2 = { scaleX: _parseVal(v.scaleX != null ? v.scaleX : v.scale, m1.scaleX),
						scaleY: _parseVal(v.scaleY != null ? v.scaleY : v.scale, m1.scaleY),
						scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
						x: _parseVal(v.x, m1.x),
						y: _parseVal(v.y, m1.y),
						z: _parseVal(v.z, m1.z),
						xPercent: _parseVal(v.xPercent, m1.xPercent),
						yPercent: _parseVal(v.yPercent, m1.yPercent),
						perspective: _parseVal(v.transformPerspective, m1.perspective) };
					dr = v.directionalRotation;
					if (dr != null) {
						if (typeof dr === "object") {
							for (copy in dr) {
								v[copy] = dr[copy];
							}
						} else {
							v.rotation = dr;
						}
					}
					if (typeof v.x === "string" && v.x.indexOf("%") !== -1) {
						m2.x = 0;
						m2.xPercent = _parseVal(v.x, m1.xPercent);
					}
					if (typeof v.y === "string" && v.y.indexOf("%") !== -1) {
						m2.y = 0;
						m2.yPercent = _parseVal(v.y, m1.yPercent);
					}

					m2.rotation = _parseAngle("rotation" in v ? v.rotation : "shortRotation" in v ? v.shortRotation + "_short" : "rotationZ" in v ? v.rotationZ : m1.rotation - m1.skewY, m1.rotation - m1.skewY, "rotation", endRotations); //see notes below about skewY for why we subtract it from rotation here
					if (_supports3D) {
						m2.rotationX = _parseAngle("rotationX" in v ? v.rotationX : "shortRotationX" in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
						m2.rotationY = _parseAngle("rotationY" in v ? v.rotationY : "shortRotationY" in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
					}
					m2.skewX = _parseAngle(v.skewX, m1.skewX - m1.skewY); //see notes below about skewY and why we subtract it from skewX here

					//note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
					if (m2.skewY = _parseAngle(v.skewY, m1.skewY)) {
						m2.skewX += m2.skewY;
						m2.rotation += m2.skewY;
					}
				}
				if (_supports3D && v.force3D != null) {
					m1.force3D = v.force3D;
					hasChange = true;
				}

				m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;

				has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective;
				if (!has3D && v.scale != null) {
					m2.scaleZ = 1; //no need to tween scaleZ.
				}

				while (--i > -1) {
					p = _transformProps[i];
					orig = m2[p] - m1[p];
					if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
						hasChange = true;
						pt = new CSSPropTween(m1, p, m1[p], orig, pt);
						if (p in endRotations) {
							pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
						}
						pt.xs0 = 0; //ensures the value stays numeric in setRatio()
						pt.plugin = plugin;
						cssp._overwriteProps.push(pt.n);
					}
				}

				orig = v.transformOrigin;
				if (m1.svg && (orig || v.svgOrigin)) {
					x = m1.xOffset; //when we change the origin, in order to prevent things from jumping we adjust the x/y so we must record those here so that we can create PropTweens for them and flip them at the same time as the origin
					y = m1.yOffset;
					_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
					pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString); //note: if there wasn't a transformOrigin defined yet, just start with the destination one; it's wasteful otherwise, and it causes problems with fromTo() tweens. For example, TweenLite.to("#wheel", 3, {rotation:180, transformOrigin:"50% 50%", delay:1}); TweenLite.fromTo("#wheel", 3, {scale:0.5, transformOrigin:"50% 50%"}, {scale:1, delay:2}); would cause a jump when the from values revert at the beginning of the 2nd tween.
					pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
					if (x !== m1.xOffset || y !== m1.yOffset) {
						pt = _addNonTweeningNumericPT(m1, "xOffset", originalGSTransform ? x : m1.xOffset, m1.xOffset, pt, transformOriginString);
						pt = _addNonTweeningNumericPT(m1, "yOffset", originalGSTransform ? y : m1.yOffset, m1.yOffset, pt, transformOriginString);
					}
					orig = _useSVGTransformAttr ? null : "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
				}
				if (orig || _supports3D && has3D && m1.zOrigin) {
					//if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
					if (_transformProp) {
						hasChange = true;
						p = _transformOriginProp;
						orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
						pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
						pt.b = style[p];
						pt.plugin = plugin;
						if (_supports3D) {
							copy = m1.zOrigin;
							orig = orig.split(" ");
							m1.zOrigin = (orig.length > 2 && !(copy !== 0 && orig[2] === "0px") ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
							pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
							pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
							pt.b = copy;
							pt.xs0 = pt.e = m1.zOrigin;
						} else {
							pt.xs0 = pt.e = orig;
						}

						//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
					} else {
						_parsePosition(orig + "", m1);
					}
				}
				if (hasChange) {
					cssp._transformType = !(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3) ? 3 : 2; //quicker than calling cssp._enableTransforms();
				}
				return pt;
			}, prefix: true });

		_registerComplexSpecialProp("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: true, color: true, multi: true, keyword: "inset" });

		_registerComplexSpecialProp("borderRadius", { defaultValue: "0px", parser: function (t, e, p, cssp, pt, plugin) {
				e = this.format(e);
				var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
				    style = t.style,
				    ea1,
				    i,
				    es2,
				    bs2,
				    bs,
				    es,
				    bn,
				    en,
				    w,
				    h,
				    esfx,
				    bsfx,
				    rel,
				    hn,
				    vn,
				    em;
				w = parseFloat(t.offsetWidth);
				h = parseFloat(t.offsetHeight);
				ea1 = e.split(" ");
				for (i = 0; i < props.length; i++) {
					//if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
					if (this.p.indexOf("border")) {
						//older browsers used a prefix
						props[i] = _checkPropPrefix(props[i]);
					}
					bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
					if (bs.indexOf(" ") !== -1) {
						bs2 = bs.split(" ");
						bs = bs2[0];
						bs2 = bs2[1];
					}
					es = es2 = ea1[i];
					bn = parseFloat(bs);
					bsfx = bs.substr((bn + "").length);
					rel = es.charAt(1) === "=";
					if (rel) {
						en = parseInt(es.charAt(0) + "1", 10);
						es = es.substr(2);
						en *= parseFloat(es);
						esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
					} else {
						en = parseFloat(es);
						esfx = es.substr((en + "").length);
					}
					if (esfx === "") {
						esfx = _suffixMap[p] || bsfx;
					}
					if (esfx !== bsfx) {
						hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
						vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
						if (esfx === "%") {
							bs = hn / w * 100 + "%";
							bs2 = vn / h * 100 + "%";
						} else if (esfx === "em") {
							em = _convertToPixels(t, "borderLeft", 1, "em");
							bs = hn / em + "em";
							bs2 = vn / em + "em";
						} else {
							bs = hn + "px";
							bs2 = vn + "px";
						}
						if (rel) {
							es = parseFloat(bs) + en + esfx;
							es2 = parseFloat(bs2) + en + esfx;
						}
					}
					pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
				}
				return pt;
			}, prefix: true, formatter: _getFormatter("0px 0px 0px 0px", false, true) });
		_registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", { defaultValue: "0px", parser: function (t, e, p, cssp, pt, plugin) {
				return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
			}, prefix: true, formatter: _getFormatter("0px 0px", false, true) });
		_registerComplexSpecialProp("backgroundPosition", { defaultValue: "0 0", parser: function (t, e, p, cssp, pt, plugin) {
				var bp = "background-position",
				    cs = _cs || _getComputedStyle(t, null),
				    bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
				    //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),
				    ba,
				    ea,
				    i,
				    pct,
				    overlap,
				    src;
				if (bs.indexOf("%") !== -1 !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
					src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
					if (src && src !== "none") {
						ba = bs.split(" ");
						ea = es.split(" ");
						_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
						i = 2;
						while (--i > -1) {
							bs = ba[i];
							pct = bs.indexOf("%") !== -1;
							if (pct !== (ea[i].indexOf("%") !== -1)) {
								overlap = i === 0 ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
								ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%";
							}
						}
						bs = ba.join(" ");
					}
				}
				return this.parseComplex(t.style, bs, es, pt, plugin);
			}, formatter: _parsePosition });
		_registerComplexSpecialProp("backgroundSize", { defaultValue: "0 0", formatter: _parsePosition });
		_registerComplexSpecialProp("perspective", { defaultValue: "0px", prefix: true });
		_registerComplexSpecialProp("perspectiveOrigin", { defaultValue: "50% 50%", prefix: true });
		_registerComplexSpecialProp("transformStyle", { prefix: true });
		_registerComplexSpecialProp("backfaceVisibility", { prefix: true });
		_registerComplexSpecialProp("userSelect", { prefix: true });
		_registerComplexSpecialProp("margin", { parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft") });
		_registerComplexSpecialProp("padding", { parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft") });
		_registerComplexSpecialProp("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function (t, e, p, cssp, pt, plugin) {
				var b, cs, delim;
				if (_ieVers < 9) {
					//IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
					cs = t.currentStyle;
					delim = _ieVers < 8 ? " " : ",";
					b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
					e = this.format(e).split(",").join(delim);
				} else {
					b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
					e = this.format(e);
				}
				return this.parseComplex(t.style, b, e, pt, plugin);
			} });
		_registerComplexSpecialProp("textShadow", { defaultValue: "0px 0px 0px #999", color: true, multi: true });
		_registerComplexSpecialProp("autoRound,strictUnits", { parser: function (t, e, p, cssp, pt) {
				return pt;
			} }); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", { defaultValue: "0px solid #000", parser: function (t, e, p, cssp, pt, plugin) {
				return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, false, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), this.format(e), pt, plugin);
			}, color: true, formatter: function (v) {
				var a = v.split(" ");
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
			} });
		_registerComplexSpecialProp("borderWidth", { parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", { parser: function (t, e, p, cssp, pt, plugin) {
				var s = t.style,
				    prop = "cssFloat" in s ? "cssFloat" : "styleFloat";
				return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
			} });

		//opacity-related
		var _setIEOpacityRatio = function (v) {
			var t = this.t,
			    //refers to the element's style property
			filters = t.filter || _getStyle(this.data, "filter") || "",
			    val = this.s + this.c * v | 0,
			    skip;
			if (val === 100) {
				//for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
				if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
					t.removeAttribute("filter");
					skip = !_getStyle(this.data, "filter"); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
				} else {
					t.filter = filters.replace(_alphaFilterExp, "");
					skip = true;
				}
			}
			if (!skip) {
				if (this.xn1) {
					t.filter = filters = filters || "alpha(opacity=" + val + ")"; //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
				}
				if (filters.indexOf("pacity") === -1) {
					//only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
					if (val !== 0 || !this.xn1) {
						//bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
						t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
					}
				} else {
					t.filter = filters.replace(_opacityExp, "opacity=" + val);
				}
			}
		};
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function (t, e, p, cssp, pt, plugin) {
				var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
				    style = t.style,
				    isAutoAlpha = p === "autoAlpha";
				if (typeof e === "string" && e.charAt(1) === "=") {
					e = (e.charAt(0) === "-" ? -1 : 1) * parseFloat(e.substr(2)) + b;
				}
				if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) {
					//if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
					b = 0;
				}
				if (_supportsOpacity) {
					pt = new CSSPropTween(style, "opacity", b, e - b, pt);
				} else {
					pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
					pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
					style.zoom = 1; //helps correct an IE issue.
					pt.type = 2;
					pt.b = "alpha(opacity=" + pt.s + ")";
					pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
					pt.data = t;
					pt.plugin = plugin;
					pt.setRatio = _setIEOpacityRatio;
				}
				if (isAutoAlpha) {
					//we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
					pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, b !== 0 ? "inherit" : "hidden", e === 0 ? "hidden" : "inherit");
					pt.xs0 = "inherit";
					cssp._overwriteProps.push(pt.n);
					cssp._overwriteProps.push(p);
				}
				return pt;
			} });

		var _removeProp = function (s, p) {
			if (p) {
				if (s.removeProperty) {
					if (p.substr(0, 2) === "ms" || p.substr(0, 6) === "webkit") {
						//Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
						p = "-" + p;
					}
					s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
				} else {
					//note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
					s.removeAttribute(p);
				}
			}
		},
		    _setClassNameRatio = function (v) {
			this.t._gsClassPT = this;
			if (v === 1 || v === 0) {
				this.t.setAttribute("class", v === 0 ? this.b : this.e);
				var mpt = this.data,
				    //first MiniPropTween
				s = this.t.style;
				while (mpt) {
					if (!mpt.v) {
						_removeProp(s, mpt.p);
					} else {
						s[mpt.p] = mpt.v;
					}
					mpt = mpt._next;
				}
				if (v === 1 && this.t._gsClassPT === this) {
					this.t._gsClassPT = null;
				}
			} else if (this.t.getAttribute("class") !== this.e) {
				this.t.setAttribute("class", this.e);
			}
		};
		_registerComplexSpecialProp("className", { parser: function (t, e, p, cssp, pt, plugin, vars) {
				var b = t.getAttribute("class") || "",
				    //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,
				    difData,
				    bs,
				    cnpt,
				    cnptLookup,
				    mpt;
				pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
				pt.setRatio = _setClassNameRatio;
				pt.pr = -11;
				_hasPriority = true;
				pt.b = b;
				bs = _getAllStyles(t, _cs);
				//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
				cnpt = t._gsClassPT;
				if (cnpt) {
					cnptLookup = {};
					mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
					while (mpt) {
						cnptLookup[mpt.p] = 1;
						mpt = mpt._next;
					}
					cnpt.setRatio(1);
				}
				t._gsClassPT = pt;
				pt.e = e.charAt(1) !== "=" ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + (e.charAt(0) === "+" ? " " + e.substr(2) : "");
				t.setAttribute("class", pt.e);
				difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
				t.setAttribute("class", b);
				pt.data = difData.firstMPT;
				t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
				pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
				return pt;
			} });

		var _setClearPropsRatio = function (v) {
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
				//this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,
				    transformParse = _specialProps.transform.parse,
				    a,
				    p,
				    i,
				    clearTransform,
				    transform;
				if (this.e === "all") {
					s.cssText = "";
					clearTransform = true;
				} else {
					a = this.e.split(" ").join("").split(",");
					i = a.length;
					while (--i > -1) {
						p = a[i];
						if (_specialProps[p]) {
							if (_specialProps[p].parse === transformParse) {
								clearTransform = true;
							} else {
								p = p === "transformOrigin" ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}
						}
						_removeProp(s, p);
					}
				}
				if (clearTransform) {
					_removeProp(s, _transformProp);
					transform = this.t._gsTransform;
					if (transform) {
						if (transform.svg) {
							this.t.removeAttribute("data-svg-origin");
							this.t.removeAttribute("transform");
						}
						delete this.t._gsTransform;
					}
				}
			}
		};
		_registerComplexSpecialProp("clearProps", { parser: function (t, e, p, cssp, pt) {
				pt = new CSSPropTween(t, p, 0, 0, pt, 2);
				pt.setRatio = _setClearPropsRatio;
				pt.e = e;
				pt.pr = -10;
				pt.data = cssp._tween;
				_hasPriority = true;
				return pt;
			} });

		p = "bezier,throwProps,physicsProps,physics2D".split(",");
		i = p.length;
		while (i--) {
			_registerPluginProp(p[i]);
		}

		p = CSSPlugin.prototype;
		p._firstPT = p._lastParsedTransform = p._transform = null;

		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
		p._onInitTween = function (target, vars, tween) {
			if (!target.nodeType) {
				//css is only for dom elements
				return false;
			}
			this._target = target;
			this._tween = tween;
			this._vars = vars;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, "");
			_overwriteProps = this._overwriteProps;
			var style = target.style,
			    v,
			    pt,
			    pt2,
			    first,
			    last,
			    next,
			    zIndex,
			    tpt,
			    threeD;
			if (_reqSafariFix) if (style.zIndex === "") {
				v = _getStyle(target, "zIndex", _cs);
				if (v === "auto" || v === "") {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);
				}
			}

			if (typeof vars === "string") {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + ";" + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity && _opacityValExp.test(vars)) {
					v.opacity = parseFloat(RegExp.$1);
				}
				vars = v;
				style.cssText = first;
			}

			if (vars.className) {
				//className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
				this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
			} else {
				this._firstPT = pt = this.parse(target, vars, null);
			}

			if (this._transformType) {
				threeD = this._transformType === 3;
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
					_reqSafariFix = true;
					//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
					if (style.zIndex === "") {
						zIndex = _getStyle(target, "zIndex", _cs);
						if (zIndex === "auto" || zIndex === "") {
							this._addLazySet(style, "zIndex", 0);
						}
					}
					//Setting WebkitBackfaceVisibility corrects 3 bugs:
					// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {
						this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
					}
				}
				pt2 = pt;
				while (pt2 && pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}

			if (_hasPriority) {
				//reorders the linked list in order of pr (priority)
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if (pt._prev = pt2 ? pt2._prev : last) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if (pt._next = pt2) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				this._firstPT = first;
			}
			return true;
		};

		p.parse = function (target, vars, pt, plugin) {
			var style = target.style,
			    p,
			    sp,
			    bn,
			    en,
			    bs,
			    es,
			    bsfx,
			    esfx,
			    isStr,
			    rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);
				} else {
					bs = _getStyle(target, p, _cs) + "";
					isStr = typeof es === "string";
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || isStr && _rgbhslExp.test(es)) {
						//Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")";
						}
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);
					} else if (isStr && _complexExp.test(es)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);
					} else {
						bn = parseFloat(bs);
						bsfx = bn || bn === 0 ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

						if (bs === "" || bs === "auto") {
							if (p === "width" || p === "height") {
								bn = _getDimension(target, p, _cs);
								bsfx = "px";
							} else if (p === "left" || p === "top") {
								bn = _calculateOffset(target, p, _cs);
								bsfx = "px";
							} else {
								bn = p !== "opacity" ? 0 : 1;
								bsfx = "";
							}
						}

						rel = isStr && es.charAt(1) === "=";
						if (rel) {
							en = parseInt(es.charAt(0) + "1", 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, "");
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, "") : "";
						}

						if (esfx === "") {
							esfx = p in _suffixMap ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}

						es = en || en === 0 ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.

						//if the beginning/ending suffixes don't match, normalize them...
						if (bsfx !== esfx) if (esfx !== "") if (en || en === 0) if (bn) {
							//note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === "%") {
								bn /= _convertToPixels(target, p, 100, "%") / 100;
								if (vars.strictUnits !== true) {
									//some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";
								}
							} else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
								bn /= _convertToPixels(target, p, 1, esfx);

								//otherwise convert to pixels.
							} else if (esfx !== "px") {
								en = _convertToPixels(target, p, en, esfx);
								esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
							}
							if (rel) if (en || en === 0) {
								es = en + bn + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) && (en || en === 0)) {
							//faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, _autoRound !== false && (esfx === "px" || p === "zIndex"), 0, bs, es);
							pt.xs0 = esfx;
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
							_log("invalid " + p + " tween value: " + vars[p]);
						} else {
							pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
							pt.xs0 = es === "none" && (p === "display" || p.indexOf("Style") !== -1) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
							//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
						}
					}
				}
				if (plugin) if (pt && !pt.plugin) {
					pt.plugin = plugin;
				}
			}
			return pt;
		};

		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function (v) {
			var pt = this._firstPT,
			    min = 0.000001,
			    val,
			    str,
			    i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						if (pt.r && pt.type !== -1) {
							val = Math.round(pt.s + pt.c);
							if (!pt.type) {
								pt.t[pt.p] = val + pt.xs0;
							} else if (pt.type === 1) {
								//complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
								i = pt.l;
								str = pt.xs0 + val + pt.xs1;
								for (i = 1; i < pt.l; i++) {
									str += pt["xn" + i] + pt["xs" + (i + 1)];
								}
								pt.t[pt.p] = str;
							}
						} else {
							pt.t[pt.p] = pt.e;
						}
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					} else if (val < min) if (val > -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) {
						//complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn" + i] + pt["xs" + (i + 1)];
							}
							pt.t[pt.p] = str;
						}
					} else if (pt.type === -1) {
						//non-tweening value
						pt.t[pt.p] = pt.xs0;
					} else if (pt.setRatio) {
						//custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

				//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.b;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			}
		};

		/**
   * @private
   * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
   * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
   * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
   * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
   * doesn't have any transform-related properties of its own. You can call this method as many times as you
   * want and it won't create duplicate CSSPropTweens.
   *
   * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
   */
		p._enableTransforms = function (threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = !(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3) ? 3 : 2;
		};

		var lazySet = function (v) {
			this.t[this.p] = this.e;
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};
		/** @private Gives us a way to set a value on the first render (and only the first render). **/
		p._addLazySet = function (t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		};

		/** @private **/
		p._linkCSSP = function (pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove && this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		};

		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function (lookup) {
			var copy = lookup,
			    pt,
			    p,
			    xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) {
					//copy the lookup so that we're not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className && (pt = this._classNamePT)) {
				//for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;
				if (xfirst && xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
					this._firstPT = pt._next;
				}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			return TweenPlugin.prototype._kill.call(this, copy);
		};

		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
		var _getChildStyles = function (e, props, targets) {
			var children, i, child, type;
			if (e.slice) {
				i = e.length;
				while (--i > -1) {
					_getChildStyles(e[i], props, targets);
				}
				return;
			}
			children = e.childNodes;
			i = children.length;
			while (--i > -1) {
				child = children[i];
				type = child.type;
				if (child.style) {
					props.push(_getAllStyles(child));
					if (targets) {
						targets.push(child);
					}
				}
				if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
					_getChildStyles(child, props, targets);
				}
			}
		};

		/**
   * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
   * and then compares the style properties of all the target's child elements at the tween's start and end, and
   * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
   * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
   * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
   * is because it creates entirely new tweens that may have completely different targets than the original tween,
   * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
   * and it would create other problems. For example:
   *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
   *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
   *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
   *
   * @param {Object} target object to be tweened
   * @param {number} Duration in seconds (or frames for frames-based tweens)
   * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
   * @return {Array} An array of TweenLite instances
   */
		CSSPlugin.cascadeTo = function (target, duration, vars) {
			var tween = TweenLite.to(target, duration, vars),
			    results = [tween],
			    b = [],
			    e = [],
			    targets = [],
			    _reservedProps = TweenLite._internals.reservedProps,
			    i,
			    difs,
			    p,
			    from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i > -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		};

		TweenPlugin.activate([CSSPlugin]);
		return CSSPlugin;
	}, true);

	/*
  * ----------------------------------------------------------------
  * RoundPropsPlugin
  * ----------------------------------------------------------------
  */
	(function () {

		var RoundPropsPlugin = _gsScope._gsDefine.plugin({
			propName: "roundProps",
			version: "1.5",
			priority: -1,
			API: 2,

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function (target, value, tween) {
				this._tween = tween;
				return true;
			}

		}),
		    _roundLinkedList = function (node) {
			while (node) {
				if (!node.f && !node.blob) {
					node.r = 1;
				}
				node = node._next;
			}
		},
		    p = RoundPropsPlugin.prototype;

		p._onInitAllProps = function () {
			var tween = this._tween,
			    rp = tween.vars.roundProps.join ? tween.vars.roundProps : tween.vars.roundProps.split(","),
			    i = rp.length,
			    lookup = {},
			    rpt = tween._propLookup.roundProps,
			    prop,
			    pt,
			    next;
			while (--i > -1) {
				lookup[rp[i]] = 1;
			}
			i = rp.length;
			while (--i > -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._roundProps(lookup, true);
					} else if (pt.n === prop) {
						if (pt.f === 2 && pt.t) {
							//a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
								next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = next;
							} else if (tween._firstPT === pt) {
								tween._firstPT = next;
							}
							pt._next = pt._prev = null;
							tween._propLookup[prop] = rpt;
						}
					}
					pt = next;
				}
			}
			return false;
		};

		p._add = function (target, p, s, c) {
			this._addTween(target, p, s, s + c, p, true);
			this._overwriteProps.push(p);
		};
	})();

	/*
  * ----------------------------------------------------------------
  * AttrPlugin
  * ----------------------------------------------------------------
  */

	(function () {

		_gsScope._gsDefine.plugin({
			propName: "attr",
			API: 2,
			version: "0.5.0",

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function (target, value, tween) {
				var p;
				if (typeof target.setAttribute !== "function") {
					return false;
				}
				for (p in value) {
					this._addTween(target, "setAttribute", target.getAttribute(p) + "", value[p] + "", p, false, p);
					this._overwriteProps.push(p);
				}
				return true;
			}

		});
	})();

	/*
  * ----------------------------------------------------------------
  * DirectionalRotationPlugin
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.2.1",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function (target, value, tween) {
			if (typeof value !== "object") {
				value = { rotation: value };
			}
			this.finals = {};
			var cap = value.useRadians === true ? Math.PI * 2 : 360,
			    min = 0.000001,
			    p,
			    v,
			    start,
			    end,
			    dif,
			    split;
			for (p in value) {
				if (p !== "useRadians") {
					split = (value[p] + "").split("_");
					v = split[0];
					start = parseFloat(typeof target[p] !== "function" ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]());
					end = this.finals[p] = typeof v === "string" && v.charAt(1) === "=" ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = dif < 0 ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function (ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;

	/*
  * ----------------------------------------------------------------
  * EasePack
  * ----------------------------------------------------------------
  */
	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function (Ease) {

		var w = _gsScope.GreenSockGlobals || _gsScope,
		    gs = w.com.greensock,
		    _2PI = Math.PI * 2,
		    _HALF_PI = Math.PI / 2,
		    _class = gs._class,
		    _create = function (n, f) {
			var C = _class("easing." + n, function () {}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			return C;
		},
		    _easeReg = Ease.register || function () {},
		    //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
		_wrap = function (name, EaseOut, EaseIn, EaseInOut, aliases) {
			var C = _class("easing." + name, {
				easeOut: new EaseOut(),
				easeIn: new EaseIn(),
				easeInOut: new EaseInOut()
			}, true);
			_easeReg(C, name);
			return C;
		},
		    EasePoint = function (time, value, next) {
			this.t = time;
			this.v = value;
			if (next) {
				this.next = next;
				next.prev = this;
				this.c = next.v - value;
				this.gap = next.t - time;
			}
		},


		//Back
		_createBack = function (n, f) {
			var C = _class("easing." + n, function (overshoot) {
				this._p1 = overshoot || overshoot === 0 ? overshoot : 1.70158;
				this._p2 = this._p1 * 1.525;
			}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function (overshoot) {
				return new C(overshoot);
			};
			return C;
		},
		    Back = _wrap("Back", _createBack("BackOut", function (p) {
			return (p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1;
		}), _createBack("BackIn", function (p) {
			return p * p * ((this._p1 + 1) * p - this._p1);
		}), _createBack("BackInOut", function (p) {
			return (p *= 2) < 1 ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
		})),


		//SlowMo
		SlowMo = _class("easing.SlowMo", function (linearRatio, power, yoyoMode) {
			power = power || power === 0 ? power : 0.7;
			if (linearRatio == null) {
				linearRatio = 0.7;
			} else if (linearRatio > 1) {
				linearRatio = 1;
			}
			this._p = linearRatio !== 1 ? power : 0;
			this._p1 = (1 - linearRatio) / 2;
			this._p2 = linearRatio;
			this._p3 = this._p1 + this._p2;
			this._calcEnd = yoyoMode === true;
		}, true),
		    p = SlowMo.prototype = new Ease(),
		    SteppedEase,
		    RoughEase,
		    _createElastic;

		p.constructor = SlowMo;
		p.getRatio = function (p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - (p = 1 - p / this._p1) * p : r - (p = 1 - p / this._p1) * p * p * p * r;
			} else if (p > this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + (p - r) * (p = (p - this._p3) / this._p1) * p * p * p;
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);

		p.config = SlowMo.config = function (linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};

		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function (steps) {
			steps = steps || 1;
			this._p1 = 1 / steps;
			this._p2 = steps + 1;
		}, true);
		p = SteppedEase.prototype = new Ease();
		p.constructor = SteppedEase;
		p.getRatio = function (p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return (this._p2 * p >> 0) * this._p1;
		};
		p.config = SteppedEase.config = function (steps) {
			return new SteppedEase(steps);
		};

		//RoughEase
		RoughEase = _class("easing.RoughEase", function (vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
			    a = [],
			    cnt = 0,
			    points = (vars.points || 20) | 0,
			    i = points,
			    randomize = vars.randomize !== false,
			    clamp = vars.clamp === true,
			    template = vars.template instanceof Ease ? vars.template : null,
			    strength = typeof vars.strength === "number" ? vars.strength * 0.4 : 0.4,
			    x,
			    y,
			    bump,
			    invX,
			    obj,
			    pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : 1 / points * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {
					//"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {
					//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += Math.random() * bump - bump * 0.5;
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = { x: x, y: y };
			}
			a.sort(function (a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, pnt.t !== 0 ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function (p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;
		};
		p.config = function (vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();

		//Bounce
		_wrap("Bounce", _create("BounceOut", function (p) {
			if (p < 1 / 2.75) {
				return 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
			} else if (p < 2.5 / 2.75) {
				return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
			}
			return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
		}), _create("BounceIn", function (p) {
			if ((p = 1 - p) < 1 / 2.75) {
				return 1 - 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
			} else if (p < 2.5 / 2.75) {
				return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
			}
			return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
		}), _create("BounceInOut", function (p) {
			var invert = p < 0.5;
			if (invert) {
				p = 1 - p * 2;
			} else {
				p = p * 2 - 1;
			}
			if (p < 1 / 2.75) {
				p = 7.5625 * p * p;
			} else if (p < 2 / 2.75) {
				p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
			} else if (p < 2.5 / 2.75) {
				p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
			} else {
				p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}
			return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
		}));

		//CIRC
		_wrap("Circ", _create("CircOut", function (p) {
			return Math.sqrt(1 - (p = p - 1) * p);
		}), _create("CircIn", function (p) {
			return -(Math.sqrt(1 - p * p) - 1);
		}), _create("CircInOut", function (p) {
			return (p *= 2) < 1 ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
		}));

		//Elastic
		_createElastic = function (n, f, def) {
			var C = _class("easing." + n, function (amplitude, period) {
				this._p1 = amplitude >= 1 ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
				this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
				this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
				this._p2 = _2PI / this._p2; //precalculate to optimize
			}, true),
			    p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function (amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic", _createElastic("ElasticOut", function (p) {
			return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * this._p2) + 1;
		}, 0.3), _createElastic("ElasticIn", function (p) {
			return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2));
		}, 0.3), _createElastic("ElasticInOut", function (p) {
			return (p *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2) * 0.5 + 1;
		}, 0.45));

		//Expo
		_wrap("Expo", _create("ExpoOut", function (p) {
			return 1 - Math.pow(2, -10 * p);
		}), _create("ExpoIn", function (p) {
			return Math.pow(2, 10 * (p - 1)) - 0.001;
		}), _create("ExpoInOut", function (p) {
			return (p *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
		}));

		//Sine
		_wrap("Sine", _create("SineOut", function (p) {
			return Math.sin(p * _HALF_PI);
		}), _create("SineIn", function (p) {
			return -Math.cos(p * _HALF_PI) + 1;
		}), _create("SineInOut", function (p) {
			return -0.5 * (Math.cos(Math.PI * p) - 1);
		}));

		_class("easing.EaseLookup", {
			find: function (s) {
				return Ease.map[s];
			}
		}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");

		return Back;
	}, true);
});

if (_gsScope._gsDefine) {
	_gsScope._gsQueue.pop()();
} //necessary in case TweenLite was already loaded separately.


/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function (window, moduleName) {

	"use strict";

	var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
	if (_globals.TweenLite) {
		return; //in case the core set of classes is already loaded, don't instantiate twice.
	}
	var _namespace = function (ns) {
		var a = ns.split("."),
		    p = _globals,
		    i;
		for (i = 0; i < a.length; i++) {
			p[a[i]] = p = p[a[i]] || {};
		}
		return p;
	},
	    gs = _namespace("com.greensock"),
	    _tinyNum = 0.0000000001,
	    _slice = function (a) {
		//don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
		var b = [],
		    l = a.length,
		    i;
		for (i = 0; i !== l; b.push(a[i++])) {}
		return b;
	},
	    _emptyFunc = function () {},
	    _isArray = function () {
		//works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
		var toString = Object.prototype.toString,
		    array = toString.call([]);
		return function (obj) {
			return obj != null && (obj instanceof Array || typeof obj === "object" && !!obj.push && toString.call(obj) === array);
		};
	}(),
	    a,
	    i,
	    p,
	    _ticker,
	    _tickerActive,
	    _defLookup = {},


	/**
  * @constructor
  * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
  * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
  * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
  * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
  *
  * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
  * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
  * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
  * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
  * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
  * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
  * sandbox the banner one like:
  *
  * <script>
  *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
  * </script>
  * <script src="js/greensock/v1.7/TweenMax.js"></script>
  * <script>
  *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
  * </script>
  * <script src="js/greensock/v1.6/TweenMax.js"></script>
  * <script>
  *     gs.TweenLite.to(...); //would use v1.7
  *     TweenLite.to(...); //would use v1.6
  * </script>
  *
  * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
  * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
  * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
  * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
  */
	Definition = function (ns, dependencies, func, global) {
		this.sc = _defLookup[ns] ? _defLookup[ns].sc : []; //subclasses
		_defLookup[ns] = this;
		this.gsClass = null;
		this.func = func;
		var _classes = [];
		this.check = function (init) {
			var i = dependencies.length,
			    missing = i,
			    cur,
			    a,
			    n,
			    cl,
			    hasModule;
			while (--i > -1) {
				if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
					_classes[i] = cur.gsClass;
					missing--;
				} else if (init) {
					cur.sc.push(this);
				}
			}
			if (missing === 0 && func) {
				a = ("com.greensock." + ns).split(".");
				n = a.pop();
				cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

				//exports to multiple environments
				if (global) {
					_globals[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
					hasModule = typeof module !== "undefined" && module.exports;
					if (!hasModule && typeof define === "function" && define.amd) {
						//AMD
						define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function () {
							return cl;
						});
					} else if (ns === moduleName && hasModule) {
						//node
						module.exports = cl;
					}
				}
				for (i = 0; i < this.sc.length; i++) {
					this.sc[i].check();
				}
			}
		};
		this.check(true);
	},


	//used to create Definition instances (which basically registers a class that has dependencies).
	_gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
		return new Definition(ns, dependencies, func, global);
	},


	//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
	_class = gs._class = function (ns, func, global) {
		func = func || function () {};
		_gsDefine(ns, [], function () {
			return func;
		}, global);
		return func;
	};

	_gsDefine.globals = _globals;

	/*
  * ----------------------------------------------------------------
  * Ease
  * ----------------------------------------------------------------
  */
	var _baseParams = [0, 0, 1, 1],
	    _blankArray = [],
	    Ease = _class("easing.Ease", function (func, extraParams, type, power) {
		this._func = func;
		this._type = type || 0;
		this._power = power || 0;
		this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
	}, true),
	    _easeMap = Ease.map = {},
	    _easeReg = Ease.register = function (ease, names, types, create) {
		var na = names.split(","),
		    i = na.length,
		    ta = (types || "easeIn,easeOut,easeInOut").split(","),
		    e,
		    name,
		    j,
		    type;
		while (--i > -1) {
			name = na[i];
			e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
			j = ta.length;
			while (--j > -1) {
				type = ta[j];
				_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
			}
		}
	};

	p = Ease.prototype;
	p._calcEnd = false;
	p.getRatio = function (p) {
		if (this._func) {
			this._params[0] = p;
			return this._func.apply(null, this._params);
		}
		var t = this._type,
		    pw = this._power,
		    r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;
		if (pw === 1) {
			r *= r;
		} else if (pw === 2) {
			r *= r * r;
		} else if (pw === 3) {
			r *= r * r * r;
		} else if (pw === 4) {
			r *= r * r * r * r;
		}
		return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;
	};

	//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
	a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
	i = a.length;
	while (--i > -1) {
		p = a[i] + ",Power" + i;
		_easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
		_easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));
		_easeReg(new Ease(null, null, 3, i), p, "easeInOut");
	}
	_easeMap.linear = gs.easing.Linear.easeIn;
	_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


	/*
  * ----------------------------------------------------------------
  * EventDispatcher
  * ----------------------------------------------------------------
  */
	var EventDispatcher = _class("events.EventDispatcher", function (target) {
		this._listeners = {};
		this._eventTarget = target || this;
	});
	p = EventDispatcher.prototype;

	p.addEventListener = function (type, callback, scope, useParam, priority) {
		priority = priority || 0;
		var list = this._listeners[type],
		    index = 0,
		    listener,
		    i;
		if (list == null) {
			this._listeners[type] = list = [];
		}
		i = list.length;
		while (--i > -1) {
			listener = list[i];
			if (listener.c === callback && listener.s === scope) {
				list.splice(i, 1);
			} else if (index === 0 && listener.pr < priority) {
				index = i + 1;
			}
		}
		list.splice(index, 0, { c: callback, s: scope, up: useParam, pr: priority });
		if (this === _ticker && !_tickerActive) {
			_ticker.wake();
		}
	};

	p.removeEventListener = function (type, callback) {
		var list = this._listeners[type],
		    i;
		if (list) {
			i = list.length;
			while (--i > -1) {
				if (list[i].c === callback) {
					list.splice(i, 1);
					return;
				}
			}
		}
	};

	p.dispatchEvent = function (type) {
		var list = this._listeners[type],
		    i,
		    t,
		    listener;
		if (list) {
			i = list.length;
			t = this._eventTarget;
			while (--i > -1) {
				listener = list[i];
				if (listener) {
					if (listener.up) {
						listener.c.call(listener.s || t, { type: type, target: t });
					} else {
						listener.c.call(listener.s || t);
					}
				}
			}
		}
	};

	/*
  * ----------------------------------------------------------------
  * Ticker
  * ----------------------------------------------------------------
  */
	var _reqAnimFrame = window.requestAnimationFrame,
	    _cancelAnimFrame = window.cancelAnimationFrame,
	    _getTime = Date.now || function () {
		return new Date().getTime();
	},
	    _lastUpdate = _getTime();

	//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
	a = ["ms", "moz", "webkit", "o"];
	i = a.length;
	while (--i > -1 && !_reqAnimFrame) {
		_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
		_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
	}

	_class("Ticker", function (fps, useRAF) {
		var _self = this,
		    _startTime = _getTime(),
		    _useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
		    _lagThreshold = 500,
		    _adjustedLag = 33,
		    _tickWord = "tick",
		    //helps reduce gc burden
		_fps,
		    _req,
		    _id,
		    _gap,
		    _nextTime,
		    _tick = function (manual) {
			var elapsed = _getTime() - _lastUpdate,
			    overlap,
			    dispatch;
			if (elapsed > _lagThreshold) {
				_startTime += elapsed - _adjustedLag;
			}
			_lastUpdate += elapsed;
			_self.time = (_lastUpdate - _startTime) / 1000;
			overlap = _self.time - _nextTime;
			if (!_fps || overlap > 0 || manual === true) {
				_self.frame++;
				_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
				dispatch = true;
			}
			if (manual !== true) {
				//make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
				_id = _req(_tick);
			}
			if (dispatch) {
				_self.dispatchEvent(_tickWord);
			}
		};

		EventDispatcher.call(_self);
		_self.time = _self.frame = 0;
		_self.tick = function () {
			_tick(true);
		};

		_self.lagSmoothing = function (threshold, adjustedLag) {
			_lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited
			_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
		};

		_self.sleep = function () {
			if (_id == null) {
				return;
			}
			if (!_useRAF || !_cancelAnimFrame) {
				clearTimeout(_id);
			} else {
				_cancelAnimFrame(_id);
			}
			_req = _emptyFunc;
			_id = null;
			if (_self === _ticker) {
				_tickerActive = false;
			}
		};

		_self.wake = function (seamless) {
			if (_id !== null) {
				_self.sleep();
			} else if (seamless) {
				_startTime += -_lastUpdate + (_lastUpdate = _getTime());
			} else if (_self.frame > 10) {
				//don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
				_lastUpdate = _getTime() - _lagThreshold + 5;
			}
			_req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
				return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
			} : _reqAnimFrame;
			if (_self === _ticker) {
				_tickerActive = true;
			}
			_tick(2);
		};

		_self.fps = function (value) {
			if (!arguments.length) {
				return _fps;
			}
			_fps = value;
			_gap = 1 / (_fps || 60);
			_nextTime = this.time + _gap;
			_self.wake();
		};

		_self.useRAF = function (value) {
			if (!arguments.length) {
				return _useRAF;
			}
			_self.sleep();
			_useRAF = value;
			_self.fps(_fps);
		};
		_self.fps(fps);

		//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
		setTimeout(function () {
			if (_useRAF === "auto" && _self.frame < 5 && document.visibilityState !== "hidden") {
				_self.useRAF(false);
			}
		}, 1500);
	});

	p = gs.Ticker.prototype = new gs.events.EventDispatcher();
	p.constructor = gs.Ticker;

	/*
  * ----------------------------------------------------------------
  * Animation
  * ----------------------------------------------------------------
  */
	var Animation = _class("core.Animation", function (duration, vars) {
		this.vars = vars = vars || {};
		this._duration = this._totalDuration = duration || 0;
		this._delay = Number(vars.delay) || 0;
		this._timeScale = 1;
		this._active = vars.immediateRender === true;
		this.data = vars.data;
		this._reversed = vars.reversed === true;

		if (!_rootTimeline) {
			return;
		}
		if (!_tickerActive) {
			//some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
			_ticker.wake();
		}

		var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
		tl.add(this, tl._time);

		if (this.vars.paused) {
			this.paused(true);
		}
	});

	_ticker = Animation.ticker = new gs.Ticker();
	p = Animation.prototype;
	p._dirty = p._gc = p._initted = p._paused = false;
	p._totalTime = p._time = 0;
	p._rawPrevTime = -1;
	p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
	p._paused = false;

	//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
	var _checkTimeout = function () {
		if (_tickerActive && _getTime() - _lastUpdate > 2000) {
			_ticker.wake();
		}
		setTimeout(_checkTimeout, 2000);
	};
	_checkTimeout();

	p.play = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from, suppressEvents);
		}
		return this.reversed(false).paused(false);
	};

	p.pause = function (atTime, suppressEvents) {
		if (atTime != null) {
			this.seek(atTime, suppressEvents);
		}
		return this.paused(true);
	};

	p.resume = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from, suppressEvents);
		}
		return this.paused(false);
	};

	p.seek = function (time, suppressEvents) {
		return this.totalTime(Number(time), suppressEvents !== false);
	};

	p.restart = function (includeDelay, suppressEvents) {
		return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);
	};

	p.reverse = function (from, suppressEvents) {
		if (from != null) {
			this.seek(from || this.totalDuration(), suppressEvents);
		}
		return this.reversed(true).paused(false);
	};

	p.render = function (time, suppressEvents, force) {
		//stub - we override this method in subclasses.
	};

	p.invalidate = function () {
		this._time = this._totalTime = 0;
		this._initted = this._gc = false;
		this._rawPrevTime = -1;
		if (this._gc || !this.timeline) {
			this._enabled(true);
		}
		return this;
	};

	p.isActive = function () {
		var tl = this._timeline,
		    //the 2 root timelines won't have a _timeline; they're always active.
		startTime = this._startTime,
		    rawTime;
		return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale;
	};

	p._enabled = function (enabled, ignoreTimeline) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		this._gc = !enabled;
		this._active = this.isActive();
		if (ignoreTimeline !== true) {
			if (enabled && !this.timeline) {
				this._timeline.add(this, this._startTime - this._delay);
			} else if (!enabled && this.timeline) {
				this._timeline._remove(this, true);
			}
		}
		return false;
	};

	p._kill = function (vars, target) {
		return this._enabled(false, false);
	};

	p.kill = function (vars, target) {
		this._kill(vars, target);
		return this;
	};

	p._uncache = function (includeSelf) {
		var tween = includeSelf ? this : this.timeline;
		while (tween) {
			tween._dirty = true;
			tween = tween.timeline;
		}
		return this;
	};

	p._swapSelfInParams = function (params) {
		var i = params.length,
		    copy = params.concat();
		while (--i > -1) {
			if (params[i] === "{self}") {
				copy[i] = this;
			}
		}
		return copy;
	};

	p._callback = function (type) {
		var v = this.vars;
		v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
	};

	//----Animation getters/setters --------------------------------------------------------

	p.eventCallback = function (type, callback, params, scope) {
		if ((type || "").substr(0, 2) === "on") {
			var v = this.vars;
			if (arguments.length === 1) {
				return v[type];
			}
			if (callback == null) {
				delete v[type];
			} else {
				v[type] = callback;
				v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
				v[type + "Scope"] = scope;
			}
			if (type === "onUpdate") {
				this._onUpdate = callback;
			}
		}
		return this;
	};

	p.delay = function (value) {
		if (!arguments.length) {
			return this._delay;
		}
		if (this._timeline.smoothChildTiming) {
			this.startTime(this._startTime + value - this._delay);
		}
		this._delay = value;
		return this;
	};

	p.duration = function (value) {
		if (!arguments.length) {
			this._dirty = false;
			return this._duration;
		}
		this._duration = this._totalDuration = value;
		this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
		if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
			this.totalTime(this._totalTime * (value / this._duration), true);
		}
		return this;
	};

	p.totalDuration = function (value) {
		this._dirty = false;
		return !arguments.length ? this._totalDuration : this.duration(value);
	};

	p.time = function (value, suppressEvents) {
		if (!arguments.length) {
			return this._time;
		}
		if (this._dirty) {
			this.totalDuration();
		}
		return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);
	};

	p.totalTime = function (time, suppressEvents, uncapped) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		if (!arguments.length) {
			return this._totalTime;
		}
		if (this._timeline) {
			if (time < 0 && !uncapped) {
				time += this.totalDuration();
			}
			if (this._timeline.smoothChildTiming) {
				if (this._dirty) {
					this.totalDuration();
				}
				var totalDuration = this._totalDuration,
				    tl = this._timeline;
				if (time > totalDuration && !uncapped) {
					time = totalDuration;
				}
				this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;
				if (!tl._dirty) {
					//for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
					this._uncache(false);
				}
				//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
				if (tl._timeline) {
					while (tl._timeline) {
						if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
							tl.totalTime(tl._totalTime, true);
						}
						tl = tl._timeline;
					}
				}
			}
			if (this._gc) {
				this._enabled(true, false);
			}
			if (this._totalTime !== time || this._duration === 0) {
				if (_lazyTweens.length) {
					_lazyRender();
				}
				this.render(time, suppressEvents, false);
				if (_lazyTweens.length) {
					//in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
					_lazyRender();
				}
			}
		}
		return this;
	};

	p.progress = p.totalProgress = function (value, suppressEvents) {
		var duration = this.duration();
		return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents);
	};

	p.startTime = function (value) {
		if (!arguments.length) {
			return this._startTime;
		}
		if (value !== this._startTime) {
			this._startTime = value;
			if (this.timeline) if (this.timeline._sortChildren) {
				this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
			}
		}
		return this;
	};

	p.endTime = function (includeRepeats) {
		return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale;
	};

	p.timeScale = function (value) {
		if (!arguments.length) {
			return this._timeScale;
		}
		value = value || _tinyNum; //can't allow zero because it'll throw the math off
		if (this._timeline && this._timeline.smoothChildTiming) {
			var pauseTime = this._pauseTime,
			    t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
			this._startTime = t - (t - this._startTime) * this._timeScale / value;
		}
		this._timeScale = value;
		return this._uncache(false);
	};

	p.reversed = function (value) {
		if (!arguments.length) {
			return this._reversed;
		}
		if (value != this._reversed) {
			this._reversed = value;
			this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true);
		}
		return this;
	};

	p.paused = function (value) {
		if (!arguments.length) {
			return this._paused;
		}
		var tl = this._timeline,
		    raw,
		    elapsed;
		if (value != this._paused) if (tl) {
			if (!_tickerActive && !value) {
				_ticker.wake();
			}
			raw = tl.rawTime();
			elapsed = raw - this._pauseTime;
			if (!value && tl.smoothChildTiming) {
				this._startTime += elapsed;
				this._uncache(false);
			}
			this._pauseTime = value ? raw : null;
			this._paused = value;
			this._active = this.isActive();
			if (!value && elapsed !== 0 && this._initted && this.duration()) {
				raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
				this.render(raw, raw === this._totalTime, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
			}
		}
		if (this._gc && !value) {
			this._enabled(true, false);
		}
		return this;
	};

	/*
  * ----------------------------------------------------------------
  * SimpleTimeline
  * ----------------------------------------------------------------
  */
	var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
		Animation.call(this, 0, vars);
		this.autoRemoveChildren = this.smoothChildTiming = true;
	});

	p = SimpleTimeline.prototype = new Animation();
	p.constructor = SimpleTimeline;
	p.kill()._gc = false;
	p._first = p._last = p._recent = null;
	p._sortChildren = false;

	p.add = p.insert = function (child, position, align, stagger) {
		var prevTween, st;
		child._startTime = Number(position || 0) + child._delay;
		if (child._paused) if (this !== child._timeline) {
			//we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
			child._pauseTime = child._startTime + (this.rawTime() - child._startTime) / child._timeScale;
		}
		if (child.timeline) {
			child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
		}
		child.timeline = child._timeline = this;
		if (child._gc) {
			child._enabled(true, true);
		}
		prevTween = this._last;
		if (this._sortChildren) {
			st = child._startTime;
			while (prevTween && prevTween._startTime > st) {
				prevTween = prevTween._prev;
			}
		}
		if (prevTween) {
			child._next = prevTween._next;
			prevTween._next = child;
		} else {
			child._next = this._first;
			this._first = child;
		}
		if (child._next) {
			child._next._prev = child;
		} else {
			this._last = child;
		}
		child._prev = prevTween;
		this._recent = child;
		if (this._timeline) {
			this._uncache(true);
		}
		return this;
	};

	p._remove = function (tween, skipDisable) {
		if (tween.timeline === this) {
			if (!skipDisable) {
				tween._enabled(false, true);
			}

			if (tween._prev) {
				tween._prev._next = tween._next;
			} else if (this._first === tween) {
				this._first = tween._next;
			}
			if (tween._next) {
				tween._next._prev = tween._prev;
			} else if (this._last === tween) {
				this._last = tween._prev;
			}
			tween._next = tween._prev = tween.timeline = null;
			if (tween === this._recent) {
				this._recent = this._last;
			}

			if (this._timeline) {
				this._uncache(true);
			}
		}
		return this;
	};

	p.render = function (time, suppressEvents, force) {
		var tween = this._first,
		    next;
		this._totalTime = this._time = this._rawPrevTime = time;
		while (tween) {
			next = tween._next; //record it here because the value could change after rendering...
			if (tween._active || time >= tween._startTime && !tween._paused) {
				if (!tween._reversed) {
					tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
				} else {
					tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
				}
			}
			tween = next;
		}
	};

	p.rawTime = function () {
		if (!_tickerActive) {
			_ticker.wake();
		}
		return this._totalTime;
	};

	/*
  * ----------------------------------------------------------------
  * TweenLite
  * ----------------------------------------------------------------
  */
	var TweenLite = _class("TweenLite", function (target, duration, vars) {
		Animation.call(this, duration, vars);
		this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

		if (target == null) {
			throw "Cannot tween a null target.";
		}

		this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;

		var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
		    overwrite = this.vars.overwrite,
		    i,
		    targ,
		    targets;

		this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];

		if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
			this._targets = targets = _slice(target); //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
			this._propLookup = [];
			this._siblings = [];
			for (i = 0; i < targets.length; i++) {
				targ = targets[i];
				if (!targ) {
					targets.splice(i--, 1);
					continue;
				} else if (typeof targ === "string") {
					targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
					if (typeof targ === "string") {
						targets.splice(i + 1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
					}
					continue;
				} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
					//in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
					targets.splice(i--, 1);
					this._targets = targets = targets.concat(_slice(targ));
					continue;
				}
				this._siblings[i] = _register(targ, this, false);
				if (overwrite === 1) if (this._siblings[i].length > 1) {
					_applyOverwrite(targ, this, null, 1, this._siblings[i]);
				}
			}
		} else {
			this._propLookup = {};
			this._siblings = _register(target, this, false);
			if (overwrite === 1) if (this._siblings.length > 1) {
				_applyOverwrite(target, this, null, 1, this._siblings);
			}
		}
		if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
			this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
			this.render(Math.min(0, -this._delay)); //in case delay is negative
		}
	}, true),
	    _isSelector = function (v) {
		return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
	},
	    _autoCSS = function (vars, target) {
		var css = {},
		    p;
		for (p in vars) {
			if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
				//note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
				css[p] = vars[p];
				delete vars[p];
			}
		}
		vars.css = css;
	};

	p = TweenLite.prototype = new Animation();
	p.constructor = TweenLite;
	p.kill()._gc = false;

	//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

	p.ratio = 0;
	p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
	p._notifyPluginsOfEnabled = p._lazy = false;

	TweenLite.version = "1.18.4";
	TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
	TweenLite.defaultOverwrite = "auto";
	TweenLite.ticker = _ticker;
	TweenLite.autoSleep = 120;
	TweenLite.lagSmoothing = function (threshold, adjustedLag) {
		_ticker.lagSmoothing(threshold, adjustedLag);
	};

	TweenLite.selector = window.$ || window.jQuery || function (e) {
		var selector = window.$ || window.jQuery;
		if (selector) {
			TweenLite.selector = selector;
			return selector(e);
		}
		return typeof document === "undefined" ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById(e.charAt(0) === "#" ? e.substr(1) : e);
	};

	var _lazyTweens = [],
	    _lazyLookup = {},
	    _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,

	//_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
	_setRatio = function (v) {
		var pt = this._firstPT,
		    min = 0.000001,
		    val;
		while (pt) {
			val = !pt.blob ? pt.c * v + pt.s : v ? this.join("") : this.start;
			if (pt.r) {
				val = Math.round(val);
			} else if (val < min) if (val > -min) {
				//prevents issues with converting very small numbers to strings in the browser
				val = 0;
			}
			if (!pt.f) {
				pt.t[pt.p] = val;
			} else if (pt.fp) {
				pt.t[pt.p](pt.fp, val);
			} else {
				pt.t[pt.p](val);
			}
			pt = pt._next;
		}
	},

	//compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
	_blobDif = function (start, end, filter, pt) {
		var a = [start, end],
		    charIndex = 0,
		    s = "",
		    color = 0,
		    startNums,
		    endNums,
		    num,
		    i,
		    l,
		    nonNumbers,
		    currentNum;
		a.start = start;
		if (filter) {
			filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
			start = a[0];
			end = a[1];
		}
		a.length = 0;
		startNums = start.match(_numbersExp) || [];
		endNums = end.match(_numbersExp) || [];
		if (pt) {
			pt._next = null;
			pt.blob = 1;
			a._firstPT = pt; //apply last in the linked list (which means inserting it first)
		}
		l = endNums.length;
		for (i = 0; i < l; i++) {
			currentNum = endNums[i];
			nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
			s += nonNumbers || !i ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
			charIndex += nonNumbers.length;
			if (color) {
				//sense rgba() values and round them.
				color = (color + 1) % 5;
			} else if (nonNumbers.substr(-5) === "rgba(") {
				color = 1;
			}
			if (currentNum === startNums[i] || startNums.length <= i) {
				s += currentNum;
			} else {
				if (s) {
					a.push(s);
					s = "";
				}
				num = parseFloat(startNums[i]);
				a.push(num);
				a._firstPT = { _next: a._firstPT, t: a, p: a.length - 1, s: num, c: (currentNum.charAt(1) === "=" ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0, f: 0, r: color && color < 4 };
				//note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
			}
			charIndex += currentNum.length;
		}
		s += end.substr(charIndex);
		if (s) {
			a.push(s);
		}
		a.setRatio = _setRatio;
		return a;
	},

	//note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
	_addPropTween = function (target, prop, start, end, overwriteProp, round, funcParam, stringFilter) {
		var s = start === "get" ? target[prop] : start,
		    type = typeof target[prop],
		    isRelative = typeof end === "string" && end.charAt(1) === "=",
		    pt = { t: target, p: prop, s: s, f: type === "function", pg: 0, n: overwriteProp || prop, r: round, pr: 0, c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0 },
		    blob,
		    getterName;
		if (type !== "number") {
			if (type === "function" && start === "get") {
				getterName = prop.indexOf("set") || typeof target["get" + prop.substr(3)] !== "function" ? prop : "get" + prop.substr(3);
				pt.s = s = funcParam ? target[getterName](funcParam) : target[getterName]();
			}
			if (typeof s === "string" && (funcParam || isNaN(s))) {
				//a blob (string that has multiple numbers in it)
				pt.fp = funcParam;
				blob = _blobDif(s, end, stringFilter || TweenLite.defaultStringFilter, pt);
				pt = { t: blob, p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: overwriteProp || prop, pr: 0 }; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
			} else if (!isRelative) {
				pt.s = parseFloat(s);
				pt.c = parseFloat(end) - pt.s || 0;
			}
		}
		if (pt.c) {
			//only add it to the linked list if there's a change.
			if (pt._next = this._firstPT) {
				pt._next._prev = pt;
			}
			this._firstPT = pt;
			return pt;
		}
	},
	    _internals = TweenLite._internals = { isArray: _isArray, isSelector: _isSelector, lazyTweens: _lazyTweens, blobDif: _blobDif },
	    //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
	_plugins = TweenLite._plugins = {},
	    _tweenLookup = _internals.tweenLookup = {},
	    _tweenLookupNum = 0,
	    _reservedProps = _internals.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1, onOverwrite: 1, callbackScope: 1, stringFilter: 1 },
	    _overwriteLookup = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, "true": 1, "false": 0 },
	    _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
	    _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
	    _nextGCFrame = 30,
	    _lazyRender = _internals.lazyRender = function () {
		var i = _lazyTweens.length,
		    tween;
		_lazyLookup = {};
		while (--i > -1) {
			tween = _lazyTweens[i];
			if (tween && tween._lazy !== false) {
				tween.render(tween._lazy[0], tween._lazy[1], true);
				tween._lazy = false;
			}
		}
		_lazyTweens.length = 0;
	};

	_rootTimeline._startTime = _ticker.time;
	_rootFramesTimeline._startTime = _ticker.frame;
	_rootTimeline._active = _rootFramesTimeline._active = true;
	setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

	Animation._updateRoot = TweenLite.render = function () {
		var i, a, p;
		if (_lazyTweens.length) {
			//if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
			_lazyRender();
		}
		_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
		_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
		if (_lazyTweens.length) {
			_lazyRender();
		}
		if (_ticker.frame >= _nextGCFrame) {
			//dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
			_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
			for (p in _tweenLookup) {
				a = _tweenLookup[p].tweens;
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc) {
						a.splice(i, 1);
					}
				}
				if (a.length === 0) {
					delete _tweenLookup[p];
				}
			}
			//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
			p = _rootTimeline._first;
			if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
				while (p && p._paused) {
					p = p._next;
				}
				if (!p) {
					_ticker.sleep();
				}
			}
		}
	};

	_ticker.addEventListener("tick", Animation._updateRoot);

	var _register = function (target, tween, scrub) {
		var id = target._gsTweenID,
		    a,
		    i;
		if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
			_tweenLookup[id] = { target: target, tweens: [] };
		}
		if (tween) {
			a = _tweenLookup[id].tweens;
			a[i = a.length] = tween;
			if (scrub) {
				while (--i > -1) {
					if (a[i] === tween) {
						a.splice(i, 1);
					}
				}
			}
		}
		return _tweenLookup[id].tweens;
	},
	    _onOverwrite = function (overwrittenTween, overwritingTween, target, killedProps) {
		var func = overwrittenTween.vars.onOverwrite,
		    r1,
		    r2;
		if (func) {
			r1 = func(overwrittenTween, overwritingTween, target, killedProps);
		}
		func = TweenLite.onOverwrite;
		if (func) {
			r2 = func(overwrittenTween, overwritingTween, target, killedProps);
		}
		return r1 !== false && r2 !== false;
	},
	    _applyOverwrite = function (target, tween, props, mode, siblings) {
		var i, changed, curTween, l;
		if (mode === 1 || mode >= 4) {
			l = siblings.length;
			for (i = 0; i < l; i++) {
				if ((curTween = siblings[i]) !== tween) {
					if (!curTween._gc) {
						if (curTween._kill(null, target, tween)) {
							changed = true;
						}
					}
				} else if (mode === 5) {
					break;
				}
			}
			return changed;
		}
		//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
		var startTime = tween._startTime + _tinyNum,
		    overlaps = [],
		    oCount = 0,
		    zeroDur = tween._duration === 0,
		    globalStart;
		i = siblings.length;
		while (--i > -1) {
			if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
				//ignore
			} else if (curTween._timeline !== tween._timeline) {
				globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
				if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
					overlaps[oCount++] = curTween;
				}
			} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
				overlaps[oCount++] = curTween;
			}
		}

		i = oCount;
		while (--i > -1) {
			curTween = overlaps[i];
			if (mode === 2) if (curTween._kill(props, target, tween)) {
				changed = true;
			}
			if (mode !== 2 || !curTween._firstPT && curTween._initted) {
				if (mode !== 2 && !_onOverwrite(curTween, tween)) {
					continue;
				}
				if (curTween._enabled(false, false)) {
					//if all property tweens have been overwritten, kill the tween.
					changed = true;
				}
			}
		}
		return changed;
	},
	    _checkOverlap = function (tween, reference, zeroDur) {
		var tl = tween._timeline,
		    ts = tl._timeScale,
		    t = tween._startTime;
		while (tl._timeline) {
			t += tl._startTime;
			ts *= tl._timeScale;
			if (tl._paused) {
				return -100;
			}
			tl = tl._timeline;
		}
		t /= ts;
		return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
	};

	//---- TweenLite instance methods -----------------------------------------------------------------------------

	p._init = function () {
		var v = this.vars,
		    op = this._overwrittenProps,
		    dur = this._duration,
		    immediate = !!v.immediateRender,
		    ease = v.ease,
		    i,
		    initPlugins,
		    pt,
		    p,
		    startVars;
		if (v.startAt) {
			if (this._startAt) {
				this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
				this._startAt.kill();
			}
			startVars = {};
			for (p in v.startAt) {
				//copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
				startVars[p] = v.startAt[p];
			}
			startVars.overwrite = false;
			startVars.immediateRender = true;
			startVars.lazy = immediate && v.lazy !== false;
			startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
			this._startAt = TweenLite.to(this.target, 0, startVars);
			if (immediate) {
				if (this._time > 0) {
					this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
				} else if (dur !== 0) {
					return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
				}
			}
		} else if (v.runBackwards && dur !== 0) {
			//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
			if (this._startAt) {
				this._startAt.render(-1, true);
				this._startAt.kill();
				this._startAt = null;
			} else {
				if (this._time !== 0) {
					//in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
					immediate = false;
				}
				pt = {};
				for (p in v) {
					//copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
					if (!_reservedProps[p] || p === "autoCSS") {
						pt[p] = v[p];
					}
				}
				pt.overwrite = 0;
				pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
				pt.lazy = immediate && v.lazy !== false;
				pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
				this._startAt = TweenLite.to(this.target, 0, pt);
				if (!immediate) {
					this._startAt._init(); //ensures that the initial values are recorded
					this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
					if (this.vars.immediateRender) {
						this._startAt = null;
					}
				} else if (this._time === 0) {
					return;
				}
			}
		}
		this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
		if (v.easeParams instanceof Array && ease.config) {
			this._ease = ease.config.apply(ease, v.easeParams);
		}
		this._easeType = this._ease._type;
		this._easePower = this._ease._power;
		this._firstPT = null;

		if (this._targets) {
			i = this._targets.length;
			while (--i > -1) {
				if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null)) {
					initPlugins = true;
				}
			}
		} else {
			initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
		}

		if (initPlugins) {
			TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
		}
		if (op) if (!this._firstPT) if (typeof this.target !== "function") {
			//if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
			this._enabled(false, false);
		}
		if (v.runBackwards) {
			pt = this._firstPT;
			while (pt) {
				pt.s += pt.c;
				pt.c = -pt.c;
				pt = pt._next;
			}
		}
		this._onUpdate = v.onUpdate;
		this._initted = true;
	};

	p._initProps = function (target, propLookup, siblings, overwrittenProps) {
		var p, i, initPlugins, plugin, pt, v;
		if (target == null) {
			return false;
		}

		if (_lazyLookup[target._gsTweenID]) {
			_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
		}

		if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) {
			//it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
			_autoCSS(this.vars, target);
		}
		for (p in this.vars) {
			v = this.vars[p];
			if (_reservedProps[p]) {
				if (v) if (v instanceof Array || v.push && _isArray(v)) if (v.join("").indexOf("{self}") !== -1) {
					this.vars[p] = v = this._swapSelfInParams(v, this);
				}
			} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {

				//t - target 		[object]
				//p - property 		[string]
				//s - start			[number]
				//c - change		[number]
				//f - isFunction	[boolean]
				//n - name			[string]
				//pg - isPlugin 	[boolean]
				//pr - priority		[number]
				this._firstPT = pt = { _next: this._firstPT, t: plugin, p: "setRatio", s: 0, c: 1, f: 1, n: p, pg: 1, pr: plugin._priority };
				i = plugin._overwriteProps.length;
				while (--i > -1) {
					propLookup[plugin._overwriteProps[i]] = this._firstPT;
				}
				if (plugin._priority || plugin._onInitAllProps) {
					initPlugins = true;
				}
				if (plugin._onDisable || plugin._onEnable) {
					this._notifyPluginsOfEnabled = true;
				}
				if (pt._next) {
					pt._next._prev = pt;
				}
			} else {
				propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter);
			}
		}

		if (overwrittenProps) if (this._kill(overwrittenProps, target)) {
			//another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
			return this._initProps(target, propLookup, siblings, overwrittenProps);
		}
		if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
			this._kill(propLookup, target);
			return this._initProps(target, propLookup, siblings, overwrittenProps);
		}
		if (this._firstPT) if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
			//zero duration tweens don't lazy render by default; everything else does.
			_lazyLookup[target._gsTweenID] = true;
		}
		return initPlugins;
	};

	p.render = function (time, suppressEvents, force) {
		var prevTime = this._time,
		    duration = this._duration,
		    prevRawPrevTime = this._rawPrevTime,
		    isComplete,
		    callback,
		    pt,
		    rawPrevTime;
		if (time >= duration - 0.0000001) {
			//to work around occasional floating point math artifacts.
			this._totalTime = this._time = duration;
			this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
			if (!this._reversed) {
				isComplete = true;
				callback = "onComplete";
				force = force || this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
			}
			if (duration === 0) if (this._initted || !this.vars.lazy || force) {
				//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
				if (this._startTime === this._timeline._duration) {
					//if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
					time = 0;
				}
				if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause") if (prevRawPrevTime !== time) {
					//note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
					force = true;
					if (prevRawPrevTime > _tinyNum) {
						callback = "onReverseComplete";
					}
				}
				this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
			}
		} else if (time < 0.0000001) {
			//to work around occasional floating point math artifacts, round super small values to 0.
			this._totalTime = this._time = 0;
			this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
			if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
				callback = "onReverseComplete";
				isComplete = this._reversed;
			}
			if (time < 0) {
				this._active = false;
				if (duration === 0) if (this._initted || !this.vars.lazy || force) {
					//zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
						force = true;
					}
					this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
			}
			if (!this._initted) {
				//if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
				force = true;
			}
		} else {
			this._totalTime = this._time = time;

			if (this._easeType) {
				var r = time / duration,
				    type = this._easeType,
				    pow = this._easePower;
				if (type === 1 || type === 3 && r >= 0.5) {
					r = 1 - r;
				}
				if (type === 3) {
					r *= 2;
				}
				if (pow === 1) {
					r *= r;
				} else if (pow === 2) {
					r *= r * r;
				} else if (pow === 3) {
					r *= r * r * r;
				} else if (pow === 4) {
					r *= r * r * r * r;
				}

				if (type === 1) {
					this.ratio = 1 - r;
				} else if (type === 2) {
					this.ratio = r;
				} else if (time / duration < 0.5) {
					this.ratio = r / 2;
				} else {
					this.ratio = 1 - r / 2;
				}
			} else {
				this.ratio = this._ease.getRatio(time / duration);
			}
		}

		if (this._time === prevTime && !force) {
			return;
		} else if (!this._initted) {
			this._init();
			if (!this._initted || this._gc) {
				//immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
				return;
			} else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
				this._time = this._totalTime = prevTime;
				this._rawPrevTime = prevRawPrevTime;
				_lazyTweens.push(this);
				this._lazy = [time, suppressEvents];
				return;
			}
			//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
			if (this._time && !isComplete) {
				this.ratio = this._ease.getRatio(this._time / duration);
			} else if (isComplete && this._ease._calcEnd) {
				this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
			}
		}
		if (this._lazy !== false) {
			//in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
			this._lazy = false;
		}
		if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
			this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
		}
		if (prevTime === 0) {
			if (this._startAt) {
				if (time >= 0) {
					this._startAt.render(time, suppressEvents, force);
				} else if (!callback) {
					callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
				}
			}
			if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
				this._callback("onStart");
			}
		}
		pt = this._firstPT;
		while (pt) {
			if (pt.f) {
				pt.t[pt.p](pt.c * this.ratio + pt.s);
			} else {
				pt.t[pt.p] = pt.c * this.ratio + pt.s;
			}
			pt = pt._next;
		}

		if (this._onUpdate) {
			if (time < 0) if (this._startAt && time !== -0.0001) {
				//if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
				this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
			}
			if (!suppressEvents) if (this._time !== prevTime || isComplete || force) {
				this._callback("onUpdate");
			}
		}
		if (callback) if (!this._gc || force) {
			//check _gc because there's a chance that kill() could be called in an onUpdate
			if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) {
				//-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
				this._startAt.render(time, suppressEvents, force);
			}
			if (isComplete) {
				if (this._timeline.autoRemoveChildren) {
					this._enabled(false, false);
				}
				this._active = false;
			}
			if (!suppressEvents && this.vars[callback]) {
				this._callback(callback);
			}
			if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
				//the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
				this._rawPrevTime = 0;
			}
		}
	};

	p._kill = function (vars, target, overwritingTween) {
		if (vars === "all") {
			vars = null;
		}
		if (vars == null) if (target == null || target === this.target) {
			this._lazy = false;
			return this._enabled(false, false);
		}
		target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
		var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,
		    i,
		    overwrittenProps,
		    p,
		    pt,
		    propLookup,
		    changed,
		    killProps,
		    record,
		    killed;
		if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
			i = target.length;
			while (--i > -1) {
				if (this._kill(vars, target[i], overwritingTween)) {
					changed = true;
				}
			}
		} else {
			if (this._targets) {
				i = this._targets.length;
				while (--i > -1) {
					if (target === this._targets[i]) {
						propLookup = this._propLookup[i] || {};
						this._overwrittenProps = this._overwrittenProps || [];
						overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
						break;
					}
				}
			} else if (target !== this.target) {
				return false;
			} else {
				propLookup = this._propLookup;
				overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
			}

			if (propLookup) {
				killProps = vars || propLookup;
				record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof vars !== "object" || !vars._tempKill); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
				if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
					for (p in killProps) {
						if (propLookup[p]) {
							if (!killed) {
								killed = [];
							}
							killed.push(p);
						}
					}
					if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
						//if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
						return false;
					}
				}

				for (p in killProps) {
					if (pt = propLookup[p]) {
						if (simultaneousOverwrite) {
							//if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
							if (pt.f) {
								pt.t[pt.p](pt.s);
							} else {
								pt.t[pt.p] = pt.s;
							}
							changed = true;
						}
						if (pt.pg && pt.t._kill(killProps)) {
							changed = true; //some plugins need to be notified so they can perform cleanup tasks first
						}
						if (!pt.pg || pt.t._overwriteProps.length === 0) {
							if (pt._prev) {
								pt._prev._next = pt._next;
							} else if (pt === this._firstPT) {
								this._firstPT = pt._next;
							}
							if (pt._next) {
								pt._next._prev = pt._prev;
							}
							pt._next = pt._prev = null;
						}
						delete propLookup[p];
					}
					if (record) {
						overwrittenProps[p] = 1;
					}
				}
				if (!this._firstPT && this._initted) {
					//if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
					this._enabled(false, false);
				}
			}
		}
		return changed;
	};

	p.invalidate = function () {
		if (this._notifyPluginsOfEnabled) {
			TweenLite._onPluginEvent("_onDisable", this);
		}
		this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
		this._notifyPluginsOfEnabled = this._active = this._lazy = false;
		this._propLookup = this._targets ? {} : [];
		Animation.prototype.invalidate.call(this);
		if (this.vars.immediateRender) {
			this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
			this.render(Math.min(0, -this._delay)); //in case delay is negative.
		}
		return this;
	};

	p._enabled = function (enabled, ignoreTimeline) {
		if (!_tickerActive) {
			_ticker.wake();
		}
		if (enabled && this._gc) {
			var targets = this._targets,
			    i;
			if (targets) {
				i = targets.length;
				while (--i > -1) {
					this._siblings[i] = _register(targets[i], this, true);
				}
			} else {
				this._siblings = _register(this.target, this, true);
			}
		}
		Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
		if (this._notifyPluginsOfEnabled) if (this._firstPT) {
			return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this);
		}
		return false;
	};

	//----TweenLite static methods -----------------------------------------------------

	TweenLite.to = function (target, duration, vars) {
		return new TweenLite(target, duration, vars);
	};

	TweenLite.from = function (target, duration, vars) {
		vars.runBackwards = true;
		vars.immediateRender = vars.immediateRender != false;
		return new TweenLite(target, duration, vars);
	};

	TweenLite.fromTo = function (target, duration, fromVars, toVars) {
		toVars.startAt = fromVars;
		toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
		return new TweenLite(target, duration, toVars);
	};

	TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
		return new TweenLite(callback, 0, { delay: delay, onComplete: callback, onCompleteParams: params, callbackScope: scope, onReverseComplete: callback, onReverseCompleteParams: params, immediateRender: false, lazy: false, useFrames: useFrames, overwrite: 0 });
	};

	TweenLite.set = function (target, vars) {
		return new TweenLite(target, 0, vars);
	};

	TweenLite.getTweensOf = function (target, onlyActive) {
		if (target == null) {
			return [];
		}
		target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
		var i, a, j, t;
		if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
			i = target.length;
			a = [];
			while (--i > -1) {
				a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
			}
			i = a.length;
			//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
			while (--i > -1) {
				t = a[i];
				j = i;
				while (--j > -1) {
					if (t === a[j]) {
						a.splice(i, 1);
					}
				}
			}
		} else {
			a = _register(target).concat();
			i = a.length;
			while (--i > -1) {
				if (a[i]._gc || onlyActive && !a[i].isActive()) {
					a.splice(i, 1);
				}
			}
		}
		return a;
	};

	TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
		if (typeof onlyActive === "object") {
			vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
			onlyActive = false;
		}
		var a = TweenLite.getTweensOf(target, onlyActive),
		    i = a.length;
		while (--i > -1) {
			a[i]._kill(vars, target);
		}
	};

	/*
  * ----------------------------------------------------------------
  * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
  * ----------------------------------------------------------------
  */
	var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
		this._overwriteProps = (props || "").split(",");
		this._propName = this._overwriteProps[0];
		this._priority = priority || 0;
		this._super = TweenPlugin.prototype;
	}, true);

	p = TweenPlugin.prototype;
	TweenPlugin.version = "1.18.0";
	TweenPlugin.API = 2;
	p._firstPT = null;
	p._addTween = _addPropTween;
	p.setRatio = _setRatio;

	p._kill = function (lookup) {
		var a = this._overwriteProps,
		    pt = this._firstPT,
		    i;
		if (lookup[this._propName] != null) {
			this._overwriteProps = [];
		} else {
			i = a.length;
			while (--i > -1) {
				if (lookup[a[i]] != null) {
					a.splice(i, 1);
				}
			}
		}
		while (pt) {
			if (lookup[pt.n] != null) {
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
					pt._prev = null;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
				}
			}
			pt = pt._next;
		}
		return false;
	};

	p._roundProps = function (lookup, value) {
		var pt = this._firstPT;
		while (pt) {
			if (lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")]) {
				//some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
				pt.r = value;
			}
			pt = pt._next;
		}
	};

	TweenLite._onPluginEvent = function (type, tween) {
		var pt = tween._firstPT,
		    changed,
		    pt2,
		    first,
		    last,
		    next;
		if (type === "_onInitAllProps") {
			//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
			while (pt) {
				next = pt._next;
				pt2 = first;
				while (pt2 && pt2.pr > pt.pr) {
					pt2 = pt2._next;
				}
				if (pt._prev = pt2 ? pt2._prev : last) {
					pt._prev._next = pt;
				} else {
					first = pt;
				}
				if (pt._next = pt2) {
					pt2._prev = pt;
				} else {
					last = pt;
				}
				pt = next;
			}
			pt = tween._firstPT = first;
		}
		while (pt) {
			if (pt.pg) if (typeof pt.t[type] === "function") if (pt.t[type]()) {
				changed = true;
			}
			pt = pt._next;
		}
		return changed;
	};

	TweenPlugin.activate = function (plugins) {
		var i = plugins.length;
		while (--i > -1) {
			if (plugins[i].API === TweenPlugin.API) {
				_plugins[new plugins[i]()._propName] = plugins[i];
			}
		}
		return true;
	};

	//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
	_gsDefine.plugin = function (config) {
		if (!config || !config.propName || !config.init || !config.API) {
			throw "illegal plugin definition.";
		}
		var propName = config.propName,
		    priority = config.priority || 0,
		    overwriteProps = config.overwriteProps,
		    map = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_roundProps", initAll: "_onInitAllProps" },
		    Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
			TweenPlugin.call(this, propName, priority);
			this._overwriteProps = overwriteProps || [];
		}, config.global === true),
		    p = Plugin.prototype = new TweenPlugin(propName),
		    prop;
		p.constructor = Plugin;
		Plugin.API = config.API;
		for (prop in map) {
			if (typeof config[prop] === "function") {
				p[map[prop]] = config[prop];
			}
		}
		Plugin.version = config.version;
		TweenPlugin.activate([Plugin]);
		return Plugin;
	};

	//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
	a = window._gsQueue;
	if (a) {
		for (i = 0; i < a.length; i++) {
			a[i]();
		}
		for (p in _defLookup) {
			if (!_defLookup[p].func) {
				window.console.log("GSAP encountered missing dependency: com.greensock." + p);
			}
		}
	}

	_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated
})(typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window, "TweenMax");
'use strict';

/*!
 * ScrollMagic v2.0.5 (2015-04-29)
 * The javascript library for magical scroll interactions.
 * (c) 2015 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.5
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic main library.
 */
/**
 * @namespace ScrollMagic
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		module.exports = factory();
	} else {
		// Browser global
		root.ScrollMagic = factory();
	}
})(this, function () {
	"use strict";

	var ScrollMagic = function () {
		_util.log(2, '(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use \'new ScrollMagic.Controller()\' to create a new controller instance. Use \'new ScrollMagic.Scene()\' to instance a scene.');
	};

	ScrollMagic.version = "2.0.5";

	// TODO: temporary workaround for chrome's scroll jitter bug
	window.addEventListener("mousewheel", function () {});

	// global const
	var PIN_SPACER_ATTRIBUTE = "data-scrollmagic-pin-spacer";

	/**
  * The main class that is needed once per scroll container.
  *
  * @class
  *
  * @example
  * // basic initialization
  * var controller = new ScrollMagic.Controller();
  *
  * // passing options
  * var controller = new ScrollMagic.Controller({container: "#myContainer", loglevel: 3});
  *
  * @param {object} [options] - An object containing one or more options for the controller.
  * @param {(string|object)} [options.container=window] - A selector, DOM object that references the main container for scrolling.
  * @param {boolean} [options.vertical=true] - Sets the scroll mode to vertical (`true`) or horizontal (`false`) scrolling.
  * @param {object} [options.globalSceneOptions={}] - These options will be passed to every Scene that is added to the controller using the addScene method. For more information on Scene options see {@link ScrollMagic.Scene}.
  * @param {number} [options.loglevel=2] Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
  ** `0` => silent
  ** `1` => errors
  ** `2` => errors, warnings
  ** `3` => errors, warnings, debuginfo
  * @param {boolean} [options.refreshInterval=100] - Some changes don't call events by default, like changing the container size or moving a scene trigger element.  
  This interval polls these parameters to fire the necessary events.  
  If you don't use custom containers, trigger elements or have static layouts, where the positions of the trigger elements don't change, you can set this to 0 disable interval checking and improve performance.
  *
  */
	ScrollMagic.Controller = function (options) {
		/*
  	 * ----------------------------------------------------------------
  	 * settings
  	 * ----------------------------------------------------------------
  	 */
		var NAMESPACE = 'ScrollMagic.Controller',
		    SCROLL_DIRECTION_FORWARD = 'FORWARD',
		    SCROLL_DIRECTION_REVERSE = 'REVERSE',
		    SCROLL_DIRECTION_PAUSED = 'PAUSED',
		    DEFAULT_OPTIONS = CONTROLLER_OPTIONS.defaults;

		/*
  	 * ----------------------------------------------------------------
  	 * private vars
  	 * ----------------------------------------------------------------
  	 */
		var Controller = this,
		    _options = _util.extend({}, DEFAULT_OPTIONS, options),
		    _sceneObjects = [],
		    _updateScenesOnNextCycle = false,

		// can be boolean (true => all scenes) or an array of scenes to be updated
		_scrollPos = 0,
		    _scrollDirection = SCROLL_DIRECTION_PAUSED,
		    _isDocument = true,
		    _viewPortSize = 0,
		    _enabled = true,
		    _updateTimeout,
		    _refreshTimeout;

		/*
  	 * ----------------------------------------------------------------
  	 * private functions
  	 * ----------------------------------------------------------------
  	 */

		/**
   * Internal constructor function of the ScrollMagic Controller
   * @private
   */
		var construct = function () {
			for (var key in _options) {
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			_options.container = _util.get.elements(_options.container)[0];
			// check ScrollContainer
			if (!_options.container) {
				log(1, "ERROR creating object " + NAMESPACE + ": No valid scroll container supplied");
				throw NAMESPACE + " init failed."; // cancel
			}
			_isDocument = _options.container === window || _options.container === document.body || !document.body.contains(_options.container);
			// normalize to window
			if (_isDocument) {
				_options.container = window;
			}
			// update container size immediately
			_viewPortSize = getViewportSize();
			// set event handlers
			_options.container.addEventListener("resize", onChange);
			_options.container.addEventListener("scroll", onChange);

			_options.refreshInterval = parseInt(_options.refreshInterval) || DEFAULT_OPTIONS.refreshInterval;
			scheduleRefresh();

			log(3, "added new " + NAMESPACE + " controller (v" + ScrollMagic.version + ")");
		};

		/**
   * Schedule the next execution of the refresh function
   * @private
   */
		var scheduleRefresh = function () {
			if (_options.refreshInterval > 0) {
				_refreshTimeout = window.setTimeout(refresh, _options.refreshInterval);
			}
		};

		/**
   * Default function to get scroll pos - overwriteable using `Controller.scrollPos(newFunction)`
   * @private
   */
		var getScrollPos = function () {
			return _options.vertical ? _util.get.scrollTop(_options.container) : _util.get.scrollLeft(_options.container);
		};

		/**
   * Returns the current viewport Size (width vor horizontal, height for vertical)
   * @private
   */
		var getViewportSize = function () {
			return _options.vertical ? _util.get.height(_options.container) : _util.get.width(_options.container);
		};

		/**
   * Default function to set scroll pos - overwriteable using `Controller.scrollTo(newFunction)`
   * Make available publicly for pinned mousewheel workaround.
   * @private
   */
		var setScrollPos = this._setScrollPos = function (pos) {
			if (_options.vertical) {
				if (_isDocument) {
					window.scrollTo(_util.get.scrollLeft(), pos);
				} else {
					_options.container.scrollTop = pos;
				}
			} else {
				if (_isDocument) {
					window.scrollTo(pos, _util.get.scrollTop());
				} else {
					_options.container.scrollLeft = pos;
				}
			}
		};

		/**
   * Handle updates in cycles instead of on scroll (performance)
   * @private
   */
		var updateScenes = function () {
			if (_enabled && _updateScenesOnNextCycle) {
				// determine scenes to update
				var scenesToUpdate = _util.type.Array(_updateScenesOnNextCycle) ? _updateScenesOnNextCycle : _sceneObjects.slice(0);
				// reset scenes
				_updateScenesOnNextCycle = false;
				var oldScrollPos = _scrollPos;
				// update scroll pos now instead of onChange, as it might have changed since scheduling (i.e. in-browser smooth scroll)
				_scrollPos = Controller.scrollPos();
				var deltaScroll = _scrollPos - oldScrollPos;
				if (deltaScroll !== 0) {
					// scroll position changed?
					_scrollDirection = deltaScroll > 0 ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_REVERSE;
				}
				// reverse order of scenes if scrolling reverse
				if (_scrollDirection === SCROLL_DIRECTION_REVERSE) {
					scenesToUpdate.reverse();
				}
				// update scenes
				scenesToUpdate.forEach(function (scene, index) {
					log(3, "updating Scene " + (index + 1) + "/" + scenesToUpdate.length + " (" + _sceneObjects.length + " total)");
					scene.update(true);
				});
				if (scenesToUpdate.length === 0 && _options.loglevel >= 3) {
					log(3, "updating 0 Scenes (nothing added to controller)");
				}
			}
		};

		/**
   * Initializes rAF callback
   * @private
   */
		var debounceUpdate = function () {
			_updateTimeout = _util.rAF(updateScenes);
		};

		/**
   * Handles Container changes
   * @private
   */
		var onChange = function (e) {
			log(3, "event fired causing an update:", e.type);
			if (e.type == "resize") {
				// resize
				_viewPortSize = getViewportSize();
				_scrollDirection = SCROLL_DIRECTION_PAUSED;
			}
			// schedule update
			if (_updateScenesOnNextCycle !== true) {
				_updateScenesOnNextCycle = true;
				debounceUpdate();
			}
		};

		var refresh = function () {
			if (!_isDocument) {
				// simulate resize event. Only works for viewport relevant param (performance)
				if (_viewPortSize != getViewportSize()) {
					var resizeEvent;
					try {
						resizeEvent = new Event('resize', {
							bubbles: false,
							cancelable: false
						});
					} catch (e) {
						// stupid IE
						resizeEvent = document.createEvent("Event");
						resizeEvent.initEvent("resize", false, false);
					}
					_options.container.dispatchEvent(resizeEvent);
				}
			}
			_sceneObjects.forEach(function (scene, index) {
				// refresh all scenes
				scene.refresh();
			});
			scheduleRefresh();
		};

		/**
   * Send a debug message to the console.
   * provided publicly with _log for plugins
   * @private
   *
   * @param {number} loglevel - The loglevel required to initiate output for the message.
   * @param {...mixed} output - One or more variables that should be passed to the console.
   */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};
		// for scenes we have getters for each option, but for the controller we don't, so we need to make it available externally for plugins
		this._options = _options;

		/**
   * Sort scenes in ascending order of their start offset.
   * @private
   *
   * @param {array} ScenesArray - an array of ScrollMagic Scenes that should be sorted
   * @return {array} The sorted array of Scenes.
   */
		var sortScenes = function (ScenesArray) {
			if (ScenesArray.length <= 1) {
				return ScenesArray;
			} else {
				var scenes = ScenesArray.slice(0);
				scenes.sort(function (a, b) {
					return a.scrollOffset() > b.scrollOffset() ? 1 : -1;
				});
				return scenes;
			}
		};

		/**
   * ----------------------------------------------------------------
   * public functions
   * ----------------------------------------------------------------
   */

		/**
   * Add one ore more scene(s) to the controller.  
   * This is the equivalent to `Scene.addTo(controller)`.
   * @public
   * @example
   * // with a previously defined scene
   * controller.addScene(scene);
   *
   * // with a newly created scene.
   * controller.addScene(new ScrollMagic.Scene({duration : 0}));
   *
   * // adding multiple scenes
   * controller.addScene([scene, scene2, new ScrollMagic.Scene({duration : 0})]);
   *
   * @param {(ScrollMagic.Scene|array)} newScene - ScrollMagic Scene or Array of Scenes to be added to the controller.
   * @return {Controller} Parent object for chaining.
   */
		this.addScene = function (newScene) {
			if (_util.type.Array(newScene)) {
				newScene.forEach(function (scene, index) {
					Controller.addScene(scene);
				});
			} else if (newScene instanceof ScrollMagic.Scene) {
				if (newScene.controller() !== Controller) {
					newScene.addTo(Controller);
				} else if (_sceneObjects.indexOf(newScene) < 0) {
					// new scene
					_sceneObjects.push(newScene); // add to array
					_sceneObjects = sortScenes(_sceneObjects); // sort
					newScene.on("shift.controller_sort", function () {
						// resort whenever scene moves
						_sceneObjects = sortScenes(_sceneObjects);
					});
					// insert Global defaults.
					for (var key in _options.globalSceneOptions) {
						if (newScene[key]) {
							newScene[key].call(newScene, _options.globalSceneOptions[key]);
						}
					}
					log(3, "adding Scene (now " + _sceneObjects.length + " total)");
				}
			} else {
				log(1, "ERROR: invalid argument supplied for '.addScene()'");
			}
			return Controller;
		};

		/**
   * Remove one ore more scene(s) from the controller.  
   * This is the equivalent to `Scene.remove()`.
   * @public
   * @example
   * // remove a scene from the controller
   * controller.removeScene(scene);
   *
   * // remove multiple scenes from the controller
   * controller.removeScene([scene, scene2, scene3]);
   *
   * @param {(ScrollMagic.Scene|array)} Scene - ScrollMagic Scene or Array of Scenes to be removed from the controller.
   * @returns {Controller} Parent object for chaining.
   */
		this.removeScene = function (Scene) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.removeScene(scene);
				});
			} else {
				var index = _sceneObjects.indexOf(Scene);
				if (index > -1) {
					Scene.off("shift.controller_sort");
					_sceneObjects.splice(index, 1);
					log(3, "removing Scene (now " + _sceneObjects.length + " left)");
					Scene.remove();
				}
			}
			return Controller;
		};

		/**
   * Update one ore more scene(s) according to the scroll position of the container.  
   * This is the equivalent to `Scene.update()`.  
   * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
   * It then updates the current scene state accordingly (or does nothing, if the state is already correct) – Pins will be set to their correct position and tweens will be updated to their correct progress.  
   * _**Note:** This method gets called constantly whenever Controller detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
   * @public
   * @example
   * // update a specific scene on next cycle
   * controller.updateScene(scene);
   *
   * // update a specific scene immediately
   * controller.updateScene(scene, true);
   *
   * // update multiple scenes scene on next cycle
   * controller.updateScene([scene1, scene2, scene3]);
   *
   * @param {ScrollMagic.Scene} Scene - ScrollMagic Scene or Array of Scenes that is/are supposed to be updated.
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle.  
   This is useful when changing multiple properties of the scene - this way it will only be updated once all new properties are set (updateScenes).
   * @return {Controller} Parent object for chaining.
   */
		this.updateScene = function (Scene, immediately) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.updateScene(scene, immediately);
				});
			} else {
				if (immediately) {
					Scene.update(true);
				} else if (_updateScenesOnNextCycle !== true && Scene instanceof ScrollMagic.Scene) {
					// if _updateScenesOnNextCycle is true, all connected scenes are already scheduled for update
					// prep array for next update cycle
					_updateScenesOnNextCycle = _updateScenesOnNextCycle || [];
					if (_updateScenesOnNextCycle.indexOf(Scene) == -1) {
						_updateScenesOnNextCycle.push(Scene);
					}
					_updateScenesOnNextCycle = sortScenes(_updateScenesOnNextCycle); // sort
					debounceUpdate();
				}
			}
			return Controller;
		};

		/**
   * Updates the controller params and calls updateScene on every scene, that is attached to the controller.  
   * See `Controller.updateScene()` for more information about what this means.  
   * In most cases you will not need this function, as it is called constantly, whenever ScrollMagic detects a state change event, like resize or scroll.  
   * The only application for this method is when ScrollMagic fails to detect these events.  
   * One application is with some external scroll libraries (like iScroll) that move an internal container to a negative offset instead of actually scrolling. In this case the update on the controller needs to be called whenever the child container's position changes.
   * For this case there will also be the need to provide a custom function to calculate the correct scroll position. See `Controller.scrollPos()` for details.
   * @public
   * @example
   * // update the controller on next cycle (saves performance due to elimination of redundant updates)
   * controller.update();
   *
   * // update the controller immediately
   * controller.update(true);
   *
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance)
   * @return {Controller} Parent object for chaining.
   */
		this.update = function (immediately) {
			onChange({
				type: "resize"
			}); // will update size and set _updateScenesOnNextCycle to true
			if (immediately) {
				updateScenes();
			}
			return Controller;
		};

		/**
   * Scroll to a numeric scroll offset, a DOM element, the start of a scene or provide an alternate method for scrolling.  
   * For vertical controllers it will change the top scroll offset and for horizontal applications it will change the left offset.
   * @public
   *
   * @since 1.1.0
   * @example
   * // scroll to an offset of 100
   * controller.scrollTo(100);
   *
   * // scroll to a DOM element
   * controller.scrollTo("#anchor");
   *
   * // scroll to the beginning of a scene
   * var scene = new ScrollMagic.Scene({offset: 200});
   * controller.scrollTo(scene);
   *
   * // define a new scroll position modification function (jQuery animate instead of jump)
   * controller.scrollTo(function (newScrollPos) {
   *	$("html, body").animate({scrollTop: newScrollPos});
   * });
   * controller.scrollTo(100); // call as usual, but the new function will be used instead
   *
   * // define a new scroll function with an additional parameter
   * controller.scrollTo(function (newScrollPos, message) {
   *  console.log(message);
   *	$(this).animate({scrollTop: newScrollPos});
   * });
   * // call as usual, but supply an extra parameter to the defined custom function
   * controller.scrollTo(100, "my message");
   *
   * // define a new scroll function with an additional parameter containing multiple variables
   * controller.scrollTo(function (newScrollPos, options) {
   *  someGlobalVar = options.a + options.b;
   *	$(this).animate({scrollTop: newScrollPos});
   * });
   * // call as usual, but supply an extra parameter containing multiple options
   * controller.scrollTo(100, {a: 1, b: 2});
   *
   * // define a new scroll function with a callback supplied as an additional parameter
   * controller.scrollTo(function (newScrollPos, callback) {
   *	$(this).animate({scrollTop: newScrollPos}, 400, "swing", callback);
   * });
   * // call as usual, but supply an extra parameter, which is used as a callback in the previously defined custom scroll function
   * controller.scrollTo(100, function() {
   *	console.log("scroll has finished.");
   * });
   *
   * @param {mixed} scrollTarget - The supplied argument can be one of these types:
   * 1. `number` -> The container will scroll to this new scroll offset.
   * 2. `string` or `object` -> Can be a selector or a DOM object.  
   *  The container will scroll to the position of this element.
   * 3. `ScrollMagic Scene` -> The container will scroll to the start of this scene.
   * 4. `function` -> This function will be used for future scroll position modifications.  
   *  This provides a way for you to change the behaviour of scrolling and adding new behaviour like animation. The function receives the new scroll position as a parameter and a reference to the container element using `this`.  
   *  It may also optionally receive an optional additional parameter (see below)  
   *  _**NOTE:**  
   *  All other options will still work as expected, using the new function to scroll._
   * @param {mixed} [additionalParameter] - If a custom scroll function was defined (see above 4.), you may want to supply additional parameters to it, when calling it. You can do this using this parameter – see examples for details. Please note, that this parameter will have no effect, if you use the default scrolling function.
   * @returns {Controller} Parent object for chaining.
   */
		this.scrollTo = function (scrollTarget, additionalParameter) {
			if (_util.type.Number(scrollTarget)) {
				// excecute
				setScrollPos.call(_options.container, scrollTarget, additionalParameter);
			} else if (scrollTarget instanceof ScrollMagic.Scene) {
				// scroll to scene
				if (scrollTarget.controller() === Controller) {
					// check if the controller is associated with this scene
					Controller.scrollTo(scrollTarget.scrollOffset(), additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", scrollTarget);
				}
			} else if (_util.type.Function(scrollTarget)) {
				// assign new scroll function
				setScrollPos = scrollTarget;
			} else {
				// scroll to element
				var elem = _util.get.elements(scrollTarget)[0];
				if (elem) {
					// if parent is pin spacer, use spacer position instead so correct start position is returned for pinned elements.
					while (elem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						elem = elem.parentNode;
					}

					var param = _options.vertical ? "top" : "left",

					// which param is of interest ?
					containerOffset = _util.get.offset(_options.container),

					// container position is needed because element offset is returned in relation to document, not in relation to container.
					elementOffset = _util.get.offset(elem);

					if (!_isDocument) {
						// container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
						containerOffset[param] -= Controller.scrollPos();
					}

					Controller.scrollTo(elementOffset[param] - containerOffset[param], additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", scrollTarget);
				}
			}
			return Controller;
		};

		/**
   * **Get** the current scrollPosition or **Set** a new method to calculate it.  
   * -> **GET**:
   * When used as a getter this function will return the current scroll position.  
   * To get a cached value use Controller.info("scrollPos"), which will be updated in the update cycle.  
   * For vertical controllers it will return the top scroll offset and for horizontal applications it will return the left offset.
   *
   * -> **SET**:
   * When used as a setter this method prodes a way to permanently overwrite the controller's scroll position calculation.  
   * A typical usecase is when the scroll position is not reflected by the containers scrollTop or scrollLeft values, but for example by the inner offset of a child container.  
   * Moving a child container inside a parent is a commonly used method for several scrolling frameworks, including iScroll.  
   * By providing an alternate calculation function you can make sure ScrollMagic receives the correct scroll position.  
   * Please also bear in mind that your function should return y values for vertical scrolls an x for horizontals.
   *
   * To change the current scroll position please use `Controller.scrollTo()`.
   * @public
   *
   * @example
   * // get the current scroll Position
   * var scrollPos = controller.scrollPos();
   *
   * // set a new scroll position calculation method
   * controller.scrollPos(function () {
   *	return this.info("vertical") ? -mychildcontainer.y : -mychildcontainer.x
   * });
   *
   * @param {function} [scrollPosMethod] - The function to be used for the scroll position calculation of the container.
   * @returns {(number|Controller)} Current scroll position or parent object for chaining.
   */
		this.scrollPos = function (scrollPosMethod) {
			if (!arguments.length) {
				// get
				return getScrollPos.call(Controller);
			} else {
				// set
				if (_util.type.Function(scrollPosMethod)) {
					getScrollPos = scrollPosMethod;
				} else {
					log(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'.");
				}
			}
			return Controller;
		};

		/**
   * **Get** all infos or one in particular about the controller.
   * @public
   * @example
   * // returns the current scroll position (number)
   * var scrollPos = controller.info("scrollPos");
   *
   * // returns all infos as an object
   * var infos = controller.info();
   *
   * @param {string} [about] - If passed only this info will be returned instead of an object containing all.  
   Valid options are:
   ** `"size"` => the current viewport size of the container
   ** `"vertical"` => true if vertical scrolling, otherwise false
   ** `"scrollPos"` => the current scroll position
   ** `"scrollDirection"` => the last known direction of the scroll
   ** `"container"` => the container element
   ** `"isDocument"` => true if container element is the document.
   * @returns {(mixed|object)} The requested info(s).
   */
		this.info = function (about) {
			var values = {
				size: _viewPortSize,
				// contains height or width (in regard to orientation);
				vertical: _options.vertical,
				scrollPos: _scrollPos,
				scrollDirection: _scrollDirection,
				container: _options.container,
				isDocument: _isDocument
			};
			if (!arguments.length) {
				// get all as an object
				return values;
			} else if (values[about] !== undefined) {
				return values[about];
			} else {
				log(1, "ERROR: option \"" + about + "\" is not available");
				return;
			}
		};

		/**
   * **Get** or **Set** the current loglevel option value.
   * @public
   *
   * @example
   * // get the current value
   * var loglevel = controller.loglevel();
   *
   * // set a new value
   * controller.loglevel(3);
   *
   * @param {number} [newLoglevel] - The new loglevel setting of the Controller. `[0-3]`
   * @returns {(number|Controller)} Current loglevel or parent object for chaining.
   */
		this.loglevel = function (newLoglevel) {
			if (!arguments.length) {
				// get
				return _options.loglevel;
			} else if (_options.loglevel != newLoglevel) {
				// set
				_options.loglevel = newLoglevel;
			}
			return Controller;
		};

		/**
   * **Get** or **Set** the current enabled state of the controller.  
   * This can be used to disable all Scenes connected to the controller without destroying or removing them.
   * @public
   *
   * @example
   * // get the current value
   * var enabled = controller.enabled();
   *
   * // disable the controller
   * controller.enabled(false);
   *
   * @param {boolean} [newState] - The new enabled state of the controller `true` or `false`.
   * @returns {(boolean|Controller)} Current enabled state or parent object for chaining.
   */
		this.enabled = function (newState) {
			if (!arguments.length) {
				// get
				return _enabled;
			} else if (_enabled != newState) {
				// set
				_enabled = !!newState;
				Controller.updateScene(_sceneObjects, true);
			}
			return Controller;
		};

		/**
   * Destroy the Controller, all Scenes and everything.
   * @public
   *
   * @example
   * // without resetting the scenes
   * controller = controller.destroy();
   *
   * // with scene reset
   * controller = controller.destroy(true);
   *
   * @param {boolean} [resetScenes=false] - If `true` the pins and tweens (if existent) of all scenes will be reset.
   * @returns {null} Null to unset handler variables.
   */
		this.destroy = function (resetScenes) {
			window.clearTimeout(_refreshTimeout);
			var i = _sceneObjects.length;
			while (i--) {
				_sceneObjects[i].destroy(resetScenes);
			}
			_options.container.removeEventListener("resize", onChange);
			_options.container.removeEventListener("scroll", onChange);
			_util.cAF(_updateTimeout);
			log(3, "destroyed " + NAMESPACE + " (reset: " + (resetScenes ? "true" : "false") + ")");
			return null;
		};

		// INIT
		construct();
		return Controller;
	};

	// store pagewide controller options
	var CONTROLLER_OPTIONS = {
		defaults: {
			container: window,
			vertical: true,
			globalSceneOptions: {},
			loglevel: 2,
			refreshInterval: 100
		}
	};
	/*
  * method used to add an option to ScrollMagic Scenes.
  */
	ScrollMagic.Controller.addOption = function (name, defaultValue) {
		CONTROLLER_OPTIONS.defaults[name] = defaultValue;
	};
	// instance extension function for plugins
	ScrollMagic.Controller.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Controller = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Controller, oldClass); // copy properties
		ScrollMagic.Controller.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Controller.prototype.constructor = ScrollMagic.Controller; // restore constructor
	};

	/**
  * A Scene defines where the controller should react and how.
  *
  * @class
  *
  * @example
  * // create a standard scene and add it to a controller
  * new ScrollMagic.Scene()
  *		.addTo(controller);
  *
  * // create a scene with custom options and assign a handler to it.
  * var scene = new ScrollMagic.Scene({
  * 		duration: 100,
  *		offset: 200,
  *		triggerHook: "onEnter",
  *		reverse: false
  * });
  *
  * @param {object} [options] - Options for the Scene. The options can be updated at any time.  
  Instead of setting the options for each scene individually you can also set them globally in the controller as the controllers `globalSceneOptions` option. The object accepts the same properties as the ones below.  
  When a scene is added to the controller the options defined using the Scene constructor will be overwritten by those set in `globalSceneOptions`.
  * @param {(number|function)} [options.duration=0] - The duration of the scene. 
  If `0` tweens will auto-play when reaching the scene start point, pins will be pinned indefinetly starting at the start position.  
  A function retuning the duration value is also supported. Please see `Scene.duration()` for details.
  * @param {number} [options.offset=0] - Offset Value for the Trigger Position. If no triggerElement is defined this will be the scroll distance from the start of the page, after which the scene will start.
  * @param {(string|object)} [options.triggerElement=null] - Selector or DOM object that defines the start of the scene. If undefined the scene will start right at the start of the page (unless an offset is set).
  * @param {(number|string)} [options.triggerHook="onCenter"] - Can be a number between 0 and 1 defining the position of the trigger Hook in relation to the viewport.  
  Can also be defined using a string:
  ** `"onEnter"` => `1`
  ** `"onCenter"` => `0.5`
  ** `"onLeave"` => `0`
  * @param {boolean} [options.reverse=true] - Should the scene reverse, when scrolling up?
  * @param {number} [options.loglevel=2] - Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
  ** `0` => silent
  ** `1` => errors
  ** `2` => errors, warnings
  ** `3` => errors, warnings, debuginfo
  * 
  */
	ScrollMagic.Scene = function (options) {

		/*
  	 * ----------------------------------------------------------------
  	 * settings
  	 * ----------------------------------------------------------------
  	 */

		var NAMESPACE = 'ScrollMagic.Scene',
		    SCENE_STATE_BEFORE = 'BEFORE',
		    SCENE_STATE_DURING = 'DURING',
		    SCENE_STATE_AFTER = 'AFTER',
		    DEFAULT_OPTIONS = SCENE_OPTIONS.defaults;

		/*
  	 * ----------------------------------------------------------------
  	 * private vars
  	 * ----------------------------------------------------------------
  	 */

		var Scene = this,
		    _options = _util.extend({}, DEFAULT_OPTIONS, options),
		    _state = SCENE_STATE_BEFORE,
		    _progress = 0,
		    _scrollOffset = {
			start: 0,
			end: 0
		},

		// reflects the controllers's scroll position for the start and end of the scene respectively
		_triggerPos = 0,
		    _enabled = true,
		    _durationUpdateMethod,
		    _controller;

		/**
   * Internal constructor function of the ScrollMagic Scene
   * @private
   */
		var construct = function () {
			for (var key in _options) {
				// check supplied options
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			// add getters/setters for all possible options
			for (var optionName in DEFAULT_OPTIONS) {
				addSceneOption(optionName);
			}
			// validate all options
			validateOption();
		};

		/*
   * ----------------------------------------------------------------
   * Event Management
   * ----------------------------------------------------------------
   */

		var _listeners = {};
		/**
   * Scene start event.  
   * Fires whenever the scroll position its the starting point of the scene.  
   * It will also fire when scrolling back up going over the start position of the scene. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#start
   *
   * @example
   * scene.on("start", function (event) {
   * 	console.log("Hit start point of scene.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"` or `"DURING"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene end event.  
   * Fires whenever the scroll position its the ending point of the scene.  
   * It will also fire when scrolling back up from after the scene and going over its end position. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#end
   *
   * @example
   * scene.on("end", function (event) {
   * 	console.log("Hit end point of scene.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"DURING"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene enter event.  
   * Fires whenever the scene enters the "DURING" state.  
   * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene enters its active scroll timeframe, regardless of the scroll-direction.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#enter
   *
   * @example
   * scene.on("enter", function (event) {
   * 	console.log("Scene entered.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene - always `"DURING"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene leave event.  
   * Fires whenever the scene's state goes from "DURING" to either "BEFORE" or "AFTER".  
   * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene leaves its active scroll timeframe, regardless of the scroll-direction.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#leave
   *
   * @example
   * scene.on("leave", function (event) {
   * 	console.log("Scene left.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene update event.  
   * Fires whenever the scene is updated (but not necessarily changes the progress).
   *
   * @event ScrollMagic.Scene#update
   *
   * @example
   * scene.on("update", function (event) {
   * 	console.log("Scene updated.");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.startPos - The starting position of the scene (in relation to the conainer)
   * @property {number} event.endPos - The ending position of the scene (in relation to the conainer)
   * @property {number} event.scrollPos - The current scroll position of the container
   */
		/**
   * Scene progress event.  
   * Fires whenever the progress of the scene changes.
   *
   * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
   *
   * @event ScrollMagic.Scene#progress
   *
   * @example
   * scene.on("progress", function (event) {
   * 	console.log("Scene progress changed to " + event.progress);
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {number} event.progress - Reflects the current progress of the scene
   * @property {string} event.state - The current state of the scene `"BEFORE"`, `"DURING"` or `"AFTER"`
   * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
   */
		/**
   * Scene change event.  
   * Fires whenvever a property of the scene is changed.
   *
   * @event ScrollMagic.Scene#change
   *
   * @example
   * scene.on("change", function (event) {
   * 	console.log("Scene Property \"" + event.what + "\" changed to " + event.newval);
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {string} event.what - Indicates what value has been changed
   * @property {mixed} event.newval - The new value of the changed property
   */
		/**
   * Scene shift event.  
   * Fires whenvever the start or end **scroll offset** of the scene change.
   * This happens explicitely, when one of these values change: `offset`, `duration` or `triggerHook`.
   * It will fire implicitly when the `triggerElement` changes, if the new element has a different position (most cases).
   * It will also fire implicitly when the size of the container changes and the triggerHook is anything other than `onLeave`.
   *
   * @event ScrollMagic.Scene#shift
   * @since 1.1.0
   *
   * @example
   * scene.on("shift", function (event) {
   * 	console.log("Scene moved, because the " + event.reason + " has changed.)");
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {string} event.reason - Indicates why the scene has shifted
   */
		/**
   * Scene destroy event.  
   * Fires whenvever the scene is destroyed.
   * This can be used to tidy up custom behaviour used in events.
   *
   * @event ScrollMagic.Scene#destroy
   * @since 1.1.0
   *
   * @example
   * scene.on("enter", function (event) {
   *        // add custom action
   *        $("#my-elem").left("200");
   *      })
   *      .on("destroy", function (event) {
   *        // reset my element to start position
   *        if (event.reset) {
   *          $("#my-elem").left("0");
   *        }
   *      });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {boolean} event.reset - Indicates if the destroy method was called with reset `true` or `false`.
   */
		/**
   * Scene add event.  
   * Fires when the scene is added to a controller.
   * This is mostly used by plugins to know that change might be due.
   *
   * @event ScrollMagic.Scene#add
   * @since 2.0.0
   *
   * @example
   * scene.on("add", function (event) {
   * 	console.log('Scene was added to a new controller.');
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   * @property {boolean} event.controller - The controller object the scene was added to.
   */
		/**
   * Scene remove event.  
   * Fires when the scene is removed from a controller.
   * This is mostly used by plugins to know that change might be due.
   *
   * @event ScrollMagic.Scene#remove
   * @since 2.0.0
   *
   * @example
   * scene.on("remove", function (event) {
   * 	console.log('Scene was removed from its controller.');
   * });
   *
   * @property {object} event - The event Object passed to each callback
   * @property {string} event.type - The name of the event
   * @property {Scene} event.target - The Scene object that triggered this event
   */

		/**
   * Add one ore more event listener.  
   * The callback function will be fired at the respective event, and an object containing relevant data will be passed to the callback.
   * @method ScrollMagic.Scene#on
   *
   * @example
   * function callback (event) {
   * 		console.log("Event fired! (" + event.type + ")");
   * }
   * // add listeners
   * scene.on("change update progress start end enter leave", callback);
   *
   * @param {string} names - The name or names of the event the callback should be attached to.
   * @param {function} callback - A function that should be executed, when the event is dispatched. An event object will be passed to the callback.
   * @returns {Scene} Parent object for chaining.
   */
		this.on = function (names, callback) {
			if (_util.type.Function(callback)) {
				names = names.trim().split(' ');
				names.forEach(function (fullname) {
					var nameparts = fullname.split('.'),
					    eventname = nameparts[0],
					    namespace = nameparts[1];
					if (eventname != "*") {
						// disallow wildcards
						if (!_listeners[eventname]) {
							_listeners[eventname] = [];
						}
						_listeners[eventname].push({
							namespace: namespace || '',
							callback: callback
						});
					}
				});
			} else {
				log(1, "ERROR when calling '.on()': Supplied callback for '" + names + "' is not a valid function!");
			}
			return Scene;
		};

		/**
   * Remove one or more event listener.
   * @method ScrollMagic.Scene#off
   *
   * @example
   * function callback (event) {
   * 		console.log("Event fired! (" + event.type + ")");
   * }
   * // add listeners
   * scene.on("change update", callback);
   * // remove listeners
   * scene.off("change update", callback);
   *
   * @param {string} names - The name or names of the event that should be removed.
   * @param {function} [callback] - A specific callback function that should be removed. If none is passed all callbacks to the event listener will be removed.
   * @returns {Scene} Parent object for chaining.
   */
		this.off = function (names, callback) {
			if (!names) {
				log(1, "ERROR: Invalid event name supplied.");
				return Scene;
			}
			names = names.trim().split(' ');
			names.forEach(function (fullname, key) {
				var nameparts = fullname.split('.'),
				    eventname = nameparts[0],
				    namespace = nameparts[1] || '',
				    removeList = eventname === '*' ? Object.keys(_listeners) : [eventname];
				removeList.forEach(function (remove) {
					var list = _listeners[remove] || [],
					    i = list.length;
					while (i--) {
						var listener = list[i];
						if (listener && (namespace === listener.namespace || namespace === '*') && (!callback || callback == listener.callback)) {
							list.splice(i, 1);
						}
					}
					if (!list.length) {
						delete _listeners[remove];
					}
				});
			});
			return Scene;
		};

		/**
   * Trigger an event.
   * @method ScrollMagic.Scene#trigger
   *
   * @example
   * this.trigger("change");
   *
   * @param {string} name - The name of the event that should be triggered.
   * @param {object} [vars] - An object containing info that should be passed to the callback.
   * @returns {Scene} Parent object for chaining.
   */
		this.trigger = function (name, vars) {
			if (name) {
				var nameparts = name.trim().split('.'),
				    eventname = nameparts[0],
				    namespace = nameparts[1],
				    listeners = _listeners[eventname];
				log(3, 'event fired:', eventname, vars ? "->" : '', vars || '');
				if (listeners) {
					listeners.forEach(function (listener, key) {
						if (!namespace || namespace === listener.namespace) {
							listener.callback.call(Scene, new ScrollMagic.Event(eventname, listener.namespace, Scene, vars));
						}
					});
				}
			} else {
				log(1, "ERROR: Invalid event name supplied.");
			}
			return Scene;
		};

		// set event listeners
		Scene.on("change.internal", function (e) {
			if (e.what !== "loglevel" && e.what !== "tweenChanges") {
				// no need for a scene update scene with these options...
				if (e.what === "triggerElement") {
					updateTriggerElementPosition();
				} else if (e.what === "reverse") {
					// the only property left that may have an impact on the current scene state. Everything else is handled by the shift event.
					Scene.update();
				}
			}
		}).on("shift.internal", function (e) {
			updateScrollOffset();
			Scene.update(); // update scene to reflect new position
		});

		/**
   * Send a debug message to the console.
   * @private
   * but provided publicly with _log for plugins
   *
   * @param {number} loglevel - The loglevel required to initiate output for the message.
   * @param {...mixed} output - One or more variables that should be passed to the console.
   */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};

		/**
   * Add the scene to a controller.  
   * This is the equivalent to `Controller.addScene(scene)`.
   * @method ScrollMagic.Scene#addTo
   *
   * @example
   * // add a scene to a ScrollMagic Controller
   * scene.addTo(controller);
   *
   * @param {ScrollMagic.Controller} controller - The controller to which the scene should be added.
   * @returns {Scene} Parent object for chaining.
   */
		this.addTo = function (controller) {
			if (!(controller instanceof ScrollMagic.Controller)) {
				log(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller");
			} else if (_controller != controller) {
				// new controller
				if (_controller) {
					// was associated to a different controller before, so remove it...
					_controller.removeScene(Scene);
				}
				_controller = controller;
				validateOption();
				updateDuration(true);
				updateTriggerElementPosition(true);
				updateScrollOffset();
				_controller.info("container").addEventListener('resize', onContainerResize);
				controller.addScene(Scene);
				Scene.trigger("add", {
					controller: _controller
				});
				log(3, "added " + NAMESPACE + " to controller");
				Scene.update();
			}
			return Scene;
		};

		/**
   * **Get** or **Set** the current enabled state of the scene.  
   * This can be used to disable this scene without removing or destroying it.
   * @method ScrollMagic.Scene#enabled
   *
   * @example
   * // get the current value
   * var enabled = scene.enabled();
   *
   * // disable the scene
   * scene.enabled(false);
   *
   * @param {boolean} [newState] - The new enabled state of the scene `true` or `false`.
   * @returns {(boolean|Scene)} Current enabled state or parent object for chaining.
   */
		this.enabled = function (newState) {
			if (!arguments.length) {
				// get
				return _enabled;
			} else if (_enabled != newState) {
				// set
				_enabled = !!newState;
				Scene.update(true);
			}
			return Scene;
		};

		/**
   * Remove the scene from the controller.  
   * This is the equivalent to `Controller.removeScene(scene)`.
   * The scene will not be updated anymore until you readd it to a controller.
   * To remove the pin or the tween you need to call removeTween() or removePin() respectively.
   * @method ScrollMagic.Scene#remove
   * @example
   * // remove the scene from its controller
   * scene.remove();
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.remove = function () {
			if (_controller) {
				_controller.info("container").removeEventListener('resize', onContainerResize);
				var tmpParent = _controller;
				_controller = undefined;
				tmpParent.removeScene(Scene);
				Scene.trigger("remove");
				log(3, "removed " + NAMESPACE + " from controller");
			}
			return Scene;
		};

		/**
   * Destroy the scene and everything.
   * @method ScrollMagic.Scene#destroy
   * @example
   * // destroy the scene without resetting the pin and tween to their initial positions
   * scene = scene.destroy();
   *
   * // destroy the scene and reset the pin and tween
   * scene = scene.destroy(true);
   *
   * @param {boolean} [reset=false] - If `true` the pin and tween (if existent) will be reset.
   * @returns {null} Null to unset handler variables.
   */
		this.destroy = function (reset) {
			Scene.trigger("destroy", {
				reset: reset
			});
			Scene.remove();
			Scene.off("*.*");
			log(3, "destroyed " + NAMESPACE + " (reset: " + (reset ? "true" : "false") + ")");
			return null;
		};

		/**
   * Updates the Scene to reflect the current state.  
   * This is the equivalent to `Controller.updateScene(scene, immediately)`.  
   * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
   * It then updates the current scene state accordingly (or does nothing, if the state is already correct) – Pins will be set to their correct position and tweens will be updated to their correct progress.
   * This means an update doesn't necessarily result in a progress change. The `progress` event will be fired if the progress has indeed changed between this update and the last.  
   * _**NOTE:** This method gets called constantly whenever ScrollMagic detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
   * @method ScrollMagic.Scene#update
   * @example
   * // update the scene on next tick
   * scene.update();
   *
   * // update the scene immediately
   * scene.update(true);
   *
   * @fires Scene.update
   *
   * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance).
   * @returns {Scene} Parent object for chaining.
   */
		this.update = function (immediately) {
			if (_controller) {
				if (immediately) {
					if (_controller.enabled() && _enabled) {
						var scrollPos = _controller.info("scrollPos"),
						    newProgress;

						if (_options.duration > 0) {
							newProgress = (scrollPos - _scrollOffset.start) / (_scrollOffset.end - _scrollOffset.start);
						} else {
							newProgress = scrollPos >= _scrollOffset.start ? 1 : 0;
						}

						Scene.trigger("update", {
							startPos: _scrollOffset.start,
							endPos: _scrollOffset.end,
							scrollPos: scrollPos
						});

						Scene.progress(newProgress);
					} else if (_pin && _state === SCENE_STATE_DURING) {
						updatePinState(true); // unpin in position
					}
				} else {
					_controller.updateScene(Scene, false);
				}
			}
			return Scene;
		};

		/**
   * Updates dynamic scene variables like the trigger element position or the duration.
   * This method is automatically called in regular intervals from the controller. See {@link ScrollMagic.Controller} option `refreshInterval`.
   * 
   * You can call it to minimize lag, for example when you intentionally change the position of the triggerElement.
   * If you don't it will simply be updated in the next refresh interval of the container, which is usually sufficient.
   *
   * @method ScrollMagic.Scene#refresh
   * @since 1.1.0
   * @example
   * scene = new ScrollMagic.Scene({triggerElement: "#trigger"});
   * 
   * // change the position of the trigger
   * $("#trigger").css("top", 500);
   * // immediately let the scene know of this change
   * scene.refresh();
   *
   * @fires {@link Scene.shift}, if the trigger element position or the duration changed
   * @fires {@link Scene.change}, if the duration changed
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.refresh = function () {
			updateDuration();
			updateTriggerElementPosition();
			// update trigger element position
			return Scene;
		};

		/**
   * **Get** or **Set** the scene's progress.  
   * Usually it shouldn't be necessary to use this as a setter, as it is set automatically by scene.update().  
   * The order in which the events are fired depends on the duration of the scene:
   *  1. Scenes with `duration == 0`:  
   *  Scenes that have no duration by definition have no ending. Thus the `end` event will never be fired.  
   *  When the trigger position of the scene is passed the events are always fired in this order:  
   *  `enter`, `start`, `progress` when scrolling forward  
   *  and  
   *  `progress`, `start`, `leave` when scrolling in reverse
   *  2. Scenes with `duration > 0`:  
   *  Scenes with a set duration have a defined start and end point.  
   *  When scrolling past the start position of the scene it will fire these events in this order:  
   *  `enter`, `start`, `progress`  
   *  When continuing to scroll and passing the end point it will fire these events:  
   *  `progress`, `end`, `leave`  
   *  When reversing through the end point these events are fired:  
   *  `enter`, `end`, `progress`  
   *  And when continuing to scroll past the start position in reverse it will fire:  
   *  `progress`, `start`, `leave`  
   *  In between start and end the `progress` event will be called constantly, whenever the progress changes.
   * 
   * In short:  
   * `enter` events will always trigger **before** the progress update and `leave` envents will trigger **after** the progress update.  
   * `start` and `end` will always trigger at their respective position.
   * 
   * Please review the event descriptions for details on the events and the event object that is passed to the callback.
   * 
   * @method ScrollMagic.Scene#progress
   * @example
   * // get the current scene progress
   * var progress = scene.progress();
   *
   * // set new scene progress
   * scene.progress(0.3);
   *
   * @fires {@link Scene.enter}, when used as setter
   * @fires {@link Scene.start}, when used as setter
   * @fires {@link Scene.progress}, when used as setter
   * @fires {@link Scene.end}, when used as setter
   * @fires {@link Scene.leave}, when used as setter
   *
   * @param {number} [progress] - The new progress value of the scene `[0-1]`.
   * @returns {number} `get` -  Current scene progress.
   * @returns {Scene} `set` -  Parent object for chaining.
   */
		this.progress = function (progress) {
			if (!arguments.length) {
				// get
				return _progress;
			} else {
				// set
				var doUpdate = false,
				    oldState = _state,
				    scrollDirection = _controller ? _controller.info("scrollDirection") : 'PAUSED',
				    reverseOrForward = _options.reverse || progress >= _progress;
				if (_options.duration === 0) {
					// zero duration scenes
					doUpdate = _progress != progress;
					_progress = progress < 1 && reverseOrForward ? 0 : 1;
					_state = _progress === 0 ? SCENE_STATE_BEFORE : SCENE_STATE_DURING;
				} else {
					// scenes with start and end
					if (progress < 0 && _state !== SCENE_STATE_BEFORE && reverseOrForward) {
						// go back to initial state
						_progress = 0;
						_state = SCENE_STATE_BEFORE;
						doUpdate = true;
					} else if (progress >= 0 && progress < 1 && reverseOrForward) {
						_progress = progress;
						_state = SCENE_STATE_DURING;
						doUpdate = true;
					} else if (progress >= 1 && _state !== SCENE_STATE_AFTER) {
						_progress = 1;
						_state = SCENE_STATE_AFTER;
						doUpdate = true;
					} else if (_state === SCENE_STATE_DURING && !reverseOrForward) {
						updatePinState(); // in case we scrolled backwards mid-scene and reverse is disabled => update the pin position, so it doesn't move back as well.
					}
				}
				if (doUpdate) {
					// fire events
					var eventVars = {
						progress: _progress,
						state: _state,
						scrollDirection: scrollDirection
					},
					    stateChanged = _state != oldState;

					var trigger = function (eventName) {
						// tmp helper to simplify code
						Scene.trigger(eventName, eventVars);
					};

					if (stateChanged) {
						// enter events
						if (oldState !== SCENE_STATE_DURING) {
							trigger("enter");
							trigger(oldState === SCENE_STATE_BEFORE ? "start" : "end");
						}
					}
					trigger("progress");
					if (stateChanged) {
						// leave events
						if (_state !== SCENE_STATE_DURING) {
							trigger(_state === SCENE_STATE_BEFORE ? "start" : "end");
							trigger("leave");
						}
					}
				}

				return Scene;
			}
		};

		/**
   * Update the start and end scrollOffset of the container.
   * The positions reflect what the controller's scroll position will be at the start and end respectively.
   * Is called, when:
   *   - Scene event "change" is called with: offset, triggerHook, duration 
   *   - scroll container event "resize" is called
   *   - the position of the triggerElement changes
   *   - the controller changes -> addTo()
   * @private
   */
		var updateScrollOffset = function () {
			_scrollOffset = {
				start: _triggerPos + _options.offset
			};
			if (_controller && _options.triggerElement) {
				// take away triggerHook portion to get relative to top
				_scrollOffset.start -= _controller.info("size") * _options.triggerHook;
			}
			_scrollOffset.end = _scrollOffset.start + _options.duration;
		};

		/**
   * Updates the duration if set to a dynamic function.
   * This method is called when the scene is added to a controller and in regular intervals from the controller through scene.refresh().
   * 
   * @fires {@link Scene.change}, if the duration changed
   * @fires {@link Scene.shift}, if the duration changed
   *
   * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
   * @private
   */
		var updateDuration = function (suppressEvents) {
			// update duration
			if (_durationUpdateMethod) {
				var varname = "duration";
				if (changeOption(varname, _durationUpdateMethod.call(Scene)) && !suppressEvents) {
					// set
					Scene.trigger("change", {
						what: varname,
						newval: _options[varname]
					});
					Scene.trigger("shift", {
						reason: varname
					});
				}
			}
		};

		/**
   * Updates the position of the triggerElement, if present.
   * This method is called ...
   *  - ... when the triggerElement is changed
   *  - ... when the scene is added to a (new) controller
   *  - ... in regular intervals from the controller through scene.refresh().
   * 
   * @fires {@link Scene.shift}, if the position changed
   *
   * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
   * @private
   */
		var updateTriggerElementPosition = function (suppressEvents) {
			var elementPos = 0,
			    telem = _options.triggerElement;
			if (_controller && telem) {
				var controllerInfo = _controller.info(),
				    containerOffset = _util.get.offset(controllerInfo.container),

				// container position is needed because element offset is returned in relation to document, not in relation to container.
				param = controllerInfo.vertical ? "top" : "left"; // which param is of interest ?
				// if parent is spacer, use spacer position instead so correct start position is returned for pinned elements.
				while (telem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
					telem = telem.parentNode;
				}

				var elementOffset = _util.get.offset(telem);

				if (!controllerInfo.isDocument) {
					// container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
					containerOffset[param] -= _controller.scrollPos();
				}

				elementPos = elementOffset[param] - containerOffset[param];
			}
			var changed = elementPos != _triggerPos;
			_triggerPos = elementPos;
			if (changed && !suppressEvents) {
				Scene.trigger("shift", {
					reason: "triggerElementPosition"
				});
			}
		};

		/**
   * Trigger a shift event, when the container is resized and the triggerHook is > 1.
   * @private
   */
		var onContainerResize = function (e) {
			if (_options.triggerHook > 0) {
				Scene.trigger("shift", {
					reason: "containerResize"
				});
			}
		};

		var _validate = _util.extend(SCENE_OPTIONS.validate, {
			// validation for duration handled internally for reference to private var _durationMethod
			duration: function (val) {
				if (_util.type.String(val) && val.match(/^(\.|\d)*\d+%$/)) {
					// percentage value
					var perc = parseFloat(val) / 100;
					val = function () {
						return _controller ? _controller.info("size") * perc : 0;
					};
				}
				if (_util.type.Function(val)) {
					// function
					_durationUpdateMethod = val;
					try {
						val = parseFloat(_durationUpdateMethod());
					} catch (e) {
						val = -1; // will cause error below
					}
				}
				// val has to be float
				val = parseFloat(val);
				if (!_util.type.Number(val) || val < 0) {
					if (_durationUpdateMethod) {
						_durationUpdateMethod = undefined;
						throw ["Invalid return value of supplied function for option \"duration\":", val];
					} else {
						throw ["Invalid value for option \"duration\":", val];
					}
				}
				return val;
			}
		});

		/**
   * Checks the validity of a specific or all options and reset to default if neccessary.
   * @private
   */
		var validateOption = function (check) {
			check = arguments.length ? [check] : Object.keys(_validate);
			check.forEach(function (optionName, key) {
				var value;
				if (_validate[optionName]) {
					// there is a validation method for this option
					try {
						// validate value
						value = _validate[optionName](_options[optionName]);
					} catch (e) {
						// validation failed -> reset to default
						value = DEFAULT_OPTIONS[optionName];
						var logMSG = _util.type.String(e) ? [e] : e;
						if (_util.type.Array(logMSG)) {
							logMSG[0] = "ERROR: " + logMSG[0];
							logMSG.unshift(1); // loglevel 1 for error msg
							log.apply(this, logMSG);
						} else {
							log(1, "ERROR: Problem executing validation callback for option '" + optionName + "':", e.message);
						}
					} finally {
						_options[optionName] = value;
					}
				}
			});
		};

		/**
   * Helper used by the setter/getters for scene options
   * @private
   */
		var changeOption = function (varname, newval) {
			var changed = false,
			    oldval = _options[varname];
			if (_options[varname] != newval) {
				_options[varname] = newval;
				validateOption(varname); // resets to default if necessary
				changed = oldval != _options[varname];
			}
			return changed;
		};

		// generate getters/setters for all options
		var addSceneOption = function (optionName) {
			if (!Scene[optionName]) {
				Scene[optionName] = function (newVal) {
					if (!arguments.length) {
						// get
						return _options[optionName];
					} else {
						if (optionName === "duration") {
							// new duration is set, so any previously set function must be unset
							_durationUpdateMethod = undefined;
						}
						if (changeOption(optionName, newVal)) {
							// set
							Scene.trigger("change", {
								what: optionName,
								newval: _options[optionName]
							});
							if (SCENE_OPTIONS.shifts.indexOf(optionName) > -1) {
								Scene.trigger("shift", {
									reason: optionName
								});
							}
						}
					}
					return Scene;
				};
			}
		};

		/**
   * **Get** or **Set** the duration option value.
   * As a setter it also accepts a function returning a numeric value.  
   * This is particularly useful for responsive setups.
   *
   * The duration is updated using the supplied function every time `Scene.refresh()` is called, which happens periodically from the controller (see ScrollMagic.Controller option `refreshInterval`).  
   * _**NOTE:** Be aware that it's an easy way to kill performance, if you supply a function that has high CPU demand.  
   * Even for size and position calculations it is recommended to use a variable to cache the value. (see example)  
   * This counts double if you use the same function for multiple scenes._
   *
   * @method ScrollMagic.Scene#duration
   * @example
   * // get the current duration value
   * var duration = scene.duration();
   *
   * // set a new duration
   * scene.duration(300);
   *
   * // use a function to automatically adjust the duration to the window height.
   * var durationValueCache;
   * function getDuration () {
   *   return durationValueCache;
   * }
   * function updateDuration (e) {
   *   durationValueCache = window.innerHeight;
   * }
   * $(window).on("resize", updateDuration); // update the duration when the window size changes
   * $(window).triggerHandler("resize"); // set to initial value
   * scene.duration(getDuration); // supply duration method
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {(number|function)} [newDuration] - The new duration of the scene.
   * @returns {number} `get` -  Current scene duration.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the offset option value.
   * @method ScrollMagic.Scene#offset
   * @example
   * // get the current offset
   * var offset = scene.offset();
   *
   * // set a new offset
   * scene.offset(100);
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {number} [newOffset] - The new offset of the scene.
   * @returns {number} `get` -  Current scene offset.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the triggerElement option value.
   * Does **not** fire `Scene.shift`, because changing the trigger Element doesn't necessarily mean the start position changes. This will be determined in `Scene.refresh()`, which is automatically triggered.
   * @method ScrollMagic.Scene#triggerElement
   * @example
   * // get the current triggerElement
   * var triggerElement = scene.triggerElement();
   *
   * // set a new triggerElement using a selector
   * scene.triggerElement("#trigger");
   * // set a new triggerElement using a DOM object
   * scene.triggerElement(document.getElementById("trigger"));
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {(string|object)} [newTriggerElement] - The new trigger element for the scene.
   * @returns {(string|object)} `get` -  Current triggerElement.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the triggerHook option value.
   * @method ScrollMagic.Scene#triggerHook
   * @example
   * // get the current triggerHook value
   * var triggerHook = scene.triggerHook();
   *
   * // set a new triggerHook using a string
   * scene.triggerHook("onLeave");
   * // set a new triggerHook using a number
   * scene.triggerHook(0.7);
   *
   * @fires {@link Scene.change}, when used as setter
   * @fires {@link Scene.shift}, when used as setter
   * @param {(number|string)} [newTriggerHook] - The new triggerHook of the scene. See {@link Scene} parameter description for value options.
   * @returns {number} `get` -  Current triggerHook (ALWAYS numerical).
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the reverse option value.
   * @method ScrollMagic.Scene#reverse
   * @example
   * // get the current reverse option
   * var reverse = scene.reverse();
   *
   * // set new reverse option
   * scene.reverse(false);
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {boolean} [newReverse] - The new reverse setting of the scene.
   * @returns {boolean} `get` -  Current reverse option value.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** or **Set** the loglevel option value.
   * @method ScrollMagic.Scene#loglevel
   * @example
   * // get the current loglevel
   * var loglevel = scene.loglevel();
   *
   * // set new loglevel
   * scene.loglevel(3);
   *
   * @fires {@link Scene.change}, when used as setter
   * @param {number} [newLoglevel] - The new loglevel setting of the scene. `[0-3]`
   * @returns {number} `get` -  Current loglevel.
   * @returns {Scene} `set` -  Parent object for chaining.
   */

		/**
   * **Get** the associated controller.
   * @method ScrollMagic.Scene#controller
   * @example
   * // get the controller of a scene
   * var controller = scene.controller();
   *
   * @returns {ScrollMagic.Controller} Parent controller or `undefined`
   */
		this.controller = function () {
			return _controller;
		};

		/**
   * **Get** the current state.
   * @method ScrollMagic.Scene#state
   * @example
   * // get the current state
   * var state = scene.state();
   *
   * @returns {string} `"BEFORE"`, `"DURING"` or `"AFTER"`
   */
		this.state = function () {
			return _state;
		};

		/**
   * **Get** the current scroll offset for the start of the scene.  
   * Mind, that the scrollOffset is related to the size of the container, if `triggerHook` is bigger than `0` (or `"onLeave"`).  
   * This means, that resizing the container or changing the `triggerHook` will influence the scene's start offset.
   * @method ScrollMagic.Scene#scrollOffset
   * @example
   * // get the current scroll offset for the start and end of the scene.
   * var start = scene.scrollOffset();
   * var end = scene.scrollOffset() + scene.duration();
   * console.log("the scene starts at", start, "and ends at", end);
   *
   * @returns {number} The scroll offset (of the container) at which the scene will trigger. Y value for vertical and X value for horizontal scrolls.
   */
		this.scrollOffset = function () {
			return _scrollOffset.start;
		};

		/**
   * **Get** the trigger position of the scene (including the value of the `offset` option).  
   * @method ScrollMagic.Scene#triggerPosition
   * @example
   * // get the scene's trigger position
   * var triggerPosition = scene.triggerPosition();
   *
   * @returns {number} Start position of the scene. Top position value for vertical and left position value for horizontal scrolls.
   */
		this.triggerPosition = function () {
			var pos = _options.offset; // the offset is the basis
			if (_controller) {
				// get the trigger position
				if (_options.triggerElement) {
					// Element as trigger
					pos += _triggerPos;
				} else {
					// return the height of the triggerHook to start at the beginning
					pos += _controller.info("size") * Scene.triggerHook();
				}
			}
			return pos;
		};

		var _pin, _pinOptions;

		Scene.on("shift.internal", function (e) {
			var durationChanged = e.reason === "duration";
			if (_state === SCENE_STATE_AFTER && durationChanged || _state === SCENE_STATE_DURING && _options.duration === 0) {
				// if [duration changed after a scene (inside scene progress updates pin position)] or [duration is 0, we are in pin phase and some other value changed].
				updatePinState();
			}
			if (durationChanged) {
				updatePinDimensions();
			}
		}).on("progress.internal", function (e) {
			updatePinState();
		}).on("add.internal", function (e) {
			updatePinDimensions();
		}).on("destroy.internal", function (e) {
			Scene.removePin(e.reset);
		});
		/**
   * Update the pin state.
   * @private
   */
		var updatePinState = function (forceUnpin) {
			if (_pin && _controller) {
				var containerInfo = _controller.info(),
				    pinTarget = _pinOptions.spacer.firstChild; // may be pin element or another spacer, if cascading pins
				if (!forceUnpin && _state === SCENE_STATE_DURING) {
					// during scene or if duration is 0 and we are past the trigger
					// pinned state
					if (_util.css(pinTarget, "position") != "fixed") {
						// change state before updating pin spacer (position changes due to fixed collapsing might occur.)
						_util.css(pinTarget, {
							"position": "fixed"
						});
						// update pin spacer
						updatePinDimensions();
					}

					var fixedPos = _util.get.offset(_pinOptions.spacer, true),

					// get viewport position of spacer
					scrollDistance = _options.reverse || _options.duration === 0 ? containerInfo.scrollPos - _scrollOffset.start // quicker
					: Math.round(_progress * _options.duration * 10) / 10; // if no reverse and during pin the position needs to be recalculated using the progress
					// add scrollDistance
					fixedPos[containerInfo.vertical ? "top" : "left"] += scrollDistance;

					// set new values
					_util.css(_pinOptions.spacer.firstChild, {
						top: fixedPos.top,
						left: fixedPos.left
					});
				} else {
					// unpinned state
					var newCSS = {
						position: _pinOptions.inFlow ? "relative" : "absolute",
						top: 0,
						left: 0
					},
					    change = _util.css(pinTarget, "position") != newCSS.position;

					if (!_pinOptions.pushFollowers) {
						newCSS[containerInfo.vertical ? "top" : "left"] = _options.duration * _progress;
					} else if (_options.duration > 0) {
						// only concerns scenes with duration
						if (_state === SCENE_STATE_AFTER && parseFloat(_util.css(_pinOptions.spacer, "padding-top")) === 0) {
							change = true; // if in after state but havent updated spacer yet (jumped past pin)
						} else if (_state === SCENE_STATE_BEFORE && parseFloat(_util.css(_pinOptions.spacer, "padding-bottom")) === 0) {
							// before
							change = true; // jumped past fixed state upward direction
						}
					}
					// set new values
					_util.css(pinTarget, newCSS);
					if (change) {
						// update pin spacer if state changed
						updatePinDimensions();
					}
				}
			}
		};

		/**
   * Update the pin spacer and/or element size.
   * The size of the spacer needs to be updated whenever the duration of the scene changes, if it is to push down following elements.
   * @private
   */
		var updatePinDimensions = function () {
			if (_pin && _controller && _pinOptions.inFlow) {
				// no spacerresize, if original position is absolute
				var after = _state === SCENE_STATE_AFTER,
				    before = _state === SCENE_STATE_BEFORE,
				    during = _state === SCENE_STATE_DURING,
				    vertical = _controller.info("vertical"),
				    pinTarget = _pinOptions.spacer.firstChild,

				// usually the pined element but can also be another spacer (cascaded pins)
				marginCollapse = _util.isMarginCollapseType(_util.css(_pinOptions.spacer, "display")),
				    css = {};

				// set new size
				// if relsize: spacer -> pin | else: pin -> spacer
				if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
					if (during) {
						_util.css(_pin, {
							"width": _util.get.width(_pinOptions.spacer)
						});
					} else {
						_util.css(_pin, {
							"width": "100%"
						});
					}
				} else {
					// minwidth is needed for cascaded pins.
					css["min-width"] = _util.get.width(vertical ? _pin : pinTarget, true, true);
					css.width = during ? css["min-width"] : "auto";
				}
				if (_pinOptions.relSize.height) {
					if (during) {
						// the only padding the spacer should ever include is the duration (if pushFollowers = true), so we need to substract that.
						_util.css(_pin, {
							"height": _util.get.height(_pinOptions.spacer) - (_pinOptions.pushFollowers ? _options.duration : 0)
						});
					} else {
						_util.css(_pin, {
							"height": "100%"
						});
					}
				} else {
					// margin is only included if it's a cascaded pin to resolve an IE9 bug
					css["min-height"] = _util.get.height(vertical ? pinTarget : _pin, true, !marginCollapse); // needed for cascading pins
					css.height = during ? css["min-height"] : "auto";
				}

				// add space for duration if pushFollowers is true
				if (_pinOptions.pushFollowers) {
					css["padding" + (vertical ? "Top" : "Left")] = _options.duration * _progress;
					css["padding" + (vertical ? "Bottom" : "Right")] = _options.duration * (1 - _progress);
				}
				_util.css(_pinOptions.spacer, css);
			}
		};

		/**
   * Updates the Pin state (in certain scenarios)
   * If the controller container is not the document and we are mid-pin-phase scrolling or resizing the main document can result to wrong pin positions.
   * So this function is called on resize and scroll of the document.
   * @private
   */
		var updatePinInContainer = function () {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
				updatePinState();
			}
		};

		/**
   * Updates the Pin spacer size state (in certain scenarios)
   * If container is resized during pin and relatively sized the size of the pin might need to be updated...
   * So this function is called on resize of the container.
   * @private
   */
		var updateRelativePinSpacer = function () {
			if (_controller && _pin && // well, duh
			_state === SCENE_STATE_DURING && ( // element in pinned state?
			// is width or height relatively sized, but not in relation to body? then we need to recalc.
			(_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) && _util.get.width(window) != _util.get.width(_pinOptions.spacer.parentNode) || _pinOptions.relSize.height && _util.get.height(window) != _util.get.height(_pinOptions.spacer.parentNode))) {
				updatePinDimensions();
			}
		};

		/**
   * Is called, when the mousewhel is used while over a pinned element inside a div container.
   * If the scene is in fixed state scroll events would be counted towards the body. This forwards the event to the scroll container.
   * @private
   */
		var onMousewheelOverPin = function (e) {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
				// in pin state
				e.preventDefault();
				_controller._setScrollPos(_controller.info("scrollPos") - ((e.wheelDelta || e[_controller.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || -e.detail * 30));
			}
		};

		/**
   * Pin an element for the duration of the tween.  
   * If the scene duration is 0 the element will only be unpinned, if the user scrolls back past the start position.  
   * Make sure only one pin is applied to an element at the same time.
   * An element can be pinned multiple times, but only successively.
   * _**NOTE:** The option `pushFollowers` has no effect, when the scene duration is 0._
   * @method ScrollMagic.Scene#setPin
   * @example
   * // pin element and push all following elements down by the amount of the pin duration.
   * scene.setPin("#pin");
   *
   * // pin element and keeping all following elements in their place. The pinned element will move past them.
   * scene.setPin("#pin", {pushFollowers: false});
   *
   * @param {(string|object)} element - A Selector targeting an element or a DOM object that is supposed to be pinned.
   * @param {object} [settings] - settings for the pin
   * @param {boolean} [settings.pushFollowers=true] - If `true` following elements will be "pushed" down for the duration of the pin, if `false` the pinned element will just scroll past them.  
   Ignored, when duration is `0`.
   * @param {string} [settings.spacerClass="scrollmagic-pin-spacer"] - Classname of the pin spacer element, which is used to replace the element.
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.setPin = function (element, settings) {
			var defaultSettings = {
				pushFollowers: true,
				spacerClass: "scrollmagic-pin-spacer"
			};
			settings = _util.extend({}, defaultSettings, settings);

			// validate Element
			element = _util.get.elements(element)[0];
			if (!element) {
				log(1, "ERROR calling method 'setPin()': Invalid pin element supplied.");
				return Scene; // cancel
			} else if (_util.css(element, "position") === "fixed") {
				log(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'.");
				return Scene; // cancel
			}

			if (_pin) {
				// preexisting pin?
				if (_pin === element) {
					// same pin we already have -> do nothing
					return Scene; // cancel
				} else {
					// kill old pin
					Scene.removePin();
				}
			}
			_pin = element;

			var parentDisplay = _pin.parentNode.style.display,
			    boundsParams = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];

			_pin.parentNode.style.display = 'none'; // hack start to force css to return stylesheet values instead of calculated px values.
			var inFlow = _util.css(_pin, "position") != "absolute",
			    pinCSS = _util.css(_pin, boundsParams.concat(["display"])),
			    sizeCSS = _util.css(_pin, ["width", "height"]);
			_pin.parentNode.style.display = parentDisplay; // hack end.
			if (!inFlow && settings.pushFollowers) {
				log(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled.");
				settings.pushFollowers = false;
			}
			window.setTimeout(function () {
				// wait until all finished, because with responsive duration it will only be set after scene is added to controller
				if (_pin && _options.duration === 0 && settings.pushFollowers) {
					log(2, "WARNING: pushFollowers =", true, "has no effect, when scene duration is 0.");
				}
			}, 0);

			// create spacer and insert
			var spacer = _pin.parentNode.insertBefore(document.createElement('div'), _pin),
			    spacerCSS = _util.extend(pinCSS, {
				position: inFlow ? "relative" : "absolute",
				boxSizing: "content-box",
				mozBoxSizing: "content-box",
				webkitBoxSizing: "content-box"
			});

			if (!inFlow) {
				// copy size if positioned absolutely, to work for bottom/right positioned elements.
				_util.extend(spacerCSS, _util.css(_pin, ["width", "height"]));
			}

			_util.css(spacer, spacerCSS);
			spacer.setAttribute(PIN_SPACER_ATTRIBUTE, "");
			_util.addClass(spacer, settings.spacerClass);

			// set the pin Options
			_pinOptions = {
				spacer: spacer,
				relSize: { // save if size is defined using % values. if so, handle spacer resize differently...
					width: sizeCSS.width.slice(-1) === "%",
					height: sizeCSS.height.slice(-1) === "%",
					autoFullWidth: sizeCSS.width === "auto" && inFlow && _util.isMarginCollapseType(pinCSS.display)
				},
				pushFollowers: settings.pushFollowers,
				inFlow: inFlow
			};

			if (!_pin.___origStyle) {
				_pin.___origStyle = {};
				var pinInlineCSS = _pin.style,
				    copyStyles = boundsParams.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]);
				copyStyles.forEach(function (val) {
					_pin.___origStyle[val] = pinInlineCSS[val] || "";
				});
			}

			// if relative size, transfer it to spacer and make pin calculate it...
			if (_pinOptions.relSize.width) {
				_util.css(spacer, {
					width: sizeCSS.width
				});
			}
			if (_pinOptions.relSize.height) {
				_util.css(spacer, {
					height: sizeCSS.height
				});
			}

			// now place the pin element inside the spacer	
			spacer.appendChild(_pin);
			// and set new css
			_util.css(_pin, {
				position: inFlow ? "relative" : "absolute",
				margin: "auto",
				top: "auto",
				left: "auto",
				bottom: "auto",
				right: "auto"
			});

			if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
				_util.css(_pin, {
					boxSizing: "border-box",
					mozBoxSizing: "border-box",
					webkitBoxSizing: "border-box"
				});
			}

			// add listener to document to update pin position in case controller is not the document.
			window.addEventListener('scroll', updatePinInContainer);
			window.addEventListener('resize', updatePinInContainer);
			window.addEventListener('resize', updateRelativePinSpacer);
			// add mousewheel listener to catch scrolls over fixed elements
			_pin.addEventListener("mousewheel", onMousewheelOverPin);
			_pin.addEventListener("DOMMouseScroll", onMousewheelOverPin);

			log(3, "added pin");

			// finally update the pin to init
			updatePinState();

			return Scene;
		};

		/**
   * Remove the pin from the scene.
   * @method ScrollMagic.Scene#removePin
   * @example
   * // remove the pin from the scene without resetting it (the spacer is not removed)
   * scene.removePin();
   *
   * // remove the pin from the scene and reset the pin element to its initial position (spacer is removed)
   * scene.removePin(true);
   *
   * @param {boolean} [reset=false] - If `false` the spacer will not be removed and the element's position will not be reset.
   * @returns {Scene} Parent object for chaining.
   */
		this.removePin = function (reset) {
			if (_pin) {
				if (_state === SCENE_STATE_DURING) {
					updatePinState(true); // force unpin at position
				}
				if (reset || !_controller) {
					// if there's no controller no progress was made anyway...
					var pinTarget = _pinOptions.spacer.firstChild; // usually the pin element, but may be another spacer (cascaded pins)...
					if (pinTarget.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						// copy margins to child spacer
						var style = _pinOptions.spacer.style,
						    values = ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
						margins = {};
						values.forEach(function (val) {
							margins[val] = style[val] || "";
						});
						_util.css(pinTarget, margins);
					}
					_pinOptions.spacer.parentNode.insertBefore(pinTarget, _pinOptions.spacer);
					_pinOptions.spacer.parentNode.removeChild(_pinOptions.spacer);
					if (!_pin.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						// if it's the last pin for this element -> restore inline styles
						// TODO: only correctly set for first pin (when cascading) - how to fix?
						_util.css(_pin, _pin.___origStyle);
						delete _pin.___origStyle;
					}
				}
				window.removeEventListener('scroll', updatePinInContainer);
				window.removeEventListener('resize', updatePinInContainer);
				window.removeEventListener('resize', updateRelativePinSpacer);
				_pin.removeEventListener("mousewheel", onMousewheelOverPin);
				_pin.removeEventListener("DOMMouseScroll", onMousewheelOverPin);
				_pin = undefined;
				log(3, "removed pin (reset: " + (reset ? "true" : "false") + ")");
			}
			return Scene;
		};

		var _cssClasses,
		    _cssClassElems = [];

		Scene.on("destroy.internal", function (e) {
			Scene.removeClassToggle(e.reset);
		});
		/**
   * Define a css class modification while the scene is active.  
   * When the scene triggers the classes will be added to the supplied element and removed, when the scene is over.
   * If the scene duration is 0 the classes will only be removed if the user scrolls back past the start position.
   * @method ScrollMagic.Scene#setClassToggle
   * @example
   * // add the class 'myclass' to the element with the id 'my-elem' for the duration of the scene
   * scene.setClassToggle("#my-elem", "myclass");
   *
   * // add multiple classes to multiple elements defined by the selector '.classChange'
   * scene.setClassToggle(".classChange", "class1 class2 class3");
   *
   * @param {(string|object)} element - A Selector targeting one or more elements or a DOM object that is supposed to be modified.
   * @param {string} classes - One or more Classnames (separated by space) that should be added to the element during the scene.
   *
   * @returns {Scene} Parent object for chaining.
   */
		this.setClassToggle = function (element, classes) {
			var elems = _util.get.elements(element);
			if (elems.length === 0 || !_util.type.String(classes)) {
				log(1, "ERROR calling method 'setClassToggle()': Invalid " + (elems.length === 0 ? "element" : "classes") + " supplied.");
				return Scene;
			}
			if (_cssClassElems.length > 0) {
				// remove old ones
				Scene.removeClassToggle();
			}
			_cssClasses = classes;
			_cssClassElems = elems;
			Scene.on("enter.internal_class leave.internal_class", function (e) {
				var toggle = e.type === "enter" ? _util.addClass : _util.removeClass;
				_cssClassElems.forEach(function (elem, key) {
					toggle(elem, _cssClasses);
				});
			});
			return Scene;
		};

		/**
   * Remove the class binding from the scene.
   * @method ScrollMagic.Scene#removeClassToggle
   * @example
   * // remove class binding from the scene without reset
   * scene.removeClassToggle();
   *
   * // remove class binding and remove the changes it caused
   * scene.removeClassToggle(true);
   *
   * @param {boolean} [reset=false] - If `false` and the classes are currently active, they will remain on the element. If `true` they will be removed.
   * @returns {Scene} Parent object for chaining.
   */
		this.removeClassToggle = function (reset) {
			if (reset) {
				_cssClassElems.forEach(function (elem, key) {
					_util.removeClass(elem, _cssClasses);
				});
			}
			Scene.off("start.internal_class end.internal_class");
			_cssClasses = undefined;
			_cssClassElems = [];
			return Scene;
		};

		// INIT
		construct();
		return Scene;
	};

	// store pagewide scene options
	var SCENE_OPTIONS = {
		defaults: {
			duration: 0,
			offset: 0,
			triggerElement: undefined,
			triggerHook: 0.5,
			reverse: true,
			loglevel: 2
		},
		validate: {
			offset: function (val) {
				val = parseFloat(val);
				if (!_util.type.Number(val)) {
					throw ["Invalid value for option \"offset\":", val];
				}
				return val;
			},
			triggerElement: function (val) {
				val = val || undefined;
				if (val) {
					var elem = _util.get.elements(val)[0];
					if (elem) {
						val = elem;
					} else {
						throw ["Element defined in option \"triggerElement\" was not found:", val];
					}
				}
				return val;
			},
			triggerHook: function (val) {
				var translate = {
					"onCenter": 0.5,
					"onEnter": 1,
					"onLeave": 0
				};
				if (_util.type.Number(val)) {
					val = Math.max(0, Math.min(parseFloat(val), 1)); //  make sure its betweeen 0 and 1
				} else if (val in translate) {
					val = translate[val];
				} else {
					throw ["Invalid value for option \"triggerHook\": ", val];
				}
				return val;
			},
			reverse: function (val) {
				return !!val; // force boolean
			},
			loglevel: function (val) {
				val = parseInt(val);
				if (!_util.type.Number(val) || val < 0 || val > 3) {
					throw ["Invalid value for option \"loglevel\":", val];
				}
				return val;
			}
		},
		// holder for  validation methods. duration validation is handled in 'getters-setters.js'
		shifts: ["duration", "offset", "triggerHook"]
	};
	/*
  * method used to add an option to ScrollMagic Scenes.
  * TODO: DOC (private for dev)
  */
	ScrollMagic.Scene.addOption = function (name, defaultValue, validationCallback, shifts) {
		if (!(name in SCENE_OPTIONS.defaults)) {
			SCENE_OPTIONS.defaults[name] = defaultValue;
			SCENE_OPTIONS.validate[name] = validationCallback;
			if (shifts) {
				SCENE_OPTIONS.shifts.push(name);
			}
		} else {
			ScrollMagic._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + name + "', because it already exists.");
		}
	};
	// instance extension function for plugins
	// TODO: DOC (private for dev)
	ScrollMagic.Scene.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Scene = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Scene, oldClass); // copy properties
		ScrollMagic.Scene.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Scene.prototype.constructor = ScrollMagic.Scene; // restore constructor
	};

	/**
  * TODO: DOCS (private for dev)
  * @class
  * @private
  */

	ScrollMagic.Event = function (type, namespace, target, vars) {
		vars = vars || {};
		for (var key in vars) {
			this[key] = vars[key];
		}
		this.type = type;
		this.target = this.currentTarget = target;
		this.namespace = namespace || '';
		this.timeStamp = this.timestamp = Date.now();
		return this;
	};

	/*
  * TODO: DOCS (private for dev)
  */

	var _util = ScrollMagic._util = function (window) {
		var U = {},
		    i;

		/**
   * ------------------------------
   * internal helpers
   * ------------------------------
   */

		// parse float and fall back to 0.
		var floatval = function (number) {
			return parseFloat(number) || 0;
		};
		// get current style IE safe (otherwise IE would return calculated values for 'auto')
		var _getComputedStyle = function (elem) {
			return elem.currentStyle ? elem.currentStyle : window.getComputedStyle(elem);
		};

		// get element dimension (width or height)
		var _dimension = function (which, elem, outer, includeMargin) {
			elem = elem === document ? window : elem;
			if (elem === window) {
				includeMargin = false;
			} else if (!_type.DomElement(elem)) {
				return 0;
			}
			which = which.charAt(0).toUpperCase() + which.substr(1).toLowerCase();
			var dimension = (outer ? elem['offset' + which] || elem['outer' + which] : elem['client' + which] || elem['inner' + which]) || 0;
			if (outer && includeMargin) {
				var style = _getComputedStyle(elem);
				dimension += which === 'Height' ? floatval(style.marginTop) + floatval(style.marginBottom) : floatval(style.marginLeft) + floatval(style.marginRight);
			}
			return dimension;
		};
		// converts 'margin-top' into 'marginTop'
		var _camelCase = function (str) {
			return str.replace(/^[^a-z]+([a-z])/g, '$1').replace(/-([a-z])/g, function (g) {
				return g[1].toUpperCase();
			});
		};

		/**
   * ------------------------------
   * external helpers
   * ------------------------------
   */

		// extend obj – same as jQuery.extend({}, objA, objB)
		U.extend = function (obj) {
			obj = obj || {};
			for (i = 1; i < arguments.length; i++) {
				if (!arguments[i]) {
					continue;
				}
				for (var key in arguments[i]) {
					if (arguments[i].hasOwnProperty(key)) {
						obj[key] = arguments[i][key];
					}
				}
			}
			return obj;
		};

		// check if a css display type results in margin-collapse or not
		U.isMarginCollapseType = function (str) {
			return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(str) > -1;
		};

		// implementation of requestAnimationFrame
		// based on https://gist.github.com/paulirish/1579671
		var lastTime = 0,
		    vendors = ['ms', 'moz', 'webkit', 'o'];
		var _requestAnimationFrame = window.requestAnimationFrame;
		var _cancelAnimationFrame = window.cancelAnimationFrame;
		// try vendor prefixes if the above doesn't work
		for (i = 0; !_requestAnimationFrame && i < vendors.length; ++i) {
			_requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
			_cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];
		}

		// fallbacks
		if (!_requestAnimationFrame) {
			_requestAnimationFrame = function (callback) {
				var currTime = new Date().getTime(),
				    timeToCall = Math.max(0, 16 - (currTime - lastTime)),
				    id = window.setTimeout(function () {
					callback(currTime + timeToCall);
				}, timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};
		}
		if (!_cancelAnimationFrame) {
			_cancelAnimationFrame = function (id) {
				window.clearTimeout(id);
			};
		}
		U.rAF = _requestAnimationFrame.bind(window);
		U.cAF = _cancelAnimationFrame.bind(window);

		var loglevels = ["error", "warn", "log"],
		    console = window.console || {};

		console.log = console.log || function () {}; // no console log, well - do nothing then...
		// make sure methods for all levels exist.
		for (i = 0; i < loglevels.length; i++) {
			var method = loglevels[i];
			if (!console[method]) {
				console[method] = console.log; // prefer .log over nothing
			}
		}
		U.log = function (loglevel) {
			if (loglevel > loglevels.length || loglevel <= 0) loglevel = loglevels.length;
			var now = new Date(),
			    time = ("0" + now.getHours()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2) + ":" + ("00" + now.getMilliseconds()).slice(-3),
			    method = loglevels[loglevel - 1],
			    args = Array.prototype.splice.call(arguments, 1),
			    func = Function.prototype.bind.call(console[method], console);
			args.unshift(time);
			func.apply(console, args);
		};

		/**
   * ------------------------------
   * type testing
   * ------------------------------
   */

		var _type = U.type = function (v) {
			return Object.prototype.toString.call(v).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
		};
		_type.String = function (v) {
			return _type(v) === 'string';
		};
		_type.Function = function (v) {
			return _type(v) === 'function';
		};
		_type.Array = function (v) {
			return Array.isArray(v);
		};
		_type.Number = function (v) {
			return !_type.Array(v) && v - parseFloat(v) + 1 >= 0;
		};
		_type.DomElement = function (o) {
			return typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
			o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
		};

		/**
   * ------------------------------
   * DOM Element info
   * ------------------------------
   */
		// always returns a list of matching DOM elements, from a selector, a DOM element or an list of elements or even an array of selectors
		var _get = U.get = {};
		_get.elements = function (selector) {
			var arr = [];
			if (_type.String(selector)) {
				try {
					selector = document.querySelectorAll(selector);
				} catch (e) {
					// invalid selector
					return arr;
				}
			}
			if (_type(selector) === 'nodelist' || _type.Array(selector)) {
				for (var i = 0, ref = arr.length = selector.length; i < ref; i++) {
					// list of elements
					var elem = selector[i];
					arr[i] = _type.DomElement(elem) ? elem : _get.elements(elem); // if not an element, try to resolve recursively
				}
			} else if (_type.DomElement(selector) || selector === document || selector === window) {
				arr = [selector]; // only the element
			}
			return arr;
		};
		// get scroll top value
		_get.scrollTop = function (elem) {
			return elem && typeof elem.scrollTop === 'number' ? elem.scrollTop : window.pageYOffset || 0;
		};
		// get scroll left value
		_get.scrollLeft = function (elem) {
			return elem && typeof elem.scrollLeft === 'number' ? elem.scrollLeft : window.pageXOffset || 0;
		};
		// get element height
		_get.width = function (elem, outer, includeMargin) {
			return _dimension('width', elem, outer, includeMargin);
		};
		// get element width
		_get.height = function (elem, outer, includeMargin) {
			return _dimension('height', elem, outer, includeMargin);
		};

		// get element position (optionally relative to viewport)
		_get.offset = function (elem, relativeToViewport) {
			var offset = {
				top: 0,
				left: 0
			};
			if (elem && elem.getBoundingClientRect) {
				// check if available
				var rect = elem.getBoundingClientRect();
				offset.top = rect.top;
				offset.left = rect.left;
				if (!relativeToViewport) {
					// clientRect is by default relative to viewport...
					offset.top += _get.scrollTop();
					offset.left += _get.scrollLeft();
				}
			}
			return offset;
		};

		/**
   * ------------------------------
   * DOM Element manipulation
   * ------------------------------
   */

		U.addClass = function (elem, classname) {
			if (classname) {
				if (elem.classList) elem.classList.add(classname);else elem.className += ' ' + classname;
			}
		};
		U.removeClass = function (elem, classname) {
			if (classname) {
				if (elem.classList) elem.classList.remove(classname);else elem.className = elem.className.replace(new RegExp('(^|\\b)' + classname.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
			}
		};
		// if options is string -> returns css value
		// if options is array -> returns object with css value pairs
		// if options is object -> set new css values
		U.css = function (elem, options) {
			if (_type.String(options)) {
				return _getComputedStyle(elem)[_camelCase(options)];
			} else if (_type.Array(options)) {
				var obj = {},
				    style = _getComputedStyle(elem);
				options.forEach(function (option, key) {
					obj[option] = style[_camelCase(option)];
				});
				return obj;
			} else {
				for (var option in options) {
					var val = options[option];
					if (val == parseFloat(val)) {
						// assume pixel for seemingly numerical values
						val += 'px';
					}
					elem.style[_camelCase(option)] = val;
				}
			}
		};

		return U;
	}(window || {});

	ScrollMagic.Scene.prototype.addIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	};
	ScrollMagic.Scene.prototype.setTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	};
	ScrollMagic.Scene.prototype.setVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	};
	ScrollMagic.Scene.prototype.removeVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	};

	return ScrollMagic;
});
'use strict';

/*!
 * ScrollMagic v2.0.5 (2015-04-29)
 * The javascript library for magical scroll interactions.
 * (c) 2015 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.5
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic GSAP Animation Plugin.
 *
 * requires: GSAP ~1.14
 * Powered by the Greensock Animation Platform (GSAP): http://www.greensock.com/js
 * Greensock License info at http://www.greensock.com/licensing/
 */
/**
 * This plugin is meant to be used in conjunction with the Greensock Animation Plattform.  
 * It offers an easy API to trigger Tweens or synchronize them to the scrollbar movement.
 *
 * Both the `lite` and the `max` versions of the GSAP library are supported.  
 * The most basic requirement is `TweenLite`.
 * 
 * To have access to this extension, please include `plugins/animation.gsap.js`.
 * @requires {@link http://greensock.com/gsap|GSAP ~1.14.x}
 * @mixin animation.GSAP
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['ScrollMagic', 'TweenMax', 'TimelineMax'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		// Loads whole gsap package onto global scope.
		require('gsap');
		factory(require('scrollmagic'), TweenMax, TimelineMax);
	} else {
		// Browser globals
		factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic, root.TweenMax || root.TweenLite, root.TimelineMax || root.TimelineLite);
	}
})(this, function (ScrollMagic, Tween, Timeline) {
	"use strict";

	var NAMESPACE = "animation.gsap";

	var console = window.console || {},
	    err = Function.prototype.bind.call(console.error || console.log || function () {}, console);
	if (!ScrollMagic) {
		err("(" + NAMESPACE + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs.");
	}
	if (!Tween) {
		err("(" + NAMESPACE + ") -> ERROR: TweenLite or TweenMax could not be found. Please make sure GSAP is loaded before ScrollMagic or use an asynchronous loader like requirejs.");
	}

	/*
 	 * ----------------------------------------------------------------
 	 * Extensions for Scene
 	 * ----------------------------------------------------------------
 	 */
	/**
  * Every instance of ScrollMagic.Scene now accepts an additional option.  
  * See {@link ScrollMagic.Scene} for a complete list of the standard options.
  * @memberof! animation.GSAP#
  * @method new ScrollMagic.Scene(options)
  * @example
  * var scene = new ScrollMagic.Scene({tweenChanges: true});
  *
  * @param {object} [options] - Options for the Scene. The options can be updated at any time.
  * @param {boolean} [options.tweenChanges=false] - Tweens Animation to the progress target instead of setting it.  
  Does not affect animations where duration is `0`.
  */
	/**
  * **Get** or **Set** the tweenChanges option value.  
  * This only affects scenes with a duration. If `tweenChanges` is `true`, the progress update when scrolling will not be immediate, but instead the animation will smoothly animate to the target state.  
  * For a better understanding, try enabling and disabling this option in the [Scene Manipulation Example](../examples/basic/scene_manipulation.html).
  * @memberof! animation.GSAP#
  * @method Scene.tweenChanges
  * 
  * @example
  * // get the current tweenChanges option
  * var tweenChanges = scene.tweenChanges();
  *
  * // set new tweenChanges option
  * scene.tweenChanges(true);
  *
  * @fires {@link Scene.change}, when used as setter
  * @param {boolean} [newTweenChanges] - The new tweenChanges setting of the scene.
  * @returns {boolean} `get` -  Current tweenChanges option value.
  * @returns {Scene} `set` -  Parent object for chaining.
  */
	// add option (TODO: DOC (private for dev))
	ScrollMagic.Scene.addOption("tweenChanges", // name
	false, // default


	function (val) {
		// validation callback
		return !!val;
	});
	// extend scene
	ScrollMagic.Scene.extend(function () {
		var Scene = this,
		    _tween;

		var log = function () {
			if (Scene._log) {
				// not available, when main source minified
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
				Scene._log.apply(this, arguments);
			}
		};

		// set listeners
		Scene.on("progress.plugin_gsap", function () {
			updateTweenProgress();
		});
		Scene.on("destroy.plugin_gsap", function (e) {
			Scene.removeTween(e.reset);
		});

		/**
   * Update the tween progress to current position.
   * @private
   */
		var updateTweenProgress = function () {
			if (_tween) {
				var progress = Scene.progress(),
				    state = Scene.state();
				if (_tween.repeat && _tween.repeat() === -1) {
					// infinite loop, so not in relation to progress
					if (state === 'DURING' && _tween.paused()) {
						_tween.play();
					} else if (state !== 'DURING' && !_tween.paused()) {
						_tween.pause();
					}
				} else if (progress != _tween.progress()) {
					// do we even need to update the progress?
					// no infinite loop - so should we just play or go to a specific point in time?
					if (Scene.duration() === 0) {
						// play the animation
						if (progress > 0) {
							// play from 0 to 1
							_tween.play();
						} else {
							// play from 1 to 0
							_tween.reverse();
						}
					} else {
						// go to a specific point in time
						if (Scene.tweenChanges() && _tween.tweenTo) {
							// go smooth
							_tween.tweenTo(progress * _tween.duration());
						} else {
							// just hard set it
							_tween.progress(progress).pause();
						}
					}
				}
			}
		};

		/**
   * Add a tween to the scene.  
   * If you want to add multiple tweens, add them into a GSAP Timeline object and supply it instead (see example below).  
   * 
   * If the scene has a duration, the tween's duration will be projected to the scroll distance of the scene, meaning its progress will be synced to scrollbar movement.  
   * For a scene with a duration of `0`, the tween will be triggered when scrolling forward past the scene's trigger position and reversed, when scrolling back.  
   * To gain better understanding, check out the [Simple Tweening example](../examples/basic/simple_tweening.html).
   *
   * Instead of supplying a tween this method can also be used as a shorthand for `TweenMax.to()` (see example below).
   * @memberof! animation.GSAP#
   *
   * @example
   * // add a single tween directly
   * scene.setTween(TweenMax.to("obj"), 1, {x: 100});
   *
   * // add a single tween via variable
   * var tween = TweenMax.to("obj"), 1, {x: 100};
   * scene.setTween(tween);
   *
   * // add multiple tweens, wrapped in a timeline.
   * var timeline = new TimelineMax();
   * var tween1 = TweenMax.from("obj1", 1, {x: 100});
   * var tween2 = TweenMax.to("obj2", 1, {y: 100});
   * timeline
   *		.add(tween1)
   *		.add(tween2);
   * scene.addTween(timeline);
   *
   * // short hand to add a TweenMax.to() tween
   * scene.setTween("obj3", 0.5, {y: 100});
   *
   * // short hand to add a TweenMax.to() tween for 1 second
   * // this is useful, when the scene has a duration and the tween duration isn't important anyway
   * scene.setTween("obj3", {y: 100});
   *
   * @param {(object|string)} TweenObject - A TweenMax, TweenLite, TimelineMax or TimelineLite object that should be animated in the scene. Can also be a Dom Element or Selector, when using direct tween definition (see examples).
   * @param {(number|object)} duration - A duration for the tween, or tween parameters. If an object containing parameters are supplied, a default duration of 1 will be used.
   * @param {object} params - The parameters for the tween
   * @returns {Scene} Parent object for chaining.
   */
		Scene.setTween = function (TweenObject, duration, params) {
			var newTween;
			if (arguments.length > 1) {
				if (arguments.length < 3) {
					params = duration;
					duration = 1;
				}
				TweenObject = Tween.to(TweenObject, duration, params);
			}
			try {
				// wrap Tween into a Timeline Object if available to include delay and repeats in the duration and standardize methods.
				if (Timeline) {
					newTween = new Timeline({
						smoothChildTiming: true
					}).add(TweenObject);
				} else {
					newTween = TweenObject;
				}
				newTween.pause();
			} catch (e) {
				log(1, "ERROR calling method 'setTween()': Supplied argument is not a valid TweenObject");
				return Scene;
			}
			if (_tween) {
				// kill old tween?
				Scene.removeTween();
			}
			_tween = newTween;

			// some properties need to be transferred it to the wrapper, otherwise they would get lost.
			if (TweenObject.repeat && TweenObject.repeat() === -1) {
				// TweenMax or TimelineMax Object?
				_tween.repeat(-1);
				_tween.yoyo(TweenObject.yoyo());
			}
			// Some tween validations and debugging helpers
			if (Scene.tweenChanges() && !_tween.tweenTo) {
				log(2, "WARNING: tweenChanges will only work if the TimelineMax object is available for ScrollMagic.");
			}

			// check if there are position tweens defined for the trigger and warn about it :)
			if (_tween && Scene.controller() && Scene.triggerElement() && Scene.loglevel() >= 2) {
				// controller is needed to know scroll direction.
				var triggerTweens = Tween.getTweensOf(Scene.triggerElement()),
				    vertical = Scene.controller().info("vertical");
				triggerTweens.forEach(function (value, index) {
					var tweenvars = value.vars.css || value.vars,
					    condition = vertical ? tweenvars.top !== undefined || tweenvars.bottom !== undefined : tweenvars.left !== undefined || tweenvars.right !== undefined;
					if (condition) {
						log(2, "WARNING: Tweening the position of the trigger element affects the scene timing and should be avoided!");
						return false;
					}
				});
			}

			// warn about tween overwrites, when an element is tweened multiple times
			if (parseFloat(TweenLite.version) >= 1.14) {
				// onOverwrite only present since GSAP v1.14.0
				var list = _tween.getChildren ? _tween.getChildren(true, true, false) : [_tween],

				// get all nested tween objects
				newCallback = function () {
					log(2, "WARNING: tween was overwritten by another. To learn how to avoid this issue see here: https://github.com/janpaepke/ScrollMagic/wiki/WARNING:-tween-was-overwritten-by-another");
				};
				for (var i = 0, thisTween, oldCallback; i < list.length; i++) {
					/*jshint loopfunc: true */
					thisTween = list[i];
					if (oldCallback !== newCallback) {
						// if tweens is added more than once
						oldCallback = thisTween.vars.onOverwrite;
						thisTween.vars.onOverwrite = function () {
							if (oldCallback) {
								oldCallback.apply(this, arguments);
							}
							newCallback.apply(this, arguments);
						};
					}
				}
			}
			log(3, "added tween");

			updateTweenProgress();
			return Scene;
		};

		/**
   * Remove the tween from the scene.  
   * This will terminate the control of the Scene over the tween.
   *
   * Using the reset option you can decide if the tween should remain in the current state or be rewound to set the target elements back to the state they were in before the tween was added to the scene.
   * @memberof! animation.GSAP#
   *
   * @example
   * // remove the tween from the scene without resetting it
   * scene.removeTween();
   *
   * // remove the tween from the scene and reset it to initial position
   * scene.removeTween(true);
   *
   * @param {boolean} [reset=false] - If `true` the tween will be reset to its initial values.
   * @returns {Scene} Parent object for chaining.
   */
		Scene.removeTween = function (reset) {
			if (_tween) {
				if (reset) {
					_tween.progress(0).pause();
				}
				_tween.kill();
				_tween = undefined;
				log(3, "removed tween (reset: " + (reset ? "true" : "false") + ")");
			}
			return Scene;
		};
	});
});
'use strict';

/*! Lazy Load XT v1.0.5 2014-06-05
 * http://ressio.github.io/lazy-load-xt
 * (C) 2014 RESS.io
 * Licensed under MIT */

(function ($, window, document, undefined) {
    // options
    var lazyLoadXT = 'lazyLoadXT',
        dataLazied = 'lazied',
        load_error = 'load error',
        classLazyHidden = 'lazy-hidden',
        docElement = document.documentElement || document.body,

    //  force load all images in Opera Mini and some mobile browsers without scroll event or getBoundingClientRect()
    forceLoad = window.onscroll === undefined || !!window.operamini || !docElement.getBoundingClientRect,
        options = {
        autoInit: true, // auto initialize in $.ready
        selector: 'img[data-src]', // selector for lazyloading elements
        blankImage: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
        throttle: 99, // interval (ms) for changes check
        forceLoad: forceLoad, // force auto load all images

        loadEvent: 'pageshow', // check AJAX-loaded content in jQueryMobile
        updateEvent: 'load orientationchange resize scroll touchmove focus', // page-modified events
        forceEvent: '', // force loading of all elements

        //onstart: null,
        oninit: { removeClass: 'lazy' }, // init handler
        onshow: { addClass: classLazyHidden }, // start loading handler
        onload: { removeClass: classLazyHidden, addClass: 'lazy-loaded' }, // load success handler
        onerror: { removeClass: classLazyHidden }, // error handler
        //oncomplete: null, // complete handler

        //scrollContainer: undefined,
        checkDuplicates: true
    },
        elementOptions = {
        srcAttr: 'data-src',
        edgeX: 0,
        edgeY: 0,
        visibleOnly: true
    },
        $window = $(window),
        $isFunction = $.isFunction,
        $extend = $.extend,
        $data = $.data || function (el, name) {
        return $(el).data(name);
    },

    // $.contains is not included into DOMtastic, so implement it there
    $contains = $.contains || function (parent, el) {
        while (el = el.parentNode) {
            if (el === parent) {
                return true;
            }
        }
        return false;
    },
        elements = [],
        topLazy = 0,

    /*
     waitingMode=0 : no setTimeout
     waitingMode=1 : setTimeout, no deferred events
     waitingMode=2 : setTimeout, deferred events
     */
    waitingMode = 0;

    $[lazyLoadXT] = $extend(options, elementOptions, $[lazyLoadXT]);

    /**
     * Return options.prop if obj.prop is undefined, otherwise return obj.prop
     * @param {*} obj
     * @param {*} prop
     * @returns *
     */
    function getOrDef(obj, prop) {
        return obj[prop] === undefined ? options[prop] : obj[prop];
    }

    /**
     * @returns {number}
     */
    function scrollTop() {
        var scroll = window.pageYOffset;
        return scroll === undefined ? docElement.scrollTop : scroll;
    }

    /**
     * Add new elements to lazy-load list:
     * $(elements).lazyLoadXT() or $(window).lazyLoadXT()
     *
     * @param {object} [overrides] override global options
     */
    $.fn[lazyLoadXT] = function (overrides) {
        overrides = overrides || {};

        var blankImage = getOrDef(overrides, 'blankImage'),
            checkDuplicates = getOrDef(overrides, 'checkDuplicates'),
            scrollContainer = getOrDef(overrides, 'scrollContainer'),
            elementOptionsOverrides = {},
            prop;

        // empty overrides.scrollContainer is supported by both jQuery and Zepto
        $(scrollContainer).on('scroll', queueCheckLazyElements);

        for (prop in elementOptions) {
            elementOptionsOverrides[prop] = getOrDef(overrides, prop);
        }

        return this.each(function (index, el) {
            if (el === window) {
                $(options.selector).lazyLoadXT(overrides);
            } else {
                // prevent duplicates
                if (checkDuplicates && $data(el, dataLazied)) {
                    return;
                }

                var $el = $(el).data(dataLazied, 1);

                if (blankImage && el.tagName === 'IMG' && !el.src) {
                    el.src = blankImage;
                }

                // clone elementOptionsOverrides object
                $el[lazyLoadXT] = $extend({}, elementOptionsOverrides);

                triggerEvent('init', $el);

                elements.push($el);
            }
        });
    };

    /**
     * Process function/object event handler
     * @param {string} event suffix
     * @param {jQuery} $el
     */
    function triggerEvent(event, $el) {
        var handler = options['on' + event];
        if (handler) {
            if ($isFunction(handler)) {
                handler.call($el[0]);
            } else {
                if (handler.addClass) {
                    $el.addClass(handler.addClass);
                }
                if (handler.removeClass) {
                    $el.removeClass(handler.removeClass);
                }
            }
        }

        $el.trigger('lazy' + event, [$el]);

        // queue next check as images may be resized after loading of actual file
        queueCheckLazyElements();
    }

    /**
     * Trigger onload/onerror handler
     * @param {Event} e
     */
    function triggerLoadOrError(e) {
        triggerEvent(e.type, $(this).off(load_error, triggerLoadOrError));
    }

    /**
     * Load visible elements
     * @param {bool} [force] loading of all elements
     */
    function checkLazyElements(force) {
        if (!elements.length) {
            return;
        }

        force = force || options.forceLoad;

        topLazy = Infinity;

        var viewportTop = scrollTop(),
            viewportHeight = window.innerHeight || docElement.clientHeight,
            viewportWidth = window.innerWidth || docElement.clientWidth,
            i,
            length;

        for (i = 0, length = elements.length; i < length; i++) {
            var $el = elements[i],
                el = $el[0],
                objData = $el[lazyLoadXT],
                removeNode = false,
                visible = force,
                topEdge;

            // remove items that are not in DOM
            if (!$contains(docElement, el)) {
                removeNode = true;
            } else if (force || !objData.visibleOnly || el.offsetWidth || el.offsetHeight) {

                if (!visible) {
                    var elPos = el.getBoundingClientRect(),
                        edgeX = objData.edgeX,
                        edgeY = objData.edgeY;

                    topEdge = elPos.top + viewportTop - edgeY - viewportHeight;

                    visible = topEdge <= viewportTop && elPos.bottom > -edgeY && elPos.left <= viewportWidth + edgeX && elPos.right > -edgeX;
                }

                if (visible) {
                    triggerEvent('show', $el);

                    var srcAttr = objData.srcAttr,
                        src = $isFunction(srcAttr) ? srcAttr($el) : el.getAttribute(srcAttr);
                    if (src) {
                        $el.on(load_error, triggerLoadOrError);
                        el.src = src;
                    }

                    removeNode = true;
                } else {
                    if (topEdge < topLazy) {
                        topLazy = topEdge;
                    }
                }
            }

            if (removeNode) {
                elements.splice(i--, 1);
                length--;
            }
        }

        if (!length) {
            triggerEvent('complete', $(docElement));
        }
    }

    /**
     * Run check of lazy elements after timeout
     */
    function timeoutLazyElements() {
        if (waitingMode > 1) {
            waitingMode = 1;
            checkLazyElements();
            setTimeout(timeoutLazyElements, options.throttle);
        } else {
            waitingMode = 0;
        }
    }

    /**
     * Queue check of lazy elements because of event e
     * @param {Event} [e]
     */
    function queueCheckLazyElements(e) {
        if (!elements.length) {
            return;
        }

        // fast check for scroll event without new visible elements
        if (e && e.type === 'scroll' && e.currentTarget === window) {
            if (topLazy >= scrollTop()) {
                return;
            }
        }

        if (!waitingMode) {
            setTimeout(timeoutLazyElements, 0);
        }
        waitingMode = 2;
    }

    /**
     * Initialize list of hidden elements
     */
    function initLazyElements() {
        $window.lazyLoadXT();
    }

    /**
     * Loading of all elements
     */
    function forceLoadAll() {
        checkLazyElements(true);
    }

    /**
     * Initialization
     */
    $(document).ready(function () {
        triggerEvent('start', $window);

        $window.on(options.loadEvent, initLazyElements).on(options.updateEvent, queueCheckLazyElements).on(options.forceEvent, forceLoadAll);

        $(document).on(options.updateEvent, queueCheckLazyElements);

        if (options.autoInit) {
            initLazyElements(); // standard initialization
        }
    });
})(window.jQuery || window.Zepto || window.$, window, document);
'use strict';

/*! Lazy Load XT v1.0.5 2014-06-05
 * http://ressio.github.io/lazy-load-xt
 * (C) 2014 RESS.io
 * Licensed under MIT */

(function ($) {
    var options = $.lazyLoadXT;

    options.forceEvent += ' lazyautoload';
    options.autoLoadTime = options.autoLoadTime || 50;

    $(document).ready(function () {
        setTimeout(function () {
            $(window).trigger('lazyautoload');
        }, options.autoLoadTime);
    });
})(window.jQuery || window.Zepto || window.$);
'use strict';

/*! Lazy Load XT v1.0.5 2014-06-05
 * http://ressio.github.io/lazy-load-xt
 * (C) 2014 RESS.io
 * Licensed under MIT */

(function ($) {
    var options = $.lazyLoadXT,
        bgAttr = options.bgAttr || 'data-bg';

    options.selector += ',[' + bgAttr + ']';

    $(document).on('lazyshow', function (e) {
        var $this = $(e.target);
        $this.css('background-image', "url('" + $this.attr(bgAttr) + "')").removeAttr(bgAttr);
    });
})(window.jQuery || window.Zepto || window.$);
!function ($) {

  "use strict";

  var FOUNDATION_VERSION = '6.2.1';

  // Global Foundation object
  // This is attached to the window, or used as a module for AMD/Browserify
  var Foundation = {
    version: FOUNDATION_VERSION,

    /**
     * Stores initialized plugins.
     */
    _plugins: {},

    /**
     * Stores generated unique ids for plugin instances
     */
    _uuids: [],

    /**
     * Returns a boolean for RTL support
     */
    rtl: function () {
      return $('html').attr('dir') === 'rtl';
    },
    /**
     * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.
     * @param {Object} plugin - The constructor of the plugin.
     */
    plugin: function (plugin, name) {
      // Object key to use when adding to global Foundation object
      // Examples: Foundation.Reveal, Foundation.OffCanvas
      var className = name || functionName(plugin);
      // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin
      // Examples: data-reveal, data-off-canvas
      var attrName = hyphenate(className);

      // Add to the Foundation object and the plugins list (for reflowing)
      this._plugins[attrName] = this[className] = plugin;
    },
    /**
     * @function
     * Populates the _uuids array with pointers to each individual plugin instance.
     * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.
     * Also fires the initialization event for each plugin, consolidating repeditive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @param {String} name - the name of the plugin, passed as a camelCased string.
     * @fires Plugin#init
     */
    registerPlugin: function (plugin, name) {
      var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();
      plugin.uuid = this.GetYoDigits(6, pluginName);

      if (!plugin.$element.attr('data-' + pluginName)) {
        plugin.$element.attr('data-' + pluginName, plugin.uuid);
      }
      if (!plugin.$element.data('zfPlugin')) {
        plugin.$element.data('zfPlugin', plugin);
      }
      /**
       * Fires when the plugin has initialized.
       * @event Plugin#init
       */
      plugin.$element.trigger('init.zf.' + pluginName);

      this._uuids.push(plugin.uuid);

      return;
    },
    /**
     * @function
     * Removes the plugins uuid from the _uuids array.
     * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.
     * Also fires the destroyed event for the plugin, consolidating repeditive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @fires Plugin#destroyed
     */
    unregisterPlugin: function (plugin) {
      var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));

      this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);
      plugin.$element.removeAttr('data-' + pluginName).removeData('zfPlugin')
      /**
       * Fires when the plugin has been destroyed.
       * @event Plugin#destroyed
       */
      .trigger('destroyed.zf.' + pluginName);
      for (var prop in plugin) {
        plugin[prop] = null; //clean up script to prep for garbage collection.
      }
      return;
    },

    /**
     * @function
     * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.
     * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`
     * @default If no argument is passed, reflow all currently active plugins.
     */
    reInit: function (plugins) {
      var isJQ = plugins instanceof $;
      try {
        if (isJQ) {
          plugins.each(function () {
            $(this).data('zfPlugin')._init();
          });
        } else {
          var type = typeof plugins,
              _this = this,
              fns = {
            'object': function (plgs) {
              plgs.forEach(function (p) {
                p = hyphenate(p);
                $('[data-' + p + ']').foundation('_init');
              });
            },
            'string': function () {
              plugins = hyphenate(plugins);
              $('[data-' + plugins + ']').foundation('_init');
            },
            'undefined': function () {
              this['object'](Object.keys(_this._plugins));
            }
          };
          fns[type](plugins);
        }
      } catch (err) {
        console.error(err);
      } finally {
        return plugins;
      }
    },

    /**
     * returns a random base-36 uid with namespacing
     * @function
     * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.
     * @param {String} namespace - name of plugin to be incorporated in uid, optional.
     * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.
     * @returns {String} - unique id
     */
    GetYoDigits: function (length, namespace) {
      length = length || 6;
      return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? '-' + namespace : '');
    },
    /**
     * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.
     * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.
     * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.
     */
    reflow: function (elem, plugins) {

      // If plugins is undefined, just grab everything
      if (typeof plugins === 'undefined') {
        plugins = Object.keys(this._plugins);
      }
      // If plugins is a string, convert it to an array with one item
      else if (typeof plugins === 'string') {
          plugins = [plugins];
        }

      var _this = this;

      // Iterate through each plugin
      $.each(plugins, function (i, name) {
        // Get the current plugin
        var plugin = _this._plugins[name];

        // Localize the search to all elements inside elem, as well as elem itself, unless elem === document
        var $elem = $(elem).find('[data-' + name + ']').addBack('[data-' + name + ']');

        // For each plugin found, initialize it
        $elem.each(function () {
          var $el = $(this),
              opts = {};
          // Don't double-dip on plugins
          if ($el.data('zfPlugin')) {
            console.warn("Tried to initialize " + name + " on an element that already has a Foundation plugin.");
            return;
          }

          if ($el.attr('data-options')) {
            var thing = $el.attr('data-options').split(';').forEach(function (e, i) {
              var opt = e.split(':').map(function (el) {
                return el.trim();
              });
              if (opt[0]) opts[opt[0]] = parseValue(opt[1]);
            });
          }
          try {
            $el.data('zfPlugin', new plugin($(this), opts));
          } catch (er) {
            console.error(er);
          } finally {
            return;
          }
        });
      });
    },
    getFnName: functionName,
    transitionend: function ($elem) {
      var transitions = {
        'transition': 'transitionend',
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'otransitionend'
      };
      var elem = document.createElement('div'),
          end;

      for (var t in transitions) {
        if (typeof elem.style[t] !== 'undefined') {
          end = transitions[t];
        }
      }
      if (end) {
        return end;
      } else {
        end = setTimeout(function () {
          $elem.triggerHandler('transitionend', [$elem]);
        }, 1);
        return 'transitionend';
      }
    }
  };

  Foundation.util = {
    /**
     * Function for applying a debounce effect to a function call.
     * @function
     * @param {Function} func - Function to be called at end of timeout.
     * @param {Number} delay - Time in ms to delay the call of `func`.
     * @returns function
     */
    throttle: function (func, delay) {
      var timer = null;

      return function () {
        var context = this,
            args = arguments;

        if (timer === null) {
          timer = setTimeout(function () {
            func.apply(context, args);
            timer = null;
          }, delay);
        }
      };
    }
  };

  // TODO: consider not making this a jQuery function
  // TODO: need way to reflow vs. re-initialize
  /**
   * The Foundation jQuery method.
   * @param {String|Array} method - An action to perform on the current jQuery object.
   */
  var foundation = function (method) {
    var type = typeof method,
        $meta = $('meta.foundation-mq'),
        $noJS = $('.no-js');

    if (!$meta.length) {
      $('<meta class="foundation-mq">').appendTo(document.head);
    }
    if ($noJS.length) {
      $noJS.removeClass('no-js');
    }

    if (type === 'undefined') {
      //needs to initialize the Foundation object, or an individual plugin.
      Foundation.MediaQuery._init();
      Foundation.reflow(this);
    } else if (type === 'string') {
      //an individual method to invoke on a plugin or group of plugins
      var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary
      var plugClass = this.data('zfPlugin'); //determine the class of plugin

      if (plugClass !== undefined && plugClass[method] !== undefined) {
        //make sure both the class and method exist
        if (this.length === 1) {
          //if there's only one, call it directly.
          plugClass[method].apply(plugClass, args);
        } else {
          this.each(function (i, el) {
            //otherwise loop through the jQuery collection and invoke the method on each
            plugClass[method].apply($(el).data('zfPlugin'), args);
          });
        }
      } else {
        //error for no class or no method
        throw new ReferenceError("We're sorry, '" + method + "' is not an available method for " + (plugClass ? functionName(plugClass) : 'this element') + '.');
      }
    } else {
      //error for invalid argument type
      throw new TypeError('We\'re sorry, ' + type + ' is not a valid parameter. You must use a string representing the method you wish to invoke.');
    }
    return this;
  };

  window.Foundation = Foundation;
  $.fn.foundation = foundation;

  // Polyfill for requestAnimationFrame
  (function () {
    if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {
      return new Date().getTime();
    };

    var vendors = ['webkit', 'moz'];
    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
      var vp = vendors[i];
      window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
    }
    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
      var lastTime = 0;
      window.requestAnimationFrame = function (callback) {
        var now = Date.now();
        var nextTime = Math.max(lastTime + 16, now);
        return setTimeout(function () {
          callback(lastTime = nextTime);
        }, nextTime - now);
      };
      window.cancelAnimationFrame = clearTimeout;
    }
    /**
     * Polyfill for performance.now, required by rAF
     */
    if (!window.performance || !window.performance.now) {
      window.performance = {
        start: Date.now(),
        now: function () {
          return Date.now() - this.start;
        }
      };
    }
  })();
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
      if (typeof this !== 'function') {
        // closest thing possible to the ECMAScript 5
        // internal IsCallable function
        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
      }

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
      };

      if (this.prototype) {
        // native functions don't have a prototype
        fNOP.prototype = this.prototype;
      }
      fBound.prototype = new fNOP();

      return fBound;
    };
  }
  // Polyfill to get the name of a function in IE9
  function functionName(fn) {
    if (Function.prototype.name === undefined) {
      var funcNameRegex = /function\s([^(]{1,})\(/;
      var results = funcNameRegex.exec(fn.toString());
      return results && results.length > 1 ? results[1].trim() : "";
    } else if (fn.prototype === undefined) {
      return fn.constructor.name;
    } else {
      return fn.prototype.constructor.name;
    }
  }
  function parseValue(str) {
    if (/true/.test(str)) return true;else if (/false/.test(str)) return false;else if (!isNaN(str * 1)) return parseFloat(str);
    return str;
  }
  // Convert PascalCase to kebab-case
  // Thank you: http://stackoverflow.com/a/8955580
  function hyphenate(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }
}(jQuery);
'use strict';

!function ($) {

  Foundation.Box = {
    ImNotTouchingYou: ImNotTouchingYou,
    GetDimensions: GetDimensions,
    GetOffsets: GetOffsets
  };

  /**
   * Compares the dimensions of an element to a container and determines collision events with container.
   * @function
   * @param {jQuery} element - jQuery object to test for collisions.
   * @param {jQuery} parent - jQuery object to use as bounding container.
   * @param {Boolean} lrOnly - set to true to check left and right values only.
   * @param {Boolean} tbOnly - set to true to check top and bottom values only.
   * @default if no parent object passed, detects collisions with `window`.
   * @returns {Boolean} - true if collision free, false if a collision in any direction.
   */
  function ImNotTouchingYou(element, parent, lrOnly, tbOnly) {
    var eleDims = GetDimensions(element),
        top,
        bottom,
        left,
        right;

    if (parent) {
      var parDims = GetDimensions(parent);

      bottom = eleDims.offset.top + eleDims.height <= parDims.height + parDims.offset.top;
      top = eleDims.offset.top >= parDims.offset.top;
      left = eleDims.offset.left >= parDims.offset.left;
      right = eleDims.offset.left + eleDims.width <= parDims.width;
    } else {
      bottom = eleDims.offset.top + eleDims.height <= eleDims.windowDims.height + eleDims.windowDims.offset.top;
      top = eleDims.offset.top >= eleDims.windowDims.offset.top;
      left = eleDims.offset.left >= eleDims.windowDims.offset.left;
      right = eleDims.offset.left + eleDims.width <= eleDims.windowDims.width;
    }

    var allDirs = [bottom, top, left, right];

    if (lrOnly) {
      return left === right === true;
    }

    if (tbOnly) {
      return top === bottom === true;
    }

    return allDirs.indexOf(false) === -1;
  };

  /**
   * Uses native methods to return an object of dimension values.
   * @function
   * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.
   * @returns {Object} - nested object of integer pixel values
   * TODO - if element is window, return only those values.
   */
  function GetDimensions(elem, test) {
    elem = elem.length ? elem[0] : elem;

    if (elem === window || elem === document) {
      throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");
    }

    var rect = elem.getBoundingClientRect(),
        parRect = elem.parentNode.getBoundingClientRect(),
        winRect = document.body.getBoundingClientRect(),
        winY = window.pageYOffset,
        winX = window.pageXOffset;

    return {
      width: rect.width,
      height: rect.height,
      offset: {
        top: rect.top + winY,
        left: rect.left + winX
      },
      parentDims: {
        width: parRect.width,
        height: parRect.height,
        offset: {
          top: parRect.top + winY,
          left: parRect.left + winX
        }
      },
      windowDims: {
        width: winRect.width,
        height: winRect.height,
        offset: {
          top: winY,
          left: winX
        }
      }
    };
  }

  /**
   * Returns an object of top and left integer pixel values for dynamically rendered elements,
   * such as: Tooltip, Reveal, and Dropdown
   * @function
   * @param {jQuery} element - jQuery object for the element being positioned.
   * @param {jQuery} anchor - jQuery object for the element's anchor point.
   * @param {String} position - a string relating to the desired position of the element, relative to it's anchor
   * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.
   * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.
   * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.
   * TODO alter/rewrite to work with `em` values as well/instead of pixels
   */
  function GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {
    var $eleDims = GetDimensions(element),
        $anchorDims = anchor ? GetDimensions(anchor) : null;

    switch (position) {
      case 'top':
        return {
          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top
        };
        break;
      case 'right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset,
          top: $anchorDims.offset.top
        };
        break;
      case 'center top':
        return {
          left: $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
          top: $anchorDims.offset.top - ($eleDims.height + vOffset)
        };
        break;
      case 'center bottom':
        return {
          left: isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
        break;
      case 'center left':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'center right':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset + 1,
          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'center':
        return {
          left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2,
          top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - $eleDims.height / 2
        };
        break;
      case 'reveal':
        return {
          left: ($eleDims.windowDims.width - $eleDims.width) / 2,
          top: $eleDims.windowDims.offset.top + vOffset
        };
      case 'reveal full':
        return {
          left: $eleDims.windowDims.offset.left,
          top: $eleDims.windowDims.offset.top
        };
        break;
      case 'left bottom':
        return {
          left: $anchorDims.offset.left - ($eleDims.width + hOffset),
          top: $anchorDims.offset.top + $anchorDims.height
        };
        break;
      case 'right bottom':
        return {
          left: $anchorDims.offset.left + $anchorDims.width + hOffset - $eleDims.width,
          top: $anchorDims.offset.top + $anchorDims.height
        };
        break;
      default:
        return {
          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
          top: $anchorDims.offset.top + $anchorDims.height + vOffset
        };
    }
  }
}(jQuery);
/*******************************************
 *                                         *
 * This util was created by Marius Olbertz *
 * Please thank Marius on GitHub /owlbertz *
 * or the web http://www.mariusolbertz.de/ *
 *                                         *
 ******************************************/

'use strict';

!function ($) {

  var keyCodes = {
    9: 'TAB',
    13: 'ENTER',
    27: 'ESCAPE',
    32: 'SPACE',
    37: 'ARROW_LEFT',
    38: 'ARROW_UP',
    39: 'ARROW_RIGHT',
    40: 'ARROW_DOWN'
  };

  var commands = {};

  var Keyboard = {
    keys: getKeyCodes(keyCodes),

    /**
     * Parses the (keyboard) event and returns a String that represents its key
     * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
     * @param {Event} event - the event generated by the event handler
     * @return String key - String that represents the key pressed
     */
    parseKey: function (event) {
      var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();
      if (event.shiftKey) key = 'SHIFT_' + key;
      if (event.ctrlKey) key = 'CTRL_' + key;
      if (event.altKey) key = 'ALT_' + key;
      return key;
    },


    /**
     * Handles the given (keyboard) event
     * @param {Event} event - the event generated by the event handler
     * @param {String} component - Foundation component's name, e.g. Slider or Reveal
     * @param {Objects} functions - collection of functions that are to be executed
     */
    handleKey: function (event, component, functions) {
      var commandList = commands[component],
          keyCode = this.parseKey(event),
          cmds,
          command,
          fn;

      if (!commandList) return console.warn('Component not defined!');

      if (typeof commandList.ltr === 'undefined') {
        // this component does not differentiate between ltr and rtl
        cmds = commandList; // use plain list
      } else {
        // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa
        if (Foundation.rtl()) cmds = $.extend({}, commandList.ltr, commandList.rtl);else cmds = $.extend({}, commandList.rtl, commandList.ltr);
      }
      command = cmds[keyCode];

      fn = functions[command];
      if (fn && typeof fn === 'function') {
        // execute function  if exists
        fn.apply();
        if (functions.handled || typeof functions.handled === 'function') {
          // execute function when event was handled
          functions.handled.apply();
        }
      } else {
        if (functions.unhandled || typeof functions.unhandled === 'function') {
          // execute function when event was not handled
          functions.unhandled.apply();
        }
      }
    },


    /**
     * Finds all focusable elements within the given `$element`
     * @param {jQuery} $element - jQuery object to search within
     * @return {jQuery} $focusable - all focusable elements within `$element`
     */
    findFocusable: function ($element) {
      return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {
        if (!$(this).is(':visible') || $(this).attr('tabindex') < 0) {
          return false;
        } //only have visible elements and those that have a tabindex greater or equal 0
        return true;
      });
    },


    /**
     * Returns the component name name
     * @param {Object} component - Foundation component, e.g. Slider or Reveal
     * @return String componentName
     */

    register: function (componentName, cmds) {
      commands[componentName] = cmds;
    }
  };

  /*
   * Constants for easier comparing.
   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
   */
  function getKeyCodes(kcs) {
    var k = {};
    for (var kc in kcs) {
      k[kcs[kc]] = kcs[kc];
    }return k;
  }

  Foundation.Keyboard = Keyboard;
}(jQuery);
'use strict';

!function ($) {

  // Default set of media queries
  var defaultQueries = {
    'default': 'only screen',
    landscape: 'only screen and (orientation: landscape)',
    portrait: 'only screen and (orientation: portrait)',
    retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'
  };

  var MediaQuery = {
    queries: [],

    current: '',

    /**
     * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.
     * @function
     * @private
     */
    _init: function () {
      var self = this;
      var extractedStyles = $('.foundation-mq').css('font-family');
      var namedQueries;

      namedQueries = parseStyleToObject(extractedStyles);

      for (var key in namedQueries) {
        self.queries.push({
          name: key,
          value: 'only screen and (min-width: ' + namedQueries[key] + ')'
        });
      }

      this.current = this._getCurrentSize();

      this._watcher();
    },


    /**
     * Checks if the screen is at least as wide as a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to check.
     * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.
     */
    atLeast: function (size) {
      var query = this.get(size);

      if (query) {
        return window.matchMedia(query).matches;
      }

      return false;
    },


    /**
     * Gets the media query of a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to get.
     * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.
     */
    get: function (size) {
      for (var i in this.queries) {
        var query = this.queries[i];
        if (size === query.name) return query.value;
      }

      return null;
    },


    /**
     * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).
     * @function
     * @private
     * @returns {String} Name of the current breakpoint.
     */
    _getCurrentSize: function () {
      var matched;

      for (var i = 0; i < this.queries.length; i++) {
        var query = this.queries[i];

        if (window.matchMedia(query.value).matches) {
          matched = query;
        }
      }

      if (typeof matched === 'object') {
        return matched.name;
      } else {
        return matched;
      }
    },


    /**
     * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.
     * @function
     * @private
     */
    _watcher: function () {
      var _this = this;

      $(window).on('resize.zf.mediaquery', function () {
        var newSize = _this._getCurrentSize();

        if (newSize !== _this.current) {
          // Broadcast the media query change on the window
          $(window).trigger('changed.zf.mediaquery', [newSize, _this.current]);

          // Change the current media query
          _this.current = newSize;
        }
      });
    }
  };

  Foundation.MediaQuery = MediaQuery;

  // matchMedia() polyfill - Test a CSS media type/query in JS.
  // Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license
  window.matchMedia || (window.matchMedia = function () {
    'use strict';

    // For browsers that support matchMedium api such as IE 9 and webkit

    var styleMedia = window.styleMedia || window.media;

    // For those that don't support matchMedium
    if (!styleMedia) {
      var style = document.createElement('style'),
          script = document.getElementsByTagName('script')[0],
          info = null;

      style.type = 'text/css';
      style.id = 'matchmediajs-test';

      script.parentNode.insertBefore(style, script);

      // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
      info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;

      styleMedia = {
        matchMedium: function (media) {
          var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

          // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
          if (style.styleSheet) {
            style.styleSheet.cssText = text;
          } else {
            style.textContent = text;
          }

          // Test if media query is true or false
          return info.width === '1px';
        }
      };
    }

    return function (media) {
      return {
        matches: styleMedia.matchMedium(media || 'all'),
        media: media || 'all'
      };
    };
  }());

  // Thank you: https://github.com/sindresorhus/query-string
  function parseStyleToObject(str) {
    var styleObject = {};

    if (typeof str !== 'string') {
      return styleObject;
    }

    str = str.trim().slice(1, -1); // browsers re-quote string style values

    if (!str) {
      return styleObject;
    }

    styleObject = str.split('&').reduce(function (ret, param) {
      var parts = param.replace(/\+/g, ' ').split('=');
      var key = parts[0];
      var val = parts[1];
      key = decodeURIComponent(key);

      // missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
      val = val === undefined ? null : decodeURIComponent(val);

      if (!ret.hasOwnProperty(key)) {
        ret[key] = val;
      } else if (Array.isArray(ret[key])) {
        ret[key].push(val);
      } else {
        ret[key] = [ret[key], val];
      }
      return ret;
    }, {});

    return styleObject;
  }

  Foundation.MediaQuery = MediaQuery;
}(jQuery);
'use strict';

!function ($) {

  /**
   * Motion module.
   * @module foundation.motion
   */

  var initClasses = ['mui-enter', 'mui-leave'];
  var activeClasses = ['mui-enter-active', 'mui-leave-active'];

  var Motion = {
    animateIn: function (element, animation, cb) {
      animate(true, element, animation, cb);
    },

    animateOut: function (element, animation, cb) {
      animate(false, element, animation, cb);
    }
  };

  function Move(duration, elem, fn) {
    var anim,
        prog,
        start = null;
    // console.log('called');

    function move(ts) {
      if (!start) start = window.performance.now();
      // console.log(start, ts);
      prog = ts - start;
      fn.apply(elem);

      if (prog < duration) {
        anim = window.requestAnimationFrame(move, elem);
      } else {
        window.cancelAnimationFrame(anim);
        elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
      }
    }
    anim = window.requestAnimationFrame(move);
  }

  /**
   * Animates an element in or out using a CSS transition class.
   * @function
   * @private
   * @param {Boolean} isIn - Defines if the animation is in or out.
   * @param {Object} element - jQuery or HTML object to animate.
   * @param {String} animation - CSS class to use.
   * @param {Function} cb - Callback to run when animation is finished.
   */
  function animate(isIn, element, animation, cb) {
    element = $(element).eq(0);

    if (!element.length) return;

    var initClass = isIn ? initClasses[0] : initClasses[1];
    var activeClass = isIn ? activeClasses[0] : activeClasses[1];

    // Set up the animation
    reset();

    element.addClass(animation).css('transition', 'none');

    requestAnimationFrame(function () {
      element.addClass(initClass);
      if (isIn) element.show();
    });

    // Start the animation
    requestAnimationFrame(function () {
      element[0].offsetWidth;
      element.css('transition', '').addClass(activeClass);
    });

    // Clean up the animation when it finishes
    element.one(Foundation.transitionend(element), finish);

    // Hides the element (for out animations), resets the element, and runs a callback
    function finish() {
      if (!isIn) element.hide();
      reset();
      if (cb) cb.apply(element);
    }

    // Resets transitions and removes motion-specific classes
    function reset() {
      element[0].style.transitionDuration = 0;
      element.removeClass(initClass + ' ' + activeClass + ' ' + animation);
    }
  }

  Foundation.Move = Move;
  Foundation.Motion = Motion;
}(jQuery);
'use strict';

!function ($) {

  var Nest = {
    Feather: function (menu) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'zf';

      menu.attr('role', 'menubar');

      var items = menu.find('li').attr({ 'role': 'menuitem' }),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      menu.find('a:first').attr('tabindex', 0);

      items.each(function () {
        var $item = $(this),
            $sub = $item.children('ul');

        if ($sub.length) {
          $item.addClass(hasSubClass).attr({
            'aria-haspopup': true,
            'aria-expanded': false,
            'aria-label': $item.children('a:first').text()
          });

          $sub.addClass('submenu ' + subMenuClass).attr({
            'data-submenu': '',
            'aria-hidden': true,
            'role': 'menu'
          });
        }

        if ($item.parent('[data-submenu]').length) {
          $item.addClass('is-submenu-item ' + subItemClass);
        }
      });

      return;
    },
    Burn: function (menu, type) {
      var items = menu.find('li').removeAttr('tabindex'),
          subMenuClass = 'is-' + type + '-submenu',
          subItemClass = subMenuClass + '-item',
          hasSubClass = 'is-' + type + '-submenu-parent';

      menu.find('*').removeClass(subMenuClass + ' ' + subItemClass + ' ' + hasSubClass + ' is-submenu-item submenu is-active').removeAttr('data-submenu').css('display', '');

      // console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')
      //           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')
      //           .removeAttr('data-submenu'));
      // items.each(function(){
      //   var $item = $(this),
      //       $sub = $item.children('ul');
      //   if($item.parent('[data-submenu]').length){
      //     $item.removeClass('is-submenu-item ' + subItemClass);
      //   }
      //   if($sub.length){
      //     $item.removeClass('has-submenu');
      //     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');
      //   }
      // });
    }
  };

  Foundation.Nest = Nest;
}(jQuery);
'use strict';

!function ($) {

  function Timer(elem, options, cb) {
    var _this = this,
        duration = options.duration,
        //options is an object for easily adding features later.
    nameSpace = Object.keys(elem.data())[0] || 'timer',
        remain = -1,
        start,
        timer;

    this.isPaused = false;

    this.restart = function () {
      remain = -1;
      clearTimeout(timer);
      this.start();
    };

    this.start = function () {
      this.isPaused = false;
      // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      remain = remain <= 0 ? duration : remain;
      elem.data('paused', false);
      start = Date.now();
      timer = setTimeout(function () {
        if (options.infinite) {
          _this.restart(); //rerun the timer.
        }
        cb();
      }, remain);
      elem.trigger('timerstart.zf.' + nameSpace);
    };

    this.pause = function () {
      this.isPaused = true;
      //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
      clearTimeout(timer);
      elem.data('paused', true);
      var end = Date.now();
      remain = remain - (end - start);
      elem.trigger('timerpaused.zf.' + nameSpace);
    };
  }

  /**
   * Runs a callback function when images are fully loaded.
   * @param {Object} images - Image(s) to check if loaded.
   * @param {Func} callback - Function to execute when image is fully loaded.
   */
  function onImagesLoaded(images, callback) {
    var self = this,
        unloaded = images.length;

    if (unloaded === 0) {
      callback();
    }

    images.each(function () {
      if (this.complete) {
        singleImageLoaded();
      } else if (typeof this.naturalWidth !== 'undefined' && this.naturalWidth > 0) {
        singleImageLoaded();
      } else {
        $(this).one('load', function () {
          singleImageLoaded();
        });
      }
    });

    function singleImageLoaded() {
      unloaded--;
      if (unloaded === 0) {
        callback();
      }
    }
  }

  Foundation.Timer = Timer;
  Foundation.onImagesLoaded = onImagesLoaded;
}(jQuery);
//**************************************************
//**Work inspired by multiple jquery swipe plugins**
//**Done by Yohai Ararat ***************************
//**************************************************
(function ($) {

	$.spotSwipe = {
		version: '1.0.0',
		enabled: 'ontouchstart' in document.documentElement,
		preventDefault: false,
		moveThreshold: 75,
		timeThreshold: 200
	};

	var startPosX,
	    startPosY,
	    startTime,
	    elapsedTime,
	    isMoving = false;

	function onTouchEnd() {
		//  alert(this);
		this.removeEventListener('touchmove', onTouchMove);
		this.removeEventListener('touchend', onTouchEnd);
		isMoving = false;
	}

	function onTouchMove(e) {
		if ($.spotSwipe.preventDefault) {
			e.preventDefault();
		}
		if (isMoving) {
			var x = e.touches[0].pageX;
			var y = e.touches[0].pageY;
			var dx = startPosX - x;
			var dy = startPosY - y;
			var dir;
			elapsedTime = new Date().getTime() - startTime;
			if (Math.abs(dx) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
				dir = dx > 0 ? 'left' : 'right';
			}
			// else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
			//   dir = dy > 0 ? 'down' : 'up';
			// }
			if (dir) {
				e.preventDefault();
				onTouchEnd.call(this);
				$(this).trigger('swipe', dir).trigger('swipe' + dir);
			}
		}
	}

	function onTouchStart(e) {
		if (e.touches.length == 1) {
			startPosX = e.touches[0].pageX;
			startPosY = e.touches[0].pageY;
			isMoving = true;
			startTime = new Date().getTime();
			this.addEventListener('touchmove', onTouchMove, false);
			this.addEventListener('touchend', onTouchEnd, false);
		}
	}

	function init() {
		this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);
	}

	function teardown() {
		this.removeEventListener('touchstart', onTouchStart);
	}

	$.event.special.swipe = { setup: init };

	$.each(['left', 'up', 'down', 'right'], function () {
		$.event.special['swipe' + this] = { setup: function () {
				$(this).on('swipe', $.noop);
			} };
	});
})(jQuery);
/****************************************************
 * Method for adding psuedo drag events to elements *
 ***************************************************/
!function ($) {
	$.fn.addTouch = function () {
		this.each(function (i, el) {
			$(el).bind('touchstart touchmove touchend touchcancel', function () {
				//we pass the original event object because the jQuery event
				//object is normalized to w3c specs and does not provide the TouchList
				handleTouch(event);
			});
		});

		var handleTouch = function (event) {
			var touches = event.changedTouches,
			    first = touches[0],
			    eventTypes = {
				touchstart: 'mousedown',
				touchmove: 'mousemove',
				touchend: 'mouseup'
			},
			    type = eventTypes[event.type],
			    simulatedEvent;

			if ('MouseEvent' in window && typeof window.MouseEvent === 'function') {
				simulatedEvent = window.MouseEvent(type, {
					'bubbles': true,
					'cancelable': true,
					'screenX': first.screenX,
					'screenY': first.screenY,
					'clientX': first.clientX,
					'clientY': first.clientY
				});
			} else {
				simulatedEvent = document.createEvent('MouseEvent');
				simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0 /*left*/, null);
			}
			first.target.dispatchEvent(simulatedEvent);
		};
	};
}(jQuery);

//**********************************
//**From the jQuery Mobile Library**
//**need to recreate functionality**
//**and try to improve if possible**
//**********************************

/* Removing the jQuery function ****
************************************

(function( $, window, undefined ) {

	var $document = $( document ),
		// supportTouch = $.mobile.support.touch,
		touchStartEvent = 'touchstart'//supportTouch ? "touchstart" : "mousedown",
		touchStopEvent = 'touchend'//supportTouch ? "touchend" : "mouseup",
		touchMoveEvent = 'touchmove'//supportTouch ? "touchmove" : "mousemove";

	// setup new event shortcuts
	$.each( ( "touchstart touchmove touchend " +
		"swipe swipeleft swiperight" ).split( " " ), function( i, name ) {

		$.fn[ name ] = function( fn ) {
			return fn ? this.bind( name, fn ) : this.trigger( name );
		};

		// jQuery < 1.8
		if ( $.attrFn ) {
			$.attrFn[ name ] = true;
		}
	});

	function triggerCustomEvent( obj, eventType, event, bubble ) {
		var originalType = event.type;
		event.type = eventType;
		if ( bubble ) {
			$.event.trigger( event, undefined, obj );
		} else {
			$.event.dispatch.call( obj, event );
		}
		event.type = originalType;
	}

	// also handles taphold

	// Also handles swipeleft, swiperight
	$.event.special.swipe = {

		// More than this horizontal displacement, and we will suppress scrolling.
		scrollSupressionThreshold: 30,

		// More time than this, and it isn't a swipe.
		durationThreshold: 1000,

		// Swipe horizontal displacement must be more than this.
		horizontalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		// Swipe vertical displacement must be less than this.
		verticalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

		getLocation: function ( event ) {
			var winPageX = window.pageXOffset,
				winPageY = window.pageYOffset,
				x = event.clientX,
				y = event.clientY;

			if ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||
				event.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {

				// iOS4 clientX/clientY have the value that should have been
				// in pageX/pageY. While pageX/page/ have the value 0
				x = x - winPageX;
				y = y - winPageY;
			} else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {

				// Some Android browsers have totally bogus values for clientX/Y
				// when scrolling/zooming a page. Detectable since clientX/clientY
				// should never be smaller than pageX/pageY minus page scroll
				x = event.pageX - winPageX;
				y = event.pageY - winPageY;
			}

			return {
				x: x,
				y: y
			};
		},

		start: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ],
						origin: $( event.target )
					};
		},

		stop: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ]
					};
		},

		handleSwipe: function( start, stop, thisObject, origTarget ) {
			if ( stop.time - start.time < $.event.special.swipe.durationThreshold &&
				Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&
				Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {
				var direction = start.coords[0] > stop.coords[ 0 ] ? "swipeleft" : "swiperight";

				triggerCustomEvent( thisObject, "swipe", $.Event( "swipe", { target: origTarget, swipestart: start, swipestop: stop }), true );
				triggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );
				return true;
			}
			return false;

		},

		// This serves as a flag to ensure that at most one swipe event event is
		// in work at any given time
		eventInProgress: false,

		setup: function() {
			var events,
				thisObject = this,
				$this = $( thisObject ),
				context = {};

			// Retrieve the events data for this element and add the swipe context
			events = $.data( this, "mobile-events" );
			if ( !events ) {
				events = { length: 0 };
				$.data( this, "mobile-events", events );
			}
			events.length++;
			events.swipe = context;

			context.start = function( event ) {

				// Bail if we're already working on a swipe event
				if ( $.event.special.swipe.eventInProgress ) {
					return;
				}
				$.event.special.swipe.eventInProgress = true;

				var stop,
					start = $.event.special.swipe.start( event ),
					origTarget = event.target,
					emitted = false;

				context.move = function( event ) {
					if ( !start || event.isDefaultPrevented() ) {
						return;
					}

					stop = $.event.special.swipe.stop( event );
					if ( !emitted ) {
						emitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );
						if ( emitted ) {

							// Reset the context to make way for the next swipe event
							$.event.special.swipe.eventInProgress = false;
						}
					}
					// prevent scrolling
					if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {
						event.preventDefault();
					}
				};

				context.stop = function() {
						emitted = true;

						// Reset the context to make way for the next swipe event
						$.event.special.swipe.eventInProgress = false;
						$document.off( touchMoveEvent, context.move );
						context.move = null;
				};

				$document.on( touchMoveEvent, context.move )
					.one( touchStopEvent, context.stop );
			};
			$this.on( touchStartEvent, context.start );
		},

		teardown: function() {
			var events, context;

			events = $.data( this, "mobile-events" );
			if ( events ) {
				context = events.swipe;
				delete events.swipe;
				events.length--;
				if ( events.length === 0 ) {
					$.removeData( this, "mobile-events" );
				}
			}

			if ( context ) {
				if ( context.start ) {
					$( this ).off( touchStartEvent, context.start );
				}
				if ( context.move ) {
					$document.off( touchMoveEvent, context.move );
				}
				if ( context.stop ) {
					$document.off( touchStopEvent, context.stop );
				}
			}
		}
	};
	$.each({
		swipeleft: "swipe.left",
		swiperight: "swipe.right"
	}, function( event, sourceEvent ) {

		$.event.special[ event ] = {
			setup: function() {
				$( this ).bind( sourceEvent, $.noop );
			},
			teardown: function() {
				$( this ).unbind( sourceEvent );
			}
		};
	});
})( jQuery, this );
*/
'use strict';

!function ($) {

  var MutationObserver = function () {
    var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
    for (var i = 0; i < prefixes.length; i++) {
      if (prefixes[i] + 'MutationObserver' in window) {
        return window[prefixes[i] + 'MutationObserver'];
      }
    }
    return false;
  }();

  var triggers = function (el, type) {
    el.data(type).split(' ').forEach(function (id) {
      $('#' + id)[type === 'close' ? 'trigger' : 'triggerHandler'](type + '.zf.trigger', [el]);
    });
  };
  // Elements with [data-open] will reveal a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-open]', function () {
    triggers($(this), 'open');
  });

  // Elements with [data-close] will close a plugin that supports it when clicked.
  // If used without a value on [data-close], the event will bubble, allowing it to close a parent component.
  $(document).on('click.zf.trigger', '[data-close]', function () {
    var id = $(this).data('close');
    if (id) {
      triggers($(this), 'close');
    } else {
      $(this).trigger('close.zf.trigger');
    }
  });

  // Elements with [data-toggle] will toggle a plugin that supports it when clicked.
  $(document).on('click.zf.trigger', '[data-toggle]', function () {
    triggers($(this), 'toggle');
  });

  // Elements with [data-closable] will respond to close.zf.trigger events.
  $(document).on('close.zf.trigger', '[data-closable]', function (e) {
    e.stopPropagation();
    var animation = $(this).data('closable');

    if (animation !== '') {
      Foundation.Motion.animateOut($(this), animation, function () {
        $(this).trigger('closed.zf');
      });
    } else {
      $(this).fadeOut().trigger('closed.zf');
    }
  });

  $(document).on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', function () {
    var id = $(this).data('toggle-focus');
    $('#' + id).triggerHandler('toggle.zf.trigger', [$(this)]);
  });

  /**
  * Fires once after all other scripts have loaded
  * @function
  * @private
  */
  $(window).load(function () {
    checkListeners();
  });

  function checkListeners() {
    eventsListener();
    resizeListener();
    scrollListener();
    closemeListener();
  }

  //******** only fires this function once on load, if there's something to watch ********
  function closemeListener(pluginName) {
    var yetiBoxes = $('[data-yeti-box]'),
        plugNames = ['dropdown', 'tooltip', 'reveal'];

    if (pluginName) {
      if (typeof pluginName === 'string') {
        plugNames.push(pluginName);
      } else if (typeof pluginName === 'object' && typeof pluginName[0] === 'string') {
        plugNames.concat(pluginName);
      } else {
        console.error('Plugin names must be strings');
      }
    }
    if (yetiBoxes.length) {
      var listeners = plugNames.map(function (name) {
        return 'closeme.zf.' + name;
      }).join(' ');

      $(window).off(listeners).on(listeners, function (e, pluginId) {
        var plugin = e.namespace.split('.')[0];
        var plugins = $('[data-' + plugin + ']').not('[data-yeti-box="' + pluginId + '"]');

        plugins.each(function () {
          var _this = $(this);

          _this.triggerHandler('close.zf.trigger', [_this]);
        });
      });
    }
  }

  function resizeListener(debounce) {
    var timer = void 0,
        $nodes = $('[data-resize]');
    if ($nodes.length) {
      $(window).off('resize.zf.trigger').on('resize.zf.trigger', function (e) {
        if (timer) {
          clearTimeout(timer);
        }

        timer = setTimeout(function () {

          if (!MutationObserver) {
            //fallback for IE 9
            $nodes.each(function () {
              $(this).triggerHandler('resizeme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a resize event
          $nodes.attr('data-events', "resize");
        }, debounce || 10); //default time to emit resize event
      });
    }
  }

  function scrollListener(debounce) {
    var timer = void 0,
        $nodes = $('[data-scroll]');
    if ($nodes.length) {
      $(window).off('scroll.zf.trigger').on('scroll.zf.trigger', function (e) {
        if (timer) {
          clearTimeout(timer);
        }

        timer = setTimeout(function () {

          if (!MutationObserver) {
            //fallback for IE 9
            $nodes.each(function () {
              $(this).triggerHandler('scrollme.zf.trigger');
            });
          }
          //trigger all listening elements and signal a scroll event
          $nodes.attr('data-events', "scroll");
        }, debounce || 10); //default time to emit scroll event
      });
    }
  }

  function eventsListener() {
    if (!MutationObserver) {
      return false;
    }
    var nodes = document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');

    //element callback
    var listeningElementsMutation = function (mutationRecordsList) {
      var $target = $(mutationRecordsList[0].target);
      //trigger the event handler for the element depending on type
      switch ($target.attr("data-events")) {

        case "resize":
          $target.triggerHandler('resizeme.zf.trigger', [$target]);
          break;

        case "scroll":
          $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);
          break;

        // case "mutate" :
        // console.log('mutate', $target);
        // $target.triggerHandler('mutate.zf.trigger');
        //
        // //make sure we don't get stuck in an infinite loop from sloppy codeing
        // if ($target.index('[data-mutate]') == $("[data-mutate]").length-1) {
        //   domMutationObserver();
        // }
        // break;

        default:
          return false;
        //nothing
      }
    };

    if (nodes.length) {
      //for each element that needs to listen for resizing, scrolling, (or coming soon mutation) add a single observer
      for (var i = 0; i <= nodes.length - 1; i++) {
        var elementObserver = new MutationObserver(listeningElementsMutation);
        elementObserver.observe(nodes[i], { attributes: true, childList: false, characterData: false, subtree: false, attributeFilter: ["data-events"] });
      }
    }
  }

  // ------------------------------------

  // [PH]
  // Foundation.CheckWatchers = checkWatchers;
  Foundation.IHearYou = checkListeners;
  // Foundation.ISeeYou = scrollListener;
  // Foundation.IFeelYou = closemeListener;
}(jQuery);

// function domMutationObserver(debounce) {
//   // !!! This is coming soon and needs more work; not active  !!! //
//   var timer,
//   nodes = document.querySelectorAll('[data-mutate]');
//   //
//   if (nodes.length) {
//     // var MutationObserver = (function () {
//     //   var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
//     //   for (var i=0; i < prefixes.length; i++) {
//     //     if (prefixes[i] + 'MutationObserver' in window) {
//     //       return window[prefixes[i] + 'MutationObserver'];
//     //     }
//     //   }
//     //   return false;
//     // }());
//
//
//     //for the body, we need to listen for all changes effecting the style and class attributes
//     var bodyObserver = new MutationObserver(bodyMutation);
//     bodyObserver.observe(document.body, { attributes: true, childList: true, characterData: false, subtree:true, attributeFilter:["style", "class"]});
//
//
//     //body callback
//     function bodyMutation(mutate) {
//       //trigger all listening elements and signal a mutation event
//       if (timer) { clearTimeout(timer); }
//
//       timer = setTimeout(function() {
//         bodyObserver.disconnect();
//         $('[data-mutate]').attr('data-events',"mutate");
//       }, debounce || 150);
//     }
//   }
// }
'use strict';

/*!
 * Masonry PACKAGED v4.1.1
 * Cascading grid layout library
 * http://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */

/**
 * Bridget makes jQuery widgets
 * v2.0.1
 * MIT license
 */

/* jshint browser: true, strict: true, undef: true, unused: true */

(function (window, factory) {
  // universal module definition
  /*jshint strict: false */ /* globals define, module, require */
  if (typeof define == 'function' && define.amd) {
    // AMD
    define('jquery-bridget/jquery-bridget', ['jquery'], function (jQuery) {
      return factory(window, jQuery);
    });
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('jquery'));
  } else {
    // browser global
    window.jQueryBridget = factory(window, window.jQuery);
  }
})(window, function factory(window, jQuery) {
  'use strict';

  // ----- utils ----- //

  var arraySlice = Array.prototype.slice;

  // helper function for logging errors
  // $.error breaks jQuery chaining
  var console = window.console;
  var logError = typeof console == 'undefined' ? function () {} : function (message) {
    console.error(message);
  };

  // ----- jQueryBridget ----- //

  function jQueryBridget(namespace, PluginClass, $) {
    $ = $ || jQuery || window.jQuery;
    if (!$) {
      return;
    }

    // add option method -> $().plugin('option', {...})
    if (!PluginClass.prototype.option) {
      // option setter
      PluginClass.prototype.option = function (opts) {
        // bail out if not an object
        if (!$.isPlainObject(opts)) {
          return;
        }
        this.options = $.extend(true, this.options, opts);
      };
    }

    // make jQuery plugin
    $.fn[namespace] = function (arg0 /*, arg1 */) {
      if (typeof arg0 == 'string') {
        // method call $().plugin( 'methodName', { options } )
        // shift arguments by 1
        var args = arraySlice.call(arguments, 1);
        return methodCall(this, arg0, args);
      }
      // just $().plugin({ options })
      plainCall(this, arg0);
      return this;
    };

    // $().plugin('methodName')
    function methodCall($elems, methodName, args) {
      var returnValue;
      var pluginMethodStr = '$().' + namespace + '("' + methodName + '")';

      $elems.each(function (i, elem) {
        // get instance
        var instance = $.data(elem, namespace);
        if (!instance) {
          logError(namespace + ' not initialized. Cannot call methods, i.e. ' + pluginMethodStr);
          return;
        }

        var method = instance[methodName];
        if (!method || methodName.charAt(0) == '_') {
          logError(pluginMethodStr + ' is not a valid method');
          return;
        }

        // apply method, get return value
        var value = method.apply(instance, args);
        // set return value if value is returned, use only first value
        returnValue = returnValue === undefined ? value : returnValue;
      });

      return returnValue !== undefined ? returnValue : $elems;
    }

    function plainCall($elems, options) {
      $elems.each(function (i, elem) {
        var instance = $.data(elem, namespace);
        if (instance) {
          // set options & init
          instance.option(options);
          instance._init();
        } else {
          // initialize new instance
          instance = new PluginClass(elem, options);
          $.data(elem, namespace, instance);
        }
      });
    }

    updateJQuery($);
  }

  // ----- updateJQuery ----- //

  // set $.bridget for v1 backwards compatibility
  function updateJQuery($) {
    if (!$ || $ && $.bridget) {
      return;
    }
    $.bridget = jQueryBridget;
  }

  updateJQuery(jQuery || window.jQuery);

  // -----  ----- //

  return jQueryBridget;
});

/**
 * EvEmitter v1.0.3
 * Lil' event emitter
 * MIT License
 */

/* jshint unused: true, undef: true, strict: true */

(function (global, factory) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, window */
  if (typeof define == 'function' && define.amd) {
    // AMD - RequireJS
    define('ev-emitter/ev-emitter', factory);
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS - Browserify, Webpack
    module.exports = factory();
  } else {
    // Browser globals
    global.EvEmitter = factory();
  }
})(typeof window != 'undefined' ? window : this, function () {

  function EvEmitter() {}

  var proto = EvEmitter.prototype;

  proto.on = function (eventName, listener) {
    if (!eventName || !listener) {
      return;
    }
    // set events hash
    var events = this._events = this._events || {};
    // set listeners array
    var listeners = events[eventName] = events[eventName] || [];
    // only add once
    if (listeners.indexOf(listener) == -1) {
      listeners.push(listener);
    }

    return this;
  };

  proto.once = function (eventName, listener) {
    if (!eventName || !listener) {
      return;
    }
    // add event
    this.on(eventName, listener);
    // set once flag
    // set onceEvents hash
    var onceEvents = this._onceEvents = this._onceEvents || {};
    // set onceListeners object
    var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
    // set flag
    onceListeners[listener] = true;

    return this;
  };

  proto.off = function (eventName, listener) {
    var listeners = this._events && this._events[eventName];
    if (!listeners || !listeners.length) {
      return;
    }
    var index = listeners.indexOf(listener);
    if (index != -1) {
      listeners.splice(index, 1);
    }

    return this;
  };

  proto.emitEvent = function (eventName, args) {
    var listeners = this._events && this._events[eventName];
    if (!listeners || !listeners.length) {
      return;
    }
    var i = 0;
    var listener = listeners[i];
    args = args || [];
    // once stuff
    var onceListeners = this._onceEvents && this._onceEvents[eventName];

    while (listener) {
      var isOnce = onceListeners && onceListeners[listener];
      if (isOnce) {
        // remove listener
        // remove before trigger to prevent recursion
        this.off(eventName, listener);
        // unset once flag
        delete onceListeners[listener];
      }
      // trigger listener
      listener.apply(this, args);
      // get next listener
      i += isOnce ? 0 : 1;
      listener = listeners[i];
    }

    return this;
  };

  return EvEmitter;
});

/*!
 * getSize v2.0.2
 * measure size of elements
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false, module: false, console: false */

(function (window, factory) {
  'use strict';

  if (typeof define == 'function' && define.amd) {
    // AMD
    define('get-size/get-size', [], function () {
      return factory();
    });
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.getSize = factory();
  }
})(window, function factory() {
  'use strict';

  // -------------------------- helpers -------------------------- //

  // get a number from a string, not a percentage

  function getStyleSize(value) {
    var num = parseFloat(value);
    // not a percent like '100%', and a number
    var isValid = value.indexOf('%') == -1 && !isNaN(num);
    return isValid && num;
  }

  function noop() {}

  var logError = typeof console == 'undefined' ? noop : function (message) {
    console.error(message);
  };

  // -------------------------- measurements -------------------------- //

  var measurements = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth'];

  var measurementsLength = measurements.length;

  function getZeroSize() {
    var size = {
      width: 0,
      height: 0,
      innerWidth: 0,
      innerHeight: 0,
      outerWidth: 0,
      outerHeight: 0
    };
    for (var i = 0; i < measurementsLength; i++) {
      var measurement = measurements[i];
      size[measurement] = 0;
    }
    return size;
  }

  // -------------------------- getStyle -------------------------- //

  /**
   * getStyle, get style of element, check for Firefox bug
   * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
   */
  function getStyle(elem) {
    var style = getComputedStyle(elem);
    if (!style) {
      logError('Style returned ' + style + '. Are you running this code in a hidden iframe on Firefox? ' + 'See http://bit.ly/getsizebug1');
    }
    return style;
  }

  // -------------------------- setup -------------------------- //

  var isSetup = false;

  var isBoxSizeOuter;

  /**
   * setup
   * check isBoxSizerOuter
   * do on first getSize() rather than on page load for Firefox bug
   */
  function setup() {
    // setup once
    if (isSetup) {
      return;
    }
    isSetup = true;

    // -------------------------- box sizing -------------------------- //

    /**
     * WebKit measures the outer-width on style.width on border-box elems
     * IE & Firefox<29 measures the inner-width
     */
    var div = document.createElement('div');
    div.style.width = '200px';
    div.style.padding = '1px 2px 3px 4px';
    div.style.borderStyle = 'solid';
    div.style.borderWidth = '1px 2px 3px 4px';
    div.style.boxSizing = 'border-box';

    var body = document.body || document.documentElement;
    body.appendChild(div);
    var style = getStyle(div);

    getSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize(style.width) == 200;
    body.removeChild(div);
  }

  // -------------------------- getSize -------------------------- //

  function getSize(elem) {
    setup();

    // use querySeletor if elem is string
    if (typeof elem == 'string') {
      elem = document.querySelector(elem);
    }

    // do not proceed on non-objects
    if (!elem || typeof elem != 'object' || !elem.nodeType) {
      return;
    }

    var style = getStyle(elem);

    // if hidden, everything is 0
    if (style.display == 'none') {
      return getZeroSize();
    }

    var size = {};
    size.width = elem.offsetWidth;
    size.height = elem.offsetHeight;

    var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';

    // get all measurements
    for (var i = 0; i < measurementsLength; i++) {
      var measurement = measurements[i];
      var value = style[measurement];
      var num = parseFloat(value);
      // any 'auto', 'medium' value will be 0
      size[measurement] = !isNaN(num) ? num : 0;
    }

    var paddingWidth = size.paddingLeft + size.paddingRight;
    var paddingHeight = size.paddingTop + size.paddingBottom;
    var marginWidth = size.marginLeft + size.marginRight;
    var marginHeight = size.marginTop + size.marginBottom;
    var borderWidth = size.borderLeftWidth + size.borderRightWidth;
    var borderHeight = size.borderTopWidth + size.borderBottomWidth;

    var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

    // overwrite width and height if we can get it from style
    var styleWidth = getStyleSize(style.width);
    if (styleWidth !== false) {
      size.width = styleWidth + (
      // add padding and border unless it's already including it
      isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
    }

    var styleHeight = getStyleSize(style.height);
    if (styleHeight !== false) {
      size.height = styleHeight + (
      // add padding and border unless it's already including it
      isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
    }

    size.innerWidth = size.width - (paddingWidth + borderWidth);
    size.innerHeight = size.height - (paddingHeight + borderHeight);

    size.outerWidth = size.width + marginWidth;
    size.outerHeight = size.height + marginHeight;

    return size;
  }

  return getSize;
});

/**
 * matchesSelector v2.0.1
 * matchesSelector( element, '.selector' )
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */

(function (window, factory) {
  /*global define: false, module: false */
  'use strict';
  // universal module definition

  if (typeof define == 'function' && define.amd) {
    // AMD
    define('desandro-matches-selector/matches-selector', factory);
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.matchesSelector = factory();
  }
})(window, function factory() {
  'use strict';

  var matchesMethod = function () {
    var ElemProto = Element.prototype;
    // check for the standard method name first
    if (ElemProto.matches) {
      return 'matches';
    }
    // check un-prefixed
    if (ElemProto.matchesSelector) {
      return 'matchesSelector';
    }
    // check vendor prefixes
    var prefixes = ['webkit', 'moz', 'ms', 'o'];

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var method = prefix + 'MatchesSelector';
      if (ElemProto[method]) {
        return method;
      }
    }
  }();

  return function matchesSelector(elem, selector) {
    return elem[matchesMethod](selector);
  };
});

/**
 * Fizzy UI utils v2.0.2
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */

(function (window, factory) {
  // universal module definition
  /*jshint strict: false */ /*globals define, module, require */

  if (typeof define == 'function' && define.amd) {
    // AMD
    define('fizzy-ui-utils/utils', ['desandro-matches-selector/matches-selector'], function (matchesSelector) {
      return factory(window, matchesSelector);
    });
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('desandro-matches-selector'));
  } else {
    // browser global
    window.fizzyUIUtils = factory(window, window.matchesSelector);
  }
})(window, function factory(window, matchesSelector) {

  var utils = {};

  // ----- extend ----- //

  // extends objects
  utils.extend = function (a, b) {
    for (var prop in b) {
      a[prop] = b[prop];
    }
    return a;
  };

  // ----- modulo ----- //

  utils.modulo = function (num, div) {
    return (num % div + div) % div;
  };

  // ----- makeArray ----- //

  // turn element or nodeList into an array
  utils.makeArray = function (obj) {
    var ary = [];
    if (Array.isArray(obj)) {
      // use object if already an array
      ary = obj;
    } else if (obj && typeof obj.length == 'number') {
      // convert nodeList to array
      for (var i = 0; i < obj.length; i++) {
        ary.push(obj[i]);
      }
    } else {
      // array of single index
      ary.push(obj);
    }
    return ary;
  };

  // ----- removeFrom ----- //

  utils.removeFrom = function (ary, obj) {
    var index = ary.indexOf(obj);
    if (index != -1) {
      ary.splice(index, 1);
    }
  };

  // ----- getParent ----- //

  utils.getParent = function (elem, selector) {
    while (elem != document.body) {
      elem = elem.parentNode;
      if (matchesSelector(elem, selector)) {
        return elem;
      }
    }
  };

  // ----- getQueryElement ----- //

  // use element as selector string
  utils.getQueryElement = function (elem) {
    if (typeof elem == 'string') {
      return document.querySelector(elem);
    }
    return elem;
  };

  // ----- handleEvent ----- //

  // enable .ontype to trigger from .addEventListener( elem, 'type' )
  utils.handleEvent = function (event) {
    var method = 'on' + event.type;
    if (this[method]) {
      this[method](event);
    }
  };

  // ----- filterFindElements ----- //

  utils.filterFindElements = function (elems, selector) {
    // make array of elems
    elems = utils.makeArray(elems);
    var ffElems = [];

    elems.forEach(function (elem) {
      // check that elem is an actual element
      if (!(elem instanceof HTMLElement)) {
        return;
      }
      // add elem if no selector
      if (!selector) {
        ffElems.push(elem);
        return;
      }
      // filter & find items if we have a selector
      // filter
      if (matchesSelector(elem, selector)) {
        ffElems.push(elem);
      }
      // find children
      var childElems = elem.querySelectorAll(selector);
      // concat childElems to filterFound array
      for (var i = 0; i < childElems.length; i++) {
        ffElems.push(childElems[i]);
      }
    });

    return ffElems;
  };

  // ----- debounceMethod ----- //

  utils.debounceMethod = function (_class, methodName, threshold) {
    // original method
    var method = _class.prototype[methodName];
    var timeoutName = methodName + 'Timeout';

    _class.prototype[methodName] = function () {
      var timeout = this[timeoutName];
      if (timeout) {
        clearTimeout(timeout);
      }
      var args = arguments;

      var _this = this;
      this[timeoutName] = setTimeout(function () {
        method.apply(_this, args);
        delete _this[timeoutName];
      }, threshold || 100);
    };
  };

  // ----- docReady ----- //

  utils.docReady = function (callback) {
    var readyState = document.readyState;
    if (readyState == 'complete' || readyState == 'interactive') {
      callback();
    } else {
      document.addEventListener('DOMContentLoaded', callback);
    }
  };

  // ----- htmlInit ----- //

  // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
  utils.toDashed = function (str) {
    return str.replace(/(.)([A-Z])/g, function (match, $1, $2) {
      return $1 + '-' + $2;
    }).toLowerCase();
  };

  var console = window.console;
  /**
   * allow user to initialize classes via [data-namespace] or .js-namespace class
   * htmlInit( Widget, 'widgetName' )
   * options are parsed from data-namespace-options
   */
  utils.htmlInit = function (WidgetClass, namespace) {
    utils.docReady(function () {
      var dashedNamespace = utils.toDashed(namespace);
      var dataAttr = 'data-' + dashedNamespace;
      var dataAttrElems = document.querySelectorAll('[' + dataAttr + ']');
      var jsDashElems = document.querySelectorAll('.js-' + dashedNamespace);
      var elems = utils.makeArray(dataAttrElems).concat(utils.makeArray(jsDashElems));
      var dataOptionsAttr = dataAttr + '-options';
      var jQuery = window.jQuery;

      elems.forEach(function (elem) {
        var attr = elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);
        var options;
        try {
          options = attr && JSON.parse(attr);
        } catch (error) {
          // log error, do not initialize
          if (console) {
            console.error('Error parsing ' + dataAttr + ' on ' + elem.className + ': ' + error);
          }
          return;
        }
        // initialize
        var instance = new WidgetClass(elem, options);
        // make available via $().data('layoutname')
        if (jQuery) {
          jQuery.data(elem, namespace, instance);
        }
      });
    });
  };

  // -----  ----- //

  return utils;
});

/**
 * Outlayer Item
 */

(function (window, factory) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */
  if (typeof define == 'function' && define.amd) {
    // AMD - RequireJS
    define('outlayer/item', ['ev-emitter/ev-emitter', 'get-size/get-size'], factory);
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS - Browserify, Webpack
    module.exports = factory(require('ev-emitter'), require('get-size'));
  } else {
    // browser global
    window.Outlayer = {};
    window.Outlayer.Item = factory(window.EvEmitter, window.getSize);
  }
})(window, function factory(EvEmitter, getSize) {
  'use strict';

  // ----- helpers ----- //

  function isEmptyObj(obj) {
    for (var prop in obj) {
      return false;
    }
    prop = null;
    return true;
  }

  // -------------------------- CSS3 support -------------------------- //


  var docElemStyle = document.documentElement.style;

  var transitionProperty = typeof docElemStyle.transition == 'string' ? 'transition' : 'WebkitTransition';
  var transformProperty = typeof docElemStyle.transform == 'string' ? 'transform' : 'WebkitTransform';

  var transitionEndEvent = {
    WebkitTransition: 'webkitTransitionEnd',
    transition: 'transitionend'
  }[transitionProperty];

  // cache all vendor properties that could have vendor prefix
  var vendorProperties = {
    transform: transformProperty,
    transition: transitionProperty,
    transitionDuration: transitionProperty + 'Duration',
    transitionProperty: transitionProperty + 'Property',
    transitionDelay: transitionProperty + 'Delay'
  };

  // -------------------------- Item -------------------------- //

  function Item(element, layout) {
    if (!element) {
      return;
    }

    this.element = element;
    // parent layout class, i.e. Masonry, Isotope, or Packery
    this.layout = layout;
    this.position = {
      x: 0,
      y: 0
    };

    this._create();
  }

  // inherit EvEmitter
  var proto = Item.prototype = Object.create(EvEmitter.prototype);
  proto.constructor = Item;

  proto._create = function () {
    // transition objects
    this._transn = {
      ingProperties: {},
      clean: {},
      onEnd: {}
    };

    this.css({
      position: 'absolute'
    });
  };

  // trigger specified handler for event type
  proto.handleEvent = function (event) {
    var method = 'on' + event.type;
    if (this[method]) {
      this[method](event);
    }
  };

  proto.getSize = function () {
    this.size = getSize(this.element);
  };

  /**
   * apply CSS styles to element
   * @param {Object} style
   */
  proto.css = function (style) {
    var elemStyle = this.element.style;

    for (var prop in style) {
      // use vendor property if available
      var supportedProp = vendorProperties[prop] || prop;
      elemStyle[supportedProp] = style[prop];
    }
  };

  // measure position, and sets it
  proto.getPosition = function () {
    var style = getComputedStyle(this.element);
    var isOriginLeft = this.layout._getOption('originLeft');
    var isOriginTop = this.layout._getOption('originTop');
    var xValue = style[isOriginLeft ? 'left' : 'right'];
    var yValue = style[isOriginTop ? 'top' : 'bottom'];
    // convert percent to pixels
    var layoutSize = this.layout.size;
    var x = xValue.indexOf('%') != -1 ? parseFloat(xValue) / 100 * layoutSize.width : parseInt(xValue, 10);
    var y = yValue.indexOf('%') != -1 ? parseFloat(yValue) / 100 * layoutSize.height : parseInt(yValue, 10);

    // clean up 'auto' or other non-integer values
    x = isNaN(x) ? 0 : x;
    y = isNaN(y) ? 0 : y;
    // remove padding from measurement
    x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
    y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;

    this.position.x = x;
    this.position.y = y;
  };

  // set settled position, apply padding
  proto.layoutPosition = function () {
    var layoutSize = this.layout.size;
    var style = {};
    var isOriginLeft = this.layout._getOption('originLeft');
    var isOriginTop = this.layout._getOption('originTop');

    // x
    var xPadding = isOriginLeft ? 'paddingLeft' : 'paddingRight';
    var xProperty = isOriginLeft ? 'left' : 'right';
    var xResetProperty = isOriginLeft ? 'right' : 'left';

    var x = this.position.x + layoutSize[xPadding];
    // set in percentage or pixels
    style[xProperty] = this.getXValue(x);
    // reset other property
    style[xResetProperty] = '';

    // y
    var yPadding = isOriginTop ? 'paddingTop' : 'paddingBottom';
    var yProperty = isOriginTop ? 'top' : 'bottom';
    var yResetProperty = isOriginTop ? 'bottom' : 'top';

    var y = this.position.y + layoutSize[yPadding];
    // set in percentage or pixels
    style[yProperty] = this.getYValue(y);
    // reset other property
    style[yResetProperty] = '';

    this.css(style);
    this.emitEvent('layout', [this]);
  };

  proto.getXValue = function (x) {
    var isHorizontal = this.layout._getOption('horizontal');
    return this.layout.options.percentPosition && !isHorizontal ? x / this.layout.size.width * 100 + '%' : x + 'px';
  };

  proto.getYValue = function (y) {
    var isHorizontal = this.layout._getOption('horizontal');
    return this.layout.options.percentPosition && isHorizontal ? y / this.layout.size.height * 100 + '%' : y + 'px';
  };

  proto._transitionTo = function (x, y) {
    this.getPosition();
    // get current x & y from top/left
    var curX = this.position.x;
    var curY = this.position.y;

    var compareX = parseInt(x, 10);
    var compareY = parseInt(y, 10);
    var didNotMove = compareX === this.position.x && compareY === this.position.y;

    // save end position
    this.setPosition(x, y);

    // if did not move and not transitioning, just go to layout
    if (didNotMove && !this.isTransitioning) {
      this.layoutPosition();
      return;
    }

    var transX = x - curX;
    var transY = y - curY;
    var transitionStyle = {};
    transitionStyle.transform = this.getTranslate(transX, transY);

    this.transition({
      to: transitionStyle,
      onTransitionEnd: {
        transform: this.layoutPosition
      },
      isCleaning: true
    });
  };

  proto.getTranslate = function (x, y) {
    // flip cooridinates if origin on right or bottom
    var isOriginLeft = this.layout._getOption('originLeft');
    var isOriginTop = this.layout._getOption('originTop');
    x = isOriginLeft ? x : -x;
    y = isOriginTop ? y : -y;
    return 'translate3d(' + x + 'px, ' + y + 'px, 0)';
  };

  // non transition + transform support
  proto.goTo = function (x, y) {
    this.setPosition(x, y);
    this.layoutPosition();
  };

  proto.moveTo = proto._transitionTo;

  proto.setPosition = function (x, y) {
    this.position.x = parseInt(x, 10);
    this.position.y = parseInt(y, 10);
  };

  // ----- transition ----- //

  /**
   * @param {Object} style - CSS
   * @param {Function} onTransitionEnd
   */

  // non transition, just trigger callback
  proto._nonTransition = function (args) {
    this.css(args.to);
    if (args.isCleaning) {
      this._removeStyles(args.to);
    }
    for (var prop in args.onTransitionEnd) {
      args.onTransitionEnd[prop].call(this);
    }
  };

  /**
   * proper transition
   * @param {Object} args - arguments
   *   @param {Object} to - style to transition to
   *   @param {Object} from - style to start transition from
   *   @param {Boolean} isCleaning - removes transition styles after transition
   *   @param {Function} onTransitionEnd - callback
   */
  proto.transition = function (args) {
    // redirect to nonTransition if no transition duration
    if (!parseFloat(this.layout.options.transitionDuration)) {
      this._nonTransition(args);
      return;
    }

    var _transition = this._transn;
    // keep track of onTransitionEnd callback by css property
    for (var prop in args.onTransitionEnd) {
      _transition.onEnd[prop] = args.onTransitionEnd[prop];
    }
    // keep track of properties that are transitioning
    for (prop in args.to) {
      _transition.ingProperties[prop] = true;
      // keep track of properties to clean up when transition is done
      if (args.isCleaning) {
        _transition.clean[prop] = true;
      }
    }

    // set from styles
    if (args.from) {
      this.css(args.from);
      // force redraw. http://blog.alexmaccaw.com/css-transitions
      var h = this.element.offsetHeight;
      // hack for JSHint to hush about unused var
      h = null;
    }
    // enable transition
    this.enableTransition(args.to);
    // set styles that are transitioning
    this.css(args.to);

    this.isTransitioning = true;
  };

  // dash before all cap letters, including first for
  // WebkitTransform => -webkit-transform
  function toDashedAll(str) {
    return str.replace(/([A-Z])/g, function ($1) {
      return '-' + $1.toLowerCase();
    });
  }

  var transitionProps = 'opacity,' + toDashedAll(transformProperty);

  proto.enableTransition = function () /* style */{
    // HACK changing transitionProperty during a transition
    // will cause transition to jump
    if (this.isTransitioning) {
      return;
    }

    // make `transition: foo, bar, baz` from style object
    // HACK un-comment this when enableTransition can work
    // while a transition is happening
    // var transitionValues = [];
    // for ( var prop in style ) {
    //   // dash-ify camelCased properties like WebkitTransition
    //   prop = vendorProperties[ prop ] || prop;
    //   transitionValues.push( toDashedAll( prop ) );
    // }
    // munge number to millisecond, to match stagger
    var duration = this.layout.options.transitionDuration;
    duration = typeof duration == 'number' ? duration + 'ms' : duration;
    // enable transition styles
    this.css({
      transitionProperty: transitionProps,
      transitionDuration: duration,
      transitionDelay: this.staggerDelay || 0
    });
    // listen for transition end event
    this.element.addEventListener(transitionEndEvent, this, false);
  };

  // ----- events ----- //

  proto.onwebkitTransitionEnd = function (event) {
    this.ontransitionend(event);
  };

  proto.onotransitionend = function (event) {
    this.ontransitionend(event);
  };

  // properties that I munge to make my life easier
  var dashedVendorProperties = {
    '-webkit-transform': 'transform'
  };

  proto.ontransitionend = function (event) {
    // disregard bubbled events from children
    if (event.target !== this.element) {
      return;
    }
    var _transition = this._transn;
    // get property name of transitioned property, convert to prefix-free
    var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;

    // remove property that has completed transitioning
    delete _transition.ingProperties[propertyName];
    // check if any properties are still transitioning
    if (isEmptyObj(_transition.ingProperties)) {
      // all properties have completed transitioning
      this.disableTransition();
    }
    // clean style
    if (propertyName in _transition.clean) {
      // clean up style
      this.element.style[event.propertyName] = '';
      delete _transition.clean[propertyName];
    }
    // trigger onTransitionEnd callback
    if (propertyName in _transition.onEnd) {
      var onTransitionEnd = _transition.onEnd[propertyName];
      onTransitionEnd.call(this);
      delete _transition.onEnd[propertyName];
    }

    this.emitEvent('transitionEnd', [this]);
  };

  proto.disableTransition = function () {
    this.removeTransitionStyles();
    this.element.removeEventListener(transitionEndEvent, this, false);
    this.isTransitioning = false;
  };

  /**
   * removes style property from element
   * @param {Object} style
  **/
  proto._removeStyles = function (style) {
    // clean up transition styles
    var cleanStyle = {};
    for (var prop in style) {
      cleanStyle[prop] = '';
    }
    this.css(cleanStyle);
  };

  var cleanTransitionStyle = {
    transitionProperty: '',
    transitionDuration: '',
    transitionDelay: ''
  };

  proto.removeTransitionStyles = function () {
    // remove transition
    this.css(cleanTransitionStyle);
  };

  // ----- stagger ----- //

  proto.stagger = function (delay) {
    delay = isNaN(delay) ? 0 : delay;
    this.staggerDelay = delay + 'ms';
  };

  // ----- show/hide/remove ----- //

  // remove element from DOM
  proto.removeElem = function () {
    this.element.parentNode.removeChild(this.element);
    // remove display: none
    this.css({ display: '' });
    this.emitEvent('remove', [this]);
  };

  proto.remove = function () {
    // just remove element if no transition support or no transition
    if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {
      this.removeElem();
      return;
    }

    // start transition
    this.once('transitionEnd', function () {
      this.removeElem();
    });
    this.hide();
  };

  proto.reveal = function () {
    delete this.isHidden;
    // remove display: none
    this.css({ display: '' });

    var options = this.layout.options;

    var onTransitionEnd = {};
    var transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');
    onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;

    this.transition({
      from: options.hiddenStyle,
      to: options.visibleStyle,
      isCleaning: true,
      onTransitionEnd: onTransitionEnd
    });
  };

  proto.onRevealTransitionEnd = function () {
    // check if still visible
    // during transition, item may have been hidden
    if (!this.isHidden) {
      this.emitEvent('reveal');
    }
  };

  /**
   * get style property use for hide/reveal transition end
   * @param {String} styleProperty - hiddenStyle/visibleStyle
   * @returns {String}
   */
  proto.getHideRevealTransitionEndProperty = function (styleProperty) {
    var optionStyle = this.layout.options[styleProperty];
    // use opacity
    if (optionStyle.opacity) {
      return 'opacity';
    }
    // get first property
    for (var prop in optionStyle) {
      return prop;
    }
  };

  proto.hide = function () {
    // set flag
    this.isHidden = true;
    // remove display: none
    this.css({ display: '' });

    var options = this.layout.options;

    var onTransitionEnd = {};
    var transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');
    onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;

    this.transition({
      from: options.visibleStyle,
      to: options.hiddenStyle,
      // keep hidden stuff hidden
      isCleaning: true,
      onTransitionEnd: onTransitionEnd
    });
  };

  proto.onHideTransitionEnd = function () {
    // check if still hidden
    // during transition, item may have been un-hidden
    if (this.isHidden) {
      this.css({ display: 'none' });
      this.emitEvent('hide');
    }
  };

  proto.destroy = function () {
    this.css({
      position: '',
      left: '',
      right: '',
      top: '',
      bottom: '',
      transition: '',
      transform: ''
    });
  };

  return Item;
});

/*!
 * Outlayer v2.1.0
 * the brains and guts of a layout library
 * MIT license
 */

(function (window, factory) {
  'use strict';
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */

  if (typeof define == 'function' && define.amd) {
    // AMD - RequireJS
    define('outlayer/outlayer', ['ev-emitter/ev-emitter', 'get-size/get-size', 'fizzy-ui-utils/utils', './item'], function (EvEmitter, getSize, utils, Item) {
      return factory(window, EvEmitter, getSize, utils, Item);
    });
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS - Browserify, Webpack
    module.exports = factory(window, require('ev-emitter'), require('get-size'), require('fizzy-ui-utils'), require('./item'));
  } else {
    // browser global
    window.Outlayer = factory(window, window.EvEmitter, window.getSize, window.fizzyUIUtils, window.Outlayer.Item);
  }
})(window, function factory(window, EvEmitter, getSize, utils, Item) {
  'use strict';

  // ----- vars ----- //

  var console = window.console;
  var jQuery = window.jQuery;
  var noop = function () {};

  // -------------------------- Outlayer -------------------------- //

  // globally unique identifiers
  var GUID = 0;
  // internal store of all Outlayer intances
  var instances = {};

  /**
   * @param {Element, String} element
   * @param {Object} options
   * @constructor
   */
  function Outlayer(element, options) {
    var queryElement = utils.getQueryElement(element);
    if (!queryElement) {
      if (console) {
        console.error('Bad element for ' + this.constructor.namespace + ': ' + (queryElement || element));
      }
      return;
    }
    this.element = queryElement;
    // add jQuery
    if (jQuery) {
      this.$element = jQuery(this.element);
    }

    // options
    this.options = utils.extend({}, this.constructor.defaults);
    this.option(options);

    // add id for Outlayer.getFromElement
    var id = ++GUID;
    this.element.outlayerGUID = id; // expando
    instances[id] = this; // associate via id

    // kick it off
    this._create();

    var isInitLayout = this._getOption('initLayout');
    if (isInitLayout) {
      this.layout();
    }
  }

  // settings are for internal use only
  Outlayer.namespace = 'outlayer';
  Outlayer.Item = Item;

  // default options
  Outlayer.defaults = {
    containerStyle: {
      position: 'relative'
    },
    initLayout: true,
    originLeft: true,
    originTop: true,
    resize: true,
    resizeContainer: true,
    // item options
    transitionDuration: '0.4s',
    hiddenStyle: {
      opacity: 0,
      transform: 'scale(0.001)'
    },
    visibleStyle: {
      opacity: 1,
      transform: 'scale(1)'
    }
  };

  var proto = Outlayer.prototype;
  // inherit EvEmitter
  utils.extend(proto, EvEmitter.prototype);

  /**
   * set options
   * @param {Object} opts
   */
  proto.option = function (opts) {
    utils.extend(this.options, opts);
  };

  /**
   * get backwards compatible option value, check old name
   */
  proto._getOption = function (option) {
    var oldOption = this.constructor.compatOptions[option];
    return oldOption && this.options[oldOption] !== undefined ? this.options[oldOption] : this.options[option];
  };

  Outlayer.compatOptions = {
    // currentName: oldName
    initLayout: 'isInitLayout',
    horizontal: 'isHorizontal',
    layoutInstant: 'isLayoutInstant',
    originLeft: 'isOriginLeft',
    originTop: 'isOriginTop',
    resize: 'isResizeBound',
    resizeContainer: 'isResizingContainer'
  };

  proto._create = function () {
    // get items from children
    this.reloadItems();
    // elements that affect layout, but are not laid out
    this.stamps = [];
    this.stamp(this.options.stamp);
    // set container style
    utils.extend(this.element.style, this.options.containerStyle);

    // bind resize method
    var canBindResize = this._getOption('resize');
    if (canBindResize) {
      this.bindResize();
    }
  };

  // goes through all children again and gets bricks in proper order
  proto.reloadItems = function () {
    // collection of item elements
    this.items = this._itemize(this.element.children);
  };

  /**
   * turn elements into Outlayer.Items to be used in layout
   * @param {Array or NodeList or HTMLElement} elems
   * @returns {Array} items - collection of new Outlayer Items
   */
  proto._itemize = function (elems) {

    var itemElems = this._filterFindItemElements(elems);
    var Item = this.constructor.Item;

    // create new Outlayer Items for collection
    var items = [];
    for (var i = 0; i < itemElems.length; i++) {
      var elem = itemElems[i];
      var item = new Item(elem, this);
      items.push(item);
    }

    return items;
  };

  /**
   * get item elements to be used in layout
   * @param {Array or NodeList or HTMLElement} elems
   * @returns {Array} items - item elements
   */
  proto._filterFindItemElements = function (elems) {
    return utils.filterFindElements(elems, this.options.itemSelector);
  };

  /**
   * getter method for getting item elements
   * @returns {Array} elems - collection of item elements
   */
  proto.getItemElements = function () {
    return this.items.map(function (item) {
      return item.element;
    });
  };

  // ----- init & layout ----- //

  /**
   * lays out all items
   */
  proto.layout = function () {
    this._resetLayout();
    this._manageStamps();

    // don't animate first layout
    var layoutInstant = this._getOption('layoutInstant');
    var isInstant = layoutInstant !== undefined ? layoutInstant : !this._isLayoutInited;
    this.layoutItems(this.items, isInstant);

    // flag for initalized
    this._isLayoutInited = true;
  };

  // _init is alias for layout
  proto._init = proto.layout;

  /**
   * logic before any new layout
   */
  proto._resetLayout = function () {
    this.getSize();
  };

  proto.getSize = function () {
    this.size = getSize(this.element);
  };

  /**
   * get measurement from option, for columnWidth, rowHeight, gutter
   * if option is String -> get element from selector string, & get size of element
   * if option is Element -> get size of element
   * else use option as a number
   *
   * @param {String} measurement
   * @param {String} size - width or height
   * @private
   */
  proto._getMeasurement = function (measurement, size) {
    var option = this.options[measurement];
    var elem;
    if (!option) {
      // default to 0
      this[measurement] = 0;
    } else {
      // use option as an element
      if (typeof option == 'string') {
        elem = this.element.querySelector(option);
      } else if (option instanceof HTMLElement) {
        elem = option;
      }
      // use size of element, if element
      this[measurement] = elem ? getSize(elem)[size] : option;
    }
  };

  /**
   * layout a collection of item elements
   * @api public
   */
  proto.layoutItems = function (items, isInstant) {
    items = this._getItemsForLayout(items);

    this._layoutItems(items, isInstant);

    this._postLayout();
  };

  /**
   * get the items to be laid out
   * you may want to skip over some items
   * @param {Array} items
   * @returns {Array} items
   */
  proto._getItemsForLayout = function (items) {
    return items.filter(function (item) {
      return !item.isIgnored;
    });
  };

  /**
   * layout items
   * @param {Array} items
   * @param {Boolean} isInstant
   */
  proto._layoutItems = function (items, isInstant) {
    this._emitCompleteOnItems('layout', items);

    if (!items || !items.length) {
      // no items, emit event with empty array
      return;
    }

    var queue = [];

    items.forEach(function (item) {
      // get x/y object from method
      var position = this._getItemLayoutPosition(item);
      // enqueue
      position.item = item;
      position.isInstant = isInstant || item.isLayoutInstant;
      queue.push(position);
    }, this);

    this._processLayoutQueue(queue);
  };

  /**
   * get item layout position
   * @param {Outlayer.Item} item
   * @returns {Object} x and y position
   */
  proto._getItemLayoutPosition = function () /* item */{
    return {
      x: 0,
      y: 0
    };
  };

  /**
   * iterate over array and position each item
   * Reason being - separating this logic prevents 'layout invalidation'
   * thx @paul_irish
   * @param {Array} queue
   */
  proto._processLayoutQueue = function (queue) {
    this.updateStagger();
    queue.forEach(function (obj, i) {
      this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);
    }, this);
  };

  // set stagger from option in milliseconds number
  proto.updateStagger = function () {
    var stagger = this.options.stagger;
    if (stagger === null || stagger === undefined) {
      this.stagger = 0;
      return;
    }
    this.stagger = getMilliseconds(stagger);
    return this.stagger;
  };

  /**
   * Sets position of item in DOM
   * @param {Outlayer.Item} item
   * @param {Number} x - horizontal position
   * @param {Number} y - vertical position
   * @param {Boolean} isInstant - disables transitions
   */
  proto._positionItem = function (item, x, y, isInstant, i) {
    if (isInstant) {
      // if not transition, just set CSS
      item.goTo(x, y);
    } else {
      item.stagger(i * this.stagger);
      item.moveTo(x, y);
    }
  };

  /**
   * Any logic you want to do after each layout,
   * i.e. size the container
   */
  proto._postLayout = function () {
    this.resizeContainer();
  };

  proto.resizeContainer = function () {
    var isResizingContainer = this._getOption('resizeContainer');
    if (!isResizingContainer) {
      return;
    }
    var size = this._getContainerSize();
    if (size) {
      this._setContainerMeasure(size.width, true);
      this._setContainerMeasure(size.height, false);
    }
  };

  /**
   * Sets width or height of container if returned
   * @returns {Object} size
   *   @param {Number} width
   *   @param {Number} height
   */
  proto._getContainerSize = noop;

  /**
   * @param {Number} measure - size of width or height
   * @param {Boolean} isWidth
   */
  proto._setContainerMeasure = function (measure, isWidth) {
    if (measure === undefined) {
      return;
    }

    var elemSize = this.size;
    // add padding and border width if border box
    if (elemSize.isBorderBox) {
      measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth;
    }

    measure = Math.max(measure, 0);
    this.element.style[isWidth ? 'width' : 'height'] = measure + 'px';
  };

  /**
   * emit eventComplete on a collection of items events
   * @param {String} eventName
   * @param {Array} items - Outlayer.Items
   */
  proto._emitCompleteOnItems = function (eventName, items) {
    var _this = this;
    function onComplete() {
      _this.dispatchEvent(eventName + 'Complete', null, [items]);
    }

    var count = items.length;
    if (!items || !count) {
      onComplete();
      return;
    }

    var doneCount = 0;
    function tick() {
      doneCount++;
      if (doneCount == count) {
        onComplete();
      }
    }

    // bind callback
    items.forEach(function (item) {
      item.once(eventName, tick);
    });
  };

  /**
   * emits events via EvEmitter and jQuery events
   * @param {String} type - name of event
   * @param {Event} event - original event
   * @param {Array} args - extra arguments
   */
  proto.dispatchEvent = function (type, event, args) {
    // add original event to arguments
    var emitArgs = event ? [event].concat(args) : args;
    this.emitEvent(type, emitArgs);

    if (jQuery) {
      // set this.$element
      this.$element = this.$element || jQuery(this.element);
      if (event) {
        // create jQuery event
        var $event = jQuery.Event(event);
        $event.type = type;
        this.$element.trigger($event, args);
      } else {
        // just trigger with type if no event available
        this.$element.trigger(type, args);
      }
    }
  };

  // -------------------------- ignore & stamps -------------------------- //


  /**
   * keep item in collection, but do not lay it out
   * ignored items do not get skipped in layout
   * @param {Element} elem
   */
  proto.ignore = function (elem) {
    var item = this.getItem(elem);
    if (item) {
      item.isIgnored = true;
    }
  };

  /**
   * return item to layout collection
   * @param {Element} elem
   */
  proto.unignore = function (elem) {
    var item = this.getItem(elem);
    if (item) {
      delete item.isIgnored;
    }
  };

  /**
   * adds elements to stamps
   * @param {NodeList, Array, Element, or String} elems
   */
  proto.stamp = function (elems) {
    elems = this._find(elems);
    if (!elems) {
      return;
    }

    this.stamps = this.stamps.concat(elems);
    // ignore
    elems.forEach(this.ignore, this);
  };

  /**
   * removes elements to stamps
   * @param {NodeList, Array, or Element} elems
   */
  proto.unstamp = function (elems) {
    elems = this._find(elems);
    if (!elems) {
      return;
    }

    elems.forEach(function (elem) {
      // filter out removed stamp elements
      utils.removeFrom(this.stamps, elem);
      this.unignore(elem);
    }, this);
  };

  /**
   * finds child elements
   * @param {NodeList, Array, Element, or String} elems
   * @returns {Array} elems
   */
  proto._find = function (elems) {
    if (!elems) {
      return;
    }
    // if string, use argument as selector string
    if (typeof elems == 'string') {
      elems = this.element.querySelectorAll(elems);
    }
    elems = utils.makeArray(elems);
    return elems;
  };

  proto._manageStamps = function () {
    if (!this.stamps || !this.stamps.length) {
      return;
    }

    this._getBoundingRect();

    this.stamps.forEach(this._manageStamp, this);
  };

  // update boundingLeft / Top
  proto._getBoundingRect = function () {
    // get bounding rect for container element
    var boundingRect = this.element.getBoundingClientRect();
    var size = this.size;
    this._boundingRect = {
      left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
      top: boundingRect.top + size.paddingTop + size.borderTopWidth,
      right: boundingRect.right - (size.paddingRight + size.borderRightWidth),
      bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)
    };
  };

  /**
   * @param {Element} stamp
  **/
  proto._manageStamp = noop;

  /**
   * get x/y position of element relative to container element
   * @param {Element} elem
   * @returns {Object} offset - has left, top, right, bottom
   */
  proto._getElementOffset = function (elem) {
    var boundingRect = elem.getBoundingClientRect();
    var thisRect = this._boundingRect;
    var size = getSize(elem);
    var offset = {
      left: boundingRect.left - thisRect.left - size.marginLeft,
      top: boundingRect.top - thisRect.top - size.marginTop,
      right: thisRect.right - boundingRect.right - size.marginRight,
      bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
    };
    return offset;
  };

  // -------------------------- resize -------------------------- //

  // enable event handlers for listeners
  // i.e. resize -> onresize
  proto.handleEvent = utils.handleEvent;

  /**
   * Bind layout to window resizing
   */
  proto.bindResize = function () {
    window.addEventListener('resize', this);
    this.isResizeBound = true;
  };

  /**
   * Unbind layout to window resizing
   */
  proto.unbindResize = function () {
    window.removeEventListener('resize', this);
    this.isResizeBound = false;
  };

  proto.onresize = function () {
    this.resize();
  };

  utils.debounceMethod(Outlayer, 'onresize', 100);

  proto.resize = function () {
    // don't trigger if size did not change
    // or if resize was unbound. See #9
    if (!this.isResizeBound || !this.needsResizeLayout()) {
      return;
    }

    this.layout();
  };

  /**
   * check if layout is needed post layout
   * @returns Boolean
   */
  proto.needsResizeLayout = function () {
    var size = getSize(this.element);
    // check that this.size and size are there
    // IE8 triggers resize on body size change, so they might not be
    var hasSizes = this.size && size;
    return hasSizes && size.innerWidth !== this.size.innerWidth;
  };

  // -------------------------- methods -------------------------- //

  /**
   * add items to Outlayer instance
   * @param {Array or NodeList or Element} elems
   * @returns {Array} items - Outlayer.Items
  **/
  proto.addItems = function (elems) {
    var items = this._itemize(elems);
    // add items to collection
    if (items.length) {
      this.items = this.items.concat(items);
    }
    return items;
  };

  /**
   * Layout newly-appended item elements
   * @param {Array or NodeList or Element} elems
   */
  proto.appended = function (elems) {
    var items = this.addItems(elems);
    if (!items.length) {
      return;
    }
    // layout and reveal just the new items
    this.layoutItems(items, true);
    this.reveal(items);
  };

  /**
   * Layout prepended elements
   * @param {Array or NodeList or Element} elems
   */
  proto.prepended = function (elems) {
    var items = this._itemize(elems);
    if (!items.length) {
      return;
    }
    // add items to beginning of collection
    var previousItems = this.items.slice(0);
    this.items = items.concat(previousItems);
    // start new layout
    this._resetLayout();
    this._manageStamps();
    // layout new stuff without transition
    this.layoutItems(items, true);
    this.reveal(items);
    // layout previous items
    this.layoutItems(previousItems);
  };

  /**
   * reveal a collection of items
   * @param {Array of Outlayer.Items} items
   */
  proto.reveal = function (items) {
    this._emitCompleteOnItems('reveal', items);
    if (!items || !items.length) {
      return;
    }
    var stagger = this.updateStagger();
    items.forEach(function (item, i) {
      item.stagger(i * stagger);
      item.reveal();
    });
  };

  /**
   * hide a collection of items
   * @param {Array of Outlayer.Items} items
   */
  proto.hide = function (items) {
    this._emitCompleteOnItems('hide', items);
    if (!items || !items.length) {
      return;
    }
    var stagger = this.updateStagger();
    items.forEach(function (item, i) {
      item.stagger(i * stagger);
      item.hide();
    });
  };

  /**
   * reveal item elements
   * @param {Array}, {Element}, {NodeList} items
   */
  proto.revealItemElements = function (elems) {
    var items = this.getItems(elems);
    this.reveal(items);
  };

  /**
   * hide item elements
   * @param {Array}, {Element}, {NodeList} items
   */
  proto.hideItemElements = function (elems) {
    var items = this.getItems(elems);
    this.hide(items);
  };

  /**
   * get Outlayer.Item, given an Element
   * @param {Element} elem
   * @param {Function} callback
   * @returns {Outlayer.Item} item
   */
  proto.getItem = function (elem) {
    // loop through items to get the one that matches
    for (var i = 0; i < this.items.length; i++) {
      var item = this.items[i];
      if (item.element == elem) {
        // return item
        return item;
      }
    }
  };

  /**
   * get collection of Outlayer.Items, given Elements
   * @param {Array} elems
   * @returns {Array} items - Outlayer.Items
   */
  proto.getItems = function (elems) {
    elems = utils.makeArray(elems);
    var items = [];
    elems.forEach(function (elem) {
      var item = this.getItem(elem);
      if (item) {
        items.push(item);
      }
    }, this);

    return items;
  };

  /**
   * remove element(s) from instance and DOM
   * @param {Array or NodeList or Element} elems
   */
  proto.remove = function (elems) {
    var removeItems = this.getItems(elems);

    this._emitCompleteOnItems('remove', removeItems);

    // bail if no items to remove
    if (!removeItems || !removeItems.length) {
      return;
    }

    removeItems.forEach(function (item) {
      item.remove();
      // remove item from collection
      utils.removeFrom(this.items, item);
    }, this);
  };

  // ----- destroy ----- //

  // remove and disable Outlayer instance
  proto.destroy = function () {
    // clean up dynamic styles
    var style = this.element.style;
    style.height = '';
    style.position = '';
    style.width = '';
    // destroy items
    this.items.forEach(function (item) {
      item.destroy();
    });

    this.unbindResize();

    var id = this.element.outlayerGUID;
    delete instances[id]; // remove reference to instance by id
    delete this.element.outlayerGUID;
    // remove data for jQuery
    if (jQuery) {
      jQuery.removeData(this.element, this.constructor.namespace);
    }
  };

  // -------------------------- data -------------------------- //

  /**
   * get Outlayer instance from element
   * @param {Element} elem
   * @returns {Outlayer}
   */
  Outlayer.data = function (elem) {
    elem = utils.getQueryElement(elem);
    var id = elem && elem.outlayerGUID;
    return id && instances[id];
  };

  // -------------------------- create Outlayer class -------------------------- //

  /**
   * create a layout class
   * @param {String} namespace
   */
  Outlayer.create = function (namespace, options) {
    // sub-class Outlayer
    var Layout = subclass(Outlayer);
    // apply new options and compatOptions
    Layout.defaults = utils.extend({}, Outlayer.defaults);
    utils.extend(Layout.defaults, options);
    Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);

    Layout.namespace = namespace;

    Layout.data = Outlayer.data;

    // sub-class Item
    Layout.Item = subclass(Item);

    // -------------------------- declarative -------------------------- //

    utils.htmlInit(Layout, namespace);

    // -------------------------- jQuery bridge -------------------------- //

    // make into jQuery plugin
    if (jQuery && jQuery.bridget) {
      jQuery.bridget(namespace, Layout);
    }

    return Layout;
  };

  function subclass(Parent) {
    function SubClass() {
      Parent.apply(this, arguments);
    }

    SubClass.prototype = Object.create(Parent.prototype);
    SubClass.prototype.constructor = SubClass;

    return SubClass;
  }

  // ----- helpers ----- //

  // how many milliseconds are in each unit
  var msUnits = {
    ms: 1,
    s: 1000
  };

  // munge time-like parameter into millisecond number
  // '0.4s' -> 40
  function getMilliseconds(time) {
    if (typeof time == 'number') {
      return time;
    }
    var matches = time.match(/(^\d*\.?\d*)(\w*)/);
    var num = matches && matches[1];
    var unit = matches && matches[2];
    if (!num.length) {
      return 0;
    }
    num = parseFloat(num);
    var mult = msUnits[unit] || 1;
    return num * mult;
  }

  // ----- fin ----- //

  // back in global
  Outlayer.Item = Item;

  return Outlayer;
});

/*!
 * Masonry v4.1.1
 * Cascading grid layout library
 * http://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */

(function (window, factory) {
  // universal module definition
  /* jshint strict: false */ /*globals define, module, require */
  if (typeof define == 'function' && define.amd) {
    // AMD
    define(['outlayer/outlayer', 'get-size/get-size'], factory);
  } else if (typeof module == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(require('outlayer'), require('get-size'));
  } else {
    // browser global
    window.Masonry = factory(window.Outlayer, window.getSize);
  }
})(window, function factory(Outlayer, getSize) {

  // -------------------------- masonryDefinition -------------------------- //

  // create an Outlayer layout class
  var Masonry = Outlayer.create('masonry');
  // isFitWidth -> fitWidth
  Masonry.compatOptions.fitWidth = 'isFitWidth';

  Masonry.prototype._resetLayout = function () {
    this.getSize();
    this._getMeasurement('columnWidth', 'outerWidth');
    this._getMeasurement('gutter', 'outerWidth');
    this.measureColumns();

    // reset column Y
    this.colYs = [];
    for (var i = 0; i < this.cols; i++) {
      this.colYs.push(0);
    }

    this.maxY = 0;
  };

  Masonry.prototype.measureColumns = function () {
    this.getContainerWidth();
    // if columnWidth is 0, default to outerWidth of first item
    if (!this.columnWidth) {
      var firstItem = this.items[0];
      var firstItemElem = firstItem && firstItem.element;
      // columnWidth fall back to item of first element
      this.columnWidth = firstItemElem && getSize(firstItemElem).outerWidth ||
      // if first elem has no width, default to size of container
      this.containerWidth;
    }

    var columnWidth = this.columnWidth += this.gutter;

    // calculate columns
    var containerWidth = this.containerWidth + this.gutter;
    var cols = containerWidth / columnWidth;
    // fix rounding errors, typically with gutters
    var excess = columnWidth - containerWidth % columnWidth;
    // if overshoot is less than a pixel, round up, otherwise floor it
    var mathMethod = excess && excess < 1 ? 'round' : 'floor';
    cols = Math[mathMethod](cols);
    this.cols = Math.max(cols, 1);
  };

  Masonry.prototype.getContainerWidth = function () {
    // container is parent if fit width
    var isFitWidth = this._getOption('fitWidth');
    var container = isFitWidth ? this.element.parentNode : this.element;
    // check that this.size and size are there
    // IE8 triggers resize on body size change, so they might not be
    var size = getSize(container);
    this.containerWidth = size && size.innerWidth;
  };

  Masonry.prototype._getItemLayoutPosition = function (item) {
    item.getSize();
    // how many columns does this brick span
    var remainder = item.size.outerWidth % this.columnWidth;
    var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';
    // round if off by 1 pixel, otherwise use ceil
    var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);
    colSpan = Math.min(colSpan, this.cols);

    var colGroup = this._getColGroup(colSpan);
    // get the minimum Y value from the columns
    var minimumY = Math.min.apply(Math, colGroup);
    var shortColIndex = colGroup.indexOf(minimumY);

    // position the brick
    var position = {
      x: this.columnWidth * shortColIndex,
      y: minimumY
    };

    // apply setHeight to necessary columns
    var setHeight = minimumY + item.size.outerHeight;
    var setSpan = this.cols + 1 - colGroup.length;
    for (var i = 0; i < setSpan; i++) {
      this.colYs[shortColIndex + i] = setHeight;
    }

    return position;
  };

  /**
   * @param {Number} colSpan - number of columns the element spans
   * @returns {Array} colGroup
   */
  Masonry.prototype._getColGroup = function (colSpan) {
    if (colSpan < 2) {
      // if brick spans only one column, use all the column Ys
      return this.colYs;
    }

    var colGroup = [];
    // how many different places could this brick fit horizontally
    var groupCount = this.cols + 1 - colSpan;
    // for each group potential horizontal position
    for (var i = 0; i < groupCount; i++) {
      // make an array of colY values for that one group
      var groupColYs = this.colYs.slice(i, i + colSpan);
      // and get the max value of the array
      colGroup[i] = Math.max.apply(Math, groupColYs);
    }
    return colGroup;
  };

  Masonry.prototype._manageStamp = function (stamp) {
    var stampSize = getSize(stamp);
    var offset = this._getElementOffset(stamp);
    // get the columns that this stamp affects
    var isOriginLeft = this._getOption('originLeft');
    var firstX = isOriginLeft ? offset.left : offset.right;
    var lastX = firstX + stampSize.outerWidth;
    var firstCol = Math.floor(firstX / this.columnWidth);
    firstCol = Math.max(0, firstCol);
    var lastCol = Math.floor(lastX / this.columnWidth);
    // lastCol should not go over if multiple of columnWidth #425
    lastCol -= lastX % this.columnWidth ? 0 : 1;
    lastCol = Math.min(this.cols - 1, lastCol);
    // set colYs to bottom of the stamp

    var isOriginTop = this._getOption('originTop');
    var stampMaxY = (isOriginTop ? offset.top : offset.bottom) + stampSize.outerHeight;
    for (var i = firstCol; i <= lastCol; i++) {
      this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);
    }
  };

  Masonry.prototype._getContainerSize = function () {
    this.maxY = Math.max.apply(Math, this.colYs);
    var size = {
      height: this.maxY
    };

    if (this._getOption('fitWidth')) {
      size.width = this._getContainerFitWidth();
    }

    return size;
  };

  Masonry.prototype._getContainerFitWidth = function () {
    var unusedCols = 0;
    // count unused columns
    var i = this.cols;
    while (--i) {
      if (this.colYs[i] !== 0) {
        break;
      }
      unusedCols++;
    }
    // fit container to columns that have been used
    return (this.cols - unusedCols) * this.columnWidth - this.gutter;
  };

  Masonry.prototype.needsResizeLayout = function () {
    var previousWidth = this.containerWidth;
    this.getContainerWidth();
    return previousWidth != this.containerWidth;
  };

  return Masonry;
});
'use strict';

// $(document).foundation();

$(document).ready(function () {
	Site.init();
});

var Site = {
	init: function () {
		if ($(window).width() > 640) {
			Site.scrollmagic();
		}
		Site.mobileMenu();
	},
	mobileMenu: function () {
		$(document).on('click', '.menu-toggle', function (event) {
			event.preventDefault();
			$('body').toggleClass('menu-open');
			return false;
		});
		$(document).on('click', '.menu a', function () {
			$('body').removeClass('menu-open');
		});
	},
	scrollmagic: function () {
		var controller = new ScrollMagic.Controller();
		var images = $('.parallax');
		var windowHeight = $(window).height();

		$.each(images, function (index, image) {
			var tween = new TweenMax.fromTo(image, 1, { transform: 'translateY(-4em)' }, { transform: 'translateY(12em)' });
			var scene = new ScrollMagic.Scene({
				duration: windowHeight * 2,
				triggerElement: image,
				triggerHook: 1
			}).setTween(tween).addTo(controller);
		});
	}
};
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5qcyIsIlR3ZWVuTWF4LmpzIiwiU2Nyb2xsTWFnaWMuanMiLCJhbmltYXRpb24uZ3NhcC5qcyIsImpxdWVyeS5sYXp5bG9hZHh0LmpzIiwianF1ZXJ5Lmxhenlsb2FkeHQuYXV0b2xvYWQuanMiLCJqcXVlcnkubGF6eWxvYWR4dC5iZy5qcyIsImZvdW5kYXRpb24uY29yZS5qcyIsImZvdW5kYXRpb24udXRpbC5ib3guanMiLCJmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanMiLCJmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qcyIsImZvdW5kYXRpb24udXRpbC5tb3Rpb24uanMiLCJmb3VuZGF0aW9uLnV0aWwubmVzdC5qcyIsImZvdW5kYXRpb24udXRpbC50aW1lckFuZEltYWdlTG9hZGVyLmpzIiwiZm91bmRhdGlvbi51dGlsLnRvdWNoLmpzIiwiZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzIiwibWFzb25yeS5wa2dkLmpzIiwiYXBwLmpzIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiZG9jdW1lbnQiLCJ3IiwiRXJyb3IiLCJ3aW5kb3ciLCJub0dsb2JhbCIsImFyciIsInNsaWNlIiwiY29uY2F0IiwicHVzaCIsImluZGV4T2YiLCJjbGFzczJ0eXBlIiwidG9TdHJpbmciLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsInN1cHBvcnQiLCJ2ZXJzaW9uIiwialF1ZXJ5Iiwic2VsZWN0b3IiLCJjb250ZXh0IiwiZm4iLCJpbml0IiwicnRyaW0iLCJybXNQcmVmaXgiLCJyZGFzaEFscGhhIiwiZmNhbWVsQ2FzZSIsImFsbCIsImxldHRlciIsInRvVXBwZXJDYXNlIiwicHJvdG90eXBlIiwianF1ZXJ5IiwiY29uc3RydWN0b3IiLCJsZW5ndGgiLCJ0b0FycmF5IiwiY2FsbCIsImdldCIsIm51bSIsInB1c2hTdGFjayIsImVsZW1zIiwicmV0IiwibWVyZ2UiLCJwcmV2T2JqZWN0IiwiZWFjaCIsImNhbGxiYWNrIiwibWFwIiwiZWxlbSIsImkiLCJhcHBseSIsImFyZ3VtZW50cyIsImZpcnN0IiwiZXEiLCJsYXN0IiwibGVuIiwiaiIsImVuZCIsInNvcnQiLCJzcGxpY2UiLCJleHRlbmQiLCJvcHRpb25zIiwibmFtZSIsInNyYyIsImNvcHkiLCJjb3B5SXNBcnJheSIsImNsb25lIiwidGFyZ2V0IiwiZGVlcCIsImlzRnVuY3Rpb24iLCJpc1BsYWluT2JqZWN0IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImV4cGFuZG8iLCJNYXRoIiwicmFuZG9tIiwicmVwbGFjZSIsImlzUmVhZHkiLCJlcnJvciIsIm1zZyIsIm5vb3AiLCJvYmoiLCJ0eXBlIiwiQXJyYXkiLCJpc1dpbmRvdyIsImlzTnVtZXJpYyIsInJlYWxTdHJpbmdPYmoiLCJwYXJzZUZsb2F0Iiwia2V5Iiwibm9kZVR5cGUiLCJpc0VtcHR5T2JqZWN0IiwiZ2xvYmFsRXZhbCIsImNvZGUiLCJzY3JpcHQiLCJpbmRpcmVjdCIsImV2YWwiLCJ0cmltIiwiY3JlYXRlRWxlbWVudCIsInRleHQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjYW1lbENhc2UiLCJzdHJpbmciLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiaXNBcnJheUxpa2UiLCJtYWtlQXJyYXkiLCJyZXN1bHRzIiwiT2JqZWN0IiwiaW5BcnJheSIsInNlY29uZCIsImdyZXAiLCJpbnZlcnQiLCJjYWxsYmFja0ludmVyc2UiLCJtYXRjaGVzIiwiY2FsbGJhY2tFeHBlY3QiLCJhcmciLCJ2YWx1ZSIsImd1aWQiLCJwcm94eSIsInRtcCIsImFyZ3MiLCJub3ciLCJEYXRlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJzcGxpdCIsIlNpenpsZSIsIkV4cHIiLCJnZXRUZXh0IiwiaXNYTUwiLCJ0b2tlbml6ZSIsImNvbXBpbGUiLCJzZWxlY3QiLCJvdXRlcm1vc3RDb250ZXh0Iiwic29ydElucHV0IiwiaGFzRHVwbGljYXRlIiwic2V0RG9jdW1lbnQiLCJkb2NFbGVtIiwiZG9jdW1lbnRJc0hUTUwiLCJyYnVnZ3lRU0EiLCJyYnVnZ3lNYXRjaGVzIiwiY29udGFpbnMiLCJwcmVmZXJyZWREb2MiLCJkaXJydW5zIiwiZG9uZSIsImNsYXNzQ2FjaGUiLCJjcmVhdGVDYWNoZSIsInRva2VuQ2FjaGUiLCJjb21waWxlckNhY2hlIiwic29ydE9yZGVyIiwiYSIsImIiLCJNQVhfTkVHQVRJVkUiLCJwb3AiLCJwdXNoX25hdGl2ZSIsImxpc3QiLCJib29sZWFucyIsIndoaXRlc3BhY2UiLCJpZGVudGlmaWVyIiwiYXR0cmlidXRlcyIsInBzZXVkb3MiLCJyd2hpdGVzcGFjZSIsIlJlZ0V4cCIsInJjb21tYSIsInJjb21iaW5hdG9ycyIsInJhdHRyaWJ1dGVRdW90ZXMiLCJycHNldWRvIiwicmlkZW50aWZpZXIiLCJtYXRjaEV4cHIiLCJyaW5wdXRzIiwicmhlYWRlciIsInJuYXRpdmUiLCJycXVpY2tFeHByIiwicnNpYmxpbmciLCJyZXNjYXBlIiwicnVuZXNjYXBlIiwiZnVuZXNjYXBlIiwiXyIsImVzY2FwZWQiLCJlc2NhcGVkV2hpdGVzcGFjZSIsImhpZ2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ1bmxvYWRIYW5kbGVyIiwiY2hpbGROb2RlcyIsImUiLCJlbHMiLCJzZWVkIiwibSIsIm5pZCIsIm5pZHNlbGVjdCIsIm1hdGNoIiwiZ3JvdXBzIiwibmV3U2VsZWN0b3IiLCJuZXdDb250ZXh0Iiwib3duZXJEb2N1bWVudCIsImV4ZWMiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwicXNhIiwidGVzdCIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInRvU2VsZWN0b3IiLCJqb2luIiwidGVzdENvbnRleHQiLCJxdWVyeVNlbGVjdG9yQWxsIiwicXNhRXJyb3IiLCJyZW1vdmVBdHRyaWJ1dGUiLCJrZXlzIiwiY2FjaGUiLCJjYWNoZUxlbmd0aCIsInNoaWZ0IiwibWFya0Z1bmN0aW9uIiwiYXNzZXJ0IiwiZGl2IiwiYWRkSGFuZGxlIiwiYXR0cnMiLCJoYW5kbGVyIiwiYXR0ckhhbmRsZSIsInNpYmxpbmdDaGVjayIsImN1ciIsImRpZmYiLCJzb3VyY2VJbmRleCIsIm5leHRTaWJsaW5nIiwiY3JlYXRlSW5wdXRQc2V1ZG8iLCJjcmVhdGVCdXR0b25Qc2V1ZG8iLCJjcmVhdGVQb3NpdGlvbmFsUHNldWRvIiwiYXJndW1lbnQiLCJtYXRjaEluZGV4ZXMiLCJkb2N1bWVudEVsZW1lbnQiLCJub2RlIiwiaGFzQ29tcGFyZSIsInBhcmVudCIsImRvYyIsImRlZmF1bHRWaWV3IiwidG9wIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2xhc3NOYW1lIiwiY3JlYXRlQ29tbWVudCIsImdldEJ5SWQiLCJnZXRFbGVtZW50c0J5TmFtZSIsImZpbmQiLCJmaWx0ZXIiLCJhdHRySWQiLCJnZXRBdHRyaWJ1dGVOb2RlIiwidGFnIiwiaW5uZXJIVE1MIiwiaW5wdXQiLCJtYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJkaXNjb25uZWN0ZWRNYXRjaCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiYWRvd24iLCJidXAiLCJjb21wYXJlIiwic29ydERldGFjaGVkIiwiYXVwIiwiYXAiLCJicCIsInVuc2hpZnQiLCJleHByIiwiZWxlbWVudHMiLCJhdHRyIiwidmFsIiwic3BlY2lmaWVkIiwidW5pcXVlU29ydCIsImR1cGxpY2F0ZXMiLCJkZXRlY3REdXBsaWNhdGVzIiwic29ydFN0YWJsZSIsInRleHRDb250ZW50IiwiZmlyc3RDaGlsZCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsInJlbGF0aXZlIiwiZGlyIiwicHJlRmlsdGVyIiwiZXhjZXNzIiwidW5xdW90ZWQiLCJub2RlTmFtZVNlbGVjdG9yIiwicGF0dGVybiIsIm9wZXJhdG9yIiwiY2hlY2siLCJyZXN1bHQiLCJ3aGF0Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsInhtbCIsInVuaXF1ZUNhY2hlIiwib3V0ZXJDYWNoZSIsIm5vZGVJbmRleCIsInN0YXJ0IiwidXNlQ2FjaGUiLCJsYXN0Q2hpbGQiLCJ1bmlxdWVJRCIsInBzZXVkbyIsInNldEZpbHRlcnMiLCJpZHgiLCJtYXRjaGVkIiwibWF0Y2hlciIsInVubWF0Y2hlZCIsImlubmVyVGV4dCIsImxhbmciLCJlbGVtTGFuZyIsImhhc2giLCJsb2NhdGlvbiIsImFjdGl2ZUVsZW1lbnQiLCJoYXNGb2N1cyIsImhyZWYiLCJ0YWJJbmRleCIsImRpc2FibGVkIiwiY2hlY2tlZCIsInNlbGVjdGVkIiwic2VsZWN0ZWRJbmRleCIsInJhZGlvIiwiY2hlY2tib3giLCJmaWxlIiwicGFzc3dvcmQiLCJpbWFnZSIsInN1Ym1pdCIsInJlc2V0IiwiZmlsdGVycyIsInBhcnNlT25seSIsInRva2VucyIsInNvRmFyIiwicHJlRmlsdGVycyIsImNhY2hlZCIsImFkZENvbWJpbmF0b3IiLCJjb21iaW5hdG9yIiwiYmFzZSIsImNoZWNrTm9uRWxlbWVudHMiLCJkb25lTmFtZSIsIm9sZENhY2hlIiwibmV3Q2FjaGUiLCJlbGVtZW50TWF0Y2hlciIsIm1hdGNoZXJzIiwibXVsdGlwbGVDb250ZXh0cyIsImNvbnRleHRzIiwiY29uZGVuc2UiLCJuZXdVbm1hdGNoZWQiLCJtYXBwZWQiLCJzZXRNYXRjaGVyIiwicG9zdEZpbHRlciIsInBvc3RGaW5kZXIiLCJwb3N0U2VsZWN0b3IiLCJ0ZW1wIiwicHJlTWFwIiwicG9zdE1hcCIsInByZWV4aXN0aW5nIiwibWF0Y2hlckluIiwibWF0Y2hlck91dCIsIm1hdGNoZXJGcm9tVG9rZW5zIiwiY2hlY2tDb250ZXh0IiwibGVhZGluZ1JlbGF0aXZlIiwiaW1wbGljaXRSZWxhdGl2ZSIsIm1hdGNoQ29udGV4dCIsIm1hdGNoQW55Q29udGV4dCIsIm1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyIsImVsZW1lbnRNYXRjaGVycyIsInNldE1hdGNoZXJzIiwiYnlTZXQiLCJieUVsZW1lbnQiLCJzdXBlck1hdGNoZXIiLCJvdXRlcm1vc3QiLCJtYXRjaGVkQ291bnQiLCJzZXRNYXRjaGVkIiwiY29udGV4dEJhY2t1cCIsImRpcnJ1bnNVbmlxdWUiLCJ0b2tlbiIsImNvbXBpbGVkIiwiZGl2MSIsImRlZmF1bHRWYWx1ZSIsInVuaXF1ZSIsImlzWE1MRG9jIiwidW50aWwiLCJ0cnVuY2F0ZSIsImlzIiwic2libGluZ3MiLCJuIiwicm5lZWRzQ29udGV4dCIsIm5lZWRzQ29udGV4dCIsInJzaW5nbGVUYWciLCJyaXNTaW1wbGUiLCJ3aW5ub3ciLCJxdWFsaWZpZXIiLCJub3QiLCJzZWxmIiwicm9vdGpRdWVyeSIsInJvb3QiLCJwYXJzZUhUTUwiLCJyZWFkeSIsInJwYXJlbnRzcHJldiIsImd1YXJhbnRlZWRVbmlxdWUiLCJjaGlsZHJlbiIsImNvbnRlbnRzIiwibmV4dCIsInByZXYiLCJoYXMiLCJ0YXJnZXRzIiwibCIsImNsb3Nlc3QiLCJwb3MiLCJpbmRleCIsInByZXZBbGwiLCJhZGQiLCJhZGRCYWNrIiwic2libGluZyIsInBhcmVudHMiLCJwYXJlbnRzVW50aWwiLCJuZXh0QWxsIiwibmV4dFVudGlsIiwicHJldlVudGlsIiwiY29udGVudERvY3VtZW50IiwicmV2ZXJzZSIsInJub3R3aGl0ZSIsImNyZWF0ZU9wdGlvbnMiLCJvYmplY3QiLCJmbGFnIiwiQ2FsbGJhY2tzIiwiZmlyaW5nIiwibWVtb3J5IiwiZmlyZWQiLCJsb2NrZWQiLCJxdWV1ZSIsImZpcmluZ0luZGV4IiwiZmlyZSIsIm9uY2UiLCJzdG9wT25GYWxzZSIsInJlbW92ZSIsImVtcHR5IiwiZGlzYWJsZSIsImxvY2siLCJmaXJlV2l0aCIsIkRlZmVycmVkIiwiZnVuYyIsInR1cGxlcyIsInN0YXRlIiwicHJvbWlzZSIsImFsd2F5cyIsImRlZmVycmVkIiwiZmFpbCIsInRoZW4iLCJmbnMiLCJuZXdEZWZlciIsInR1cGxlIiwicmV0dXJuZWQiLCJwcm9ncmVzcyIsIm5vdGlmeSIsInJlc29sdmUiLCJyZWplY3QiLCJwaXBlIiwic3RhdGVTdHJpbmciLCJ3aGVuIiwic3Vib3JkaW5hdGUiLCJyZXNvbHZlVmFsdWVzIiwicmVtYWluaW5nIiwidXBkYXRlRnVuYyIsInZhbHVlcyIsInByb2dyZXNzVmFsdWVzIiwibm90aWZ5V2l0aCIsInJlc29sdmVXaXRoIiwicHJvZ3Jlc3NDb250ZXh0cyIsInJlc29sdmVDb250ZXh0cyIsInJlYWR5TGlzdCIsInJlYWR5V2FpdCIsImhvbGRSZWFkeSIsImhvbGQiLCJ3YWl0IiwidHJpZ2dlckhhbmRsZXIiLCJvZmYiLCJjb21wbGV0ZWQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVhZHlTdGF0ZSIsImRvU2Nyb2xsIiwic2V0VGltZW91dCIsImFjY2VzcyIsImNoYWluYWJsZSIsImVtcHR5R2V0IiwicmF3IiwiYnVsayIsImFjY2VwdERhdGEiLCJvd25lciIsIkRhdGEiLCJ1aWQiLCJyZWdpc3RlciIsImluaXRpYWwiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwic2V0IiwiZGF0YSIsInByb3AiLCJzdG9yZWQiLCJjYW1lbCIsImhhc0RhdGEiLCJkYXRhUHJpdiIsImRhdGFVc2VyIiwicmJyYWNlIiwicm11bHRpRGFzaCIsImRhdGFBdHRyIiwicGFyc2VKU09OIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJjYW1lbEtleSIsImRlcXVldWUiLCJzdGFydExlbmd0aCIsImhvb2tzIiwiX3F1ZXVlSG9va3MiLCJzdG9wIiwic2V0dGVyIiwiY2xlYXJRdWV1ZSIsImNvdW50IiwiZGVmZXIiLCJwbnVtIiwic291cmNlIiwicmNzc051bSIsImNzc0V4cGFuZCIsImlzSGlkZGVuIiwiZWwiLCJjc3MiLCJhZGp1c3RDU1MiLCJ2YWx1ZVBhcnRzIiwidHdlZW4iLCJhZGp1c3RlZCIsInNjYWxlIiwibWF4SXRlcmF0aW9ucyIsImN1cnJlbnRWYWx1ZSIsInVuaXQiLCJjc3NOdW1iZXIiLCJpbml0aWFsSW5Vbml0Iiwic3R5bGUiLCJyY2hlY2thYmxlVHlwZSIsInJ0YWdOYW1lIiwicnNjcmlwdFR5cGUiLCJ3cmFwTWFwIiwib3B0aW9uIiwidGhlYWQiLCJjb2wiLCJ0ciIsInRkIiwiX2RlZmF1bHQiLCJvcHRncm91cCIsInRib2R5IiwidGZvb3QiLCJjb2xncm91cCIsImNhcHRpb24iLCJ0aCIsImdldEFsbCIsInNldEdsb2JhbEV2YWwiLCJyZWZFbGVtZW50cyIsInJodG1sIiwiYnVpbGRGcmFnbWVudCIsInNjcmlwdHMiLCJzZWxlY3Rpb24iLCJpZ25vcmVkIiwid3JhcCIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIm5vZGVzIiwiY3JlYXRlVGV4dE5vZGUiLCJodG1sUHJlZmlsdGVyIiwiY2hlY2tDbG9uZSIsImNsb25lTm9kZSIsIm5vQ2xvbmVDaGVja2VkIiwicmtleUV2ZW50Iiwicm1vdXNlRXZlbnQiLCJydHlwZW5hbWVzcGFjZSIsInJldHVyblRydWUiLCJyZXR1cm5GYWxzZSIsInNhZmVBY3RpdmVFbGVtZW50IiwiZXJyIiwib24iLCJ0eXBlcyIsIm9uZSIsIm9yaWdGbiIsImV2ZW50IiwiaGFuZGxlT2JqSW4iLCJldmVudEhhbmRsZSIsImV2ZW50cyIsInQiLCJoYW5kbGVPYmoiLCJzcGVjaWFsIiwiaGFuZGxlcnMiLCJuYW1lc3BhY2VzIiwib3JpZ1R5cGUiLCJlbGVtRGF0YSIsImhhbmRsZSIsInRyaWdnZXJlZCIsImRpc3BhdGNoIiwiZGVsZWdhdGVUeXBlIiwiYmluZFR5cGUiLCJuYW1lc3BhY2UiLCJkZWxlZ2F0ZUNvdW50Iiwic2V0dXAiLCJtYXBwZWRUeXBlcyIsIm9yaWdDb3VudCIsInRlYXJkb3duIiwicmVtb3ZlRXZlbnQiLCJmaXgiLCJoYW5kbGVyUXVldWUiLCJkZWxlZ2F0ZVRhcmdldCIsInByZURpc3BhdGNoIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJjdXJyZW50VGFyZ2V0IiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJybmFtZXNwYWNlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwb3N0RGlzcGF0Y2giLCJzZWwiLCJpc05hTiIsImJ1dHRvbiIsInByb3BzIiwiZml4SG9va3MiLCJrZXlIb29rcyIsIm9yaWdpbmFsIiwid2hpY2giLCJjaGFyQ29kZSIsImtleUNvZGUiLCJtb3VzZUhvb2tzIiwiZXZlbnREb2MiLCJib2R5IiwicGFnZVgiLCJjbGllbnRYIiwic2Nyb2xsTGVmdCIsImNsaWVudExlZnQiLCJwYWdlWSIsImNsaWVudFkiLCJzY3JvbGxUb3AiLCJjbGllbnRUb3AiLCJvcmlnaW5hbEV2ZW50IiwiZml4SG9vayIsIkV2ZW50IiwibG9hZCIsIm5vQnViYmxlIiwiZm9jdXMiLCJ0cmlnZ2VyIiwiYmx1ciIsImNsaWNrIiwiYmVmb3JldW5sb2FkIiwicmV0dXJuVmFsdWUiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwidGltZVN0YW1wIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVybGVhdmUiLCJvcmlnIiwicmVsYXRlZCIsInJlbGF0ZWRUYXJnZXQiLCJyeGh0bWxUYWciLCJybm9Jbm5lcmh0bWwiLCJyY2hlY2tlZCIsInJzY3JpcHRUeXBlTWFza2VkIiwicmNsZWFuU2NyaXB0IiwibWFuaXB1bGF0aW9uVGFyZ2V0IiwiY29udGVudCIsImRpc2FibGVTY3JpcHQiLCJyZXN0b3JlU2NyaXB0IiwiY2xvbmVDb3B5RXZlbnQiLCJkZXN0IiwicGRhdGFPbGQiLCJwZGF0YUN1ciIsInVkYXRhT2xkIiwidWRhdGFDdXIiLCJmaXhJbnB1dCIsImRvbU1hbmlwIiwiY29sbGVjdGlvbiIsImhhc1NjcmlwdHMiLCJpTm9DbG9uZSIsImh0bWwiLCJfZXZhbFVybCIsImtlZXBEYXRhIiwiY2xlYW5EYXRhIiwiZGF0YUFuZEV2ZW50cyIsImRlZXBEYXRhQW5kRXZlbnRzIiwic3JjRWxlbWVudHMiLCJkZXN0RWxlbWVudHMiLCJpblBhZ2UiLCJkZXRhY2giLCJhcHBlbmQiLCJwcmVwZW5kIiwiaW5zZXJ0QmVmb3JlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyZXBsYWNlV2l0aCIsInJlcGxhY2VDaGlsZCIsImFwcGVuZFRvIiwicHJlcGVuZFRvIiwiaW5zZXJ0QWZ0ZXIiLCJyZXBsYWNlQWxsIiwiaW5zZXJ0IiwiaWZyYW1lIiwiZWxlbWRpc3BsYXkiLCJIVE1MIiwiQk9EWSIsImFjdHVhbERpc3BsYXkiLCJkaXNwbGF5IiwiZGVmYXVsdERpc3BsYXkiLCJ3cml0ZSIsImNsb3NlIiwicm1hcmdpbiIsInJudW1ub25weCIsImdldFN0eWxlcyIsInZpZXciLCJvcGVuZXIiLCJnZXRDb21wdXRlZFN0eWxlIiwic3dhcCIsIm9sZCIsInBpeGVsUG9zaXRpb25WYWwiLCJib3hTaXppbmdSZWxpYWJsZVZhbCIsInBpeGVsTWFyZ2luUmlnaHRWYWwiLCJyZWxpYWJsZU1hcmdpbkxlZnRWYWwiLCJjb250YWluZXIiLCJiYWNrZ3JvdW5kQ2xpcCIsImNsZWFyQ2xvbmVTdHlsZSIsImNzc1RleHQiLCJjb21wdXRlU3R5bGVUZXN0cyIsImRpdlN0eWxlIiwibWFyZ2luTGVmdCIsIndpZHRoIiwibWFyZ2luUmlnaHQiLCJwaXhlbFBvc2l0aW9uIiwiYm94U2l6aW5nUmVsaWFibGUiLCJwaXhlbE1hcmdpblJpZ2h0IiwicmVsaWFibGVNYXJnaW5MZWZ0IiwicmVsaWFibGVNYXJnaW5SaWdodCIsIm1hcmdpbkRpdiIsImN1ckNTUyIsImNvbXB1dGVkIiwibWluV2lkdGgiLCJtYXhXaWR0aCIsImdldFByb3BlcnR5VmFsdWUiLCJhZGRHZXRIb29rSWYiLCJjb25kaXRpb25GbiIsImhvb2tGbiIsInJkaXNwbGF5c3dhcCIsImNzc1Nob3ciLCJwb3NpdGlvbiIsInZpc2liaWxpdHkiLCJjc3NOb3JtYWxUcmFuc2Zvcm0iLCJsZXR0ZXJTcGFjaW5nIiwiZm9udFdlaWdodCIsImNzc1ByZWZpeGVzIiwiZW1wdHlTdHlsZSIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsInNldFBvc2l0aXZlTnVtYmVyIiwic3VidHJhY3QiLCJtYXgiLCJhdWdtZW50V2lkdGhPckhlaWdodCIsImV4dHJhIiwiaXNCb3JkZXJCb3giLCJzdHlsZXMiLCJnZXRXaWR0aE9ySGVpZ2h0IiwidmFsdWVJc0JvcmRlckJveCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwibXNGdWxsc2NyZWVuRWxlbWVudCIsImdldENsaWVudFJlY3RzIiwicm91bmQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzaG93SGlkZSIsInNob3ciLCJoaWRkZW4iLCJjc3NIb29rcyIsIm9wYWNpdHkiLCJjc3NQcm9wcyIsIm9yaWdOYW1lIiwiaXNGaW5pdGUiLCJsZWZ0IiwibWFyZ2luIiwicGFkZGluZyIsImJvcmRlciIsInByZWZpeCIsInN1ZmZpeCIsImV4cGFuZCIsImV4cGFuZGVkIiwicGFydHMiLCJoaWRlIiwidG9nZ2xlIiwiVHdlZW4iLCJlYXNpbmciLCJwcm9wSG9va3MiLCJydW4iLCJwZXJjZW50IiwiZWFzZWQiLCJkdXJhdGlvbiIsInN0ZXAiLCJmeCIsImxpbmVhciIsInAiLCJzd2luZyIsImNvcyIsIlBJIiwiZnhOb3ciLCJ0aW1lcklkIiwicmZ4dHlwZXMiLCJycnVuIiwiY3JlYXRlRnhOb3ciLCJnZW5GeCIsImluY2x1ZGVXaWR0aCIsImhlaWdodCIsImNyZWF0ZVR3ZWVuIiwiYW5pbWF0aW9uIiwiQW5pbWF0aW9uIiwidHdlZW5lcnMiLCJkZWZhdWx0UHJlZmlsdGVyIiwib3B0cyIsIm9sZGZpcmUiLCJjaGVja0Rpc3BsYXkiLCJhbmltIiwiZGF0YVNob3ciLCJ1bnF1ZXVlZCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwicHJvcEZpbHRlciIsInNwZWNpYWxFYXNpbmciLCJwcm9wZXJ0aWVzIiwic3RvcHBlZCIsInByZWZpbHRlcnMiLCJ0aWNrIiwiY3VycmVudFRpbWUiLCJzdGFydFRpbWUiLCJ0d2VlbnMiLCJvcmlnaW5hbFByb3BlcnRpZXMiLCJvcmlnaW5hbE9wdGlvbnMiLCJnb3RvRW5kIiwicmVqZWN0V2l0aCIsInRpbWVyIiwiY29tcGxldGUiLCJ0d2VlbmVyIiwicHJlZmlsdGVyIiwic3BlZWQiLCJvcHQiLCJzcGVlZHMiLCJmYWRlVG8iLCJ0byIsImFuaW1hdGUiLCJvcHRhbGwiLCJkb0FuaW1hdGlvbiIsImZpbmlzaCIsInN0b3BRdWV1ZSIsInRpbWVycyIsImNzc0ZuIiwic2xpZGVEb3duIiwic2xpZGVVcCIsInNsaWRlVG9nZ2xlIiwiZmFkZUluIiwiZmFkZU91dCIsImZhZGVUb2dnbGUiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInNsb3ciLCJmYXN0IiwiZGVsYXkiLCJ0aW1lIiwidGltZW91dCIsImNsZWFyVGltZW91dCIsImNoZWNrT24iLCJvcHRTZWxlY3RlZCIsIm9wdERpc2FibGVkIiwicmFkaW9WYWx1ZSIsImJvb2xIb29rIiwicmVtb3ZlQXR0ciIsIm5UeXBlIiwiYXR0ckhvb2tzIiwiYm9vbCIsInByb3BOYW1lIiwiYXR0ck5hbWVzIiwicHJvcEZpeCIsImdldHRlciIsInJmb2N1c2FibGUiLCJyY2xpY2thYmxlIiwicmVtb3ZlUHJvcCIsInRhYmluZGV4IiwicGFyc2VJbnQiLCJyY2xhc3MiLCJnZXRDbGFzcyIsImFkZENsYXNzIiwiY2xhc3NlcyIsImN1clZhbHVlIiwiY2xhenoiLCJmaW5hbFZhbHVlIiwicmVtb3ZlQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsInN0YXRlVmFsIiwiY2xhc3NOYW1lcyIsImhhc0NsYXNzIiwicnJldHVybiIsInJzcGFjZXMiLCJ2YWxIb29rcyIsIm9wdGlvblNldCIsInJmb2N1c01vcnBoIiwib25seUhhbmRsZXJzIiwiYnViYmxlVHlwZSIsIm9udHlwZSIsImV2ZW50UGF0aCIsImlzVHJpZ2dlciIsInBhcmVudFdpbmRvdyIsInNpbXVsYXRlIiwiaXNTaW11bGF0ZWQiLCJob3ZlciIsImZuT3ZlciIsImZuT3V0IiwiZm9jdXNpbiIsImF0dGFjaGVzIiwibm9uY2UiLCJycXVlcnkiLCJKU09OIiwicGFyc2UiLCJwYXJzZVhNTCIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsInJoYXNoIiwicnRzIiwicmhlYWRlcnMiLCJybG9jYWxQcm90b2NvbCIsInJub0NvbnRlbnQiLCJycHJvdG9jb2wiLCJ0cmFuc3BvcnRzIiwiYWxsVHlwZXMiLCJvcmlnaW5BbmNob3IiLCJhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJzdHJ1Y3R1cmUiLCJkYXRhVHlwZUV4cHJlc3Npb24iLCJkYXRhVHlwZSIsImRhdGFUeXBlcyIsImluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwianFYSFIiLCJpbnNwZWN0ZWQiLCJzZWVraW5nVHJhbnNwb3J0IiwiaW5zcGVjdCIsInByZWZpbHRlck9yRmFjdG9yeSIsImRhdGFUeXBlT3JUcmFuc3BvcnQiLCJhamF4RXh0ZW5kIiwiZmxhdE9wdGlvbnMiLCJhamF4U2V0dGluZ3MiLCJhamF4SGFuZGxlUmVzcG9uc2VzIiwicyIsInJlc3BvbnNlcyIsImN0IiwiZmluYWxEYXRhVHlwZSIsImZpcnN0RGF0YVR5cGUiLCJtaW1lVHlwZSIsImdldFJlc3BvbnNlSGVhZGVyIiwiY29udmVydGVycyIsImFqYXhDb252ZXJ0IiwicmVzcG9uc2UiLCJpc1N1Y2Nlc3MiLCJjb252MiIsImN1cnJlbnQiLCJjb252IiwicmVzcG9uc2VGaWVsZHMiLCJkYXRhRmlsdGVyIiwidGhyb3dzIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInVybCIsImlzTG9jYWwiLCJwcm90b2NvbCIsInByb2Nlc3NEYXRhIiwiYXN5bmMiLCJjb250ZW50VHlwZSIsImFjY2VwdHMiLCJqc29uIiwiYWpheFNldHVwIiwic2V0dGluZ3MiLCJhamF4UHJlZmlsdGVyIiwiYWpheFRyYW5zcG9ydCIsImFqYXgiLCJ0cmFuc3BvcnQiLCJjYWNoZVVSTCIsInJlc3BvbnNlSGVhZGVyc1N0cmluZyIsInJlc3BvbnNlSGVhZGVycyIsInRpbWVvdXRUaW1lciIsInVybEFuY2hvciIsImZpcmVHbG9iYWxzIiwiY2FsbGJhY2tDb250ZXh0IiwiZ2xvYmFsRXZlbnRDb250ZXh0IiwiY29tcGxldGVEZWZlcnJlZCIsInN0YXR1c0NvZGUiLCJyZXF1ZXN0SGVhZGVycyIsInJlcXVlc3RIZWFkZXJzTmFtZXMiLCJzdHJBYm9ydCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInNldFJlcXVlc3RIZWFkZXIiLCJsbmFtZSIsIm92ZXJyaWRlTWltZVR5cGUiLCJzdGF0dXMiLCJhYm9ydCIsInN0YXR1c1RleHQiLCJmaW5hbFRleHQiLCJzdWNjZXNzIiwibWV0aG9kIiwiY3Jvc3NEb21haW4iLCJob3N0IiwicGFyYW0iLCJ0cmFkaXRpb25hbCIsImhhc0NvbnRlbnQiLCJpZk1vZGlmaWVkIiwiaGVhZGVycyIsImJlZm9yZVNlbmQiLCJzZW5kIiwibmF0aXZlU3RhdHVzVGV4dCIsIm1vZGlmaWVkIiwiZ2V0SlNPTiIsImdldFNjcmlwdCIsIndyYXBBbGwiLCJmaXJzdEVsZW1lbnRDaGlsZCIsIndyYXBJbm5lciIsInVud3JhcCIsInZpc2libGUiLCJyMjAiLCJyYnJhY2tldCIsInJDUkxGIiwicnN1Ym1pdHRlclR5cGVzIiwicnN1Ym1pdHRhYmxlIiwiYnVpbGRQYXJhbXMiLCJ2IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2VyaWFsaXplIiwic2VyaWFsaXplQXJyYXkiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInhoclN1Y2Nlc3NTdGF0dXMiLCJ4aHJTdXBwb3J0ZWQiLCJjb3JzIiwiZXJyb3JDYWxsYmFjayIsIm9wZW4iLCJ1c2VybmFtZSIsInhockZpZWxkcyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJvbmFib3J0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VUZXh0IiwiYmluYXJ5IiwiY2hhcnNldCIsInNjcmlwdENoYXJzZXQiLCJldnQiLCJvbGRDYWxsYmFja3MiLCJyanNvbnAiLCJqc29ucCIsImpzb25wQ2FsbGJhY2siLCJvcmlnaW5hbFNldHRpbmdzIiwiY2FsbGJhY2tOYW1lIiwib3ZlcndyaXR0ZW4iLCJyZXNwb25zZUNvbnRhaW5lciIsImpzb25Qcm9wIiwia2VlcFNjcmlwdHMiLCJwYXJzZWQiLCJfbG9hZCIsInBhcmFtcyIsImFuaW1hdGVkIiwiZ2V0V2luZG93Iiwib2Zmc2V0Iiwic2V0T2Zmc2V0IiwiY3VyUG9zaXRpb24iLCJjdXJMZWZ0IiwiY3VyQ1NTVG9wIiwiY3VyVG9wIiwiY3VyT2Zmc2V0IiwiY3VyQ1NTTGVmdCIsImNhbGN1bGF0ZVBvc2l0aW9uIiwiY3VyRWxlbSIsInVzaW5nIiwid2luIiwiYm94IiwicGFnZVlPZmZzZXQiLCJwYWdlWE9mZnNldCIsIm9mZnNldFBhcmVudCIsInBhcmVudE9mZnNldCIsInNjcm9sbFRvIiwiSGVpZ2h0IiwiV2lkdGgiLCJkZWZhdWx0RXh0cmEiLCJmdW5jTmFtZSIsImJpbmQiLCJ1bmJpbmQiLCJkZWxlZ2F0ZSIsInVuZGVsZWdhdGUiLCJzaXplIiwiYW5kU2VsZiIsImRlZmluZSIsImFtZCIsIl9qUXVlcnkiLCJfJCIsIiQiLCJub0NvbmZsaWN0IiwiX2dzU2NvcGUiLCJfZ3NRdWV1ZSIsIl9nc0RlZmluZSIsIlNpbXBsZVRpbWVsaW5lIiwiVHdlZW5MaXRlIiwiX3NsaWNlIiwiX2FwcGx5Q3ljbGUiLCJ2YXJzIiwiYWx0IiwiY3ljbGUiLCJUd2Vlbk1heCIsIl9jeWNsZSIsIl95b3lvIiwieW95byIsIl9yZXBlYXQiLCJyZXBlYXQiLCJfcmVwZWF0RGVsYXkiLCJyZXBlYXREZWxheSIsIl9kaXJ0eSIsInJlbmRlciIsIl90aW55TnVtIiwiVHdlZW5MaXRlSW50ZXJuYWxzIiwiX2ludGVybmFscyIsIl9pc1NlbGVjdG9yIiwiaXNTZWxlY3RvciIsIl9pc0FycmF5IiwiX2JsYW5rQXJyYXkiLCJraWxsIiwiX2djIiwia2lsbFR3ZWVuc09mIiwia2lsbERlbGF5ZWRDYWxsc1RvIiwiZ2V0VHdlZW5zT2YiLCJsYWdTbW9vdGhpbmciLCJ0aWNrZXIiLCJpbnZhbGlkYXRlIiwiX3VuY2FjaGUiLCJ1cGRhdGVUbyIsInJlc2V0RHVyYXRpb24iLCJjdXJSYXRpbyIsInJhdGlvIiwiaW1tZWRpYXRlIiwiaW1tZWRpYXRlUmVuZGVyIiwiX3N0YXJ0VGltZSIsIl90aW1lbGluZSIsIl90aW1lIiwiX2VuYWJsZWQiLCJfZGVsYXkiLCJfaW5pdHRlZCIsIl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkIiwiX2ZpcnN0UFQiLCJfb25QbHVnaW5FdmVudCIsIl9kdXJhdGlvbiIsInByZXZUaW1lIiwiX3RvdGFsVGltZSIsIl9pbml0IiwiaW52IiwicHQiLCJlbmRWYWx1ZSIsImMiLCJfbmV4dCIsInN1cHByZXNzRXZlbnRzIiwiZm9yY2UiLCJ0b3RhbER1ciIsIl90b3RhbER1cmF0aW9uIiwidG90YWxEdXJhdGlvbiIsInByZXZUb3RhbFRpbWUiLCJwcmV2Q3ljbGUiLCJwcmV2UmF3UHJldlRpbWUiLCJfcmF3UHJldlRpbWUiLCJpc0NvbXBsZXRlIiwiY3ljbGVEdXJhdGlvbiIsInIiLCJwb3ciLCJyYXdQcmV2VGltZSIsIl9lYXNlIiwiX2NhbGNFbmQiLCJnZXRSYXRpbyIsIl9yZXZlcnNlZCIsImF1dG9SZW1vdmVDaGlsZHJlbiIsImxhenkiLCJfYWN0aXZlIiwiX2Vhc2VUeXBlIiwiX2Vhc2VQb3dlciIsIl9vblVwZGF0ZSIsIl9jYWxsYmFjayIsImxhenlUd2VlbnMiLCJfbGF6eSIsIl9wYXVzZWQiLCJfc3RhcnRBdCIsIm9uU3RhcnQiLCJmIiwib25SZXBlYXQiLCJmcm9tIiwicnVuQmFja3dhcmRzIiwiZnJvbVRvIiwiZnJvbVZhcnMiLCJ0b1ZhcnMiLCJzdGFydEF0Iiwic3RhZ2dlclRvIiwiYWxsVG8iLCJzdGFnZ2VyIiwib25Db21wbGV0ZUFsbCIsIm9uQ29tcGxldGVBbGxQYXJhbXMiLCJvbkNvbXBsZXRlQWxsU2NvcGUiLCJmaW5hbENvbXBsZXRlIiwib25Db21wbGV0ZSIsIm9uQ29tcGxldGVTY29wZSIsImNhbGxiYWNrU2NvcGUiLCJmcm9tQ3ljbGUiLCJzdGFnZ2VyRnJvbSIsImFsbEZyb20iLCJzdGFnZ2VyRnJvbVRvIiwiYWxsRnJvbVRvIiwiZGVsYXllZENhbGwiLCJzY29wZSIsInVzZUZyYW1lcyIsIm9uQ29tcGxldGVQYXJhbXMiLCJvblJldmVyc2VDb21wbGV0ZSIsIm9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zIiwib3ZlcndyaXRlIiwiaXNUd2VlbmluZyIsIl9nZXRDaGlsZHJlbk9mIiwidGltZWxpbmUiLCJpbmNsdWRlVGltZWxpbmVzIiwiY250IiwiX2ZpcnN0IiwiZ2V0QWxsVHdlZW5zIiwiX3Jvb3RUaW1lbGluZSIsIl9yb290RnJhbWVzVGltZWxpbmUiLCJraWxsQWxsIiwiZGVsYXllZENhbGxzIiwidGltZWxpbmVzIiwiYWxsVHJ1ZSIsImlzREMiLCJ0b3RhbFRpbWUiLCJraWxsQ2hpbGRUd2VlbnNPZiIsInRsIiwidHdlZW5Mb29rdXAiLCJjdXJQYXJlbnQiLCJfY2hhbmdlUGF1c2UiLCJwYXVzZSIsInBhdXNlZCIsInBhdXNlQWxsIiwicmVzdW1lQWxsIiwiZ2xvYmFsVGltZVNjYWxlIiwiX3RpbWVTY2FsZSIsImZyYW1lIiwidG90YWxQcm9ncmVzcyIsIlRpbWVsaW5lTGl0ZSIsIl9sYWJlbHMiLCJzbW9vdGhDaGlsZFRpbWluZyIsIl9zb3J0Q2hpbGRyZW4iLCJvblVwZGF0ZSIsIl9zd2FwU2VsZkluUGFyYW1zIiwiYWxpZ24iLCJfbGF6eVR3ZWVucyIsIl9sYXp5UmVuZGVyIiwibGF6eVJlbmRlciIsIl9nbG9iYWxzIiwiZ2xvYmFscyIsIl9jb3B5IiwiX3BhdXNlQ2FsbGJhY2siLCJwYXVzZUNhbGxiYWNrIiwiX2ZvcmNpbmdQbGF5aGVhZCIsIl9oYXNQYXVzZSIsIkVuZ2luZSIsIl9wYXJzZVRpbWVPckxhYmVsIiwiZXhwb3J0Um9vdCIsImlnbm9yZURlbGF5ZWRDYWxscyIsIl9yZW1vdmUiLCJjdXJUaW1lIiwiY2hpbGQiLCJiZWZvcmVSYXdUaW1lIiwiYWRkTGFiZWwiLCJyYXdUaW1lIiwiX3BhdXNlVGltZSIsInJlbW92ZUxhYmVsIiwic2tpcERpc2FibGUiLCJfbGFzdCIsIm9mZnNldE9yTGFiZWwiLCJpbnNlcnRNdWx0aXBsZSIsImFwcGVuZE11bHRpcGxlIiwibGFiZWwiLCJhZGRQYXVzZSIsImdldExhYmVsVGltZSIsInRpbWVPckxhYmVsIiwiYXBwZW5kSWZBYnNlbnQiLCJpZ25vcmUiLCJjaGFyQXQiLCJOdW1iZXIiLCJzdWJzdHIiLCJzZWVrIiwiZ290b0FuZFBsYXkiLCJwbGF5IiwiZ290b0FuZFN0b3AiLCJwcmV2U3RhcnQiLCJwcmV2VGltZVNjYWxlIiwicHJldlBhdXNlZCIsImludGVybmFsRm9yY2UiLCJwYXVzZVR3ZWVuIiwiX2hhc1BhdXNlZENoaWxkIiwiX3ByZXYiLCJlbmRUaW1lIiwiZ2V0Q2hpbGRyZW4iLCJuZXN0ZWQiLCJpZ25vcmVCZWZvcmVUaW1lIiwiX2NvbnRhaW5zIiwicmVjZW50IiwiX3JlY2VudCIsInNoaWZ0Q2hpbGRyZW4iLCJhbW91bnQiLCJhZGp1c3RMYWJlbHMiLCJsYWJlbHMiLCJfa2lsbCIsImNoYW5nZWQiLCJjbGVhciIsImVuYWJsZWQiLCJpZ25vcmVUaW1lbGluZSIsInVuY2FwcGVkIiwidGltZVNjYWxlIiwidXNlc0ZyYW1lcyIsIkVhc2UiLCJUaW1lbGluZU1heCIsIl9lYXNlTm9uZSIsImFkZENhbGxiYWNrIiwicmVtb3ZlQ2FsbGJhY2siLCJyZW1vdmVQYXVzZSIsInR3ZWVuVG8iLCJlYXNlIiwiYWJzIiwidHdlZW5Gcm9tVG8iLCJmcm9tUG9zaXRpb24iLCJ0b1Bvc2l0aW9uIiwiZHVyIiwiX2xvY2tlZCIsImJhY2t3YXJkcyIsInJlY1RvdGFsVGltZSIsInJlY0N5Y2xlIiwicmVjUmF3UHJldlRpbWUiLCJyZWNUaW1lIiwiZ2V0QWN0aXZlIiwiaXNBY3RpdmUiLCJnZXRMYWJlbEFmdGVyIiwiZ2V0TGFiZWxzQXJyYXkiLCJnZXRMYWJlbEJlZm9yZSIsImN1cnJlbnRMYWJlbCIsIl9SQUQyREVHIiwiX3IxIiwiX3IyIiwiX3IzIiwiX2NvclByb3BzIiwiU2VnbWVudCIsImQiLCJkYSIsImNhIiwiYmEiLCJfY29ycmVsYXRlIiwiY3ViaWNUb1F1YWRyYXRpYyIsInExIiwicTIiLCJxMyIsInE0IiwibWFiIiwibWJjIiwibWNkIiwibWFiYyIsIm1iY2QiLCJtOCIsIl9jYWxjdWxhdGVDb250cm9sUG9pbnRzIiwiY3VydmluZXNzIiwicXVhZCIsImJhc2ljIiwiY29ycmVsYXRlIiwiaWkiLCJjcDEiLCJwMSIsInAyIiwicDMiLCJzZWciLCJtMSIsIm0yIiwibW0iLCJjcDIiLCJxYiIsInIxIiwicjIiLCJfcGFyc2VBbmNob3JzIiwiYmV6aWVyVGhyb3VnaCIsInF1YWRyYXRpYyIsInNlYW1sZXNzIiwic3FydCIsIl9wYXJzZUJlemllckRhdGEiLCJpbmMiLCJzb2Z0IiwiX2FkZEN1YmljTGVuZ3RocyIsInN0ZXBzIiwicmVzb2x1dGlvbiIsImQxIiwiYmV6IiwiX3BhcnNlTGVuZ3RoRGF0YSIsImxlbmd0aHMiLCJ0b3RhbCIsInRocmVzaG9sZCIsInNlZ21lbnRzIiwiY3VyTFMiLCJCZXppZXJQbHVnaW4iLCJwbHVnaW4iLCJwcmlvcml0eSIsIkFQSSIsIl90YXJnZXQiLCJfZnVuYyIsIl9yb3VuZCIsIl9wcm9wcyIsIl90aW1lUmVzIiwidGltZVJlc29sdXRpb24iLCJhdXRvUm90YXRlIiwib3JpZW50VG9CZXppZXIiLCJpc0Z1bmMiLCJfYXV0b1JvdGF0ZSIsIl9vdmVyd3JpdGVQcm9wcyIsIl9iZXppZXJzIiwiX3NlZ0NvdW50IiwibGQiLCJfbGVuZ3RoIiwiX2xlbmd0aHMiLCJfc2VnbWVudHMiLCJfbDEiLCJfbGkiLCJfczEiLCJfc2kiLCJfbDIiLCJfY3VyU2VnIiwiX3MyIiwiX3ByZWMiLCJfaW5pdGlhbFJvdGF0aW9ucyIsIl9zdGFydFJhdGlvIiwibm90U3RhcnQiLCJjdXJJbmRleCIsImN1clNlZyIsImFyIiwiYjIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImF0YW4yIiwiX2F1dG9DU1MiLCJxdWFkcmF0aWNUb0N1YmljIiwiX2Nzc1JlZ2lzdGVyIiwiQ1NTUGx1Z2luIiwiX3BhcnNlVG9Qcm94eSIsIl9zZXRQbHVnaW5SYXRpbyIsIkNTU1Byb3BUd2VlbiIsIl9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcCIsInBhcnNlciIsImNzc3AiLCJwbHVnaW5WYWx1ZXMiLCJzZXRSYXRpbyIsIngiLCJfdHJhbnNmb3JtIiwiX2VuYWJsZVRyYW5zZm9ybXMiLCJfZ3NUcmFuc2Zvcm0iLCJfb25Jbml0VHdlZW4iLCJfdHdlZW4iLCJfcm91bmRQcm9wcyIsImxvb2t1cCIsIm9wIiwiYmV6aWVyIiwiX3N1cGVyIiwiVHdlZW5QbHVnaW4iLCJfaGFzUHJpb3JpdHkiLCJfc3VmZml4TWFwIiwiX2NzIiwiX3NwZWNpYWxQcm9wcyIsImRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSIsImRlZmF1bHRTa2V3VHlwZSIsImRlZmF1bHRTbW9vdGhPcmlnaW4iLCJzdWZmaXhNYXAiLCJyaWdodCIsImJvdHRvbSIsImZvbnRTaXplIiwicGVyc3BlY3RpdmUiLCJsaW5lSGVpZ2h0IiwiX251bUV4cCIsIl9yZWxOdW1FeHAiLCJfdmFsdWVzRXhwIiwiX05hTkV4cCIsIl9zdWZmaXhFeHAiLCJfb3BhY2l0eUV4cCIsIl9vcGFjaXR5VmFsRXhwIiwiX2FscGhhRmlsdGVyRXhwIiwiX3JnYmhzbEV4cCIsIl9jYXBzRXhwIiwiX2NhbWVsRXhwIiwiX3VybEV4cCIsIl9jYW1lbEZ1bmMiLCJnIiwiX2hvcml6RXhwIiwiX2llR2V0TWF0cml4RXhwIiwiX2llU2V0TWF0cml4RXhwIiwiX2NvbW1hc091dHNpZGVQYXJlbkV4cCIsIl9jb21wbGV4RXhwIiwiX0RFRzJSQUQiLCJfZm9yY2VQVCIsIl9kb2MiLCJfY3JlYXRlRWxlbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsIl90ZW1wRGl2IiwiX3RlbXBJbWciLCJfYWdlbnQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJfYXV0b1JvdW5kIiwiX3JlcVNhZmFyaUZpeCIsIl9pc1NhZmFyaSIsIl9pc0ZpcmVmb3giLCJfaXNTYWZhcmlMVDYiLCJfaWVWZXJzIiwiX3N1cHBvcnRzT3BhY2l0eSIsIiQxIiwiX2dldElFT3BhY2l0eSIsImN1cnJlbnRTdHlsZSIsIl9sb2ciLCJjb25zb2xlIiwibG9nIiwiX3ByZWZpeENTUyIsIl9wcmVmaXgiLCJfY2hlY2tQcm9wUHJlZml4IiwiX2dldENvbXB1dGVkU3R5bGUiLCJfZ2V0U3R5bGUiLCJnZXRTdHlsZSIsImNzIiwiY2FsYyIsImRmbHQiLCJydiIsIl9jb252ZXJ0VG9QaXhlbHMiLCJjb252ZXJ0VG9QaXhlbHMiLCJzZngiLCJyZWN1cnNlIiwiaG9yaXoiLCJuZWciLCJwaXgiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIl9nc0NhY2hlIiwiY2FjaGVXaWR0aHMiLCJfY2FsY3VsYXRlT2Zmc2V0IiwiY2FsY3VsYXRlT2Zmc2V0IiwiZGltIiwiX2dldEFsbFN0eWxlcyIsIl90cmFuc2Zvcm1Qcm9wQ1NTIiwiX3RyYW5zZm9ybVByb3AiLCJfZ2V0VHJhbnNmb3JtIiwicm90YXRpb24iLCJza2V3WCIsInNjYWxlWCIsInNjYWxlWSIsInkiLCJfc3VwcG9ydHMzRCIsInoiLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJzY2FsZVoiLCJfY3NzRGlmIiwiczEiLCJzMiIsImZvcmNlTG9va3VwIiwiZGlmcyIsIm1wdCIsIk1pbmlQcm9wVHdlZW4iLCJmaXJzdE1QVCIsIl9kaW1lbnNpb25zIiwiX21hcmdpbnMiLCJfZ2V0RGltZW5zaW9uIiwiZ2V0QkJveCIsIl9pc1NWRyIsIl9wYXJzZVBvc2l0aW9uIiwicmVjT2JqIiwib3hwIiwib3lwIiwib3hyIiwib3lyIiwib3giLCJveSIsIl9wYXJzZUNoYW5nZSIsIl9wYXJzZVZhbCIsIl9wYXJzZUFuZ2xlIiwiZGlyZWN0aW9uYWxFbmQiLCJtaW4iLCJjYXAiLCJkaWYiLCJpc1JlbGF0aXZlIiwiX2NvbG9yTG9va3VwIiwiYXF1YSIsImxpbWUiLCJzaWx2ZXIiLCJibGFjayIsIm1hcm9vbiIsInRlYWwiLCJibHVlIiwibmF2eSIsIndoaXRlIiwiZnVjaHNpYSIsIm9saXZlIiwieWVsbG93Iiwib3JhbmdlIiwiZ3JheSIsInB1cnBsZSIsImdyZWVuIiwicmVkIiwicGluayIsImN5YW4iLCJ0cmFuc3BhcmVudCIsIl9odWUiLCJoIiwiX3BhcnNlQ29sb3IiLCJwYXJzZUNvbG9yIiwidG9IU0wiLCJ3YXNIU0wiLCJfZm9ybWF0Q29sb3JzIiwiY29sb3JzIiwiX2NvbG9yRXhwIiwiY2hhckluZGV4IiwiY29sb3IiLCJjb2xvclN0cmluZ0ZpbHRlciIsImNvbWJpbmVkIiwibGFzdEluZGV4IiwiZGVmYXVsdFN0cmluZ0ZpbHRlciIsIl9nZXRGb3JtYXR0ZXIiLCJjbHIiLCJjb2xsYXBzaWJsZSIsIm11bHRpIiwiZENvbG9yIiwiZFZhbHMiLCJwZngiLCJkZWxpbSIsIm51bVZhbHMiLCJkU2Z4IiwiZm9ybWF0dGVyIiwidmFscyIsIl9nZXRFZGdlUGFyc2VyIiwic3RyIiwieHMwIiwieHMxIiwic2hhbGxvdyIsImJwdCIsInRyYW5zZm9ybSIsIm9sZEZvcmNlIiwieHAiLCJmaXJzdFBUIiwicnhwIiwicHIiLCJfYWRkTm9uVHdlZW5pbmdOdW1lcmljUFQiLCJvdmVyd3JpdGVQcm9wIiwiX3BhcnNlQ29tcGxleCIsInBhcnNlQ29tcGxleCIsImNscnMiLCJlYSIsImF1dG9Sb3VuZCIsInhpIiwibmkiLCJidiIsImV2IiwiYm51bXMiLCJlbnVtcyIsImJuIiwiaGFzQWxwaGEiLCJjdiIsInVzZUhTTCIsImFwcGVuZFh0cmEiLCJ4Zmlyc3QiLCJwYWQiLCJTcGVjaWFsUHJvcCIsImZvcm1hdCIsImtleXdvcmQiLCJkZWZhdWx0cyIsIl9yZWdpc3RlclBsdWdpblByb3AiLCJwbHVnaW5OYW1lIiwicGx1Z2luQ2xhc3MiLCJjb20iLCJncmVlbnNvY2siLCJwbHVnaW5zIiwia3dkIiwiYmkiLCJlaSIsInJlZ2lzdGVyU3BlY2lhbFByb3AiLCJvbkluaXRUd2VlbiIsInVzZVNWR1RyYW5zZm9ybUF0dHIiLCJfdHJhbnNmb3JtUHJvcHMiLCJfdHJhbnNmb3JtT3JpZ2luUHJvcCIsIlRyYW5zZm9ybSIsImZvcmNlM0QiLCJkZWZhdWx0Rm9yY2UzRCIsIl9TVkdFbGVtZW50IiwiU1ZHRWxlbWVudCIsIl91c2VTVkdUcmFuc2Zvcm1BdHRyIiwiX2NyZWF0ZVNWRyIsImVsZW1lbnQiLCJyZWciLCJzZXRBdHRyaWJ1dGVOUyIsIl9kb2NFbGVtZW50IiwiX2ZvcmNlU1ZHVHJhbnNmb3JtQXR0ciIsImNocm9tZSIsInN2ZyIsInJlY3QiLCJfcGFyc2VTVkdPcmlnaW4iLCJsb2NhbCIsImRlY29yYXRlZSIsImFic29sdXRlIiwic21vb3RoT3JpZ2luIiwic2tpcFJlY29yZCIsInRtIiwiX2dldE1hdHJpeCIsInhPcmlnaW4iLCJ5T3JpZ2luIiwidHgiLCJ0eSIsImRldGVybWluYW50IiwieE9yaWdpbk9sZCIsInlPcmlnaW5PbGQiLCJfaWRlbnRpdHkyRE1hdHJpeCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiX2NhbkdldEJCb3giLCJnZXRDVE0iLCJmb3JjZTJEIiwicm5kIiwiaXNEZWZhdWx0IiwiZGVjIiwiZ2V0VHJhbnNmb3JtIiwicmVjIiwiaW52WCIsInpPcmlnaW4iLCJhMTEiLCJhMjEiLCJhMzEiLCJhNDEiLCJhMTIiLCJhMjIiLCJhMzIiLCJhNDIiLCJhMTMiLCJhMjMiLCJhMzMiLCJhMTQiLCJhMjQiLCJhMzQiLCJhNDMiLCJhbmdsZSIsInQxIiwidDIiLCJ0MyIsInQ0Iiwic2luIiwiayIsIl9yZW1vdmVQcm9wIiwiX3NldElFVHJhbnNmb3JtUmF0aW8iLCJhbmciLCJza2V3IiwiY2xpcCIsInhQZXJjZW50IiwieVBlcmNlbnQiLCJkeCIsImR5IiwibXVsdCIsIm1hcmciLCJpZU9mZnNldFgiLCJpZU9mZnNldFkiLCJfc2V0VHJhbnNmb3JtUmF0aW8iLCJzZXQzRFRyYW5zZm9ybVJhdGlvIiwic2V0VHJhbnNmb3JtUmF0aW8iLCJzeCIsInN5Iiwic3oiLCJpc1NWRyIsImNvbW1hIiwiemVybyIsInNrZXdUeXBlIiwidGFuIiwic2tld1kiLCJfbGFzdFBhcnNlZFRyYW5zZm9ybSIsIm9yaWdpbmFsR1NUcmFuc2Zvcm0iLCJlbmRSb3RhdGlvbnMiLCJ0cmFuc2Zvcm1PcmlnaW5TdHJpbmciLCJoYXMzRCIsImhhc0NoYW5nZSIsImRyIiwibWF0cml4IiwicGFyc2VUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1PcmlnaW4iLCJzdmdPcmlnaW4iLCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZSIsImRpcmVjdGlvbmFsUm90YXRpb24iLCJzaG9ydFJvdGF0aW9uIiwicm90YXRpb25aIiwic2hvcnRSb3RhdGlvblgiLCJzaG9ydFJvdGF0aW9uWSIsIl90cmFuc2Zvcm1UeXBlIiwiZWExIiwiZXMyIiwiYnMyIiwiYnMiLCJlcyIsImVuIiwiZXNmeCIsImJzZngiLCJyZWwiLCJobiIsInZuIiwiZW0iLCJiYWNrZ3JvdW5kUG9zaXRpb25YIiwiYmFja2dyb3VuZFBvc2l0aW9uWSIsInBjdCIsIm92ZXJsYXAiLCJjbGlwVG9wIiwiY2xpcFJpZ2h0IiwiY2xpcEJvdHRvbSIsImNsaXBMZWZ0IiwiX3NldElFT3BhY2l0eVJhdGlvIiwic2tpcCIsInhuMSIsImlzQXV0b0FscGhhIiwiem9vbSIsInJlbW92ZVByb3BlcnR5IiwiX3NldENsYXNzTmFtZVJhdGlvIiwiX2dzQ2xhc3NQVCIsImRpZkRhdGEiLCJjbnB0IiwiY25wdExvb2t1cCIsIl9jbGFzc05hbWVQVCIsIl9zZXRDbGVhclByb3BzUmF0aW8iLCJ0cmFuc2Zvcm1QYXJzZSIsImNsZWFyVHJhbnNmb3JtIiwiX3ZhcnMiLCJwdDIiLCJ6SW5kZXgiLCJ0cHQiLCJ0aHJlZUQiLCJfYWRkTGF6eVNldCIsIldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSIsIl9saW5rQ1NTUCIsInNwIiwiaXNTdHIiLCJzdHJpY3RVbml0cyIsInhzMiIsInhuMiIsInhzMyIsInhuMyIsInhzNCIsInhuNCIsInhzNSIsImxhenlTZXQiLCJhdXRvQWxwaGEiLCJhbHBoYSIsIl9nZXRDaGlsZFN0eWxlcyIsImNhc2NhZGVUbyIsIl9yZXNlcnZlZFByb3BzIiwicmVzZXJ2ZWRQcm9wcyIsIl90YXJnZXRzIiwiYWN0aXZhdGUiLCJSb3VuZFByb3BzUGx1Z2luIiwiX3JvdW5kTGlua2VkTGlzdCIsImJsb2IiLCJfb25Jbml0QWxsUHJvcHMiLCJycCIsInJvdW5kUHJvcHMiLCJycHQiLCJfcHJvcExvb2t1cCIsInBnIiwiX2FkZCIsIl9hZGRUd2VlbiIsImZpbmFscyIsInVzZVJhZGlhbnMiLCJHcmVlblNvY2tHbG9iYWxzIiwiZ3MiLCJfMlBJIiwiX0hBTEZfUEkiLCJfY2xhc3MiLCJfY3JlYXRlIiwiQyIsIl9lYXNlUmVnIiwiX3dyYXAiLCJFYXNlT3V0IiwiRWFzZUluIiwiRWFzZUluT3V0IiwiYWxpYXNlcyIsImVhc2VPdXQiLCJlYXNlSW4iLCJlYXNlSW5PdXQiLCJFYXNlUG9pbnQiLCJnYXAiLCJfY3JlYXRlQmFjayIsIm92ZXJzaG9vdCIsIl9wMSIsIl9wMiIsImNvbmZpZyIsIkJhY2siLCJTbG93TW8iLCJsaW5lYXJSYXRpbyIsInBvd2VyIiwieW95b01vZGUiLCJfcCIsIl9wMyIsIlN0ZXBwZWRFYXNlIiwiUm91Z2hFYXNlIiwiX2NyZWF0ZUVsYXN0aWMiLCJ0YXBlciIsInBvaW50cyIsInJhbmRvbWl6ZSIsImNsYW1wIiwidGVtcGxhdGUiLCJzdHJlbmd0aCIsImJ1bXAiLCJwbnQiLCJkZWYiLCJhbXBsaXR1ZGUiLCJwZXJpb2QiLCJhc2luIiwibW9kdWxlTmFtZSIsIl9uYW1lc3BhY2UiLCJucyIsIl9lbXB0eUZ1bmMiLCJhcnJheSIsIl90aWNrZXIiLCJfdGlja2VyQWN0aXZlIiwiX2RlZkxvb2t1cCIsIkRlZmluaXRpb24iLCJkZXBlbmRlbmNpZXMiLCJzYyIsImdzQ2xhc3MiLCJfY2xhc3NlcyIsIm1pc3NpbmciLCJjbCIsImhhc01vZHVsZSIsIkdyZWVuU29ja0FNRFBhdGgiLCJfYmFzZVBhcmFtcyIsImV4dHJhUGFyYW1zIiwiX3R5cGUiLCJfcG93ZXIiLCJfcGFyYW1zIiwiX2Vhc2VNYXAiLCJuYW1lcyIsImNyZWF0ZSIsIm5hIiwidGEiLCJwdyIsIkxpbmVhciIsIlF1YWQiLCJFdmVudERpc3BhdGNoZXIiLCJfbGlzdGVuZXJzIiwiX2V2ZW50VGFyZ2V0IiwidXNlUGFyYW0iLCJsaXN0ZW5lciIsInVwIiwid2FrZSIsImRpc3BhdGNoRXZlbnQiLCJfcmVxQW5pbUZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX2NhbmNlbEFuaW1GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiX2dldFRpbWUiLCJnZXRUaW1lIiwiX2xhc3RVcGRhdGUiLCJmcHMiLCJ1c2VSQUYiLCJfc2VsZiIsIl91c2VSQUYiLCJfbGFnVGhyZXNob2xkIiwiX2FkanVzdGVkTGFnIiwiX3RpY2tXb3JkIiwiX2ZwcyIsIl9yZXEiLCJfaWQiLCJfZ2FwIiwiX25leHRUaW1lIiwiX3RpY2siLCJtYW51YWwiLCJlbGFwc2VkIiwiYWRqdXN0ZWRMYWciLCJzbGVlcCIsInZpc2liaWxpdHlTdGF0ZSIsIlRpY2tlciIsInJldmVyc2VkIiwiX2NoZWNrVGltZW91dCIsImF0VGltZSIsInJlc3VtZSIsInJlc3RhcnQiLCJpbmNsdWRlRGVsYXkiLCJpbmNsdWRlU2VsZiIsImV2ZW50Q2FsbGJhY2siLCJpbmNsdWRlUmVwZWF0cyIsInBhdXNlVGltZSIsInByZXZUd2VlbiIsInN0IiwidGFyZyIsIl9vdmVyd3JpdGUiLCJfb3ZlcndyaXRlTG9va3VwIiwiZGVmYXVsdE92ZXJ3cml0ZSIsIl9zaWJsaW5ncyIsIl9yZWdpc3RlciIsIl9hcHBseU92ZXJ3cml0ZSIsIl9wbHVnaW5zIiwiX292ZXJ3cml0dGVuUHJvcHMiLCJkZWZhdWx0RWFzZSIsImF1dG9TbGVlcCIsIl9sYXp5TG9va3VwIiwiX251bWJlcnNFeHAiLCJfc2V0UmF0aW8iLCJmcCIsIl9ibG9iRGlmIiwic3RhcnROdW1zIiwiZW5kTnVtcyIsIm5vbk51bWJlcnMiLCJjdXJyZW50TnVtIiwiX2FkZFByb3BUd2VlbiIsImZ1bmNQYXJhbSIsInN0cmluZ0ZpbHRlciIsImdldHRlck5hbWUiLCJibG9iRGlmIiwiX3R3ZWVuTG9va3VwIiwiX3R3ZWVuTG9va3VwTnVtIiwib25VcGRhdGVQYXJhbXMiLCJvblVwZGF0ZVNjb3BlIiwib25TdGFydFBhcmFtcyIsIm9uU3RhcnRTY29wZSIsIm9uUmV2ZXJzZUNvbXBsZXRlU2NvcGUiLCJvblJlcGVhdFBhcmFtcyIsIm9uUmVwZWF0U2NvcGUiLCJlYXNlUGFyYW1zIiwiYXV0b0NTUyIsIm9uT3ZlcndyaXRlIiwibm9uZSIsImF1dG8iLCJjb25jdXJyZW50IiwiYWxsT25TdGFydCIsIl9uZXh0R0NGcmFtZSIsIl91cGRhdGVSb290Iiwic2NydWIiLCJfZ3NUd2VlbklEIiwiX29uT3ZlcndyaXRlIiwib3ZlcndyaXR0ZW5Ud2VlbiIsIm92ZXJ3cml0aW5nVHdlZW4iLCJraWxsZWRQcm9wcyIsIm1vZGUiLCJjdXJUd2VlbiIsIm92ZXJsYXBzIiwib0NvdW50IiwiemVyb0R1ciIsImdsb2JhbFN0YXJ0IiwiX2NoZWNrT3ZlcmxhcCIsInJlZmVyZW5jZSIsInRzIiwiaW5pdFBsdWdpbnMiLCJzdGFydFZhcnMiLCJfaW5pdFByb3BzIiwicHJvcExvb2t1cCIsIm92ZXJ3cml0dGVuUHJvcHMiLCJfcHJpb3JpdHkiLCJfb25EaXNhYmxlIiwiX29uRW5hYmxlIiwic2ltdWx0YW5lb3VzT3ZlcndyaXRlIiwia2lsbFByb3BzIiwicmVjb3JkIiwia2lsbGVkIiwiX3RlbXBLaWxsIiwib25seUFjdGl2ZSIsIl9wcm9wTmFtZSIsIm92ZXJ3cml0ZVByb3BzIiwiaW5pdEFsbCIsIlBsdWdpbiIsIlNjcm9sbE1hZ2ljIiwiX3V0aWwiLCJQSU5fU1BBQ0VSX0FUVFJJQlVURSIsIkNvbnRyb2xsZXIiLCJOQU1FU1BBQ0UiLCJTQ1JPTExfRElSRUNUSU9OX0ZPUldBUkQiLCJTQ1JPTExfRElSRUNUSU9OX1JFVkVSU0UiLCJTQ1JPTExfRElSRUNUSU9OX1BBVVNFRCIsIkRFRkFVTFRfT1BUSU9OUyIsIkNPTlRST0xMRVJfT1BUSU9OUyIsIl9vcHRpb25zIiwiX3NjZW5lT2JqZWN0cyIsIl91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSIsIl9zY3JvbGxQb3MiLCJfc2Nyb2xsRGlyZWN0aW9uIiwiX2lzRG9jdW1lbnQiLCJfdmlld1BvcnRTaXplIiwiX3VwZGF0ZVRpbWVvdXQiLCJfcmVmcmVzaFRpbWVvdXQiLCJjb25zdHJ1Y3QiLCJnZXRWaWV3cG9ydFNpemUiLCJvbkNoYW5nZSIsInJlZnJlc2hJbnRlcnZhbCIsInNjaGVkdWxlUmVmcmVzaCIsInJlZnJlc2giLCJnZXRTY3JvbGxQb3MiLCJ2ZXJ0aWNhbCIsInNldFNjcm9sbFBvcyIsIl9zZXRTY3JvbGxQb3MiLCJ1cGRhdGVTY2VuZXMiLCJzY2VuZXNUb1VwZGF0ZSIsIm9sZFNjcm9sbFBvcyIsInNjcm9sbFBvcyIsImRlbHRhU2Nyb2xsIiwiZm9yRWFjaCIsInNjZW5lIiwidXBkYXRlIiwibG9nbGV2ZWwiLCJkZWJvdW5jZVVwZGF0ZSIsInJBRiIsInJlc2l6ZUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsIm91dHB1dCIsInNvcnRTY2VuZXMiLCJTY2VuZXNBcnJheSIsInNjZW5lcyIsInNjcm9sbE9mZnNldCIsImFkZFNjZW5lIiwibmV3U2NlbmUiLCJTY2VuZSIsImNvbnRyb2xsZXIiLCJhZGRUbyIsImdsb2JhbFNjZW5lT3B0aW9ucyIsInJlbW92ZVNjZW5lIiwidXBkYXRlU2NlbmUiLCJpbW1lZGlhdGVseSIsInNjcm9sbFRhcmdldCIsImFkZGl0aW9uYWxQYXJhbWV0ZXIiLCJGdW5jdGlvbiIsImhhc0F0dHJpYnV0ZSIsImNvbnRhaW5lck9mZnNldCIsImVsZW1lbnRPZmZzZXQiLCJzY3JvbGxQb3NNZXRob2QiLCJpbmZvIiwiYWJvdXQiLCJzY3JvbGxEaXJlY3Rpb24iLCJpc0RvY3VtZW50IiwibmV3TG9nbGV2ZWwiLCJuZXdTdGF0ZSIsImRlc3Ryb3kiLCJyZXNldFNjZW5lcyIsImNBRiIsImFkZE9wdGlvbiIsImV4dGVuc2lvbiIsIm9sZENsYXNzIiwiJHN1cGVyIiwiU0NFTkVfU1RBVEVfQkVGT1JFIiwiU0NFTkVfU1RBVEVfRFVSSU5HIiwiU0NFTkVfU1RBVEVfQUZURVIiLCJTQ0VORV9PUFRJT05TIiwiX3N0YXRlIiwiX3Byb2dyZXNzIiwiX3Njcm9sbE9mZnNldCIsIl90cmlnZ2VyUG9zIiwiX2R1cmF0aW9uVXBkYXRlTWV0aG9kIiwiX2NvbnRyb2xsZXIiLCJvcHRpb25OYW1lIiwiYWRkU2NlbmVPcHRpb24iLCJ2YWxpZGF0ZU9wdGlvbiIsImZ1bGxuYW1lIiwibmFtZXBhcnRzIiwiZXZlbnRuYW1lIiwicmVtb3ZlTGlzdCIsImxpc3RlbmVycyIsInVwZGF0ZVRyaWdnZXJFbGVtZW50UG9zaXRpb24iLCJ1cGRhdGVTY3JvbGxPZmZzZXQiLCJ1cGRhdGVEdXJhdGlvbiIsIm9uQ29udGFpbmVyUmVzaXplIiwidG1wUGFyZW50IiwibmV3UHJvZ3Jlc3MiLCJzdGFydFBvcyIsImVuZFBvcyIsIl9waW4iLCJ1cGRhdGVQaW5TdGF0ZSIsImRvVXBkYXRlIiwib2xkU3RhdGUiLCJyZXZlcnNlT3JGb3J3YXJkIiwiZXZlbnRWYXJzIiwic3RhdGVDaGFuZ2VkIiwiZXZlbnROYW1lIiwidHJpZ2dlckVsZW1lbnQiLCJ0cmlnZ2VySG9vayIsInZhcm5hbWUiLCJjaGFuZ2VPcHRpb24iLCJuZXd2YWwiLCJyZWFzb24iLCJlbGVtZW50UG9zIiwidGVsZW0iLCJjb250cm9sbGVySW5mbyIsIl92YWxpZGF0ZSIsInZhbGlkYXRlIiwicGVyYyIsImxvZ01TRyIsIm1lc3NhZ2UiLCJvbGR2YWwiLCJuZXdWYWwiLCJzaGlmdHMiLCJ0cmlnZ2VyUG9zaXRpb24iLCJfcGluT3B0aW9ucyIsImR1cmF0aW9uQ2hhbmdlZCIsInVwZGF0ZVBpbkRpbWVuc2lvbnMiLCJyZW1vdmVQaW4iLCJmb3JjZVVucGluIiwiY29udGFpbmVySW5mbyIsInBpblRhcmdldCIsInNwYWNlciIsImZpeGVkUG9zIiwic2Nyb2xsRGlzdGFuY2UiLCJuZXdDU1MiLCJpbkZsb3ciLCJjaGFuZ2UiLCJwdXNoRm9sbG93ZXJzIiwiZHVyaW5nIiwibWFyZ2luQ29sbGFwc2UiLCJpc01hcmdpbkNvbGxhcHNlVHlwZSIsInJlbFNpemUiLCJhdXRvRnVsbFdpZHRoIiwidXBkYXRlUGluSW5Db250YWluZXIiLCJ1cGRhdGVSZWxhdGl2ZVBpblNwYWNlciIsIm9uTW91c2V3aGVlbE92ZXJQaW4iLCJ3aGVlbERlbHRhIiwiZGV0YWlsIiwic2V0UGluIiwiZGVmYXVsdFNldHRpbmdzIiwic3BhY2VyQ2xhc3MiLCJwYXJlbnREaXNwbGF5IiwiYm91bmRzUGFyYW1zIiwicGluQ1NTIiwic2l6ZUNTUyIsInNwYWNlckNTUyIsImJveFNpemluZyIsIm1vekJveFNpemluZyIsIndlYmtpdEJveFNpemluZyIsIl9fX29yaWdTdHlsZSIsInBpbklubGluZUNTUyIsImNvcHlTdHlsZXMiLCJtYXJnaW5zIiwiX2Nzc0NsYXNzZXMiLCJfY3NzQ2xhc3NFbGVtcyIsInJlbW92ZUNsYXNzVG9nZ2xlIiwic2V0Q2xhc3NUb2dnbGUiLCJ0cmFuc2xhdGUiLCJ2YWxpZGF0aW9uQ2FsbGJhY2siLCJ0aW1lc3RhbXAiLCJVIiwiZmxvYXR2YWwiLCJudW1iZXIiLCJfZGltZW5zaW9uIiwib3V0ZXIiLCJpbmNsdWRlTWFyZ2luIiwiRG9tRWxlbWVudCIsImRpbWVuc2lvbiIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsIl9jYW1lbENhc2UiLCJsYXN0VGltZSIsInZlbmRvcnMiLCJfcmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX2NhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY3VyclRpbWUiLCJ0aW1lVG9DYWxsIiwibG9nbGV2ZWxzIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsIm8iLCJIVE1MRWxlbWVudCIsIl9nZXQiLCJyZWYiLCJyZWxhdGl2ZVRvVmlld3BvcnQiLCJjbGFzc25hbWUiLCJjbGFzc0xpc3QiLCJhZGRJbmRpY2F0b3JzIiwicmVtb3ZlSW5kaWNhdG9ycyIsInNldFR3ZWVuIiwicmVtb3ZlVHdlZW4iLCJzZXRWZWxvY2l0eSIsInJlbW92ZVZlbG9jaXR5IiwicmVxdWlyZSIsIlRpbWVsaW5lIiwidXBkYXRlVHdlZW5Qcm9ncmVzcyIsInR3ZWVuQ2hhbmdlcyIsIlR3ZWVuT2JqZWN0IiwibmV3VHdlZW4iLCJ0cmlnZ2VyVHdlZW5zIiwidHdlZW52YXJzIiwiY29uZGl0aW9uIiwibmV3Q2FsbGJhY2siLCJ0aGlzVHdlZW4iLCJvbGRDYWxsYmFjayIsImxhenlMb2FkWFQiLCJkYXRhTGF6aWVkIiwibG9hZF9lcnJvciIsImNsYXNzTGF6eUhpZGRlbiIsImRvY0VsZW1lbnQiLCJmb3JjZUxvYWQiLCJvbnNjcm9sbCIsIm9wZXJhbWluaSIsImF1dG9Jbml0IiwiYmxhbmtJbWFnZSIsInRocm90dGxlIiwibG9hZEV2ZW50IiwidXBkYXRlRXZlbnQiLCJmb3JjZUV2ZW50Iiwib25pbml0Iiwib25zaG93IiwiY2hlY2tEdXBsaWNhdGVzIiwiZWxlbWVudE9wdGlvbnMiLCJzcmNBdHRyIiwiZWRnZVgiLCJlZGdlWSIsInZpc2libGVPbmx5IiwiJHdpbmRvdyIsIiRpc0Z1bmN0aW9uIiwiJGV4dGVuZCIsIiRkYXRhIiwiJGNvbnRhaW5zIiwidG9wTGF6eSIsIndhaXRpbmdNb2RlIiwiZ2V0T3JEZWYiLCJzY3JvbGwiLCJvdmVycmlkZXMiLCJzY3JvbGxDb250YWluZXIiLCJlbGVtZW50T3B0aW9uc092ZXJyaWRlcyIsInF1ZXVlQ2hlY2tMYXp5RWxlbWVudHMiLCIkZWwiLCJ0YWdOYW1lIiwidHJpZ2dlckV2ZW50IiwidHJpZ2dlckxvYWRPckVycm9yIiwiY2hlY2tMYXp5RWxlbWVudHMiLCJJbmZpbml0eSIsInZpZXdwb3J0VG9wIiwidmlld3BvcnRIZWlnaHQiLCJpbm5lckhlaWdodCIsInZpZXdwb3J0V2lkdGgiLCJpbm5lcldpZHRoIiwib2JqRGF0YSIsInJlbW92ZU5vZGUiLCJ0b3BFZGdlIiwiZWxQb3MiLCJ0aW1lb3V0TGF6eUVsZW1lbnRzIiwiaW5pdExhenlFbGVtZW50cyIsImZvcmNlTG9hZEFsbCIsIlplcHRvIiwiYXV0b0xvYWRUaW1lIiwiYmdBdHRyIiwiJHRoaXMiLCJGT1VOREFUSU9OX1ZFUlNJT04iLCJGb3VuZGF0aW9uIiwiX3V1aWRzIiwicnRsIiwiZnVuY3Rpb25OYW1lIiwiYXR0ck5hbWUiLCJoeXBoZW5hdGUiLCJyZWdpc3RlclBsdWdpbiIsInV1aWQiLCJHZXRZb0RpZ2l0cyIsIiRlbGVtZW50IiwidW5yZWdpc3RlclBsdWdpbiIsInJlSW5pdCIsImlzSlEiLCJfdGhpcyIsInBsZ3MiLCJmb3VuZGF0aW9uIiwicmVmbG93IiwiJGVsZW0iLCJ3YXJuIiwidGhpbmciLCJwYXJzZVZhbHVlIiwiZXIiLCJnZXRGbk5hbWUiLCJ0cmFuc2l0aW9uZW5kIiwidHJhbnNpdGlvbnMiLCJ1dGlsIiwiJG1ldGEiLCIkbm9KUyIsIk1lZGlhUXVlcnkiLCJwbHVnQ2xhc3MiLCJSZWZlcmVuY2VFcnJvciIsIlR5cGVFcnJvciIsInZwIiwibmV4dFRpbWUiLCJwZXJmb3JtYW5jZSIsIm9UaGlzIiwiYUFyZ3MiLCJmVG9CaW5kIiwiZk5PUCIsImZCb3VuZCIsImZ1bmNOYW1lUmVnZXgiLCJCb3giLCJJbU5vdFRvdWNoaW5nWW91IiwiR2V0RGltZW5zaW9ucyIsIkdldE9mZnNldHMiLCJsck9ubHkiLCJ0Yk9ubHkiLCJlbGVEaW1zIiwicGFyRGltcyIsIndpbmRvd0RpbXMiLCJhbGxEaXJzIiwicGFyUmVjdCIsIndpblJlY3QiLCJ3aW5ZIiwid2luWCIsInBhcmVudERpbXMiLCJhbmNob3IiLCJ2T2Zmc2V0IiwiaE9mZnNldCIsImlzT3ZlcmZsb3ciLCIkZWxlRGltcyIsIiRhbmNob3JEaW1zIiwia2V5Q29kZXMiLCJjb21tYW5kcyIsIktleWJvYXJkIiwiZ2V0S2V5Q29kZXMiLCJwYXJzZUtleSIsInNoaWZ0S2V5IiwiY3RybEtleSIsImFsdEtleSIsImhhbmRsZUtleSIsImNvbXBvbmVudCIsImZ1bmN0aW9ucyIsImNvbW1hbmRMaXN0IiwiY21kcyIsImNvbW1hbmQiLCJsdHIiLCJoYW5kbGVkIiwidW5oYW5kbGVkIiwiZmluZEZvY3VzYWJsZSIsImNvbXBvbmVudE5hbWUiLCJrY3MiLCJrYyIsImRlZmF1bHRRdWVyaWVzIiwibGFuZHNjYXBlIiwicG9ydHJhaXQiLCJyZXRpbmEiLCJxdWVyaWVzIiwiZXh0cmFjdGVkU3R5bGVzIiwibmFtZWRRdWVyaWVzIiwicGFyc2VTdHlsZVRvT2JqZWN0IiwiX2dldEN1cnJlbnRTaXplIiwiX3dhdGNoZXIiLCJhdExlYXN0IiwicXVlcnkiLCJtYXRjaE1lZGlhIiwibmV3U2l6ZSIsInN0eWxlTWVkaWEiLCJtZWRpYSIsIm1hdGNoTWVkaXVtIiwic3R5bGVTaGVldCIsInN0eWxlT2JqZWN0IiwicmVkdWNlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaW5pdENsYXNzZXMiLCJhY3RpdmVDbGFzc2VzIiwiTW90aW9uIiwiYW5pbWF0ZUluIiwiY2IiLCJhbmltYXRlT3V0IiwiTW92ZSIsInByb2ciLCJtb3ZlIiwiaXNJbiIsImluaXRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiTmVzdCIsIkZlYXRoZXIiLCJtZW51IiwiaXRlbXMiLCJzdWJNZW51Q2xhc3MiLCJzdWJJdGVtQ2xhc3MiLCJoYXNTdWJDbGFzcyIsIiRpdGVtIiwiJHN1YiIsIkJ1cm4iLCJUaW1lciIsIm5hbWVTcGFjZSIsInJlbWFpbiIsImlzUGF1c2VkIiwiaW5maW5pdGUiLCJvbkltYWdlc0xvYWRlZCIsImltYWdlcyIsInVubG9hZGVkIiwic2luZ2xlSW1hZ2VMb2FkZWQiLCJuYXR1cmFsV2lkdGgiLCJzcG90U3dpcGUiLCJtb3ZlVGhyZXNob2xkIiwidGltZVRocmVzaG9sZCIsInN0YXJ0UG9zWCIsInN0YXJ0UG9zWSIsImVsYXBzZWRUaW1lIiwiaXNNb3ZpbmciLCJvblRvdWNoRW5kIiwib25Ub3VjaE1vdmUiLCJ0b3VjaGVzIiwib25Ub3VjaFN0YXJ0Iiwic3dpcGUiLCJhZGRUb3VjaCIsImhhbmRsZVRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJldmVudFR5cGVzIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwic2ltdWxhdGVkRXZlbnQiLCJNb3VzZUV2ZW50Iiwic2NyZWVuWCIsInNjcmVlblkiLCJpbml0TW91c2VFdmVudCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJwcmVmaXhlcyIsInRyaWdnZXJzIiwiY2hlY2tMaXN0ZW5lcnMiLCJldmVudHNMaXN0ZW5lciIsInJlc2l6ZUxpc3RlbmVyIiwic2Nyb2xsTGlzdGVuZXIiLCJjbG9zZW1lTGlzdGVuZXIiLCJ5ZXRpQm94ZXMiLCJwbHVnTmFtZXMiLCJwbHVnaW5JZCIsImRlYm91bmNlIiwiJG5vZGVzIiwibGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbiIsIm11dGF0aW9uUmVjb3Jkc0xpc3QiLCIkdGFyZ2V0IiwiZWxlbWVudE9ic2VydmVyIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJzdWJ0cmVlIiwiYXR0cmlidXRlRmlsdGVyIiwiSUhlYXJZb3UiLCJqUXVlcnlCcmlkZ2V0IiwiYXJyYXlTbGljZSIsImxvZ0Vycm9yIiwiUGx1Z2luQ2xhc3MiLCJhcmcwIiwibWV0aG9kQ2FsbCIsInBsYWluQ2FsbCIsIiRlbGVtcyIsIm1ldGhvZE5hbWUiLCJwbHVnaW5NZXRob2RTdHIiLCJpbnN0YW5jZSIsInVwZGF0ZUpRdWVyeSIsImJyaWRnZXQiLCJFdkVtaXR0ZXIiLCJwcm90byIsIl9ldmVudHMiLCJvbmNlRXZlbnRzIiwiX29uY2VFdmVudHMiLCJvbmNlTGlzdGVuZXJzIiwiZW1pdEV2ZW50IiwiaXNPbmNlIiwiZ2V0U2l6ZSIsImdldFN0eWxlU2l6ZSIsImlzVmFsaWQiLCJtZWFzdXJlbWVudHMiLCJtZWFzdXJlbWVudHNMZW5ndGgiLCJnZXRaZXJvU2l6ZSIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsIm1lYXN1cmVtZW50IiwiaXNTZXR1cCIsImlzQm94U2l6ZU91dGVyIiwiYm9yZGVyU3R5bGUiLCJib3JkZXJXaWR0aCIsInF1ZXJ5U2VsZWN0b3IiLCJwYWRkaW5nV2lkdGgiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdIZWlnaHQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsIm1hcmdpbldpZHRoIiwibWFyZ2luSGVpZ2h0IiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlckhlaWdodCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJpc0JvcmRlckJveFNpemVPdXRlciIsInN0eWxlV2lkdGgiLCJzdHlsZUhlaWdodCIsIm1hdGNoZXNNZXRob2QiLCJFbGVtUHJvdG8iLCJFbGVtZW50IiwiZml6enlVSVV0aWxzIiwidXRpbHMiLCJtb2R1bG8iLCJhcnkiLCJyZW1vdmVGcm9tIiwiZ2V0UGFyZW50IiwiZ2V0UXVlcnlFbGVtZW50IiwiaGFuZGxlRXZlbnQiLCJmaWx0ZXJGaW5kRWxlbWVudHMiLCJmZkVsZW1zIiwiY2hpbGRFbGVtcyIsImRlYm91bmNlTWV0aG9kIiwidGltZW91dE5hbWUiLCJkb2NSZWFkeSIsInRvRGFzaGVkIiwiJDIiLCJodG1sSW5pdCIsIldpZGdldENsYXNzIiwiZGFzaGVkTmFtZXNwYWNlIiwiZGF0YUF0dHJFbGVtcyIsImpzRGFzaEVsZW1zIiwiZGF0YU9wdGlvbnNBdHRyIiwiT3V0bGF5ZXIiLCJJdGVtIiwiaXNFbXB0eU9iaiIsImRvY0VsZW1TdHlsZSIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb24iLCJ0cmFuc2Zvcm1Qcm9wZXJ0eSIsInRyYW5zaXRpb25FbmRFdmVudCIsIldlYmtpdFRyYW5zaXRpb24iLCJ2ZW5kb3JQcm9wZXJ0aWVzIiwidHJhbnNpdGlvbkRlbGF5IiwibGF5b3V0IiwiX3RyYW5zbiIsImluZ1Byb3BlcnRpZXMiLCJjbGVhbiIsIm9uRW5kIiwiZWxlbVN0eWxlIiwic3VwcG9ydGVkUHJvcCIsImdldFBvc2l0aW9uIiwiaXNPcmlnaW5MZWZ0IiwiX2dldE9wdGlvbiIsImlzT3JpZ2luVG9wIiwieFZhbHVlIiwieVZhbHVlIiwibGF5b3V0U2l6ZSIsImxheW91dFBvc2l0aW9uIiwieFBhZGRpbmciLCJ4UHJvcGVydHkiLCJ4UmVzZXRQcm9wZXJ0eSIsImdldFhWYWx1ZSIsInlQYWRkaW5nIiwieVByb3BlcnR5IiwieVJlc2V0UHJvcGVydHkiLCJnZXRZVmFsdWUiLCJpc0hvcml6b250YWwiLCJwZXJjZW50UG9zaXRpb24iLCJfdHJhbnNpdGlvblRvIiwiY3VyWCIsImN1clkiLCJjb21wYXJlWCIsImNvbXBhcmVZIiwiZGlkTm90TW92ZSIsInNldFBvc2l0aW9uIiwiaXNUcmFuc2l0aW9uaW5nIiwidHJhbnNYIiwidHJhbnNZIiwidHJhbnNpdGlvblN0eWxlIiwiZ2V0VHJhbnNsYXRlIiwib25UcmFuc2l0aW9uRW5kIiwiaXNDbGVhbmluZyIsImdvVG8iLCJtb3ZlVG8iLCJfbm9uVHJhbnNpdGlvbiIsIl9yZW1vdmVTdHlsZXMiLCJfdHJhbnNpdGlvbiIsImVuYWJsZVRyYW5zaXRpb24iLCJ0b0Rhc2hlZEFsbCIsInRyYW5zaXRpb25Qcm9wcyIsInN0YWdnZXJEZWxheSIsIm9ud2Via2l0VHJhbnNpdGlvbkVuZCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ub3RyYW5zaXRpb25lbmQiLCJkYXNoZWRWZW5kb3JQcm9wZXJ0aWVzIiwicHJvcGVydHlOYW1lIiwiZGlzYWJsZVRyYW5zaXRpb24iLCJyZW1vdmVUcmFuc2l0aW9uU3R5bGVzIiwiY2xlYW5TdHlsZSIsImNsZWFuVHJhbnNpdGlvblN0eWxlIiwicmVtb3ZlRWxlbSIsInJldmVhbCIsInRyYW5zaXRpb25FbmRQcm9wZXJ0eSIsImdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkiLCJvblJldmVhbFRyYW5zaXRpb25FbmQiLCJoaWRkZW5TdHlsZSIsInZpc2libGVTdHlsZSIsInN0eWxlUHJvcGVydHkiLCJvcHRpb25TdHlsZSIsIm9uSGlkZVRyYW5zaXRpb25FbmQiLCJHVUlEIiwiaW5zdGFuY2VzIiwicXVlcnlFbGVtZW50Iiwib3V0bGF5ZXJHVUlEIiwiaXNJbml0TGF5b3V0IiwiY29udGFpbmVyU3R5bGUiLCJpbml0TGF5b3V0Iiwib3JpZ2luTGVmdCIsIm9yaWdpblRvcCIsInJlc2l6ZSIsInJlc2l6ZUNvbnRhaW5lciIsIm9sZE9wdGlvbiIsImNvbXBhdE9wdGlvbnMiLCJob3Jpem9udGFsIiwibGF5b3V0SW5zdGFudCIsInJlbG9hZEl0ZW1zIiwic3RhbXBzIiwic3RhbXAiLCJjYW5CaW5kUmVzaXplIiwiYmluZFJlc2l6ZSIsIl9pdGVtaXplIiwiaXRlbUVsZW1zIiwiX2ZpbHRlckZpbmRJdGVtRWxlbWVudHMiLCJpdGVtIiwiaXRlbVNlbGVjdG9yIiwiZ2V0SXRlbUVsZW1lbnRzIiwiX3Jlc2V0TGF5b3V0IiwiX21hbmFnZVN0YW1wcyIsImlzSW5zdGFudCIsIl9pc0xheW91dEluaXRlZCIsImxheW91dEl0ZW1zIiwiX2dldE1lYXN1cmVtZW50IiwiX2dldEl0ZW1zRm9yTGF5b3V0IiwiX2xheW91dEl0ZW1zIiwiX3Bvc3RMYXlvdXQiLCJpc0lnbm9yZWQiLCJfZW1pdENvbXBsZXRlT25JdGVtcyIsIl9nZXRJdGVtTGF5b3V0UG9zaXRpb24iLCJpc0xheW91dEluc3RhbnQiLCJfcHJvY2Vzc0xheW91dFF1ZXVlIiwidXBkYXRlU3RhZ2dlciIsIl9wb3NpdGlvbkl0ZW0iLCJpc1Jlc2l6aW5nQ29udGFpbmVyIiwiX2dldENvbnRhaW5lclNpemUiLCJfc2V0Q29udGFpbmVyTWVhc3VyZSIsIm1lYXN1cmUiLCJpc1dpZHRoIiwiZWxlbVNpemUiLCJkb25lQ291bnQiLCJlbWl0QXJncyIsIiRldmVudCIsImdldEl0ZW0iLCJ1bmlnbm9yZSIsIl9maW5kIiwidW5zdGFtcCIsIl9nZXRCb3VuZGluZ1JlY3QiLCJfbWFuYWdlU3RhbXAiLCJib3VuZGluZ1JlY3QiLCJfYm91bmRpbmdSZWN0IiwiX2dldEVsZW1lbnRPZmZzZXQiLCJ0aGlzUmVjdCIsImlzUmVzaXplQm91bmQiLCJ1bmJpbmRSZXNpemUiLCJvbnJlc2l6ZSIsIm5lZWRzUmVzaXplTGF5b3V0IiwiaGFzU2l6ZXMiLCJhZGRJdGVtcyIsImFwcGVuZGVkIiwicHJlcGVuZGVkIiwicHJldmlvdXNJdGVtcyIsInJldmVhbEl0ZW1FbGVtZW50cyIsImdldEl0ZW1zIiwiaGlkZUl0ZW1FbGVtZW50cyIsInJlbW92ZUl0ZW1zIiwiTGF5b3V0Iiwic3ViY2xhc3MiLCJQYXJlbnQiLCJTdWJDbGFzcyIsIm1zVW5pdHMiLCJtcyIsIk1hc29ucnkiLCJmaXRXaWR0aCIsIm1lYXN1cmVDb2x1bW5zIiwiY29sWXMiLCJjb2xzIiwibWF4WSIsImdldENvbnRhaW5lcldpZHRoIiwiY29sdW1uV2lkdGgiLCJmaXJzdEl0ZW0iLCJmaXJzdEl0ZW1FbGVtIiwiY29udGFpbmVyV2lkdGgiLCJndXR0ZXIiLCJtYXRoTWV0aG9kIiwiaXNGaXRXaWR0aCIsInJlbWFpbmRlciIsImNvbFNwYW4iLCJjb2xHcm91cCIsIl9nZXRDb2xHcm91cCIsIm1pbmltdW1ZIiwic2hvcnRDb2xJbmRleCIsInNldEhlaWdodCIsInNldFNwYW4iLCJncm91cENvdW50IiwiZ3JvdXBDb2xZcyIsInN0YW1wU2l6ZSIsImZpcnN0WCIsImxhc3RYIiwiZmlyc3RDb2wiLCJmbG9vciIsImxhc3RDb2wiLCJzdGFtcE1heFkiLCJfZ2V0Q29udGFpbmVyRml0V2lkdGgiLCJ1bnVzZWRDb2xzIiwicHJldmlvdXNXaWR0aCIsIlNpdGUiLCJzY3JvbGxtYWdpYyIsIm1vYmlsZU1lbnUiLCJ3aW5kb3dIZWlnaHQiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7O0FBY0MsV0FBVUEsTUFBVixFQUFrQkMsT0FBbEIsRUFBNEI7O0FBRTVCLEtBQUssT0FBT0MsTUFBUCxLQUFrQixRQUFsQixJQUE4QixPQUFPQSxPQUFPQyxPQUFkLEtBQTBCLFFBQTdELEVBQXdFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FELFNBQU9DLE9BQVAsR0FBaUJILE9BQU9J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UztBQUVoQ2huQixvQkFBZ0J0MEQsS0FGZ0I7QUFHaEN1MEQsaUJBQWE7QUFIbUIsSUFBdEIsRUFLVjhGLFFBTFUsQ0FLQXh0RCxLQUxBLEVBTVY4akQsS0FOVSxDQU1KRCxVQU5JLENBQVo7QUFPQSxHQVREO0FBVUE7QUFoQ1MsQ0FBWCIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMi4zXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDQtMDVUMTk6MjZaXG4gKi9cblxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gU3VwcG9ydDogRmlyZWZveCAxOCtcbi8vIENhbid0IGJlIGluIHN0cmljdCBtb2RlLCBzZXZlcmFsIGxpYnMgaW5jbHVkaW5nIEFTUC5ORVQgdHJhY2Vcbi8vIHRoZSBzdGFjayB2aWEgYXJndW1lbnRzLmNhbGxlci5jYWxsZWUgYW5kIEZpcmVmb3ggZGllcyBpZlxuLy8geW91IHRyeSB0byB0cmFjZSB0aHJvdWdoIFwidXNlIHN0cmljdFwiIGNhbGwgY2hhaW5zLiAoIzEzMzM1KVxuLy9cInVzZSBzdHJpY3RcIjtcbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIyLjIuM1wiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbXFxkYS16XSkvZ2ksXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0Ly8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG5cdFx0dmFyIHJlYWxTdHJpbmdPYmogPSBvYmogJiYgb2JqLnRvU3RyaW5nKCk7XG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgKCByZWFsU3RyaW5nT2JqIC0gcGFyc2VGbG9hdCggcmVhbFN0cmluZ09iaiApICsgMSApID49IDA7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Ly8gTm90IHBsYWluIG9iamVjdHM6XG5cdFx0Ly8gLSBBbnkgb2JqZWN0IG9yIHZhbHVlIHdob3NlIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSBpcyBub3QgXCJbb2JqZWN0IE9iamVjdF1cIlxuXHRcdC8vIC0gRE9NIG5vZGVzXG5cdFx0Ly8gLSB3aW5kb3dcblx0XHRpZiAoIGpRdWVyeS50eXBlKCBvYmogKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG5cdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmosIFwiY29uc3RydWN0b3JcIiApICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbCggb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSB8fCB7fSwgXCJpc1Byb3RvdHlwZU9mXCIgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0XHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93blxuXHRcdGZvciAoIGtleSBpbiBvYmogKSB7fVxuXG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKCBvYmosIGtleSApO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wLCBpT1M8NiAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHR2YXIgc2NyaXB0LFxuXHRcdFx0aW5kaXJlY3QgPSBldmFsO1xuXG5cdFx0Y29kZSA9IGpRdWVyeS50cmltKCBjb2RlICk7XG5cblx0XHRpZiAoIGNvZGUgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBjb2RlIGluY2x1ZGVzIGEgdmFsaWQsIHByb2xvZ3VlIHBvc2l0aW9uXG5cdFx0XHQvLyBzdHJpY3QgbW9kZSBwcmFnbWEsIGV4ZWN1dGUgY29kZSBieSBpbmplY3RpbmcgYVxuXHRcdFx0Ly8gc2NyaXB0IHRhZyBpbnRvIHRoZSBkb2N1bWVudC5cblx0XHRcdGlmICggY29kZS5pbmRleE9mKCBcInVzZSBzdHJpY3RcIiApID09PSAxICkge1xuXHRcdFx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cdFx0XHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgYXZvaWQgdGhlIERPTSBub2RlIGNyZWF0aW9uLCBpbnNlcnRpb25cblx0XHRcdFx0Ly8gYW5kIHJlbW92YWwgYnkgdXNpbmcgYW4gaW5kaXJlY3QgZ2xvYmFsIGV2YWxcblxuXHRcdFx0XHRpbmRpcmVjdCggY29kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjFcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuLy8gSlNIaW50IHdvdWxkIGVycm9yIG9uIHRoaXMgY29kZSBkdWUgdG8gdGhlIFN5bWJvbCBub3QgYmVpbmcgZGVmaW5lZCBpbiBFUzUuXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuanNoaW50cmMgd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBqdXN0IGRpc2FibGUgSlNIaW50IGZvciB0aGVzZVxuLy8gdGhyZWUgbGluZXMuXG4vKiBqc2hpbnQgaWdub3JlOiBzdGFydCAqL1xuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuLyoganNoaW50IGlnbm9yZTogZW5kICovXG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiBpT1MgOC4yIChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjIuMVxuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNS0xMC0xN1xuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gR2VuZXJhbC1wdXJwb3NlIGNvbnN0YW50c1xuXHRNQVhfTkVHQVRJVkUgPSAxIDw8IDMxLFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXFxceDAwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cdHJlc2NhcGUgPSAvJ3xcXFxcL2csXG5cblx0Ly8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9O1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG5pZHNlbGVjdCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJlc2NhcGUsIFwiXFxcXCQmXCIgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0bmlkc2VsZWN0ID0gcmlkZW50aWZpZXIudGVzdCggbmlkICkgPyBcIiNcIiArIG5pZCA6IFwiW2lkPSdcIiArIG5pZCArIFwiJ11cIjtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IG5pZHNlbGVjdCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZGl2IGFuZCBleHBlY3RzIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZGl2ICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBkaXYucGFyZW50Tm9kZSApIHtcblx0XHRcdGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBkaXYgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRkaXYgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0KCB+Yi5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKSAtXG5cdFx0XHQoIH5hLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApO1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBwYXJlbnQsXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIChwYXJlbnQgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgcGFyZW50LnRvcCAhPT0gcGFyZW50ICkge1xuXHRcdC8vIFN1cHBvcnQ6IElFIDExXG5cdFx0aWYgKCBwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHBhcmVudC5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBwYXJlbnQuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRwYXJlbnQuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFkaXYuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBtID8gWyBtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdXBwb3J0OiBJRTYvN1xuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBkaXIgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsgZGlyIF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBkaXIgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdFx0XHRFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdjEgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZGl2MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGRpdi5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdHJldHVybiBkaXYuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW1xcdy1dKylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8gKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cblx0fVxuXG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cblx0fVxuXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0XHR9XG5cblx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHR9ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdC8vIE5lZWRlZCBiZWNhdXNlICQoIHNlbGVjdG9yLCBjb250ZXh0ICkgYmVjb21lcyAkKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKVxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQgKTtcblx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFwiIFwiICsgc2VsZWN0b3IgOiBzZWxlY3Rvcjtcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBCbGFja2JlcnJ5IDQuNlxuXHRcdFx0XHRcdC8vIGdFQklEIHJldHVybnMgbm9kZXMgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAoIzY5NjMpXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0cG9zID0gcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSB8fCB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0ICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHBvcyA/XG5cdFx0XHRcdFx0cG9zLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdHdoaXRlID0gKCAvXFxTKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIGpRdWVyeS50eXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIFwicmVqZWN0ZWRcIiBdLFxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyBpIF0gKSAmJiBmbnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMgPT09IHByb21pc2UgPyBuZXdEZWZlci5wcm9taXNlKCkgOiB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdHByb21pc2UucGlwZSA9IHByb21pc2UudGhlbjtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDMgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdC8vIHN0YXRlID0gWyByZXNvbHZlZCB8IHJlamVjdGVkIF1cblx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXG5cdFx0XHRcdC8vIFsgcmVqZWN0X2xpc3QgfCByZXNvbHZlX2xpc3QgXS5kaXNhYmxlOyBwcm9ncmVzc19saXN0LmxvY2tcblx0XHRcdFx0fSwgdHVwbGVzWyBpIF4gMSBdWyAyIF0uZGlzYWJsZSwgdHVwbGVzWyAyIF1bIDIgXS5sb2NrICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHByb21pc2UgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzdWJvcmRpbmF0ZSAvKiAsIC4uLiwgc3Vib3JkaW5hdGVOICovICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGxlbmd0aCA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxuXG5cdFx0XHQvLyB0aGUgY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBsZW5ndGggIT09IDEgfHxcblx0XHRcdFx0KCBzdWJvcmRpbmF0ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggc3Vib3JkaW5hdGUucHJvbWlzZSApICkgPyBsZW5ndGggOiAwLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkLlxuXHRcdFx0Ly8gSWYgcmVzb2x2ZVZhbHVlcyBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgRGVmZXJyZWQsIGp1c3QgdXNlIHRoYXQuXG5cdFx0XHRkZWZlcnJlZCA9IHJlbWFpbmluZyA9PT0gMSA/IHN1Ym9yZGluYXRlIDogalF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIFVwZGF0ZSBmdW5jdGlvbiBmb3IgYm90aCByZXNvbHZlIGFuZCBwcm9ncmVzcyB2YWx1ZXNcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRjb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHR2YWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlcyA9PT0gcHJvZ3Jlc3NWYWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMsIHByb2dyZXNzQ29udGV4dHMsIHJlc29sdmVDb250ZXh0cztcblxuXHRcdC8vIEFkZCBsaXN0ZW5lcnMgdG8gRGVmZXJyZWQgc3Vib3JkaW5hdGVzOyB0cmVhdCBvdGhlcnMgYXMgcmVzb2x2ZWRcblx0XHRpZiAoIGxlbmd0aCA+IDEgKSB7XG5cdFx0XHRwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRwcm9ncmVzc0NvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0LnByb2dyZXNzKCB1cGRhdGVGdW5jKCBpLCBwcm9ncmVzc0NvbnRleHRzLCBwcm9ncmVzc1ZhbHVlcyApIClcblx0XHRcdFx0XHRcdC5kb25lKCB1cGRhdGVGdW5jKCBpLCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZmFpbCggZGVmZXJyZWQucmVqZWN0ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LS1yZW1haW5pbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBvbiBhbnl0aGluZywgcmVzb2x2ZSB0aGUgbWFzdGVyXG5cdFx0aWYgKCAhcmVtYWluaW5nICkge1xuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3Q7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHQvLyBBZGQgdGhlIGNhbGxiYWNrXG5cdGpRdWVyeS5yZWFkeS5wcm9taXNlKCkuZG9uZSggZm4gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cblx0XHQvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcblx0XHRpZiAoIGpRdWVyeS5mbi50cmlnZ2VySGFuZGxlciApIHtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS50cmlnZ2VySGFuZGxlciggXCJyZWFkeVwiICk7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkub2ZmKCBcInJlYWR5XCIgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuLyoqXG4gKiBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuICovXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbmpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHtcblx0aWYgKCAhcmVhZHlMaXN0ICkge1xuXG5cdFx0cmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cblx0XHQvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuXHRcdC8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuXHRcdC8vIFN1cHBvcnQ6IElFOS0xMCBvbmx5XG5cdFx0Ly8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0XHRcdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkeUxpc3QucHJvbWlzZSggb2JqICk7XG59O1xuXG4vLyBLaWNrIG9mZiB0aGUgRE9NIHJlYWR5IGNoZWNrIGV2ZW4gaWYgdGhlIHVzZXIgZG9lcyBub3RcbmpRdWVyeS5yZWFkeS5wcm9taXNlKCk7XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdGVsZW1zIDpcblxuXHRcdC8vIEdldHNcblx0XHRidWxrID9cblx0XHRcdGZuLmNhbGwoIGVsZW1zICkgOlxuXHRcdFx0bGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdC8qIGpzaGludCAtVzAxOCAqL1xuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0cmVnaXN0ZXI6IGZ1bmN0aW9uKCBvd25lciwgaW5pdGlhbCApIHtcblx0XHR2YXIgdmFsdWUgPSBpbml0aWFsIHx8IHt9O1xuXG5cdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUgcHJvcGVydHlcblx0XHQvLyBjb25maWd1cmFiaWxpdHkgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdC8vIGRlbGV0ZWQgd2l0aCB0aGUgZGVsZXRlIG9wZXJhdG9yXG5cdFx0fSBlbHNlIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0fSxcblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0aWYgKCAhYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBkYXRhIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIHByb3AgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGtleSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgc3RvcmVkO1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRzdG9yZWQgPSB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXG5cdFx0XHRyZXR1cm4gc3RvcmVkICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRzdG9yZWQgOiB0aGlzLmdldCggb3duZXIsIGpRdWVyeS5jYW1lbENhc2UoIGtleSApICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLCBuYW1lLCBjYW1lbCxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnJlZ2lzdGVyKCBvd25lciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIFwibmFtZVwiIGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2hlbiBkYXRhIGlzIGluaXRpYWxseSBjcmVhdGVkLCB2aWEgKFwia2V5XCIsIFwidmFsXCIpIHNpZ25hdHVyZSxcblx0XHRcdFx0Ly8ga2V5cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2UuXG5cdFx0XHRcdC8vIFNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byB0ZWxsIF9ob3dfIGEga2V5IHdhcyBhZGRlZCwgcmVtb3ZlXG5cdFx0XHRcdC8vIGJvdGggcGxhaW4ga2V5IGFuZCBjYW1lbENhc2Uga2V5LiAjMTI3ODZcblx0XHRcdFx0Ly8gVGhpcyB3aWxsIG9ubHkgcGVuYWxpemUgdGhlIGFycmF5IGFyZ3VtZW50IHBhdGguXG5cdFx0XHRcdG5hbWUgPSBrZXkuY29uY2F0KCBrZXkubWFwKCBqUXVlcnkuY2FtZWxDYXNlICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbWVsID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gVHJ5IHRoZSBzdHJpbmcgYXMgYSBrZXkgYmVmb3JlIGFueSBtYW5pcHVsYXRpb25cblx0XHRcdFx0aWYgKCBrZXkgaW4gY2FjaGUgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IFsga2V5LCBjYW1lbCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0bmFtZSA9IGNhbWVsO1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lIGluIGNhY2hlID9cblx0XHRcdFx0XHRcdFsgbmFtZSBdIDogKCBuYW1lLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsgbmFtZVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDdcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXG5cdFx0XHRcdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRcdFx0XHQrZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTExK1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGEsIGNhbWVsS2V5O1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgYXMtaXNcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICkgfHxcblxuXHRcdFx0XHRcdC8vIFRyeSB0byBmaW5kIGRhc2hlZCBrZXkgaWYgaXQgZXhpc3RzIChnaC0yNzc5KVxuXHRcdFx0XHRcdC8vIFRoaXMgaXMgZm9yIDIuMi54IG9ubHlcblx0XHRcdFx0XHRkYXRhVXNlci5nZXQoIGVsZW0sIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKSApO1xuXG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FtZWxLZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBjYW1lbGl6ZWRcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwgY2FtZWxLZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwgY2FtZWxLZXksIHVuZGVmaW5lZCApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIEZpcnN0LCBhdHRlbXB0IHRvIHN0b3JlIGEgY29weSBvciByZWZlcmVuY2Ugb2YgYW55XG5cdFx0XHRcdC8vIGRhdGEgdGhhdCBtaWdodCd2ZSBiZWVuIHN0b3JlIHdpdGggYSBjYW1lbENhc2VkIGtleS5cblx0XHRcdFx0dmFyIGRhdGEgPSBkYXRhVXNlci5nZXQoIHRoaXMsIGNhbWVsS2V5ICk7XG5cblx0XHRcdFx0Ly8gRm9yIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGUgaW50ZXJvcCwgd2UgaGF2ZSB0b1xuXHRcdFx0XHQvLyBzdG9yZSBwcm9wZXJ0eSBuYW1lcyB3aXRoIGRhc2hlcyBpbiBhIGNhbWVsQ2FzZSBmb3JtLlxuXHRcdFx0XHQvLyBUaGlzIG1pZ2h0IG5vdCBhcHBseSB0byBhbGwgcHJvcGVydGllcy4uLipcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBjYW1lbEtleSwgdmFsdWUgKTtcblxuXHRcdFx0XHQvLyAqLi4uIEluIHRoZSBjYXNlIG9mIHByb3BlcnRpZXMgdGhhdCBtaWdodCBfYWN0dWFsbHlfXG5cdFx0XHRcdC8vIGhhdmUgZGFzaGVzLCB3ZSBuZWVkIHRvIGFsc28gc3RvcmUgYSBjb3B5IG9mIHRoYXRcblx0XHRcdFx0Ly8gdW5jaGFuZ2VkIHByb3BlcnR5LlxuXHRcdFx0XHRpZiAoIGtleS5pbmRleE9mKCBcIi1cIiApID4gLTEgJiYgZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW4gbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCIgfHxcblx0XHRcdCFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLFxuXHRcdHNjYWxlID0gMSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0d2Vlbi5jdXIoKTsgfSA6XG5cdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTsgfSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW1xcdzotXSspLyApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRTlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0ID0gdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0dHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRcdGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0W107XG5cblx0cmV0dXJuIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBqUXVlcnkubm9kZU5hbWUoIGNvbnRleHQsIHRhZyApID9cblx0XHRqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKSA6XG5cdFx0cmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjEsIFBoYW50b21KUzwyXG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wLTQuMywgU2FmYXJpPD01LjFcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaTw9NS4xLCBBbmRyb2lkPDQuMlxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRTlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBtYXRjaGVzLCBzZWwsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBTdXBwb3J0IChhdCBsZWFzdCk6IENocm9tZSwgSUU5XG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG5cdFx0Ly9cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PD00Mitcblx0XHQvLyBBdm9pZCBub24tbGVmdC1jbGljayBpbiBGRiBidXQgZG9uJ3QgYmxvY2sgSUUgcmFkaW8gZXZlbnRzICgjMzg2MSwgZ2gtMjM0Mylcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiYgY3VyLm5vZGVUeXBlICYmXG5cdFx0XHQoIGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiB8fCBpc05hTiggZXZlbnQuYnV0dG9uICkgfHwgZXZlbnQuYnV0dG9uIDwgMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICggY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiApICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlcyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdC8vIEluY2x1ZGVzIHNvbWUgZXZlbnQgcHJvcHMgc2hhcmVkIGJ5IEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50XG5cdHByb3BzOiAoIFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZGV0YWlsIGV2ZW50UGhhc2UgXCIgK1xuXHRcdFwibWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiICkuc3BsaXQoIFwiIFwiICksXG5cblx0Zml4SG9va3M6IHt9LFxuXG5cdGtleUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KCBcIiBcIiApLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gb3JpZ2luYWwuY2hhckNvZGUgIT0gbnVsbCA/IG9yaWdpbmFsLmNoYXJDb2RlIDogb3JpZ2luYWwua2V5Q29kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRtb3VzZUhvb2tzOiB7XG5cdFx0cHJvcHM6ICggXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIFwiICtcblx0XHRcdFwic2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFwiICkuc3BsaXQoIFwiIFwiICksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXHRcdFx0dmFyIGV2ZW50RG9jLCBkb2MsIGJvZHksXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbjtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0ZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcblxuXHRcdFx0XHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggK1xuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDAgKSAtXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCApO1xuXHRcdFx0XHRldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgK1xuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLmNsaWVudFRvcCAgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCAgfHwgMCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0XHQvLyBOb3RlOiBidXR0b24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIGRvbid0IHVzZSBpdFxuXHRcdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBhIHdyaXRhYmxlIGNvcHkgb2YgdGhlIGV2ZW50IG9iamVjdCBhbmQgbm9ybWFsaXplIHNvbWUgcHJvcGVydGllc1xuXHRcdHZhciBpLCBwcm9wLCBjb3B5LFxuXHRcdFx0dHlwZSA9IGV2ZW50LnR5cGUsXG5cdFx0XHRvcmlnaW5hbEV2ZW50ID0gZXZlbnQsXG5cdFx0XHRmaXhIb29rID0gdGhpcy5maXhIb29rc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCAhZml4SG9vayApIHtcblx0XHRcdHRoaXMuZml4SG9va3NbIHR5cGUgXSA9IGZpeEhvb2sgPVxuXHRcdFx0XHRybW91c2VFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLm1vdXNlSG9va3MgOlxuXHRcdFx0XHRya2V5RXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5rZXlIb29rcyA6XG5cdFx0XHRcdHt9O1xuXHRcdH1cblx0XHRjb3B5ID0gZml4SG9vay5wcm9wcyA/IHRoaXMucHJvcHMuY29uY2F0KCBmaXhIb29rLnByb3BzICkgOiB0aGlzLnByb3BzO1xuXG5cdFx0ZXZlbnQgPSBuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cblx0XHRpID0gY29weS5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRwcm9wID0gY29weVsgaSBdO1xuXHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdpbmFsRXZlbnRbIHByb3AgXTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBDb3Jkb3ZhIDIuNSAoV2ViS2l0KSAoIzEzMjU1KVxuXHRcdC8vIEFsbCBldmVudHMgc2hvdWxkIGhhdmUgYSB0YXJnZXQ7IENvcmRvdmEgZGV2aWNlcmVhZHkgZG9lc24ndFxuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGRvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjArLCBDaHJvbWU8Mjhcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZpeEhvb2suZmlsdGVyID8gZml4SG9vay5maWx0ZXIoIGV2ZW50LCBvcmlnaW5hbEV2ZW50ICkgOiBldmVudDtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzotXSspW14+XSopXFwvPi9naSxcblxuXHQvLyBTdXBwb3J0OiBJRSAxMC0xMSwgRWRnZSAxMDI0MCtcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fFxuXHRcdFx0ZWxlbS5hcHBlbmRDaGlsZCggZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGJvZHlcIiApICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0gMzUtNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gS2VlcCBkb21NYW5pcCBleHBvc2VkIHVudGlsIDMuMCAoZ2gtMjIyNSlcblx0ZG9tTWFuaXA6IGRvbU1hbmlwLFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3hcblx0XHQvLyBXZSBoYXZlIHRvIHByZS1kZWZpbmUgdGhlc2UgdmFsdWVzIGZvciBGRiAoIzEwMjI3KVxuXHRcdEhUTUw6IFwiYmxvY2tcIixcblx0XHRCT0RZOiBcImJsb2NrXCJcblx0fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW1bIDAgXSwgXCJkaXNwbGF5XCIgKTtcblxuXHQvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCxcblx0Ly8gc28gdXNlIFwiZGV0YWNoXCIgbWV0aG9kIGFzIGZhc3Qgd2F5IHRvIGdldCByaWQgb2YgdGhlIGVsZW1lbnRcblx0ZWxlbS5kZXRhY2goKTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblx0dmFyIGRvYyA9IGRvY3VtZW50LFxuXHRcdGRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcblxuXHRpZiAoICFkaXNwbGF5ICkge1xuXHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cblx0XHQvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFkaXNwbGF5ICkge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcblx0XHRcdGlmcmFtZSA9ICggaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSApXG5cdFx0XHRcdC5hcHBlbmRUbyggZG9jLmRvY3VtZW50RWxlbWVudCApO1xuXG5cdFx0XHQvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2Vcblx0XHRcdGRvYyA9IGlmcmFtZVsgMCBdLmNvbnRlbnREb2N1bWVudDtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdGRvYy53cml0ZSgpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cblx0XHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cdFx0XHRpZnJhbWUuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG5cdFx0ZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXHR9XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcblx0XHRcdC8vIHNpbmNlIHdlIGNhbiB1c2UgdGhlIGJveFNpemluZ1JlbGlhYmxlIHByZS1jb21wdXRpbmcuXG5cdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wLTQuM1xuXHRcdFx0Ly8gV2UncmUgY2hlY2tpbmcgZm9yIGJveFNpemluZ1JlbGlhYmxlVmFsIGhlcmUgaW5zdGVhZCBvZiBwaXhlbE1hcmdpblJpZ2h0VmFsXG5cdFx0XHQvLyBzaW5jZSB0aGF0IGNvbXByZXNzZXMgYmV0dGVyIGFuZCB0aGV5J3JlIGNvbXB1dGVkIHRvZ2V0aGVyIGFueXdheS5cblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IG9ubHksIEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gMzdcblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXG5cdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFwiZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcblx0XHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2ICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0XHRcdGRpdi5yZW1vdmVDaGlsZCggbWFyZ2luRGl2ICk7XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXHRyZXQgPSBjb21wdXRlZCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkO1xuXG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDEyLjF4IG9ubHlcblx0Ly8gRmFsbCBiYWNrIHRvIHN0eWxlIGV2ZW4gd2l0aG91dCBjb21wdXRlZFxuXHQvLyBjb21wdXRlZCBpcyB1bmRlZmluZWQgZm9yIGVsZW1zIG9uIGRvY3VtZW50IGZyYWdtZW50c1xuXHRpZiAoICggcmV0ID09PSBcIlwiIHx8IHJldCA9PT0gdW5kZWZpbmVkICkgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgKCMxMjUzNylcblx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGkgPSBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApID9cblxuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogSUUxMSBvbmx5XG5cdC8vIEluIElFIDExIGZ1bGxzY3JlZW4gZWxlbWVudHMgaW5zaWRlIG9mIGFuIGlmcmFtZSBoYXZlXG5cdC8vIDEwMHggdG9vIHNtYWxsIGRpbWVuc2lvbnMgKGdoLTE3NjQpLlxuXHRpZiAoIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQgJiYgd2luZG93LnRvcCAhPT0gd2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUxMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRpZiAoIGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHR2YWwgPSBNYXRoLnJvdW5kKCBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpWyBuYW1lIF0gKiAxMDAgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcblx0Ly8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApO1xuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBSZXNldCB0aGUgaW5saW5lIGRpc3BsYXkgb2YgdGhpcyBlbGVtZW50IHRvIGxlYXJuIGlmIGl0IGlzXG5cdFx0XHQvLyBiZWluZyBoaWRkZW4gYnkgY2FzY2FkZWQgcnVsZXMgb3Igbm90XG5cdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gJiYgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB3aXRoIGRpc3BsYXk6IG5vbmVcblx0XHRcdC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG5cdFx0XHQvLyBmb3Igc3VjaCBhbiBlbGVtZW50XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbiggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5hY2Nlc3MoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcIm9sZGRpc3BsYXlcIixcblx0XHRcdFx0XHRkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhpZGRlbiA9IGlzSGlkZGVuKCBlbGVtICk7XG5cblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgfHwgIWhpZGRlbiApIHtcblx0XHRcdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XCJvbGRkaXNwbGF5XCIsXG5cdFx0XHRcdFx0aGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCAhc2hvdyB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZXNbIGluZGV4IF0gfHwgXCJcIiA6IFwibm9uZVwiO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cdFx0XHRcdFx0ZWxlbS5vZmZzZXRXaWR0aCA9PT0gMCA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xualF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuIHN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSxcblx0XHRcdFx0Y3VyQ1NTLCBbIGVsZW0sIFwibWFyZ2luUmlnaHRcIiBdICk7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW4oIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRTlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNCA7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHQvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCB0d2VlbiwgaG9va3MsIG9sZGZpcmUsIGRpc3BsYXksIGNoZWNrRGlzcGxheSxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIEhhbmRsZSBxdWV1ZTogZmFsc2UgcHJvbWlzZXNcblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3Ncblx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUU5LTEwIGRvIG5vdFxuXHRcdC8vIGNoYW5nZSB0aGUgb3ZlcmZsb3cgYXR0cmlidXRlIHdoZW4gb3ZlcmZsb3dYIGFuZFxuXHRcdC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBTZXQgZGlzcGxheSBwcm9wZXJ0eSB0byBpbmxpbmUtYmxvY2sgZm9yIGhlaWdodC93aWR0aFxuXHRcdC8vIGFuaW1hdGlvbnMgb24gaW5saW5lIGVsZW1lbnRzIHRoYXQgYXJlIGhhdmluZyB3aWR0aC9oZWlnaHQgYW5pbWF0ZWRcblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblxuXHRcdC8vIFRlc3QgZGVmYXVsdCBkaXNwbGF5IGlmIGRpc3BsYXkgaXMgY3VycmVudGx5IFwibm9uZVwiXG5cdFx0Y2hlY2tEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgP1xuXHRcdFx0ZGF0YVByaXYuZ2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApIHx8IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5O1xuXG5cdFx0aWYgKCBjaGVja0Rpc3BsYXkgPT09IFwiaW5saW5lXCIgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBzaG93L2hpZGUgcGFzc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLmV4ZWMoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGRhdGFTaG93IGxlZnQgb3ZlciBmcm9tIGEgc3RvcHBlZCBoaWRlIG9yIHNob3dcblx0XHRcdFx0Ly8gYW5kIHdlIGFyZSBnb2luZyB0byBwcm9jZWVkIHdpdGggc2hvdywgd2Ugc2hvdWxkIHByZXRlbmQgdG8gYmUgaGlkZGVuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXG5cdFx0Ly8gQW55IG5vbi1meCB2YWx1ZSBzdG9wcyB1cyBmcm9tIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXNwbGF5ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwge30gKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSBzdGF0ZSBpZiBpdHMgdG9nZ2xlIC0gZW5hYmxlcyAuc3RvcCgpLnRvZ2dsZSgpIHRvIFwicmV2ZXJzZVwiXG5cdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdH1cblx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdGpRdWVyeSggZWxlbSApLnNob3coKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5KCBlbGVtICkuaGlkZSgpO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3A7XG5cblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHR0d2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXG5cdFx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0XHR0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0XHR0d2Vlbi5zdGFydCA9IHByb3AgPT09IFwid2lkdGhcIiB8fCBwcm9wID09PSBcImhlaWdodFwiID8gMSA6IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0Ly8gSWYgdGhpcyBpcyBhIG5vb3AgbGlrZSAuaGlkZSgpLmhpZGUoKSwgcmVzdG9yZSBhbiBvdmVyd3JpdHRlbiBkaXNwbGF5IHZhbHVlXG5cdH0gZWxzZSBpZiAoICggZGlzcGxheSA9PT0gXCJub25lXCIgPyBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheSApID09PSBcImlubGluZVwiICkge1xuXHRcdHN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRqUXVlcnkucHJveHkoIHJlc3VsdC5zdG9wLCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90d2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID9cblx0XHRvcHQuZHVyYXRpb24gOiBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/XG5cdFx0XHRqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW4gKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gd2luZG93LnNldEludGVydmFsKCBqUXVlcnkuZngudGljaywgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdHdpbmRvdy5jbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cblx0dGltZXJJZCA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cDovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IGlPUzw9NS4xLCBBbmRyb2lkPD00LjIrXG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw9Mi4zXG5cdC8vIE9wdGlvbnMgaW5zaWRlIGRpc2FibGVkIHNlbGVjdHMgYXJlIGluY29ycmVjdGx5IG1hcmtlZCBhcyBkaXNhYmxlZFxuXHRzZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xuXHRzdXBwb3J0Lm9wdERpc2FibGVkID0gIW9wdC5kaXNhYmxlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSwgcHJvcE5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cblx0XHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGdldCBzcGVjaWFsIHRyZWF0bWVudCAoIzEwODcwKVxuXHRcdFx0XHRpZiAoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHRcdFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2Vcblx0XHRcdFx0XHRlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZTtcblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdHJldHVybiB0YWJpbmRleCA/XG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRhYmluZGV4LCAxMCApIDpcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRcdFx0MCA6XG5cdFx0XHRcdFx0XHRcdC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIGdldENsYXNzKCBlbGVtICkgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nLFxuXHRyc3BhY2VzID0gL1tcXHgyMFxcdFxcclxcblxcZl0rL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICkgOlxuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTAtMTErXG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApLnJlcGxhY2UoIHJzcGFjZXMsIFwiIFwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0KCBzdXBwb3J0Lm9wdERpc2FibGVkID9cblx0XHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT09IG51bGwgKSAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cblx0XHRcdFx0Ly8gUHJldmlvdXNseSwgYG9yaWdpbmFsRXZlbnQ6IHt9YCB3YXMgc2V0IGhlcmUsIHNvIHN0b3BQcm9wYWdhdGlvbiBjYWxsXG5cdFx0XHRcdC8vIHdvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgb24gZG9ub3IgZXZlbnQsIHNpbmNlIGluIG91ciBvd25cblx0XHRcdFx0Ly8galF1ZXJ5LmV2ZW50LnN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbiB3ZSBoYWQgYSBjaGVjayBmb3IgZXhpc3RlbmNlIG9mXG5cdFx0XHRcdC8vIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uIG1ldGhvZCwgc28sIGNvbnNlcXVlbnRseSBpdCB3b3VsZCBiZSBhIG5vb3AuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEJ1dCBub3csIHRoaXMgXCJzaW11bGF0ZVwiIGZ1bmN0aW9uIGlzIHVzZWQgb25seSBmb3IgZXZlbnRzXG5cdFx0XHRcdC8vIGZvciB3aGljaCBzdG9wUHJvcGFnYXRpb24oKSBpcyBub29wLCBzbyB0aGVyZSBpcyBubyBuZWVkIGZvciB0aGF0IGFueW1vcmUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEZvciB0aGUgMS54IGJyYW5jaCB0aG91Z2gsIGd1YXJkIGZvciBcImNsaWNrXCIgYW5kIFwic3VibWl0XCJcblx0XHRcdFx0Ly8gZXZlbnRzIGlzIHN0aWxsIHVzZWQsIGJ1dCB3YXMgbW92ZWQgdG8galF1ZXJ5LmV2ZW50LnN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvblxuXHRcdFx0XHQvLyBiZWNhdXNlIGBvcmlnaW5hbEV2ZW50YCBzaG91bGQgcG9pbnQgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IGZvciB0aGUgY29uc3RhbmN5XG5cdFx0XHRcdC8vIHdpdGggb3RoZXIgZXZlbnRzIGFuZCBmb3IgbW9yZSBmb2N1c2VkIGxvZ2ljXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUsIFNhZmFyaVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcbmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgtMTErXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIGlmIHVybCBpcyBtYWxmb3JtZWQsIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU4LTExK1xuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdGNhY2hlVVJMID0gcy51cmw7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0gKS5lbmQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0Ly8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcblx0Ly8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuXHQvLyBVc2UgT1IgaW5zdGVhZCBvZiBBTkQgYXMgdGhlIGVsZW1lbnQgaXMgbm90IHZpc2libGUgaWYgZWl0aGVyIGlzIHRydWVcblx0Ly8gU2VlIHRpY2tldHMgIzEwNDA2IGFuZCAjMTMxMzJcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPiAwIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0ID4gMCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID4gMDtcbn07XG5cblxuXG5cbnZhciByMjAgPSAvJTIwL2csXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFOSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0dmFyIHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApLFxuXHRcdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbnZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IGpRdWVyeS50cmltKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/IGVsZW0gOiBlbGVtLm5vZGVUeXBlID09PSA5ICYmIGVsZW0uZGVmYXVsdFZpZXc7XG59XG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciBkb2NFbGVtLCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0Ym94ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcblx0XHRcdGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xuXG5cdFx0aWYgKCAhZG9jICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlzY29ubmVjdGVkIERPTSBub2RlXG5cdFx0aWYgKCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm4gYm94O1xuXHRcdH1cblxuXHRcdGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZ2V0V2luZG93KCBkb2MgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBib3gudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRsZWZ0OiBib3gubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdH07XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG5cdFx0Ly8gYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaTw3LTgrLCBDaHJvbWU8MzctNDQrXG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjkyODBcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQXMgb2YgNS84LzIwMTIgdGhpcyB3aWxsIHlpZWxkIGluY29ycmVjdCByZXN1bHRzIGZvciBNb2JpbGUgU2FmYXJpLCBidXQgdGhlcmVcblx0XHRcdFx0XHQvLyBpc24ndCBhIHdob2xlIGxvdCB3ZSBjYW4gZG8uIFNlZSBwdWxsIHJlcXVlc3QgYXQgdGhpcyBVUkwgZm9yIGRpc2N1c3Npb246XG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC83NjRcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fSxcblx0c2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxucmV0dXJuIGpRdWVyeTtcbn0pKTtcbiIsIi8qIVxuICogVkVSU0lPTjogMS4xOC40XG4gKiBEQVRFOiAyMDE2LTA0LTI2XG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICogXG4gKiBJbmNsdWRlcyBhbGwgb2YgdGhlIGZvbGxvd2luZzogVHdlZW5MaXRlLCBUd2Vlbk1heCwgVGltZWxpbmVMaXRlLCBUaW1lbGluZU1heCwgRWFzZVBhY2ssIENTU1BsdWdpbiwgUm91bmRQcm9wc1BsdWdpbiwgQmV6aWVyUGx1Z2luLCBBdHRyUGx1Z2luLCBEaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTYsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICoqL1xudmFyIF9nc1Njb3BlID0gKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93OyAvL2hlbHBzIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggQU1EL1JlcXVpcmVKUyBhbmQgQ29tbW9uSlMvTm9kZVxuKF9nc1Njb3BlLl9nc1F1ZXVlIHx8IChfZ3NTY29wZS5fZ3NRdWV1ZSA9IFtdKSkucHVzaCggZnVuY3Rpb24oKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwiVHdlZW5NYXhcIiwgW1wiY29yZS5BbmltYXRpb25cIixcImNvcmUuU2ltcGxlVGltZWxpbmVcIixcIlR3ZWVuTGl0ZVwiXSwgZnVuY3Rpb24oQW5pbWF0aW9uLCBTaW1wbGVUaW1lbGluZSwgVHdlZW5MaXRlKSB7XG5cblx0XHR2YXIgX3NsaWNlID0gZnVuY3Rpb24oYSkgeyAvL2Rvbid0IHVzZSBbXS5zbGljZSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHR2YXIgYiA9IFtdLFxuXHRcdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpICE9PSBsOyBiLnB1c2goYVtpKytdKSk7XG5cdFx0XHRcdHJldHVybiBiO1xuXHRcdFx0fSxcblx0XHRcdF9hcHBseUN5Y2xlID0gZnVuY3Rpb24odmFycywgdGFyZ2V0cywgaSkge1xuXHRcdFx0XHR2YXIgYWx0ID0gdmFycy5jeWNsZSxcblx0XHRcdFx0XHRwLCB2YWw7XG5cdFx0XHRcdGZvciAocCBpbiBhbHQpIHtcblx0XHRcdFx0XHR2YWwgPSBhbHRbcF07XG5cdFx0XHRcdFx0dmFyc1twXSA9ICh0eXBlb2YodmFsKSA9PT0gXCJmdW5jdGlvblwiKSA/IHZhbC5jYWxsKHRhcmdldHNbaV0sIGkpIDogdmFsW2kgJSB2YWwubGVuZ3RoXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgdmFycy5jeWNsZTtcblx0XHRcdH0sXG5cdFx0XHRUd2Vlbk1heCA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdFx0VHdlZW5MaXRlLmNhbGwodGhpcywgdGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gMDtcblx0XHRcdFx0dGhpcy5feW95byA9ICh0aGlzLnZhcnMueW95byA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSB0cnVlOyAvL2Vuc3VyZXMgdGhhdCBpZiB0aGVyZSBpcyBhbnkgcmVwZWF0LCB0aGUgdG90YWxEdXJhdGlvbiB3aWxsIGdldCByZWNhbGN1bGF0ZWQgdG8gYWNjdXJhdGVseSByZXBvcnQgaXQuXG5cdFx0XHRcdHRoaXMucmVuZGVyID0gVHdlZW5NYXgucHJvdG90eXBlLnJlbmRlcjsgLy9zcGVlZCBvcHRpbWl6YXRpb24gKGF2b2lkIHByb3RvdHlwZSBsb29rdXAgb24gdGhpcyBcImhvdFwiIG1ldGhvZClcblx0XHRcdH0sXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdFR3ZWVuTGl0ZUludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNTZWxlY3Rvcixcblx0XHRcdF9pc0FycmF5ID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzQXJyYXksXG5cdFx0XHRwID0gVHdlZW5NYXgucHJvdG90eXBlID0gVHdlZW5MaXRlLnRvKHt9LCAwLjEsIHt9KSxcblx0XHRcdF9ibGFua0FycmF5ID0gW107XG5cblx0XHRUd2Vlbk1heC52ZXJzaW9uID0gXCIxLjE4LjRcIjtcblx0XHRwLmNvbnN0cnVjdG9yID0gVHdlZW5NYXg7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cdFx0VHdlZW5NYXgua2lsbFR3ZWVuc09mID0gVHdlZW5NYXgua2lsbERlbGF5ZWRDYWxsc1RvID0gVHdlZW5MaXRlLmtpbGxUd2VlbnNPZjtcblx0XHRUd2Vlbk1heC5nZXRUd2VlbnNPZiA9IFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZjtcblx0XHRUd2Vlbk1heC5sYWdTbW9vdGhpbmcgPSBUd2VlbkxpdGUubGFnU21vb3RoaW5nO1xuXHRcdFR3ZWVuTWF4LnRpY2tlciA9IFR3ZWVuTGl0ZS50aWNrZXI7XG5cdFx0VHdlZW5NYXgucmVuZGVyID0gVHdlZW5MaXRlLnJlbmRlcjtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5feW95byA9ICh0aGlzLnZhcnMueW95byA9PT0gdHJ1ZSk7XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB0aGlzLnZhcnMucmVwZWF0IHx8IDA7XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHRoaXMudmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdHJldHVybiBUd2VlbkxpdGUucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAudXBkYXRlVG8gPSBmdW5jdGlvbih2YXJzLCByZXNldER1cmF0aW9uKSB7XG5cdFx0XHR2YXIgY3VyUmF0aW8gPSB0aGlzLnJhdGlvLFxuXHRcdFx0XHRpbW1lZGlhdGUgPSB0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyIHx8IHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuXHRcdFx0XHRwO1xuXHRcdFx0aWYgKHJlc2V0RHVyYXRpb24gJiYgdGhpcy5fc3RhcnRUaW1lIDwgdGhpcy5fdGltZWxpbmUuX3RpbWUpIHtcblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdGhpcy5fdGltZWxpbmUuX3RpbWU7XG5cdFx0XHRcdHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lbGluZS5pbnNlcnQodGhpcywgdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fZGVsYXkpOyAvL2Vuc3VyZXMgdGhhdCBhbnkgbmVjZXNzYXJ5IHJlLXNlcXVlbmNpbmcgb2YgQW5pbWF0aW9ucyBpbiB0aGUgdGltZWxpbmUgb2NjdXJzIHRvIG1ha2Ugc3VyZSB0aGUgcmVuZGVyaW5nIG9yZGVyIGlzIGNvcnJlY3QuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdHRoaXMudmFyc1twXSA9IHZhcnNbcF07XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5faW5pdHRlZCB8fCBpbW1lZGlhdGUpIHtcblx0XHRcdFx0aWYgKHJlc2V0RHVyYXRpb24pIHtcblx0XHRcdFx0XHR0aGlzLl9pbml0dGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKGltbWVkaWF0ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkICYmIHRoaXMuX2ZpcnN0UFQpIHtcblx0XHRcdFx0XHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudChcIl9vbkRpc2FibGVcIiwgdGhpcyk7IC8vaW4gY2FzZSBhIHBsdWdpbiBsaWtlIE1vdGlvbkJsdXIgbXVzdCBwZXJmb3JtIHNvbWUgY2xlYW51cCB0YXNrc1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSAvIHRoaXMuX2R1cmF0aW9uID4gMC45OTgpIHsgLy9pZiB0aGUgdHdlZW4gaGFzIGZpbmlzaGVkIChvciBjb21lIGV4dHJlbWVseSBjbG9zZSB0byBmaW5pc2hpbmcpLCB3ZSBqdXN0IG5lZWQgdG8gcmV3aW5kIGl0IHRvIDAgYW5kIHRoZW4gcmVuZGVyIGl0IGFnYWluIGF0IHRoZSBlbmQgd2hpY2ggZm9yY2VzIGl0IHRvIHJlLWluaXRpYWxpemUgKHBhcnNpbmcgdGhlIG5ldyB2YXJzKS4gV2UgYWxsb3cgdHdlZW5zIHRoYXQgYXJlIGNsb3NlIHRvIGZpbmlzaGluZyAoYnV0IGhhdmVuJ3QgcXVpdGUgZmluaXNoZWQpIHRvIHdvcmsgdGhpcyB3YXkgdG9vIGJlY2F1c2Ugb3RoZXJ3aXNlLCB0aGUgdmFsdWVzIGFyZSBzbyBzbWFsbCB3aGVuIGRldGVybWluaW5nIHdoZXJlIHRvIHByb2plY3QgdGhlIHN0YXJ0aW5nIHZhbHVlcyB0aGF0IGJpbmFyeSBtYXRoIGlzc3VlcyBjcmVlcCBpbiBhbmQgY2FuIG1ha2UgdGhlIHR3ZWVuIGFwcGVhciB0byByZW5kZXIgaW5jb3JyZWN0bHkgd2hlbiBydW4gYmFja3dhcmRzLiBcblx0XHRcdFx0XHRcdHZhciBwcmV2VGltZSA9IHRoaXMuX3RvdGFsVGltZTtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKDAsIHRydWUsIGZhbHNlKTtcblx0XHRcdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKHByZXZUaW1lLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMuX2luaXQoKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gMCB8fCBpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGludiA9IDEgLyAoMSAtIGN1clJhdGlvKSxcblx0XHRcdFx0XHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQsIGVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHB0LnMgKyBwdC5jO1xuXHRcdFx0XHRcdFx0XHRcdHB0LmMgKj0gaW52O1xuXHRcdFx0XHRcdFx0XHRcdHB0LnMgPSBlbmRWYWx1ZSAtIHB0LmM7XG5cdFx0XHRcdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcdFx0XG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkgaWYgKHRoaXMuX2R1cmF0aW9uID09PSAwICYmIHRoaXMudmFycy5yZXBlYXQpIHsgLy96ZXJvIGR1cmF0aW9uIHR3ZWVucyB0aGF0IHJlbmRlciBpbW1lZGlhdGVseSBoYXZlIHJlbmRlcigpIGNhbGxlZCBmcm9tIFR3ZWVuTGl0ZSdzIGNvbnN0cnVjdG9yLCBiZWZvcmUgVHdlZW5NYXgncyBjb25zdHJ1Y3RvciBoYXMgZmluaXNoZWQgc2V0dGluZyBfcmVwZWF0LCBfcmVwZWF0RGVsYXksIGFuZCBfeW95byB3aGljaCBhcmUgY3JpdGljYWwgaW4gZGV0ZXJtaW5pbmcgdG90YWxEdXJhdGlvbigpIHNvIHdlIG5lZWQgdG8gY2FsbCBpbnZhbGlkYXRlKCkgd2hpY2ggaXMgYSBsb3cta2Igd2F5IHRvIGdldCB0aG9zZSBzZXQgcHJvcGVybHkuXG5cdFx0XHRcdHRoaXMuaW52YWxpZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0cHJldlRvdGFsVGltZSA9IHRoaXMuX3RvdGFsVGltZSwgXG5cdFx0XHRcdHByZXZDeWNsZSA9IHRoaXMuX2N5Y2xlLFxuXHRcdFx0XHRkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRwcmV2UmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0aXNDb21wbGV0ZSwgY2FsbGJhY2ssIHB0LCBjeWNsZUR1cmF0aW9uLCByLCB0eXBlLCBwb3csIHJhd1ByZXZUaW1lO1xuXHRcdFx0aWYgKHRpbWUgPj0gdG90YWxEdXIgLSAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0b3RhbER1cjtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSB0aGlzLl9yZXBlYXQ7XG5cdFx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDApIDogMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDEpIDogMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRmb3JjZSA9IChmb3JjZSB8fCB0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9zdGFydFRpbWUgPT09IHRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbikgeyAvL2lmIGEgemVyby1kdXJhdGlvbiB0d2VlbiBpcyBhdCB0aGUgVkVSWSBlbmQgb2YgYSB0aW1lbGluZSBhbmQgdGhhdCB0aW1lbGluZSByZW5kZXJzIGF0IGl0cyBlbmQsIGl0IHdpbGwgdHlwaWNhbGx5IGFkZCBhIHRpbnkgYml0IG9mIGN1c2hpb24gdG8gdGhlIHJlbmRlciB0aW1lIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzIGZyb20gZ2V0dGluZyBpbiB0aGUgd2F5IG9mIHR3ZWVucyByZW5kZXJpbmcgdGhlaXIgVkVSWSBlbmQuIElmIHdlIHRoZW4gcmV2ZXJzZSgpIHRoYXQgdGltZWxpbmUsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHdpbGwgdHJpZ2dlciBpdHMgb25SZXZlcnNlQ29tcGxldGUgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHkgdGhlIHBsYXloZWFkIGRpZG4ndCBwYXNzIG92ZXIgaXQgYWdhaW4uIEl0J3MgYSB2ZXJ5IHNwZWNpZmljIGVkZ2UgY2FzZSB3ZSBtdXN0IGFjY29tbW9kYXRlLlxuXHRcdFx0XHRcdFx0dGltZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPCAwIHx8ICh0aW1lIDw9IDAgJiYgdGltZSA+PSAtMC4wMDAwMDAxKSB8fCAocHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiB0aGlzLmRhdGEgIT09IFwiaXNQYXVzZVwiKSkgaWYgKHByZXZSYXdQcmV2VGltZSAhPT0gdGltZSkgeyAvL25vdGU6IHdoZW4gdGhpcy5kYXRhIGlzIFwiaXNQYXVzZVwiLCBpdCdzIGEgY2FsbGJhY2sgYWRkZWQgYnkgYWRkUGF1c2UoKSBvbiBhIHRpbWVsaW5lIHRoYXQgd2Ugc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgd2hlbiBMRUFWSU5HIGl0cyBleGFjdCBzdGFydCB0aW1lLiBJbiBvdGhlciB3b3JkcywgdGwuYWRkUGF1c2UoMSkucGxheSgxKSBzaG91bGRuJ3QgcGF1c2UuXG5cdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHRpZiAocHJldlRvdGFsVGltZSAhPT0gMCB8fCAoZHVyYXRpb24gPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lID4gMCkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkgeyAvL2lmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cblx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aW1lO1xuXHRcdFx0XHRpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdFx0Y3ljbGVEdXJhdGlvbiA9IGR1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSAodGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikgPj4gMDsgLy9vcmlnaW5hbGx5IF90b3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uIGJ1dCBmbG9hdGluZyBwb2ludCBlcnJvcnMgY2F1c2VkIHByb2JsZW1zLCBzbyBJIG5vcm1hbGl6ZWQgaXQuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblx0XHRcdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IDApIGlmICh0aGlzLl9jeWNsZSA9PT0gdGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbiAmJiBwcmV2VG90YWxUaW1lIDw9IHRpbWUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlLS07IC8vb3RoZXJ3aXNlIHdoZW4gcmVuZGVyZWQgZXhhY3RseSBhdCB0aGUgZW5kIHRpbWUsIGl0IHdpbGwgYWN0IGFzIHRob3VnaCBpdCBpcyByZXBlYXRpbmcgKGF0IHRoZSBiZWdpbm5pbmcpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgLSAodGhpcy5fY3ljbGUgKiBjeWNsZUR1cmF0aW9uKTtcblx0XHRcdFx0XHRpZiAodGhpcy5feW95bykgaWYgKCh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyYXRpb24gLSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IGR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lIDwgMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX2Vhc2VUeXBlKSB7XG5cdFx0XHRcdFx0ciA9IHRoaXMuX3RpbWUgLyBkdXJhdGlvbjtcblx0XHRcdFx0XHR0eXBlID0gdGhpcy5fZWFzZVR5cGU7XG5cdFx0XHRcdFx0cG93ID0gdGhpcy5fZWFzZVBvd2VyO1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxIHx8ICh0eXBlID09PSAzICYmIHIgPj0gMC41KSkge1xuXHRcdFx0XHRcdFx0ciA9IDEgLSByO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocG93ID09PSAxKSB7XG5cdFx0XHRcdFx0XHRyICo9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDIpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSA0KSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogciAqIHI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSAvIGR1cmF0aW9uIDwgMC41KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gciAvIDI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gKHIgLyAyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdGlmIChwcmV2VGltZSA9PT0gdGhpcy5fdGltZSAmJiAhZm9yY2UgJiYgcHJldkN5Y2xlID09PSB0aGlzLl9jeWNsZSkge1xuXHRcdFx0XHRpZiAocHJldlRvdGFsVGltZSAhPT0gdGhpcy5fdG90YWxUaW1lKSBpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHsgLy9zbyB0aGF0IG9uVXBkYXRlIGZpcmVzIGV2ZW4gZHVyaW5nIHRoZSByZXBlYXREZWxheSAtIGFzIGxvbmcgYXMgdGhlIHRvdGFsVGltZSBjaGFuZ2VkLCB3ZSBzaG91bGQgdHJpZ2dlciBvblVwZGF0ZS5cblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdCgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQgfHwgdGhpcy5fZ2MpIHsgLy9pbW1lZGlhdGVSZW5kZXIgdHdlZW5zIHR5cGljYWxseSB3b24ndCBpbml0aWFsaXplIHVudGlsIHRoZSBwbGF5aGVhZCBhZHZhbmNlcyAoX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDApIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IG92ZXJ3cml0aW5nIG9jY3VycyBwcm9wZXJseS4gQWxzbywgaWYgYWxsIG9mIHRoZSB0d2VlbmluZyBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiAod2hpY2ggd291bGQgY2F1c2UgX2djIHRvIGJlIHRydWUsIGFzIHNldCBpbiBfaW5pdCgpKSwgd2Ugc2hvdWxkbid0IGNvbnRpbnVlIG90aGVyd2lzZSBhbiBvblN0YXJ0IGNhbGxiYWNrIGNvdWxkIGJlIGNhbGxlZCBmb3IgZXhhbXBsZS5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWZvcmNlICYmIHRoaXMuX2ZpcnN0UFQgJiYgKCh0aGlzLnZhcnMubGF6eSAhPT0gZmFsc2UgJiYgdGhpcy5fZHVyYXRpb24pIHx8ICh0aGlzLnZhcnMubGF6eSAmJiAhdGhpcy5fZHVyYXRpb24pKSkgeyAvL3dlIHN0aWNrIGl0IGluIHRoZSBxdWV1ZSBmb3IgcmVuZGVyaW5nIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgdGljayAtIHRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gYmVjYXVzZSBicm93c2VycyBpbnZhbGlkYXRlIHN0eWxlcyBhbmQgZm9yY2UgYSByZWNhbGN1bGF0aW9uIGlmIHlvdSByZWFkLCB3cml0ZSwgYW5kIHRoZW4gcmVhZCBzdHlsZSBkYXRhIChzbyBpdCdzIGJldHRlciB0byByZWFkL3JlYWQvcmVhZC93cml0ZS93cml0ZS93cml0ZSB0aGFuIHJlYWQvd3JpdGUvcmVhZC93cml0ZS9yZWFkL3dyaXRlKS4gVGhlIGRvd24gc2lkZSwgb2YgY291cnNlLCBpcyB0aGF0IHVzdWFsbHkgeW91IFdBTlQgdGhpbmdzIHRvIHJlbmRlciBpbW1lZGlhdGVseSBiZWNhdXNlIHlvdSBtYXkgaGF2ZSBjb2RlIHJ1bm5pbmcgcmlnaHQgYWZ0ZXIgdGhhdCB3aGljaCBkZXBlbmRzIG9uIHRoZSBjaGFuZ2UuIExpa2UgaW1hZ2luZSBydW5uaW5nIFR3ZWVuTGl0ZS5zZXQoLi4uKSBhbmQgdGhlbiBpbW1lZGlhdGVseSBhZnRlciB0aGF0LCBjcmVhdGluZyBhIG5vdGhlciB0d2VlbiB0aGF0IGFuaW1hdGVzIHRoZSBzYW1lIHByb3BlcnR5IHRvIGFub3RoZXIgdmFsdWU7IHRoZSBzdGFydGluZyB2YWx1ZXMgb2YgdGhhdCAybmQgdHdlZW4gd291bGRuJ3QgYmUgYWNjdXJhdGUgaWYgbGF6eSBpcyB0cnVlLlxuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBwcmV2VGltZTtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSBwcmV2VG90YWxUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcHJldlJhd1ByZXZUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gcHJldkN5Y2xlO1xuXHRcdFx0XHRcdFR3ZWVuTGl0ZUludGVybmFscy5sYXp5VHdlZW5zLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0dGhpcy5fbGF6eSA9IFt0aW1lLCBzdXBwcmVzc0V2ZW50c107XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vX2Vhc2UgaXMgaW5pdGlhbGx5IHNldCB0byBkZWZhdWx0RWFzZSwgc28gbm93IHRoYXQgaW5pdCgpIGhhcyBydW4sIF9lYXNlIGlzIHNldCBwcm9wZXJseSBhbmQgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgcmF0aW8uIE92ZXJhbGwgdGhpcyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjb25kaXRpb25hbCBsb2dpYyBlYXJsaWVyIGluIHRoZSBtZXRob2QgdG8gYXZvaWQgaGF2aW5nIHRvIHNldCByYXRpbyB0d2ljZSBiZWNhdXNlIHdlIG9ubHkgaW5pdCgpIG9uY2UgYnV0IHJlbmRlclRpbWUoKSBnZXRzIGNhbGxlZCBWRVJZIGZyZXF1ZW50bHkuXG5cdFx0XHRcdGlmICh0aGlzLl90aW1lICYmICFpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc0NvbXBsZXRlICYmIHRoaXMuX2Vhc2UuX2NhbGNFbmQpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbygodGhpcy5fdGltZSA9PT0gMCkgPyAwIDogMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9sYXp5ICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90aW1lICE9PSBwcmV2VGltZSAmJiB0aW1lID49IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgYSB0d2VlbiAoYXMgb3Bwb3NlZCB0byB0aGUgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgdGhlIHRpbWVsaW5lIGlzIGZvcmNlZCB0byByZS1yZW5kZXIgYW5kIGFsaWduIGl0IHdpdGggdGhlIHByb3BlciB0aW1lL2ZyYW1lIG9uIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZS4gTWF5YmUgdGhlIHR3ZWVuIGFscmVhZHkgZmluaXNoZWQgYnV0IHRoZSB1c2VyIG1hbnVhbGx5IHJlLXJlbmRlcnMgaXQgYXMgaGFsZndheSBkb25lLlxuXHRcdFx0fVxuXHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgPT09IDApIHtcblx0XHRcdFx0aWYgKHRoaXMuX2luaXR0ZWQgPT09IDIgJiYgdGltZSA+IDApIHtcblx0XHRcdFx0XHQvL3RoaXMuaW52YWxpZGF0ZSgpO1xuXHRcdFx0XHRcdHRoaXMuX2luaXQoKTsgLy93aWxsIGp1c3QgYXBwbHkgb3ZlcndyaXRpbmcgc2luY2UgX2luaXR0ZWQgb2YgKDIpIG1lYW5zIGl0IHdhcyBhIGZyb20oKSB0d2VlbiB0aGF0IGhhZCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9zdGFydEF0KSB7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIl9kdW1teUdTXCI7IC8vaWYgbm8gY2FsbGJhY2sgaXMgZGVmaW5lZCwgdXNlIGEgZHVtbXkgdmFsdWUganVzdCBzbyB0aGF0IHRoZSBjb25kaXRpb24gYXQgdGhlIGVuZCBldmFsdWF0ZXMgYXMgdHJ1ZSBiZWNhdXNlIF9zdGFydEF0IHNob3VsZCByZW5kZXIgQUZURVIgdGhlIG5vcm1hbCByZW5kZXIgbG9vcCB3aGVuIHRoZSB0aW1lIGlzIG5lZ2F0aXZlLiBXZSBjb3VsZCBoYW5kbGUgdGhpcyBpbiBhIG1vcmUgaW50dWl0aXZlIHdheSwgb2YgY291cnNlLCBidXQgdGhlIHJlbmRlciBsb29wIGlzIHRoZSBNT1NUIGltcG9ydGFudCB0aGluZyB0byBvcHRpbWl6ZSwgc28gdGhpcyB0ZWNobmlxdWUgYWxsb3dzIHVzIHRvIGF2b2lkIGFkZGluZyBleHRyYSBjb25kaXRpb25hbCBsb2dpYyBpbiBhIGhpZ2gtZnJlcXVlbmN5IGFyZWEuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gMCB8fCBkdXJhdGlvbiA9PT0gMCkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25TdGFydFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucztcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwKSBpZiAodGhpcy5fc3RhcnRBdCAmJiB0aGlzLl9zdGFydFRpbWUpIHsgLy9pZiB0aGUgdHdlZW4gaXMgcG9zaXRpb25lZCBhdCB0aGUgVkVSWSBiZWdpbm5pbmcgKF9zdGFydFRpbWUgMCkgb2YgaXRzIHBhcmVudCB0aW1lbGluZSwgaXQncyBpbGxlZ2FsIGZvciB0aGUgcGxheWhlYWQgdG8gZ28gYmFjayBmdXJ0aGVyLCBzbyB3ZSBzaG91bGQgbm90IHJlbmRlciB0aGUgcmVjb3JkZWQgc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAodGhpcy5fdG90YWxUaW1lICE9PSBwcmV2VG90YWxUaW1lIHx8IGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2N5Y2xlICE9PSBwcmV2Q3ljbGUpIGlmICghc3VwcHJlc3NFdmVudHMpIGlmICghdGhpcy5fZ2MpIGlmICh0aGlzLnZhcnMub25SZXBlYXQpIHtcblx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblJlcGVhdFwiKTtcblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9nYyB8fCBmb3JjZSkgeyAvL2NoZWNrIGdjIGJlY2F1c2UgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGtpbGwoKSBjb3VsZCBiZSBjYWxsZWQgaW4gYW4gb25VcGRhdGVcblx0XHRcdFx0aWYgKHRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQgJiYgIXRoaXMuX29uVXBkYXRlICYmIHRoaXMuX3N0YXJ0VGltZSkgeyAvL2lmIHRoZSB0d2VlbiBpcyBwb3NpdGlvbmVkIGF0IHRoZSBWRVJZIGJlZ2lubmluZyAoX3N0YXJ0VGltZSAwKSBvZiBpdHMgcGFyZW50IHRpbWVsaW5lLCBpdCdzIGlsbGVnYWwgZm9yIHRoZSBwbGF5aGVhZCB0byBnbyBiYWNrIGZ1cnRoZXIsIHNvIHdlIHNob3VsZCBub3QgcmVuZGVyIHRoZSByZWNvcmRlZCBzdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzICYmIHRoaXMudmFyc1tjYWxsYmFja10pIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiByYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0pIHsgLy90aGUgb25Db21wbGV0ZSBvciBvblJldmVyc2VDb21wbGV0ZSBjb3VsZCB0cmlnZ2VyIG1vdmVtZW50IG9mIHRoZSBwbGF5aGVhZCBhbmQgZm9yIHplcm8tZHVyYXRpb24gdHdlZW5zICh3aGljaCBtdXN0IGRpc2Nlcm4gZGlyZWN0aW9uKSB0aGF0IGxhbmQgZGlyZWN0bHkgYmFjayBvbiB0aGVpciBzdGFydCB0aW1lLCB3ZSBkb24ndCB3YW50IHRvIGZpcmUgYWdhaW4gb24gdGhlIG5leHQgcmVuZGVyLiBUaGluayBvZiBzZXZlcmFsIGFkZFBhdXNlKCkncyBpbiBhIHRpbWVsaW5lIHRoYXQgZm9yY2VzIHRoZSBwbGF5aGVhZCB0byBhIGNlcnRhaW4gc3BvdCwgYnV0IHdoYXQgaWYgaXQncyBhbHJlYWR5IHBhdXNlZCBhbmQgYW5vdGhlciB0d2VlbiBpcyB0d2VlbmluZyB0aGUgXCJ0aW1lXCIgb2YgdGhlIHRpbWVsaW5lPyBFYWNoIHRpbWUgaXQgbW92ZXMgW2ZvcndhcmRdIHBhc3QgdGhhdCBzcG90LCBpdCB3b3VsZCBtb3ZlIGJhY2ssIGFuZCBzaW5jZSBzdXBwcmVzc0V2ZW50cyBpcyB0cnVlLCBpdCdkIHJlc2V0IF9yYXdQcmV2VGltZSB0byBfdGlueU51bSBzbyB0aGF0IHdoZW4gaXQgYmVnaW5zIGFnYWluLCB0aGUgY2FsbGJhY2sgd291bGQgZmlyZSAoc28gdWx0aW1hdGVseSBpdCBjb3VsZCBib3VuY2UgYmFjayBhbmQgZm9ydGggZHVyaW5nIHRoYXQgdHdlZW4pLiBBZ2FpbiwgdGhpcyBpcyBhIHZlcnkgdW5jb21tb24gc2NlbmFyaW8sIGJ1dCBwb3NzaWJsZSBub25ldGhlbGVzcy5cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuLy8tLS0tIFNUQVRJQyBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcblx0XHRUd2Vlbk1heC50byA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5mcm9tID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgodGFyZ2V0LCBkdXJhdGlvbiwgdG9WYXJzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnN0YWdnZXJUbyA9IFR3ZWVuTWF4LmFsbFRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0c3RhZ2dlciA9IHN0YWdnZXIgfHwgMDtcblx0XHRcdHZhciBkZWxheSA9IDAsXG5cdFx0XHRcdGEgPSBbXSxcblx0XHRcdFx0ZmluYWxDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICh2YXJzLm9uQ29tcGxldGUpIHtcblx0XHRcdFx0XHRcdHZhcnMub25Db21wbGV0ZS5hcHBseSh2YXJzLm9uQ29tcGxldGVTY29wZSB8fCB0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvbkNvbXBsZXRlQWxsLmFwcGx5KG9uQ29tcGxldGVBbGxTY29wZSB8fCB2YXJzLmNhbGxiYWNrU2NvcGUgfHwgdGhpcywgb25Db21wbGV0ZUFsbFBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGN5Y2xlID0gdmFycy5jeWNsZSxcblx0XHRcdFx0ZnJvbUN5Y2xlID0gKHZhcnMuc3RhcnRBdCAmJiB2YXJzLnN0YXJ0QXQuY3ljbGUpLFxuXHRcdFx0XHRsLCBjb3B5LCBpLCBwO1xuXHRcdFx0aWYgKCFfaXNBcnJheSh0YXJnZXRzKSkge1xuXHRcdFx0XHRpZiAodHlwZW9mKHRhcmdldHMpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0dGFyZ2V0cyA9IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXRzKSB8fCB0YXJnZXRzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNTZWxlY3Rvcih0YXJnZXRzKSkge1xuXHRcdFx0XHRcdHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0cyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRhcmdldHMgPSB0YXJnZXRzIHx8IFtdO1xuXHRcdFx0aWYgKHN0YWdnZXIgPCAwKSB7XG5cdFx0XHRcdHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0cyk7XG5cdFx0XHRcdHRhcmdldHMucmV2ZXJzZSgpO1xuXHRcdFx0XHRzdGFnZ2VyICo9IC0xO1xuXHRcdFx0fVxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoIC0gMTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPD0gbDsgaSsrKSB7XG5cdFx0XHRcdGNvcHkgPSB7fTtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRjb3B5W3BdID0gdmFyc1twXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY3ljbGUpIHtcblx0XHRcdFx0XHRfYXBwbHlDeWNsZShjb3B5LCB0YXJnZXRzLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZnJvbUN5Y2xlKSB7XG5cdFx0XHRcdFx0ZnJvbUN5Y2xlID0gY29weS5zdGFydEF0ID0ge307XG5cdFx0XHRcdFx0Zm9yIChwIGluIHZhcnMuc3RhcnRBdCkge1xuXHRcdFx0XHRcdFx0ZnJvbUN5Y2xlW3BdID0gdmFycy5zdGFydEF0W3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfYXBwbHlDeWNsZShjb3B5LnN0YXJ0QXQsIHRhcmdldHMsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvcHkuZGVsYXkgPSBkZWxheSArIChjb3B5LmRlbGF5IHx8IDApO1xuXHRcdFx0XHRpZiAoaSA9PT0gbCAmJiBvbkNvbXBsZXRlQWxsKSB7XG5cdFx0XHRcdFx0Y29weS5vbkNvbXBsZXRlID0gZmluYWxDb21wbGV0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhW2ldID0gbmV3IFR3ZWVuTWF4KHRhcmdldHNbaV0sIGR1cmF0aW9uLCBjb3B5KTtcblx0XHRcdFx0ZGVsYXkgKz0gc3RhZ2dlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc3RhZ2dlckZyb20gPSBUd2Vlbk1heC5hbGxGcm9tID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIFR3ZWVuTWF4LnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnN0YWdnZXJGcm9tVG8gPSBUd2Vlbk1heC5hbGxGcm9tVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gVHdlZW5NYXguc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB0b1ZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblx0XHRcdFx0XG5cdFx0VHdlZW5NYXguZGVsYXllZENhbGwgPSBmdW5jdGlvbihkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUsIHVzZUZyYW1lcykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heChjYWxsYmFjaywgMCwge2RlbGF5OmRlbGF5LCBvbkNvbXBsZXRlOmNhbGxiYWNrLCBvbkNvbXBsZXRlUGFyYW1zOnBhcmFtcywgY2FsbGJhY2tTY29wZTpzY29wZSwgb25SZXZlcnNlQ29tcGxldGU6Y2FsbGJhY2ssIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOnBhcmFtcywgaW1tZWRpYXRlUmVuZGVyOmZhbHNlLCB1c2VGcmFtZXM6dXNlRnJhbWVzLCBvdmVyd3JpdGU6MH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgMCwgdmFycyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5pc1R3ZWVuaW5nID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gKFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXQsIHRydWUpLmxlbmd0aCA+IDApO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIF9nZXRDaGlsZHJlbk9mID0gZnVuY3Rpb24odGltZWxpbmUsIGluY2x1ZGVUaW1lbGluZXMpIHtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRcdHR3ZWVuID0gdGltZWxpbmUuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRpZiAodHdlZW4gaW5zdGFuY2VvZiBUd2VlbkxpdGUpIHtcblx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChpbmNsdWRlVGltZWxpbmVzKSB7XG5cdFx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhID0gYS5jb25jYXQoX2dldENoaWxkcmVuT2YodHdlZW4sIGluY2x1ZGVUaW1lbGluZXMpKTtcblx0XHRcdFx0XHRcdGNudCA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fSwgXG5cdFx0XHRnZXRBbGxUd2VlbnMgPSBUd2Vlbk1heC5nZXRBbGxUd2VlbnMgPSBmdW5jdGlvbihpbmNsdWRlVGltZWxpbmVzKSB7XG5cdFx0XHRcdHJldHVybiBfZ2V0Q2hpbGRyZW5PZihBbmltYXRpb24uX3Jvb3RUaW1lbGluZSwgaW5jbHVkZVRpbWVsaW5lcykuY29uY2F0KCBfZ2V0Q2hpbGRyZW5PZihBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSwgaW5jbHVkZVRpbWVsaW5lcykgKTtcblx0XHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXgua2lsbEFsbCA9IGZ1bmN0aW9uKGNvbXBsZXRlLCB0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHRpZiAodHdlZW5zID09IG51bGwpIHtcblx0XHRcdFx0dHdlZW5zID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChkZWxheWVkQ2FsbHMgPT0gbnVsbCkge1xuXHRcdFx0XHRkZWxheWVkQ2FsbHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBnZXRBbGxUd2VlbnMoKHRpbWVsaW5lcyAhPSBmYWxzZSkpLFxuXHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdGFsbFRydWUgPSAodHdlZW5zICYmIGRlbGF5ZWRDYWxscyAmJiB0aW1lbGluZXMpLFxuXHRcdFx0XHRpc0RDLCB0d2VlbiwgaTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dHdlZW4gPSBhW2ldO1xuXHRcdFx0XHRpZiAoYWxsVHJ1ZSB8fCAodHdlZW4gaW5zdGFuY2VvZiBTaW1wbGVUaW1lbGluZSkgfHwgKChpc0RDID0gKHR3ZWVuLnRhcmdldCA9PT0gdHdlZW4udmFycy5vbkNvbXBsZXRlKSkgJiYgZGVsYXllZENhbGxzKSB8fCAodHdlZW5zICYmICFpc0RDKSkge1xuXHRcdFx0XHRcdGlmIChjb21wbGV0ZSkge1xuXHRcdFx0XHRcdFx0dHdlZW4udG90YWxUaW1lKHR3ZWVuLl9yZXZlcnNlZCA/IDAgOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXgua2lsbENoaWxkVHdlZW5zT2YgPSBmdW5jdGlvbihwYXJlbnQsIGNvbXBsZXRlKSB7XG5cdFx0XHRpZiAocGFyZW50ID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gVHdlZW5MaXRlSW50ZXJuYWxzLnR3ZWVuTG9va3VwLFxuXHRcdFx0XHRhLCBjdXJQYXJlbnQsIHAsIGksIGw7XG5cdFx0XHRpZiAodHlwZW9mKHBhcmVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0cGFyZW50ID0gVHdlZW5MaXRlLnNlbGVjdG9yKHBhcmVudCkgfHwgcGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9pc1NlbGVjdG9yKHBhcmVudCkpIHtcblx0XHRcdFx0cGFyZW50ID0gX3NsaWNlKHBhcmVudCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX2lzQXJyYXkocGFyZW50KSkge1xuXHRcdFx0XHRpID0gcGFyZW50Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0VHdlZW5NYXgua2lsbENoaWxkVHdlZW5zT2YocGFyZW50W2ldLCBjb21wbGV0ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0YSA9IFtdO1xuXHRcdFx0Zm9yIChwIGluIHRsKSB7XG5cdFx0XHRcdGN1clBhcmVudCA9IHRsW3BdLnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdFx0XHR3aGlsZSAoY3VyUGFyZW50KSB7XG5cdFx0XHRcdFx0aWYgKGN1clBhcmVudCA9PT0gcGFyZW50KSB7XG5cdFx0XHRcdFx0XHRhID0gYS5jb25jYXQodGxbcF0udHdlZW5zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VyUGFyZW50ID0gY3VyUGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGwgPSBhLmxlbmd0aDtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0YVtpXS50b3RhbFRpbWUoYVtpXS50b3RhbER1cmF0aW9uKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFbaV0uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIF9jaGFuZ2VQYXVzZSA9IGZ1bmN0aW9uKHBhdXNlLCB0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHR0d2VlbnMgPSAodHdlZW5zICE9PSBmYWxzZSk7XG5cdFx0XHRkZWxheWVkQ2FsbHMgPSAoZGVsYXllZENhbGxzICE9PSBmYWxzZSk7XG5cdFx0XHR0aW1lbGluZXMgPSAodGltZWxpbmVzICE9PSBmYWxzZSk7XG5cdFx0XHR2YXIgYSA9IGdldEFsbFR3ZWVucyh0aW1lbGluZXMpLFxuXHRcdFx0XHRhbGxUcnVlID0gKHR3ZWVucyAmJiBkZWxheWVkQ2FsbHMgJiYgdGltZWxpbmVzKSxcblx0XHRcdFx0aSA9IGEubGVuZ3RoLFxuXHRcdFx0XHRpc0RDLCB0d2Vlbjtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHR0d2VlbiA9IGFbaV07XG5cdFx0XHRcdGlmIChhbGxUcnVlIHx8ICh0d2VlbiBpbnN0YW5jZW9mIFNpbXBsZVRpbWVsaW5lKSB8fCAoKGlzREMgPSAodHdlZW4udGFyZ2V0ID09PSB0d2Vlbi52YXJzLm9uQ29tcGxldGUpKSAmJiBkZWxheWVkQ2FsbHMpIHx8ICh0d2VlbnMgJiYgIWlzREMpKSB7XG5cdFx0XHRcdFx0dHdlZW4ucGF1c2VkKHBhdXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXgucGF1c2VBbGwgPSBmdW5jdGlvbih0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHRfY2hhbmdlUGF1c2UodHJ1ZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5yZXN1bWVBbGwgPSBmdW5jdGlvbih0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHRfY2hhbmdlUGF1c2UoZmFsc2UsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpO1xuXHRcdH07XG5cblx0XHRUd2Vlbk1heC5nbG9iYWxUaW1lU2NhbGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIHRsID0gQW5pbWF0aW9uLl9yb290VGltZWxpbmUsXG5cdFx0XHRcdHQgPSBUd2VlbkxpdGUudGlja2VyLnRpbWU7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRsLl90aW1lU2NhbGU7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHZhbHVlIHx8IF90aW55TnVtOyAvL2Nhbid0IGFsbG93IHplcm8gYmVjYXVzZSBpdCdsbCB0aHJvdyB0aGUgbWF0aCBvZmZcblx0XHRcdHRsLl9zdGFydFRpbWUgPSB0IC0gKCh0IC0gdGwuX3N0YXJ0VGltZSkgKiB0bC5fdGltZVNjYWxlIC8gdmFsdWUpO1xuXHRcdFx0dGwgPSBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZTtcblx0XHRcdHQgPSBUd2VlbkxpdGUudGlja2VyLmZyYW1lO1xuXHRcdFx0dGwuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0bC5fc3RhcnRUaW1lKSAqIHRsLl90aW1lU2NhbGUgLyB2YWx1ZSk7XG5cdFx0XHR0bC5fdGltZVNjYWxlID0gQW5pbWF0aW9uLl9yb290VGltZWxpbmUuX3RpbWVTY2FsZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cdFx0XG5cdFxuLy8tLS0tIEdFVFRFUlMgLyBTRVRURVJTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcblx0XHRwLnByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RpbWUgLyB0aGlzLmR1cmF0aW9uKCkgOiB0aGlzLnRvdGFsVGltZSggdGhpcy5kdXJhdGlvbigpICogKCh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSA/IDEgLSB2YWx1ZSA6IHZhbHVlKSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSksIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAudG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90b3RhbFRpbWUgLyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSA+IHRoaXMuX2R1cmF0aW9uKSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSA9ICh0aGlzLl9kdXJhdGlvbiAtIHZhbHVlKSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3JlcGVhdCAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSArPSB0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247IC8vZG9uJ3Qgc2V0IF9kaXJ0eSA9IGZhbHNlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgcmVwZWF0cyB0aGF0IGhhdmVuJ3QgYmVlbiBmYWN0b3JlZCBpbnRvIHRoZSBfdG90YWxEdXJhdGlvbiB5ZXQuIE90aGVyd2lzZSwgaWYgeW91IGNyZWF0ZSBhIHJlcGVhdGVkIFR3ZWVuTWF4IGFuZCB0aGVuIGltbWVkaWF0ZWx5IGNoZWNrIGl0cyBkdXJhdGlvbigpLCBpdCB3b3VsZCBjYWNoZSB0aGUgdmFsdWUgYW5kIHRoZSB0b3RhbER1cmF0aW9uIHdvdWxkIG5vdCBiZSBjb3JyZWN0LCB0aHVzIHJlcGVhdHMgd291bGRuJ3QgdGFrZSBlZmZlY3QuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQW5pbWF0aW9uLnByb3RvdHlwZS5kdXJhdGlvbi5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHQvL2luc3RlYWQgb2YgSW5maW5pdHksIHdlIHVzZSA5OTk5OTk5OTk5OTkgc28gdGhhdCB3ZSBjYW4gYWNjb21tb2RhdGUgcmV2ZXJzZXNcblx0XHRcdFx0XHR0aGlzLl90b3RhbER1cmF0aW9uID0gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gOTk5OTk5OTk5OTk5IDogdGhpcy5fZHVyYXRpb24gKiAodGhpcy5fcmVwZWF0ICsgMSkgKyAodGhpcy5fcmVwZWF0RGVsYXkgKiB0aGlzLl9yZXBlYXQpO1xuXHRcdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gdGhpcyA6IHRoaXMuZHVyYXRpb24oICh2YWx1ZSAtICh0aGlzLl9yZXBlYXQgKiB0aGlzLl9yZXBlYXREZWxheSkpIC8gKHRoaXMuX3JlcGVhdCArIDEpICk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnJlcGVhdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcGVhdDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnlveW8gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl95b3lvO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5feW95byA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRyZXR1cm4gVHdlZW5NYXg7XG5cdFx0XG5cdH0sIHRydWUpO1xuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUaW1lbGluZUxpdGVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUaW1lbGluZUxpdGVcIiwgW1wiY29yZS5BbmltYXRpb25cIixcImNvcmUuU2ltcGxlVGltZWxpbmVcIixcIlR3ZWVuTGl0ZVwiXSwgZnVuY3Rpb24oQW5pbWF0aW9uLCBTaW1wbGVUaW1lbGluZSwgVHdlZW5MaXRlKSB7XG5cblx0XHR2YXIgVGltZWxpbmVMaXRlID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0XHRTaW1wbGVUaW1lbGluZS5jYWxsKHRoaXMsIHZhcnMpO1xuXHRcdFx0XHR0aGlzLl9sYWJlbHMgPSB7fTtcblx0XHRcdFx0dGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSAodGhpcy52YXJzLmF1dG9SZW1vdmVDaGlsZHJlbiA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSAodGhpcy52YXJzLnNtb290aENoaWxkVGltaW5nID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5fc29ydENoaWxkcmVuID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGUgPSB0aGlzLnZhcnMub25VcGRhdGU7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YXJzLFxuXHRcdFx0XHRcdHZhbCwgcDtcblx0XHRcdFx0Zm9yIChwIGluIHYpIHtcblx0XHRcdFx0XHR2YWwgPSB2W3BdO1xuXHRcdFx0XHRcdGlmIChfaXNBcnJheSh2YWwpKSBpZiAodmFsLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHZbcF0gPSB0aGlzLl9zd2FwU2VsZkluUGFyYW1zKHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNBcnJheSh2LnR3ZWVucykpIHtcblx0XHRcdFx0XHR0aGlzLmFkZCh2LnR3ZWVucywgMCwgdi5hbGlnbiwgdi5zdGFnZ2VyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMsXG5cdFx0XHRfaW50ZXJuYWxzID0gVGltZWxpbmVMaXRlLl9pbnRlcm5hbHMgPSB7fSxcblx0XHRcdF9pc1NlbGVjdG9yID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzU2VsZWN0b3IsXG5cdFx0XHRfaXNBcnJheSA9IFR3ZWVuTGl0ZUludGVybmFscy5pc0FycmF5LFxuXHRcdFx0X2xhenlUd2VlbnMgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVR3ZWVucyxcblx0XHRcdF9sYXp5UmVuZGVyID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlSZW5kZXIsXG5cdFx0XHRfZ2xvYmFscyA9IF9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLFxuXHRcdFx0X2NvcHkgPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRcdHZhciBjb3B5ID0ge30sIHA7XG5cdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0Y29weVtwXSA9IHZhcnNbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0XHR9LFxuXHRcdFx0X2FwcGx5Q3ljbGUgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXRzLCBpKSB7XG5cdFx0XHRcdHZhciBhbHQgPSB2YXJzLmN5Y2xlLFxuXHRcdFx0XHRcdHAsIHZhbDtcblx0XHRcdFx0Zm9yIChwIGluIGFsdCkge1xuXHRcdFx0XHRcdHZhbCA9IGFsdFtwXTtcblx0XHRcdFx0XHR2YXJzW3BdID0gKHR5cGVvZih2YWwpID09PSBcImZ1bmN0aW9uXCIpID8gdmFsLmNhbGwodGFyZ2V0c1tpXSwgaSkgOiB2YWxbaSAlIHZhbC5sZW5ndGhdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSB2YXJzLmN5Y2xlO1xuXHRcdFx0fSxcblx0XHRcdF9wYXVzZUNhbGxiYWNrID0gX2ludGVybmFscy5wYXVzZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fSxcblx0XHRcdF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgW10uc2xpY2UgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0dmFyIGIgPSBbXSxcblx0XHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSAhPT0gbDsgYi5wdXNoKGFbaSsrXSkpO1xuXHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdH0sXG5cdFx0XHRwID0gVGltZWxpbmVMaXRlLnByb3RvdHlwZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpO1xuXG5cdFx0VGltZWxpbmVMaXRlLnZlcnNpb24gPSBcIjEuMTguNFwiO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUaW1lbGluZUxpdGU7XG5cdFx0cC5raWxsKCkuX2djID0gcC5fZm9yY2luZ1BsYXloZWFkID0gcC5faGFzUGF1c2UgPSBmYWxzZTtcblxuXHRcdC8qIG1pZ2h0IHVzZSBsYXRlci4uLlxuXHRcdC8vdHJhbnNsYXRlcyBhIGxvY2FsIHRpbWUgaW5zaWRlIGFuIGFuaW1hdGlvbiB0byB0aGUgY29ycmVzcG9uZGluZyB0aW1lIG9uIHRoZSByb290L2dsb2JhbCB0aW1lbGluZSwgZmFjdG9yaW5nIGluIGFsbCBuZXN0aW5nIGFuZCB0aW1lU2NhbGVzLlxuXHRcdGZ1bmN0aW9uIGxvY2FsVG9HbG9iYWwodGltZSwgYW5pbWF0aW9uKSB7XG5cdFx0XHR3aGlsZSAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHRpbWUgPSAodGltZSAvIGFuaW1hdGlvbi5fdGltZVNjYWxlKSArIGFuaW1hdGlvbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGltZTtcblx0XHR9XG5cblx0XHQvL3RyYW5zbGF0ZXMgdGhlIHN1cHBsaWVkIHRpbWUgb24gdGhlIHJvb3QvZ2xvYmFsIHRpbWVsaW5lIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbG9jYWwgdGltZSBpbnNpZGUgYSBwYXJ0aWN1bGFyIGFuaW1hdGlvbiwgZmFjdG9yaW5nIGluIGFsbCBuZXN0aW5nIGFuZCB0aW1lU2NhbGVzXG5cdFx0ZnVuY3Rpb24gZ2xvYmFsVG9Mb2NhbCh0aW1lLCBhbmltYXRpb24pIHtcblx0XHRcdHZhciBzY2FsZSA9IDE7XG5cdFx0XHR0aW1lIC09IGxvY2FsVG9HbG9iYWwoMCwgYW5pbWF0aW9uKTtcblx0XHRcdHdoaWxlIChhbmltYXRpb24pIHtcblx0XHRcdFx0c2NhbGUgKj0gYW5pbWF0aW9uLl90aW1lU2NhbGU7XG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aW1lICogc2NhbGU7XG5cdFx0fVxuXHRcdCovXG5cblx0XHRwLnRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdHZhciBFbmdpbmUgPSAodmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZTtcblx0XHRcdHJldHVybiBkdXJhdGlvbiA/IHRoaXMuYWRkKCBuZXcgRW5naW5lKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpLCBwb3NpdGlvbikgOiB0aGlzLnNldCh0YXJnZXQsIHZhcnMsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5mcm9tID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggKCh2YXJzLnJlcGVhdCAmJiBfZ2xvYmFscy5Ud2Vlbk1heCkgfHwgVHdlZW5MaXRlKS5mcm9tKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgcG9zaXRpb24pIHtcblx0XHRcdHZhciBFbmdpbmUgPSAodG9WYXJzLnJlcGVhdCAmJiBfZ2xvYmFscy5Ud2Vlbk1heCkgfHwgVHdlZW5MaXRlO1xuXHRcdFx0cmV0dXJuIGR1cmF0aW9uID8gdGhpcy5hZGQoIEVuZ2luZS5mcm9tVG8odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycyksIHBvc2l0aW9uKSA6IHRoaXMuc2V0KHRhcmdldCwgdG9WYXJzLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlclRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHZhciB0bCA9IG5ldyBUaW1lbGluZUxpdGUoe29uQ29tcGxldGU6b25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZVBhcmFtczpvbkNvbXBsZXRlQWxsUGFyYW1zLCBjYWxsYmFja1Njb3BlOm9uQ29tcGxldGVBbGxTY29wZSwgc21vb3RoQ2hpbGRUaW1pbmc6dGhpcy5zbW9vdGhDaGlsZFRpbWluZ30pLFxuXHRcdFx0XHRjeWNsZSA9IHZhcnMuY3ljbGUsXG5cdFx0XHRcdGNvcHksIGk7XG5cdFx0XHRpZiAodHlwZW9mKHRhcmdldHMpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHRhcmdldHMgPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0cykgfHwgdGFyZ2V0cztcblx0XHRcdH1cblx0XHRcdHRhcmdldHMgPSB0YXJnZXRzIHx8IFtdO1xuXHRcdFx0aWYgKF9pc1NlbGVjdG9yKHRhcmdldHMpKSB7IC8vc2Vuc2VzIGlmIHRoZSB0YXJnZXRzIG9iamVjdCBpcyBhIHNlbGVjdG9yLiBJZiBpdCBpcywgd2Ugc2hvdWxkIHRyYW5zbGF0ZSBpdCBpbnRvIGFuIGFycmF5LlxuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0fVxuXHRcdFx0c3RhZ2dlciA9IHN0YWdnZXIgfHwgMDtcblx0XHRcdGlmIChzdGFnZ2VyIDwgMCkge1xuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR0YXJnZXRzLnJldmVyc2UoKTtcblx0XHRcdFx0c3RhZ2dlciAqPSAtMTtcblx0XHRcdH1cblx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvcHkgPSBfY29weSh2YXJzKTtcblx0XHRcdFx0aWYgKGNvcHkuc3RhcnRBdCkge1xuXHRcdFx0XHRcdGNvcHkuc3RhcnRBdCA9IF9jb3B5KGNvcHkuc3RhcnRBdCk7XG5cdFx0XHRcdFx0aWYgKGNvcHkuc3RhcnRBdC5jeWNsZSkge1xuXHRcdFx0XHRcdFx0X2FwcGx5Q3ljbGUoY29weS5zdGFydEF0LCB0YXJnZXRzLCBpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGN5Y2xlKSB7XG5cdFx0XHRcdFx0X2FwcGx5Q3ljbGUoY29weSwgdGFyZ2V0cywgaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGwudG8odGFyZ2V0c1tpXSwgZHVyYXRpb24sIGNvcHksIGkgKiBzdGFnZ2VyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmFkZCh0bCwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnN0YWdnZXJGcm9tID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlckZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblxuXHRcdHAuY2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlLCBwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uLCAwLCB0cnVlKTtcblx0XHRcdGlmICh2YXJzLmltbWVkaWF0ZVJlbmRlciA9PSBudWxsKSB7XG5cdFx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHBvc2l0aW9uID09PSB0aGlzLl90aW1lICYmICF0aGlzLl9wYXVzZWQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCBuZXcgVHdlZW5MaXRlKHRhcmdldCwgMCwgdmFycyksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0VGltZWxpbmVMaXRlLmV4cG9ydFJvb3QgPSBmdW5jdGlvbih2YXJzLCBpZ25vcmVEZWxheWVkQ2FsbHMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0aWYgKHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPT0gbnVsbCkge1xuXHRcdFx0XHR2YXJzLnNtb290aENoaWxkVGltaW5nID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHZhciB0bCA9IG5ldyBUaW1lbGluZUxpdGUodmFycyksXG5cdFx0XHRcdHJvb3QgPSB0bC5fdGltZWxpbmUsXG5cdFx0XHRcdHR3ZWVuLCBuZXh0O1xuXHRcdFx0aWYgKGlnbm9yZURlbGF5ZWRDYWxscyA9PSBudWxsKSB7XG5cdFx0XHRcdGlnbm9yZURlbGF5ZWRDYWxscyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyb290Ll9yZW1vdmUodGwsIHRydWUpO1xuXHRcdFx0dGwuX3N0YXJ0VGltZSA9IDA7XG5cdFx0XHR0bC5fcmF3UHJldlRpbWUgPSB0bC5fdGltZSA9IHRsLl90b3RhbFRpbWUgPSByb290Ll90aW1lO1xuXHRcdFx0dHdlZW4gPSByb290Ll9maXJzdDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdGlmICghaWdub3JlRGVsYXllZENhbGxzIHx8ICEodHdlZW4gaW5zdGFuY2VvZiBUd2VlbkxpdGUgJiYgdHdlZW4udGFyZ2V0ID09PSB0d2Vlbi52YXJzLm9uQ29tcGxldGUpKSB7XG5cdFx0XHRcdFx0dGwuYWRkKHR3ZWVuLCB0d2Vlbi5fc3RhcnRUaW1lIC0gdHdlZW4uX2RlbGF5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0XHRyb290LmFkZCh0bCwgMCk7XG5cdFx0XHRyZXR1cm4gdGw7XG5cdFx0fTtcblxuXHRcdHAuYWRkID0gZnVuY3Rpb24odmFsdWUsIHBvc2l0aW9uLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0dmFyIGN1clRpbWUsIGwsIGksIGNoaWxkLCB0bCwgYmVmb3JlUmF3VGltZTtcblx0XHRcdGlmICh0eXBlb2YocG9zaXRpb24pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbiwgMCwgdHJ1ZSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBbmltYXRpb24pKSB7XG5cdFx0XHRcdGlmICgodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgfHwgKHZhbHVlICYmIHZhbHVlLnB1c2ggJiYgX2lzQXJyYXkodmFsdWUpKSkge1xuXHRcdFx0XHRcdGFsaWduID0gYWxpZ24gfHwgXCJub3JtYWxcIjtcblx0XHRcdFx0XHRzdGFnZ2VyID0gc3RhZ2dlciB8fCAwO1xuXHRcdFx0XHRcdGN1clRpbWUgPSBwb3NpdGlvbjtcblx0XHRcdFx0XHRsID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChfaXNBcnJheShjaGlsZCA9IHZhbHVlW2ldKSkge1xuXHRcdFx0XHRcdFx0XHRjaGlsZCA9IG5ldyBUaW1lbGluZUxpdGUoe3R3ZWVuczpjaGlsZH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5hZGQoY2hpbGQsIGN1clRpbWUpO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZihjaGlsZCkgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mKGNoaWxkKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhbGlnbiA9PT0gXCJzZXF1ZW5jZVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3VyVGltZSA9IGNoaWxkLl9zdGFydFRpbWUgKyAoY2hpbGQudG90YWxEdXJhdGlvbigpIC8gY2hpbGQuX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYWxpZ24gPT09IFwic3RhcnRcIikge1xuXHRcdFx0XHRcdFx0XHRcdGNoaWxkLl9zdGFydFRpbWUgLT0gY2hpbGQuZGVsYXkoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3VyVGltZSArPSBzdGFnZ2VyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkTGFiZWwodmFsdWUsIHBvc2l0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3coXCJDYW5ub3QgYWRkIFwiICsgdmFsdWUgKyBcIiBpbnRvIHRoZSB0aW1lbGluZTsgaXQgaXMgbm90IGEgdHdlZW4sIHRpbWVsaW5lLCBmdW5jdGlvbiwgb3Igc3RyaW5nLlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgdmFsdWUsIHBvc2l0aW9uKTtcblxuXHRcdFx0Ly9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cdFx0XHRpZiAodGhpcy5fZ2MgfHwgdGhpcy5fdGltZSA9PT0gdGhpcy5fZHVyYXRpb24pIGlmICghdGhpcy5fcGF1c2VkKSBpZiAodGhpcy5fZHVyYXRpb24gPCB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0Ly9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3JzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZC4uLlxuXHRcdFx0XHR0bCA9IHRoaXM7XG5cdFx0XHRcdGJlZm9yZVJhd1RpbWUgPSAodGwucmF3VGltZSgpID4gdmFsdWUuX3N0YXJ0VGltZSk7IC8vaWYgdGhlIHR3ZWVuIGlzIHBsYWNlZCBvbiB0aGUgdGltZWxpbmUgc28gdGhhdCBpdCBzdGFydHMgQkVGT1JFIHRoZSBjdXJyZW50IHJhd1RpbWUsIHdlIHNob3VsZCBhbGlnbiB0aGUgcGxheWhlYWQgKG1vdmUgdGhlIHRpbWVsaW5lKS4gVGhpcyBpcyBiZWNhdXNlIHNvbWV0aW1lcyB1c2VycyB3aWxsIGNyZWF0ZSBhIHRpbWVsaW5lLCBsZXQgaXQgZmluaXNoLCBhbmQgbXVjaCBsYXRlciBhcHBlbmQgYSB0d2VlbiBhbmQgZXhwZWN0IGl0IHRvIHJ1biBpbnN0ZWFkIG9mIGp1bXBpbmcgdG8gaXRzIGVuZCBzdGF0ZS4gV2hpbGUgdGVjaG5pY2FsbHkgb25lIGNvdWxkIGFyZ3VlIHRoYXQgaXQgc2hvdWxkIGp1bXAgdG8gaXRzIGVuZCBzdGF0ZSwgdGhhdCdzIG5vdCB3aGF0IHVzZXJzIGludHVpdGl2ZWx5IGV4cGVjdC5cblx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdGlmIChiZWZvcmVSYXdUaW1lICYmIHRsLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdFx0dGwudG90YWxUaW1lKHRsLl90b3RhbFRpbWUsIHRydWUpOyAvL21vdmVzIHRoZSB0aW1lbGluZSAoc2hpZnRzIGl0cyBzdGFydFRpbWUpIGlmIG5lY2Vzc2FyeSwgYW5kIGFsc28gZW5hYmxlcyBpdC5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRsLl9nYykge1xuXHRcdFx0XHRcdFx0dGwuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5yZW1vdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZSh2YWx1ZSwgZmFsc2UpO1xuXHRcdFx0XHR2YXIgdGwgPSB2YWx1ZS5fdGltZWxpbmUgPSB2YWx1ZS52YXJzLnVzZUZyYW1lcyA/IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lIDogQW5pbWF0aW9uLl9yb290VGltZWxpbmU7IC8vbm93IHRoYXQgaXQncyByZW1vdmVkLCBkZWZhdWx0IGl0IHRvIHRoZSByb290IHRpbWVsaW5lIHNvIHRoYXQgaWYgaXQgZ2V0cyBwbGF5ZWQgYWdhaW4sIGl0IGRvZXNuJ3QganVtcCBiYWNrIGludG8gdGhpcyB0aW1lbGluZS5cblx0XHRcdFx0dmFsdWUuX3N0YXJ0VGltZSA9ICh2YWx1ZS5fcGF1c2VkID8gdmFsdWUuX3BhdXNlVGltZSA6IHRsLl90aW1lKSAtICgoIXZhbHVlLl9yZXZlcnNlZCA/IHZhbHVlLl90b3RhbFRpbWUgOiB2YWx1ZS50b3RhbER1cmF0aW9uKCkgLSB2YWx1ZS5fdG90YWxUaW1lKSAvIHZhbHVlLl90aW1lU2NhbGUpOyAvL2Vuc3VyZSB0aGF0IGlmIGl0IGdldHMgcGxheWVkIGFnYWluLCB0aGUgdGltaW5nIGlzIGNvcnJlY3QuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5IHx8ICh2YWx1ZSAmJiB2YWx1ZS5wdXNoICYmIF9pc0FycmF5KHZhbHVlKSkpIHtcblx0XHRcdFx0dmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlKHZhbHVlW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYWJlbCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5raWxsKG51bGwsIHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC5fcmVtb3ZlID0gZnVuY3Rpb24odHdlZW4sIHNraXBEaXNhYmxlKSB7XG5cdFx0XHRTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuX3JlbW92ZS5jYWxsKHRoaXMsIHR3ZWVuLCBza2lwRGlzYWJsZSk7XG5cdFx0XHR2YXIgbGFzdCA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRpZiAoIWxhc3QpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPiBsYXN0Ll9zdGFydFRpbWUgKyBsYXN0Ll90b3RhbER1cmF0aW9uIC8gbGFzdC5fdGltZVNjYWxlKSB7XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLmR1cmF0aW9uKCk7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5hcHBlbmQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0T3JMYWJlbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHZhbHVlLCB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG51bGwsIG9mZnNldE9yTGFiZWwsIHRydWUsIHZhbHVlKSk7XG5cdFx0fTtcblxuXHRcdHAuaW5zZXJ0ID0gcC5pbnNlcnRNdWx0aXBsZSA9IGZ1bmN0aW9uKHZhbHVlLCBwb3NpdGlvbiwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh2YWx1ZSwgcG9zaXRpb24gfHwgMCwgYWxpZ24sIHN0YWdnZXIpO1xuXHRcdH07XG5cblx0XHRwLmFwcGVuZE11bHRpcGxlID0gZnVuY3Rpb24odHdlZW5zLCBvZmZzZXRPckxhYmVsLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHR3ZWVucywgdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLCBvZmZzZXRPckxhYmVsLCB0cnVlLCB0d2VlbnMpLCBhbGlnbiwgc3RhZ2dlcik7XG5cdFx0fTtcblxuXHRcdHAuYWRkTGFiZWwgPSBmdW5jdGlvbihsYWJlbCwgcG9zaXRpb24pIHtcblx0XHRcdHRoaXMuX2xhYmVsc1tsYWJlbF0gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmFkZFBhdXNlID0gZnVuY3Rpb24ocG9zaXRpb24sIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHR2YXIgdCA9IFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCBfcGF1c2VDYWxsYmFjaywgcGFyYW1zLCBzY29wZSB8fCB0aGlzKTtcblx0XHRcdHQudmFycy5vbkNvbXBsZXRlID0gdC52YXJzLm9uUmV2ZXJzZUNvbXBsZXRlID0gY2FsbGJhY2s7XG5cdFx0XHR0LmRhdGEgPSBcImlzUGF1c2VcIjtcblx0XHRcdHRoaXMuX2hhc1BhdXNlID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh0LCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xhYmVsc1tsYWJlbF07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5nZXRMYWJlbFRpbWUgPSBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0cmV0dXJuICh0aGlzLl9sYWJlbHNbbGFiZWxdICE9IG51bGwpID8gdGhpcy5fbGFiZWxzW2xhYmVsXSA6IC0xO1xuXHRcdH07XG5cblx0XHRwLl9wYXJzZVRpbWVPckxhYmVsID0gZnVuY3Rpb24odGltZU9yTGFiZWwsIG9mZnNldE9yTGFiZWwsIGFwcGVuZElmQWJzZW50LCBpZ25vcmUpIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0Ly9pZiB3ZSdyZSBhYm91dCB0byBhZGQgYSB0d2Vlbi90aW1lbGluZSAob3IgYW4gYXJyYXkgb2YgdGhlbSkgdGhhdCdzIGFscmVhZHkgYSBjaGlsZCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBzaG91bGQgcmVtb3ZlIGl0IGZpcnN0IHNvIHRoYXQgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgZHVyYXRpb24oKS5cblx0XHRcdGlmIChpZ25vcmUgaW5zdGFuY2VvZiBBbmltYXRpb24gJiYgaWdub3JlLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKGlnbm9yZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGlnbm9yZSAmJiAoKGlnbm9yZSBpbnN0YW5jZW9mIEFycmF5KSB8fCAoaWdub3JlLnB1c2ggJiYgX2lzQXJyYXkoaWdub3JlKSkpKSB7XG5cdFx0XHRcdGkgPSBpZ25vcmUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoaWdub3JlW2ldIGluc3RhbmNlb2YgQW5pbWF0aW9uICYmIGlnbm9yZVtpXS50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmUoaWdub3JlW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2Yob2Zmc2V0T3JMYWJlbCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwob2Zmc2V0T3JMYWJlbCwgKGFwcGVuZElmQWJzZW50ICYmIHR5cGVvZih0aW1lT3JMYWJlbCkgPT09IFwibnVtYmVyXCIgJiYgdGhpcy5fbGFiZWxzW29mZnNldE9yTGFiZWxdID09IG51bGwpID8gdGltZU9yTGFiZWwgLSB0aGlzLmR1cmF0aW9uKCkgOiAwLCBhcHBlbmRJZkFic2VudCk7XG5cdFx0XHR9XG5cdFx0XHRvZmZzZXRPckxhYmVsID0gb2Zmc2V0T3JMYWJlbCB8fCAwO1xuXHRcdFx0aWYgKHR5cGVvZih0aW1lT3JMYWJlbCkgPT09IFwic3RyaW5nXCIgJiYgKGlzTmFOKHRpbWVPckxhYmVsKSB8fCB0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdICE9IG51bGwpKSB7IC8vaWYgdGhlIHN0cmluZyBpcyBhIG51bWJlciBsaWtlIFwiMVwiLCBjaGVjayB0byBzZWUgaWYgdGhlcmUncyBhIGxhYmVsIHdpdGggdGhhdCBuYW1lLCBvdGhlcndpc2UgaW50ZXJwcmV0IGl0IGFzIGEgbnVtYmVyIChhYnNvbHV0ZSB2YWx1ZSkuXG5cdFx0XHRcdGkgPSB0aW1lT3JMYWJlbC5pbmRleE9mKFwiPVwiKTtcblx0XHRcdFx0aWYgKGkgPT09IC0xKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGFwcGVuZElmQWJzZW50ID8gKHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gPSB0aGlzLmR1cmF0aW9uKCkgKyBvZmZzZXRPckxhYmVsKSA6IG9mZnNldE9yTGFiZWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdICsgb2Zmc2V0T3JMYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRvZmZzZXRPckxhYmVsID0gcGFyc2VJbnQodGltZU9yTGFiZWwuY2hhckF0KGktMSkgKyBcIjFcIiwgMTApICogTnVtYmVyKHRpbWVPckxhYmVsLnN1YnN0cihpKzEpKTtcblx0XHRcdFx0dGltZU9yTGFiZWwgPSAoaSA+IDEpID8gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbCh0aW1lT3JMYWJlbC5zdWJzdHIoMCwgaS0xKSwgMCwgYXBwZW5kSWZBYnNlbnQpIDogdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0fSBlbHNlIGlmICh0aW1lT3JMYWJlbCA9PSBudWxsKSB7XG5cdFx0XHRcdHRpbWVPckxhYmVsID0gdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWJlcih0aW1lT3JMYWJlbCkgKyBvZmZzZXRPckxhYmVsO1xuXHRcdH07XG5cblx0XHRwLnNlZWsgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSgodHlwZW9mKHBvc2l0aW9uKSA9PT0gXCJudW1iZXJcIikgPyBwb3NpdGlvbiA6IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24pLCAoc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKSk7XG5cdFx0fTtcblxuXHRcdHAuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24ocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wbGF5KHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhdXNlKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG90YWxEdXIgPSAoIXRoaXMuX2RpcnR5KSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLnRvdGFsRHVyYXRpb24oKSxcblx0XHRcdFx0cHJldlRpbWUgPSB0aGlzLl90aW1lLFxuXHRcdFx0XHRwcmV2U3RhcnQgPSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0XHRcdHByZXZUaW1lU2NhbGUgPSB0aGlzLl90aW1lU2NhbGUsXG5cdFx0XHRcdHByZXZQYXVzZWQgPSB0aGlzLl9wYXVzZWQsXG5cdFx0XHRcdHR3ZWVuLCBpc0NvbXBsZXRlLCBuZXh0LCBjYWxsYmFjaywgaW50ZXJuYWxGb3JjZSwgcGF1c2VUd2VlbiwgY3VyVGltZTtcblx0XHRcdGlmICh0aW1lID49IHRvdGFsRHVyIC0gMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cy5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRvdGFsRHVyO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkKSBpZiAoIXRoaXMuX2hhc1BhdXNlZENoaWxkKCkpIHtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25Db21wbGV0ZVwiO1xuXHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSAhIXRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbjsgLy9vdGhlcndpc2UsIGlmIHRoZSBhbmltYXRpb24gaXMgdW5wYXVzZWQvYWN0aXZhdGVkIGFmdGVyIGl0J3MgYWxyZWFkeSBmaW5pc2hlZCwgaXQgZG9lc24ndCBnZXQgcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgdGltZWxpbmUuXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2R1cmF0aW9uID09PSAwKSBpZiAoKHRpbWUgPD0gMCAmJiB0aW1lID49IC0wLjAwMDAwMDEpIHx8IHRoaXMuX3Jhd1ByZXZUaW1lIDwgMCB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0pIGlmICh0aGlzLl9yYXdQcmV2VGltZSAhPT0gdGltZSAmJiB0aGlzLl9maXJzdCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fcmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAodGhpcy5fZHVyYXRpb24gfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHR0aW1lID0gdG90YWxEdXIgKyAwLjAwMDE7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgLSBzb21ldGltZXMgY2hpbGQgdHdlZW5zL3RpbWVsaW5lcyB3ZXJlIG5vdCBiZWluZyBmdWxseSBjb21wbGV0ZWQgKHRoZWlyIHByb2dyZXNzIG1pZ2h0IGJlIDAuOTk5OTk5OTk5OTk5OTk4IGluc3RlYWQgb2YgMSBiZWNhdXNlIHdoZW4gX3RpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lIGlzIHBlcmZvcm1lZCwgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHdvdWxkIHJldHVybiBhIHZhbHVlIHRoYXQgd2FzIFNMSUdIVExZIG9mZikuIFRyeSAoOTk5OTk5OTk5OTk5LjcgLSA5OTk5OTk5OTk5OTkpICogMSA9IDAuNjk5OTUxMTcxODc1IGluc3RlYWQgb2YgMC43LlxuXG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLCByb3VuZCBzdXBlciBzbWFsbCB2YWx1ZXMgdG8gMC5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdGlmIChwcmV2VGltZSAhPT0gMCB8fCAodGhpcy5fZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgIT09IF90aW55TnVtICYmICh0aGlzLl9yYXdQcmV2VGltZSA+IDAgfHwgKHRpbWUgPCAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID49IDApKSkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiAmJiB0aGlzLl9yZXZlcnNlZCkgeyAvL2Vuc3VyZXMgcHJvcGVyIEdDIGlmIGEgdGltZWxpbmUgaXMgcmVzdW1lZCBhZnRlciBpdCdzIGZpbmlzaGVkIHJldmVyc2luZy5cblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSBpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fcmF3UHJldlRpbWUgPj0gMCAmJiB0aGlzLl9maXJzdCkgeyAvL3doZW4gZ29pbmcgYmFjayBiZXlvbmQgdGhlIHN0YXJ0LCBmb3JjZSBhIHJlbmRlciBzbyB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIHRoYXQgc2l0IGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyByZW5kZXIgdGhlaXIgc3RhcnQgdmFsdWVzIHByb3Blcmx5LiBPdGhlcndpc2UsIGlmIHRoZSBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBsYW5kcyBleGFjdGx5IGF0IHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUsIGFuZCB0aGVuIG1vdmVzIGJhY2t3YXJkcywgdGhlIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSBiZWdpbm5pbmcgd291bGQgc3RpbGwgYmUgYXQgdGhlaXIgZW5kIHN0YXRlLlxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9ICh0aGlzLl9kdXJhdGlvbiB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0aWYgKHRpbWUgPT09IDAgJiYgaXNDb21wbGV0ZSkgeyAvL2lmIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHRpbWVsaW5lIGFuZCB0aGUgcGxheWhlYWQgbGFuZHMgRVhBQ1RMWSBhdCB0aW1lIDAsIHRoYXQgdHdlZW4gd2lsbCBjb3JyZWN0bHkgcmVuZGVyIGl0cyBlbmQgdmFsdWVzLCBidXQgd2UgbmVlZCB0byBrZWVwIHRoZSB0aW1lbGluZSBhbGl2ZSBmb3Igb25lIG1vcmUgcmVuZGVyIHNvIHRoYXQgdGhlIGJlZ2lubmluZyB2YWx1ZXMgcmVuZGVyIHByb3Blcmx5IGFzIHRoZSBwYXJlbnQncyBwbGF5aGVhZCBrZWVwcyBtb3ZpbmcgYmV5b25kIHRoZSBiZWdpbmluZy4gSW1hZ2luZSBvYmoueCBzdGFydHMgYXQgMCBhbmQgdGhlbiB3ZSBkbyB0bC5zZXQob2JqLCB7eDoxMDB9KS50byhvYmosIDEsIHt4OjIwMH0pIGFuZCB0aGVuIGxhdGVyIHdlIHRsLnJldmVyc2UoKS4uLnRoZSBnb2FsIGlzIHRvIGhhdmUgb2JqLnggcmV2ZXJ0IHRvIDAuIElmIHRoZSBwbGF5aGVhZCBoYXBwZW5zIHRvIGxhbmQgb24gZXhhY3RseSAwLCB3aXRob3V0IHRoaXMgY2h1bmsgb2YgY29kZSwgaXQnZCBjb21wbGV0ZSB0aGUgdGltZWxpbmUgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZW5kZXJpbmcgcXVldWUgKG5vdCBnb29kKS5cblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdGlzQ29tcGxldGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aW1lID0gMDsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAoY291bGQgY2F1c2UgcHJvYmxlbXMgZXNwZWNpYWxseSB3aXRoIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiB0aGUgdGltZWxpbmUpXG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAodGhpcy5faGFzUGF1c2UgJiYgIXRoaXMuX2ZvcmNpbmdQbGF5aGVhZCAmJiAhc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0XHRpZiAodGltZSA+PSBwcmV2VGltZSkge1xuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lIDw9IHRpbWUgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIGlmICh0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIiAmJiAhdHdlZW4ucmF0aW8gJiYgISh0d2Vlbi5fc3RhcnRUaW1lID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID09PSAwKSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA+PSB0aW1lICYmICFwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSBpZiAodHdlZW4uZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgdHdlZW4uX3Jhd1ByZXZUaW1lID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGF1c2VUd2Vlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRpbWUgPSBwYXVzZVR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aW1lICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX3RvdGFsRHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKHRoaXMuX3RpbWUgPT09IHByZXZUaW1lIHx8ICF0aGlzLl9maXJzdCkgJiYgIWZvcmNlICYmICFpbnRlcm5hbEZvcmNlICYmICFwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90aW1lICE9PSBwcmV2VGltZSAmJiB0aW1lID4gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgdGhlIHRpbWVsaW5lIChhcyBvcHBvc2VkIHRvIHRoZSBwYXJlbnQgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgaXQgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdGltZWxpbmUgYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUsIGZvciBleGFtcGxlLlxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJldlRpbWUgPT09IDApIGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RpbWUgIT09IDApIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdXJUaW1lID0gdGhpcy5fdGltZTtcblx0XHRcdGlmIChjdXJUaW1lID49IHByZXZUaW1lKSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKGN1clRpbWUgIT09IHRoaXMuX3RpbWUgfHwgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IGN1clRpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmIChjdXJUaW1lICE9PSB0aGlzLl90aW1lIHx8ICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSBwcmV2VGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4gPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbi5fcHJldjsgLy90aGUgbGlua2VkIGxpc3QgaXMgb3JnYW5pemVkIGJ5IF9zdGFydFRpbWUsIHRodXMgaXQncyBwb3NzaWJsZSB0aGF0IGEgdHdlZW4gY291bGQgc3RhcnQgQkVGT1JFIHRoZSBwYXVzZSBhbmQgZW5kIGFmdGVyIGl0LCBpbiB3aGljaCBjYXNlIGl0IHdvdWxkIGJlIHBvc2l0aW9uZWQgYmVmb3JlIHRoZSBwYXVzZSB0d2VlbiBpbiB0aGUgbGlua2VkIGxpc3QsIGJ1dCB3ZSBzaG91bGQgcmVuZGVyIGl0IGJlZm9yZSB3ZSBwYXVzZSgpIHRoZSB0aW1lbGluZSBhbmQgY2Vhc2UgcmVuZGVyaW5nLiBUaGlzIGlzIG9ubHkgYSBjb25jZXJuIHdoZW4gZ29pbmcgaW4gcmV2ZXJzZS5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKHBhdXNlVHdlZW4gJiYgcGF1c2VUd2Vlbi5lbmRUaW1lKCkgPiB0aGlzLl90aW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2Vlbi5yZW5kZXIoIChwYXVzZVR3ZWVuLl9yZXZlcnNlZCA/IHBhdXNlVHdlZW4udG90YWxEdXJhdGlvbigpIC0gKCh0aW1lIC0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lKSAqIHBhdXNlVHdlZW4uX3RpbWVTY2FsZSkgOiAodGltZSAtIHBhdXNlVHdlZW4uX3N0YXJ0VGltZSkgKiBwYXVzZVR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSBwYXVzZVR3ZWVuLl9wcmV2O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uVXBkYXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9nYykgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnRUaW1lIHx8IHByZXZUaW1lU2NhbGUgIT09IHRoaXMuX3RpbWVTY2FsZSkgaWYgKHRoaXMuX3RpbWUgPT09IDAgfHwgdG90YWxEdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkpIHsgLy9pZiBvbmUgb2YgdGhlIHR3ZWVucyB0aGF0IHdhcyByZW5kZXJlZCBhbHRlcmVkIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgKGxpa2UgaWYgYW4gb25Db21wbGV0ZSByZXZlcnNlZCB0aGUgdGltZWxpbmUpLCBpdCBwcm9iYWJseSBpc24ndCBjb21wbGV0ZS4gSWYgaXQgaXMsIGRvbid0IHdvcnJ5LCBiZWNhdXNlIHdoYXRldmVyIGNhbGwgYWx0ZXJlZCB0aGUgc3RhcnRUaW1lIHdvdWxkIGNvbXBsZXRlIGlmIGl0IHdhcyBuZWNlc3NhcnkgYXQgdGhlIG5ldyB0aW1lLiBUaGUgb25seSBleGNlcHRpb24gaXMgdGhlIHRpbWVTY2FsZSBwcm9wZXJ0eS4gQWxzbyBjaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvbkNvbXBsZXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2hhc1BhdXNlZENoaWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRpZiAodHdlZW4uX3BhdXNlZCB8fCAoKHR3ZWVuIGluc3RhbmNlb2YgVGltZWxpbmVMaXRlKSAmJiB0d2Vlbi5faGFzUGF1c2VkQ2hpbGQoKSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLmdldENoaWxkcmVuID0gZnVuY3Rpb24obmVzdGVkLCB0d2VlbnMsIHRpbWVsaW5lcywgaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0aWdub3JlQmVmb3JlVGltZSA9IGlnbm9yZUJlZm9yZVRpbWUgfHwgLTk5OTk5OTk5OTk7XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lIDwgaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdC8vZG8gbm90aGluZ1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuIGluc3RhbmNlb2YgVHdlZW5MaXRlKSB7XG5cdFx0XHRcdFx0aWYgKHR3ZWVucyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aW1lbGluZXMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobmVzdGVkICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YSA9IGEuY29uY2F0KHR3ZWVuLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XG5cdFx0XHRcdFx0XHRjbnQgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRwLmdldFR3ZWVuc09mID0gZnVuY3Rpb24odGFyZ2V0LCBuZXN0ZWQpIHtcblx0XHRcdHZhciBkaXNhYmxlZCA9IHRoaXMuX2djLFxuXHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdHR3ZWVucywgaTtcblx0XHRcdGlmIChkaXNhYmxlZCkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIHRydWUpOyAvL2dldFR3ZWVuc09mKCkgZmlsdGVycyBvdXQgZGlzYWJsZWQgdHdlZW5zLCBhbmQgd2UgaGF2ZSB0byBtYXJrIHRoZW0gYXMgX2djID0gdHJ1ZSB3aGVuIHRoZSB0aW1lbGluZSBjb21wbGV0ZXMgaW4gb3JkZXIgdG8gYWxsb3cgY2xlYW4gZ2FyYmFnZSBjb2xsZWN0aW9uLCBzbyB0ZW1wb3JhcmlseSByZS1lbmFibGUgdGhlIHRpbWVsaW5lIGhlcmUuXG5cdFx0XHR9XG5cdFx0XHR0d2VlbnMgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0KTtcblx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmICh0d2VlbnNbaV0udGltZWxpbmUgPT09IHRoaXMgfHwgKG5lc3RlZCAmJiB0aGlzLl9jb250YWlucyh0d2VlbnNbaV0pKSkge1xuXHRcdFx0XHRcdGFbY250KytdID0gdHdlZW5zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGlzYWJsZWQpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cdFx0cC5yZWNlbnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZWNlbnQ7XG5cdFx0fTtcblxuXHRcdHAuX2NvbnRhaW5zID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHRcdHZhciB0bCA9IHR3ZWVuLnRpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHRsKSB7XG5cdFx0XHRcdGlmICh0bCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRsID0gdGwudGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuc2hpZnRDaGlsZHJlbiA9IGZ1bmN0aW9uKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRpZ25vcmVCZWZvcmVUaW1lID0gaWdub3JlQmVmb3JlVGltZSB8fCAwO1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdGxhYmVscyA9IHRoaXMuX2xhYmVscyxcblx0XHRcdFx0cDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0dHdlZW4uX3N0YXJ0VGltZSArPSBhbW91bnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdGlmIChhZGp1c3RMYWJlbHMpIHtcblx0XHRcdFx0Zm9yIChwIGluIGxhYmVscykge1xuXHRcdFx0XHRcdGlmIChsYWJlbHNbcF0gPj0gaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdFx0bGFiZWxzW3BdICs9IGFtb3VudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHRpZiAoIXZhcnMgJiYgIXRhcmdldCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHR3ZWVucyA9ICghdGFyZ2V0KSA/IHRoaXMuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHJ1ZSwgZmFsc2UpIDogdGhpcy5nZXRUd2VlbnNPZih0YXJnZXQpLFxuXHRcdFx0XHRpID0gdHdlZW5zLmxlbmd0aCxcblx0XHRcdFx0Y2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmICh0d2VlbnNbaV0uX2tpbGwodmFycywgdGFyZ2V0KSkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0cC5jbGVhciA9IGZ1bmN0aW9uKGxhYmVscykge1xuXHRcdFx0dmFyIHR3ZWVucyA9IHRoaXMuZ2V0Q2hpbGRyZW4oZmFsc2UsIHRydWUsIHRydWUpLFxuXHRcdFx0XHRpID0gdHdlZW5zLmxlbmd0aDtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSAwO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHR3ZWVuc1tpXS5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxhYmVscyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fbGFiZWxzID0ge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHR0d2Vlbi5pbnZhbGlkYXRlKCk7XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQW5pbWF0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7O1xuXHRcdH07XG5cblx0XHRwLl9lbmFibGVkID0gZnVuY3Rpb24oZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpIHtcblx0XHRcdGlmIChlbmFibGVkID09PSB0aGlzLl9nYykge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0dHdlZW4uX2VuYWJsZWQoZW5hYmxlZCwgdHJ1ZSk7XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsIGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbFRpbWUgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgdW5jYXBwZWQpIHtcblx0XHRcdHRoaXMuX2ZvcmNpbmdQbGF5aGVhZCA9IHRydWU7XG5cdFx0XHR2YXIgdmFsID0gQW5pbWF0aW9uLnByb3RvdHlwZS50b3RhbFRpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX2ZvcmNpbmdQbGF5aGVhZCA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9O1xuXG5cdFx0cC5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7IC8vanVzdCB0cmlnZ2VycyByZWNhbGN1bGF0aW9uXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuZHVyYXRpb24oKSAhPT0gMCAmJiB2YWx1ZSAhPT0gMCkge1xuXHRcdFx0XHR0aGlzLnRpbWVTY2FsZSh0aGlzLl9kdXJhdGlvbiAvIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdHZhciBtYXggPSAwLFxuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0LFxuXHRcdFx0XHRcdFx0cHJldlN0YXJ0ID0gOTk5OTk5OTk5OTk5LFxuXHRcdFx0XHRcdFx0cHJldiwgZW5kO1xuXHRcdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdFx0cHJldiA9IHR3ZWVuLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXG5cdFx0XHRcdFx0XHRpZiAodHdlZW4uX2RpcnR5KSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnRvdGFsRHVyYXRpb24oKTsgLy9jb3VsZCBjaGFuZ2UgdGhlIHR3ZWVuLl9zdGFydFRpbWUsIHNvIG1ha2Ugc3VyZSB0aGUgdHdlZW4ncyBjYWNoZSBpcyBjbGVhbiBiZWZvcmUgYW5hbHl6aW5nIGl0LlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPiBwcmV2U3RhcnQgJiYgdGhpcy5fc29ydENoaWxkcmVuICYmICF0d2Vlbi5fcGF1c2VkKSB7IC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2Vcblx0XHRcdFx0XHRcdFx0dGhpcy5hZGQodHdlZW4sIHR3ZWVuLl9zdGFydFRpbWUgLSB0d2Vlbi5fZGVsYXkpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHJldlN0YXJ0ID0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lIDwgMCAmJiAhdHdlZW4uX3BhdXNlZCkgeyAvL2NoaWxkcmVuIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgbmVnYXRpdmUgc3RhcnRUaW1lcyB1bmxlc3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgc28gYWRqdXN0IGhlcmUgaWYgb25lIGlzIGZvdW5kLlxuXHRcdFx0XHRcdFx0XHRtYXggLT0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lICs9IHR3ZWVuLl9zdGFydFRpbWUgLyB0aGlzLl90aW1lU2NhbGU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGhpcy5zaGlmdENoaWxkcmVuKC10d2Vlbi5fc3RhcnRUaW1lLCBmYWxzZSwgLTk5OTk5OTk5OTkpO1xuXHRcdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZW5kID0gdHdlZW4uX3N0YXJ0VGltZSArICh0d2Vlbi5fdG90YWxEdXJhdGlvbiAvIHR3ZWVuLl90aW1lU2NhbGUpO1xuXHRcdFx0XHRcdFx0aWYgKGVuZCA+IG1heCkge1xuXHRcdFx0XHRcdFx0XHRtYXggPSBlbmQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHByZXY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IG1heDtcblx0XHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh2YWx1ZSAmJiB0aGlzLnRvdGFsRHVyYXRpb24oKSkgPyB0aGlzLnRpbWVTY2FsZSh0aGlzLl90b3RhbER1cmF0aW9uIC8gdmFsdWUpIDogdGhpcztcblx0XHR9O1xuXG5cdFx0cC5wYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCF2YWx1ZSkgeyAvL2lmIHRoZXJlJ3MgYSBwYXVzZSBkaXJlY3RseSBhdCB0aGUgc3BvdCBmcm9tIHdoZXJlIHdlJ3JlIHVucGF1c2luZywgc2tpcCBpdC5cblx0XHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID09PSB0aW1lICYmIHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fcmF3UHJldlRpbWUgPSAwOyAvL3JlbWVtYmVyLCBfcmF3UHJldlRpbWUgaXMgaG93IHplcm8tZHVyYXRpb24gdHdlZW5zL2NhbGxiYWNrcyBzZW5zZSBkaXJlY3Rpb25hbGl0eSBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGZpcmUuIElmIF9yYXdQcmV2VGltZSBpcyB0aGUgc2FtZSBhcyBfc3RhcnRUaW1lIG9uIHRoZSBuZXh0IHJlbmRlciwgaXQgd29uJ3QgZmlyZS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEFuaW1hdGlvbi5wcm90b3R5cGUucGF1c2VkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudXNlc0ZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0bCA9PT0gQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmUpO1xuXHRcdH07XG5cblx0XHRwLnJhd1RpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wYXVzZWQgPyB0aGlzLl90b3RhbFRpbWUgOiAodGhpcy5fdGltZWxpbmUucmF3VGltZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSAqIHRoaXMuX3RpbWVTY2FsZTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFRpbWVsaW5lTGl0ZTtcblxuXHR9LCB0cnVlKTtcblxuXG5cblxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUaW1lbGluZU1heFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTWF4XCIsIFtcIlRpbWVsaW5lTGl0ZVwiLFwiVHdlZW5MaXRlXCIsXCJlYXNpbmcuRWFzZVwiXSwgZnVuY3Rpb24oVGltZWxpbmVMaXRlLCBUd2VlbkxpdGUsIEVhc2UpIHtcblxuXHRcdHZhciBUaW1lbGluZU1heCA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0VGltZWxpbmVMaXRlLmNhbGwodGhpcywgdmFycyk7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMsXG5cdFx0XHRfbGF6eVR3ZWVucyA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5VHdlZW5zLFxuXHRcdFx0X2xhenlSZW5kZXIgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVJlbmRlcixcblx0XHRcdF9lYXNlTm9uZSA9IG5ldyBFYXNlKG51bGwsIG51bGwsIDEsIDApLFxuXHRcdFx0cCA9IFRpbWVsaW5lTWF4LnByb3RvdHlwZSA9IG5ldyBUaW1lbGluZUxpdGUoKTtcblxuXHRcdHAuY29uc3RydWN0b3IgPSBUaW1lbGluZU1heDtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblx0XHRUaW1lbGluZU1heC52ZXJzaW9uID0gXCIxLjE4LjRcIjtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5feW95byA9ICh0aGlzLnZhcnMueW95byA9PT0gdHJ1ZSk7XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB0aGlzLnZhcnMucmVwZWF0IHx8IDA7XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHRoaXMudmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdHJldHVybiBUaW1lbGluZUxpdGUucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcblx0XHR9O1xuXG5cdFx0cC5hZGRDYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwb3NpdGlvbiwgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlQ2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgcG9zaXRpb24pIHtcblx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRpZiAocG9zaXRpb24gPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuX2tpbGwobnVsbCwgY2FsbGJhY2spO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBhID0gdGhpcy5nZXRUd2VlbnNPZihjYWxsYmFjaywgZmFsc2UpLFxuXHRcdFx0XHRcdFx0aSA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdFx0dGltZSA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24pO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKGFbaV0uX3N0YXJ0VGltZSA9PT0gdGltZSkge1xuXHRcdFx0XHRcdFx0XHRhW2ldLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5yZW1vdmVQYXVzZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVDYWxsYmFjayhUaW1lbGluZUxpdGUuX2ludGVybmFscy5wYXVzZUNhbGxiYWNrLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAudHdlZW5UbyA9IGZ1bmN0aW9uKHBvc2l0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdHZhciBjb3B5ID0ge2Vhc2U6X2Vhc2VOb25lLCB1c2VGcmFtZXM6dGhpcy51c2VzRnJhbWVzKCksIGltbWVkaWF0ZVJlbmRlcjpmYWxzZX0sXG5cdFx0XHRcdGR1cmF0aW9uLCBwLCB0O1xuXHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0Y29weVtwXSA9IHZhcnNbcF07XG5cdFx0XHR9XG5cdFx0XHRjb3B5LnRpbWUgPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdGR1cmF0aW9uID0gKE1hdGguYWJzKE51bWJlcihjb3B5LnRpbWUpIC0gdGhpcy5fdGltZSkgLyB0aGlzLl90aW1lU2NhbGUpIHx8IDAuMDAxO1xuXHRcdFx0dCA9IG5ldyBUd2VlbkxpdGUodGhpcywgZHVyYXRpb24sIGNvcHkpO1xuXHRcdFx0Y29weS5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHQudGFyZ2V0LnBhdXNlZCh0cnVlKTtcblx0XHRcdFx0aWYgKHQudmFycy50aW1lICE9PSB0LnRhcmdldC50aW1lKCkgJiYgZHVyYXRpb24gPT09IHQuZHVyYXRpb24oKSkgeyAvL2Rvbid0IG1ha2UgdGhlIGR1cmF0aW9uIHplcm8gLSBpZiBpdCdzIHN1cHBvc2VkIHRvIGJlIHplcm8sIGRvbid0IHdvcnJ5IGJlY2F1c2UgaXQncyBhbHJlYWR5IGluaXR0aW5nIHRoZSB0d2VlbiBhbmQgd2lsbCBjb21wbGV0ZSBpbW1lZGlhdGVseSwgZWZmZWN0aXZlbHkgbWFraW5nIHRoZSBkdXJhdGlvbiB6ZXJvIGFueXdheS4gSWYgd2UgbWFrZSBkdXJhdGlvbiB6ZXJvLCB0aGUgdHdlZW4gd29uJ3QgcnVuIGF0IGFsbC5cblx0XHRcdFx0XHR0LmR1cmF0aW9uKCBNYXRoLmFicyggdC52YXJzLnRpbWUgLSB0LnRhcmdldC50aW1lKCkpIC8gdC50YXJnZXQuX3RpbWVTY2FsZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YXJzLm9uU3RhcnQpIHsgLy9pbiBjYXNlIHRoZSB1c2VyIGhhZCBhbiBvblN0YXJ0IGluIHRoZSB2YXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgaXQuXG5cdFx0XHRcdFx0dC5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHQ7XG5cdFx0fTtcblxuXHRcdHAudHdlZW5Gcm9tVG8gPSBmdW5jdGlvbihmcm9tUG9zaXRpb24sIHRvUG9zaXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0ZnJvbVBvc2l0aW9uID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChmcm9tUG9zaXRpb24pO1xuXHRcdFx0dmFycy5zdGFydEF0ID0ge29uQ29tcGxldGU6dGhpcy5zZWVrLCBvbkNvbXBsZXRlUGFyYW1zOltmcm9tUG9zaXRpb25dLCBjYWxsYmFja1Njb3BlOnRoaXN9O1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlKTtcblx0XHRcdHZhciB0ID0gdGhpcy50d2VlblRvKHRvUG9zaXRpb24sIHZhcnMpO1xuXHRcdFx0cmV0dXJuIHQuZHVyYXRpb24oKE1hdGguYWJzKCB0LnZhcnMudGltZSAtIGZyb21Qb3NpdGlvbikgLyB0aGlzLl90aW1lU2NhbGUpIHx8IDAuMDAxKTtcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHZhciB0b3RhbER1ciA9ICghdGhpcy5fZGlydHkpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMudG90YWxEdXJhdGlvbigpLFxuXHRcdFx0XHRkdXIgPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0cHJldlRpbWUgPSB0aGlzLl90aW1lLFxuXHRcdFx0XHRwcmV2VG90YWxUaW1lID0gdGhpcy5fdG90YWxUaW1lLFxuXHRcdFx0XHRwcmV2U3RhcnQgPSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0XHRcdHByZXZUaW1lU2NhbGUgPSB0aGlzLl90aW1lU2NhbGUsXG5cdFx0XHRcdHByZXZSYXdQcmV2VGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lLFxuXHRcdFx0XHRwcmV2UGF1c2VkID0gdGhpcy5fcGF1c2VkLFxuXHRcdFx0XHRwcmV2Q3ljbGUgPSB0aGlzLl9jeWNsZSxcblx0XHRcdFx0dHdlZW4sIGlzQ29tcGxldGUsIG5leHQsIGNhbGxiYWNrLCBpbnRlcm5hbEZvcmNlLCBjeWNsZUR1cmF0aW9uLCBwYXVzZVR3ZWVuLCBjdXJUaW1lO1xuXHRcdFx0aWYgKHRpbWUgPj0gdG90YWxEdXIgLSAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLlxuXHRcdFx0XHRpZiAoIXRoaXMuX2xvY2tlZCkge1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRvdGFsRHVyO1xuXHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gdGhpcy5fcmVwZWF0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIGlmICghdGhpcy5faGFzUGF1c2VkQ2hpbGQoKSkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9ICEhdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0XHRpZiAodGhpcy5fZHVyYXRpb24gPT09IDApIGlmICgodGltZSA8PSAwICYmIHRpbWUgPj0gLTAuMDAwMDAwMSkgfHwgcHJldlJhd1ByZXZUaW1lIDwgMCB8fCBwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtKSBpZiAocHJldlJhd1ByZXZUaW1lICE9PSB0aW1lICYmIHRoaXMuX2ZpcnN0KSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAodGhpcy5fZHVyYXRpb24gfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRpZiAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lID0gMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyO1xuXHRcdFx0XHRcdHRpbWUgPSBkdXIgKyAwLjAwMDE7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgLSBzb21ldGltZXMgY2hpbGQgdHdlZW5zL3RpbWVsaW5lcyB3ZXJlIG5vdCBiZWluZyBmdWxseSBjb21wbGV0ZWQgKHRoZWlyIHByb2dyZXNzIG1pZ2h0IGJlIDAuOTk5OTk5OTk5OTk5OTk4IGluc3RlYWQgb2YgMSBiZWNhdXNlIHdoZW4gX3RpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lIGlzIHBlcmZvcm1lZCwgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHdvdWxkIHJldHVybiBhIHZhbHVlIHRoYXQgd2FzIFNMSUdIVExZIG9mZikuIFRyeSAoOTk5OTk5OTk5OTk5LjcgLSA5OTk5OTk5OTk5OTkpICogMSA9IDAuNjk5OTUxMTcxODc1IGluc3RlYWQgb2YgMC43LiBXZSBjYW5ub3QgZG8gbGVzcyB0aGVuIDAuMDAwMSBiZWNhdXNlIHRoZSBzYW1lIGlzc3VlIGNhbiBvY2N1ciB3aGVuIHRoZSBkdXJhdGlvbiBpcyBleHRyZW1lbHkgbGFyZ2UgbGlrZSA5OTk5OTk5OTk5OTkgaW4gd2hpY2ggY2FzZSBhZGRpbmcgMC4wMDAwMDAwMSwgZm9yIGV4YW1wbGUsIGNhdXNlcyBpdCB0byBhY3QgbGlrZSBub3RoaW5nIHdhcyBhZGRlZC5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLCByb3VuZCBzdXBlciBzbWFsbCB2YWx1ZXMgdG8gMC5cblx0XHRcdFx0aWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdGlmIChwcmV2VGltZSAhPT0gMCB8fCAoZHVyID09PSAwICYmIHByZXZSYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0gJiYgKHByZXZSYXdQcmV2VGltZSA+IDAgfHwgKHRpbWUgPCAwICYmIHByZXZSYXdQcmV2VGltZSA+PSAwKSkgJiYgIXRoaXMuX2xvY2tlZCkpIHsgLy9lZGdlIGNhc2UgZm9yIGNoZWNraW5nIHRpbWUgPCAwICYmIHByZXZSYXdQcmV2VGltZSA+PSAwOiBhIHplcm8tZHVyYXRpb24gZnJvbVRvKCkgdHdlZW4gaW5zaWRlIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSAoeWVhaCwgdmVyeSByYXJlKVxuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuICYmIHRoaXMuX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gaXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHByZXZSYXdQcmV2VGltZSA+PSAwICYmIHRoaXMuX2ZpcnN0KSB7IC8vd2hlbiBnb2luZyBiYWNrIGJleW9uZCB0aGUgc3RhcnQsIGZvcmNlIGEgcmVuZGVyIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgdGhhdCBzaXQgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIHJlbmRlciB0aGVpciBzdGFydCB2YWx1ZXMgcHJvcGVybHkuIE90aGVyd2lzZSwgaWYgdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGxhbmRzIGV4YWN0bHkgYXQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSwgYW5kIHRoZW4gbW92ZXMgYmFja3dhcmRzLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIGJlZ2lubmluZyB3b3VsZCBzdGlsbCBiZSBhdCB0aGVpciBlbmQgc3RhdGUuXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKGR1ciB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0aWYgKHRpbWUgPT09IDAgJiYgaXNDb21wbGV0ZSkgeyAvL2lmIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHRpbWVsaW5lIGFuZCB0aGUgcGxheWhlYWQgbGFuZHMgRVhBQ1RMWSBhdCB0aW1lIDAsIHRoYXQgdHdlZW4gd2lsbCBjb3JyZWN0bHkgcmVuZGVyIGl0cyBlbmQgdmFsdWVzLCBidXQgd2UgbmVlZCB0byBrZWVwIHRoZSB0aW1lbGluZSBhbGl2ZSBmb3Igb25lIG1vcmUgcmVuZGVyIHNvIHRoYXQgdGhlIGJlZ2lubmluZyB2YWx1ZXMgcmVuZGVyIHByb3Blcmx5IGFzIHRoZSBwYXJlbnQncyBwbGF5aGVhZCBrZWVwcyBtb3ZpbmcgYmV5b25kIHRoZSBiZWdpbmluZy4gSW1hZ2luZSBvYmoueCBzdGFydHMgYXQgMCBhbmQgdGhlbiB3ZSBkbyB0bC5zZXQob2JqLCB7eDoxMDB9KS50byhvYmosIDEsIHt4OjIwMH0pIGFuZCB0aGVuIGxhdGVyIHdlIHRsLnJldmVyc2UoKS4uLnRoZSBnb2FsIGlzIHRvIGhhdmUgb2JqLnggcmV2ZXJ0IHRvIDAuIElmIHRoZSBwbGF5aGVhZCBoYXBwZW5zIHRvIGxhbmQgb24gZXhhY3RseSAwLCB3aXRob3V0IHRoaXMgY2h1bmsgb2YgY29kZSwgaXQnZCBjb21wbGV0ZSB0aGUgdGltZWxpbmUgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZW5kZXJpbmcgcXVldWUgKG5vdCBnb29kKS5cblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdGlzQ29tcGxldGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aW1lID0gMDsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAoY291bGQgY2F1c2UgcHJvYmxlbXMgZXNwZWNpYWxseSB3aXRoIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiB0aGUgdGltZWxpbmUpXG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGR1ciA9PT0gMCAmJiBwcmV2UmF3UHJldlRpbWUgPCAwKSB7IC8vd2l0aG91dCB0aGlzLCB6ZXJvLWR1cmF0aW9uIHJlcGVhdGluZyB0aW1lbGluZXMgKGxpa2Ugd2l0aCBhIHNpbXBsZSBjYWxsYmFjayBuZXN0ZWQgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIGFuZCBhIHJlcGVhdERlbGF5KSB3b3VsZG4ndCByZW5kZXIgdGhlIGZpcnN0IHRpbWUgdGhyb3VnaC5cblx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0XHRpZiAoIXRoaXMuX2xvY2tlZCkge1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRpbWU7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3JlcGVhdCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0Y3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JlcGVhdERlbGF5O1xuXHRcdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSAodGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikgPj4gMDsgLy9vcmlnaW5hbGx5IF90b3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uIGJ1dCBmbG9hdGluZyBwb2ludCBlcnJvcnMgY2F1c2VkIHByb2JsZW1zLCBzbyBJIG5vcm1hbGl6ZWQgaXQuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBpdCBnZXRzIHJlcG9ydGVkIGFzIDAuNzk5OTk5OTkhKVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX2N5Y2xlICE9PSAwKSBpZiAodGhpcy5fY3ljbGUgPT09IHRoaXMuX3RvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24gJiYgcHJldlRvdGFsVGltZSA8PSB0aW1lKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlLS07IC8vb3RoZXJ3aXNlIHdoZW4gcmVuZGVyZWQgZXhhY3RseSBhdCB0aGUgZW5kIHRpbWUsIGl0IHdpbGwgYWN0IGFzIHRob3VnaCBpdCBpcyByZXBlYXRpbmcgKGF0IHRoZSBiZWdpbm5pbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lIC0gKHRoaXMuX2N5Y2xlICogY3ljbGVEdXJhdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5feW95bykgaWYgKCh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXIgLSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgPiBkdXIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cjtcblx0XHRcdFx0XHRcdFx0dGltZSA9IGR1ciArIDAuMDAwMTsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9yXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZ1BsYXloZWFkICYmICFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdGlmICh0aW1lID49IHByZXZUaW1lKSB7XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPD0gdGltZSAmJiAhcGF1c2VUd2Vlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikgaWYgKHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmICF0d2Vlbi5yYXRpbyAmJiAhKHR3ZWVuLl9zdGFydFRpbWUgPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPT09IDApKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lID49IHRpbWUgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIGlmICh0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIiAmJiB0d2Vlbi5fcmF3UHJldlRpbWUgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGltZSA9IHBhdXNlVHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRpbWUgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fdG90YWxEdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX2N5Y2xlICE9PSBwcmV2Q3ljbGUpIGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdC8qXG5cdFx0XHRcdG1ha2Ugc3VyZSBjaGlsZHJlbiBhdCB0aGUgZW5kL2JlZ2lubmluZyBvZiB0aGUgdGltZWxpbmUgYXJlIHJlbmRlcmVkIHByb3Blcmx5LiBJZiwgZm9yIGV4YW1wbGUsXG5cdFx0XHRcdGEgMy1zZWNvbmQgbG9uZyB0aW1lbGluZSByZW5kZXJlZCBhdCAyLjkgc2Vjb25kcyBwcmV2aW91c2x5LCBhbmQgbm93IHJlbmRlcnMgYXQgMy4yIHNlY29uZHMgKHdoaWNoXG5cdFx0XHRcdHdvdWxkIGdldCB0cmFuc2F0ZWQgdG8gMi44IHNlY29uZHMgaWYgdGhlIHRpbWVsaW5lIHlveW9zIG9yIDAuMiBzZWNvbmRzIGlmIGl0IGp1c3QgcmVwZWF0cyksIHRoZXJlXG5cdFx0XHRcdGNvdWxkIGJlIGEgY2FsbGJhY2sgb3IgYSBzaG9ydCB0d2VlbiB0aGF0J3MgYXQgMi45NSBvciAzIHNlY29uZHMgaW4gd2hpY2ggd291bGRuJ3QgcmVuZGVyLiBTb1xuXHRcdFx0XHR3ZSBuZWVkIHRvIHB1c2ggdGhlIHRpbWVsaW5lIHRvIHRoZSBlbmQgKGFuZC9vciBiZWdpbm5pbmcgZGVwZW5kaW5nIG9uIGl0cyB5b3lvIHZhbHVlKS4gQWxzbyB3ZSBtdXN0XG5cdFx0XHRcdGVuc3VyZSB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIFRpbWVsaW5lTWF4IHdvcmsuXG5cdFx0XHRcdCovXG5cdFx0XHRcdHZhciBiYWNrd2FyZHMgPSAodGhpcy5feW95byAmJiAocHJldkN5Y2xlICYgMSkgIT09IDApLFxuXHRcdFx0XHRcdHdyYXAgPSAoYmFja3dhcmRzID09PSAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkpLFxuXHRcdFx0XHRcdHJlY1RvdGFsVGltZSA9IHRoaXMuX3RvdGFsVGltZSxcblx0XHRcdFx0XHRyZWNDeWNsZSA9IHRoaXMuX2N5Y2xlLFxuXHRcdFx0XHRcdHJlY1Jhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdFx0cmVjVGltZSA9IHRoaXMuX3RpbWU7XG5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gcHJldkN5Y2xlICogZHVyO1xuXHRcdFx0XHRpZiAodGhpcy5fY3ljbGUgPCBwcmV2Q3ljbGUpIHtcblx0XHRcdFx0XHRiYWNrd2FyZHMgPSAhYmFja3dhcmRzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSArPSBkdXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGltZSA9IHByZXZUaW1lOyAvL3RlbXBvcmFyaWx5IHJldmVydCBfdGltZSBzbyB0aGF0IHJlbmRlcigpIHJlbmRlcnMgdGhlIGNoaWxkcmVuIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBXaXRob3V0IHRoaXMsIHR3ZWVucyB3b24ndCByZXdpbmQgY29ycmVjdGx5LiBXZSBjb3VsZCBhcmhpY3RlY3QgdGhpbmdzIGluIGEgXCJjbGVhbmVyXCIgd2F5IGJ5IHNwbGl0dGluZyBvdXQgdGhlIHJlbmRlcmluZyBxdWV1ZSBpbnRvIGEgc2VwYXJhdGUgbWV0aG9kIGJ1dCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2Uga2VwdCBpdCBhbGwgaW5zaWRlIHRoaXMgbWV0aG9kLlxuXG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKGR1ciA9PT0gMCkgPyBwcmV2UmF3UHJldlRpbWUgLSAwLjAwMDEgOiBwcmV2UmF3UHJldlRpbWU7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gcHJldkN5Y2xlO1xuXHRcdFx0XHR0aGlzLl9sb2NrZWQgPSB0cnVlOyAvL3ByZXZlbnRzIGNoYW5nZXMgdG8gdG90YWxUaW1lIGFuZCBza2lwcyByZXBlYXQveW95byBiZWhhdmlvciB3aGVuIHdlIHJlY3Vyc2l2ZWx5IGNhbGwgcmVuZGVyKClcblx0XHRcdFx0cHJldlRpbWUgPSAoYmFja3dhcmRzKSA/IDAgOiBkdXI7XG5cdFx0XHRcdHRoaXMucmVuZGVyKHByZXZUaW1lLCBzdXBwcmVzc0V2ZW50cywgKGR1ciA9PT0gMCkpO1xuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAoIXRoaXMuX2djKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMudmFycy5vblJlcGVhdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblJlcGVhdFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lKSB7IC8vaW4gY2FzZSB0aGVyZSdzIGEgY2FsbGJhY2sgbGlrZSBvbkNvbXBsZXRlIGluIGEgbmVzdGVkIHR3ZWVuL3RpbWVsaW5lIHRoYXQgY2hhbmdlcyB0aGUgcGxheWhlYWQgcG9zaXRpb24sIGxpa2UgdmlhIHNlZWsoKSwgd2Ugc2hvdWxkIGp1c3QgYWJvcnQuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh3cmFwKSB7XG5cdFx0XHRcdFx0cHJldlRpbWUgPSAoYmFja3dhcmRzKSA/IGR1ciArIDAuMDAwMSA6IC0wLjAwMDE7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkgeyAvL2lmIHRoZSByZW5kZXIoKSB0cmlnZ2VyZWQgY2FsbGJhY2sgdGhhdCBwYXVzZWQgdGhpcyB0aW1lbGluZSwgd2Ugc2hvdWxkIGFib3J0ICh2ZXJ5IHJhcmUsIGJ1dCBwb3NzaWJsZSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGltZSA9IHJlY1RpbWU7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHJlY1RvdGFsVGltZTtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSByZWNDeWNsZTtcblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByZWNSYXdQcmV2VGltZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCh0aGlzLl90aW1lID09PSBwcmV2VGltZSB8fCAhdGhpcy5fZmlyc3QpICYmICFmb3JjZSAmJiAhaW50ZXJuYWxGb3JjZSAmJiAhcGF1c2VUd2Vlbikge1xuXHRcdFx0XHRpZiAocHJldlRvdGFsVGltZSAhPT0gdGhpcy5fdG90YWxUaW1lKSBpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHsgLy9zbyB0aGF0IG9uVXBkYXRlIGZpcmVzIGV2ZW4gZHVyaW5nIHRoZSByZXBlYXREZWxheSAtIGFzIGxvbmcgYXMgdGhlIHRvdGFsVGltZSBjaGFuZ2VkLCB3ZSBzaG91bGQgdHJpZ2dlciBvblVwZGF0ZS5cblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90b3RhbFRpbWUgIT09IHByZXZUb3RhbFRpbWUgJiYgdGltZSA+IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgIC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIHRoZSB0aW1lbGluZSAoYXMgb3Bwb3NlZCB0byB0aGUgcGFyZW50IHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIGl0IGlzIGZvcmNlZCB0byByZS1yZW5kZXIgYW5kIGFsaWduIGl0IHdpdGggdGhlIHByb3BlciB0aW1lL2ZyYW1lIG9uIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZS4gTWF5YmUgdGhlIHRpbWVsaW5lIGFscmVhZHkgZmluaXNoZWQgYnV0IHRoZSB1c2VyIG1hbnVhbGx5IHJlLXJlbmRlcnMgaXQgYXMgaGFsZndheSBkb25lLCBmb3IgZXhhbXBsZS5cblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgPT09IDApIGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gMCkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIik7XG5cdFx0XHR9XG5cblx0XHRcdGN1clRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0aWYgKGN1clRpbWUgPj0gcHJldlRpbWUpIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAoY3VyVGltZSAhPT0gdGhpcy5fdGltZSB8fCAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHR3ZWVuLl9zdGFydFRpbWUgPD0gdGhpcy5fdGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4gPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKGN1clRpbWUgIT09IHRoaXMuX3RpbWUgfHwgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IHByZXZUaW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAocGF1c2VUd2VlbiA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuLl9wcmV2OyAvL3RoZSBsaW5rZWQgbGlzdCBpcyBvcmdhbml6ZWQgYnkgX3N0YXJ0VGltZSwgdGh1cyBpdCdzIHBvc3NpYmxlIHRoYXQgYSB0d2VlbiBjb3VsZCBzdGFydCBCRUZPUkUgdGhlIHBhdXNlIGFuZCBlbmQgYWZ0ZXIgaXQsIGluIHdoaWNoIGNhc2UgaXQgd291bGQgYmUgcG9zaXRpb25lZCBiZWZvcmUgdGhlIHBhdXNlIHR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCwgYnV0IHdlIHNob3VsZCByZW5kZXIgaXQgYmVmb3JlIHdlIHBhdXNlKCkgdGhlIHRpbWVsaW5lIGFuZCBjZWFzZSByZW5kZXJpbmcuIFRoaXMgaXMgb25seSBhIGNvbmNlcm4gd2hlbiBnb2luZyBpbiByZXZlcnNlLlxuXHRcdFx0XHRcdFx0XHR3aGlsZSAocGF1c2VUd2VlbiAmJiBwYXVzZVR3ZWVuLmVuZFRpbWUoKSA+IHRoaXMuX3RpbWUpIHtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuLnJlbmRlciggKHBhdXNlVHdlZW4uX3JldmVyc2VkID8gcGF1c2VUd2Vlbi50b3RhbER1cmF0aW9uKCkgLSAoKHRpbWUgLSBwYXVzZVR3ZWVuLl9zdGFydFRpbWUpICogcGF1c2VUd2Vlbi5fdGltZVNjYWxlKSA6ICh0aW1lIC0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lKSAqIHBhdXNlVHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHBhdXNlVHdlZW4uX3ByZXY7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25VcGRhdGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKTtcblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9sb2NrZWQpIGlmICghdGhpcy5fZ2MpIGlmIChwcmV2U3RhcnQgPT09IHRoaXMuX3N0YXJ0VGltZSB8fCBwcmV2VGltZVNjYWxlICE9PSB0aGlzLl90aW1lU2NhbGUpIGlmICh0aGlzLl90aW1lID09PSAwIHx8IHRvdGFsRHVyID49IHRoaXMudG90YWxEdXJhdGlvbigpKSB7IC8vaWYgb25lIG9mIHRoZSB0d2VlbnMgdGhhdCB3YXMgcmVuZGVyZWQgYWx0ZXJlZCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lIChsaWtlIGlmIGFuIG9uQ29tcGxldGUgcmV2ZXJzZWQgdGhlIHRpbWVsaW5lKSwgaXQgcHJvYmFibHkgaXNuJ3QgY29tcGxldGUuIElmIGl0IGlzLCBkb24ndCB3b3JyeSwgYmVjYXVzZSB3aGF0ZXZlciBjYWxsIGFsdGVyZWQgdGhlIHN0YXJ0VGltZSB3b3VsZCBjb21wbGV0ZSBpZiBpdCB3YXMgbmVjZXNzYXJ5IGF0IHRoZSBuZXcgdGltZS4gVGhlIG9ubHkgZXhjZXB0aW9uIGlzIHRoZSB0aW1lU2NhbGUgcHJvcGVydHkuIEFsc28gY2hlY2sgX2djIGJlY2F1c2UgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGtpbGwoKSBjb3VsZCBiZSBjYWxsZWQgaW4gYW4gb25VcGRhdGVcblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25Db21wbGV0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKGNhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLmdldEFjdGl2ZSA9IGZ1bmN0aW9uKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMpIHtcblx0XHRcdGlmIChuZXN0ZWQgPT0gbnVsbCkge1xuXHRcdFx0XHRuZXN0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR3ZWVucyA9PSBudWxsKSB7XG5cdFx0XHRcdHR3ZWVucyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGltZWxpbmVzID09IG51bGwpIHtcblx0XHRcdFx0dGltZWxpbmVzID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRhbGwgPSB0aGlzLmdldENoaWxkcmVuKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMpLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRsID0gYWxsLmxlbmd0aCxcblx0XHRcdFx0aSwgdHdlZW47XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHR3ZWVuID0gYWxsW2ldO1xuXHRcdFx0XHRpZiAodHdlZW4uaXNBY3RpdmUoKSkge1xuXHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblxuXHRcdHAuZ2V0TGFiZWxBZnRlciA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRcdGlmICghdGltZSkgaWYgKHRpbWUgIT09IDApIHsgLy9mYXN0ZXIgdGhhbiBpc05hbigpXG5cdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzQXJyYXkoKSxcblx0XHRcdFx0bCA9IGxhYmVscy5sZW5ndGgsXG5cdFx0XHRcdGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0udGltZSA+IHRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFiZWxzW2ldLm5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cblx0XHRwLmdldExhYmVsQmVmb3JlID0gZnVuY3Rpb24odGltZSkge1xuXHRcdFx0aWYgKHRpbWUgPT0gbnVsbCkge1xuXHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVsc0FycmF5KCksXG5cdFx0XHRcdGkgPSBsYWJlbHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0udGltZSA8IHRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFiZWxzW2ldLm5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cblx0XHRwLmdldExhYmVsc0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRwO1xuXHRcdFx0Zm9yIChwIGluIHRoaXMuX2xhYmVscykge1xuXHRcdFx0XHRhW2NudCsrXSA9IHt0aW1lOnRoaXMuX2xhYmVsc1twXSwgbmFtZTpwfTtcblx0XHRcdH1cblx0XHRcdGEuc29ydChmdW5jdGlvbihhLGIpIHtcblx0XHRcdFx0cmV0dXJuIGEudGltZSAtIGIudGltZTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXG4vLy0tLS0gR0VUVEVSUyAvIFNFVFRFUlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5wcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUoIHRoaXMuZHVyYXRpb24oKSAqICgodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90b3RhbFRpbWUgLyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0VGltZWxpbmVMaXRlLnByb3RvdHlwZS50b3RhbER1cmF0aW9uLmNhbGwodGhpcyk7IC8vanVzdCBmb3JjZXMgcmVmcmVzaFxuXHRcdFx0XHRcdC8vSW5zdGVhZCBvZiBJbmZpbml0eSwgd2UgdXNlIDk5OTk5OTk5OTk5OSBzbyB0aGF0IHdlIGNhbiBhY2NvbW1vZGF0ZSByZXZlcnNlcy5cblx0XHRcdFx0XHR0aGlzLl90b3RhbER1cmF0aW9uID0gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gOTk5OTk5OTk5OTk5IDogdGhpcy5fZHVyYXRpb24gKiAodGhpcy5fcmVwZWF0ICsgMSkgKyAodGhpcy5fcmVwZWF0RGVsYXkgKiB0aGlzLl9yZXBlYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0aGlzLl9yZXBlYXQgPT09IC0xIHx8ICF2YWx1ZSkgPyB0aGlzIDogdGhpcy50aW1lU2NhbGUoIHRoaXMudG90YWxEdXJhdGlvbigpIC8gdmFsdWUgKTtcblx0XHR9O1xuXG5cdFx0cC50aW1lID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgPiB0aGlzLl9kdXJhdGlvbikge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgPSAodGhpcy5fZHVyYXRpb24gLSB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgKz0gdGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUodmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5yZXBlYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAueW95byA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3lveW87XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl95b3lvID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5jdXJyZW50TGFiZWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldExhYmVsQmVmb3JlKHRoaXMuX3RpbWUgKyAwLjAwMDAwMDAxKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnNlZWsodmFsdWUsIHRydWUpO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gVGltZWxpbmVNYXg7XG5cblx0fSwgdHJ1ZSk7XG5cdFxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJlemllclBsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdChmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG5cdFx0XHRfcjEgPSBbXSxcblx0XHRcdF9yMiA9IFtdLFxuXHRcdFx0X3IzID0gW10sXG5cdFx0XHRfY29yUHJvcHMgPSB7fSxcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRTZWdtZW50ID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuXHRcdFx0XHR0aGlzLmEgPSBhO1xuXHRcdFx0XHR0aGlzLmIgPSBiO1xuXHRcdFx0XHR0aGlzLmMgPSBjO1xuXHRcdFx0XHR0aGlzLmQgPSBkO1xuXHRcdFx0XHR0aGlzLmRhID0gZCAtIGE7XG5cdFx0XHRcdHRoaXMuY2EgPSBjIC0gYTtcblx0XHRcdFx0dGhpcy5iYSA9IGIgLSBhO1xuXHRcdFx0fSxcblx0XHRcdF9jb3JyZWxhdGUgPSBcIix4LHkseixsZWZ0LHRvcCxyaWdodCxib3R0b20sbWFyZ2luVG9wLG1hcmdpbkxlZnQsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLHBhZGRpbmdMZWZ0LHBhZGRpbmdUb3AscGFkZGluZ1JpZ2h0LHBhZGRpbmdCb3R0b20sYmFja2dyb3VuZFBvc2l0aW9uLGJhY2tncm91bmRQb3NpdGlvbl95LFwiLFxuXHRcdFx0Y3ViaWNUb1F1YWRyYXRpYyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcblx0XHRcdFx0dmFyIHExID0ge2E6YX0sXG5cdFx0XHRcdFx0cTIgPSB7fSxcblx0XHRcdFx0XHRxMyA9IHt9LFxuXHRcdFx0XHRcdHE0ID0ge2M6ZH0sXG5cdFx0XHRcdFx0bWFiID0gKGEgKyBiKSAvIDIsXG5cdFx0XHRcdFx0bWJjID0gKGIgKyBjKSAvIDIsXG5cdFx0XHRcdFx0bWNkID0gKGMgKyBkKSAvIDIsXG5cdFx0XHRcdFx0bWFiYyA9IChtYWIgKyBtYmMpIC8gMixcblx0XHRcdFx0XHRtYmNkID0gKG1iYyArIG1jZCkgLyAyLFxuXHRcdFx0XHRcdG04ID0gKG1iY2QgLSBtYWJjKSAvIDg7XG5cdFx0XHRcdHExLmIgPSBtYWIgKyAoYSAtIG1hYikgLyA0O1xuXHRcdFx0XHRxMi5iID0gbWFiYyArIG04O1xuXHRcdFx0XHRxMS5jID0gcTIuYSA9IChxMS5iICsgcTIuYikgLyAyO1xuXHRcdFx0XHRxMi5jID0gcTMuYSA9IChtYWJjICsgbWJjZCkgLyAyO1xuXHRcdFx0XHRxMy5iID0gbWJjZCAtIG04O1xuXHRcdFx0XHRxNC5iID0gbWNkICsgKGQgLSBtY2QpIC8gNDtcblx0XHRcdFx0cTMuYyA9IHE0LmEgPSAocTMuYiArIHE0LmIpIC8gMjtcblx0XHRcdFx0cmV0dXJuIFtxMSwgcTIsIHEzLCBxNF07XG5cdFx0XHR9LFxuXHRcdFx0X2NhbGN1bGF0ZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbihhLCBjdXJ2aW5lc3MsIHF1YWQsIGJhc2ljLCBjb3JyZWxhdGUpIHtcblx0XHRcdFx0dmFyIGwgPSBhLmxlbmd0aCAtIDEsXG5cdFx0XHRcdFx0aWkgPSAwLFxuXHRcdFx0XHRcdGNwMSA9IGFbMF0uYSxcblx0XHRcdFx0XHRpLCBwMSwgcDIsIHAzLCBzZWcsIG0xLCBtMiwgbW0sIGNwMiwgcWIsIHIxLCByMiwgdGw7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRzZWcgPSBhW2lpXTtcblx0XHRcdFx0XHRwMSA9IHNlZy5hO1xuXHRcdFx0XHRcdHAyID0gc2VnLmQ7XG5cdFx0XHRcdFx0cDMgPSBhW2lpKzFdLmQ7XG5cblx0XHRcdFx0XHRpZiAoY29ycmVsYXRlKSB7XG5cdFx0XHRcdFx0XHRyMSA9IF9yMVtpXTtcblx0XHRcdFx0XHRcdHIyID0gX3IyW2ldO1xuXHRcdFx0XHRcdFx0dGwgPSAoKHIyICsgcjEpICogY3VydmluZXNzICogMC4yNSkgLyAoYmFzaWMgPyAwLjUgOiBfcjNbaV0gfHwgMC41KTtcblx0XHRcdFx0XHRcdG0xID0gcDIgLSAocDIgLSBwMSkgKiAoYmFzaWMgPyBjdXJ2aW5lc3MgKiAwLjUgOiAocjEgIT09IDAgPyB0bCAvIHIxIDogMCkpO1xuXHRcdFx0XHRcdFx0bTIgPSBwMiArIChwMyAtIHAyKSAqIChiYXNpYyA/IGN1cnZpbmVzcyAqIDAuNSA6IChyMiAhPT0gMCA/IHRsIC8gcjIgOiAwKSk7XG5cdFx0XHRcdFx0XHRtbSA9IHAyIC0gKG0xICsgKCgobTIgLSBtMSkgKiAoKHIxICogMyAvIChyMSArIHIyKSkgKyAwLjUpIC8gNCkgfHwgMCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtMSA9IHAyIC0gKHAyIC0gcDEpICogY3VydmluZXNzICogMC41O1xuXHRcdFx0XHRcdFx0bTIgPSBwMiArIChwMyAtIHAyKSAqIGN1cnZpbmVzcyAqIDAuNTtcblx0XHRcdFx0XHRcdG1tID0gcDIgLSAobTEgKyBtMikgLyAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtMSArPSBtbTtcblx0XHRcdFx0XHRtMiArPSBtbTtcblxuXHRcdFx0XHRcdHNlZy5jID0gY3AyID0gbTE7XG5cdFx0XHRcdFx0aWYgKGkgIT09IDApIHtcblx0XHRcdFx0XHRcdHNlZy5iID0gY3AxO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWcuYiA9IGNwMSA9IHNlZy5hICsgKHNlZy5jIC0gc2VnLmEpICogMC42OyAvL2luc3RlYWQgb2YgcGxhY2luZyBiIG9uIGEgZXhhY3RseSwgd2UgbW92ZSBpdCBpbmxpbmUgd2l0aCBjIHNvIHRoYXQgaWYgdGhlIHVzZXIgc3BlY2lmaWVzIGFuIGVhc2UgbGlrZSBCYWNrLmVhc2VJbiBvciBFbGFzdGljLmVhc2VJbiB3aGljaCBnb2VzIEJFWU9ORCB0aGUgYmVnaW5uaW5nLCBpdCB3aWxsIGRvIHNvIHNtb290aGx5LlxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNlZy5kYSA9IHAyIC0gcDE7XG5cdFx0XHRcdFx0c2VnLmNhID0gY3AyIC0gcDE7XG5cdFx0XHRcdFx0c2VnLmJhID0gY3AxIC0gcDE7XG5cblx0XHRcdFx0XHRpZiAocXVhZCkge1xuXHRcdFx0XHRcdFx0cWIgPSBjdWJpY1RvUXVhZHJhdGljKHAxLCBjcDEsIGNwMiwgcDIpO1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaWksIDEsIHFiWzBdLCBxYlsxXSwgcWJbMl0sIHFiWzNdKTtcblx0XHRcdFx0XHRcdGlpICs9IDQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlpKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y3AxID0gbTI7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VnID0gYVtpaV07XG5cdFx0XHRcdHNlZy5iID0gY3AxO1xuXHRcdFx0XHRzZWcuYyA9IGNwMSArIChzZWcuZCAtIGNwMSkgKiAwLjQ7IC8vaW5zdGVhZCBvZiBwbGFjaW5nIGMgb24gZCBleGFjdGx5LCB3ZSBtb3ZlIGl0IGlubGluZSB3aXRoIGIgc28gdGhhdCBpZiB0aGUgdXNlciBzcGVjaWZpZXMgYW4gZWFzZSBsaWtlIEJhY2suZWFzZU91dCBvciBFbGFzdGljLmVhc2VPdXQgd2hpY2ggZ29lcyBCRVlPTkQgdGhlIGVuZCwgaXQgd2lsbCBkbyBzbyBzbW9vdGhseS5cblx0XHRcdFx0c2VnLmRhID0gc2VnLmQgLSBzZWcuYTtcblx0XHRcdFx0c2VnLmNhID0gc2VnLmMgLSBzZWcuYTtcblx0XHRcdFx0c2VnLmJhID0gY3AxIC0gc2VnLmE7XG5cdFx0XHRcdGlmIChxdWFkKSB7XG5cdFx0XHRcdFx0cWIgPSBjdWJpY1RvUXVhZHJhdGljKHNlZy5hLCBjcDEsIHNlZy5jLCBzZWcuZCk7XG5cdFx0XHRcdFx0YS5zcGxpY2UoaWksIDEsIHFiWzBdLCBxYlsxXSwgcWJbMl0sIHFiWzNdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9wYXJzZUFuY2hvcnMgPSBmdW5jdGlvbih2YWx1ZXMsIHAsIGNvcnJlbGF0ZSwgcHJlcGVuZCkge1xuXHRcdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRcdGwsIGksIHAxLCBwMiwgcDMsIHRtcDtcblx0XHRcdFx0aWYgKHByZXBlbmQpIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSBbcHJlcGVuZF0uY29uY2F0KHZhbHVlcyk7XG5cdFx0XHRcdFx0aSA9IHZhbHVlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKCAodG1wID0gdmFsdWVzW2ldW3BdKSApID09PSBcInN0cmluZ1wiKSBpZiAodG1wLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzW2ldW3BdID0gcHJlcGVuZFtwXSArIE51bWJlcih0bXAuY2hhckF0KDApICsgdG1wLnN1YnN0cigyKSk7IC8vYWNjb21tb2RhdGUgcmVsYXRpdmUgdmFsdWVzLiBEbyBpdCBpbmxpbmUgaW5zdGVhZCBvZiBicmVha2luZyBpdCBvdXQgaW50byBhIGZ1bmN0aW9uIGZvciBzcGVlZCByZWFzb25zXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoIC0gMjtcblx0XHRcdFx0aWYgKGwgPCAwKSB7XG5cdFx0XHRcdFx0YVswXSA9IG5ldyBTZWdtZW50KHZhbHVlc1swXVtwXSwgMCwgMCwgdmFsdWVzWyhsIDwgLTEpID8gMCA6IDFdW3BdKTtcblx0XHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0cDEgPSB2YWx1ZXNbaV1bcF07XG5cdFx0XHRcdFx0cDIgPSB2YWx1ZXNbaSsxXVtwXTtcblx0XHRcdFx0XHRhW2ldID0gbmV3IFNlZ21lbnQocDEsIDAsIDAsIHAyKTtcblx0XHRcdFx0XHRpZiAoY29ycmVsYXRlKSB7XG5cdFx0XHRcdFx0XHRwMyA9IHZhbHVlc1tpKzJdW3BdO1xuXHRcdFx0XHRcdFx0X3IxW2ldID0gKF9yMVtpXSB8fCAwKSArIChwMiAtIHAxKSAqIChwMiAtIHAxKTtcblx0XHRcdFx0XHRcdF9yMltpXSA9IChfcjJbaV0gfHwgMCkgKyAocDMgLSBwMikgKiAocDMgLSBwMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGFbaV0gPSBuZXcgU2VnbWVudCh2YWx1ZXNbaV1bcF0sIDAsIDAsIHZhbHVlc1tpKzFdW3BdKTtcblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9LFxuXHRcdFx0YmV6aWVyVGhyb3VnaCA9IGZ1bmN0aW9uKHZhbHVlcywgY3VydmluZXNzLCBxdWFkcmF0aWMsIGJhc2ljLCBjb3JyZWxhdGUsIHByZXBlbmQpIHtcblx0XHRcdFx0dmFyIG9iaiA9IHt9LFxuXHRcdFx0XHRcdHByb3BzID0gW10sXG5cdFx0XHRcdFx0Zmlyc3QgPSBwcmVwZW5kIHx8IHZhbHVlc1swXSxcblx0XHRcdFx0XHRpLCBwLCBhLCBqLCByLCBsLCBzZWFtbGVzcywgbGFzdDtcblx0XHRcdFx0Y29ycmVsYXRlID0gKHR5cGVvZihjb3JyZWxhdGUpID09PSBcInN0cmluZ1wiKSA/IFwiLFwiK2NvcnJlbGF0ZStcIixcIiA6IF9jb3JyZWxhdGU7XG5cdFx0XHRcdGlmIChjdXJ2aW5lc3MgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGN1cnZpbmVzcyA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwIGluIHZhbHVlc1swXSkge1xuXHRcdFx0XHRcdHByb3BzLnB1c2gocCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9jaGVjayB0byBzZWUgaWYgdGhlIGxhc3QgYW5kIGZpcnN0IHZhbHVlcyBhcmUgaWRlbnRpY2FsICh3ZWxsLCB3aXRoaW4gMC4wNSkuIElmIHNvLCBtYWtlIHNlYW1sZXNzIGJ5IGFwcGVuZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQgdG8gdGhlIHZlcnkgZW5kIG9mIHRoZSB2YWx1ZXMgYXJyYXkgYW5kIHRoZSAybmQtdG8tbGFzdCBlbGVtZW50IHRvIHRoZSB2ZXJ5IGJlZ2lubmluZyAod2UnbGwgcmVtb3ZlIHRob3NlIHNlZ21lbnRzIGxhdGVyKVxuXHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRsYXN0ID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0XHRzZWFtbGVzcyA9IHRydWU7XG5cdFx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRcdGlmIChNYXRoLmFicyhmaXJzdFtwXSAtIGxhc3RbcF0pID4gMC4wNSkgeyAvL2J1aWxkIGluIGEgdG9sZXJhbmNlIG9mICsvLTAuMDUgdG8gYWNjb21tb2RhdGUgcm91bmRpbmcgZXJyb3JzLlxuXHRcdFx0XHRcdFx0XHRzZWFtbGVzcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNlYW1sZXNzKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KCk7IC8vZHVwbGljYXRlIHRoZSBhcnJheSB0byBhdm9pZCBjb250YW1pbmF0aW5nIHRoZSBvcmlnaW5hbCB3aGljaCB0aGUgdXNlciBtYXkgYmUgcmV1c2luZyBmb3Igb3RoZXIgdHdlZW5zXG5cdFx0XHRcdFx0XHRpZiAocHJlcGVuZCkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXMudW5zaGlmdChwcmVwZW5kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKHZhbHVlc1sxXSk7XG5cdFx0XHRcdFx0XHRwcmVwZW5kID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAzXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0X3IxLmxlbmd0aCA9IF9yMi5sZW5ndGggPSBfcjMubGVuZ3RoID0gMDtcblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHRcdF9jb3JQcm9wc1twXSA9IChjb3JyZWxhdGUuaW5kZXhPZihcIixcIitwK1wiLFwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdG9ialtwXSA9IF9wYXJzZUFuY2hvcnModmFsdWVzLCBwLCBfY29yUHJvcHNbcF0sIHByZXBlbmQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBfcjEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRfcjFbaV0gPSBNYXRoLnNxcnQoX3IxW2ldKTtcblx0XHRcdFx0XHRfcjJbaV0gPSBNYXRoLnNxcnQoX3IyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWJhc2ljKSB7XG5cdFx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChfY29yUHJvcHNbcF0pIHtcblx0XHRcdFx0XHRcdFx0YSA9IG9ialtwcm9wc1tpXV07XG5cdFx0XHRcdFx0XHRcdGwgPSBhLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHRyID0gKGFbaisxXS5kYSAvIF9yMltqXSArIGFbal0uZGEgLyBfcjFbal0pIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0X3IzW2pdID0gKF9yM1tqXSB8fCAwKSArIHIgKiByO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGkgPSBfcjMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0X3IzW2ldID0gTWF0aC5zcXJ0KF9yM1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdGogPSBxdWFkcmF0aWMgPyA0IDogMTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHRcdGEgPSBvYmpbcF07XG5cdFx0XHRcdFx0X2NhbGN1bGF0ZUNvbnRyb2xQb2ludHMoYSwgY3VydmluZXNzLCBxdWFkcmF0aWMsIGJhc2ljLCBfY29yUHJvcHNbcF0pOyAvL3RoaXMgbWV0aG9kIHJlcXVpcmVzIHRoYXQgX3BhcnNlQW5jaG9ycygpIGFuZCBfc2V0U2VnbWVudFJhdGlvcygpIHJhbiBmaXJzdCBzbyB0aGF0IF9yMSwgX3IyLCBhbmQgX3IzIHZhbHVlcyBhcmUgcG9wdWxhdGVkIGZvciBhbGwgcHJvcGVydGllc1xuXHRcdFx0XHRcdGlmIChzZWFtbGVzcykge1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoMCwgaik7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShhLmxlbmd0aCAtIGosIGopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fSxcblx0XHRcdF9wYXJzZUJlemllckRhdGEgPSBmdW5jdGlvbih2YWx1ZXMsIHR5cGUsIHByZXBlbmQpIHtcblx0XHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJzb2Z0XCI7XG5cdFx0XHRcdHZhciBvYmogPSB7fSxcblx0XHRcdFx0XHRpbmMgPSAodHlwZSA9PT0gXCJjdWJpY1wiKSA/IDMgOiAyLFxuXHRcdFx0XHRcdHNvZnQgPSAodHlwZSA9PT0gXCJzb2Z0XCIpLFxuXHRcdFx0XHRcdHByb3BzID0gW10sXG5cdFx0XHRcdFx0YSwgYiwgYywgZCwgY3VyLCBpLCBqLCBsLCBwLCBjbnQsIHRtcDtcblx0XHRcdFx0aWYgKHNvZnQgJiYgcHJlcGVuZCkge1xuXHRcdFx0XHRcdHZhbHVlcyA9IFtwcmVwZW5kXS5jb25jYXQodmFsdWVzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFsdWVzID09IG51bGwgfHwgdmFsdWVzLmxlbmd0aCA8IGluYyArIDEpIHsgdGhyb3cgXCJpbnZhbGlkIEJlemllciBkYXRhXCI7IH1cblx0XHRcdFx0Zm9yIChwIGluIHZhbHVlc1swXSkge1xuXHRcdFx0XHRcdHByb3BzLnB1c2gocCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHRcdG9ialtwXSA9IGN1ciA9IFtdO1xuXHRcdFx0XHRcdGNudCA9IDA7XG5cdFx0XHRcdFx0bCA9IHZhbHVlcy5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuXHRcdFx0XHRcdFx0YSA9IChwcmVwZW5kID09IG51bGwpID8gdmFsdWVzW2pdW3BdIDogKHR5cGVvZiggKHRtcCA9IHZhbHVlc1tqXVtwXSkgKSA9PT0gXCJzdHJpbmdcIiAmJiB0bXAuY2hhckF0KDEpID09PSBcIj1cIikgPyBwcmVwZW5kW3BdICsgTnVtYmVyKHRtcC5jaGFyQXQoMCkgKyB0bXAuc3Vic3RyKDIpKSA6IE51bWJlcih0bXApO1xuXHRcdFx0XHRcdFx0aWYgKHNvZnQpIGlmIChqID4gMSkgaWYgKGogPCBsIC0gMSkge1xuXHRcdFx0XHRcdFx0XHRjdXJbY250KytdID0gKGEgKyBjdXJbY250LTJdKSAvIDI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJbY250KytdID0gYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bCA9IGNudCAtIGluYyArIDE7XG5cdFx0XHRcdFx0Y250ID0gMDtcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaiArPSBpbmMpIHtcblx0XHRcdFx0XHRcdGEgPSBjdXJbal07XG5cdFx0XHRcdFx0XHRiID0gY3VyW2orMV07XG5cdFx0XHRcdFx0XHRjID0gY3VyW2orMl07XG5cdFx0XHRcdFx0XHRkID0gKGluYyA9PT0gMikgPyAwIDogY3VyW2orM107XG5cdFx0XHRcdFx0XHRjdXJbY250KytdID0gdG1wID0gKGluYyA9PT0gMykgPyBuZXcgU2VnbWVudChhLCBiLCBjLCBkKSA6IG5ldyBTZWdtZW50KGEsICgyICogYiArIGEpIC8gMywgKDIgKiBiICsgYykgLyAzLCBjKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VyLmxlbmd0aCA9IGNudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fSxcblx0XHRcdF9hZGRDdWJpY0xlbmd0aHMgPSBmdW5jdGlvbihhLCBzdGVwcywgcmVzb2x1dGlvbikge1xuXHRcdFx0XHR2YXIgaW5jID0gMSAvIHJlc29sdXRpb24sXG5cdFx0XHRcdFx0aiA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGQsIGQxLCBzLCBkYSwgY2EsIGJhLCBwLCBpLCBpbnYsIGJleiwgaW5kZXg7XG5cdFx0XHRcdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdFx0XHRcdGJleiA9IGFbal07XG5cdFx0XHRcdFx0cyA9IGJlei5hO1xuXHRcdFx0XHRcdGRhID0gYmV6LmQgLSBzO1xuXHRcdFx0XHRcdGNhID0gYmV6LmMgLSBzO1xuXHRcdFx0XHRcdGJhID0gYmV6LmIgLSBzO1xuXHRcdFx0XHRcdGQgPSBkMSA9IDA7XG5cdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8PSByZXNvbHV0aW9uOyBpKyspIHtcblx0XHRcdFx0XHRcdHAgPSBpbmMgKiBpO1xuXHRcdFx0XHRcdFx0aW52ID0gMSAtIHA7XG5cdFx0XHRcdFx0XHRkID0gZDEgLSAoZDEgPSAocCAqIHAgKiBkYSArIDMgKiBpbnYgKiAocCAqIGNhICsgaW52ICogYmEpKSAqIHApO1xuXHRcdFx0XHRcdFx0aW5kZXggPSBqICogcmVzb2x1dGlvbiArIGkgLSAxO1xuXHRcdFx0XHRcdFx0c3RlcHNbaW5kZXhdID0gKHN0ZXBzW2luZGV4XSB8fCAwKSArIGQgKiBkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9wYXJzZUxlbmd0aERhdGEgPSBmdW5jdGlvbihvYmosIHJlc29sdXRpb24pIHtcblx0XHRcdFx0cmVzb2x1dGlvbiA9IHJlc29sdXRpb24gPj4gMCB8fCA2O1xuXHRcdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRcdGxlbmd0aHMgPSBbXSxcblx0XHRcdFx0XHRkID0gMCxcblx0XHRcdFx0XHR0b3RhbCA9IDAsXG5cdFx0XHRcdFx0dGhyZXNob2xkID0gcmVzb2x1dGlvbiAtIDEsXG5cdFx0XHRcdFx0c2VnbWVudHMgPSBbXSxcblx0XHRcdFx0XHRjdXJMUyA9IFtdLCAvL2N1cnJlbnQgbGVuZ3RoIHNlZ21lbnRzIGFycmF5XG5cdFx0XHRcdFx0cCwgaSwgbCwgaW5kZXg7XG5cdFx0XHRcdGZvciAocCBpbiBvYmopIHtcblx0XHRcdFx0XHRfYWRkQ3ViaWNMZW5ndGhzKG9ialtwXSwgYSwgcmVzb2x1dGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0bCA9IGEubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0ZCArPSBNYXRoLnNxcnQoYVtpXSk7XG5cdFx0XHRcdFx0aW5kZXggPSBpICUgcmVzb2x1dGlvbjtcblx0XHRcdFx0XHRjdXJMU1tpbmRleF0gPSBkO1xuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gdGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0XHR0b3RhbCArPSBkO1xuXHRcdFx0XHRcdFx0aW5kZXggPSAoaSAvIHJlc29sdXRpb24pID4+IDA7XG5cdFx0XHRcdFx0XHRzZWdtZW50c1tpbmRleF0gPSBjdXJMUztcblx0XHRcdFx0XHRcdGxlbmd0aHNbaW5kZXhdID0gdG90YWw7XG5cdFx0XHRcdFx0XHRkID0gMDtcblx0XHRcdFx0XHRcdGN1ckxTID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7bGVuZ3RoOnRvdGFsLCBsZW5ndGhzOmxlbmd0aHMsIHNlZ21lbnRzOnNlZ21lbnRzfTtcblx0XHRcdH0sXG5cblxuXG5cdFx0XHRCZXppZXJQbHVnaW4gPSBfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRcdFx0XHRwcm9wTmFtZTogXCJiZXppZXJcIixcblx0XHRcdFx0XHRwcmlvcml0eTogLTEsXG5cdFx0XHRcdFx0dmVyc2lvbjogXCIxLjMuNVwiLFxuXHRcdFx0XHRcdEFQSTogMixcblx0XHRcdFx0XHRnbG9iYWw6dHJ1ZSxcblxuXHRcdFx0XHRcdC8vZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgaXMgd2hlcmUgaW5pdGlhbCB2YWx1ZXMgc2hvdWxkIGJlIHJlY29yZGVkIGFuZCBhbnkgc2V0dXAgcm91dGluZXMgc2hvdWxkIHJ1bi5cblx0XHRcdFx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhcnMsIHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHRcdFx0XHRpZiAodmFycyBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0XHRcdHZhcnMgPSB7dmFsdWVzOnZhcnN9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fZnVuYyA9IHt9O1xuXHRcdFx0XHRcdFx0dGhpcy5fcm91bmQgPSB7fTtcblx0XHRcdFx0XHRcdHRoaXMuX3Byb3BzID0gW107XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lUmVzID0gKHZhcnMudGltZVJlc29sdXRpb24gPT0gbnVsbCkgPyA2IDogcGFyc2VJbnQodmFycy50aW1lUmVzb2x1dGlvbiwgMTApO1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IHZhcnMudmFsdWVzIHx8IFtdLFxuXHRcdFx0XHRcdFx0XHRmaXJzdCA9IHt9LFxuXHRcdFx0XHRcdFx0XHRzZWNvbmQgPSB2YWx1ZXNbMF0sXG5cdFx0XHRcdFx0XHRcdGF1dG9Sb3RhdGUgPSB2YXJzLmF1dG9Sb3RhdGUgfHwgdHdlZW4udmFycy5vcmllbnRUb0Jlemllcixcblx0XHRcdFx0XHRcdFx0cCwgaXNGdW5jLCBpLCBqLCBwcmVwZW5kO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl9hdXRvUm90YXRlID0gYXV0b1JvdGF0ZSA/IChhdXRvUm90YXRlIGluc3RhbmNlb2YgQXJyYXkpID8gYXV0b1JvdGF0ZSA6IFtbXCJ4XCIsXCJ5XCIsXCJyb3RhdGlvblwiLCgoYXV0b1JvdGF0ZSA9PT0gdHJ1ZSkgPyAwIDogTnVtYmVyKGF1dG9Sb3RhdGUpIHx8IDApXV0gOiBudWxsO1xuXHRcdFx0XHRcdFx0Zm9yIChwIGluIHNlY29uZCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9wcm9wcy5wdXNoKHApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpID0gdGhpcy5fcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSB0aGlzLl9wcm9wc1tpXTtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0XHRcdFx0XHRpc0Z1bmMgPSB0aGlzLl9mdW5jW3BdID0gKHR5cGVvZih0YXJnZXRbcF0pID09PSBcImZ1bmN0aW9uXCIpO1xuXHRcdFx0XHRcdFx0XHRmaXJzdFtwXSA9ICghaXNGdW5jKSA/IHBhcnNlRmxvYXQodGFyZ2V0W3BdKSA6IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0oKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFwcmVwZW5kKSBpZiAoZmlyc3RbcF0gIT09IHZhbHVlc1swXVtwXSkge1xuXHRcdFx0XHRcdFx0XHRcdHByZXBlbmQgPSBmaXJzdDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fYmV6aWVycyA9ICh2YXJzLnR5cGUgIT09IFwiY3ViaWNcIiAmJiB2YXJzLnR5cGUgIT09IFwicXVhZHJhdGljXCIgJiYgdmFycy50eXBlICE9PSBcInNvZnRcIikgPyBiZXppZXJUaHJvdWdoKHZhbHVlcywgaXNOYU4odmFycy5jdXJ2aW5lc3MpID8gMSA6IHZhcnMuY3VydmluZXNzLCBmYWxzZSwgKHZhcnMudHlwZSA9PT0gXCJ0aHJ1QmFzaWNcIiksIHZhcnMuY29ycmVsYXRlLCBwcmVwZW5kKSA6IF9wYXJzZUJlemllckRhdGEodmFsdWVzLCB2YXJzLnR5cGUsIGZpcnN0KTtcblx0XHRcdFx0XHRcdHRoaXMuX3NlZ0NvdW50ID0gdGhpcy5fYmV6aWVyc1twXS5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLl90aW1lUmVzKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBsZCA9IF9wYXJzZUxlbmd0aERhdGEodGhpcy5fYmV6aWVycywgdGhpcy5fdGltZVJlcyk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xlbmd0aCA9IGxkLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbGVuZ3RocyA9IGxkLmxlbmd0aHM7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NlZ21lbnRzID0gbGQuc2VnbWVudHM7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2wxID0gdGhpcy5fbGkgPSB0aGlzLl9zMSA9IHRoaXMuX3NpID0gMDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbDIgPSB0aGlzLl9sZW5ndGhzWzBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJTZWcgPSB0aGlzLl9zZWdtZW50c1swXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSB0aGlzLl9jdXJTZWdbMF07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3ByZWMgPSAxIC8gdGhpcy5fY3VyU2VnLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKChhdXRvUm90YXRlID0gdGhpcy5fYXV0b1JvdGF0ZSkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5faW5pdGlhbFJvdGF0aW9ucyA9IFtdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIShhdXRvUm90YXRlWzBdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fYXV0b1JvdGF0ZSA9IGF1dG9Sb3RhdGUgPSBbYXV0b1JvdGF0ZV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aSA9IGF1dG9Sb3RhdGUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgMzsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwID0gYXV0b1JvdGF0ZVtpXVtqXTtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2Z1bmNbcF0gPSAodHlwZW9mKHRhcmdldFtwXSkgPT09IFwiZnVuY3Rpb25cIikgPyB0YXJnZXRbICgocC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHAuc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdIDogZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHAgPSBhdXRvUm90YXRlW2ldWzJdO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2luaXRpYWxSb3RhdGlvbnNbaV0gPSAodGhpcy5fZnVuY1twXSA/IHRoaXMuX2Z1bmNbcF0uY2FsbCh0aGlzLl90YXJnZXQpIDogdGhpcy5fdGFyZ2V0W3BdKSB8fCAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydFJhdGlvID0gdHdlZW4udmFycy5ydW5CYWNrd2FyZHMgPyAxIDogMDsgLy93ZSBkZXRlcm1pbmUgdGhlIHN0YXJ0aW5nIHJhdGlvIHdoZW4gdGhlIHR3ZWVuIGluaXRzIHdoaWNoIGlzIGFsd2F5cyAwIHVubGVzcyB0aGUgdHdlZW4gaGFzIHJ1bkJhY2t3YXJkczp0cnVlIChpbmRpY2F0aW5nIGl0J3MgYSBmcm9tKCkgdHdlZW4pIGluIHdoaWNoIGNhc2UgaXQncyAxLlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vY2FsbGVkIGVhY2ggdGltZSB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkLCBhbmQgdGhlIHJhdGlvIGdldHMgcGFzc2VkIGFzIHRoZSBvbmx5IHBhcmFtZXRlciAodHlwaWNhbGx5IGl0J3MgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGJ1dCBpdCBjYW4gZXhjZWVkIHRob3NlIHdoZW4gdXNpbmcgYW4gZWFzZSBsaWtlIEVsYXN0aWMuZWFzZU91dCBvciBCYWNrLmVhc2VPdXQsIGV0Yy4pXG5cdFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdDb3VudCxcblx0XHRcdFx0XHRcdFx0ZnVuYyA9IHRoaXMuX2Z1bmMsXG5cdFx0XHRcdFx0XHRcdHRhcmdldCA9IHRoaXMuX3RhcmdldCxcblx0XHRcdFx0XHRcdFx0bm90U3RhcnQgPSAodiAhPT0gdGhpcy5fc3RhcnRSYXRpbyksXG5cdFx0XHRcdFx0XHRcdGN1ckluZGV4LCBpbnYsIGksIHAsIGIsIHQsIHZhbCwgbCwgbGVuZ3RocywgY3VyU2VnO1xuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLl90aW1lUmVzKSB7XG5cdFx0XHRcdFx0XHRcdGN1ckluZGV4ID0gKHYgPCAwKSA/IDAgOiAodiA+PSAxKSA/IHNlZ21lbnRzIC0gMSA6IChzZWdtZW50cyAqIHYpID4+IDA7XG5cdFx0XHRcdFx0XHRcdHQgPSAodiAtIChjdXJJbmRleCAqICgxIC8gc2VnbWVudHMpKSkgKiBzZWdtZW50cztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxlbmd0aHMgPSB0aGlzLl9sZW5ndGhzO1xuXHRcdFx0XHRcdFx0XHRjdXJTZWcgPSB0aGlzLl9jdXJTZWc7XG5cdFx0XHRcdFx0XHRcdHYgKj0gdGhpcy5fbGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRpID0gdGhpcy5fbGk7XG5cdFx0XHRcdFx0XHRcdC8vZmluZCB0aGUgYXBwcm9wcmlhdGUgc2VnbWVudCAoaWYgdGhlIGN1cnJlbnRseSBjYWNoZWQgb25lIGlzbid0IGNvcnJlY3QpXG5cdFx0XHRcdFx0XHRcdGlmICh2ID4gdGhpcy5fbDIgJiYgaSA8IHNlZ21lbnRzIC0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdGwgPSBzZWdtZW50cyAtIDE7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBsICYmICh0aGlzLl9sMiA9IGxlbmd0aHNbKytpXSkgPD0gdikge1x0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2wxID0gbGVuZ3Roc1tpLTFdO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2xpID0gaTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJTZWcgPSBjdXJTZWcgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IGN1clNlZ1sodGhpcy5fczEgPSB0aGlzLl9zaSA9IDApXTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2IDwgdGhpcy5fbDEgJiYgaSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA+IDAgJiYgKHRoaXMuX2wxID0gbGVuZ3Roc1stLWldKSA+PSB2KSB7IH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCAmJiB2IDwgdGhpcy5fbDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2wxID0gMDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMiA9IGxlbmd0aHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbGkgPSBpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2N1clNlZyA9IGN1clNlZyA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MxID0gY3VyU2VnWyh0aGlzLl9zaSA9IGN1clNlZy5sZW5ndGggLSAxKSAtIDFdIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbdGhpcy5fc2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGN1ckluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0Ly9ub3cgZmluZCB0aGUgYXBwcm9wcmlhdGUgc3ViLXNlZ21lbnQgKHdlIHNwbGl0IGl0IGludG8gdGhlIG51bWJlciBvZiBwaWVjZXMgdGhhdCB3YXMgZGVmaW5lZCBieSBcInByZWNpc2lvblwiIGFuZCBtZWFzdXJlZCBlYWNoIG9uZSlcblx0XHRcdFx0XHRcdFx0diAtPSB0aGlzLl9sMTtcblx0XHRcdFx0XHRcdFx0aSA9IHRoaXMuX3NpO1xuXHRcdFx0XHRcdFx0XHRpZiAodiA+IHRoaXMuX3MyICYmIGkgPCBjdXJTZWcubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdGwgPSBjdXJTZWcubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA8IGwgJiYgKHRoaXMuX3MyID0gY3VyU2VnWysraV0pIDw9IHYpIHtcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IGN1clNlZ1tpLTFdO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NpID0gaTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2IDwgdGhpcy5fczEgJiYgaSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA+IDAgJiYgKHRoaXMuX3MxID0gY3VyU2VnWy0taV0pID49IHYpIHtcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCAmJiB2IDwgdGhpcy5fczEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MxID0gMDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IGN1clNlZ1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaSA9IGk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dCA9ICgoaSArICh2IC0gdGhpcy5fczEpIC8gKHRoaXMuX3MyIC0gdGhpcy5fczEpKSAqIHRoaXMuX3ByZWMpIHx8IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpbnYgPSAxIC0gdDtcblxuXHRcdFx0XHRcdFx0aSA9IHRoaXMuX3Byb3BzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRwID0gdGhpcy5fcHJvcHNbaV07XG5cdFx0XHRcdFx0XHRcdGIgPSB0aGlzLl9iZXppZXJzW3BdW2N1ckluZGV4XTtcblx0XHRcdFx0XHRcdFx0dmFsID0gKHQgKiB0ICogYi5kYSArIDMgKiBpbnYgKiAodCAqIGIuY2EgKyBpbnYgKiBiLmJhKSkgKiB0ICsgYi5hO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fcm91bmRbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGZ1bmNbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0odmFsKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0gPSB2YWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX2F1dG9Sb3RhdGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGFyID0gdGhpcy5fYXV0b1JvdGF0ZSxcblx0XHRcdFx0XHRcdFx0XHRiMiwgeDEsIHkxLCB4MiwgeTIsIGFkZCwgY29udjtcblx0XHRcdFx0XHRcdFx0aSA9IGFyLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IGFyW2ldWzJdO1xuXHRcdFx0XHRcdFx0XHRcdGFkZCA9IGFyW2ldWzNdIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0Y29udiA9IChhcltpXVs0XSA9PT0gdHJ1ZSkgPyAxIDogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRcdFx0YiA9IHRoaXMuX2JlemllcnNbYXJbaV1bMF1dO1xuXHRcdFx0XHRcdFx0XHRcdGIyID0gdGhpcy5fYmV6aWVyc1thcltpXVsxXV07XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoYiAmJiBiMikgeyAvL2luIGNhc2Ugb25lIG9mIHRoZSBwcm9wZXJ0aWVzIGdvdCBvdmVyd3JpdHRlbi5cblx0XHRcdFx0XHRcdFx0XHRcdGIgPSBiW2N1ckluZGV4XTtcblx0XHRcdFx0XHRcdFx0XHRcdGIyID0gYjJbY3VySW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR4MSA9IGIuYSArIChiLmIgLSBiLmEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgyID0gYi5iICsgKGIuYyAtIGIuYikgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eDEgKz0gKHgyIC0geDEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgyICs9ICgoYi5jICsgKGIuZCAtIGIuYykgKiB0KSAtIHgyKSAqIHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHkxID0gYjIuYSArIChiMi5iIC0gYjIuYSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTIgPSBiMi5iICsgKGIyLmMgLSBiMi5iKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR5MSArPSAoeTIgLSB5MSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTIgKz0gKChiMi5jICsgKGIyLmQgLSBiMi5jKSAqIHQpIC0geTIpICogdDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsID0gbm90U3RhcnQgPyBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogY29udiArIGFkZCA6IHRoaXMuX2luaXRpYWxSb3RhdGlvbnNbaV07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChmdW5jW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSh2YWwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdID0gdmFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdH0pLFxuXHRcdFx0cCA9IEJlemllclBsdWdpbi5wcm90b3R5cGU7XG5cblxuXHRcdEJlemllclBsdWdpbi5iZXppZXJUaHJvdWdoID0gYmV6aWVyVGhyb3VnaDtcblx0XHRCZXppZXJQbHVnaW4uY3ViaWNUb1F1YWRyYXRpYyA9IGN1YmljVG9RdWFkcmF0aWM7XG5cdFx0QmV6aWVyUGx1Z2luLl9hdXRvQ1NTID0gdHJ1ZTsgLy9pbmRpY2F0ZXMgdGhhdCB0aGlzIHBsdWdpbiBjYW4gYmUgaW5zZXJ0ZWQgaW50byB0aGUgXCJjc3NcIiBvYmplY3QgdXNpbmcgdGhlIGF1dG9DU1MgZmVhdHVyZSBvZiBUd2VlbkxpdGVcblx0XHRCZXppZXJQbHVnaW4ucXVhZHJhdGljVG9DdWJpYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcblx0XHRcdHJldHVybiBuZXcgU2VnbWVudChhLCAoMiAqIGIgKyBhKSAvIDMsICgyICogYiArIGMpIC8gMywgYyk7XG5cdFx0fTtcblxuXHRcdEJlemllclBsdWdpbi5fY3NzUmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBDU1NQbHVnaW4gPSBfZ2xvYmFscy5DU1NQbHVnaW47XG5cdFx0XHRpZiAoIUNTU1BsdWdpbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgX2ludGVybmFscyA9IENTU1BsdWdpbi5faW50ZXJuYWxzLFxuXHRcdFx0XHRfcGFyc2VUb1Byb3h5ID0gX2ludGVybmFscy5fcGFyc2VUb1Byb3h5LFxuXHRcdFx0XHRfc2V0UGx1Z2luUmF0aW8gPSBfaW50ZXJuYWxzLl9zZXRQbHVnaW5SYXRpbyxcblx0XHRcdFx0Q1NTUHJvcFR3ZWVuID0gX2ludGVybmFscy5DU1NQcm9wVHdlZW47XG5cdFx0XHRfaW50ZXJuYWxzLl9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJlemllclwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHByb3AsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdGUgPSB7dmFsdWVzOmV9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsdWdpbiA9IG5ldyBCZXppZXJQbHVnaW4oKTtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IGUudmFsdWVzLFxuXHRcdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRwbHVnaW5WYWx1ZXMgPSBbXSxcblx0XHRcdFx0XHR2ID0ge30sXG5cdFx0XHRcdFx0aSwgcCwgZGF0YTtcblx0XHRcdFx0aWYgKGwgPCAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPD0gbDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IF9wYXJzZVRvUHJveHkodCwgdmFsdWVzW2ldLCBjc3NwLCBwdCwgcGx1Z2luLCAobCAhPT0gaSkpO1xuXHRcdFx0XHRcdHBsdWdpblZhbHVlc1tpXSA9IGRhdGEuZW5kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocCBpbiBlKSB7XG5cdFx0XHRcdFx0dltwXSA9IGVbcF07IC8vZHVwbGljYXRlIHRoZSB2YXJzIG9iamVjdCBiZWNhdXNlIHdlIG5lZWQgdG8gYWx0ZXIgc29tZSB0aGluZ3Mgd2hpY2ggd291bGQgY2F1c2UgcHJvYmxlbXMgaWYgdGhlIHVzZXIgcGxhbnMgdG8gcmV1c2UgdGhlIHNhbWUgdmFycyBvYmplY3QgZm9yIGFub3RoZXIgdHdlZW4uXG5cdFx0XHRcdH1cblx0XHRcdFx0di52YWx1ZXMgPSBwbHVnaW5WYWx1ZXM7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBcImJlemllclwiLCAwLCAwLCBkYXRhLnB0LCAyKTtcblx0XHRcdFx0cHQuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0UGx1Z2luUmF0aW87XG5cdFx0XHRcdGlmICh2LmF1dG9Sb3RhdGUgPT09IDApIHtcblx0XHRcdFx0XHR2LmF1dG9Sb3RhdGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LmF1dG9Sb3RhdGUgJiYgISh2LmF1dG9Sb3RhdGUgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0XHRpID0gKHYuYXV0b1JvdGF0ZSA9PT0gdHJ1ZSkgPyAwIDogTnVtYmVyKHYuYXV0b1JvdGF0ZSk7XG5cdFx0XHRcdFx0di5hdXRvUm90YXRlID0gKGRhdGEuZW5kLmxlZnQgIT0gbnVsbCkgPyBbW1wibGVmdFwiLFwidG9wXCIsXCJyb3RhdGlvblwiLGksZmFsc2VdXSA6IChkYXRhLmVuZC54ICE9IG51bGwpID8gW1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsaSxmYWxzZV1dIDogZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSkge1xuXHRcdFx0XHRcdGlmICghY3NzcC5fdHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0XHRjc3NwLl9lbmFibGVUcmFuc2Zvcm1zKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YS5hdXRvUm90YXRlID0gY3NzcC5fdGFyZ2V0Ll9nc1RyYW5zZm9ybTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwbHVnaW4uX29uSW5pdFR3ZWVuKGRhdGEucHJveHksIHYsIGNzc3AuX3R3ZWVuKTtcblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fX0pO1xuXHRcdH07XG5cblx0XHRwLl9yb3VuZFByb3BzID0gZnVuY3Rpb24obG9va3VwLCB2YWx1ZSkge1xuXHRcdFx0dmFyIG9wID0gdGhpcy5fb3ZlcndyaXRlUHJvcHMsXG5cdFx0XHRcdGkgPSBvcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKGxvb2t1cFtvcFtpXV0gfHwgbG9va3VwLmJlemllciB8fCBsb29rdXAuYmV6aWVyVGhyb3VnaCkge1xuXHRcdFx0XHRcdHRoaXMuX3JvdW5kW29wW2ldXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbihsb29rdXApIHtcblx0XHRcdHZhciBhID0gdGhpcy5fcHJvcHMsXG5cdFx0XHRcdHAsIGk7XG5cdFx0XHRmb3IgKHAgaW4gdGhpcy5fYmV6aWVycykge1xuXHRcdFx0XHRpZiAocCBpbiBsb29rdXApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fYmV6aWVyc1twXTtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fZnVuY1twXTtcblx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoYVtpXSA9PT0gcCkge1xuXHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9zdXBlci5fa2lsbC5jYWxsKHRoaXMsIGxvb2t1cCk7XG5cdFx0fTtcblxuXHR9KCkpO1xuXG5cblxuXG5cblxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ1NTUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwicGx1Z2lucy5DU1NQbHVnaW5cIiwgW1wicGx1Z2lucy5Ud2VlblBsdWdpblwiLFwiVHdlZW5MaXRlXCJdLCBmdW5jdGlvbihUd2VlblBsdWdpbiwgVHdlZW5MaXRlKSB7XG5cblx0XHQvKiogQGNvbnN0cnVjdG9yICoqL1xuXHRcdHZhciBDU1NQbHVnaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0VHdlZW5QbHVnaW4uY2FsbCh0aGlzLCBcImNzc1wiKTtcblx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoID0gMDtcblx0XHRcdFx0dGhpcy5zZXRSYXRpbyA9IENTU1BsdWdpbi5wcm90b3R5cGUuc2V0UmF0aW87IC8vc3BlZWQgb3B0aW1pemF0aW9uIChhdm9pZCBwcm90b3R5cGUgbG9va3VwIG9uIHRoaXMgXCJob3RcIiBtZXRob2QpXG5cdFx0XHR9LFxuXHRcdFx0X2dsb2JhbHMgPSBfZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxcblx0XHRcdF9oYXNQcmlvcml0eSwgLy90dXJucyB0cnVlIHdoZW5ldmVyIGEgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlIGlzIGNyZWF0ZWQgdGhhdCBoYXMgYSBwcmlvcml0eSBvdGhlciB0aGFuIDAuIFRoaXMgaGVscHMgdXMgZGlzY2VybiB3aGV0aGVyIG9yIG5vdCB3ZSBzaG91bGQgc3BlbmQgdGhlIHRpbWUgb3JnYW5pemluZyB0aGUgbGlua2VkIGxpc3Qgb3Igbm90IGFmdGVyIGEgQ1NTUGx1Z2luJ3MgX29uSW5pdFR3ZWVuKCkgbWV0aG9kIGlzIGNhbGxlZC5cblx0XHRcdF9zdWZmaXhNYXAsIC8vd2Ugc2V0IHRoaXMgaW4gX29uSW5pdFR3ZWVuKCkgZWFjaCB0aW1lIGFzIGEgd2F5IHRvIGhhdmUgYSBwZXJzaXN0ZW50IHZhcmlhYmxlIHdlIGNhbiB1c2UgaW4gb3RoZXIgbWV0aG9kcyBsaWtlIF9wYXJzZSgpIHdpdGhvdXQgaGF2aW5nIHRvIHBhc3MgaXQgYXJvdW5kIGFzIGEgcGFyYW1ldGVyIGFuZCB3ZSBrZWVwIF9wYXJzZSgpIGRlY291cGxlZCBmcm9tIGEgcGFydGljdWxhciBDU1NQbHVnaW4gaW5zdGFuY2Vcblx0XHRcdF9jcywgLy9jb21wdXRlZCBzdHlsZSAod2Ugc3RvcmUgdGhpcyBpbiBhIHNoYXJlZCB2YXJpYWJsZSB0byBjb25zZXJ2ZSBtZW1vcnkgYW5kIG1ha2UgbWluaWZpY2F0aW9uIHRpZ2h0ZXJcblx0XHRcdF9vdmVyd3JpdGVQcm9wcywgLy9hbGlhcyB0byB0aGUgY3VycmVudGx5IGluc3RhbnRpYXRpbmcgQ1NTUGx1Z2luJ3MgX292ZXJ3cml0ZVByb3BzIGFycmF5LiBXZSB1c2UgdGhpcyBjbG9zdXJlIGluIG9yZGVyIHRvIGF2b2lkIGhhdmluZyB0byBwYXNzIGEgcmVmZXJlbmNlIGFyb3VuZCBmcm9tIG1ldGhvZCB0byBtZXRob2QgYW5kIGFpZCBpbiBtaW5pZmljYXRpb24uXG5cdFx0XHRfc3BlY2lhbFByb3BzID0ge30sXG5cdFx0XHRwID0gQ1NTUGx1Z2luLnByb3RvdHlwZSA9IG5ldyBUd2VlblBsdWdpbihcImNzc1wiKTtcblxuXHRcdHAuY29uc3RydWN0b3IgPSBDU1NQbHVnaW47XG5cdFx0Q1NTUGx1Z2luLnZlcnNpb24gPSBcIjEuMTguNFwiO1xuXHRcdENTU1BsdWdpbi5BUEkgPSAyO1xuXHRcdENTU1BsdWdpbi5kZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmUgPSAwO1xuXHRcdENTU1BsdWdpbi5kZWZhdWx0U2tld1R5cGUgPSBcImNvbXBlbnNhdGVkXCI7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRTbW9vdGhPcmlnaW4gPSB0cnVlO1xuXHRcdHAgPSBcInB4XCI7IC8vd2UnbGwgcmV1c2UgdGhlIFwicFwiIHZhcmlhYmxlIHRvIGtlZXAgZmlsZSBzaXplIGRvd25cblx0XHRDU1NQbHVnaW4uc3VmZml4TWFwID0ge3RvcDpwLCByaWdodDpwLCBib3R0b206cCwgbGVmdDpwLCB3aWR0aDpwLCBoZWlnaHQ6cCwgZm9udFNpemU6cCwgcGFkZGluZzpwLCBtYXJnaW46cCwgcGVyc3BlY3RpdmU6cCwgbGluZUhlaWdodDpcIlwifTtcblxuXG5cdFx0dmFyIF9udW1FeHAgPSAvKD86XFwtfFxcLnxcXGIpKFxcZHxcXC58ZVxcLSkrL2csXG5cdFx0XHRfcmVsTnVtRXhwID0gLyg/OlxcZHxcXC1cXGR8XFwuXFxkfFxcLVxcLlxcZHxcXCs9XFxkfFxcLT1cXGR8XFwrPS5cXGR8XFwtPVxcLlxcZCkrL2csXG5cdFx0XHRfdmFsdWVzRXhwID0gLyg/OlxcKz18XFwtPXxcXC18XFxiKVtcXGRcXC1cXC5dK1thLXpBLVowLTldKig/OiV8XFxiKS9naSwgLy9maW5kcyBhbGwgdGhlIHZhbHVlcyB0aGF0IGJlZ2luIHdpdGggbnVtYmVycyBvciArPSBvciAtPSBhbmQgdGhlbiBhIG51bWJlci4gSW5jbHVkZXMgc3VmZml4ZXMuIFdlIHVzZSB0aGlzIHRvIHNwbGl0IGNvbXBsZXggdmFsdWVzIGFwYXJ0IGxpa2UgXCIxcHggNXB4IDIwcHggcmdiKDI1NSwxMDIsNTEpXCJcblx0XHRcdF9OYU5FeHAgPSAvKD8hWystXT9cXGQqXFwuP1xcZCt8WystXXxlWystXVxcZCspW14wLTldL2csIC8vYWxzbyBhbGxvd3Mgc2NpZW50aWZpYyBub3RhdGlvbiBhbmQgZG9lc24ndCBraWxsIHRoZSBsZWFkaW5nIC0vKyBpbiAtPSBhbmQgKz1cblx0XHRcdF9zdWZmaXhFeHAgPSAvKD86XFxkfFxcLXxcXCt8PXwjfFxcLikqL2csXG5cdFx0XHRfb3BhY2l0eUV4cCA9IC9vcGFjaXR5ICo9ICooW14pXSopL2ksXG5cdFx0XHRfb3BhY2l0eVZhbEV4cCA9IC9vcGFjaXR5OihbXjtdKikvaSxcblx0XHRcdF9hbHBoYUZpbHRlckV4cCA9IC9hbHBoYVxcKG9wYWNpdHkgKj0uKz9cXCkvaSxcblx0XHRcdF9yZ2Joc2xFeHAgPSAvXihyZ2J8aHNsKS8sXG5cdFx0XHRfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG5cdFx0XHRfY2FtZWxFeHAgPSAvLShbYS16XSkvZ2ksXG5cdFx0XHRfdXJsRXhwID0gLyheKD86dXJsXFwoXFxcInx1cmxcXCgpKXwoPzooXFxcIlxcKSkkfFxcKSQpL2dpLCAvL2ZvciBwdWxsaW5nIG91dCB1cmxzIGZyb20gdXJsKC4uLikgb3IgdXJsKFwiLi4uXCIpIHN0cmluZ3MgKHNvbWUgYnJvd3NlcnMgd3JhcCB1cmxzIGluIHF1b3Rlcywgc29tZSBkb24ndCB3aGVuIHJlcG9ydGluZyB0aGluZ3MgbGlrZSBiYWNrZ3JvdW5kSW1hZ2UpXG5cdFx0XHRfY2FtZWxGdW5jID0gZnVuY3Rpb24ocywgZykgeyByZXR1cm4gZy50b1VwcGVyQ2FzZSgpOyB9LFxuXHRcdFx0X2hvcml6RXhwID0gLyg/OkxlZnR8UmlnaHR8V2lkdGgpL2ksXG5cdFx0XHRfaWVHZXRNYXRyaXhFeHAgPSAvKE0xMXxNMTJ8TTIxfE0yMik9W1xcZFxcLVxcLmVdKy9naSxcblx0XHRcdF9pZVNldE1hdHJpeEV4cCA9IC9wcm9naWRcXDpEWEltYWdlVHJhbnNmb3JtXFwuTWljcm9zb2Z0XFwuTWF0cml4XFwoLis/XFwpL2ksXG5cdFx0XHRfY29tbWFzT3V0c2lkZVBhcmVuRXhwID0gLywoPz1bXlxcKV0qKD86XFwofCQpKS9naSwgLy9maW5kcyBhbnkgY29tbWFzIHRoYXQgYXJlIG5vdCB3aXRoaW4gcGFyZW50aGVzaXNcblx0XHRcdF9jb21wbGV4RXhwID0gL1tcXHMsXFwoXS9pLCAvL2ZvciB0ZXN0aW5nIGEgc3RyaW5nIHRvIGZpbmQgaWYgaXQgaGFzIGEgc3BhY2UsIGNvbW1hLCBvciBvcGVuIHBhcmVudGhlc2lzIChjbHVlcyB0aGF0IGl0J3MgYSBjb21wbGV4IHZhbHVlKVxuXHRcdFx0X0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0X1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuXHRcdFx0X2ZvcmNlUFQgPSB7fSxcblx0XHRcdF9kb2MgPSBkb2N1bWVudCxcblx0XHRcdF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHRyZXR1cm4gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgdHlwZSkgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7XG5cdFx0XHR9LFxuXHRcdFx0X3RlbXBEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblx0XHRcdF90ZW1wSW1nID0gX2NyZWF0ZUVsZW1lbnQoXCJpbWdcIiksXG5cdFx0XHRfaW50ZXJuYWxzID0gQ1NTUGx1Z2luLl9pbnRlcm5hbHMgPSB7X3NwZWNpYWxQcm9wczpfc3BlY2lhbFByb3BzfSwgLy9wcm92aWRlcyBhIGhvb2sgdG8gYSBmZXcgaW50ZXJuYWwgbWV0aG9kcyB0aGF0IHdlIG5lZWQgdG8gYWNjZXNzIGZyb20gaW5zaWRlIG90aGVyIHBsdWdpbnNcblx0XHRcdF9hZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG5cdFx0XHRfYXV0b1JvdW5kLFxuXHRcdFx0X3JlcVNhZmFyaUZpeCwgLy93ZSB3b24ndCBhcHBseSB0aGUgU2FmYXJpIHRyYW5zZm9ybSBmaXggdW50aWwgd2UgYWN0dWFsbHkgY29tZSBhY3Jvc3MgYSB0d2VlbiB0aGF0IGFmZmVjdHMgYSB0cmFuc2Zvcm0gcHJvcGVydHkgKHRvIG1haW50YWluIGJlc3QgcGVyZm9ybWFuY2UpLlxuXG5cdFx0XHRfaXNTYWZhcmksXG5cdFx0XHRfaXNGaXJlZm94LCAvL0ZpcmVmb3ggaGFzIGEgYnVnIHRoYXQgY2F1c2VzIDNEIHRyYW5zZm9ybWVkIGVsZW1lbnRzIHRvIHJhbmRvbWx5IGRpc2FwcGVhciB1bmxlc3MgYSByZXBhaW50IGlzIGZvcmNlZCBhZnRlciBlYWNoIHVwZGF0ZSBvbiBlYWNoIGVsZW1lbnQuXG5cdFx0XHRfaXNTYWZhcmlMVDYsIC8vU2FmYXJpIChhbmQgQW5kcm9pZCA0IHdoaWNoIHVzZXMgYSBmbGF2b3Igb2YgU2FmYXJpKSBoYXMgYSBidWcgdGhhdCBwcmV2ZW50cyBjaGFuZ2VzIHRvIFwidG9wXCIgYW5kIFwibGVmdFwiIHByb3BlcnRpZXMgZnJvbSByZW5kZXJpbmcgcHJvcGVybHkgaWYgY2hhbmdlZCBvbiB0aGUgc2FtZSBmcmFtZSBhcyBhIHRyYW5zZm9ybSBVTkxFU1Mgd2Ugc2V0IHRoZSBlbGVtZW50J3MgV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IHRvIGhpZGRlbiAod2VpcmQsIEkga25vdykuIERvaW5nIHRoaXMgZm9yIEFuZHJvaWQgMyBhbmQgZWFybGllciBzZWVtcyB0byBhY3R1YWxseSBjYXVzZSBvdGhlciBwcm9ibGVtcywgdGhvdWdoIChmdW4hKVxuXHRcdFx0X2llVmVycyxcblx0XHRcdF9zdXBwb3J0c09wYWNpdHkgPSAoZnVuY3Rpb24oKSB7IC8vd2Ugc2V0IF9pc1NhZmFyaSwgX2llVmVycywgX2lzRmlyZWZveCwgYW5kIF9zdXBwb3J0c09wYWNpdHkgYWxsIGluIG9uZSBmdW5jdGlvbiBoZXJlIHRvIHJlZHVjZSBmaWxlIHNpemUgc2xpZ2h0bHksIGVzcGVjaWFsbHkgaW4gdGhlIG1pbmlmaWVkIHZlcnNpb24uXG5cdFx0XHRcdHZhciBpID0gX2FnZW50LmluZGV4T2YoXCJBbmRyb2lkXCIpLFxuXHRcdFx0XHRcdGEgPSBfY3JlYXRlRWxlbWVudChcImFcIik7XG5cdFx0XHRcdF9pc1NhZmFyaSA9IChfYWdlbnQuaW5kZXhPZihcIlNhZmFyaVwiKSAhPT0gLTEgJiYgX2FnZW50LmluZGV4T2YoXCJDaHJvbWVcIikgPT09IC0xICYmIChpID09PSAtMSB8fCBOdW1iZXIoX2FnZW50LnN1YnN0cihpKzgsIDEpKSA+IDMpKTtcblx0XHRcdFx0X2lzU2FmYXJpTFQ2ID0gKF9pc1NhZmFyaSAmJiAoTnVtYmVyKF9hZ2VudC5zdWJzdHIoX2FnZW50LmluZGV4T2YoXCJWZXJzaW9uL1wiKSs4LCAxKSkgPCA2KSk7XG5cdFx0XHRcdF9pc0ZpcmVmb3ggPSAoX2FnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpICE9PSAtMSk7XG5cdFx0XHRcdGlmICgoL01TSUUgKFswLTldezEsfVtcXC4wLTldezAsfSkvKS5leGVjKF9hZ2VudCkgfHwgKC9UcmlkZW50XFwvLipydjooWzAtOV17MSx9W1xcLjAtOV17MCx9KS8pLmV4ZWMoX2FnZW50KSkge1xuXHRcdFx0XHRcdF9pZVZlcnMgPSBwYXJzZUZsb2F0KCBSZWdFeHAuJDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWEpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5zdHlsZS5jc3NUZXh0ID0gXCJ0b3A6MXB4O29wYWNpdHk6LjU1O1wiO1xuXHRcdFx0XHRyZXR1cm4gL14wLjU1Ly50ZXN0KGEuc3R5bGUub3BhY2l0eSk7XG5cdFx0XHR9KCkpLFxuXHRcdFx0X2dldElFT3BhY2l0eSA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0cmV0dXJuIChfb3BhY2l0eUV4cC50ZXN0KCAoKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIikgPyB2IDogKHYuY3VycmVudFN0eWxlID8gdi5jdXJyZW50U3R5bGUuZmlsdGVyIDogdi5zdHlsZS5maWx0ZXIpIHx8IFwiXCIpICkgPyAoIHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApIC8gMTAwICkgOiAxKTtcblx0XHRcdH0sXG5cdFx0XHRfbG9nID0gZnVuY3Rpb24ocykgey8vZm9yIGxvZ2dpbmcgbWVzc2FnZXMsIGJ1dCBpbiBhIHdheSB0aGF0IHdvbid0IHRocm93IGVycm9ycyBpbiBvbGQgdmVyc2lvbnMgb2YgSUUuXG5cdFx0XHRcdGlmICh3aW5kb3cuY29uc29sZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfcHJlZml4Q1NTID0gXCJcIiwgLy90aGUgbm9uLWNhbWVsQ2FzZSB2ZW5kb3IgcHJlZml4IGxpa2UgXCItby1cIiwgXCItbW96LVwiLCBcIi1tcy1cIiwgb3IgXCItd2Via2l0LVwiXG5cdFx0XHRfcHJlZml4ID0gXCJcIiwgLy9jYW1lbENhc2UgdmVuZG9yIHByZWZpeCBsaWtlIFwiT1wiLCBcIm1zXCIsIFwiV2Via2l0XCIsIG9yIFwiTW96XCIuXG5cblx0XHRcdC8vIEBwcml2YXRlIGZlZWQgaW4gYSBjYW1lbENhc2UgcHJvcGVydHkgbmFtZSBsaWtlIFwidHJhbnNmb3JtXCIgYW5kIGl0IHdpbGwgY2hlY2sgdG8gc2VlIGlmIGl0IGlzIHZhbGlkIGFzLWlzIG9yIGlmIGl0IG5lZWRzIGEgdmVuZG9yIHByZWZpeC4gSXQgcmV0dXJucyB0aGUgY29ycmVjdGVkIGNhbWVsQ2FzZSBwcm9wZXJ0eSBuYW1lIChpLmUuIFwiV2Via2l0VHJhbnNmb3JtXCIgb3IgXCJNb3pUcmFuc2Zvcm1cIiBvciBcInRyYW5zZm9ybVwiIG9yIG51bGwgaWYgbm8gc3VjaCBwcm9wZXJ0eSBpcyBmb3VuZCwgbGlrZSBpZiB0aGUgYnJvd3NlciBpcyBJRTggb3IgYmVmb3JlLCBcInRyYW5zZm9ybVwiIHdvbid0IGJlIGZvdW5kIGF0IGFsbClcblx0XHRcdF9jaGVja1Byb3BQcmVmaXggPSBmdW5jdGlvbihwLCBlKSB7XG5cdFx0XHRcdGUgPSBlIHx8IF90ZW1wRGl2O1xuXHRcdFx0XHR2YXIgcyA9IGUuc3R5bGUsXG5cdFx0XHRcdFx0YSwgaTtcblx0XHRcdFx0aWYgKHNbcF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHAgPSBwLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcC5zdWJzdHIoMSk7XG5cdFx0XHRcdGEgPSBbXCJPXCIsXCJNb3pcIixcIm1zXCIsXCJNc1wiLFwiV2Via2l0XCJdO1xuXHRcdFx0XHRpID0gNTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xICYmIHNbYVtpXStwXSA9PT0gdW5kZWZpbmVkKSB7IH1cblx0XHRcdFx0aWYgKGkgPj0gMCkge1xuXHRcdFx0XHRcdF9wcmVmaXggPSAoaSA9PT0gMykgPyBcIm1zXCIgOiBhW2ldO1xuXHRcdFx0XHRcdF9wcmVmaXhDU1MgPSBcIi1cIiArIF9wcmVmaXgudG9Mb3dlckNhc2UoKSArIFwiLVwiO1xuXHRcdFx0XHRcdHJldHVybiBfcHJlZml4ICsgcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdF9nZXRDb21wdXRlZFN0eWxlID0gX2RvYy5kZWZhdWx0VmlldyA/IF9kb2MuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSA6IGZ1bmN0aW9uKCkge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgUmV0dXJucyB0aGUgY3NzIHN0eWxlIGZvciBhIHBhcnRpY3VsYXIgcHJvcGVydHkgb2YgYW4gZWxlbWVudC4gRm9yIGV4YW1wbGUsIHRvIGdldCB3aGF0ZXZlciB0aGUgY3VycmVudCBcImxlZnRcIiBjc3MgdmFsdWUgZm9yIGFuIGVsZW1lbnQgd2l0aCBhbiBJRCBvZiBcIm15RWxlbWVudFwiLCB5b3UgY291bGQgZG86XG5cdFx0XHQgKiB2YXIgY3VycmVudExlZnQgPSBDU1NQbHVnaW4uZ2V0U3R5bGUoIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlFbGVtZW50XCIpLCBcImxlZnRcIik7XG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBlbGVtZW50IHdob3NlIHN0eWxlIHByb3BlcnR5IHlvdSB3YW50IHRvIHF1ZXJ5XG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZSAobGlrZSBcImxlZnRcIiBvciBcInRvcFwiIG9yIFwibWFyZ2luVG9wXCIsIGV0Yy4pXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGNzIENvbXB1dGVkIHN0eWxlIG9iamVjdC4gVGhpcyBqdXN0IHByb3ZpZGVzIGEgd2F5IHRvIHNwZWVkIHByb2Nlc3NpbmcgaWYgeW91J3JlIGdvaW5nIHRvIGdldCBzZXZlcmFsIHByb3BlcnRpZXMgb24gdGhlIHNhbWUgZWxlbWVudCBpbiBxdWljayBzdWNjZXNzaW9uIC0geW91IGNhbiByZXVzZSB0aGUgcmVzdWx0IG9mIHRoZSBnZXRDb21wdXRlZFN0eWxlKCkgY2FsbC5cblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGNhbGMgSWYgdHJ1ZSwgdGhlIHZhbHVlIHdpbGwgbm90IGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgZWxlbWVudCdzIFwic3R5bGVcIiBwcm9wZXJ0eSAoaWYgaXQgZXhpc3RzIHRoZXJlKSwgYnV0IGluc3RlYWQgdGhlIGdldENvbXB1dGVkU3R5bGUoKSByZXN1bHQgd2lsbCBiZSB1c2VkLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCB0aGUgYnJvd3NlciBpdHNlbGYgaXMgaW50ZXJwcmV0aW5nIHRoZSB2YWx1ZS5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gZGZsdCBEZWZhdWx0IHZhbHVlIHRoYXQgc2hvdWxkIGJlIHJldHVybmVkIGluIHRoZSBwbGFjZSBvZiBudWxsLCBcIm5vbmVcIiwgXCJhdXRvXCIgb3IgXCJhdXRvIGF1dG9cIi5cblx0XHRcdCAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBjdXJyZW50IHByb3BlcnR5IHZhbHVlXG5cdFx0XHQgKi9cblx0XHRcdF9nZXRTdHlsZSA9IENTU1BsdWdpbi5nZXRTdHlsZSA9IGZ1bmN0aW9uKHQsIHAsIGNzLCBjYWxjLCBkZmx0KSB7XG5cdFx0XHRcdHZhciBydjtcblx0XHRcdFx0aWYgKCFfc3VwcG9ydHNPcGFjaXR5KSBpZiAocCA9PT0gXCJvcGFjaXR5XCIpIHsgLy9zZXZlcmFsIHZlcnNpb25zIG9mIElFIGRvbid0IHVzZSB0aGUgc3RhbmRhcmQgXCJvcGFjaXR5XCIgcHJvcGVydHkgLSB0aGV5IHVzZSB0aGluZ3MgbGlrZSBmaWx0ZXI6YWxwaGEob3BhY2l0eT01MCksIHNvIHdlIHBhcnNlIHRoYXQgaGVyZS5cblx0XHRcdFx0XHRyZXR1cm4gX2dldElFT3BhY2l0eSh0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWNhbGMgJiYgdC5zdHlsZVtwXSkge1xuXHRcdFx0XHRcdHJ2ID0gdC5zdHlsZVtwXTtcblx0XHRcdFx0fSBlbHNlIGlmICgoY3MgPSBjcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0KSkpIHtcblx0XHRcdFx0XHRydiA9IGNzW3BdIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocCkgfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQuY3VycmVudFN0eWxlKSB7XG5cdFx0XHRcdFx0cnYgPSB0LmN1cnJlbnRTdHlsZVtwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKGRmbHQgIT0gbnVsbCAmJiAoIXJ2IHx8IHJ2ID09PSBcIm5vbmVcIiB8fCBydiA9PT0gXCJhdXRvXCIgfHwgcnYgPT09IFwiYXV0byBhdXRvXCIpKSA/IGRmbHQgOiBydjtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgUGFzcyB0aGUgdGFyZ2V0IGVsZW1lbnQsIHRoZSBwcm9wZXJ0eSBuYW1lLCB0aGUgbnVtZXJpYyB2YWx1ZSwgYW5kIHRoZSBzdWZmaXggKGxpa2UgXCIlXCIsIFwiZW1cIiwgXCJweFwiLCBldGMuKSBhbmQgaXQgd2lsbCBzcGl0IGJhY2sgdGhlIGVxdWl2YWxlbnQgcGl4ZWwgbnVtYmVyLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZSAobGlrZSBcImxlZnRcIiwgXCJ0b3BcIiwgXCJtYXJnaW5MZWZ0XCIsIGV0Yy4pXG5cdFx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IHYgVmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gc2Z4IFN1ZmZpeCAobGlrZSBcInB4XCIgb3IgXCIlXCIgb3IgXCJlbVwiKVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcmVjdXJzZSBJZiB0cnVlLCB0aGUgY2FsbCBpcyBhIHJlY3Vyc2l2ZSBvbmUuIEluIHNvbWUgYnJvd3NlcnMgKGxpa2UgSUU3LzgpLCBvY2Nhc2lvbmFsbHkgdGhlIHZhbHVlIGlzbid0IGFjY3VyYXRlbHkgcmVwb3J0ZWQgaW5pdGlhbGx5LCBidXQgaWYgd2UgcnVuIHRoZSBmdW5jdGlvbiBhZ2FpbiBpdCB3aWxsIHRha2UgZWZmZWN0LlxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSB2YWx1ZSBpbiBwaXhlbHNcblx0XHRcdCAqL1xuXHRcdFx0X2NvbnZlcnRUb1BpeGVscyA9IF9pbnRlcm5hbHMuY29udmVydFRvUGl4ZWxzID0gZnVuY3Rpb24odCwgcCwgdiwgc2Z4LCByZWN1cnNlKSB7XG5cdFx0XHRcdGlmIChzZnggPT09IFwicHhcIiB8fCAhc2Z4KSB7IHJldHVybiB2OyB9XG5cdFx0XHRcdGlmIChzZnggPT09IFwiYXV0b1wiIHx8ICF2KSB7IHJldHVybiAwOyB9XG5cdFx0XHRcdHZhciBob3JpeiA9IF9ob3JpekV4cC50ZXN0KHApLFxuXHRcdFx0XHRcdG5vZGUgPSB0LFxuXHRcdFx0XHRcdHN0eWxlID0gX3RlbXBEaXYuc3R5bGUsXG5cdFx0XHRcdFx0bmVnID0gKHYgPCAwKSxcblx0XHRcdFx0XHRwaXgsIGNhY2hlLCB0aW1lO1xuXHRcdFx0XHRpZiAobmVnKSB7XG5cdFx0XHRcdFx0diA9IC12O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzZnggPT09IFwiJVwiICYmIHAuaW5kZXhPZihcImJvcmRlclwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRwaXggPSAodiAvIDEwMCkgKiAoaG9yaXogPyB0LmNsaWVudFdpZHRoIDogdC5jbGllbnRIZWlnaHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowIHNvbGlkIHJlZDtwb3NpdGlvbjpcIiArIF9nZXRTdHlsZSh0LCBcInBvc2l0aW9uXCIpICsgXCI7bGluZS1oZWlnaHQ6MDtcIjtcblx0XHRcdFx0XHRpZiAoc2Z4ID09PSBcIiVcIiB8fCAhbm9kZS5hcHBlbmRDaGlsZCB8fCBzZnguY2hhckF0KDApID09PSBcInZcIiB8fCBzZnggPT09IFwicmVtXCIpIHtcblx0XHRcdFx0XHRcdG5vZGUgPSB0LnBhcmVudE5vZGUgfHwgX2RvYy5ib2R5O1xuXHRcdFx0XHRcdFx0Y2FjaGUgPSBub2RlLl9nc0NhY2hlO1xuXHRcdFx0XHRcdFx0dGltZSA9IFR3ZWVuTGl0ZS50aWNrZXIuZnJhbWU7XG5cdFx0XHRcdFx0XHRpZiAoY2FjaGUgJiYgaG9yaXogJiYgY2FjaGUudGltZSA9PT0gdGltZSkgeyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogd2UgcmVjb3JkIHRoZSB3aWR0aCBvZiBlbGVtZW50cyBhbG9uZyB3aXRoIHRoZSB0aWNrZXIgZnJhbWUgc28gdGhhdCB3ZSBjYW4gcXVpY2tseSBnZXQgaXQgYWdhaW4gb24gdGhlIHNhbWUgdGljayAoc2VlbXMgcmVsYXRpdmVseSBzYWZlIHRvIGFzc3VtZSBpdCB3b3VsZG4ndCBjaGFuZ2Ugb24gdGhlIHNhbWUgdGljaylcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNhY2hlLndpZHRoICogdiAvIDEwMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0eWxlWyhob3JpeiA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIpXSA9IHYgKyBzZng7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlWyhob3JpeiA/IFwiYm9yZGVyTGVmdFdpZHRoXCIgOiBcImJvcmRlclRvcFdpZHRoXCIpXSA9IHYgKyBzZng7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRcdHBpeCA9IHBhcnNlRmxvYXQoX3RlbXBEaXZbKGhvcml6ID8gXCJvZmZzZXRXaWR0aFwiIDogXCJvZmZzZXRIZWlnaHRcIildKTtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKF90ZW1wRGl2KTtcblx0XHRcdFx0XHRpZiAoaG9yaXogJiYgc2Z4ID09PSBcIiVcIiAmJiBDU1NQbHVnaW4uY2FjaGVXaWR0aHMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRjYWNoZSA9IG5vZGUuX2dzQ2FjaGUgPSBub2RlLl9nc0NhY2hlIHx8IHt9O1xuXHRcdFx0XHRcdFx0Y2FjaGUudGltZSA9IHRpbWU7XG5cdFx0XHRcdFx0XHRjYWNoZS53aWR0aCA9IHBpeCAvIHYgKiAxMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwaXggPT09IDAgJiYgIXJlY3Vyc2UpIHtcblx0XHRcdFx0XHRcdHBpeCA9IF9jb252ZXJ0VG9QaXhlbHModCwgcCwgdiwgc2Z4LCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5lZyA/IC1waXggOiBwaXg7XG5cdFx0XHR9LFxuXHRcdFx0X2NhbGN1bGF0ZU9mZnNldCA9IF9pbnRlcm5hbHMuY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24odCwgcCwgY3MpIHsgLy9mb3IgZmlndXJpbmcgb3V0IFwidG9wXCIgb3IgXCJsZWZ0XCIgaW4gcHggd2hlbiBpdCdzIFwiYXV0b1wiLiBXZSBuZWVkIHRvIGZhY3RvciBpbiBtYXJnaW4gd2l0aCB0aGUgb2Zmc2V0TGVmdC9vZmZzZXRUb3Bcblx0XHRcdFx0aWYgKF9nZXRTdHlsZSh0LCBcInBvc2l0aW9uXCIsIGNzKSAhPT0gXCJhYnNvbHV0ZVwiKSB7IHJldHVybiAwOyB9XG5cdFx0XHRcdHZhciBkaW0gPSAoKHAgPT09IFwibGVmdFwiKSA/IFwiTGVmdFwiIDogXCJUb3BcIiksXG5cdFx0XHRcdFx0diA9IF9nZXRTdHlsZSh0LCBcIm1hcmdpblwiICsgZGltLCBjcyk7XG5cdFx0XHRcdHJldHVybiB0W1wib2Zmc2V0XCIgKyBkaW1dIC0gKF9jb252ZXJ0VG9QaXhlbHModCwgcCwgcGFyc2VGbG9hdCh2KSwgdi5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpKSB8fCAwKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBwcml2YXRlIHJldHVybnMgYXQgb2JqZWN0IGNvbnRhaW5pbmcgQUxMIG9mIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGluIGNhbWVsQ2FzZSBhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMuXG5cdFx0XHRfZ2V0QWxsU3R5bGVzID0gZnVuY3Rpb24odCwgY3MpIHtcblx0XHRcdFx0dmFyIHMgPSB7fSxcblx0XHRcdFx0XHRpLCB0ciwgcDtcblx0XHRcdFx0aWYgKChjcyA9IGNzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpKSkge1xuXHRcdFx0XHRcdGlmICgoaSA9IGNzLmxlbmd0aCkpIHtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRwID0gY3NbaV07XG5cdFx0XHRcdFx0XHRcdGlmIChwLmluZGV4T2YoXCItdHJhbnNmb3JtXCIpID09PSAtMSB8fCBfdHJhbnNmb3JtUHJvcENTUyA9PT0gcCkgeyAvL1NvbWUgd2Via2l0IGJyb3dzZXJzIGR1cGxpY2F0ZSB0cmFuc2Zvcm0gdmFsdWVzLCBvbmUgbm9uLXByZWZpeGVkIGFuZCBvbmUgcHJlZml4ZWQgKFwidHJhbnNmb3JtXCIgYW5kIFwiV2Via2l0VHJhbnNmb3JtXCIpLCBzbyB3ZSBtdXN0IHdlZWQgb3V0IHRoZSBleHRyYSBvbmUgaGVyZS5cblx0XHRcdFx0XHRcdFx0XHRzW3AucmVwbGFjZShfY2FtZWxFeHAsIF9jYW1lbEZ1bmMpXSA9IGNzLmdldFByb3BlcnR5VmFsdWUocCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgeyAvL3NvbWUgYnJvd3NlcnMgYmVoYXZlIGRpZmZlcmVudGx5IC0gY3MubGVuZ3RoIGlzIGFsd2F5cyAwLCBzbyB3ZSBtdXN0IGRvIGEgZm9yLi4uaW4gbG9vcC5cblx0XHRcdFx0XHRcdGZvciAoaSBpbiBjcykge1xuXHRcdFx0XHRcdFx0XHRpZiAoaS5pbmRleE9mKFwiVHJhbnNmb3JtXCIpID09PSAtMSB8fCBfdHJhbnNmb3JtUHJvcCA9PT0gaSkgeyAvL1NvbWUgd2Via2l0IGJyb3dzZXJzIGR1cGxpY2F0ZSB0cmFuc2Zvcm0gdmFsdWVzLCBvbmUgbm9uLXByZWZpeGVkIGFuZCBvbmUgcHJlZml4ZWQgKFwidHJhbnNmb3JtXCIgYW5kIFwiV2Via2l0VHJhbnNmb3JtXCIpLCBzbyB3ZSBtdXN0IHdlZWQgb3V0IHRoZSBleHRyYSBvbmUgaGVyZS5cblx0XHRcdFx0XHRcdFx0XHRzW2ldID0gY3NbaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGNzID0gdC5jdXJyZW50U3R5bGUgfHwgdC5zdHlsZSkpIHtcblx0XHRcdFx0XHRmb3IgKGkgaW4gY3MpIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoaSkgPT09IFwic3RyaW5nXCIgJiYgc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHNbaS5yZXBsYWNlKF9jYW1lbEV4cCwgX2NhbWVsRnVuYyldID0gY3NbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkge1xuXHRcdFx0XHRcdHMub3BhY2l0eSA9IF9nZXRJRU9wYWNpdHkodCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHIgPSBfZ2V0VHJhbnNmb3JtKHQsIGNzLCBmYWxzZSk7XG5cdFx0XHRcdHMucm90YXRpb24gPSB0ci5yb3RhdGlvbjtcblx0XHRcdFx0cy5za2V3WCA9IHRyLnNrZXdYO1xuXHRcdFx0XHRzLnNjYWxlWCA9IHRyLnNjYWxlWDtcblx0XHRcdFx0cy5zY2FsZVkgPSB0ci5zY2FsZVk7XG5cdFx0XHRcdHMueCA9IHRyLng7XG5cdFx0XHRcdHMueSA9IHRyLnk7XG5cdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdHMueiA9IHRyLno7XG5cdFx0XHRcdFx0cy5yb3RhdGlvblggPSB0ci5yb3RhdGlvblg7XG5cdFx0XHRcdFx0cy5yb3RhdGlvblkgPSB0ci5yb3RhdGlvblk7XG5cdFx0XHRcdFx0cy5zY2FsZVogPSB0ci5zY2FsZVo7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHMuZmlsdGVycykge1xuXHRcdFx0XHRcdGRlbGV0ZSBzLmZpbHRlcnM7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSBhbmFseXplcyB0d28gc3R5bGUgb2JqZWN0cyAoYXMgcmV0dXJuZWQgYnkgX2dldEFsbFN0eWxlcygpKSBhbmQgb25seSBsb29rcyBmb3IgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGVtIHRoYXQgY29udGFpbiB0d2VlbmFibGUgdmFsdWVzIChsaWtlIGEgbnVtYmVyIG9yIGNvbG9yKS4gSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIFwiZGlmc1wiIHByb3BlcnR5IHdoaWNoIHJlZmVycyB0byBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IHRob3NlIGlzb2xhdGVkIHByb3BlcnRpZXMgYW5kIHZhbHVlcyBmb3IgdHdlZW5pbmcsIGFuZCBhIFwiZmlyc3RNUFRcIiBwcm9wZXJ0eSB3aGljaCByZWZlcnMgdG8gdGhlIGZpcnN0IE1pbmlQcm9wVHdlZW4gaW5zdGFuY2UgaW4gYSBsaW5rZWQgbGlzdCB0aGF0IHJlY29yZGVkIGFsbCB0aGUgc3RhcnRpbmcgdmFsdWVzIG9mIHRoZSBkaWZmZXJlbnQgcHJvcGVydGllcyBzbyB0aGF0IHdlIGNhbiByZXZlcnQgdG8gdGhlbSBhdCB0aGUgZW5kIG9yIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gLSB3ZSBkb24ndCB3YW50IHRoZSBjYXNjYWRpbmcgdG8gZ2V0IG1lc3NlZCB1cC4gVGhlIGZvcmNlTG9va3VwIHBhcmFtZXRlciBpcyBhbiBvcHRpb25hbCBnZW5lcmljIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgZm9yY2VkIGludG8gdGhlIHJlc3VsdHMgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY2xhc3NOYW1lIHR3ZWVucyB0aGF0IGFyZSBvdmVyd3JpdGluZyBvdGhlcnMgYmVjYXVzZSBpbWFnaW5lIGEgc2NlbmFyaW8gd2hlcmUgYSByb2xsb3Zlci9yb2xsb3V0IGFkZHMvcmVtb3ZlcyBhIGNsYXNzIGFuZCB0aGUgdXNlciBzd2lwZXMgdGhlIG1vdXNlIG92ZXIgdGhlIHRhcmdldCBTVVBFUiBmYXN0LCB0aHVzIG5vdGhpbmcgYWN0dWFsbHkgY2hhbmdlZCB5ZXQgYW5kIHRoZSBzdWJzZXF1ZW50IGNvbXBhcmlzb24gb2YgdGhlIHByb3BlcnRpZXMgd291bGQgaW5kaWNhdGUgdGhleSBtYXRjaCAoZXNwZWNpYWxseSB3aGVuIHB4IHJvdW5kaW5nIGlzIHRha2VuIGludG8gY29uc2lkZXJhdGlvbiksIHRodXMgbm8gdHdlZW5pbmcgaXMgbmVjZXNzYXJ5IGV2ZW4gdGhvdWdoIGl0IFNIT1VMRCB0d2VlbiBhbmQgcmVtb3ZlIHRob3NlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIHR3ZWVuIChvdGhlcndpc2UgdGhlIGlubGluZSBzdHlsZXMgd2lsbCBjb250YW1pbmF0ZSB0aGluZ3MpLiBTZWUgdGhlIGNsYXNzTmFtZSBTcGVjaWFsUHJvcCBjb2RlIGZvciBkZXRhaWxzLlxuXHRcdFx0X2Nzc0RpZiA9IGZ1bmN0aW9uKHQsIHMxLCBzMiwgdmFycywgZm9yY2VMb29rdXApIHtcblx0XHRcdFx0dmFyIGRpZnMgPSB7fSxcblx0XHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdFx0dmFsLCBwLCBtcHQ7XG5cdFx0XHRcdGZvciAocCBpbiBzMikge1xuXHRcdFx0XHRcdGlmIChwICE9PSBcImNzc1RleHRcIikgaWYgKHAgIT09IFwibGVuZ3RoXCIpIGlmIChpc05hTihwKSkgaWYgKHMxW3BdICE9PSAodmFsID0gczJbcF0pIHx8IChmb3JjZUxvb2t1cCAmJiBmb3JjZUxvb2t1cFtwXSkpIGlmIChwLmluZGV4T2YoXCJPcmlnaW5cIikgPT09IC0xKSBpZiAodHlwZW9mKHZhbCkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mKHZhbCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdGRpZnNbcF0gPSAodmFsID09PSBcImF1dG9cIiAmJiAocCA9PT0gXCJsZWZ0XCIgfHwgcCA9PT0gXCJ0b3BcIikpID8gX2NhbGN1bGF0ZU9mZnNldCh0LCBwKSA6ICgodmFsID09PSBcIlwiIHx8IHZhbCA9PT0gXCJhdXRvXCIgfHwgdmFsID09PSBcIm5vbmVcIikgJiYgdHlwZW9mKHMxW3BdKSA9PT0gXCJzdHJpbmdcIiAmJiBzMVtwXS5yZXBsYWNlKF9OYU5FeHAsIFwiXCIpICE9PSBcIlwiKSA/IDAgOiB2YWw7IC8vaWYgdGhlIGVuZGluZyB2YWx1ZSBpcyBkZWZhdWx0aW5nIChcIlwiIG9yIFwiYXV0b1wiKSwgd2UgY2hlY2sgdGhlIHN0YXJ0aW5nIHZhbHVlIGFuZCBpZiBpdCBjYW4gYmUgcGFyc2VkIGludG8gYSBudW1iZXIgKGEgc3RyaW5nIHdoaWNoIGNvdWxkIGhhdmUgYSBzdWZmaXggdG9vLCBsaWtlIDcwMHB4KSwgdGhlbiB3ZSBzd2FwIGluIDAgZm9yIFwiXCIgb3IgXCJhdXRvXCIgc28gdGhhdCB0aGluZ3MgYWN0dWFsbHkgdHdlZW4uXG5cdFx0XHRcdFx0XHRpZiAoc3R5bGVbcF0gIT09IHVuZGVmaW5lZCkgeyAvL2ZvciBjbGFzc05hbWUgdHdlZW5zLCB3ZSBtdXN0IHJlbWVtYmVyIHdoaWNoIHByb3BlcnRpZXMgYWxyZWFkeSBleGlzdGVkIGlubGluZSAtIHRoZSBvbmVzIHRoYXQgZGlkbid0IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gdGhlIHR3ZWVuIGlzbid0IGluIHByb2dyZXNzIGJlY2F1c2UgdGhleSB3ZXJlIG9ubHkgaW50cm9kdWNlZCB0byBmYWNpbGl0YXRlIHRoZSB0cmFuc2l0aW9uIGJldHdlZW4gY2xhc3Nlcy5cblx0XHRcdFx0XHRcdFx0bXB0ID0gbmV3IE1pbmlQcm9wVHdlZW4oc3R5bGUsIHAsIHN0eWxlW3BdLCBtcHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFycykge1xuXHRcdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7IC8vY29weSBwcm9wZXJ0aWVzIChleGNlcHQgY2xhc3NOYW1lKVxuXHRcdFx0XHRcdFx0aWYgKHAgIT09IFwiY2xhc3NOYW1lXCIpIHtcblx0XHRcdFx0XHRcdFx0ZGlmc1twXSA9IHZhcnNbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7ZGlmczpkaWZzLCBmaXJzdE1QVDptcHR9O1xuXHRcdFx0fSxcblx0XHRcdF9kaW1lbnNpb25zID0ge3dpZHRoOltcIkxlZnRcIixcIlJpZ2h0XCJdLCBoZWlnaHQ6W1wiVG9wXCIsXCJCb3R0b21cIl19LFxuXHRcdFx0X21hcmdpbnMgPSBbXCJtYXJnaW5MZWZ0XCIsXCJtYXJnaW5SaWdodFwiLFwibWFyZ2luVG9wXCIsXCJtYXJnaW5Cb3R0b21cIl0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgR2V0cyB0aGUgd2lkdGggb3IgaGVpZ2h0IG9mIGFuIGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKFwid2lkdGhcIiBvciBcImhlaWdodFwiKVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBDb21wdXRlZCBzdHlsZSBvYmplY3QgKGlmIG9uZSBleGlzdHMpLiBKdXN0IGEgc3BlZWQgb3B0aW1pemF0aW9uLlxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBEaW1lbnNpb24gKGluIHBpeGVscylcblx0XHRcdCAqL1xuXHRcdFx0X2dldERpbWVuc2lvbiA9IGZ1bmN0aW9uKHQsIHAsIGNzKSB7XG5cdFx0XHRcdGlmICgodC5ub2RlTmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIpIHsgLy9DaHJvbWUgbm8gbG9uZ2VyIHN1cHBvcnRzIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBvbiBTVkcgZWxlbWVudHMuXG5cdFx0XHRcdFx0cmV0dXJuIChjcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0KSlbcF0gfHwgMDtcblx0XHRcdFx0fSBlbHNlIGlmICh0LmdldEJCb3ggJiYgX2lzU1ZHKHQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHQuZ2V0QkJveCgpW3BdIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHYgPSBwYXJzZUZsb2F0KChwID09PSBcIndpZHRoXCIpID8gdC5vZmZzZXRXaWR0aCA6IHQub2Zmc2V0SGVpZ2h0KSxcblx0XHRcdFx0XHRhID0gX2RpbWVuc2lvbnNbcF0sXG5cdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRjcyA9IGNzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR2IC09IHBhcnNlRmxvYXQoIF9nZXRTdHlsZSh0LCBcInBhZGRpbmdcIiArIGFbaV0sIGNzLCB0cnVlKSApIHx8IDA7XG5cdFx0XHRcdFx0diAtPSBwYXJzZUZsb2F0KCBfZ2V0U3R5bGUodCwgXCJib3JkZXJcIiArIGFbaV0gKyBcIldpZHRoXCIsIGNzLCB0cnVlKSApIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSBQYXJzZXMgcG9zaXRpb24tcmVsYXRlZCBjb21wbGV4IHN0cmluZ3MgbGlrZSBcInRvcCBsZWZ0XCIgb3IgXCI1MHB4IDEwcHhcIiBvciBcIjcwJSAyMCVcIiwgZXRjLiB3aGljaCBhcmUgdXNlZCBmb3IgdGhpbmdzIGxpa2UgdHJhbnNmb3JtT3JpZ2luIG9yIGJhY2tncm91bmRQb3NpdGlvbi4gT3B0aW9uYWxseSBkZWNvcmF0ZXMgYSBzdXBwbGllZCBvYmplY3QgKHJlY09iaikgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IFwib3hcIiAob2Zmc2V0WCksIFwib3lcIiAob2Zmc2V0WSksIFwib3hwXCIgKGlmIHRydWUsIFwib3hcIiBpcyBhIHBlcmNlbnRhZ2Ugbm90IGEgcGl4ZWwgdmFsdWUpLCBhbmQgXCJveHlcIiAoaWYgdHJ1ZSwgXCJveVwiIGlzIGEgcGVyY2VudGFnZSBub3QgYSBwaXhlbCB2YWx1ZSlcblx0XHRcdF9wYXJzZVBvc2l0aW9uID0gZnVuY3Rpb24odiwgcmVjT2JqKSB7XG5cdFx0XHRcdGlmICh2ID09PSBcImNvbnRhaW5cIiB8fCB2ID09PSBcImF1dG9cIiB8fCB2ID09PSBcImF1dG8gYXV0b1wiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHYgKyBcIiBcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodiA9PSBudWxsIHx8IHYgPT09IFwiXCIpIHsgLy9ub3RlOiBGaXJlZm94IHVzZXMgXCJhdXRvIGF1dG9cIiBhcyBkZWZhdWx0IHdoZXJlYXMgQ2hyb21lIHVzZXMgXCJhdXRvXCIuXG5cdFx0XHRcdFx0diA9IFwiMCAwXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGEgPSB2LnNwbGl0KFwiIFwiKSxcblx0XHRcdFx0XHR4ID0gKHYuaW5kZXhPZihcImxlZnRcIikgIT09IC0xKSA/IFwiMCVcIiA6ICh2LmluZGV4T2YoXCJyaWdodFwiKSAhPT0gLTEpID8gXCIxMDAlXCIgOiBhWzBdLFxuXHRcdFx0XHRcdHkgPSAodi5pbmRleE9mKFwidG9wXCIpICE9PSAtMSkgPyBcIjAlXCIgOiAodi5pbmRleE9mKFwiYm90dG9tXCIpICE9PSAtMSkgPyBcIjEwMCVcIiA6IGFbMV0sXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0aWYgKGEubGVuZ3RoID4gMyAmJiAhcmVjT2JqKSB7IC8vbXVsdGlwbGUgcG9zaXRpb25zXG5cdFx0XHRcdFx0YSA9IHYuc3BsaXQoXCIsIFwiKS5qb2luKFwiLFwiKS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0diA9IFtdO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2LnB1c2goX3BhcnNlUG9zaXRpb24oYVtpXSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdi5qb2luKFwiLFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0eSA9ICh4ID09PSBcImNlbnRlclwiKSA/IFwiNTAlXCIgOiBcIjBcIjtcblx0XHRcdFx0fSBlbHNlIGlmICh5ID09PSBcImNlbnRlclwiKSB7XG5cdFx0XHRcdFx0eSA9IFwiNTAlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHggPT09IFwiY2VudGVyXCIgfHwgKGlzTmFOKHBhcnNlRmxvYXQoeCkpICYmICh4ICsgXCJcIikuaW5kZXhPZihcIj1cIikgPT09IC0xKSkgeyAvL3JlbWVtYmVyLCB0aGUgdXNlciBjb3VsZCBmbGlwLWZsb3AgdGhlIHZhbHVlcyBhbmQgc2F5IFwiYm90dG9tIGNlbnRlclwiIG9yIFwiY2VudGVyIGJvdHRvbVwiLCBldGMuIFwiY2VudGVyXCIgaXMgYW1iaWd1b3VzIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZCB0byBkZXNjcmliZSBob3Jpem9udGFsIG9yIHZlcnRpY2FsLCBoZW5jZSB0aGUgaXNOYU4oKS4gSWYgdGhlcmUncyBhbiBcIj1cIiBzaWduIGluIHRoZSB2YWx1ZSwgaXQncyByZWxhdGl2ZS5cblx0XHRcdFx0XHR4ID0gXCI1MCVcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ID0geCArIFwiIFwiICsgeSArICgoYS5sZW5ndGggPiAyKSA/IFwiIFwiICsgYVsyXSA6IFwiXCIpO1xuXHRcdFx0XHRpZiAocmVjT2JqKSB7XG5cdFx0XHRcdFx0cmVjT2JqLm94cCA9ICh4LmluZGV4T2YoXCIlXCIpICE9PSAtMSk7XG5cdFx0XHRcdFx0cmVjT2JqLm95cCA9ICh5LmluZGV4T2YoXCIlXCIpICE9PSAtMSk7XG5cdFx0XHRcdFx0cmVjT2JqLm94ciA9ICh4LmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdHJlY09iai5veXIgPSAoeS5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0XHRyZWNPYmoub3ggPSBwYXJzZUZsb2F0KHgucmVwbGFjZShfTmFORXhwLCBcIlwiKSk7XG5cdFx0XHRcdFx0cmVjT2JqLm95ID0gcGFyc2VGbG9hdCh5LnJlcGxhY2UoX05hTkV4cCwgXCJcIikpO1xuXHRcdFx0XHRcdHJlY09iai52ID0gdjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVjT2JqIHx8IHY7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFRha2VzIGFuIGVuZGluZyB2YWx1ZSAodHlwaWNhbGx5IGEgc3RyaW5nLCBidXQgY2FuIGJlIGEgbnVtYmVyKSBhbmQgYSBzdGFydGluZyB2YWx1ZSBhbmQgcmV0dXJucyB0aGUgY2hhbmdlIGJldHdlZW4gdGhlIHR3bywgbG9va2luZyBmb3IgcmVsYXRpdmUgdmFsdWUgaW5kaWNhdG9ycyBsaWtlICs9IGFuZCAtPSBhbmQgaXQgYWxzbyBpZ25vcmVzIHN1ZmZpeGVzIChidXQgbWFrZSBzdXJlIHRoZSBlbmRpbmcgdmFsdWUgc3RhcnRzIHdpdGggYSBudW1iZXIgb3IgKz0vLT0gYW5kIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlIGlzIGEgTlVNQkVSISlcblx0XHRcdCAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBlIEVuZCB2YWx1ZSB3aGljaCBpcyB0eXBpY2FsbHkgYSBzdHJpbmcsIGJ1dCBjb3VsZCBiZSBhIG51bWJlclxuXHRcdFx0ICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyl9IGIgQmVnaW5uaW5nIHZhbHVlIHdoaWNoIGlzIHR5cGljYWxseSBhIHN0cmluZyBidXQgY291bGQgYmUgYSBudW1iZXJcblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gQW1vdW50IG9mIGNoYW5nZSBiZXR3ZWVuIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgKHJlbGF0aXZlIHZhbHVlcyB0aGF0IGhhdmUgYSBcIis9XCIgb3IgXCItPVwiIGFyZSByZWNvZ25pemVkKVxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VDaGFuZ2UgPSBmdW5jdGlvbihlLCBiKSB7XG5cdFx0XHRcdHJldHVybiAodHlwZW9mKGUpID09PSBcInN0cmluZ1wiICYmIGUuY2hhckF0KDEpID09PSBcIj1cIikgPyBwYXJzZUludChlLmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KGUuc3Vic3RyKDIpKSA6IChwYXJzZUZsb2F0KGUpIC0gcGFyc2VGbG9hdChiKSkgfHwgMDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgVGFrZXMgYSB2YWx1ZSBhbmQgYSBkZWZhdWx0IG51bWJlciwgY2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyByZWxhdGl2ZSwgbnVsbCwgb3IgbnVtZXJpYyBhbmQgc3BpdHMgYmFjayBhIG5vcm1hbGl6ZWQgbnVtYmVyIGFjY29yZGluZ2x5LiBQcmltYXJpbHkgdXNlZCBpbiB0aGUgX3BhcnNlVHJhbnNmb3JtKCkgZnVuY3Rpb24uXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gdiBWYWx1ZSB0byBiZSBwYXJzZWRcblx0XHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gZCBEZWZhdWx0IHZhbHVlICh3aGljaCBpcyBhbHNvIHVzZWQgZm9yIHJlbGF0aXZlIGNhbGN1bGF0aW9ucyBpZiBcIis9XCIgb3IgXCItPVwiIGlzIGZvdW5kIGluIHRoZSBmaXJzdCBwYXJhbWV0ZXIpXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IFBhcnNlZCB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VWYWwgPSBmdW5jdGlvbih2LCBkKSB7XG5cdFx0XHRcdHJldHVybiAodiA9PSBudWxsKSA/IGQgOiAodHlwZW9mKHYpID09PSBcInN0cmluZ1wiICYmIHYuY2hhckF0KDEpID09PSBcIj1cIikgPyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KHYuc3Vic3RyKDIpKSArIGQgOiBwYXJzZUZsb2F0KHYpIHx8IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFRyYW5zbGF0ZXMgc3RyaW5ncyBsaWtlIFwiNDBkZWdcIiBvciBcIjQwXCIgb3IgNDByYWRcIiBvciBcIis9NDBkZWdcIiBvciBcIjI3MF9zaG9ydFwiIG9yIFwiLTkwX2N3XCIgb3IgXCIrPTQ1X2Njd1wiIHRvIGEgbnVtZXJpYyByYWRpYW4gYW5nbGUuIE9mIGNvdXJzZSBhIHN0YXJ0aW5nL2RlZmF1bHQgdmFsdWUgbXVzdCBiZSBmZWQgaW4gdG9vIHNvIHRoYXQgcmVsYXRpdmUgdmFsdWVzIGNhbiBiZSBjYWxjdWxhdGVkIHByb3Blcmx5LlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHYgVmFsdWUgdG8gYmUgcGFyc2VkXG5cdFx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IGQgRGVmYXVsdCB2YWx1ZSAod2hpY2ggaXMgYWxzbyB1c2VkIGZvciByZWxhdGl2ZSBjYWxjdWxhdGlvbnMgaWYgXCIrPVwiIG9yIFwiLT1cIiBpcyBmb3VuZCBpbiB0aGUgZmlyc3QgcGFyYW1ldGVyKVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBwIHByb3BlcnR5IG5hbWUgZm9yIGRpcmVjdGlvbmFsRW5kIChvcHRpb25hbCAtIG9ubHkgdXNlZCB3aGVuIHRoZSBwYXJzZWQgdmFsdWUgaXMgZGlyZWN0aW9uYWwgKFwiX3Nob3J0XCIsIFwiX2N3XCIsIG9yIFwiX2Njd1wiIHN1ZmZpeCkuIFdlIG5lZWQgYSB3YXkgdG8gc3RvcmUgdGhlIHVuY29tcGVuc2F0ZWQgdmFsdWUgc28gdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSB0d2Vlbiwgd2Ugc2V0IGl0IHRvIGV4YWN0bHkgd2hhdCB3YXMgcmVxdWVzdGVkIHdpdGggbm8gZGlyZWN0aW9uYWwgY29tcGVuc2F0aW9uKS4gUHJvcGVydHkgbmFtZSB3b3VsZCBiZSBcInJvdGF0aW9uXCIsIFwicm90YXRpb25YXCIsIG9yIFwicm90YXRpb25ZXCJcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gZGlyZWN0aW9uYWxFbmQgQW4gb2JqZWN0IHRoYXQgd2lsbCBzdG9yZSB0aGUgcmF3IGVuZCB2YWx1ZXMgZm9yIGRpcmVjdGlvbmFsIGFuZ2xlcyAoXCJfc2hvcnRcIiwgXCJfY3dcIiwgb3IgXCJfY2N3XCIgc3VmZml4KS4gV2UgbmVlZCBhIHdheSB0byBzdG9yZSB0aGUgdW5jb21wZW5zYXRlZCB2YWx1ZSBzbyB0aGF0IGF0IHRoZSBlbmQgb2YgdGhlIHR3ZWVuLCB3ZSBzZXQgaXQgdG8gZXhhY3RseSB3aGF0IHdhcyByZXF1ZXN0ZWQgd2l0aCBubyBkaXJlY3Rpb25hbCBjb21wZW5zYXRpb24uXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IHBhcnNlZCBhbmdsZSBpbiByYWRpYW5zXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUFuZ2xlID0gZnVuY3Rpb24odiwgZCwgcCwgZGlyZWN0aW9uYWxFbmQpIHtcblx0XHRcdFx0dmFyIG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRcdGNhcCwgc3BsaXQsIGRpZiwgcmVzdWx0LCBpc1JlbGF0aXZlO1xuXHRcdFx0XHRpZiAodiA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZDtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodikgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRyZXN1bHQgPSB2O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhcCA9IDM2MDtcblx0XHRcdFx0XHRzcGxpdCA9IHYuc3BsaXQoXCJfXCIpO1xuXHRcdFx0XHRcdGlzUmVsYXRpdmUgPSAodi5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0XHRkaWYgPSAoaXNSZWxhdGl2ZSA/IHBhcnNlSW50KHYuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIHBhcnNlRmxvYXQoc3BsaXRbMF0uc3Vic3RyKDIpKSA6IHBhcnNlRmxvYXQoc3BsaXRbMF0pKSAqICgodi5pbmRleE9mKFwicmFkXCIpID09PSAtMSkgPyAxIDogX1JBRDJERUcpIC0gKGlzUmVsYXRpdmUgPyAwIDogZCk7XG5cdFx0XHRcdFx0aWYgKHNwbGl0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKGRpcmVjdGlvbmFsRW5kKSB7XG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbmFsRW5kW3BdID0gZCArIGRpZjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJzaG9ydFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gZGlmICUgY2FwO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGlmICE9PSBkaWYgJSAoY2FwIC8gMikpIHtcblx0XHRcdFx0XHRcdFx0XHRkaWYgPSAoZGlmIDwgMCkgPyBkaWYgKyBjYXAgOiBkaWYgLSBjYXA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJfY3dcIikgIT09IC0xICYmIGRpZiA8IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgKyBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodi5pbmRleE9mKFwiY2N3XCIpICE9PSAtMSAmJiBkaWYgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmIC0gY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCA9IGQgKyBkaWY7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3VsdCA8IG1pbiAmJiByZXN1bHQgPiAtbWluKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fSxcblxuXHRcdFx0X2NvbG9yTG9va3VwID0ge2FxdWE6WzAsMjU1LDI1NV0sXG5cdFx0XHRcdGxpbWU6WzAsMjU1LDBdLFxuXHRcdFx0XHRzaWx2ZXI6WzE5MiwxOTIsMTkyXSxcblx0XHRcdFx0YmxhY2s6WzAsMCwwXSxcblx0XHRcdFx0bWFyb29uOlsxMjgsMCwwXSxcblx0XHRcdFx0dGVhbDpbMCwxMjgsMTI4XSxcblx0XHRcdFx0Ymx1ZTpbMCwwLDI1NV0sXG5cdFx0XHRcdG5hdnk6WzAsMCwxMjhdLFxuXHRcdFx0XHR3aGl0ZTpbMjU1LDI1NSwyNTVdLFxuXHRcdFx0XHRmdWNoc2lhOlsyNTUsMCwyNTVdLFxuXHRcdFx0XHRvbGl2ZTpbMTI4LDEyOCwwXSxcblx0XHRcdFx0eWVsbG93OlsyNTUsMjU1LDBdLFxuXHRcdFx0XHRvcmFuZ2U6WzI1NSwxNjUsMF0sXG5cdFx0XHRcdGdyYXk6WzEyOCwxMjgsMTI4XSxcblx0XHRcdFx0cHVycGxlOlsxMjgsMCwxMjhdLFxuXHRcdFx0XHRncmVlbjpbMCwxMjgsMF0sXG5cdFx0XHRcdHJlZDpbMjU1LDAsMF0sXG5cdFx0XHRcdHBpbms6WzI1NSwxOTIsMjAzXSxcblx0XHRcdFx0Y3lhbjpbMCwyNTUsMjU1XSxcblx0XHRcdFx0dHJhbnNwYXJlbnQ6WzI1NSwyNTUsMjU1LDBdfSxcblxuXHRcdFx0X2h1ZSA9IGZ1bmN0aW9uKGgsIG0xLCBtMikge1xuXHRcdFx0XHRoID0gKGggPCAwKSA/IGggKyAxIDogKGggPiAxKSA/IGggLSAxIDogaDtcblx0XHRcdFx0cmV0dXJuICgoKChoICogNiA8IDEpID8gbTEgKyAobTIgLSBtMSkgKiBoICogNiA6IChoIDwgMC41KSA/IG0yIDogKGggKiAzIDwgMikgPyBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNiA6IG0xKSAqIDI1NSkgKyAwLjUpIHwgMDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgUGFyc2VzIGEgY29sb3IgKGxpa2UgIzlGMCwgI0ZGOTkwMCwgcmdiKDI1NSw1MSwxNTMpIG9yIGhzbCgxMDgsIDUwJSwgMTAlKSkgaW50byBhbiBhcnJheSB3aXRoIDMgZWxlbWVudHMgZm9yIHJlZCwgZ3JlZW4sIGFuZCBibHVlIG9yIGlmIHRvSFNMIHBhcmFtZXRlciBpcyB0cnVlLCBpdCB3aWxsIHBvcHVsYXRlIHRoZSBhcnJheSB3aXRoIGh1ZSwgc2F0dXJhdGlvbiwgYW5kIGxpZ2h0bmVzcyB2YWx1ZXMuIElmIGEgcmVsYXRpdmUgdmFsdWUgaXMgZm91bmQgaW4gYW4gaHNsKCkgb3IgaHNsYSgpIHN0cmluZywgaXQgd2lsbCBwcmVzZXJ2ZSB0aG9zZSByZWxhdGl2ZSBwcmVmaXhlcyBhbmQgYWxsIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5IHdpbGwgYmUgc3RyaW5ncyBpbnN0ZWFkIG9mIG51bWJlcnMgKGluIGFsbCBvdGhlciBjYXNlcyBpdCB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIG51bWJlcnMpLlxuXHRcdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IHYgVGhlIHZhbHVlIHRoZSBzaG91bGQgYmUgcGFyc2VkIHdoaWNoIGNvdWxkIGJlIGEgc3RyaW5nIGxpa2UgIzlGMCBvciByZ2IoMjU1LDEwMiw1MSkgb3IgcmdiYSgyNTUsMCwwLDAuNSkgb3IgaXQgY291bGQgYmUgYSBudW1iZXIgbGlrZSAweEZGMDBDQyBvciBldmVuIGEgbmFtZWQgY29sb3IgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLlxuXHRcdFx0ICogQHBhcmFtIHsoYm9vbGVhbil9IHRvSFNMIElmIHRydWUsIGFuIGhzbCgpIG9yIGhzbGEoKSB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgcmdiKCkgb3IgcmdiYSgpXG5cdFx0XHQgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gQW4gYXJyYXkgY29udGFpbmluZyByZWQsIGdyZWVuLCBhbmQgYmx1ZSAoYW5kIG9wdGlvbmFsbHkgYWxwaGEpIGluIHRoYXQgb3JkZXIsIG9yIGlmIHRoZSB0b0hTTCBwYXJhbWV0ZXIgd2FzIHRydWUsIHRoZSBhcnJheSB3aWxsIGNvbnRhaW4gaHVlLCBzYXR1cmF0aW9uIGFuZCBsaWdodG5lc3MgKGFuZCBvcHRpb25hbGx5IGFscGhhKSBpbiB0aGF0IG9yZGVyLiBBbHdheXMgbnVtYmVycyB1bmxlc3MgdGhlcmUncyBhIHJlbGF0aXZlIHByZWZpeCBmb3VuZCBpbiBhbiBoc2woKSBvciBoc2xhKCkgc3RyaW5nIGFuZCB0b0hTTCBpcyB0cnVlLlxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VDb2xvciA9IENTU1BsdWdpbi5wYXJzZUNvbG9yID0gZnVuY3Rpb24odiwgdG9IU0wpIHtcblx0XHRcdFx0dmFyIGEsIHIsIGcsIGIsIGgsIHMsIGwsIG1heCwgbWluLCBkLCB3YXNIU0w7XG5cdFx0XHRcdGlmICghdikge1xuXHRcdFx0XHRcdGEgPSBfY29sb3JMb29rdXAuYmxhY2s7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0YSA9IFt2ID4+IDE2LCAodiA+PiA4KSAmIDI1NSwgdiAmIDI1NV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHYuY2hhckF0KHYubGVuZ3RoIC0gMSkgPT09IFwiLFwiKSB7IC8vc29tZXRpbWVzIGEgdHJhaWxpbmcgY29tbWEgaXMgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjaG9wIGl0IG9mZiAodHlwaWNhbGx5IGZyb20gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgbGlrZSBhIHRleHRTaGFkb3c6XCIycHggMnB4IDJweCBibHVlLCA1cHggNXB4IDVweCByZ2IoMjU1LDAsMClcIiAtIGluIHRoaXMgZXhhbXBsZSBcImJsdWUsXCIgaGFzIGEgdHJhaWxpbmcgY29tbWEuIFdlIGNvdWxkIHN0cmlwIGl0IG91dCBpbnNpZGUgcGFyc2VDb21wbGV4KCkgYnV0IHdlJ2QgbmVlZCB0byBkbyBpdCB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIHBsdXMgaXQgd291bGRuJ3QgcHJvdmlkZSBwcm90ZWN0aW9uIGZyb20gb3RoZXIgcG90ZW50aWFsIHNjZW5hcmlvcyBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHNpbWlsYXIgdmFsdWUuXG5cdFx0XHRcdFx0XHR2ID0gdi5zdWJzdHIoMCwgdi5sZW5ndGggLSAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKF9jb2xvckxvb2t1cFt2XSkge1xuXHRcdFx0XHRcdFx0YSA9IF9jb2xvckxvb2t1cFt2XTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuY2hhckF0KDApID09PSBcIiNcIikge1xuXHRcdFx0XHRcdFx0aWYgKHYubGVuZ3RoID09PSA0KSB7IC8vZm9yIHNob3J0aGFuZCBsaWtlICM5RjBcblx0XHRcdFx0XHRcdFx0ciA9IHYuY2hhckF0KDEpO1xuXHRcdFx0XHRcdFx0XHRnID0gdi5jaGFyQXQoMik7XG5cdFx0XHRcdFx0XHRcdGIgPSB2LmNoYXJBdCgzKTtcblx0XHRcdFx0XHRcdFx0diA9IFwiI1wiICsgciArIHIgKyBnICsgZyArIGIgKyBiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0diA9IHBhcnNlSW50KHYuc3Vic3RyKDEpLCAxNik7XG5cdFx0XHRcdFx0XHRhID0gW3YgPj4gMTYsICh2ID4+IDgpICYgMjU1LCB2ICYgMjU1XTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuc3Vic3RyKDAsIDMpID09PSBcImhzbFwiKSB7XG5cdFx0XHRcdFx0XHRhID0gd2FzSFNMID0gdi5tYXRjaChfbnVtRXhwKTtcblx0XHRcdFx0XHRcdGlmICghdG9IU0wpIHtcblx0XHRcdFx0XHRcdFx0aCA9IChOdW1iZXIoYVswXSkgJSAzNjApIC8gMzYwO1xuXHRcdFx0XHRcdFx0XHRzID0gTnVtYmVyKGFbMV0pIC8gMTAwO1xuXHRcdFx0XHRcdFx0XHRsID0gTnVtYmVyKGFbMl0pIC8gMTAwO1xuXHRcdFx0XHRcdFx0XHRnID0gKGwgPD0gMC41KSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcblx0XHRcdFx0XHRcdFx0ciA9IGwgKiAyIC0gZztcblx0XHRcdFx0XHRcdFx0aWYgKGEubGVuZ3RoID4gMykge1xuXHRcdFx0XHRcdFx0XHRcdGFbM10gPSBOdW1iZXIodlszXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YVswXSA9IF9odWUoaCArIDEgLyAzLCByLCBnKTtcblx0XHRcdFx0XHRcdFx0YVsxXSA9IF9odWUoaCwgciwgZyk7XG5cdFx0XHRcdFx0XHRcdGFbMl0gPSBfaHVlKGggLSAxIC8gMywgciwgZyk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuaW5kZXhPZihcIj1cIikgIT09IC0xKSB7IC8vaWYgcmVsYXRpdmUgdmFsdWVzIGFyZSBmb3VuZCwganVzdCByZXR1cm4gdGhlIHJhdyBzdHJpbmdzIHdpdGggdGhlIHJlbGF0aXZlIHByZWZpeGVzIGluIHBsYWNlLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdi5tYXRjaChfcmVsTnVtRXhwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YSA9IHYubWF0Y2goX251bUV4cCkgfHwgX2NvbG9yTG9va3VwLnRyYW5zcGFyZW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhWzBdID0gTnVtYmVyKGFbMF0pO1xuXHRcdFx0XHRcdGFbMV0gPSBOdW1iZXIoYVsxXSk7XG5cdFx0XHRcdFx0YVsyXSA9IE51bWJlcihhWzJdKTtcblx0XHRcdFx0XHRpZiAoYS5sZW5ndGggPiAzKSB7XG5cdFx0XHRcdFx0XHRhWzNdID0gTnVtYmVyKGFbM10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodG9IU0wgJiYgIXdhc0hTTCkge1xuXHRcdFx0XHRcdHIgPSBhWzBdIC8gMjU1O1xuXHRcdFx0XHRcdGcgPSBhWzFdIC8gMjU1O1xuXHRcdFx0XHRcdGIgPSBhWzJdIC8gMjU1O1xuXHRcdFx0XHRcdG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHRcdFx0XHRcdG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRcdFx0XHRcdGwgPSAobWF4ICsgbWluKSAvIDI7XG5cdFx0XHRcdFx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0XHRcdFx0XHRoID0gcyA9IDA7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGQgPSBtYXggLSBtaW47XG5cdFx0XHRcdFx0XHRzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG5cdFx0XHRcdFx0XHRoID0gKG1heCA9PT0gcikgPyAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKSA6IChtYXggPT09IGcpID8gKGIgLSByKSAvIGQgKyAyIDogKHIgLSBnKSAvIGQgKyA0O1xuXHRcdFx0XHRcdFx0aCAqPSA2MDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YVswXSA9IChoICsgMC41KSB8IDA7XG5cdFx0XHRcdFx0YVsxXSA9IChzICogMTAwICsgMC41KSB8IDA7XG5cdFx0XHRcdFx0YVsyXSA9IChsICogMTAwICsgMC41KSB8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9LFxuXHRcdFx0X2Zvcm1hdENvbG9ycyA9IGZ1bmN0aW9uKHMsIHRvSFNMKSB7XG5cdFx0XHRcdHZhciBjb2xvcnMgPSBzLm1hdGNoKF9jb2xvckV4cCkgfHwgW10sXG5cdFx0XHRcdFx0Y2hhckluZGV4ID0gMCxcblx0XHRcdFx0XHRwYXJzZWQgPSBjb2xvcnMubGVuZ3RoID8gXCJcIiA6IHMsXG5cdFx0XHRcdFx0aSwgY29sb3IsIHRlbXA7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb2xvciA9IGNvbG9yc1tpXTtcblx0XHRcdFx0XHR0ZW1wID0gcy5zdWJzdHIoY2hhckluZGV4LCBzLmluZGV4T2YoY29sb3IsIGNoYXJJbmRleCktY2hhckluZGV4KTtcblx0XHRcdFx0XHRjaGFySW5kZXggKz0gdGVtcC5sZW5ndGggKyBjb2xvci5sZW5ndGg7XG5cdFx0XHRcdFx0Y29sb3IgPSBfcGFyc2VDb2xvcihjb2xvciwgdG9IU0wpO1xuXHRcdFx0XHRcdGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcblx0XHRcdFx0XHRcdGNvbG9yLnB1c2goMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlZCArPSB0ZW1wICsgKHRvSFNMID8gXCJoc2xhKFwiICsgY29sb3JbMF0gKyBcIixcIiArIGNvbG9yWzFdICsgXCIlLFwiICsgY29sb3JbMl0gKyBcIiUsXCIgKyBjb2xvclszXSA6IFwicmdiYShcIiArIGNvbG9yLmpvaW4oXCIsXCIpKSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYXJzZWQgKyBzLnN1YnN0cihjaGFySW5kZXgpO1xuXHRcdFx0fSxcblx0XHRcdF9jb2xvckV4cCA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMoPzpbMC05YS1mXXszfSl7MSwyfVxcXFxiXCI7IC8vd2UnbGwgZHluYW1pY2FsbHkgYnVpbGQgdGhpcyBSZWd1bGFyIEV4cHJlc3Npb24gdG8gY29uc2VydmUgZmlsZSBzaXplLiBBZnRlciBidWlsZGluZyBpdCwgaXQgd2lsbCBiZSBhYmxlIHRvIGZpbmQgcmdiKCksIHJnYmEoKSwgIyAoaGV4YWRlY2ltYWwpLCBhbmQgbmFtZWQgY29sb3IgdmFsdWVzIGxpa2UgcmVkLCBibHVlLCBwdXJwbGUsIGV0Yy5cblxuXHRcdGZvciAocCBpbiBfY29sb3JMb29rdXApIHtcblx0XHRcdF9jb2xvckV4cCArPSBcInxcIiArIHAgKyBcIlxcXFxiXCI7XG5cdFx0fVxuXHRcdF9jb2xvckV4cCA9IG5ldyBSZWdFeHAoX2NvbG9yRXhwK1wiKVwiLCBcImdpXCIpO1xuXG5cdFx0Q1NTUGx1Z2luLmNvbG9yU3RyaW5nRmlsdGVyID0gZnVuY3Rpb24oYSkge1xuXHRcdFx0dmFyIGNvbWJpbmVkID0gYVswXSArIGFbMV0sXG5cdFx0XHRcdHRvSFNMO1xuXHRcdFx0aWYgKF9jb2xvckV4cC50ZXN0KGNvbWJpbmVkKSkge1xuXHRcdFx0XHR0b0hTTCA9IChjb21iaW5lZC5pbmRleE9mKFwiaHNsKFwiKSAhPT0gLTEgfHwgY29tYmluZWQuaW5kZXhPZihcImhzbGEoXCIpICE9PSAtMSk7XG5cdFx0XHRcdGFbMF0gPSBfZm9ybWF0Q29sb3JzKGFbMF0sIHRvSFNMKTtcblx0XHRcdFx0YVsxXSA9IF9mb3JtYXRDb2xvcnMoYVsxXSwgdG9IU0wpO1xuXHRcdFx0fVxuXHRcdFx0X2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7XG5cdFx0fTtcblxuXHRcdGlmICghVHdlZW5MaXRlLmRlZmF1bHRTdHJpbmdGaWx0ZXIpIHtcblx0XHRcdFR3ZWVuTGl0ZS5kZWZhdWx0U3RyaW5nRmlsdGVyID0gQ1NTUGx1Z2luLmNvbG9yU3RyaW5nRmlsdGVyO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlIFJldHVybnMgYSBmb3JtYXR0ZXIgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHRha2luZyBhIHN0cmluZyAob3IgbnVtYmVyIGluIHNvbWUgY2FzZXMpIGFuZCByZXR1cm5pbmcgYSBjb25zaXN0ZW50bHkgZm9ybWF0dGVkIG9uZSBpbiB0ZXJtcyBvZiBkZWxpbWl0ZXJzLCBxdWFudGl0eSBvZiB2YWx1ZXMsIGV0Yy4gRm9yIGV4YW1wbGUsIHdlIG1heSBnZXQgYm94U2hhZG93IHZhbHVlcyBkZWZpbmVkIGFzIFwiMHB4IHJlZFwiIG9yIFwiMHB4IDBweCAxMHB4IHJnYigyNTUsMCwwKVwiIG9yIFwiMHB4IDBweCAyMHB4IDIwcHggI0YwMFwiIGFuZCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHdoYXQgd2UgZ2V0IGJhY2sgaXMgZGVzY3JpYmVkIHdpdGggNCBudW1iZXJzIGFuZCBhIGNvbG9yLiBUaGlzIGFsbG93cyB1cyB0byBmZWVkIGl0IGludG8gdGhlIF9wYXJzZUNvbXBsZXgoKSBtZXRob2QgYW5kIHNwbGl0IHRoZSB2YWx1ZXMgdXAgYXBwcm9wcmlhdGVseS4gVGhlIG5lYXQgdGhpbmcgYWJvdXQgdGhpcyBfZ2V0Rm9ybWF0dGVyKCkgZnVuY3Rpb24gaXMgdGhhdCB0aGUgZGZsdCBkZWZpbmVzIGEgcGF0dGVybiBhcyB3ZWxsIGFzIGEgZGVmYXVsdCwgc28gZm9yIGV4YW1wbGUsIF9nZXRGb3JtYXR0ZXIoXCIwcHggMHB4IDBweCAwcHggIzc3N1wiLCB0cnVlKSBub3Qgb25seSBzZXRzIHRoZSBkZWZhdWx0IGFzIDBweCBmb3IgYWxsIGRpc3RhbmNlcyBhbmQgIzc3NyBmb3IgdGhlIGNvbG9yLCBidXQgYWxzbyBzZXRzIHRoZSBwYXR0ZXJuIHN1Y2ggdGhhdCA0IG51bWJlcnMgYW5kIGEgY29sb3Igd2lsbCBhbHdheXMgZ2V0IHJldHVybmVkLlxuXHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gZGZsdCBUaGUgZGVmYXVsdCB2YWx1ZSBhbmQgcGF0dGVybiB0byBmb2xsb3cuIFNvIFwiMHB4IDBweCAwcHggMHB4ICM3NzdcIiB3aWxsIGVuc3VyZSB0aGF0IDQgbnVtYmVycyBhbmQgYSBjb2xvciB3aWxsIGFsd2F5cyBnZXQgcmV0dXJuZWQuXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gY2xyIElmIHRydWUsIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHNlYXJjaGVkIGZvciBjb2xvci1yZWxhdGVkIGRhdGEuIEZvciBleGFtcGxlLCBib3hTaGFkb3cgdmFsdWVzIHR5cGljYWxseSBjb250YWluIGEgY29sb3Igd2hlcmVhcyBib3JkZXJSYWRpdXMgZG9uJ3QuXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gY29sbGFwc2libGUgSWYgdHJ1ZSwgdGhlIHZhbHVlIGlzIGEgdG9wL2xlZnQvcmlnaHQvYm90dG9tIHN0eWxlIG9uZSB0aGF0IGFjdHMgbGlrZSBtYXJnaW4gb3IgcGFkZGluZywgd2hlcmUgaWYgb25seSBvbmUgdmFsdWUgaXMgcmVjZWl2ZWQsIGl0J3MgdXNlZCBmb3IgYWxsIDQ7IGlmIDIgYXJlIHJlY2VpdmVkLCB0aGUgZmlyc3QgaXMgZHVwbGljYXRlZCBmb3IgM3JkIChib3R0b20pIGFuZCB0aGUgMm5kIGlzIGR1cGxpY2F0ZWQgZm9yIHRoZSA0dGggc3BvdCAobGVmdCksIGV0Yy5cblx0XHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gZm9ybWF0dGVyIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0dmFyIF9nZXRGb3JtYXR0ZXIgPSBmdW5jdGlvbihkZmx0LCBjbHIsIGNvbGxhcHNpYmxlLCBtdWx0aSkge1xuXHRcdFx0XHRpZiAoZGZsdCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHYpIHtyZXR1cm4gdjt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBkQ29sb3IgPSBjbHIgPyAoZGZsdC5tYXRjaChfY29sb3JFeHApIHx8IFtcIlwiXSlbMF0gOiBcIlwiLFxuXHRcdFx0XHRcdGRWYWxzID0gZGZsdC5zcGxpdChkQ29sb3IpLmpvaW4oXCJcIikubWF0Y2goX3ZhbHVlc0V4cCkgfHwgW10sXG5cdFx0XHRcdFx0cGZ4ID0gZGZsdC5zdWJzdHIoMCwgZGZsdC5pbmRleE9mKGRWYWxzWzBdKSksXG5cdFx0XHRcdFx0c2Z4ID0gKGRmbHQuY2hhckF0KGRmbHQubGVuZ3RoIC0gMSkgPT09IFwiKVwiKSA/IFwiKVwiIDogXCJcIixcblx0XHRcdFx0XHRkZWxpbSA9IChkZmx0LmluZGV4T2YoXCIgXCIpICE9PSAtMSkgPyBcIiBcIiA6IFwiLFwiLFxuXHRcdFx0XHRcdG51bVZhbHMgPSBkVmFscy5sZW5ndGgsXG5cdFx0XHRcdFx0ZFNmeCA9IChudW1WYWxzID4gMCkgPyBkVmFsc1swXS5yZXBsYWNlKF9udW1FeHAsIFwiXCIpIDogXCJcIixcblx0XHRcdFx0XHRmb3JtYXR0ZXI7XG5cdFx0XHRcdGlmICghbnVtVmFscykge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbih2KSB7cmV0dXJuIHY7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2xyKSB7XG5cdFx0XHRcdFx0Zm9ybWF0dGVyID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0dmFyIGNvbG9yLCB2YWxzLCBpLCBhO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0XHR2ICs9IGRTZng7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG11bHRpICYmIF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdCh2KSkge1xuXHRcdFx0XHRcdFx0XHRhID0gdi5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwifFwiKS5zcGxpdChcInxcIik7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0YVtpXSA9IGZvcm1hdHRlcihhW2ldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYS5qb2luKFwiLFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbG9yID0gKHYubWF0Y2goX2NvbG9yRXhwKSB8fCBbZENvbG9yXSlbMF07XG5cdFx0XHRcdFx0XHR2YWxzID0gdi5zcGxpdChjb2xvcikuam9pbihcIlwiKS5tYXRjaChfdmFsdWVzRXhwKSB8fCBbXTtcblx0XHRcdFx0XHRcdGkgPSB2YWxzLmxlbmd0aDtcblx0XHRcdFx0XHRcdGlmIChudW1WYWxzID4gaS0tKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgrK2kgPCBudW1WYWxzKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsc1tpXSA9IGNvbGxhcHNpYmxlID8gdmFsc1soKChpIC0gMSkgLyAyKSB8IDApXSA6IGRWYWxzW2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGZ4ICsgdmFscy5qb2luKGRlbGltKSArIGRlbGltICsgY29sb3IgKyBzZnggKyAodi5pbmRleE9mKFwiaW5zZXRcIikgIT09IC0xID8gXCIgaW5zZXRcIiA6IFwiXCIpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuIGZvcm1hdHRlcjtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvcm1hdHRlciA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHR2YXIgdmFscywgYSwgaTtcblx0XHRcdFx0XHRpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0XHR2ICs9IGRTZng7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtdWx0aSAmJiBfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QodikpIHtcblx0XHRcdFx0XHRcdGEgPSB2LnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBmb3JtYXR0ZXIoYVtpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gYS5qb2luKFwiLFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFscyA9IHYubWF0Y2goX3ZhbHVlc0V4cCkgfHwgW107XG5cdFx0XHRcdFx0aSA9IHZhbHMubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChudW1WYWxzID4gaS0tKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoKytpIDwgbnVtVmFscykge1xuXHRcdFx0XHRcdFx0XHR2YWxzW2ldID0gY29sbGFwc2libGUgPyB2YWxzWygoKGkgLSAxKSAvIDIpIHwgMCldIDogZFZhbHNbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBwZnggKyB2YWxzLmpvaW4oZGVsaW0pICsgc2Z4O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gZm9ybWF0dGVyO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSByZXR1cm5zIGEgZm9ybWF0dGVyIGZ1bmN0aW9uIHRoYXQncyB1c2VkIGZvciBlZGdlLXJlbGF0ZWQgdmFsdWVzIGxpa2UgbWFyZ2luVG9wLCBtYXJnaW5MZWZ0LCBwYWRkaW5nQm90dG9tLCBwYWRkaW5nUmlnaHQsIGV0Yy4gSnVzdCBwYXNzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgcmVsYXRlZCB0byB0aGUgZWRnZXMuXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHByb3BzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgaW4gb3JkZXIgZnJvbSB0b3AgdG8gbGVmdCwgbGlrZSBcIm1hcmdpblRvcCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20sbWFyZ2luTGVmdFwiXG5cdFx0XHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmb3JtYXR0ZXIgZnVuY3Rpb25cblx0XHRcdCAqL1xuXHRcdFx0X2dldEVkZ2VQYXJzZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdFx0XHRwcm9wcyA9IHByb3BzLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdFx0XHR2YXIgYSA9IChlICsgXCJcIikuc3BsaXQoXCIgXCIpLFxuXHRcdFx0XHRcdFx0aTtcblx0XHRcdFx0XHR2YXJzID0ge307XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyc1twcm9wc1tpXV0gPSBhW2ldID0gYVtpXSB8fCBhWygoKGkgLSAxKSAvIDIpID4+IDApXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGNzc3AucGFyc2UodCwgdmFycywgcHQsIHBsdWdpbik7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSB1c2VkIHdoZW4gb3RoZXIgcGx1Z2lucyBtdXN0IHR3ZWVuIHZhbHVlcyBmaXJzdCwgbGlrZSBCZXppZXJQbHVnaW4gb3IgVGhyb3dQcm9wc1BsdWdpbiwgZXRjLiBUaGF0IHBsdWdpbidzIHNldFJhdGlvKCkgZ2V0cyBjYWxsZWQgZmlyc3Qgc28gdGhhdCB0aGUgdmFsdWVzIGFyZSB1cGRhdGVkLCBhbmQgdGhlbiB3ZSBsb29wIHRocm91Z2ggdGhlIE1pbmlQcm9wVHdlZW5zICB3aGljaCBoYW5kbGUgY29weWluZyB0aGUgdmFsdWVzIGludG8gdGhlaXIgYXBwcm9wcmlhdGUgc2xvdHMgc28gdGhhdCB0aGV5IGNhbiB0aGVuIGJlIGFwcGxpZWQgY29ycmVjdGx5IGluIHRoZSBtYWluIENTU1BsdWdpbiBzZXRSYXRpbygpIG1ldGhvZC4gUmVtZW1iZXIsIHdlIHR5cGljYWxseSBjcmVhdGUgYSBwcm94eSBvYmplY3QgdGhhdCBoYXMgYSBidW5jaCBvZiB1bmlxdWVseS1uYW1lZCBwcm9wZXJ0aWVzIHRoYXQgd2UgZmVlZCB0byB0aGUgc3ViLXBsdWdpbiBhbmQgaXQgZG9lcyBpdHMgbWFnaWMgbm9ybWFsbHksIGFuZCB0aGVuIHdlIG11c3QgaW50ZXJwcmV0IHRob3NlIHZhbHVlcyBhbmQgYXBwbHkgdGhlbSB0byB0aGUgY3NzIGJlY2F1c2Ugb2Z0ZW4gbnVtYmVycyBtdXN0IGdldCBjb21iaW5lZC9jb25jYXRlbmF0ZWQsIHN1ZmZpeGVzIGFkZGVkLCBldGMuIHRvIHdvcmsgd2l0aCBjc3MsIGxpa2UgYm94U2hhZG93IGNvdWxkIGhhdmUgNCB2YWx1ZXMgcGx1cyBhIGNvbG9yLlxuXHRcdFx0X3NldFBsdWdpblJhdGlvID0gX2ludGVybmFscy5fc2V0UGx1Z2luUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHRoaXMucGx1Z2luLnNldFJhdGlvKHYpO1xuXHRcdFx0XHR2YXIgZCA9IHRoaXMuZGF0YSxcblx0XHRcdFx0XHRwcm94eSA9IGQucHJveHksXG5cdFx0XHRcdFx0bXB0ID0gZC5maXJzdE1QVCxcblx0XHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0XHR2YWwsIHB0LCBpLCBzdHIsIHA7XG5cdFx0XHRcdHdoaWxlIChtcHQpIHtcblx0XHRcdFx0XHR2YWwgPSBwcm94eVttcHQudl07XG5cdFx0XHRcdFx0aWYgKG1wdC5yKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWwgPCBtaW4gJiYgdmFsID4gLW1pbikge1xuXHRcdFx0XHRcdFx0dmFsID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bXB0LnRbbXB0LnBdID0gdmFsO1xuXHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZC5hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0ZC5hdXRvUm90YXRlLnJvdGF0aW9uID0gcHJveHkucm90YXRpb247XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9hdCB0aGUgZW5kLCB3ZSBtdXN0IHNldCB0aGUgQ1NTUHJvcFR3ZWVuJ3MgXCJlXCIgKGVuZCkgdmFsdWUgZHluYW1pY2FsbHkgaGVyZSBiZWNhdXNlIHRoYXQncyB3aGF0IGlzIHVzZWQgaW4gdGhlIGZpbmFsIHNldFJhdGlvKCkgbWV0aG9kLiBTYW1lIGZvciBcImJcIiBhdCB0aGUgYmVnaW5uaW5nLlxuXHRcdFx0XHRpZiAodiA9PT0gMSB8fCB2ID09PSAwKSB7XG5cdFx0XHRcdFx0bXB0ID0gZC5maXJzdE1QVDtcblx0XHRcdFx0XHRwID0gKHYgPT09IDEpID8gXCJlXCIgOiBcImJcIjtcblx0XHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0XHRwdCA9IG1wdC50O1xuXHRcdFx0XHRcdFx0aWYgKCFwdC50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdHB0W3BdID0gcHQucyArIHB0LnhzMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyBwdC5zICsgcHQueHMxO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgcHQubDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieG5cIitpXSArIHB0W1wieHNcIisoaSsxKV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHRbcF0gPSBzdHI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtcHQgPSBtcHQuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIEBjb25zdHJ1Y3RvciBVc2VkIGJ5IGEgZmV3IFNwZWNpYWxQcm9wcyB0byBob2xkIGltcG9ydGFudCB2YWx1ZXMgZm9yIHByb3hpZXMuIEZvciBleGFtcGxlLCBfcGFyc2VUb1Byb3h5KCkgY3JlYXRlcyBhIE1pbmlQcm9wVHdlZW4gaW5zdGFuY2UgZm9yIGVhY2ggcHJvcGVydHkgdGhhdCBtdXN0IGdldCB0d2VlbmVkIG9uIHRoZSBwcm94eSwgYW5kIHdlIHJlY29yZCB0aGUgb3JpZ2luYWwgcHJvcGVydHkgbmFtZSBhcyB3ZWxsIGFzIHRoZSB1bmlxdWUgb25lIHdlIGNyZWF0ZSBmb3IgdGhlIHByb3h5LCBwbHVzIHdoZXRoZXIgb3Igbm90IHRoZSB2YWx1ZSBuZWVkcyB0byBiZSByb3VuZGVkIHBsdXMgdGhlIG9yaWdpbmFsIHZhbHVlLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgd2UncmUgdHdlZW5pbmcgKG9mdGVuIGEgQ1NTUHJvcFR3ZWVuKVxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIHByb3BlcnR5IG5hbWVcblx0XHRcdCAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmd8b2JqZWN0KX0gdiB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtNaW5pUHJvcFR3ZWVuPX0gbmV4dCBuZXh0IE1pbmlQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByIGlmIHRydWUsIHRoZSB0d2VlbmVkIHZhbHVlIHNob3VsZCBiZSByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcblx0XHRcdCAqL1xuXHRcdFx0TWluaVByb3BUd2VlbiA9IGZ1bmN0aW9uKHQsIHAsIHYsIG5leHQsIHIpIHtcblx0XHRcdFx0dGhpcy50ID0gdDtcblx0XHRcdFx0dGhpcy5wID0gcDtcblx0XHRcdFx0dGhpcy52ID0gdjtcblx0XHRcdFx0dGhpcy5yID0gcjtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gdGhpcztcblx0XHRcdFx0XHR0aGlzLl9uZXh0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBNb3N0IG90aGVyIHBsdWdpbnMgKGxpa2UgQmV6aWVyUGx1Z2luIGFuZCBUaHJvd1Byb3BzUGx1Z2luIGFuZCBvdGhlcnMpIGNhbiBvbmx5IHR3ZWVuIG51bWVyaWMgdmFsdWVzLCBidXQgQ1NTUGx1Z2luIG11c3QgYWNjb21tb2RhdGUgc3BlY2lhbCB2YWx1ZXMgdGhhdCBoYXZlIGEgYnVuY2ggb2YgZXh0cmEgZGF0YSAobGlrZSBhIHN1ZmZpeCBvciBzdHJpbmdzIGJldHdlZW4gbnVtZXJpYyB2YWx1ZXMsIGV0Yy4pLiBGb3IgZXhhbXBsZSwgYm94U2hhZG93IGhhcyB2YWx1ZXMgbGlrZSBcIjEwcHggMTBweCAyMHB4IDMwcHggcmdiKDI1NSwwLDApXCIgd2hpY2ggd291bGQgdXR0ZXJseSBjb25mdXNlIG90aGVyIHBsdWdpbnMuIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byBzcGxpdCB0aGF0IGRhdGEgYXBhcnQgYW5kIGdyYWIgb25seSB0aGUgbnVtZXJpYyBkYXRhIGFuZCBhdHRhY2ggaXQgdG8gdW5pcXVlbHktbmFtZWQgcHJvcGVydGllcyBvZiBhIGdlbmVyaWMgcHJveHkgb2JqZWN0ICh7fSkgc28gdGhhdCB3ZSBjYW4gZmVlZCB0aGF0IHRvIHZpcnR1YWxseSBhbnkgcGx1Z2luIHRvIGhhdmUgdGhlIG51bWJlcnMgdHdlZW5lZC4gSG93ZXZlciwgd2UgbXVzdCBhbHNvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggcHJvcGVydGllcyBmcm9tIHRoZSBwcm94eSBnbyB3aXRoIHdoaWNoIENTU1Byb3BUd2VlbiB2YWx1ZXMgYW5kIGluc3RhbmNlcy4gU28gd2UgY3JlYXRlIGEgbGlua2VkIGxpc3Qgb2YgTWluaVByb3BUd2VlbnMuIEVhY2ggb25lIHJlY29yZHMgYSB0YXJnZXQgKHRoZSBvcmlnaW5hbCBDU1NQcm9wVHdlZW4pLCBwcm9wZXJ0eSAobGlrZSBcInNcIiBvciBcInhuMVwiIG9yIFwieG4yXCIpIHRoYXQgd2UncmUgdHdlZW5pbmcgYW5kIHRoZSB1bmlxdWUgcHJvcGVydHkgbmFtZSB0aGF0IHdhcyB1c2VkIGZvciB0aGUgcHJveHkgKGxpa2UgXCJib3hTaGFkb3dfeG4xXCIgYW5kIFwiYm94U2hhZG93X3huMlwiKSBhbmQgd2hldGhlciBvciBub3QgdGhleSBuZWVkIHRvIGJlIHJvdW5kZWQuIFRoYXQgd2F5LCBpbiB0aGUgX3NldFBsdWdpblJhdGlvKCkgbWV0aG9kIHdlIGNhbiBzaW1wbHkgY29weSB0aGUgdmFsdWVzIG92ZXIgZnJvbSB0aGUgcHJveHkgdG8gdGhlIENTU1Byb3BUd2VlbiBpbnN0YW5jZShzKS4gVGhlbiwgd2hlbiB0aGUgbWFpbiBDU1NQbHVnaW4gc2V0UmF0aW8oKSBtZXRob2QgcnVucyBhbmQgYXBwbGllcyB0aGUgQ1NTUHJvcFR3ZWVuIHZhbHVlcyBhY2NvcmRpbmdseSwgdGhleSdyZSB1cGRhdGVkIG5pY2VseS4gU28gdGhlIGV4dGVybmFsIHBsdWdpbiB0d2VlbnMgdGhlIG51bWJlcnMsIF9zZXRQbHVnaW5SYXRpbygpIGNvcGllcyB0aGVtIG92ZXIsIGFuZCBzZXRSYXRpbygpIGFjdHMgbm9ybWFsbHksIGFwcGx5aW5nIGNzcy1zcGVjaWZpYyB2YWx1ZXMgdG8gdGhlIGVsZW1lbnQuXG5cdFx0XHQgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdFx0XHQgKiAgLSBwcm94eTogYSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHRoZSBzdGFydGluZyB2YWx1ZXMgZm9yIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgdHdlZW5lZCBieSB0aGUgZXh0ZXJuYWwgcGx1Z2luLiAgVGhpcyBpcyB3aGF0IHdlIGZlZWQgdG8gdGhlIGV4dGVybmFsIF9vbkluaXRUd2VlbigpIGFzIHRoZSB0YXJnZXRcblx0XHRcdCAqICAtIGVuZDogYSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHRoZSBlbmRpbmcgdmFsdWVzIGZvciBhbGwgdGhlIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHR3ZWVuZWQgYnkgdGhlIGV4dGVybmFsIHBsdWdpbi4gVGhpcyBpcyB3aGF0IHdlIGZlZWQgdG8gdGhlIGV4dGVybmFsIHBsdWdpbidzIF9vbkluaXRUd2VlbigpIGFzIHRoZSBkZXN0aW5hdGlvbiB2YWx1ZXNcblx0XHRcdCAqICAtIGZpcnN0TVBUOiB0aGUgZmlyc3QgTWluaVByb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHRcdCAqICAtIHB0OiB0aGUgZmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCB0aGF0IHdhcyBjcmVhdGVkIHdoZW4gcGFyc2luZy4gSWYgc2hhbGxvdyBpcyB0cnVlLCB0aGlzIGxpbmtlZCBsaXN0IHdpbGwgTk9UIGF0dGFjaCB0byB0aGUgb25lIHBhc3NlZCBpbnRvIHRoZSBfcGFyc2VUb1Byb3h5KCkgYXMgdGhlIFwicHRcIiAoNHRoKSBwYXJhbWV0ZXIuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgdGFyZ2V0IG9iamVjdCB0byBiZSB0d2VlbmVkXG5cdFx0XHQgKiBAcGFyYW0geyEoT2JqZWN0fHN0cmluZyl9IHZhcnMgdGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdHdlZW5pbmcgdmFsdWVzICh0eXBpY2FsbHkgdGhlIGVuZC9kZXN0aW5hdGlvbiB2YWx1ZXMpIHRoYXQgc2hvdWxkIGJlIHBhcnNlZFxuXHRcdFx0ICogQHBhcmFtIHshQ1NTUGx1Z2lufSBjc3NwIFRoZSBDU1NQbHVnaW4gaW5zdGFuY2Vcblx0XHRcdCAqIEBwYXJhbSB7Q1NTUHJvcFR3ZWVuPX0gcHQgdGhlIG5leHQgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdFx0ICogQHBhcmFtIHtUd2VlblBsdWdpbj19IHBsdWdpbiB0aGUgZXh0ZXJuYWwgVHdlZW5QbHVnaW4gaW5zdGFuY2UgdGhhdCB3aWxsIGJlIGhhbmRsaW5nIHR3ZWVuaW5nIHRoZSBudW1lcmljIHZhbHVlc1xuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gc2hhbGxvdyBpZiB0cnVlLCB0aGUgcmVzdWx0aW5nIGxpbmtlZCBsaXN0IGZyb20gdGhlIHBhcnNlIHdpbGwgTk9UIGJlIGF0dGFjaGVkIHRvIHRoZSBDU1NQcm9wVHdlZW4gdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBcInB0XCIgKDR0aCkgcGFyYW1ldGVyLlxuXHRcdFx0ICogQHJldHVybiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IHByb3h5LCBlbmQsIGZpcnN0TVBULCBhbmQgcHQgKHNlZSBhYm92ZSBmb3IgZGVzY3JpcHRpb25zKVxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VUb1Byb3h5ID0gX2ludGVybmFscy5fcGFyc2VUb1Byb3h5ID0gZnVuY3Rpb24odCwgdmFycywgY3NzcCwgcHQsIHBsdWdpbiwgc2hhbGxvdykge1xuXHRcdFx0XHR2YXIgYnB0ID0gcHQsXG5cdFx0XHRcdFx0c3RhcnQgPSB7fSxcblx0XHRcdFx0XHRlbmQgPSB7fSxcblx0XHRcdFx0XHR0cmFuc2Zvcm0gPSBjc3NwLl90cmFuc2Zvcm0sXG5cdFx0XHRcdFx0b2xkRm9yY2UgPSBfZm9yY2VQVCxcblx0XHRcdFx0XHRpLCBwLCB4cCwgbXB0LCBmaXJzdFBUO1xuXHRcdFx0XHRjc3NwLl90cmFuc2Zvcm0gPSBudWxsO1xuXHRcdFx0XHRfZm9yY2VQVCA9IHZhcnM7XG5cdFx0XHRcdHB0ID0gZmlyc3RQVCA9IGNzc3AucGFyc2UodCwgdmFycywgcHQsIHBsdWdpbik7XG5cdFx0XHRcdF9mb3JjZVBUID0gb2xkRm9yY2U7XG5cdFx0XHRcdC8vYnJlYWsgb2ZmIGZyb20gdGhlIGxpbmtlZCBsaXN0IHNvIHRoZSBuZXcgb25lcyBhcmUgaXNvbGF0ZWQuXG5cdFx0XHRcdGlmIChzaGFsbG93KSB7XG5cdFx0XHRcdFx0Y3NzcC5fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuXHRcdFx0XHRcdGlmIChicHQpIHtcblx0XHRcdFx0XHRcdGJwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoYnB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRcdGJwdC5fcHJldi5fbmV4dCA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlIChwdCAmJiBwdCAhPT0gYnB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LnR5cGUgPD0gMSkge1xuXHRcdFx0XHRcdFx0cCA9IHB0LnA7XG5cdFx0XHRcdFx0XHRlbmRbcF0gPSBwdC5zICsgcHQuYztcblx0XHRcdFx0XHRcdHN0YXJ0W3BdID0gcHQucztcblx0XHRcdFx0XHRcdGlmICghc2hhbGxvdykge1xuXHRcdFx0XHRcdFx0XHRtcHQgPSBuZXcgTWluaVByb3BUd2VlbihwdCwgXCJzXCIsIHAsIG1wdCwgcHQucik7XG5cdFx0XHRcdFx0XHRcdHB0LmMgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHB0LnR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0aSA9IHB0Lmw7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0eHAgPSBcInhuXCIgKyBpO1xuXHRcdFx0XHRcdFx0XHRcdHAgPSBwdC5wICsgXCJfXCIgKyB4cDtcblx0XHRcdFx0XHRcdFx0XHRlbmRbcF0gPSBwdC5kYXRhW3hwXTtcblx0XHRcdFx0XHRcdFx0XHRzdGFydFtwXSA9IHB0W3hwXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIXNoYWxsb3cpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1wdCA9IG5ldyBNaW5pUHJvcFR3ZWVuKHB0LCB4cCwgcCwgbXB0LCBwdC5yeHBbeHBdKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge3Byb3h5OnN0YXJ0LCBlbmQ6ZW5kLCBmaXJzdE1QVDptcHQsIHB0OmZpcnN0UFR9O1xuXHRcdFx0fSxcblxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQGNvbnN0cnVjdG9yIEVhY2ggcHJvcGVydHkgdGhhdCBpcyB0d2VlbmVkIGhhcyBhdCBsZWFzdCBvbmUgQ1NTUHJvcFR3ZWVuIGFzc29jaWF0ZWQgd2l0aCBpdC4gVGhlc2UgaW5zdGFuY2VzIHN0b3JlIGltcG9ydGFudCBpbmZvcm1hdGlvbiBsaWtlIHRoZSB0YXJnZXQsIHByb3BlcnR5LCBzdGFydGluZyB2YWx1ZSwgYW1vdW50IG9mIGNoYW5nZSwgZXRjLiBUaGV5IGNhbiBhbHNvIG9wdGlvbmFsbHkgaGF2ZSBhIG51bWJlciBvZiBcImV4dHJhXCIgc3RyaW5ncyBhbmQgbnVtZXJpYyB2YWx1ZXMgbmFtZWQgeHMxLCB4bjEsIHhzMiwgeG4yLCB4czMsIHhuMywgZXRjLiB3aGVyZSBcInNcIiBpbmRpY2F0ZXMgc3RyaW5nIGFuZCBcIm5cIiBpbmRpY2F0ZXMgbnVtYmVyLiBUaGVzZSBjYW4gYmUgcGllY2VkIHRvZ2V0aGVyIGluIGEgY29tcGxleC12YWx1ZSB0d2VlbiAodHlwZToxKSB0aGF0IGhhcyBhbHRlcm5hdGluZyB0eXBlcyBvZiBkYXRhIGxpa2UgYSBzdHJpbmcsIG51bWJlciwgc3RyaW5nLCBudW1iZXIsIGV0Yy4gRm9yIGV4YW1wbGUsIGJveFNoYWRvdyBjb3VsZCBiZSBcIjVweCA1cHggOHB4IHJnYigxMDIsIDEwMiwgNTEpXCIuIEluIHRoYXQgdmFsdWUsIHRoZXJlIGFyZSA2IG51bWJlcnMgdGhhdCBtYXkgbmVlZCB0byB0d2VlbiBhbmQgdGhlbiBwaWVjZWQgYmFjayB0b2dldGhlciBpbnRvIGEgc3RyaW5nIGFnYWluIHdpdGggc3BhY2VzLCBzdWZmaXhlcywgZXRjLiB4czAgaXMgc3BlY2lhbCBpbiB0aGF0IGl0IHN0b3JlcyB0aGUgc3VmZml4IGZvciBzdGFuZGFyZCAodHlwZTowKSB0d2VlbnMsIC1PUi0gdGhlIGZpcnN0IHN0cmluZyAocHJlZml4KSBpbiBhIGNvbXBsZXgtdmFsdWUgKHR5cGU6MSkgQ1NTUHJvcFR3ZWVuIC1PUi0gaXQgY2FuIGJlIHRoZSBub24tdHdlZW5pbmcgdmFsdWUgaW4gYSB0eXBlOi0xIENTU1Byb3BUd2Vlbi4gV2UgZG8gdGhpcyB0byBjb25zZXJ2ZSBtZW1vcnkuXG5cdFx0XHQgKiBDU1NQcm9wVHdlZW5zIGhhdmUgdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIGFzIHdlbGwgKG5vdCBkZWZpbmVkIHRocm91Z2ggdGhlIGNvbnN0cnVjdG9yKTpcblx0XHRcdCAqICAtIGw6IExlbmd0aCBpbiB0ZXJtcyBvZiB0aGUgbnVtYmVyIG9mIGV4dHJhIHByb3BlcnRpZXMgdGhhdCB0aGUgQ1NTUHJvcFR3ZWVuIGhhcyAoZGVmYXVsdDogMCkuIEZvciBleGFtcGxlLCBmb3IgYSBib3hTaGFkb3cgd2UgbWF5IG5lZWQgdG8gdHdlZW4gNSBudW1iZXJzIGluIHdoaWNoIGNhc2UgbCB3b3VsZCBiZSA1OyBLZWVwIGluIG1pbmQgdGhhdCB0aGUgc3RhcnQvZW5kIHZhbHVlcyBmb3IgdGhlIGZpcnN0IG51bWJlciB0aGF0J3MgdHdlZW5lZCBhcmUgYWx3YXlzIHN0b3JlZCBpbiB0aGUgcyBhbmQgYyBwcm9wZXJ0aWVzIHRvIGNvbnNlcnZlIG1lbW9yeS4gQWxsIGFkZGl0aW9uYWwgdmFsdWVzIHRoZXJlYWZ0ZXIgYXJlIHN0b3JlZCBpbiB4bjEsIHhuMiwgZXRjLlxuXHRcdFx0ICogIC0geGZpcnN0OiBUaGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IHN1Yi1DU1NQcm9wVHdlZW5zIHRoYXQgYXJlIHR3ZWVuaW5nIHByb3BlcnRpZXMgb2YgdGhpcyBpbnN0YW5jZS4gRm9yIGV4YW1wbGUsIHdlIG1heSBzcGxpdCB1cCBhIGJveFNoYWRvdyB0d2VlbiBzbyB0aGF0IHRoZXJlJ3MgYSBtYWluIENTU1Byb3BUd2VlbiBvZiB0eXBlOjEgdGhhdCBoYXMgdmFyaW91cyB4cyogYW5kIHhuKiB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBoLXNoYWRvdywgdi1zaGFkb3csIGJsdXIsIGNvbG9yLCBldGMuIFRoZW4gd2Ugc3Bhd24gYSBDU1NQcm9wVHdlZW4gZm9yIGVhY2ggb2YgdGhvc2UgdGhhdCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgYW5kIHJ1bnMgQkVGT1JFIHRoZSBtYWluIENTU1Byb3BUd2VlbiBzbyB0aGF0IHRoZSB2YWx1ZXMgYXJlIGFsbCBzZXQgYnkgdGhlIHRpbWUgaXQgbmVlZHMgdG8gcmUtYXNzZW1ibGUgdGhlbS4gVGhlIHhmaXJzdCBnaXZlcyB1cyBhbiBlYXN5IHdheSB0byBpZGVudGlmeSB0aGUgZmlyc3Qgb25lIGluIHRoYXQgY2hhaW4gd2hpY2ggdHlwaWNhbGx5IGVuZHMgYXQgdGhlIG1haW4gb25lIChiZWNhdXNlIHRoZXkncmUgYWxsIHByZXBlbmRlIHRvIHRoZSBsaW5rZWQgbGlzdClcblx0XHRcdCAqICAtIHBsdWdpbjogVGhlIFR3ZWVuUGx1Z2luIGluc3RhbmNlIHRoYXQgd2lsbCBoYW5kbGUgdGhlIHR3ZWVuaW5nIG9mIGFueSBjb21wbGV4IHZhbHVlcy4gRm9yIGV4YW1wbGUsIHNvbWV0aW1lcyB3ZSBkb24ndCB3YW50IHRvIHVzZSBub3JtYWwgc3VidHdlZW5zIChsaWtlIHhmaXJzdCByZWZlcnMgdG8pIHRvIHR3ZWVuIHRoZSB2YWx1ZXMgLSB3ZSBtaWdodCB3YW50IFRocm93UHJvcHNQbHVnaW4gb3IgQmV6aWVyUGx1Z2luIHNvbWUgb3RoZXIgcGx1Z2luIHRvIGRvIHRoZSBhY3R1YWwgdHdlZW5pbmcsIHNvIHdlIGNyZWF0ZSBhIHBsdWdpbiBpbnN0YW5jZSBhbmQgc3RvcmUgYSByZWZlcmVuY2UgaGVyZS4gV2UgbmVlZCB0aGlzIHJlZmVyZW5jZSBzbyB0aGF0IGlmIHdlIGdldCBhIHJlcXVlc3QgdG8gcm91bmQgdmFsdWVzIG9yIGRpc2FibGUgYSB0d2Vlbiwgd2UgY2FuIHBhc3MgYWxvbmcgdGhhdCByZXF1ZXN0LlxuXHRcdFx0ICogIC0gZGF0YTogQXJiaXRyYXJ5IGRhdGEgdGhhdCBuZWVkcyB0byBiZSBzdG9yZWQgd2l0aCB0aGUgQ1NTUHJvcFR3ZWVuLiBUeXBpY2FsbHkgaWYgd2UncmUgZ29pbmcgdG8gaGF2ZSBhIHBsdWdpbiBoYW5kbGUgdGhlIHR3ZWVuaW5nIG9mIGEgY29tcGxleC12YWx1ZSB0d2Vlbiwgd2UgY3JlYXRlIGEgZ2VuZXJpYyBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIEVORCB2YWx1ZXMgdGhhdCB3ZSdyZSB0d2VlbmluZyB0byBhbmQgdGhlIENTU1Byb3BUd2VlbidzIHhzMSwgeHMyLCBldGMuIGhhdmUgdGhlIHN0YXJ0aW5nIHZhbHVlcy4gV2Ugc3RvcmUgdGhhdCBvYmplY3QgYXMgZGF0YS4gVGhhdCB3YXksIHdlIGNhbiBzaW1wbHkgcGFzcyB0aGF0IG9iamVjdCB0byB0aGUgcGx1Z2luIGFuZCB1c2UgdGhlIENTU1Byb3BUd2VlbiBhcyB0aGUgdGFyZ2V0LlxuXHRcdFx0ICogIC0gc2V0UmF0aW86IE9ubHkgdXNlZCBmb3IgdHlwZToyIHR3ZWVucyB0aGF0IHJlcXVpcmUgY3VzdG9tIGZ1bmN0aW9uYWxpdHkuIEluIHRoaXMgY2FzZSwgd2UgY2FsbCB0aGUgQ1NTUHJvcFR3ZWVuJ3Mgc2V0UmF0aW8oKSBtZXRob2QgYW5kIHBhc3MgdGhlIHJhdGlvIGVhY2ggdGltZSB0aGUgdHdlZW4gdXBkYXRlcy4gVGhpcyBpc24ndCBxdWl0ZSBhcyBlZmZpY2llbnQgYXMgZG9pbmcgdGhpbmdzIGRpcmVjdGx5IGluIHRoZSBDU1NQbHVnaW4ncyBzZXRSYXRpbygpIG1ldGhvZCwgYnV0IGl0J3MgdmVyeSBjb252ZW5pZW50IGFuZCBmbGV4aWJsZS5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnR5IHdpbGwgYmUgdHdlZW5lZC4gT2Z0ZW4gYSBET00gZWxlbWVudCwgYnV0IG5vdCBhbHdheXMuIEl0IGNvdWxkIGJlIGFueXRoaW5nLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHAgUHJvcGVydHkgdG8gdHdlZW4gKG5hbWUpLiBGb3IgZXhhbXBsZSwgdG8gdHdlZW4gZWxlbWVudC53aWR0aCwgcCB3b3VsZCBiZSBcIndpZHRoXCIuXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcn0gcyBTdGFydGluZyBudW1lcmljIHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcn0gYyBDaGFuZ2UgaW4gbnVtZXJpYyB2YWx1ZSBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIGVudGlyZSB0d2Vlbi4gRm9yIGV4YW1wbGUsIGlmIGVsZW1lbnQud2lkdGggc3RhcnRzIGF0IDUgYW5kIHNob3VsZCBlbmQgYXQgMTAwLCBjIHdvdWxkIGJlIDk1LlxuXHRcdFx0ICogQHBhcmFtIHtDU1NQcm9wVHdlZW49fSBuZXh0IFRoZSBuZXh0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3QuIElmIG9uZSBpcyBkZWZpbmVkLCB3ZSB3aWxsIGRlZmluZSBpdHMgX3ByZXYgYXMgdGhlIG5ldyBpbnN0YW5jZSwgYW5kIHRoZSBuZXcgaW5zdGFuY2UncyBfbmV4dCB3aWxsIGJlIHBvaW50ZWQgYXQgaXQuXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcj19IHR5cGUgVGhlIHR5cGUgb2YgQ1NTUHJvcFR3ZWVuIHdoZXJlIC0xID0gYSBub24tdHdlZW5pbmcgdmFsdWUsIDAgPSBhIHN0YW5kYXJkIHNpbXBsZSB0d2VlbiwgMSA9IGEgY29tcGxleCB2YWx1ZSAobGlrZSBvbmUgdGhhdCBoYXMgbXVsdGlwbGUgbnVtYmVycyBpbiBhIGNvbW1hLSBvciBzcGFjZS1kZWxpbWl0ZWQgc3RyaW5nIGxpa2UgYm9yZGVyOlwiMXB4IHNvbGlkIHJlZFwiKSwgYW5kIDIgPSBvbmUgdGhhdCB1c2VzIGEgY3VzdG9tIHNldFJhdGlvIGZ1bmN0aW9uIHRoYXQgZG9lcyBhbGwgb2YgdGhlIHdvcmsgb2YgYXBwbHlpbmcgdGhlIHZhbHVlcyBvbiBlYWNoIHVwZGF0ZS5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gbiBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBvdmVyd3JpdGluZyBwdXJwb3NlcyB3aGljaCBpcyB0eXBpY2FsbHkgdGhlIHNhbWUgYXMgcCBidXQgbm90IGFsd2F5cy4gRm9yIGV4YW1wbGUsIHdlIG1heSBuZWVkIHRvIGNyZWF0ZSBhIHN1YnR3ZWVuIGZvciB0aGUgMm5kIHBhcnQgb2YgYSBcImNsaXA6cmVjdCguLi4pXCIgdHdlZW4gaW4gd2hpY2ggY2FzZSBcInBcIiBtaWdodCBiZSB4czEgYnV0IFwiblwiIGlzIHN0aWxsIFwiY2xpcFwiXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByIElmIHRydWUsIHRoZSB2YWx1ZShzKSBzaG91bGQgYmUgcm91bmRlZFxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXI9fSBwciBQcmlvcml0eSBpbiB0aGUgbGlua2VkIGxpc3Qgb3JkZXIuIEhpZ2hlciBwcmlvcml0eSBDU1NQcm9wVHdlZW5zIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy4gVGhlIGRlZmF1bHQgcHJpb3JpdHkgaXMgMC5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gYiBCZWdpbm5pbmcgdmFsdWUuIFdlIHN0b3JlIHRoaXMgdG8gZW5zdXJlIHRoYXQgaXQgaXMgRVhBQ1RMWSB3aGF0IGl0IHdhcyB3aGVuIHRoZSB0d2VlbiBiZWdhbiB3aXRob3V0IGFueSByaXNrIG9mIGludGVycHJldGF0aW9uIGlzc3Vlcy5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gZSBFbmRpbmcgdmFsdWUuIFdlIHN0b3JlIHRoaXMgdG8gZW5zdXJlIHRoYXQgaXQgaXMgRVhBQ1RMWSB3aGF0IHRoZSB1c2VyIGRlZmluZWQgYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4gd2l0aG91dCBhbnkgcmlzayBvZiBpbnRlcnByZXRhdGlvbiBpc3N1ZXMuXG5cdFx0XHQgKi9cblx0XHRcdENTU1Byb3BUd2VlbiA9IF9pbnRlcm5hbHMuQ1NTUHJvcFR3ZWVuID0gZnVuY3Rpb24odCwgcCwgcywgYywgbmV4dCwgdHlwZSwgbiwgciwgcHIsIGIsIGUpIHtcblx0XHRcdFx0dGhpcy50ID0gdDsgLy90YXJnZXRcblx0XHRcdFx0dGhpcy5wID0gcDsgLy9wcm9wZXJ0eVxuXHRcdFx0XHR0aGlzLnMgPSBzOyAvL3N0YXJ0aW5nIHZhbHVlXG5cdFx0XHRcdHRoaXMuYyA9IGM7IC8vY2hhbmdlIHZhbHVlXG5cdFx0XHRcdHRoaXMubiA9IG4gfHwgcDsgLy9uYW1lIHRoYXQgdGhpcyBDU1NQcm9wVHdlZW4gc2hvdWxkIGJlIGFzc29jaWF0ZWQgdG8gKHVzdWFsbHkgdGhlIHNhbWUgYXMgcCwgYnV0IG5vdCBhbHdheXMgLSBuIGlzIHdoYXQgb3ZlcndyaXRpbmcgbG9va3MgYXQpXG5cdFx0XHRcdGlmICghKHQgaW5zdGFuY2VvZiBDU1NQcm9wVHdlZW4pKSB7XG5cdFx0XHRcdFx0X292ZXJ3cml0ZVByb3BzLnB1c2godGhpcy5uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnIgPSByOyAvL3JvdW5kIChib29sZWFuKVxuXHRcdFx0XHR0aGlzLnR5cGUgPSB0eXBlIHx8IDA7IC8vMCA9IG5vcm1hbCB0d2VlbiwgLTEgPSBub24tdHdlZW5pbmcgKGluIHdoaWNoIGNhc2UgeHMwIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgdGFyZ2V0J3MgcHJvcGVydHksIGxpa2UgdHAudFt0cC5wXSA9IHRwLnhzMCksIDEgPSBjb21wbGV4LXZhbHVlIFNwZWNpYWxQcm9wLCAyID0gY3VzdG9tIHNldFJhdGlvKCkgdGhhdCBkb2VzIGFsbCB0aGUgd29ya1xuXHRcdFx0XHRpZiAocHIpIHtcblx0XHRcdFx0XHR0aGlzLnByID0gcHI7XG5cdFx0XHRcdFx0X2hhc1ByaW9yaXR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmIgPSAoYiA9PT0gdW5kZWZpbmVkKSA/IHMgOiBiO1xuXHRcdFx0XHR0aGlzLmUgPSAoZSA9PT0gdW5kZWZpbmVkKSA/IHMgKyBjIDogZTtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHR0aGlzLl9uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X2FkZE5vblR3ZWVuaW5nTnVtZXJpY1BUID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBuZXh0LCBvdmVyd3JpdGVQcm9wKSB7IC8vY2xlYW5zIHVwIHNvbWUgY29kZSByZWR1bmRhbmNpZXMgYW5kIGhlbHBzIG1pbmlmaWNhdGlvbi4gSnVzdCBhIGZhc3Qgd2F5IHRvIGFkZCBhIE5VTUVSSUMgbm9uLXR3ZWVuaW5nIENTU1Byb3BUd2VlblxuXHRcdFx0XHR2YXIgcHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCAtIHN0YXJ0LCBuZXh0LCAtMSwgb3ZlcndyaXRlUHJvcCk7XG5cdFx0XHRcdHB0LmIgPSBzdGFydDtcblx0XHRcdFx0cHQuZSA9IHB0LnhzMCA9IGVuZDtcblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUYWtlcyBhIHRhcmdldCwgdGhlIGJlZ2lubmluZyB2YWx1ZSBhbmQgZW5kaW5nIHZhbHVlIChhcyBzdHJpbmdzKSBhbmQgcGFyc2VzIHRoZW0gaW50byBhIENTU1Byb3BUd2VlbiAocG9zc2libHkgd2l0aCBjaGlsZCBDU1NQcm9wVHdlZW5zKSB0aGF0IGFjY29tbW9kYXRlcyBtdWx0aXBsZSBudW1iZXJzLCBjb2xvcnMsIGNvbW1hLWRlbGltaXRlZCB2YWx1ZXMsIGV0Yy4gRm9yIGV4YW1wbGU6XG5cdFx0XHQgKiBzcC5wYXJzZUNvbXBsZXgoZWxlbWVudCwgXCJib3hTaGFkb3dcIiwgXCI1cHggMTBweCAyMHB4IHJnYigyNTUsMTAyLDUxKVwiLCBcIjBweCAwcHggMHB4IHJlZFwiLCB0cnVlLCBcIjBweCAwcHggMHB4IHJnYigwLDAsMCwwKVwiLCBwdCk7XG5cdFx0XHQgKiBJdCB3aWxsIHdhbGsgdGhyb3VnaCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzICh3aGljaCBzaG91bGQgYmUgaW4gdGhlIHNhbWUgZm9ybWF0IHdpdGggdGhlIHNhbWUgbnVtYmVyIGFuZCB0eXBlIG9mIHZhbHVlcykgYW5kIGZpZ3VyZSBvdXQgd2hpY2ggcGFydHMgYXJlIG51bWJlcnMsIHdoYXQgc3RyaW5ncyBzZXBhcmF0ZSB0aGUgbnVtZXJpYy90d2VlbmFibGUgdmFsdWVzLCBhbmQgdGhlbiBjcmVhdGUgdGhlIENTU1Byb3BUd2VlbnMgYWNjb3JkaW5nbHkuIElmIGEgcGx1Z2luIGlzIGRlZmluZWQsIG5vIGNoaWxkIENTU1Byb3BUd2VlbnMgd2lsbCBiZSBjcmVhdGVkLiBJbnN0ZWFkLCB0aGUgZW5kaW5nIHZhbHVlcyB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgXCJkYXRhXCIgcHJvcGVydHkgb2YgdGhlIHJldHVybmVkIENTU1Byb3BUd2VlbiBsaWtlOiB7czotNSwgeG4xOi0xMCwgeG4yOi0yMCwgeG4zOjI1NSwgeG40OjAsIHhuNTowfSBzbyB0aGF0IGl0IGNhbiBiZSBmZWQgdG8gYW55IG90aGVyIHBsdWdpbiBhbmQgaXQnbGwgYmUgcGxhaW4gbnVtZXJpYyB0d2VlbnMgYnV0IHRoZSByZWNvbXBvc2l0aW9uIG9mIHRoZSBjb21wbGV4IHZhbHVlIHdpbGwgYmUgaGFuZGxlZCBpbnNpZGUgQ1NTUGx1Z2luJ3Mgc2V0UmF0aW8oKS5cblx0XHRcdCAqIElmIGEgc2V0UmF0aW8gaXMgZGVmaW5lZCwgdGhlIHR5cGUgb2YgdGhlIENTU1Byb3BUd2VlbiB3aWxsIGJlIHNldCB0byAyIGFuZCByZWNvbXBvc2l0aW9uIG9mIHRoZSB2YWx1ZXMgd2lsbCBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhhdCBtZXRob2QuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCB3aG9zZSBwcm9wZXJ0eSB3aWxsIGJlIHR3ZWVuZWRcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSB0aGF0IHdpbGwgYmUgdHdlZW5lZCAoaXRzIG5hbWUsIGxpa2UgXCJsZWZ0XCIgb3IgXCJiYWNrZ3JvdW5kQ29sb3JcIiBvciBcImJveFNoYWRvd1wiKVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGIgQmVnaW5uaW5nIHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZSBFbmRpbmcgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xycyBJZiB0cnVlLCB0aGUgdmFsdWUgY291bGQgY29udGFpbiBhIGNvbG9yIHZhbHVlIGxpa2UgXCJyZ2IoMjU1LDAsMClcIiBvciBcIiNGMDBcIiBvciBcInJlZFwiLiBUaGUgZGVmYXVsdCBpcyBmYWxzZSwgc28gbm8gY29sb3JzIHdpbGwgYmUgcmVjb2duaXplZCAoYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG5cdFx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfE9iamVjdCl9IGRmbHQgVGhlIGRlZmF1bHQgYmVnaW5uaW5nIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgaWYgbm8gdmFsaWQgYmVnaW5uaW5nIHZhbHVlIGlzIGRlZmluZWQgb3IgaWYgdGhlIG51bWJlciBvZiB2YWx1ZXMgaW5zaWRlIHRoZSBjb21wbGV4IGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBkb24ndCBtYXRjaFxuXHRcdFx0ICogQHBhcmFtIHs/Q1NTUHJvcFR3ZWVufSBwdCBDU1NQcm9wVHdlZW4gaW5zdGFuY2UgdGhhdCBpcyB0aGUgY3VycmVudCBoZWFkIG9mIHRoZSBsaW5rZWQgbGlzdCAod2UnbGwgcHJlcGVuZCB0byB0aGlzKS5cblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gcHIgUHJpb3JpdHkgaW4gdGhlIGxpbmtlZCBsaXN0IG9yZGVyLiBIaWdoZXIgcHJpb3JpdHkgcHJvcGVydGllcyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuIFRoZSBkZWZhdWx0IHByaW9yaXR5IGlzIDAuXG5cdFx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGEgcGx1Z2luIHNob3VsZCBoYW5kbGUgdGhlIHR3ZWVuaW5nIG9mIGV4dHJhIHByb3BlcnRpZXMsIHBhc3MgdGhlIHBsdWdpbiBpbnN0YW5jZSBoZXJlLiBJZiBvbmUgaXMgZGVmaW5lZCwgdGhlbiBOTyBzdWJ0d2VlbnMgd2lsbCBiZSBjcmVhdGVkIGZvciBhbnkgZXh0cmEgcHJvcGVydGllcyAodGhlIHByb3BlcnRpZXMgd2lsbCBiZSBjcmVhdGVkIC0ganVzdCBub3QgYWRkaXRpb25hbCBDU1NQcm9wVHdlZW4gaW5zdGFuY2VzIHRvIHR3ZWVuIHRoZW0pIGJlY2F1c2UgdGhlIHBsdWdpbiBpcyBleHBlY3RlZCB0byBkbyBzby4gSG93ZXZlciwgdGhlIGVuZCB2YWx1ZXMgV0lMTCBiZSBwb3B1bGF0ZWQgaW4gdGhlIFwiZGF0YVwiIHByb3BlcnR5LCBsaWtlIHtzOjEwMCwgeG4xOjUwLCB4bjI6MzAwfVxuXHRcdFx0ICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpPX0gc2V0UmF0aW8gSWYgdmFsdWVzIHNob3VsZCBiZSBzZXQgaW4gYSBjdXN0b20gZnVuY3Rpb24gaW5zdGVhZCBvZiBiZWluZyBwaWVjZWQgdG9nZXRoZXIgaW4gYSB0eXBlOjEgKGNvbXBsZXgtdmFsdWUpIENTU1Byb3BUd2VlbiwgZGVmaW5lIHRoYXQgY3VzdG9tIGZ1bmN0aW9uIGhlcmUuXG5cdFx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW59IFRoZSBmaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0IHdoaWNoIGluY2x1ZGVzIHRoZSBuZXcgb25lKHMpIGFkZGVkIGJ5IHRoZSBwYXJzZUNvbXBsZXgoKSBjYWxsLlxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VDb21wbGV4ID0gQ1NTUGx1Z2luLnBhcnNlQ29tcGxleCA9IGZ1bmN0aW9uKHQsIHAsIGIsIGUsIGNscnMsIGRmbHQsIHB0LCBwciwgcGx1Z2luLCBzZXRSYXRpbykge1xuXHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwicGFyc2VDb21wbGV4OiBcIitwK1wiLCBiOiBcIitiK1wiLCBlOiBcIitlKTtcblx0XHRcdFx0YiA9IGIgfHwgZGZsdCB8fCBcIlwiO1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgcHQsIChzZXRSYXRpbyA/IDIgOiAxKSwgbnVsbCwgZmFsc2UsIHByLCBiLCBlKTtcblx0XHRcdFx0ZSArPSBcIlwiOyAvL2Vuc3VyZXMgaXQncyBhIHN0cmluZ1xuXHRcdFx0XHRpZiAoY2xycyAmJiBfY29sb3JFeHAudGVzdChlICsgYikpIHsgLy9pZiBjb2xvcnMgYXJlIGZvdW5kLCBub3JtYWxpemUgdGhlIGZvcm1hdHRpbmcgdG8gcmdiYSgpIG9yIGhzbGEoKS5cblx0XHRcdFx0XHRlID0gW2IsIGVdO1xuXHRcdFx0XHRcdENTU1BsdWdpbi5jb2xvclN0cmluZ0ZpbHRlcihlKTtcblx0XHRcdFx0XHRiID0gZVswXTtcblx0XHRcdFx0XHRlID0gZVsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgYmEgPSBiLnNwbGl0KFwiLCBcIikuam9pbihcIixcIikuc3BsaXQoXCIgXCIpLCAvL2JlZ2lubmluZyBhcnJheVxuXHRcdFx0XHRcdGVhID0gZS5zcGxpdChcIiwgXCIpLmpvaW4oXCIsXCIpLnNwbGl0KFwiIFwiKSwgLy9lbmRpbmcgYXJyYXlcblx0XHRcdFx0XHRsID0gYmEubGVuZ3RoLFxuXHRcdFx0XHRcdGF1dG9Sb3VuZCA9IChfYXV0b1JvdW5kICE9PSBmYWxzZSksXG5cdFx0XHRcdFx0aSwgeGksIG5pLCBidiwgZXYsIGJudW1zLCBlbnVtcywgYm4sIGhhc0FscGhhLCB0ZW1wLCBjdiwgc3RyLCB1c2VIU0w7XG5cdFx0XHRcdGlmIChlLmluZGV4T2YoXCIsXCIpICE9PSAtMSB8fCBiLmluZGV4T2YoXCIsXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdGJhID0gYmEuam9pbihcIiBcIikucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcIiwgXCIpLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRlYSA9IGVhLmpvaW4oXCIgXCIpLnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCIsIFwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0bCA9IGJhLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobCAhPT0gZWEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcIm1pc21hdGNoZWQgZm9ybWF0dGluZyBkZXRlY3RlZCBvbiBcIiArIHAgKyBcIiAoXCIgKyBiICsgXCIgdnMgXCIgKyBlICsgXCIpXCIpO1xuXHRcdFx0XHRcdGJhID0gKGRmbHQgfHwgXCJcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGwgPSBiYS5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRwdC5zZXRSYXRpbyA9IHNldFJhdGlvO1xuXHRcdFx0XHRfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGJ2ID0gYmFbaV07XG5cdFx0XHRcdFx0ZXYgPSBlYVtpXTtcblx0XHRcdFx0XHRibiA9IHBhcnNlRmxvYXQoYnYpO1xuXHRcdFx0XHRcdC8vaWYgdGhlIHZhbHVlIGJlZ2lucyB3aXRoIGEgbnVtYmVyIChtb3N0IGNvbW1vbikuIEl0J3MgZmluZSBpZiBpdCBoYXMgYSBzdWZmaXggbGlrZSBweFxuXHRcdFx0XHRcdGlmIChibiB8fCBibiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYShcIlwiLCBibiwgX3BhcnNlQ2hhbmdlKGV2LCBibiksIGV2LnJlcGxhY2UoX3JlbE51bUV4cCwgXCJcIiksIChhdXRvUm91bmQgJiYgZXYuaW5kZXhPZihcInB4XCIpICE9PSAtMSksIHRydWUpO1xuXG5cdFx0XHRcdFx0Ly9pZiB0aGUgdmFsdWUgaXMgYSBjb2xvclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY2xycyAmJiBfY29sb3JFeHAudGVzdChidikpIHtcblx0XHRcdFx0XHRcdHN0ciA9IGV2LmluZGV4T2YoXCIpXCIpICsgMTtcblx0XHRcdFx0XHRcdHN0ciA9IFwiKVwiICsgKHN0ciA/IGV2LnN1YnN0cihzdHIpIDogXCJcIik7IC8vaWYgdGhlcmUncyBhIGNvbW1hIG9yICkgYXQgdGhlIGVuZCwgcmV0YWluIGl0LlxuXHRcdFx0XHRcdFx0dXNlSFNMID0gKGV2LmluZGV4T2YoXCJoc2xcIikgIT09IC0xICYmIF9zdXBwb3J0c09wYWNpdHkpO1xuXHRcdFx0XHRcdFx0YnYgPSBfcGFyc2VDb2xvcihidiwgdXNlSFNMKTtcblx0XHRcdFx0XHRcdGV2ID0gX3BhcnNlQ29sb3IoZXYsIHVzZUhTTCk7XG5cdFx0XHRcdFx0XHRoYXNBbHBoYSA9IChidi5sZW5ndGggKyBldi5sZW5ndGggPiA2KTtcblx0XHRcdFx0XHRcdGlmIChoYXNBbHBoYSAmJiAhX3N1cHBvcnRzT3BhY2l0eSAmJiBldlszXSA9PT0gMCkgeyAvL29sZGVyIHZlcnNpb25zIG9mIElFIGRvbid0IHN1cHBvcnQgcmdiYSgpLCBzbyBpZiB0aGUgZGVzdGluYXRpb24gYWxwaGEgaXMgMCwganVzdCB1c2UgXCJ0cmFuc3BhcmVudFwiIGZvciB0aGUgZW5kIGNvbG9yXG5cdFx0XHRcdFx0XHRcdHB0W1wieHNcIiArIHB0LmxdICs9IHB0LmwgPyBcIiB0cmFuc3BhcmVudFwiIDogXCJ0cmFuc3BhcmVudFwiO1xuXHRcdFx0XHRcdFx0XHRwdC5lID0gcHQuZS5zcGxpdChlYVtpXSkuam9pbihcInRyYW5zcGFyZW50XCIpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFfc3VwcG9ydHNPcGFjaXR5KSB7IC8vb2xkIHZlcnNpb25zIG9mIElFIGRvbid0IHN1cHBvcnQgcmdiYSgpLlxuXHRcdFx0XHRcdFx0XHRcdGhhc0FscGhhID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHVzZUhTTCkge1xuXHRcdFx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoKGhhc0FscGhhID8gXCJoc2xhKFwiIDogXCJoc2woXCIpLCBidlswXSwgX3BhcnNlQ2hhbmdlKGV2WzBdLCBidlswXSksIFwiLFwiLCBmYWxzZSwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmRYdHJhKFwiXCIsIGJ2WzFdLCBfcGFyc2VDaGFuZ2UoZXZbMV0sIGJ2WzFdKSwgXCIlLFwiLCBmYWxzZSlcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmRYdHJhKFwiXCIsIGJ2WzJdLCBfcGFyc2VDaGFuZ2UoZXZbMl0sIGJ2WzJdKSwgKGhhc0FscGhhID8gXCIlLFwiIDogXCIlXCIgKyBzdHIpLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYSgoaGFzQWxwaGEgPyBcInJnYmEoXCIgOiBcInJnYihcIiksIGJ2WzBdLCBldlswXSAtIGJ2WzBdLCBcIixcIiwgdHJ1ZSwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmRYdHJhKFwiXCIsIGJ2WzFdLCBldlsxXSAtIGJ2WzFdLCBcIixcIiwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmRYdHJhKFwiXCIsIGJ2WzJdLCBldlsyXSAtIGJ2WzJdLCAoaGFzQWxwaGEgPyBcIixcIiA6IHN0ciksIHRydWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGhhc0FscGhhKSB7XG5cdFx0XHRcdFx0XHRcdFx0YnYgPSAoYnYubGVuZ3RoIDwgNCkgPyAxIDogYnZbM107XG5cdFx0XHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYShcIlwiLCBidiwgKChldi5sZW5ndGggPCA0KSA/IDEgOiBldlszXSkgLSBidiwgc3RyLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdF9jb2xvckV4cC5sYXN0SW5kZXggPSAwOyAvL290aGVyd2lzZSB0aGUgdGVzdCgpIG9uIHRoZSBSZWdFeHAgY291bGQgbW92ZSB0aGUgbGFzdEluZGV4IGFuZCB0YWludCBmdXR1cmUgcmVzdWx0cy5cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRibnVtcyA9IGJ2Lm1hdGNoKF9udW1FeHApOyAvL2dldHMgZWFjaCBncm91cCBvZiBudW1iZXJzIGluIHRoZSBiZWdpbm5pbmcgdmFsdWUgc3RyaW5nIGFuZCBkcm9wcyB0aGVtIGludG8gYW4gYXJyYXlcblxuXHRcdFx0XHRcdFx0Ly9pZiBubyBudW1iZXIgaXMgZm91bmQsIHRyZWF0IGl0IGFzIGEgbm9uLXR3ZWVuaW5nIHZhbHVlIGFuZCBqdXN0IGFwcGVuZCB0aGUgc3RyaW5nIHRvIHRoZSBjdXJyZW50IHhzLlxuXHRcdFx0XHRcdFx0aWYgKCFibnVtcykge1xuXHRcdFx0XHRcdFx0XHRwdFtcInhzXCIgKyBwdC5sXSArPSAocHQubCB8fCBwdFtcInhzXCIgKyBwdC5sXSkgPyBcIiBcIiArIGV2IDogZXY7XG5cblx0XHRcdFx0XHRcdC8vbG9vcCB0aHJvdWdoIGFsbCB0aGUgbnVtYmVycyB0aGF0IGFyZSBmb3VuZCBhbmQgY29uc3RydWN0IHRoZSBleHRyYSB2YWx1ZXMgb24gdGhlIHB0LlxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZW51bXMgPSBldi5tYXRjaChfcmVsTnVtRXhwKTsgLy9nZXQgZWFjaCBncm91cCBvZiBudW1iZXJzIGluIHRoZSBlbmQgdmFsdWUgc3RyaW5nIGFuZCBkcm9wIHRoZW0gaW50byBhbiBhcnJheS4gV2UgYWxsb3cgcmVsYXRpdmUgdmFsdWVzIHRvbywgbGlrZSArPTUwIG9yIC09LjVcblx0XHRcdFx0XHRcdFx0aWYgKCFlbnVtcyB8fCBlbnVtcy5sZW5ndGggIT09IGJudW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJtaXNtYXRjaGVkIGZvcm1hdHRpbmcgZGV0ZWN0ZWQgb24gXCIgKyBwICsgXCIgKFwiICsgYiArIFwiIHZzIFwiICsgZSArIFwiKVwiKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bmkgPSAwO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHhpID0gMDsgeGkgPCBibnVtcy5sZW5ndGg7IHhpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjdiA9IGJudW1zW3hpXTtcblx0XHRcdFx0XHRcdFx0XHR0ZW1wID0gYnYuaW5kZXhPZihjdiwgbmkpO1xuXHRcdFx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoYnYuc3Vic3RyKG5pLCB0ZW1wIC0gbmkpLCBOdW1iZXIoY3YpLCBfcGFyc2VDaGFuZ2UoZW51bXNbeGldLCBjdiksIFwiXCIsIChhdXRvUm91bmQgJiYgYnYuc3Vic3RyKHRlbXAgKyBjdi5sZW5ndGgsIDIpID09PSBcInB4XCIpLCAoeGkgPT09IDApKTtcblx0XHRcdFx0XHRcdFx0XHRuaSA9IHRlbXAgKyBjdi5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gKz0gYnYuc3Vic3RyKG5pKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9pZiB0aGVyZSBhcmUgcmVsYXRpdmUgdmFsdWVzIChcIis9XCIgb3IgXCItPVwiIHByZWZpeCksIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBlbmRpbmcgdmFsdWUgdG8gZWxpbWluYXRlIHRoZSBwcmVmaXhlcyBhbmQgY29tYmluZSB0aGUgdmFsdWVzIHByb3Blcmx5LlxuXHRcdFx0XHRpZiAoZS5pbmRleE9mKFwiPVwiKSAhPT0gLTEpIGlmIChwdC5kYXRhKSB7XG5cdFx0XHRcdFx0c3RyID0gcHQueHMwICsgcHQuZGF0YS5zO1xuXHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBwdC5sOyBpKyspIHtcblx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhzXCIgKyBpXSArIHB0LmRhdGFbXCJ4blwiICsgaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0LmUgPSBzdHIgKyBwdFtcInhzXCIgKyBpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXB0LmwpIHtcblx0XHRcdFx0XHRwdC50eXBlID0gLTE7XG5cdFx0XHRcdFx0cHQueHMwID0gcHQuZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHQueGZpcnN0IHx8IHB0O1xuXHRcdFx0fSxcblx0XHRcdGkgPSA5O1xuXG5cblx0XHRwID0gQ1NTUHJvcFR3ZWVuLnByb3RvdHlwZTtcblx0XHRwLmwgPSBwLnByID0gMDsgLy9sZW5ndGggKG51bWJlciBvZiBleHRyYSBwcm9wZXJ0aWVzIGxpa2UgeG4xLCB4bjIsIHhuMywgZXRjLlxuXHRcdHdoaWxlICgtLWkgPiAwKSB7XG5cdFx0XHRwW1wieG5cIiArIGldID0gMDtcblx0XHRcdHBbXCJ4c1wiICsgaV0gPSBcIlwiO1xuXHRcdH1cblx0XHRwLnhzMCA9IFwiXCI7XG5cdFx0cC5fbmV4dCA9IHAuX3ByZXYgPSBwLnhmaXJzdCA9IHAuZGF0YSA9IHAucGx1Z2luID0gcC5zZXRSYXRpbyA9IHAucnhwID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogQXBwZW5kcyBhbmQgZXh0cmEgdHdlZW5pbmcgdmFsdWUgdG8gYSBDU1NQcm9wVHdlZW4gYW5kIGF1dG9tYXRpY2FsbHkgbWFuYWdlcyBhbnkgcHJlZml4IGFuZCBzdWZmaXggc3RyaW5ncy4gVGhlIGZpcnN0IGV4dHJhIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgcyBhbmQgYyBvZiB0aGUgbWFpbiBDU1NQcm9wVHdlZW4gaW5zdGFuY2UsIGJ1dCB0aGVyZWFmdGVyIGFueSBleHRyYXMgYXJlIHN0b3JlZCBpbiB0aGUgeG4xLCB4bjIsIHhuMywgZXRjLiBUaGUgcHJlZml4ZXMgYW5kIHN1ZmZpeGVzIGFyZSBzdG9yZWQgaW4gdGhlIHhzMCwgeHMxLCB4czIsIGV0Yy4gcHJvcGVydGllcy4gRm9yIGV4YW1wbGUsIGlmIEkgd2FsayB0aHJvdWdoIGEgY2xpcCB2YWx1ZSBsaWtlIFwicmVjdCgxMHB4LCA1cHgsIDBweCwgMjBweClcIiwgdGhlIHZhbHVlcyB3b3VsZCBiZSBzdG9yZWQgbGlrZSB0aGlzOlxuXHRcdCAqIHhzMDpcInJlY3QoXCIsIHM6MTAsIHhzMTpcInB4LCBcIiwgeG4xOjUsIHhzMjpcInB4LCBcIiwgeG4yOjAsIHhzMzpcInB4LCBcIiwgeG4zOjIwLCB4bjQ6XCJweClcIlxuXHRcdCAqIEFuZCB0aGV5J2QgYWxsIGdldCBqb2luZWQgdG9nZXRoZXIgd2hlbiB0aGUgQ1NTUGx1Z2luIHJlbmRlcnMgKGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZCkuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBwZnggUHJlZml4IChpZiBhbnkpXG5cdFx0ICogQHBhcmFtIHshbnVtYmVyfSBzIFN0YXJ0aW5nIHZhbHVlXG5cdFx0ICogQHBhcmFtIHshbnVtYmVyfSBjIENoYW5nZSBpbiBudW1lcmljIHZhbHVlIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgZW50aXJlIHR3ZWVuLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHN0YXJ0IGlzIDUgYW5kIHRoZSBlbmQgaXMgMTAwLCB0aGUgY2hhbmdlIHdvdWxkIGJlIDk1LlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gc2Z4IFN1ZmZpeCAoaWYgYW55KVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHIgUm91bmQgKGlmIHRydWUpLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHBhZCBJZiB0cnVlLCB0aGlzIGV4dHJhIHZhbHVlIHNob3VsZCBiZSBzZXBhcmF0ZWQgYnkgdGhlIHByZXZpb3VzIG9uZSBieSBhIHNwYWNlLiBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBleHRyYSBhbmQgcGFkIGlzIHRydWUsIGl0IHdpbGwgYXV0b21hdGljYWxseSBkcm9wIHRoZSBzcGFjZS5cblx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW59IHJldHVybnMgaXRzZWxmIHNvIHRoYXQgbXVsdGlwbGUgbWV0aG9kcyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci5cblx0XHQgKi9cblx0XHRwLmFwcGVuZFh0cmEgPSBmdW5jdGlvbihwZngsIHMsIGMsIHNmeCwgciwgcGFkKSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLFxuXHRcdFx0XHRsID0gcHQubDtcblx0XHRcdHB0W1wieHNcIiArIGxdICs9IChwYWQgJiYgKGwgfHwgcHRbXCJ4c1wiICsgbF0pKSA/IFwiIFwiICsgcGZ4IDogcGZ4IHx8IFwiXCI7XG5cdFx0XHRpZiAoIWMpIGlmIChsICE9PSAwICYmICFwdC5wbHVnaW4pIHsgLy90eXBpY2FsbHkgd2UnbGwgY29tYmluZSBub24tY2hhbmdpbmcgdmFsdWVzIHJpZ2h0IGludG8gdGhlIHhzIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlLCBidXQgd2UgZG9uJ3QgY29tYmluZSB0aGVtIHdoZW4gdGhlcmUncyBhIHBsdWdpbiB0aGF0IHdpbGwgYmUgdHdlZW5pbmcgdGhlIHZhbHVlcyBiZWNhdXNlIGl0IG1heSBkZXBlbmQgb24gdGhlIHZhbHVlcyBiZWluZyBzcGxpdCBhcGFydCwgbGlrZSBmb3IgYSBiZXppZXIsIGlmIGEgdmFsdWUgZG9lc24ndCBjaGFuZ2UgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIHNlY29uZCBpdGVyYXRpb24gYnV0IHRoZW4gaXQgZG9lcyBvbiB0aGUgM3JkLCB3ZSdsbCBydW4gaW50byB0cm91YmxlIGJlY2F1c2UgdGhlcmUncyBubyB4biBzbG90IGZvciB0aGF0IHZhbHVlIVxuXHRcdFx0XHRwdFtcInhzXCIgKyBsXSArPSBzICsgKHNmeCB8fCBcIlwiKTtcblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fVxuXHRcdFx0cHQubCsrO1xuXHRcdFx0cHQudHlwZSA9IHB0LnNldFJhdGlvID8gMiA6IDE7XG5cdFx0XHRwdFtcInhzXCIgKyBwdC5sXSA9IHNmeCB8fCBcIlwiO1xuXHRcdFx0aWYgKGwgPiAwKSB7XG5cdFx0XHRcdHB0LmRhdGFbXCJ4blwiICsgbF0gPSBzICsgYztcblx0XHRcdFx0cHQucnhwW1wieG5cIiArIGxdID0gcjsgLy9yb3VuZCBleHRyYSBwcm9wZXJ0eSAod2UgbmVlZCB0byB0YXAgaW50byB0aGlzIGluIHRoZSBfcGFyc2VUb1Byb3h5KCkgbWV0aG9kKVxuXHRcdFx0XHRwdFtcInhuXCIgKyBsXSA9IHM7XG5cdFx0XHRcdGlmICghcHQucGx1Z2luKSB7XG5cdFx0XHRcdFx0cHQueGZpcnN0ID0gbmV3IENTU1Byb3BUd2VlbihwdCwgXCJ4blwiICsgbCwgcywgYywgcHQueGZpcnN0IHx8IHB0LCAwLCBwdC5uLCByLCBwdC5wcik7XG5cdFx0XHRcdFx0cHQueGZpcnN0LnhzMCA9IDA7IC8vanVzdCB0byBlbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgc3RheXMgbnVtZXJpYyB3aGljaCBoZWxwcyBtb2Rlcm4gYnJvd3NlcnMgc3BlZWQgdXAgcHJvY2Vzc2luZy4gUmVtZW1iZXIsIGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZCwgd2UgZG8gcHQudFtwdC5wXSA9IHZhbCArIHB0LnhzMCBzbyBpZiBwdC54czAgaXMgXCJcIiAodGhlIGRlZmF1bHQpLCBpdCdsbCBjYXN0IHRoZSBlbmQgdmFsdWUgYXMgYSBzdHJpbmcuIFdoZW4gYSBwcm9wZXJ0eSBpcyBhIG51bWJlciBzb21ldGltZXMgYW5kIGEgc3RyaW5nIHNvbWV0aW1lcywgaXQgcHJldmVudHMgdGhlIGNvbXBpbGVyIGZyb20gbG9ja2luZyBpbiB0aGUgZGF0YSB0eXBlLCBzbG93aW5nIHRoaW5ncyBkb3duIHNsaWdodGx5LlxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH1cblx0XHRcdHB0LmRhdGEgPSB7czpzICsgY307XG5cdFx0XHRwdC5yeHAgPSB7fTtcblx0XHRcdHB0LnMgPSBzO1xuXHRcdFx0cHQuYyA9IGM7XG5cdFx0XHRwdC5yID0gcjtcblx0XHRcdHJldHVybiBwdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQGNvbnN0cnVjdG9yIEEgU3BlY2lhbFByb3AgaXMgYmFzaWNhbGx5IGEgY3NzIHByb3BlcnR5IHRoYXQgbmVlZHMgdG8gYmUgdHJlYXRlZCBpbiBhIG5vbi1zdGFuZGFyZCB3YXksIGxpa2UgaWYgaXQgbWF5IGNvbnRhaW4gYSBjb21wbGV4IHZhbHVlIGxpa2UgYm94U2hhZG93OlwiNXB4IDEwcHggMTVweCByZ2IoMjU1LCAxMDIsIDUxKVwiIG9yIGlmIGl0IGlzIGFzc29jaWF0ZWQgd2l0aCBhbm90aGVyIHBsdWdpbiBsaWtlIFRocm93UHJvcHNQbHVnaW4gb3IgQmV6aWVyUGx1Z2luLiBFdmVyeSBTcGVjaWFsUHJvcCBpcyBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIHByb3BlcnR5IG5hbWUgbGlrZSBcImJveFNoYWRvd1wiIG9yIFwidGhyb3dQcm9wc1wiIG9yIFwiYmV6aWVyXCIgYW5kIGl0IHdpbGwgaW50ZXJjZXB0IHRob3NlIHZhbHVlcyBpbiB0aGUgdmFycyBvYmplY3QgdGhhdCdzIHBhc3NlZCB0byB0aGUgQ1NTUGx1Z2luIGFuZCBoYW5kbGUgdGhlbSBhY2NvcmRpbmdseS5cblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZSAobGlrZSBcImJveFNoYWRvd1wiIG9yIFwidGhyb3dQcm9wc1wiKVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBhbnkgb2YgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uIG9wdGlvbnM6XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBkZWZhdWx0VmFsdWU6IHRoZSBkZWZhdWx0IHZhbHVlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBwYXJzZXI6IEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgbmFtZSBpcyBmb3VuZCBpbiB0aGUgdmFycy4gVGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlIGFuZCBpdCBzaG91bGQgZW5zdXJlIHRoYXQgaXQgaXMgcHJvcGVybHkgaW5zZXJ0ZWQgaW50byB0aGUgbGlua2VkIGxpc3QuIEl0IHdpbGwgcmVjZWl2ZSA0IHBhcmFtdGVyczogMSkgVGhlIHRhcmdldCwgMikgVGhlIHZhbHVlIGRlZmluZWQgaW4gdGhlIHZhcnMsIDMpIFRoZSBDU1NQbHVnaW4gaW5zdGFuY2UgKHdob3NlIF9maXJzdFBUIHNob3VsZCBiZSB1c2VkIGZvciB0aGUgbGlua2VkIGxpc3QpLCBhbmQgNCkgQSBjb21wdXRlZCBzdHlsZSBvYmplY3QgaWYgb25lIHdhcyBjYWxjdWxhdGVkICh0aGlzIGlzIGEgc3BlZWQgb3B0aW1pemF0aW9uIHRoYXQgYWxsb3dzIHJldHJpZXZhbCBvZiBzdGFydGluZyB2YWx1ZXMgcXVpY2tlcilcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGZvcm1hdHRlcjogYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYW55IHZhbHVlIHJlY2VpdmVkIGZvciB0aGlzIHNwZWNpYWwgcHJvcGVydHkgKGZvciBleGFtcGxlLCBib3hTaGFkb3cgY291bGQgdGFrZSBcIjVweCA1cHggcmVkXCIgYW5kIGZvcm1hdCBpdCB0byBcIjVweCA1cHggMHB4IDBweCByZWRcIiBzbyB0aGF0IGJvdGggdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBoYXZlIGEgY29tbW9uIG9yZGVyIGFuZCBxdWFudGl0eSBvZiB2YWx1ZXMuKVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gcHJlZml4OiBpZiB0cnVlLCB3ZSdsbCBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhpcyBwcm9wZXJ0eSByZXF1aXJlcyBhIHZlbmRvciBwcmVmaXggKGxpa2UgV2Via2l0IG9yIE1veiBvciBtcyBvciBPKVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gY29sb3I6IHNldCB0aGlzIHRvIHRydWUgaWYgdGhlIHZhbHVlIGZvciB0aGlzIFNwZWNpYWxQcm9wIG1heSBjb250YWluIGNvbG9yLXJlbGF0ZWQgdmFsdWVzIGxpa2UgcmdiKCksIHJnYmEoKSwgZXRjLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gcHJpb3JpdHk6IHByaW9yaXR5IGluIHRoZSBsaW5rZWQgbGlzdCBvcmRlci4gSGlnaGVyIHByaW9yaXR5IFNwZWNpYWxQcm9wcyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuIFRoZSBkZWZhdWx0IHByaW9yaXR5IGlzIDAuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBtdWx0aTogaWYgdHJ1ZSwgdGhlIGZvcm1hdHRlciBzaG91bGQgYWNjb21tb2RhdGUgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMsIGxpa2UgYm94U2hhZG93IGNvdWxkIGhhdmUgbXVsdGlwbGUgYm94U2hhZG93cyBsaXN0ZWQgb3V0LlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gY29sbGFwc2libGU6IGlmIHRydWUsIHRoZSBmb3JtYXR0ZXIgc2hvdWxkIHRyZWF0IHRoZSB2YWx1ZSBsaWtlIGl0J3MgYSB0b3AvcmlnaHQvYm90dG9tL2xlZnQgdmFsdWUgdGhhdCBjb3VsZCBiZSBjb2xsYXBzZWQsIGxpa2UgXCI1cHhcIiB3b3VsZCBhcHBseSB0byBhbGwsIFwiNXB4LCAxMHB4XCIgd291bGQgdXNlIDVweCBmb3IgdG9wL2JvdHRvbSBhbmQgMTBweCBmb3IgcmlnaHQvbGVmdCwgZXRjLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0ga2V5d29yZDogYSBzcGVjaWFsIGtleXdvcmQgdGhhdCBjYW4gW29wdGlvbmFsbHldIGJlIGZvdW5kIGluc2lkZSB0aGUgdmFsdWUgKGxpa2UgXCJpbnNldFwiIGZvciBib3hTaGFkb3cpLiBUaGlzIGFsbG93cyB1cyB0byB2YWxpZGF0ZSBiZWdpbm5pbmcvZW5kaW5nIHZhbHVlcyB0byBtYWtlIHN1cmUgdGhleSBtYXRjaCAoaWYgdGhlIGtleXdvcmQgaXMgZm91bmQgaW4gb25lLCBpdCdsbCBiZSBhZGRlZCB0byB0aGUgb3RoZXIgZm9yIGNvbnNpc3RlbmN5IGJ5IGRlZmF1bHQpLlxuXHRcdCAqL1xuXHRcdHZhciBTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKHAsIG9wdGlvbnMpIHtcblx0XHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRcdHRoaXMucCA9IG9wdGlvbnMucHJlZml4ID8gX2NoZWNrUHJvcFByZWZpeChwKSB8fCBwIDogcDtcblx0XHRcdFx0X3NwZWNpYWxQcm9wc1twXSA9IF9zcGVjaWFsUHJvcHNbdGhpcy5wXSA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgX2dldEZvcm1hdHRlcihvcHRpb25zLmRlZmF1bHRWYWx1ZSwgb3B0aW9ucy5jb2xvciwgb3B0aW9ucy5jb2xsYXBzaWJsZSwgb3B0aW9ucy5tdWx0aSk7XG5cdFx0XHRcdGlmIChvcHRpb25zLnBhcnNlcikge1xuXHRcdFx0XHRcdHRoaXMucGFyc2UgPSBvcHRpb25zLnBhcnNlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmNscnMgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0XHR0aGlzLm11bHRpID0gb3B0aW9ucy5tdWx0aTtcblx0XHRcdFx0dGhpcy5rZXl3b3JkID0gb3B0aW9ucy5rZXl3b3JkO1xuXHRcdFx0XHR0aGlzLmRmbHQgPSBvcHRpb25zLmRlZmF1bHRWYWx1ZTtcblx0XHRcdFx0dGhpcy5wciA9IG9wdGlvbnMucHJpb3JpdHkgfHwgMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGEgbmV3IFNwZWNpYWxQcm9wIHRoYXQgY2FuIGFjY2VwdCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGFzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3QgKGhlbHBzIG1pbmlmaWNhdGlvbikuIGRmbHQgY2FuIGJlIGFuIGFycmF5IGZvciBtdWx0aXBsZSB2YWx1ZXMgKHdlIGRvbid0IGRvIGEgY29tbWEtZGVsaW1pdGVkIGxpc3QgYmVjYXVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBtYXkgY29udGFpbiBjb21tYXMsIGxpa2UgcmVjdCgwcHgsMHB4LDBweCwwcHgpKS4gV2UgYXR0YWNoIHRoaXMgbWV0aG9kIHRvIHRoZSBTcGVjaWFsUHJvcCBjbGFzcy9vYmplY3QgaW5zdGVhZCBvZiB1c2luZyBhIHByaXZhdGUgX2NyZWF0ZVNwZWNpYWxQcm9wKCkgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIHRhcCBpbnRvIGl0IGV4dGVybmFsbHkgaWYgbmVjZXNzYXJ5LCBsaWtlIGZyb20gYW5vdGhlciBwbHVnaW4uXG5cdFx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AgPSBfaW50ZXJuYWxzLl9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKHAsIG9wdGlvbnMsIGRlZmF1bHRzKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Yob3B0aW9ucykgIT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRvcHRpb25zID0ge3BhcnNlcjpkZWZhdWx0c307IC8vdG8gbWFrZSBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIEJlemllclBsdWdpbiBhbmQgVGhyb3dQcm9wc1BsdWdpblxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBhID0gcC5zcGxpdChcIixcIiksXG5cdFx0XHRcdFx0ZCA9IG9wdGlvbnMuZGVmYXVsdFZhbHVlLFxuXHRcdFx0XHRcdGksIHRlbXA7XG5cdFx0XHRcdGRlZmF1bHRzID0gZGVmYXVsdHMgfHwgW2RdO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9wdGlvbnMucHJlZml4ID0gKGkgPT09IDAgJiYgb3B0aW9ucy5wcmVmaXgpO1xuXHRcdFx0XHRcdG9wdGlvbnMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdHNbaV0gfHwgZDtcblx0XHRcdFx0XHR0ZW1wID0gbmV3IFNwZWNpYWxQcm9wKGFbaV0sIG9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2NyZWF0ZXMgYSBwbGFjZWhvbGRlciBzcGVjaWFsIHByb3AgZm9yIGEgcGx1Z2luIHNvIHRoYXQgdGhlIHByb3BlcnR5IGdldHMgY2F1Z2h0IHRoZSBmaXJzdCB0aW1lIGEgdHdlZW4gb2YgaXQgaXMgYXR0ZW1wdGVkLCBhbmQgYXQgdGhhdCB0aW1lIGl0IG1ha2VzIHRoZSBwbHVnaW4gcmVnaXN0ZXIgaXRzZWxmLCB0aHVzIHRha2luZyBvdmVyIGZvciBhbGwgZnV0dXJlIHR3ZWVucyBvZiB0aGF0IHByb3BlcnR5LiBUaGlzIGFsbG93cyB1cyB0byBub3QgbWFuZGF0ZSB0aGF0IHRoaW5ncyBsb2FkIGluIGEgcGFydGljdWxhciBvcmRlciBhbmQgaXQgYWxzbyBhbGxvd3MgdXMgdG8gbG9nKCkgYW4gZXJyb3IgdGhhdCBpbmZvcm1zIHRoZSB1c2VyIHdoZW4gdGhleSBhdHRlbXB0IHRvIHR3ZWVuIGFuIGV4dGVybmFsIHBsdWdpbi1yZWxhdGVkIHByb3BlcnR5IHdpdGhvdXQgbG9hZGluZyBpdHMgLmpzIGZpbGUuXG5cdFx0XHRfcmVnaXN0ZXJQbHVnaW5Qcm9wID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAoIV9zcGVjaWFsUHJvcHNbcF0pIHtcblx0XHRcdFx0XHR2YXIgcGx1Z2luTmFtZSA9IHAuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwLnN1YnN0cigxKSArIFwiUGx1Z2luXCI7XG5cdFx0XHRcdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKHAsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0XHRcdFx0dmFyIHBsdWdpbkNsYXNzID0gX2dsb2JhbHMuY29tLmdyZWVuc29jay5wbHVnaW5zW3BsdWdpbk5hbWVdO1xuXHRcdFx0XHRcdFx0aWYgKCFwbHVnaW5DbGFzcykge1xuXHRcdFx0XHRcdFx0XHRfbG9nKFwiRXJyb3I6IFwiICsgcGx1Z2luTmFtZSArIFwiIGpzIGZpbGUgbm90IGxvYWRlZC5cIik7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBsdWdpbkNsYXNzLl9jc3NSZWdpc3RlcigpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9zcGVjaWFsUHJvcHNbcF0ucGFyc2UodCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycyk7XG5cdFx0XHRcdFx0fX0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cblx0XHRwID0gU3BlY2lhbFByb3AucHJvdG90eXBlO1xuXG5cdFx0LyoqXG5cdFx0ICogQWxpYXMgZm9yIF9wYXJzZUNvbXBsZXgoKSB0aGF0IGF1dG9tYXRpY2FsbHkgcGx1Z3MgaW4gY2VydGFpbiB2YWx1ZXMgZm9yIHRoaXMgU3BlY2lhbFByb3AsIGxpa2UgaXRzIHByb3BlcnR5IG5hbWUsIHdoZXRoZXIgb3Igbm90IGNvbG9ycyBzaG91bGQgYmUgc2Vuc2VkLCB0aGUgZGVmYXVsdCB2YWx1ZSwgYW5kIHByaW9yaXR5LiBJdCBhbHNvIGxvb2tzIGZvciBhbnkga2V5d29yZCB0aGF0IHRoZSBTcGVjaWFsUHJvcCBkZWZpbmVzIChsaWtlIFwiaW5zZXRcIiBmb3IgYm94U2hhZG93KSBhbmQgZW5zdXJlcyB0aGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgdmFsdWVzIGZvciBTcGVjaWFsUHJvcHMgd2hlcmUgbXVsdGkgaXMgdHJ1ZSAobGlrZSBib3hTaGFkb3cgYW5kIHRleHRTaGFkb3cgY2FuIGhhdmUgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdClcblx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgdGFyZ2V0IGVsZW1lbnRcblx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfG9iamVjdCl9IGIgYmVnaW5uaW5nIHZhbHVlXG5cdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxvYmplY3QpfSBlIGVuZGluZyAoZGVzdGluYXRpb24pIHZhbHVlXG5cdFx0ICogQHBhcmFtIHtDU1NQcm9wVHdlZW49fSBwdCBuZXh0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGFub3RoZXIgcGx1Z2luIHdpbGwgYmUgdHdlZW5pbmcgdGhlIGNvbXBsZXggdmFsdWUsIHRoYXQgVHdlZW5QbHVnaW4gaW5zdGFuY2UgZ29lcyBoZXJlLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBzZXRSYXRpbyBJZiBhIGN1c3RvbSBzZXRSYXRpbygpIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBoYW5kbGUgdGhpcyBjb21wbGV4IHZhbHVlLCB0aGF0IGdvZXMgaGVyZS5cblx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW49fSBGaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0ICovXG5cdFx0cC5wYXJzZUNvbXBsZXggPSBmdW5jdGlvbih0LCBiLCBlLCBwdCwgcGx1Z2luLCBzZXRSYXRpbykge1xuXHRcdFx0dmFyIGt3ZCA9IHRoaXMua2V5d29yZCxcblx0XHRcdFx0aSwgYmEsIGVhLCBsLCBiaSwgZWk7XG5cdFx0XHQvL2lmIHRoaXMgU3BlY2lhbFByb3AncyB2YWx1ZSBjYW4gY29udGFpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyAobGlrZSBib3hTaGFkb3cgb3IgdGV4dFNoYWRvdyksIHdlIG11c3QgcGFyc2UgdGhlbSBpbiBhIHNwZWNpYWwgd2F5LCBhbmQgbG9vayBmb3IgYSBrZXl3b3JkIChsaWtlIFwiaW5zZXRcIiBmb3IgYm94U2hhZG93KSBhbmQgZW5zdXJlIHRoYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIEJPVEggaGF2ZSBpdCBpZiB0aGUgZW5kIGRlZmluZXMgaXQgYXMgc3VjaC4gV2UgYWxzbyBtdXN0IGVuc3VyZSB0aGF0IHRoZXJlIGFyZSBhbiBlcXVhbCBudW1iZXIgb2YgdmFsdWVzIHNwZWNpZmllZCAod2UgY2FuJ3QgdHdlZW4gMSBib3hTaGFkb3cgdG8gMyBmb3IgZXhhbXBsZSlcblx0XHRcdGlmICh0aGlzLm11bHRpKSBpZiAoX2NvbW1hc091dHNpZGVQYXJlbkV4cC50ZXN0KGUpIHx8IF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdChiKSkge1xuXHRcdFx0XHRiYSA9IGIucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0XHRlYSA9IGUucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0fSBlbHNlIGlmIChrd2QpIHtcblx0XHRcdFx0YmEgPSBbYl07XG5cdFx0XHRcdGVhID0gW2VdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVhKSB7XG5cdFx0XHRcdGwgPSAoZWEubGVuZ3RoID4gYmEubGVuZ3RoKSA/IGVhLmxlbmd0aCA6IGJhLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGIgPSBiYVtpXSA9IGJhW2ldIHx8IHRoaXMuZGZsdDtcblx0XHRcdFx0XHRlID0gZWFbaV0gPSBlYVtpXSB8fCB0aGlzLmRmbHQ7XG5cdFx0XHRcdFx0aWYgKGt3ZCkge1xuXHRcdFx0XHRcdFx0YmkgPSBiLmluZGV4T2Yoa3dkKTtcblx0XHRcdFx0XHRcdGVpID0gZS5pbmRleE9mKGt3ZCk7XG5cdFx0XHRcdFx0XHRpZiAoYmkgIT09IGVpKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChlaSA9PT0gLTEpIHsgLy9pZiB0aGUga2V5d29yZCBpc24ndCBpbiB0aGUgZW5kIHZhbHVlLCByZW1vdmUgaXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9uZS5cblx0XHRcdFx0XHRcdFx0XHRiYVtpXSA9IGJhW2ldLnNwbGl0KGt3ZCkuam9pbihcIlwiKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChiaSA9PT0gLTEpIHsgLy9pZiB0aGUga2V5d29yZCBpc24ndCBpbiB0aGUgYmVnaW5uaW5nLCBhZGQgaXQuXG5cdFx0XHRcdFx0XHRcdFx0YmFbaV0gKz0gXCIgXCIgKyBrd2Q7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YiA9IGJhLmpvaW4oXCIsIFwiKTtcblx0XHRcdFx0ZSA9IGVhLmpvaW4oXCIsIFwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBfcGFyc2VDb21wbGV4KHQsIHRoaXMucCwgYiwgZSwgdGhpcy5jbHJzLCB0aGlzLmRmbHQsIHB0LCB0aGlzLnByLCBwbHVnaW4sIHNldFJhdGlvKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWNjZXB0cyBhIHRhcmdldCBhbmQgZW5kIHZhbHVlIGFuZCBzcGl0cyBiYWNrIGEgQ1NTUHJvcFR3ZWVuIHRoYXQgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byB0aGUgQ1NTUGx1Z2luJ3MgbGlua2VkIGxpc3QgYW5kIGNvbmZvcm1zIHdpdGggYWxsIHRoZSBjb252ZW50aW9ucyB3ZSB1c2UgaW50ZXJuYWxseSwgbGlrZSB0eXBlOi0xLCAwLCAxLCBvciAyLCBzZXR0aW5nIHVwIGFueSBleHRyYSBwcm9wZXJ0eSB0d2VlbnMsIHByaW9yaXR5LCBldGMuIEZvciBleGFtcGxlLCBpZiB3ZSBoYXZlIGEgYm94U2hhZG93IFNwZWNpYWxQcm9wIGFuZCBjYWxsOlxuXHRcdCAqIHRoaXMuX2ZpcnN0UFQgPSBzcC5wYXJzZShlbGVtZW50LCBcIjVweCAxMHB4IDIwcHggcmdiKDI1NTAsMTAyLDUxKVwiLCBcImJveFNoYWRvd1wiLCB0aGlzKTtcblx0XHQgKiBJdCBzaG91bGQgZmlndXJlIG91dCB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGVsZW1lbnQncyBib3hTaGFkb3csIGNvbXBhcmUgaXQgdG8gdGhlIHByb3ZpZGVkIGVuZCB2YWx1ZSBhbmQgY3JlYXRlIGFsbCB0aGUgbmVjZXNzYXJ5IENTU1Byb3BUd2VlbnMgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGVzIHRvIHR3ZWVuIHRoZSBib3hTaGFkb3cuIFRoZSBDU1NQcm9wVHdlZW4gdGhhdCBnZXRzIHNwaXQgYmFjayBzaG91bGQgYWxyZWFkeSBiZSBpbnNlcnRlZCBpbnRvIHRoZSBsaW5rZWQgbGlzdCAodGhlIDR0aCBwYXJhbWV0ZXIgaXMgdGhlIGN1cnJlbnQgaGVhZCwgc28gcHJlcGVuZCB0byB0aGF0KS5cblx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBpcyBiZWluZyB0d2VlbmVkXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGUgRW5kIHZhbHVlIGFzIHByb3ZpZGVkIGluIHRoZSB2YXJzIG9iamVjdCAodHlwaWNhbGx5IGEgc3RyaW5nLCBidXQgbm90IGFsd2F5cyAtIGxpa2UgYSB0aHJvd1Byb3BzIHdvdWxkIGJlIGFuIG9iamVjdCkuXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWVcblx0XHQgKiBAcGFyYW0geyFDU1NQbHVnaW59IGNzc3AgVGhlIENTU1BsdWdpbiBpbnN0YW5jZSB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0d2Vlbi5cblx0XHQgKiBAcGFyYW0gez9DU1NQcm9wVHdlZW59IHB0IFRoZSBDU1NQcm9wVHdlZW4gdGhhdCBpcyB0aGUgY3VycmVudCBoZWFkIG9mIHRoZSBsaW5rZWQgbGlzdCAod2UnbGwgcHJlcGVuZCB0byBpdClcblx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGEgcGx1Z2luIHdpbGwgYmUgdXNlZCB0byB0d2VlbiB0aGUgcGFyc2VkIHZhbHVlLCB0aGlzIGlzIHRoZSBwbHVnaW4gaW5zdGFuY2UuXG5cdFx0ICogQHBhcmFtIHtPYmplY3Q9fSB2YXJzIE9yaWdpbmFsIHZhcnMgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgZm9yIHBhcnNpbmcuXG5cdFx0ICogQHJldHVybiB7Q1NTUHJvcFR3ZWVufSBUaGUgZmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCB3aGljaCBpbmNsdWRlcyB0aGUgbmV3IG9uZShzKSBhZGRlZCBieSB0aGUgcGFyc2UoKSBjYWxsLlxuXHRcdCAqL1xuXHRcdHAucGFyc2UgPSBmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgdGhpcy5mb3JtYXQoX2dldFN0eWxlKHQsIHRoaXMucCwgX2NzLCBmYWxzZSwgdGhpcy5kZmx0KSksIHRoaXMuZm9ybWF0KGUpLCBwdCwgcGx1Z2luKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIGEgc3BlY2lhbCBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBpbnRlcmNlcHRlZCBmcm9tIGFueSBcImNzc1wiIG9iamVjdHMgZGVmaW5lZCBpbiB0d2VlbnMuIFRoaXMgYWxsb3dzIHlvdSB0byBoYW5kbGUgdGhlbSBob3dldmVyIHlvdSB3YW50IHdpdGhvdXQgQ1NTUGx1Z2luIGRvaW5nIGl0IGZvciB5b3UuIFRoZSAybmQgcGFyYW1ldGVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyAzIHBhcmFtZXRlcnM6XG5cdFx0ICogIDEpIFRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgc2hvdWxkIGJlIHR3ZWVuZWQgKHR5cGljYWxseSBhIERPTSBlbGVtZW50KVxuXHRcdCAqICAyKSBUaGUgZW5kL2Rlc3RpbmF0aW9uIHZhbHVlIChjb3VsZCBiZSBhIHN0cmluZywgbnVtYmVyLCBvYmplY3QsIG9yIHdoYXRldmVyIHlvdSB3YW50KVxuXHRcdCAqICAzKSBUaGUgdHdlZW4gaW5zdGFuY2UgKHlvdSBwcm9iYWJseSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoaXMsIGJ1dCBpdCBjYW4gYmUgdXNlZnVsIGZvciBsb29raW5nIHVwIGluZm9ybWF0aW9uIGxpa2UgdGhlIGR1cmF0aW9uKVxuXHRcdCAqXG5cdFx0ICogVGhlbiwgeW91ciBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZWFjaCB0aW1lIHRoZSB0d2VlbiBnZXRzIHJlbmRlcmVkLCBwYXNzaW5nIGEgbnVtZXJpYyBcInJhdGlvXCIgcGFyYW1ldGVyIHRvIHlvdXIgZnVuY3Rpb24gdGhhdCBpbmRpY2F0ZXMgdGhlIGNoYW5nZSBmYWN0b3IgKHVzdWFsbHkgYmV0d2VlbiAwIGFuZCAxKS4gRm9yIGV4YW1wbGU6XG5cdFx0ICpcblx0XHQgKiBDU1NQbHVnaW4ucmVnaXN0ZXJTcGVjaWFsUHJvcChcIm15Q3VzdG9tUHJvcFwiLCBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdCAqICAgICAgdmFyIHN0YXJ0ID0gdGFyZ2V0LnN0eWxlLndpZHRoO1xuXHRcdCAqICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJhdGlvKSB7XG5cdFx0ICogICAgICAgICAgICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IChzdGFydCArIHZhbHVlICogcmF0aW8pICsgXCJweFwiO1xuXHRcdCAqICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNldCB3aWR0aCB0byBcIiArIHRhcmdldC5zdHlsZS53aWR0aCk7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqIH0sIDApO1xuXHRcdCAqXG5cdFx0ICogVGhlbiwgd2hlbiBJIGRvIHRoaXMgdHdlZW4sIGl0IHdpbGwgdHJpZ2dlciBteSBzcGVjaWFsIHByb3BlcnR5OlxuXHRcdCAqXG5cdFx0ICogVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e215Q3VzdG9tUHJvcDoxMDB9fSk7XG5cdFx0ICpcblx0XHQgKiBJbiB0aGUgZXhhbXBsZSwgb2YgY291cnNlLCB3ZSdyZSBqdXN0IGNoYW5naW5nIHRoZSB3aWR0aCwgYnV0IHlvdSBjYW4gZG8gYW55dGhpbmcgeW91IHdhbnQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IG5hbWUgUHJvcGVydHkgbmFtZSAob3IgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMpIHRoYXQgc2hvdWxkIGJlIGludGVyY2VwdGVkIGFuZCBoYW5kbGVkIGJ5IHlvdXIgZnVuY3Rpb24uIEZvciBleGFtcGxlLCBpZiBJIGRlZmluZSBcIm15Q3VzdG9tUHJvcFwiLCB0aGVuIGl0IHdvdWxkIGhhbmRsZSB0aGF0IHBvcnRpb24gb2YgdGhlIGZvbGxvd2luZyB0d2VlbjogVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e215Q3VzdG9tUHJvcDoxMDB9fSlcblx0XHQgKiBAcGFyYW0geyFmdW5jdGlvbihPYmplY3QsIE9iamVjdCwgT2JqZWN0LCBzdHJpbmcpOmZ1bmN0aW9uKG51bWJlcil9IG9uSW5pdFR3ZWVuIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSB0d2VlbiBvZiB0aGlzIHNwZWNpYWwgcHJvcGVydHkgaXMgcGVyZm9ybWVkLiBUaGUgZnVuY3Rpb24gd2lsbCByZWNlaXZlIDQgcGFyYW1ldGVyczogMSkgVGFyZ2V0IG9iamVjdCB0aGF0IHNob3VsZCBiZSB0d2VlbmVkLCAyKSBWYWx1ZSB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIHR3ZWVuLCAzKSBUaGUgdHdlZW4gaW5zdGFuY2UgaXRzZWxmIChyYXJlbHkgdXNlZCksIGFuZCA0KSBUaGUgcHJvcGVydHkgbmFtZSB0aGF0J3MgYmVpbmcgdHdlZW5lZC4gWW91ciBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIG9uIGV2ZXJ5IHVwZGF0ZSBvZiB0aGUgdHdlZW4uIFRoYXQgZnVuY3Rpb24gd2lsbCByZWNlaXZlIGEgc2luZ2xlIHBhcmFtZXRlciB0aGF0IGlzIGEgXCJjaGFuZ2UgZmFjdG9yXCIgdmFsdWUgKHR5cGljYWxseSBiZXR3ZWVuIDAgYW5kIDEpIGluZGljYXRpbmcgdGhlIGFtb3VudCBvZiBjaGFuZ2UgYXMgYSByYXRpby4gWW91IGNhbiB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGUgdmFsdWVzIGFwcHJvcHJpYXRlbHkgaW4geW91ciBmdW5jdGlvbi5cblx0XHQgKiBAcGFyYW0ge251bWJlcj19IHByaW9yaXR5IFByaW9yaXR5IHRoYXQgaGVscHMgdGhlIGVuZ2luZSBkZXRlcm1pbmUgdGhlIG9yZGVyIGluIHdoaWNoIHRvIHNldCB0aGUgcHJvcGVydGllcyAoZGVmYXVsdDogMCkuIEhpZ2hlciBwcmlvcml0eSBwcm9wZXJ0aWVzIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy5cblx0XHQgKi9cblx0XHRDU1NQbHVnaW4ucmVnaXN0ZXJTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKG5hbWUsIG9uSW5pdFR3ZWVuLCBwcmlvcml0eSkge1xuXHRcdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKG5hbWUsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0XHR2YXIgcnYgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyLCBwLCBmYWxzZSwgcHJpb3JpdHkpO1xuXHRcdFx0XHRydi5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHJ2LnNldFJhdGlvID0gb25Jbml0VHdlZW4odCwgZSwgY3NzcC5fdHdlZW4sIHApO1xuXHRcdFx0XHRyZXR1cm4gcnY7XG5cdFx0XHR9LCBwcmlvcml0eTpwcmlvcml0eX0pO1xuXHRcdH07XG5cblxuXG5cblxuXG5cdFx0Ly90cmFuc2Zvcm0tcmVsYXRlZCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG5cdFx0Q1NTUGx1Z2luLnVzZVNWR1RyYW5zZm9ybUF0dHIgPSBfaXNTYWZhcmkgfHwgX2lzRmlyZWZveDsgLy9TYWZhcmkgYW5kIEZpcmVmb3ggYm90aCBoYXZlIHNvbWUgcmVuZGVyaW5nIGJ1Z3Mgd2hlbiBhcHBseWluZyBDU1MgdHJhbnNmb3JtcyB0byBTVkcgZWxlbWVudHMsIHNvIGRlZmF1bHQgdG8gdXNpbmcgdGhlIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlIGluc3RlYWQgKHVzZXJzIGNhbiBvdmVycmlkZSB0aGlzKS5cblx0XHR2YXIgX3RyYW5zZm9ybVByb3BzID0gKFwic2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHosc2tld1gsc2tld1kscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxwZXJzcGVjdGl2ZSx4UGVyY2VudCx5UGVyY2VudFwiKS5zcGxpdChcIixcIiksXG5cdFx0XHRfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1Byb3BQcmVmaXgoXCJ0cmFuc2Zvcm1cIiksIC8vdGhlIEphdmFzY3JpcHQgKGNhbWVsQ2FzZSkgdHJhbnNmb3JtIHByb3BlcnR5LCBsaWtlIG1zVHJhbnNmb3JtLCBXZWJraXRUcmFuc2Zvcm0sIE1velRyYW5zZm9ybSwgb3IgT1RyYW5zZm9ybS5cblx0XHRcdF90cmFuc2Zvcm1Qcm9wQ1NTID0gX3ByZWZpeENTUyArIFwidHJhbnNmb3JtXCIsXG5cdFx0XHRfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF9jaGVja1Byb3BQcmVmaXgoXCJ0cmFuc2Zvcm1PcmlnaW5cIiksXG5cdFx0XHRfc3VwcG9ydHMzRCA9IChfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIikgIT09IG51bGwpLFxuXHRcdFx0VHJhbnNmb3JtID0gX2ludGVybmFscy5UcmFuc2Zvcm0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wZXJzcGVjdGl2ZSA9IHBhcnNlRmxvYXQoQ1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSkgfHwgMDtcblx0XHRcdFx0dGhpcy5mb3JjZTNEID0gKENTU1BsdWdpbi5kZWZhdWx0Rm9yY2UzRCA9PT0gZmFsc2UgfHwgIV9zdXBwb3J0czNEKSA/IGZhbHNlIDogQ1NTUGx1Z2luLmRlZmF1bHRGb3JjZTNEIHx8IFwiYXV0b1wiO1xuXHRcdFx0fSxcblx0XHRcdF9TVkdFbGVtZW50ID0gd2luZG93LlNWR0VsZW1lbnQsXG5cdFx0XHRfdXNlU1ZHVHJhbnNmb3JtQXR0cixcblx0XHRcdC8vU29tZSBicm93c2VycyAobGlrZSBGaXJlZm94IGFuZCBJRSkgZG9uJ3QgaG9ub3IgdHJhbnNmb3JtLW9yaWdpbiBwcm9wZXJseSBpbiBTVkcgZWxlbWVudHMsIHNvIHdlIG5lZWQgdG8gbWFudWFsbHkgYWRqdXN0IHRoZSBtYXRyaXggYWNjb3JkaW5nbHkuIFdlIGZlYXR1cmUgZGV0ZWN0IGhlcmUgcmF0aGVyIHRoYW4gYWx3YXlzIGRvaW5nIHRoZSBjb252ZXJzaW9uIGZvciBjZXJ0YWluIGJyb3dzZXJzIGJlY2F1c2UgdGhleSBtYXkgZml4IHRoZSBwcm9ibGVtIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cblxuXHRcdFx0X2NyZWF0ZVNWRyA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRhaW5lciwgYXR0cmlidXRlcykge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IF9kb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdHlwZSksXG5cdFx0XHRcdFx0cmVnID0gLyhbYS16XSkoW0EtWl0pL2csXG5cdFx0XHRcdFx0cDtcblx0XHRcdFx0Zm9yIChwIGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIHAucmVwbGFjZShyZWcsIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKSwgYXR0cmlidXRlc1twXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHRcdFx0XHRyZXR1cm4gZWxlbWVudDtcblx0XHRcdH0sXG5cdFx0XHRfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0X2ZvcmNlU1ZHVHJhbnNmb3JtQXR0ciA9IChmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly9JRSBhbmQgQW5kcm9pZCBzdG9jayBkb24ndCBzdXBwb3J0IENTUyB0cmFuc2Zvcm1zIG9uIFNWRyBlbGVtZW50cywgc28gd2UgbXVzdCB3cml0ZSB0aGVtIHRvIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZS4gV2UgcG9wdWxhdGUgdGhpcyB2YXJpYWJsZSBpbiB0aGUgX3BhcnNlVHJhbnNmb3JtKCkgbWV0aG9kLCBhbmQgb25seSBpZi93aGVuIHdlIGNvbWUgYWNyb3NzIGFuIFNWRyBlbGVtZW50XG5cdFx0XHRcdHZhciBmb3JjZSA9IF9pZVZlcnMgfHwgKC9BbmRyb2lkL2kudGVzdChfYWdlbnQpICYmICF3aW5kb3cuY2hyb21lKSxcblx0XHRcdFx0XHRzdmcsIHJlY3QsIHdpZHRoO1xuXHRcdFx0XHRpZiAoX2RvYy5jcmVhdGVFbGVtZW50TlMgJiYgIWZvcmNlKSB7IC8vSUU4IGFuZCBlYXJsaWVyIGRvZXNuJ3Qgc3VwcG9ydCBTVkcgYW55d2F5XG5cdFx0XHRcdFx0c3ZnID0gX2NyZWF0ZVNWRyhcInN2Z1wiLCBfZG9jRWxlbWVudCk7XG5cdFx0XHRcdFx0cmVjdCA9IF9jcmVhdGVTVkcoXCJyZWN0XCIsIHN2Zywge3dpZHRoOjEwMCwgaGVpZ2h0OjUwLCB4OjEwMH0pO1xuXHRcdFx0XHRcdHdpZHRoID0gcmVjdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblx0XHRcdFx0XHRyZWN0LnN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IFwiNTAlIDUwJVwiO1xuXHRcdFx0XHRcdHJlY3Quc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gXCJzY2FsZVgoMC41KVwiO1xuXHRcdFx0XHRcdGZvcmNlID0gKHdpZHRoID09PSByZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICYmICEoX2lzRmlyZWZveCAmJiBfc3VwcG9ydHMzRCkpOyAvL25vdGU6IEZpcmVmb3ggZmFpbHMgdGhlIHRlc3QgZXZlbiB0aG91Z2ggaXQgZG9lcyBzdXBwb3J0IENTUyB0cmFuc2Zvcm1zIGluIDNELiBTaW5jZSB3ZSBjYW4ndCBwdXNoIDNEIHN0dWZmIGludG8gdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUsIHdlIGZvcmNlIEZpcmVmb3ggdG8gcGFzcyB0aGUgdGVzdCBoZXJlIChhcyBsb25nIGFzIGl0IGRvZXMgdHJ1bHkgc3VwcG9ydCAzRCkuXG5cdFx0XHRcdFx0X2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQoc3ZnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZm9yY2U7XG5cdFx0XHR9KSgpLFxuXHRcdFx0X3BhcnNlU1ZHT3JpZ2luID0gZnVuY3Rpb24oZSwgbG9jYWwsIGRlY29yYXRlZSwgYWJzb2x1dGUsIHNtb290aE9yaWdpbiwgc2tpcFJlY29yZCkge1xuXHRcdFx0XHR2YXIgdG0gPSBlLl9nc1RyYW5zZm9ybSxcblx0XHRcdFx0XHRtID0gX2dldE1hdHJpeChlLCB0cnVlKSxcblx0XHRcdFx0XHR2LCB4LCB5LCB4T3JpZ2luLCB5T3JpZ2luLCBhLCBiLCBjLCBkLCB0eCwgdHksIGRldGVybWluYW50LCB4T3JpZ2luT2xkLCB5T3JpZ2luT2xkO1xuXHRcdFx0XHRpZiAodG0pIHtcblx0XHRcdFx0XHR4T3JpZ2luT2xkID0gdG0ueE9yaWdpbjsgLy9yZWNvcmQgdGhlIG9yaWdpbmFsIHZhbHVlcyBiZWZvcmUgd2UgYWx0ZXIgdGhlbS5cblx0XHRcdFx0XHR5T3JpZ2luT2xkID0gdG0ueU9yaWdpbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWFic29sdXRlIHx8ICh2ID0gYWJzb2x1dGUuc3BsaXQoXCIgXCIpKS5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdFx0YiA9IGUuZ2V0QkJveCgpO1xuXHRcdFx0XHRcdGxvY2FsID0gX3BhcnNlUG9zaXRpb24obG9jYWwpLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHR2ID0gWyhsb2NhbFswXS5pbmRleE9mKFwiJVwiKSAhPT0gLTEgPyBwYXJzZUZsb2F0KGxvY2FsWzBdKSAvIDEwMCAqIGIud2lkdGggOiBwYXJzZUZsb2F0KGxvY2FsWzBdKSkgKyBiLngsXG5cdFx0XHRcdFx0XHQgKGxvY2FsWzFdLmluZGV4T2YoXCIlXCIpICE9PSAtMSA/IHBhcnNlRmxvYXQobG9jYWxbMV0pIC8gMTAwICogYi5oZWlnaHQgOiBwYXJzZUZsb2F0KGxvY2FsWzFdKSkgKyBiLnldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlY29yYXRlZS54T3JpZ2luID0geE9yaWdpbiA9IHBhcnNlRmxvYXQodlswXSk7XG5cdFx0XHRcdGRlY29yYXRlZS55T3JpZ2luID0geU9yaWdpbiA9IHBhcnNlRmxvYXQodlsxXSk7XG5cdFx0XHRcdGlmIChhYnNvbHV0ZSAmJiBtICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkgeyAvL2lmIHN2Z09yaWdpbiBpcyBiZWluZyBzZXQsIHdlIG11c3QgaW52ZXJ0IHRoZSBtYXRyaXggYW5kIGRldGVybWluZSB3aGVyZSB0aGUgYWJzb2x1dGUgcG9pbnQgaXMsIGZhY3RvcmluZyBpbiB0aGUgY3VycmVudCB0cmFuc2Zvcm1zLiBPdGhlcndpc2UsIHRoZSBzdmdPcmlnaW4gd291bGQgYmUgYmFzZWQgb24gdGhlIGVsZW1lbnQncyBub24tdHJhbnNmb3JtZWQgcG9zaXRpb24gb24gdGhlIGNhbnZhcy5cblx0XHRcdFx0XHRhID0gbVswXTtcblx0XHRcdFx0XHRiID0gbVsxXTtcblx0XHRcdFx0XHRjID0gbVsyXTtcblx0XHRcdFx0XHRkID0gbVszXTtcblx0XHRcdFx0XHR0eCA9IG1bNF07XG5cdFx0XHRcdFx0dHkgPSBtWzVdO1xuXHRcdFx0XHRcdGRldGVybWluYW50ID0gKGEgKiBkIC0gYiAqIGMpO1xuXHRcdFx0XHRcdHggPSB4T3JpZ2luICogKGQgLyBkZXRlcm1pbmFudCkgKyB5T3JpZ2luICogKC1jIC8gZGV0ZXJtaW5hbnQpICsgKChjICogdHkgLSBkICogdHgpIC8gZGV0ZXJtaW5hbnQpO1xuXHRcdFx0XHRcdHkgPSB4T3JpZ2luICogKC1iIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqIChhIC8gZGV0ZXJtaW5hbnQpIC0gKChhICogdHkgLSBiICogdHgpIC8gZGV0ZXJtaW5hbnQpO1xuXHRcdFx0XHRcdHhPcmlnaW4gPSBkZWNvcmF0ZWUueE9yaWdpbiA9IHZbMF0gPSB4O1xuXHRcdFx0XHRcdHlPcmlnaW4gPSBkZWNvcmF0ZWUueU9yaWdpbiA9IHZbMV0gPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0bSkgeyAvL2F2b2lkIGp1bXAgd2hlbiB0cmFuc2Zvcm1PcmlnaW4gaXMgY2hhbmdlZCAtIGFkanVzdCB0aGUgeC95IHZhbHVlcyBhY2NvcmRpbmdseVxuXHRcdFx0XHRcdGlmIChza2lwUmVjb3JkKSB7XG5cdFx0XHRcdFx0XHRkZWNvcmF0ZWUueE9mZnNldCA9IHRtLnhPZmZzZXQ7XG5cdFx0XHRcdFx0XHRkZWNvcmF0ZWUueU9mZnNldCA9IHRtLnlPZmZzZXQ7XG5cdFx0XHRcdFx0XHR0bSA9IGRlY29yYXRlZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNtb290aE9yaWdpbiB8fCAoc21vb3RoT3JpZ2luICE9PSBmYWxzZSAmJiBDU1NQbHVnaW4uZGVmYXVsdFNtb290aE9yaWdpbiAhPT0gZmFsc2UpKSB7XG5cdFx0XHRcdFx0XHR4ID0geE9yaWdpbiAtIHhPcmlnaW5PbGQ7XG5cdFx0XHRcdFx0XHR5ID0geU9yaWdpbiAtIHlPcmlnaW5PbGQ7XG5cdFx0XHRcdFx0XHQvL29yaWdpbmFsbHksIHdlIHNpbXBseSBhZGp1c3RlZCB0aGUgeCBhbmQgeSB2YWx1ZXMsIGJ1dCB0aGF0IHdvdWxkIGNhdXNlIHByb2JsZW1zIGlmLCBmb3IgZXhhbXBsZSwgeW91IGNyZWF0ZWQgYSByb3RhdGlvbmFsIHR3ZWVuIHBhcnQtd2F5IHRocm91Z2ggYW4geC95IHR3ZWVuLiBNYW5hZ2luZyB0aGUgb2Zmc2V0IGluIGEgc2VwYXJhdGUgdmFyaWFibGUgZ2l2ZXMgdXMgdWx0aW1hdGUgZmxleGliaWxpdHkuXG5cdFx0XHRcdFx0XHQvL3RtLnggLT0geCAtICh4ICogbVswXSArIHkgKiBtWzJdKTtcblx0XHRcdFx0XHRcdC8vdG0ueSAtPSB5IC0gKHggKiBtWzFdICsgeSAqIG1bM10pO1xuXHRcdFx0XHRcdFx0dG0ueE9mZnNldCArPSAoeCAqIG1bMF0gKyB5ICogbVsyXSkgLSB4O1xuXHRcdFx0XHRcdFx0dG0ueU9mZnNldCArPSAoeCAqIG1bMV0gKyB5ICogbVszXSkgLSB5O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0bS54T2Zmc2V0ID0gdG0ueU9mZnNldCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2tpcFJlY29yZCkge1xuXHRcdFx0XHRcdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHYuam9pbihcIiBcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X2NhbkdldEJCb3ggPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuIGUuZ2V0QkJveCgpOyAvL0ZpcmVmb3ggdGhyb3dzIGVycm9ycyBpZiB5b3UgdHJ5IGNhbGxpbmcgZ2V0QkJveCgpIG9uIGFuIFNWRyBlbGVtZW50IHRoYXQncyBub3QgcmVuZGVyZWQgKGxpa2UgaW4gYSA8c3ltYm9sPiBvciA8ZGVmcz4pLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02MTIxMThcblx0XHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdH0sXG5cdFx0XHRfaXNTVkcgPSBmdW5jdGlvbihlKSB7IC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5cdFx0XHRcdHJldHVybiAhIShfU1ZHRWxlbWVudCAmJiBlLmdldEJCb3ggJiYgZS5nZXRDVE0gJiYgX2NhbkdldEJCb3goZSkgJiYgKCFlLnBhcmVudE5vZGUgfHwgKGUucGFyZW50Tm9kZS5nZXRCQm94ICYmIGUucGFyZW50Tm9kZS5nZXRDVE0pKSk7XG5cdFx0XHR9LFxuXHRcdFx0X2lkZW50aXR5MkRNYXRyaXggPSBbMSwwLDAsMSwwLDBdLFxuXHRcdFx0X2dldE1hdHJpeCA9IGZ1bmN0aW9uKGUsIGZvcmNlMkQpIHtcblx0XHRcdFx0dmFyIHRtID0gZS5fZ3NUcmFuc2Zvcm0gfHwgbmV3IFRyYW5zZm9ybSgpLFxuXHRcdFx0XHRcdHJuZCA9IDEwMDAwMCxcblx0XHRcdFx0XHRpc0RlZmF1bHQsIHMsIG0sIG4sIGRlYztcblx0XHRcdFx0aWYgKF90cmFuc2Zvcm1Qcm9wKSB7XG5cdFx0XHRcdFx0cyA9IF9nZXRTdHlsZShlLCBfdHJhbnNmb3JtUHJvcENTUywgbnVsbCwgdHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZS5jdXJyZW50U3R5bGUpIHtcblx0XHRcdFx0XHQvL2ZvciBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgd2UgbmVlZCB0byBpbnRlcnByZXQgdGhlIGZpbHRlciBwb3J0aW9uIHRoYXQgaXMgaW4gdGhlIGZvcm1hdDogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9Ni4xMjMyMzM5OTU3MzY3NjZlLTE3LCBNMTI9LTEsIE0yMT0xLCBNMjI9Ni4xMjMyMzM5OTU3MzY3NjZlLTE3LCBzaXppbmdNZXRob2Q9J2F1dG8gZXhwYW5kJykgTm90aWNlIHRoYXQgd2UgbmVlZCB0byBzd2FwIGIgYW5kIGMgY29tcGFyZWQgdG8gYSBub3JtYWwgbWF0cml4LlxuXHRcdFx0XHRcdHMgPSBlLmN1cnJlbnRTdHlsZS5maWx0ZXIubWF0Y2goX2llR2V0TWF0cml4RXhwKTtcblx0XHRcdFx0XHRzID0gKHMgJiYgcy5sZW5ndGggPT09IDQpID8gW3NbMF0uc3Vic3RyKDQpLCBOdW1iZXIoc1syXS5zdWJzdHIoNCkpLCBOdW1iZXIoc1sxXS5zdWJzdHIoNCkpLCBzWzNdLnN1YnN0cig0KSwgKHRtLnggfHwgMCksICh0bS55IHx8IDApXS5qb2luKFwiLFwiKSA6IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aXNEZWZhdWx0ID0gKCFzIHx8IHMgPT09IFwibm9uZVwiIHx8IHMgPT09IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCIpO1xuXHRcdFx0XHRpZiAodG0uc3ZnIHx8IChlLmdldEJCb3ggJiYgX2lzU1ZHKGUpKSkge1xuXHRcdFx0XHRcdGlmIChpc0RlZmF1bHQgJiYgKGUuc3R5bGVbX3RyYW5zZm9ybVByb3BdICsgXCJcIikuaW5kZXhPZihcIm1hdHJpeFwiKSAhPT0gLTEpIHsgLy9zb21lIGJyb3dzZXJzIChsaWtlIENocm9tZSA0MCkgZG9uJ3QgY29ycmVjdGx5IHJlcG9ydCB0cmFuc2Zvcm1zIHRoYXQgYXJlIGFwcGxpZWQgaW5saW5lIG9uIGFuIFNWRyBlbGVtZW50ICh0aGV5IGRvbid0IGdldCBpbmNsdWRlZCBpbiB0aGUgY29tcHV0ZWQgc3R5bGUpLCBzbyB3ZSBkb3VibGUtY2hlY2sgaGVyZSBhbmQgYWNjZXB0IG1hdHJpeCB2YWx1ZXNcblx0XHRcdFx0XHRcdHMgPSBlLnN0eWxlW190cmFuc2Zvcm1Qcm9wXTtcblx0XHRcdFx0XHRcdGlzRGVmYXVsdCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG0gPSBlLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblx0XHRcdFx0XHRpZiAoaXNEZWZhdWx0ICYmIG0pIHtcblx0XHRcdFx0XHRcdGlmIChtLmluZGV4T2YoXCJtYXRyaXhcIikgIT09IC0xKSB7IC8vanVzdCBpbiBjYXNlIHRoZXJlJ3MgYSBcInRyYW5zZm9ybVwiIHZhbHVlIHNwZWNpZmllZCBhcyBhbiBhdHRyaWJ1dGUgaW5zdGVhZCBvZiBDU1Mgc3R5bGUuIEFjY2VwdCBlaXRoZXIgYSBtYXRyaXgoKSBvciBzaW1wbGUgdHJhbnNsYXRlKCkgdmFsdWUgdGhvdWdoLlxuXHRcdFx0XHRcdFx0XHRzID0gbTtcblx0XHRcdFx0XHRcdFx0aXNEZWZhdWx0ID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobS5pbmRleE9mKFwidHJhbnNsYXRlXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRzID0gXCJtYXRyaXgoMSwwLDAsMSxcIiArIG0ubWF0Y2goLyg/OlxcLXxcXGIpW1xcZFxcLVxcLmVdK1xcYi9naSkuam9pbihcIixcIikgKyBcIilcIjtcblx0XHRcdFx0XHRcdFx0aXNEZWZhdWx0ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzRGVmYXVsdCkge1xuXHRcdFx0XHRcdHJldHVybiBfaWRlbnRpdHkyRE1hdHJpeDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL3NwbGl0IHRoZSBtYXRyaXggdmFsdWVzIG91dCBpbnRvIGFuIGFycmF5IChtIGZvciBtYXRyaXgpXG5cdFx0XHRcdG0gPSAocyB8fCBcIlwiKS5tYXRjaChfbnVtRXhwKSB8fCBbXTtcblx0XHRcdFx0aSA9IG0ubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRuID0gTnVtYmVyKG1baV0pO1xuXHRcdFx0XHRcdG1baV0gPSAoZGVjID0gbiAtIChuIHw9IDApKSA/ICgoZGVjICogcm5kICsgKGRlYyA8IDAgPyAtMC41IDogMC41KSkgfCAwKSAvIHJuZCArIG4gOiBuOyAvL2NvbnZlcnQgc3RyaW5ncyB0byBOdW1iZXJzIGFuZCByb3VuZCB0byA1IGRlY2ltYWwgcGxhY2VzIHRvIGF2b2lkIGlzc3VlcyB3aXRoIHRpbnkgbnVtYmVycy4gUm91Z2hseSAyMHggZmFzdGVyIHRoYW4gTnVtYmVyLnRvRml4ZWQoKS4gV2UgYWxzbyBtdXN0IG1ha2Ugc3VyZSB0byByb3VuZCBiZWZvcmUgZGl2aWRpbmcgc28gdGhhdCB2YWx1ZXMgbGlrZSAwLjk5OTk5OTk5OTkgYmVjb21lIDEgdG8gYXZvaWQgZ2xpdGNoZXMgaW4gYnJvd3NlciByZW5kZXJpbmcgYW5kIGludGVycHJldGF0aW9uIG9mIGZsaXBwZWQvcm90YXRlZCAzRCBtYXRyaWNlcy4gQW5kIGRvbid0IGp1c3QgbXVsdGlwbHkgdGhlIG51bWJlciBieSBybmQsIGZsb29yIGl0LCBhbmQgdGhlbiBkaXZpZGUgYnkgcm5kIGJlY2F1c2UgdGhlIGJpdHdpc2Ugb3BlcmF0aW9ucyBtYXggb3V0IGF0IGEgMzItYml0IHNpZ25lZCBpbnRlZ2VyLCB0aHVzIGl0IGNvdWxkIGdldCBjbGlwcGVkIGF0IGEgcmVsYXRpdmVseSBsb3cgdmFsdWUgKGxpa2UgMjIsMDAwLjAwMDAwIGZvciBleGFtcGxlKS5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKGZvcmNlMkQgJiYgbS5sZW5ndGggPiA2KSA/IFttWzBdLCBtWzFdLCBtWzRdLCBtWzVdLCBtWzEyXSwgbVsxM11dIDogbTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUGFyc2VzIHRoZSB0cmFuc2Zvcm0gdmFsdWVzIGZvciBhbiBlbGVtZW50LCByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggeCwgeSwgeiwgc2NhbGVYLCBzY2FsZVksIHNjYWxlWiwgcm90YXRpb24sIHJvdGF0aW9uWCwgcm90YXRpb25ZLCBza2V3WCwgYW5kIHNrZXdZIHByb3BlcnRpZXMuIE5vdGU6IGJ5IGRlZmF1bHQgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSwgYWxsIHNrZXdpbmcgaXMgY29tYmluZWQgaW50byBza2V3WCBhbmQgcm90YXRpb24gYnV0IHNrZXdZIHN0aWxsIGhhcyBhIHBsYWNlIGluIHRoZSB0cmFuc2Zvcm0gb2JqZWN0IHNvIHRoYXQgd2UgY2FuIHJlY29yZCBob3cgbXVjaCBvZiB0aGUgc2tldyBpcyBhdHRyaWJ1dGVkIHRvIHNrZXdYIHZzIHNrZXdZLiBSZW1lbWJlciwgYSBza2V3WSBvZiAxMCBsb29rcyB0aGUgc2FtZSBhcyBhIHJvdGF0aW9uIG9mIDEwIGFuZCBza2V3WCBvZiAtMTAuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgdGFyZ2V0IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gY3MgY29tcHV0ZWQgc3R5bGUgb2JqZWN0IChvcHRpb25hbClcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlYyBpZiB0cnVlLCB0aGUgdHJhbnNmb3JtIHZhbHVlcyB3aWxsIGJlIHJlY29yZGVkIHRvIHRoZSB0YXJnZXQgZWxlbWVudCdzIF9nc1RyYW5zZm9ybSBvYmplY3QsIGxpa2UgdGFyZ2V0Ll9nc1RyYW5zZm9ybSA9IHt4OjAsIHk6MCwgejowLCBzY2FsZVg6MS4uLn1cblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHBhcnNlIGlmIHRydWUsIHdlJ2xsIGlnbm9yZSBhbnkgX2dzVHJhbnNmb3JtIHZhbHVlcyB0aGF0IGFscmVhZHkgZXhpc3Qgb24gdGhlIGVsZW1lbnQsIGFuZCBmb3JjZSBhIHJlcGFyc2luZyBvZiB0aGUgY3NzIChjYWxjdWxhdGVkIHN0eWxlKVxuXHRcdFx0ICogQHJldHVybiB7b2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBhbGwgb2YgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzL3ZhbHVlcyBsaWtlIHt4OjAsIHk6MCwgejowLCBzY2FsZVg6MS4uLn1cblx0XHRcdCAqL1xuXHRcdFx0X2dldFRyYW5zZm9ybSA9IF9pbnRlcm5hbHMuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24odCwgY3MsIHJlYywgcGFyc2UpIHtcblx0XHRcdFx0aWYgKHQuX2dzVHJhbnNmb3JtICYmIHJlYyAmJiAhcGFyc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gdC5fZ3NUcmFuc2Zvcm07IC8vaWYgdGhlIGVsZW1lbnQgYWxyZWFkeSBoYXMgYSBfZ3NUcmFuc2Zvcm0sIHVzZSB0aGF0LiBOb3RlOiBzb21lIGJyb3dzZXJzIGRvbid0IGFjY3VyYXRlbHkgcmV0dXJuIHRoZSBjYWxjdWxhdGVkIHN0eWxlIGZvciB0aGUgdHJhbnNmb3JtIChwYXJ0aWN1bGFybHkgZm9yIFNWRyksIHNvIGl0J3MgYWxtb3N0IGFsd2F5cyBzYWZlc3QgdG8ganVzdCB1c2UgdGhlIHZhbHVlcyB3ZSd2ZSBhbHJlYWR5IGFwcGxpZWQgcmF0aGVyIHRoYW4gcmUtcGFyc2luZyB0aGluZ3MuXG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHRtID0gcmVjID8gdC5fZ3NUcmFuc2Zvcm0gfHwgbmV3IFRyYW5zZm9ybSgpIDogbmV3IFRyYW5zZm9ybSgpLFxuXHRcdFx0XHRcdGludlggPSAodG0uc2NhbGVYIDwgMCksIC8vaW4gb3JkZXIgdG8gaW50ZXJwcmV0IHRoaW5ncyBwcm9wZXJseSwgd2UgbmVlZCB0byBrbm93IGlmIHRoZSB1c2VyIGFwcGxpZWQgYSBuZWdhdGl2ZSBzY2FsZVggcHJldmlvdXNseSBzbyB0aGF0IHdlIGNhbiBhZGp1c3QgdGhlIHJvdGF0aW9uIGFuZCBza2V3WCBhY2NvcmRpbmdseS4gT3RoZXJ3aXNlLCBpZiB3ZSBhbHdheXMgaW50ZXJwcmV0IGEgZmxpcHBlZCBtYXRyaXggYXMgYWZmZWN0aW5nIHNjYWxlWSBhbmQgdGhlIHVzZXIgb25seSB3YW50cyB0byB0d2VlbiB0aGUgc2NhbGVYIG9uIG11bHRpcGxlIHNlcXVlbnRpYWwgdHdlZW5zLCBpdCB3b3VsZCBrZWVwIHRoZSBuZWdhdGl2ZSBzY2FsZVkgd2l0aG91dCB0aGF0IGJlaW5nIHRoZSB1c2VyJ3MgaW50ZW50LlxuXHRcdFx0XHRcdG1pbiA9IDAuMDAwMDIsXG5cdFx0XHRcdFx0cm5kID0gMTAwMDAwLFxuXHRcdFx0XHRcdHpPcmlnaW4gPSBfc3VwcG9ydHMzRCA/IHBhcnNlRmxvYXQoX2dldFN0eWxlKHQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wLCBjcywgZmFsc2UsIFwiMCAwIDBcIikuc3BsaXQoXCIgXCIpWzJdKSB8fCB0bS56T3JpZ2luICB8fCAwIDogMCxcblx0XHRcdFx0XHRkZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBwYXJzZUZsb2F0KENTU1BsdWdpbi5kZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmUpIHx8IDAsXG5cdFx0XHRcdFx0bSwgaSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WDtcblxuXHRcdFx0XHR0bS5zdmcgPSAhISh0LmdldEJCb3ggJiYgX2lzU1ZHKHQpKTtcblx0XHRcdFx0aWYgKHRtLnN2Zykge1xuXHRcdFx0XHRcdF9wYXJzZVNWR09yaWdpbih0LCBfZ2V0U3R5bGUodCwgX3RyYW5zZm9ybU9yaWdpblByb3AsIF9jcywgZmFsc2UsIFwiNTAlIDUwJVwiKSArIFwiXCIsIHRtLCB0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKSk7XG5cdFx0XHRcdFx0X3VzZVNWR1RyYW5zZm9ybUF0dHIgPSBDU1NQbHVnaW4udXNlU1ZHVHJhbnNmb3JtQXR0ciB8fCBfZm9yY2VTVkdUcmFuc2Zvcm1BdHRyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG0gPSBfZ2V0TWF0cml4KHQpO1xuXHRcdFx0XHRpZiAobSAhPT0gX2lkZW50aXR5MkRNYXRyaXgpIHtcblxuXHRcdFx0XHRcdGlmIChtLmxlbmd0aCA9PT0gMTYpIHtcblx0XHRcdFx0XHRcdC8vd2UnbGwgb25seSBsb29rIGF0IHRoZXNlIHBvc2l0aW9uLXJlbGF0ZWQgNiB2YXJpYWJsZXMgZmlyc3QgYmVjYXVzZSBpZiB4L3kveiBhbGwgbWF0Y2gsIGl0J3MgcmVsYXRpdmVseSBzYWZlIHRvIGFzc3VtZSB3ZSBkb24ndCBuZWVkIHRvIHJlLXBhcnNlIGV2ZXJ5dGhpbmcgd2hpY2ggcmlza3MgbG9zaW5nIGltcG9ydGFudCByb3RhdGlvbmFsIGluZm9ybWF0aW9uIChsaWtlIHJvdGF0aW9uWDoxODAgcGx1cyByb3RhdGlvblk6MTgwIHdvdWxkIGxvb2sgdGhlIHNhbWUgYXMgcm90YXRpb246MTgwIC0gdGhlcmUncyBubyB3YXkgdG8ga25vdyBmb3Igc3VyZSB3aGljaCBkaXJlY3Rpb24gd2FzIHRha2VuIGJhc2VkIHNvbGVseSBvbiB0aGUgbWF0cml4M2QoKSB2YWx1ZXMpXG5cdFx0XHRcdFx0XHR2YXIgYTExID0gbVswXSwgYTIxID0gbVsxXSwgYTMxID0gbVsyXSwgYTQxID0gbVszXSxcblx0XHRcdFx0XHRcdFx0YTEyID0gbVs0XSwgYTIyID0gbVs1XSwgYTMyID0gbVs2XSwgYTQyID0gbVs3XSxcblx0XHRcdFx0XHRcdFx0YTEzID0gbVs4XSwgYTIzID0gbVs5XSwgYTMzID0gbVsxMF0sXG5cdFx0XHRcdFx0XHRcdGExNCA9IG1bMTJdLCBhMjQgPSBtWzEzXSwgYTM0ID0gbVsxNF0sXG5cdFx0XHRcdFx0XHRcdGE0MyA9IG1bMTFdLFxuXHRcdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoYTMyLCBhMzMpLFxuXHRcdFx0XHRcdFx0XHR0MSwgdDIsIHQzLCB0NCwgY29zLCBzaW47XG5cblx0XHRcdFx0XHRcdC8vd2UgbWFudWFsbHkgY29tcGVuc2F0ZSBmb3Igbm9uLXplcm8geiBjb21wb25lbnQgb2YgdHJhbnNmb3JtT3JpZ2luIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gU2FmYXJpXG5cdFx0XHRcdFx0XHRpZiAodG0uek9yaWdpbikge1xuXHRcdFx0XHRcdFx0XHRhMzQgPSAtdG0uek9yaWdpbjtcblx0XHRcdFx0XHRcdFx0YTE0ID0gYTEzKmEzNC1tWzEyXTtcblx0XHRcdFx0XHRcdFx0YTI0ID0gYTIzKmEzNC1tWzEzXTtcblx0XHRcdFx0XHRcdFx0YTM0ID0gYTMzKmEzNCt0bS56T3JpZ2luLW1bMTRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dG0ucm90YXRpb25YID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdC8vcm90YXRpb25YXG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0dDEgPSBhMTIqY29zK2ExMypzaW47XG5cdFx0XHRcdFx0XHRcdHQyID0gYTIyKmNvcythMjMqc2luO1xuXHRcdFx0XHRcdFx0XHR0MyA9IGEzMipjb3MrYTMzKnNpbjtcblx0XHRcdFx0XHRcdFx0YTEzID0gYTEyKi1zaW4rYTEzKmNvcztcblx0XHRcdFx0XHRcdFx0YTIzID0gYTIyKi1zaW4rYTIzKmNvcztcblx0XHRcdFx0XHRcdFx0YTMzID0gYTMyKi1zaW4rYTMzKmNvcztcblx0XHRcdFx0XHRcdFx0YTQzID0gYTQyKi1zaW4rYTQzKmNvcztcblx0XHRcdFx0XHRcdFx0YTEyID0gdDE7XG5cdFx0XHRcdFx0XHRcdGEyMiA9IHQyO1xuXHRcdFx0XHRcdFx0XHRhMzIgPSB0Mztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vcm90YXRpb25ZXG5cdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoLWEzMSwgYTMzKTtcblx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWSA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0dDEgPSBhMTEqY29zLWExMypzaW47XG5cdFx0XHRcdFx0XHRcdHQyID0gYTIxKmNvcy1hMjMqc2luO1xuXHRcdFx0XHRcdFx0XHR0MyA9IGEzMSpjb3MtYTMzKnNpbjtcblx0XHRcdFx0XHRcdFx0YTIzID0gYTIxKnNpbithMjMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMzMgPSBhMzEqc2luK2EzMypjb3M7XG5cdFx0XHRcdFx0XHRcdGE0MyA9IGE0MSpzaW4rYTQzKmNvcztcblx0XHRcdFx0XHRcdFx0YTExID0gdDE7XG5cdFx0XHRcdFx0XHRcdGEyMSA9IHQyO1xuXHRcdFx0XHRcdFx0XHRhMzEgPSB0Mztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vcm90YXRpb25aXG5cdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoYTIxLCBhMTEpO1xuXHRcdFx0XHRcdFx0dG0ucm90YXRpb24gPSBhbmdsZSAqIF9SQUQyREVHO1xuXHRcdFx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdGExMSA9IGExMSpjb3MrYTEyKnNpbjtcblx0XHRcdFx0XHRcdFx0dDIgPSBhMjEqY29zK2EyMipzaW47XG5cdFx0XHRcdFx0XHRcdGEyMiA9IGEyMSotc2luK2EyMipjb3M7XG5cdFx0XHRcdFx0XHRcdGEzMiA9IGEzMSotc2luK2EzMipjb3M7XG5cdFx0XHRcdFx0XHRcdGEyMSA9IHQyO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodG0ucm90YXRpb25YICYmIE1hdGguYWJzKHRtLnJvdGF0aW9uWCkgKyBNYXRoLmFicyh0bS5yb3RhdGlvbikgPiAzNTkuOSkgeyAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cblx0XHRcdFx0XHRcdFx0dG0ucm90YXRpb25YID0gdG0ucm90YXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblkgPSAxODAgLSB0bS5yb3RhdGlvblk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRtLnNjYWxlWCA9ICgoTWF0aC5zcXJ0KGExMSAqIGExMSArIGEyMSAqIGEyMSkgKiBybmQgKyAwLjUpIHwgMCkgLyBybmQ7XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVkgPSAoKE1hdGguc3FydChhMjIgKiBhMjIgKyBhMjMgKiBhMjMpICogcm5kICsgMC41KSB8IDApIC8gcm5kO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVaID0gKChNYXRoLnNxcnQoYTMyICogYTMyICsgYTMzICogYTMzKSAqIHJuZCArIDAuNSkgfCAwKSAvIHJuZDtcblx0XHRcdFx0XHRcdHRtLnNrZXdYID0gKGExMiB8fCBhMjIpID8gTWF0aC5hdGFuMihhMTIsIGEyMikgKiBfUkFEMkRFRyArIHRtLnJvdGF0aW9uIDogdG0uc2tld1ggfHwgMDtcblx0XHRcdFx0XHRcdGlmIChNYXRoLmFicyh0bS5za2V3WCkgPiA5MCAmJiBNYXRoLmFicyh0bS5za2V3WCkgPCAyNzApIHtcblx0XHRcdFx0XHRcdFx0aWYgKGludlgpIHtcblx0XHRcdFx0XHRcdFx0XHR0bS5zY2FsZVggKj0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0dG0uc2tld1ggKz0gKHRtLnJvdGF0aW9uIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvbiArPSAodG0ucm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRtLnNjYWxlWSAqPSAtMTtcblx0XHRcdFx0XHRcdFx0XHR0bS5za2V3WCArPSAodG0uc2tld1ggPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0bS5wZXJzcGVjdGl2ZSA9IGE0MyA/IDEgLyAoKGE0MyA8IDApID8gLWE0MyA6IGE0MykgOiAwO1xuXHRcdFx0XHRcdFx0dG0ueCA9IGExNDtcblx0XHRcdFx0XHRcdHRtLnkgPSBhMjQ7XG5cdFx0XHRcdFx0XHR0bS56ID0gYTM0O1xuXHRcdFx0XHRcdFx0aWYgKHRtLnN2Zykge1xuXHRcdFx0XHRcdFx0XHR0bS54IC09IHRtLnhPcmlnaW4gLSAodG0ueE9yaWdpbiAqIGExMSAtIHRtLnlPcmlnaW4gKiBhMTIpO1xuXHRcdFx0XHRcdFx0XHR0bS55IC09IHRtLnlPcmlnaW4gLSAodG0ueU9yaWdpbiAqIGEyMSAtIHRtLnhPcmlnaW4gKiBhMjIpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICgoIV9zdXBwb3J0czNEIHx8IHBhcnNlIHx8ICFtLmxlbmd0aCB8fCB0bS54ICE9PSBtWzRdIHx8IHRtLnkgIT09IG1bNV0gfHwgKCF0bS5yb3RhdGlvblggJiYgIXRtLnJvdGF0aW9uWSkpICYmICEodG0ueCAhPT0gdW5kZWZpbmVkICYmIF9nZXRTdHlsZSh0LCBcImRpc3BsYXlcIiwgY3MpID09PSBcIm5vbmVcIikpIHsgLy9zb21ldGltZXMgYSA2LWVsZW1lbnQgbWF0cml4IGlzIHJldHVybmVkIGV2ZW4gd2hlbiB3ZSBwZXJmb3JtZWQgM0QgdHJhbnNmb3JtcywgbGlrZSBpZiByb3RhdGlvblggYW5kIHJvdGF0aW9uWSBhcmUgMTgwLiBJbiBjYXNlcyBsaWtlIHRoaXMsIHdlIHN0aWxsIG5lZWQgdG8gaG9ub3IgdGhlIDNEIHRyYW5zZm9ybXMuIElmIHdlIGp1c3QgcmVseSBvbiB0aGUgMkQgaW5mbywgaXQgY291bGQgYWZmZWN0IGhvdyB0aGUgZGF0YSBpcyBpbnRlcnByZXRlZCwgbGlrZSBzY2FsZVkgbWlnaHQgZ2V0IHNldCB0byAtMSBvciByb3RhdGlvbiBjb3VsZCBnZXQgb2Zmc2V0IGJ5IDE4MCBkZWdyZWVzLiBGb3IgZXhhbXBsZSwgZG8gYSBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7cm90YXRpb25YOjE4MCwgcm90YXRpb25ZOjE4MH19KSBhbmQgdGhlbiBsYXRlciwgVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e3JvdGF0aW9uWDowfX0pIGFuZCB3aXRob3V0IHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW4gcGxhY2UsIGl0J2QganVtcCB0byBhIHN0YXRlIG9mIGJlaW5nIHVucm90YXRlZCB3aGVuIHRoZSAybmQgdHdlZW4gc3RhcnRzLiBUaGVuIGFnYWluLCB3ZSBuZWVkIHRvIGhvbm9yIHRoZSBmYWN0IHRoYXQgdGhlIHVzZXIgQ09VTEQgYWx0ZXIgdGhlIHRyYW5zZm9ybXMgb3V0c2lkZSBvZiBDU1NQbHVnaW4sIGxpa2UgYnkgbWFudWFsbHkgYXBwbHlpbmcgbmV3IGNzcywgc28gd2UgdHJ5IHRvIHNlbnNlIHRoYXQgYnkgbG9va2luZyBhdCB4IGFuZCB5IGJlY2F1c2UgaWYgdGhvc2UgY2hhbmdlZCwgd2Uga25vdyB0aGUgY2hhbmdlcyB3ZXJlIG1hZGUgb3V0c2lkZSBDU1NQbHVnaW4gYW5kIHdlIGZvcmNlIGEgcmVpbnRlcnByZXRhdGlvbiBvZiB0aGUgbWF0cml4IHZhbHVlcy4gQWxzbywgaW4gV2Via2l0IGJyb3dzZXJzLCBpZiB0aGUgZWxlbWVudCdzIFwiZGlzcGxheVwiIGlzIFwibm9uZVwiLCBpdHMgY2FsY3VsYXRlZCBzdHlsZSB2YWx1ZSB3aWxsIGFsd2F5cyByZXR1cm4gZW1wdHksIHNvIGlmIHdlJ3ZlIGFscmVhZHkgcmVjb3JkZWQgdGhlIHZhbHVlcyBpbiB0aGUgX2dzVHJhbnNmb3JtIG9iamVjdCwgd2UnbGwganVzdCByZWx5IG9uIHRob3NlLlxuXHRcdFx0XHRcdFx0dmFyIGsgPSAobS5sZW5ndGggPj0gNiksXG5cdFx0XHRcdFx0XHRcdGEgPSBrID8gbVswXSA6IDEsXG5cdFx0XHRcdFx0XHRcdGIgPSBtWzFdIHx8IDAsXG5cdFx0XHRcdFx0XHRcdGMgPSBtWzJdIHx8IDAsXG5cdFx0XHRcdFx0XHRcdGQgPSBrID8gbVszXSA6IDE7XG5cdFx0XHRcdFx0XHR0bS54ID0gbVs0XSB8fCAwO1xuXHRcdFx0XHRcdFx0dG0ueSA9IG1bNV0gfHwgMDtcblx0XHRcdFx0XHRcdHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblx0XHRcdFx0XHRcdHNjYWxlWSA9IE1hdGguc3FydChkICogZCArIGMgKiBjKTtcblx0XHRcdFx0XHRcdHJvdGF0aW9uID0gKGEgfHwgYikgPyBNYXRoLmF0YW4yKGIsIGEpICogX1JBRDJERUcgOiB0bS5yb3RhdGlvbiB8fCAwOyAvL25vdGU6IGlmIHNjYWxlWCBpcyAwLCB3ZSBjYW5ub3QgYWNjdXJhdGVseSBtZWFzdXJlIHJvdGF0aW9uLiBTYW1lIGZvciBza2V3WCB3aXRoIGEgc2NhbGVZIG9mIDAuIFRoZXJlZm9yZSwgd2UgZGVmYXVsdCB0byB0aGUgcHJldmlvdXNseSByZWNvcmRlZCB2YWx1ZSAob3IgemVybyBpZiB0aGF0IGRvZXNuJ3QgZXhpc3QpLlxuXHRcdFx0XHRcdFx0c2tld1ggPSAoYyB8fCBkKSA/IE1hdGguYXRhbjIoYywgZCkgKiBfUkFEMkRFRyArIHJvdGF0aW9uIDogdG0uc2tld1ggfHwgMDtcblx0XHRcdFx0XHRcdGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcblx0XHRcdFx0XHRcdFx0aWYgKGludlgpIHtcblx0XHRcdFx0XHRcdFx0XHRzY2FsZVggKj0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0c2tld1ggKz0gKHJvdGF0aW9uIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdFx0XHRcdFx0XHRyb3RhdGlvbiArPSAocm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNjYWxlWSAqPSAtMTtcblx0XHRcdFx0XHRcdFx0XHRza2V3WCArPSAoc2tld1ggPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVggPSBzY2FsZVg7XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVkgPSBzY2FsZVk7XG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuXHRcdFx0XHRcdFx0dG0uc2tld1ggPSBza2V3WDtcblx0XHRcdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblggPSB0bS5yb3RhdGlvblkgPSB0bS56ID0gMDtcblx0XHRcdFx0XHRcdFx0dG0ucGVyc3BlY3RpdmUgPSBkZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmU7XG5cdFx0XHRcdFx0XHRcdHRtLnNjYWxlWiA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodG0uc3ZnKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnggLT0gdG0ueE9yaWdpbiAtICh0bS54T3JpZ2luICogYSArIHRtLnlPcmlnaW4gKiBjKTtcblx0XHRcdFx0XHRcdFx0dG0ueSAtPSB0bS55T3JpZ2luIC0gKHRtLnhPcmlnaW4gKiBiICsgdG0ueU9yaWdpbiAqIGQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bS56T3JpZ2luID0gek9yaWdpbjtcblx0XHRcdFx0XHQvL3NvbWUgYnJvd3NlcnMgaGF2ZSBhIGhhcmQgdGltZSB3aXRoIHZlcnkgc21hbGwgdmFsdWVzIGxpa2UgMi40NDkyOTM1OTgyOTQ3MDY0ZS0xNiAobm90aWNlIHRoZSBcImUtXCIgdG93YXJkcyB0aGUgZW5kKSBhbmQgd291bGQgcmVuZGVyIHRoZSBvYmplY3Qgc2xpZ2h0bHkgb2ZmLiBTbyB3ZSByb3VuZCB0byAwIGluIHRoZXNlIGNhc2VzLiBUaGUgY29uZGl0aW9uYWwgbG9naWMgaGVyZSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIE1hdGguYWJzKCkuIEFsc28sIGJyb3dzZXJzIHRlbmQgdG8gcmVuZGVyIGEgU0xJR0hUTFkgcm90YXRlZCBvYmplY3QgaW4gYSBmdXp6eSB3YXksIHNvIHdlIG5lZWQgdG8gc25hcCB0byBleGFjdGx5IDAgd2hlbiBhcHByb3ByaWF0ZS5cblx0XHRcdFx0XHRmb3IgKGkgaW4gdG0pIHtcblx0XHRcdFx0XHRcdGlmICh0bVtpXSA8IG1pbikgaWYgKHRtW2ldID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHR0bVtpXSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vREVCVUc6IF9sb2coXCJwYXJzZWQgcm90YXRpb24gb2YgXCIgKyB0LmdldEF0dHJpYnV0ZShcImlkXCIpK1wiOiBcIisodG0ucm90YXRpb25YKStcIiwgXCIrKHRtLnJvdGF0aW9uWSkrXCIsIFwiKyh0bS5yb3RhdGlvbikrXCIsIHNjYWxlOiBcIit0bS5zY2FsZVgrXCIsIFwiK3RtLnNjYWxlWStcIiwgXCIrdG0uc2NhbGVaK1wiLCBwb3NpdGlvbjogXCIrdG0ueCtcIiwgXCIrdG0ueStcIiwgXCIrdG0ueitcIiwgcGVyc3BlY3RpdmU6IFwiK3RtLnBlcnNwZWN0aXZlKyBcIiwgb3JpZ2luOiBcIisgdG0ueE9yaWdpbisgXCIsXCIrIHRtLnlPcmlnaW4pO1xuXHRcdFx0XHRpZiAocmVjKSB7XG5cdFx0XHRcdFx0dC5fZ3NUcmFuc2Zvcm0gPSB0bTsgLy9yZWNvcmQgdG8gdGhlIG9iamVjdCdzIF9nc1RyYW5zZm9ybSB3aGljaCB3ZSB1c2Ugc28gdGhhdCB0d2VlbnMgY2FuIGNvbnRyb2wgaW5kaXZpZHVhbCBwcm9wZXJ0aWVzIGluZGVwZW5kZW50bHkgKHdlIG5lZWQgYWxsIHRoZSBwcm9wZXJ0aWVzIHRvIGFjY3VyYXRlbHkgcmVjb21wb3NlIHRoZSBtYXRyaXggaW4gdGhlIHNldFJhdGlvKCkgbWV0aG9kKVxuXHRcdFx0XHRcdGlmICh0bS5zdmcpIHsgLy9pZiB3ZSdyZSBzdXBwb3NlZCB0byBhcHBseSB0cmFuc2Zvcm1zIHRvIHRoZSBTVkcgZWxlbWVudCdzIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCBtYWtlIHN1cmUgdGhlcmUgYXJlbid0IGFueSBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkIG9yIHRoZXknbGwgb3ZlcnJpZGUgdGhlIGF0dHJpYnV0ZSBvbmVzLiBBbHNvIGNsZWFyIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGlmIHdlJ3JlIHVzaW5nIENTUywganVzdCB0byBiZSBjbGVhbi5cblx0XHRcdFx0XHRcdGlmIChfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiB0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSkge1xuXHRcdFx0XHRcdFx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwoMC4wMDEsIGZ1bmN0aW9uKCl7IC8vaWYgd2UgYXBwbHkgdGhpcyByaWdodCBhd2F5IChiZWZvcmUgYW55dGhpbmcgaGFzIHJlbmRlcmVkKSwgd2UgcmlzayB0aGVyZSBiZWluZyBubyB0cmFuc2Zvcm1zIGZvciBhIGJyaWVmIG1vbWVudCBhbmQgaXQgYWxzbyBpbnRlcmZlcmVzIHdpdGggYWRqdXN0aW5nIHRoZSB0cmFuc2Zvcm1PcmlnaW4gaW4gYSB0d2VlbiB3aXRoIGltbWVkaWF0ZVJlbmRlcjp0cnVlIChpdCdkIHRyeSByZWFkaW5nIHRoZSBtYXRyaXggYW5kIGl0IHdvdWxkbid0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGRhdGEgaW4gcGxhY2UgYmVjYXVzZSB3ZSBqdXN0IHJlbW92ZWQgaXQpLlxuXHRcdFx0XHRcdFx0XHRcdF9yZW1vdmVQcm9wKHQuc3R5bGUsIF90cmFuc2Zvcm1Qcm9wKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiB0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSkge1xuXHRcdFx0XHRcdFx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwoMC4wMDEsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0dC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdG07XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2ZvciBzZXR0aW5nIDJEIHRyYW5zZm9ybXMgaW4gSUU2LCBJRTcsIGFuZCBJRTggKG11c3QgdXNlIGEgXCJmaWx0ZXJcIiB0byBlbXVsYXRlIHRoZSBiZWhhdmlvciBvZiBtb2Rlcm4gZGF5IGJyb3dzZXIgdHJhbnNmb3Jtcylcblx0XHRcdF9zZXRJRVRyYW5zZm9ybVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMuZGF0YSwgLy9yZWZlcnMgdG8gdGhlIGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0XG5cdFx0XHRcdFx0YW5nID0gLXQucm90YXRpb24gKiBfREVHMlJBRCxcblx0XHRcdFx0XHRza2V3ID0gYW5nICsgdC5za2V3WCAqIF9ERUcyUkFELFxuXHRcdFx0XHRcdHJuZCA9IDEwMDAwMCxcblx0XHRcdFx0XHRhID0gKChNYXRoLmNvcyhhbmcpICogdC5zY2FsZVggKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0YiA9ICgoTWF0aC5zaW4oYW5nKSAqIHQuc2NhbGVYICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdGMgPSAoKE1hdGguc2luKHNrZXcpICogLXQuc2NhbGVZICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdGQgPSAoKE1hdGguY29zKHNrZXcpICogdC5zY2FsZVkgKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0c3R5bGUgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0Y3MgPSB0aGlzLnQuY3VycmVudFN0eWxlLFxuXHRcdFx0XHRcdGZpbHRlcnMsIHZhbDtcblx0XHRcdFx0aWYgKCFjcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWwgPSBiOyAvL2p1c3QgZm9yIHN3YXBwaW5nIHRoZSB2YXJpYWJsZXMgYW4gaW52ZXJ0aW5nIHRoZW0gKHJldXNlZCBcInZhbFwiIHRvIGF2b2lkIGNyZWF0aW5nIGFub3RoZXIgdmFyaWFibGUgaW4gbWVtb3J5KS4gSUUncyBmaWx0ZXIgbWF0cml4IHVzZXMgYSBub24tc3RhbmRhcmQgbWF0cml4IGNvbmZpZ3VyYXRpb24gKGFuZ2xlIGdvZXMgdGhlIG9wcG9zaXRlIHdheSwgYW5kIGIgYW5kIGMgYXJlIHJldmVyc2VkIGFuZCBpbnZlcnRlZClcblx0XHRcdFx0YiA9IC1jO1xuXHRcdFx0XHRjID0gLXZhbDtcblx0XHRcdFx0ZmlsdGVycyA9IGNzLmZpbHRlcjtcblx0XHRcdFx0c3R5bGUuZmlsdGVyID0gXCJcIjsgLy9yZW1vdmUgZmlsdGVycyBzbyB0aGF0IHdlIGNhbiBhY2N1cmF0ZWx5IG1lYXN1cmUgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0XG5cdFx0XHRcdHZhciB3ID0gdGhpcy50Lm9mZnNldFdpZHRoLFxuXHRcdFx0XHRcdGggPSB0aGlzLnQub2Zmc2V0SGVpZ2h0LFxuXHRcdFx0XHRcdGNsaXAgPSAoY3MucG9zaXRpb24gIT09IFwiYWJzb2x1dGVcIiksXG5cdFx0XHRcdFx0bSA9IFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9XCIgKyBhICsgXCIsIE0xMj1cIiArIGIgKyBcIiwgTTIxPVwiICsgYyArIFwiLCBNMjI9XCIgKyBkLFxuXHRcdFx0XHRcdG94ID0gdC54ICsgKHcgKiB0LnhQZXJjZW50IC8gMTAwKSxcblx0XHRcdFx0XHRveSA9IHQueSArIChoICogdC55UGVyY2VudCAvIDEwMCksXG5cdFx0XHRcdFx0ZHgsIGR5O1xuXG5cdFx0XHRcdC8vaWYgdHJhbnNmb3JtT3JpZ2luIGlzIGJlaW5nIHVzZWQsIGFkanVzdCB0aGUgb2Zmc2V0IHggYW5kIHlcblx0XHRcdFx0aWYgKHQub3ggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGR4ID0gKCh0Lm94cCkgPyB3ICogdC5veCAqIDAuMDEgOiB0Lm94KSAtIHcgLyAyO1xuXHRcdFx0XHRcdGR5ID0gKCh0Lm95cCkgPyBoICogdC5veSAqIDAuMDEgOiB0Lm95KSAtIGggLyAyO1xuXHRcdFx0XHRcdG94ICs9IGR4IC0gKGR4ICogYSArIGR5ICogYik7XG5cdFx0XHRcdFx0b3kgKz0gZHkgLSAoZHggKiBjICsgZHkgKiBkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghY2xpcCkge1xuXHRcdFx0XHRcdG0gKz0gXCIsIHNpemluZ01ldGhvZD0nYXV0byBleHBhbmQnKVwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGR4ID0gKHcgLyAyKTtcblx0XHRcdFx0XHRkeSA9IChoIC8gMik7XG5cdFx0XHRcdFx0Ly90cmFuc2xhdGUgdG8gZW5zdXJlIHRoYXQgdHJhbnNmb3JtYXRpb25zIG9jY3VyIGFyb3VuZCB0aGUgY29ycmVjdCBvcmlnaW4gKGRlZmF1bHQgaXMgY2VudGVyKS5cblx0XHRcdFx0XHRtICs9IFwiLCBEeD1cIiArIChkeCAtIChkeCAqIGEgKyBkeSAqIGIpICsgb3gpICsgXCIsIER5PVwiICsgKGR5IC0gKGR4ICogYyArIGR5ICogZCkgKyBveSkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZmlsdGVycy5pbmRleE9mKFwiRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRzdHlsZS5maWx0ZXIgPSBmaWx0ZXJzLnJlcGxhY2UoX2llU2V0TWF0cml4RXhwLCBtKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZS5maWx0ZXIgPSBtICsgXCIgXCIgKyBmaWx0ZXJzOyAvL3dlIG11c3QgYWx3YXlzIHB1dCB0aGUgdHJhbnNmb3JtL21hdHJpeCBGSVJTVCAoYmVmb3JlIGFscGhhKG9wYWNpdHk9eHgpKSB0byBhdm9pZCBhbiBJRSBidWcgdGhhdCBzbGljZXMgcGFydCBvZiB0aGUgb2JqZWN0IHdoZW4gcm90YXRpb24gaXMgYXBwbGllZCB3aXRoIGFscGhhLlxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9hdCB0aGUgZW5kIG9yIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4sIGlmIHRoZSBtYXRyaXggaXMgbm9ybWFsICgxLCAwLCAwLCAxKSBhbmQgb3BhY2l0eSBpcyAxMDAgKG9yIGRvZXNuJ3QgZXhpc3QpLCByZW1vdmUgdGhlIGZpbHRlciB0byBpbXByb3ZlIGJyb3dzZXIgcGVyZm9ybWFuY2UuXG5cdFx0XHRcdGlmICh2ID09PSAwIHx8IHYgPT09IDEpIGlmIChhID09PSAxKSBpZiAoYiA9PT0gMCkgaWYgKGMgPT09IDApIGlmIChkID09PSAxKSBpZiAoIWNsaXAgfHwgbS5pbmRleE9mKFwiRHg9MCwgRHk9MFwiKSAhPT0gLTEpIGlmICghX29wYWNpdHlFeHAudGVzdChmaWx0ZXJzKSB8fCBwYXJzZUZsb2F0KFJlZ0V4cC4kMSkgPT09IDEwMCkgaWYgKGZpbHRlcnMuaW5kZXhPZihcImdyYWRpZW50KFwiICYmIGZpbHRlcnMuaW5kZXhPZihcIkFscGhhXCIpKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL3dlIG11c3Qgc2V0IHRoZSBtYXJnaW5zIEFGVEVSIGFwcGx5aW5nIHRoZSBmaWx0ZXIgaW4gb3JkZXIgdG8gYXZvaWQgc29tZSBidWdzIGluIElFOCB0aGF0IGNvdWxkIChpbiByYXJlIHNjZW5hcmlvcykgY2F1c2UgdGhlbSB0byBiZSBpZ25vcmVkIGludGVybWl0dGVudGx5ICh2aWJyYXRpb24pLlxuXHRcdFx0XHRpZiAoIWNsaXApIHtcblx0XHRcdFx0XHR2YXIgbXVsdCA9IChfaWVWZXJzIDwgOCkgPyAxIDogLTEsIC8vaW4gSW50ZXJuZXQgRXhwbG9yZXIgNyBhbmQgYmVmb3JlLCB0aGUgYm94IG1vZGVsIGlzIGJyb2tlbiwgY2F1c2luZyB0aGUgYnJvd3NlciB0byB0cmVhdCB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBhY3R1YWwgcm90YXRlZCBmaWx0ZXJlZCBpbWFnZSBhcyB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBib3ggaXRzZWxmLCBidXQgTWljcm9zb2Z0IGNvcnJlY3RlZCB0aGF0IGluIElFOC4gV2UgbXVzdCB1c2UgYSBuZWdhdGl2ZSBvZmZzZXQgaW4gSUU4IG9uIHRoZSByaWdodC9ib3R0b21cblx0XHRcdFx0XHRcdG1hcmcsIHByb3AsIGRpZjtcblx0XHRcdFx0XHRkeCA9IHQuaWVPZmZzZXRYIHx8IDA7XG5cdFx0XHRcdFx0ZHkgPSB0LmllT2Zmc2V0WSB8fCAwO1xuXHRcdFx0XHRcdHQuaWVPZmZzZXRYID0gTWF0aC5yb3VuZCgodyAtICgoYSA8IDAgPyAtYSA6IGEpICogdyArIChiIDwgMCA/IC1iIDogYikgKiBoKSkgLyAyICsgb3gpO1xuXHRcdFx0XHRcdHQuaWVPZmZzZXRZID0gTWF0aC5yb3VuZCgoaCAtICgoZCA8IDAgPyAtZCA6IGQpICogaCArIChjIDwgMCA/IC1jIDogYykgKiB3KSkgLyAyICsgb3kpO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0XHRcdHByb3AgPSBfbWFyZ2luc1tpXTtcblx0XHRcdFx0XHRcdG1hcmcgPSBjc1twcm9wXTtcblx0XHRcdFx0XHRcdC8vd2UgbmVlZCB0byBnZXQgdGhlIGN1cnJlbnQgbWFyZ2luIGluIGNhc2UgaXQgaXMgYmVpbmcgdHdlZW5lZCBzZXBhcmF0ZWx5ICh3ZSB3YW50IHRvIHJlc3BlY3QgdGhhdCB0d2VlbidzIGNoYW5nZXMpXG5cdFx0XHRcdFx0XHR2YWwgPSAobWFyZy5pbmRleE9mKFwicHhcIikgIT09IC0xKSA/IHBhcnNlRmxvYXQobWFyZykgOiBfY29udmVydFRvUGl4ZWxzKHRoaXMudCwgcHJvcCwgcGFyc2VGbG9hdChtYXJnKSwgbWFyZy5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpKSB8fCAwO1xuXHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gdFtwcm9wXSkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoaSA8IDIpID8gLXQuaWVPZmZzZXRYIDogLXQuaWVPZmZzZXRZOyAvL2lmIGFub3RoZXIgdHdlZW4gaXMgY29udHJvbGxpbmcgYSBtYXJnaW4sIHdlIGNhbm5vdCBvbmx5IGFwcGx5IHRoZSBkaWZmZXJlbmNlIGluIHRoZSBpZU9mZnNldHMsIHNvIHdlIGVzc2VudGlhbGx5IHplcm8tb3V0IHRoZSBkeCBhbmQgZHkgaGVyZSBpbiB0aGF0IGNhc2UuIFdlIHJlY29yZCB0aGUgbWFyZ2luKHMpIGxhdGVyIHNvIHRoYXQgd2UgY2FuIGtlZXAgY29tcGFyaW5nIHRoZW0sIG1ha2luZyB0aGlzIGNvZGUgdmVyeSBmbGV4aWJsZS5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IChpIDwgMikgPyBkeCAtIHQuaWVPZmZzZXRYIDogZHkgLSB0LmllT2Zmc2V0WTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0eWxlW3Byb3BdID0gKHRbcHJvcF0gPSBNYXRoLnJvdW5kKCB2YWwgLSBkaWYgKiAoKGkgPT09IDAgfHwgaSA9PT0gMikgPyAxIDogbXVsdCkgKSkgKyBcInB4XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKiB0cmFuc2xhdGVzIGEgc3VwZXIgc21hbGwgZGVjaW1hbCB0byBhIHN0cmluZyBXSVRIT1VUIHNjaWVudGlmaWMgbm90YXRpb25cblx0XHRcdF9zYWZlRGVjaW1hbCA9IGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0dmFyIHMgPSAobiA8IDAgPyAtbiA6IG4pICsgXCJcIixcblx0XHRcdFx0XHRhID0gcy5zcGxpdChcImUtXCIpO1xuXHRcdFx0XHRyZXR1cm4gKG4gPCAwID8gXCItMC5cIiA6IFwiMC5cIikgKyBuZXcgQXJyYXkocGFyc2VJbnQoYVsxXSwgMTApIHx8IDApLmpvaW4oXCIwXCIpICsgYVswXS5zcGxpdChcIi5cIikuam9pbihcIlwiKTtcblx0XHRcdH0sXG5cdFx0XHQqL1xuXG5cdFx0XHRfc2V0VHJhbnNmb3JtUmF0aW8gPSBfaW50ZXJuYWxzLnNldDNEVHJhbnNmb3JtUmF0aW8gPSBfaW50ZXJuYWxzLnNldFRyYW5zZm9ybVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMuZGF0YSwgLy9yZWZlcnMgdG8gdGhlIGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0XG5cdFx0XHRcdFx0c3R5bGUgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0YW5nbGUgPSB0LnJvdGF0aW9uLFxuXHRcdFx0XHRcdHJvdGF0aW9uWCA9IHQucm90YXRpb25YLFxuXHRcdFx0XHRcdHJvdGF0aW9uWSA9IHQucm90YXRpb25ZLFxuXHRcdFx0XHRcdHN4ID0gdC5zY2FsZVgsXG5cdFx0XHRcdFx0c3kgPSB0LnNjYWxlWSxcblx0XHRcdFx0XHRzeiA9IHQuc2NhbGVaLFxuXHRcdFx0XHRcdHggPSB0LngsXG5cdFx0XHRcdFx0eSA9IHQueSxcblx0XHRcdFx0XHR6ID0gdC56LFxuXHRcdFx0XHRcdGlzU1ZHID0gdC5zdmcsXG5cdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSB0LnBlcnNwZWN0aXZlLFxuXHRcdFx0XHRcdGZvcmNlM0QgPSB0LmZvcmNlM0QsXG5cdFx0XHRcdFx0YTExLCBhMTIsIGExMywgYTIxLCBhMjIsIGEyMywgYTMxLCBhMzIsIGEzMywgYTQxLCBhNDIsIGE0Myxcblx0XHRcdFx0XHR6T3JpZ2luLCBtaW4sIGNvcywgc2luLCB0MSwgdDIsIHRyYW5zZm9ybSwgY29tbWEsIHplcm8sIHNrZXcsIHJuZDtcblx0XHRcdFx0Ly9jaGVjayB0byBzZWUgaWYgd2Ugc2hvdWxkIHJlbmRlciBhcyAyRCAoYW5kIFNWR3MgbXVzdCB1c2UgMkQgd2hlbiBfdXNlU1ZHVHJhbnNmb3JtQXR0ciBpcyB0cnVlKVxuXHRcdFx0XHRpZiAoKCgoKHYgPT09IDEgfHwgdiA9PT0gMCkgJiYgZm9yY2UzRCA9PT0gXCJhdXRvXCIgJiYgKHRoaXMudHdlZW4uX3RvdGFsVGltZSA9PT0gdGhpcy50d2Vlbi5fdG90YWxEdXJhdGlvbiB8fCAhdGhpcy50d2Vlbi5fdG90YWxUaW1lKSkgfHwgIWZvcmNlM0QpICYmICF6ICYmICFwZXJzcGVjdGl2ZSAmJiAhcm90YXRpb25ZICYmICFyb3RhdGlvblggJiYgc3ogPT09IDEpIHx8IChfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiBpc1NWRykgfHwgIV9zdXBwb3J0czNEKSB7IC8vb24gdGhlIGZpbmFsIHJlbmRlciAod2hpY2ggY291bGQgYmUgMCBmb3IgYSBmcm9tIHR3ZWVuKSwgaWYgdGhlcmUgYXJlIG5vIDNEIGFzcGVjdHMsIHJlbmRlciBpbiAyRCB0byBmcmVlIHVwIG1lbW9yeSBhbmQgaW1wcm92ZSBwZXJmb3JtYW5jZSBlc3BlY2lhbGx5IG9uIG1vYmlsZSBkZXZpY2VzLiBDaGVjayB0aGUgdHdlZW4ncyB0b3RhbFRpbWUvdG90YWxEdXJhdGlvbiB0b28gaW4gb3JkZXIgdG8gbWFrZSBzdXJlIGl0IGRvZXNuJ3QgaGFwcGVuIGJldHdlZW4gcmVwZWF0cyBpZiBpdCdzIGEgcmVwZWF0aW5nIHR3ZWVuLlxuXG5cdFx0XHRcdFx0Ly8yRFxuXHRcdFx0XHRcdGlmIChhbmdsZSB8fCB0LnNrZXdYIHx8IGlzU1ZHKSB7XG5cdFx0XHRcdFx0XHRhbmdsZSAqPSBfREVHMlJBRDtcblx0XHRcdFx0XHRcdHNrZXcgPSB0LnNrZXdYICogX0RFRzJSQUQ7XG5cdFx0XHRcdFx0XHRybmQgPSAxMDAwMDA7XG5cdFx0XHRcdFx0XHRhMTEgPSBNYXRoLmNvcyhhbmdsZSkgKiBzeDtcblx0XHRcdFx0XHRcdGEyMSA9IE1hdGguc2luKGFuZ2xlKSAqIHN4O1xuXHRcdFx0XHRcdFx0YTEyID0gTWF0aC5zaW4oYW5nbGUgLSBza2V3KSAqIC1zeTtcblx0XHRcdFx0XHRcdGEyMiA9IE1hdGguY29zKGFuZ2xlIC0gc2tldykgKiBzeTtcblx0XHRcdFx0XHRcdGlmIChza2V3ICYmIHQuc2tld1R5cGUgPT09IFwic2ltcGxlXCIpIHsgLy9ieSBkZWZhdWx0LCB3ZSBjb21wZW5zYXRlIHNrZXdpbmcgb24gdGhlIG90aGVyIGF4aXMgdG8gbWFrZSBpdCBsb29rIG1vcmUgbmF0dXJhbCwgYnV0IHlvdSBjYW4gc2V0IHRoZSBza2V3VHlwZSB0byBcInNpbXBsZVwiIHRvIHVzZSB0aGUgdW5jb21wZW5zYXRlZCBza2V3aW5nIHRoYXQgQ1NTIGRvZXNcblx0XHRcdFx0XHRcdFx0dDEgPSBNYXRoLnRhbihza2V3KTtcblx0XHRcdFx0XHRcdFx0dDEgPSBNYXRoLnNxcnQoMSArIHQxICogdDEpO1xuXHRcdFx0XHRcdFx0XHRhMTIgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdGEyMiAqPSB0MTtcblx0XHRcdFx0XHRcdFx0aWYgKHQuc2tld1kpIHtcblx0XHRcdFx0XHRcdFx0XHRhMTEgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdFx0YTIxICo9IHQxO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoaXNTVkcpIHtcblx0XHRcdFx0XHRcdFx0eCArPSB0LnhPcmlnaW4gLSAodC54T3JpZ2luICogYTExICsgdC55T3JpZ2luICogYTEyKSArIHQueE9mZnNldDtcblx0XHRcdFx0XHRcdFx0eSArPSB0LnlPcmlnaW4gLSAodC54T3JpZ2luICogYTIxICsgdC55T3JpZ2luICogYTIyKSArIHQueU9mZnNldDtcblx0XHRcdFx0XHRcdFx0aWYgKF91c2VTVkdUcmFuc2Zvcm1BdHRyICYmICh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpKSB7IC8vVGhlIFNWRyBzcGVjIGRvZXNuJ3Qgc3VwcG9ydCBwZXJjZW50YWdlLWJhc2VkIHRyYW5zbGF0aW9uIGluIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgc28gd2UgbWVyZ2UgaXQgaW50byB0aGUgbWF0cml4IHRvIHNpbXVsYXRlIGl0LlxuXHRcdFx0XHRcdFx0XHRcdG1pbiA9IHRoaXMudC5nZXRCQm94KCk7XG5cdFx0XHRcdFx0XHRcdFx0eCArPSB0LnhQZXJjZW50ICogMC4wMSAqIG1pbi53aWR0aDtcblx0XHRcdFx0XHRcdFx0XHR5ICs9IHQueVBlcmNlbnQgKiAwLjAxICogbWluLmhlaWdodDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtaW4gPSAwLjAwMDAwMTtcblx0XHRcdFx0XHRcdFx0aWYgKHggPCBtaW4pIGlmICh4ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHRcdHggPSAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICh5IDwgbWluKSBpZiAoeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJhbnNmb3JtID0gKCgoYTExICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTIxICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTEyICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTIyICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0aWYgKGlzU1ZHICYmIF91c2VTVkdUcmFuc2Zvcm1BdHRyKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJtYXRyaXgoXCIgKyB0cmFuc2Zvcm0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly9zb21lIGJyb3dzZXJzIGhhdmUgYSBoYXJkIHRpbWUgd2l0aCB2ZXJ5IHNtYWxsIHZhbHVlcyBsaWtlIDIuNDQ5MjkzNTk4Mjk0NzA2NGUtMTYgKG5vdGljZSB0aGUgXCJlLVwiIHRvd2FyZHMgdGhlIGVuZCkgYW5kIHdvdWxkIHJlbmRlciB0aGUgb2JqZWN0IHNsaWdodGx5IG9mZi4gU28gd2Ugcm91bmQgdG8gNSBkZWNpbWFsIHBsYWNlcy5cblx0XHRcdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgbWF0cml4KFwiIDogXCJtYXRyaXgoXCIpICsgdHJhbnNmb3JtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoKHQueFBlcmNlbnQgfHwgdC55UGVyY2VudCkgPyBcInRyYW5zbGF0ZShcIiArIHQueFBlcmNlbnQgKyBcIiUsXCIgKyB0LnlQZXJjZW50ICsgXCIlKSBtYXRyaXgoXCIgOiBcIm1hdHJpeChcIikgKyBzeCArIFwiLDAsMCxcIiArIHN5ICsgXCIsXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNGaXJlZm94KSB7IC8vRmlyZWZveCBoYXMgYSBidWcgKGF0IGxlYXN0IGluIHYyNSkgdGhhdCBjYXVzZXMgaXQgdG8gcmVuZGVyIHRoZSB0cmFuc3BhcmVudCBwYXJ0IG9mIDMyLWJpdCBQTkcgaW1hZ2VzIGFzIGJsYWNrIHdoZW4gZGlzcGxheWVkIGluc2lkZSBhbiBpZnJhbWUgYW5kIHRoZSAzRCBzY2FsZSBpcyB2ZXJ5IHNtYWxsIGFuZCBkb2Vzbid0IGNoYW5nZSBzdWZmaWNpZW50bHkgZW5vdWdoIGJldHdlZW4gcmVuZGVycyAobGlrZSBpZiB5b3UgdXNlIGEgUG93ZXI0LmVhc2VJbk91dCB0byBzY2FsZSBmcm9tIDAgdG8gMSB3aGVyZSB0aGUgYmVnaW5uaW5nIHZhbHVlcyBvbmx5IGNoYW5nZSBhIHRpbnkgYW1vdW50IHRvIGJlZ2luIHRoZSB0d2VlbiBiZWZvcmUgYWNjZWxlcmF0aW5nKS4gSW4gdGhpcyBjYXNlLCB3ZSBmb3JjZSB0aGUgc2NhbGUgdG8gYmUgMC4wMDAwMiBpbnN0ZWFkIHdoaWNoIGlzIHZpc3VhbGx5IHRoZSBzYW1lIGJ1dCB3b3JrcyBhcm91bmQgdGhlIEZpcmVmb3ggaXNzdWUuXG5cdFx0XHRcdFx0bWluID0gMC4wMDAxO1xuXHRcdFx0XHRcdGlmIChzeCA8IG1pbiAmJiBzeCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHN4ID0gc3ogPSAwLjAwMDAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc3kgPCBtaW4gJiYgc3kgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRzeSA9IHN6ID0gMC4wMDAwMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBlcnNwZWN0aXZlICYmICF0LnogJiYgIXQucm90YXRpb25YICYmICF0LnJvdGF0aW9uWSkgeyAvL0ZpcmVmb3ggaGFzIGEgYnVnIHRoYXQgY2F1c2VzIGVsZW1lbnRzIHRvIGhhdmUgYW4gb2RkIHN1cGVyLXRoaW4sIGJyb2tlbi9kb3R0ZWQgYmxhY2sgYm9yZGVyIG9uIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIHBlcnNwZWN0aXZlIHNldCBidXQgYXJlbid0IHV0aWxpemluZyAzRCBzcGFjZSAobm8gcm90YXRpb25YLCByb3RhdGlvblksIG9yIHopLlxuXHRcdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYW5nbGUgfHwgdC5za2V3WCkge1xuXHRcdFx0XHRcdGFuZ2xlICo9IF9ERUcyUkFEO1xuXHRcdFx0XHRcdGNvcyA9IGExMSA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRzaW4gPSBhMjEgPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRcdFx0aWYgKHQuc2tld1gpIHtcblx0XHRcdFx0XHRcdGFuZ2xlIC09IHQuc2tld1ggKiBfREVHMlJBRDtcblx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRcdGlmICh0LnNrZXdUeXBlID09PSBcInNpbXBsZVwiKSB7IC8vYnkgZGVmYXVsdCwgd2UgY29tcGVuc2F0ZSBza2V3aW5nIG9uIHRoZSBvdGhlciBheGlzIHRvIG1ha2UgaXQgbG9vayBtb3JlIG5hdHVyYWwsIGJ1dCB5b3UgY2FuIHNldCB0aGUgc2tld1R5cGUgdG8gXCJzaW1wbGVcIiB0byB1c2UgdGhlIHVuY29tcGVuc2F0ZWQgc2tld2luZyB0aGF0IENTUyBkb2VzXG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4odC5za2V3WCAqIF9ERUcyUkFEKTtcblx0XHRcdFx0XHRcdFx0dDEgPSBNYXRoLnNxcnQoMSArIHQxICogdDEpO1xuXHRcdFx0XHRcdFx0XHRjb3MgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdHNpbiAqPSB0MTtcblx0XHRcdFx0XHRcdFx0aWYgKHQuc2tld1kpIHtcblx0XHRcdFx0XHRcdFx0XHRhMTEgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdFx0YTIxICo9IHQxO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGExMiA9IC1zaW47XG5cdFx0XHRcdFx0YTIyID0gY29zO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIXJvdGF0aW9uWSAmJiAhcm90YXRpb25YICYmIHN6ID09PSAxICYmICFwZXJzcGVjdGl2ZSAmJiAhaXNTVkcpIHsgLy9pZiB3ZSdyZSBvbmx5IHRyYW5zbGF0aW5nIGFuZC9vciAyRCBzY2FsaW5nLCB0aGlzIGlzIGZhc3Rlci4uLlxuXHRcdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIHRyYW5zbGF0ZTNkKFwiIDogXCJ0cmFuc2xhdGUzZChcIikgKyB4ICsgXCJweCxcIiArIHkgKyBcInB4LFwiICsgeiArXCJweClcIiArICgoc3ggIT09IDEgfHwgc3kgIT09IDEpID8gXCIgc2NhbGUoXCIgKyBzeCArIFwiLFwiICsgc3kgKyBcIilcIiA6IFwiXCIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhMTEgPSBhMjIgPSAxO1xuXHRcdFx0XHRcdGExMiA9IGEyMSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gS0VZICBJTkRFWCAgIEFGRkVDVFNcblx0XHRcdFx0Ly8gYTExICAwICAgICAgIHJvdGF0aW9uLCByb3RhdGlvblksIHNjYWxlWFxuXHRcdFx0XHQvLyBhMjEgIDEgICAgICAgcm90YXRpb24sIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGEzMSAgMiAgICAgICByb3RhdGlvblksIHNjYWxlWFxuXHRcdFx0XHQvLyBhNDEgIDMgICAgICAgcm90YXRpb25ZLCBzY2FsZVhcblx0XHRcdFx0Ly8gYTEyICA0ICAgICAgIHJvdGF0aW9uLCBza2V3WCwgcm90YXRpb25YLCBzY2FsZVlcblx0XHRcdFx0Ly8gYTIyICA1ICAgICAgIHJvdGF0aW9uLCBza2V3WCwgcm90YXRpb25YLCBzY2FsZVlcblx0XHRcdFx0Ly8gYTMyICA2ICAgICAgIHJvdGF0aW9uWCwgc2NhbGVZXG5cdFx0XHRcdC8vIGE0MiAgNyAgICAgICByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMTMgIDggICAgICAgcm90YXRpb25ZLCByb3RhdGlvblgsIHNjYWxlWlxuXHRcdFx0XHQvLyBhMjMgIDkgICAgICAgcm90YXRpb25ZLCByb3RhdGlvblgsIHNjYWxlWlxuXHRcdFx0XHQvLyBhMzMgIDEwICAgICAgcm90YXRpb25ZLCByb3RhdGlvblgsIHNjYWxlWlxuXHRcdFx0XHQvLyBhNDMgIDExICAgICAgcm90YXRpb25ZLCByb3RhdGlvblgsIHBlcnNwZWN0aXZlLCBzY2FsZVpcblx0XHRcdFx0Ly8gYTE0ICAxMiAgICAgIHgsIHpPcmlnaW4sIHN2Z09yaWdpblxuXHRcdFx0XHQvLyBhMjQgIDEzICAgICAgeSwgek9yaWdpbiwgc3ZnT3JpZ2luXG5cdFx0XHRcdC8vIGEzNCAgMTQgICAgICB6LCB6T3JpZ2luXG5cdFx0XHRcdC8vIGE0NCAgMTVcblx0XHRcdFx0Ly8gcm90YXRpb246IE1hdGguYXRhbjIoYTIxLCBhMTEpXG5cdFx0XHRcdC8vIHJvdGF0aW9uWTogTWF0aC5hdGFuMihhMTMsIGEzMykgKG9yIE1hdGguYXRhbjIoYTEzLCBhMTEpKVxuXHRcdFx0XHQvLyByb3RhdGlvblg6IE1hdGguYXRhbjIoYTMyLCBhMzMpXG5cdFx0XHRcdGEzMyA9IDE7XG5cdFx0XHRcdGExMyA9IGEyMyA9IGEzMSA9IGEzMiA9IGE0MSA9IGE0MiA9IDA7XG5cdFx0XHRcdGE0MyA9IChwZXJzcGVjdGl2ZSkgPyAtMSAvIHBlcnNwZWN0aXZlIDogMDtcblx0XHRcdFx0ek9yaWdpbiA9IHQuek9yaWdpbjtcblx0XHRcdFx0bWluID0gMC4wMDAwMDE7IC8vdGhyZXNob2xkIGJlbG93IHdoaWNoIGJyb3dzZXJzIHVzZSBzY2llbnRpZmljIG5vdGF0aW9uIHdoaWNoIHdvbid0IHdvcmsuXG5cdFx0XHRcdGNvbW1hID0gXCIsXCI7XG5cdFx0XHRcdHplcm8gPSBcIjBcIjtcblx0XHRcdFx0YW5nbGUgPSByb3RhdGlvblkgKiBfREVHMlJBRDtcblx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRhMzEgPSAtc2luO1xuXHRcdFx0XHRcdGE0MSA9IGE0Myotc2luO1xuXHRcdFx0XHRcdGExMyA9IGExMSpzaW47XG5cdFx0XHRcdFx0YTIzID0gYTIxKnNpbjtcblx0XHRcdFx0XHRhMzMgPSBjb3M7XG5cdFx0XHRcdFx0YTQzICo9IGNvcztcblx0XHRcdFx0XHRhMTEgKj0gY29zO1xuXHRcdFx0XHRcdGEyMSAqPSBjb3M7XG5cdFx0XHRcdH1cblx0XHRcdFx0YW5nbGUgPSByb3RhdGlvblggKiBfREVHMlJBRDtcblx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHR0MSA9IGExMipjb3MrYTEzKnNpbjtcblx0XHRcdFx0XHR0MiA9IGEyMipjb3MrYTIzKnNpbjtcblx0XHRcdFx0XHRhMzIgPSBhMzMqc2luO1xuXHRcdFx0XHRcdGE0MiA9IGE0MypzaW47XG5cdFx0XHRcdFx0YTEzID0gYTEyKi1zaW4rYTEzKmNvcztcblx0XHRcdFx0XHRhMjMgPSBhMjIqLXNpbithMjMqY29zO1xuXHRcdFx0XHRcdGEzMyA9IGEzMypjb3M7XG5cdFx0XHRcdFx0YTQzID0gYTQzKmNvcztcblx0XHRcdFx0XHRhMTIgPSB0MTtcblx0XHRcdFx0XHRhMjIgPSB0Mjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3ogIT09IDEpIHtcblx0XHRcdFx0XHRhMTMqPXN6O1xuXHRcdFx0XHRcdGEyMyo9c3o7XG5cdFx0XHRcdFx0YTMzKj1zejtcblx0XHRcdFx0XHRhNDMqPXN6O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeSAhPT0gMSkge1xuXHRcdFx0XHRcdGExMio9c3k7XG5cdFx0XHRcdFx0YTIyKj1zeTtcblx0XHRcdFx0XHRhMzIqPXN5O1xuXHRcdFx0XHRcdGE0Mio9c3k7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN4ICE9PSAxKSB7XG5cdFx0XHRcdFx0YTExKj1zeDtcblx0XHRcdFx0XHRhMjEqPXN4O1xuXHRcdFx0XHRcdGEzMSo9c3g7XG5cdFx0XHRcdFx0YTQxKj1zeDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh6T3JpZ2luIHx8IGlzU1ZHKSB7XG5cdFx0XHRcdFx0aWYgKHpPcmlnaW4pIHtcblx0XHRcdFx0XHRcdHggKz0gYTEzKi16T3JpZ2luO1xuXHRcdFx0XHRcdFx0eSArPSBhMjMqLXpPcmlnaW47XG5cdFx0XHRcdFx0XHR6ICs9IGEzMyotek9yaWdpbit6T3JpZ2luO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaXNTVkcpIHsgLy9kdWUgdG8gYnVncyBpbiBzb21lIGJyb3dzZXJzLCB3ZSBuZWVkIHRvIG1hbmFnZSB0aGUgdHJhbnNmb3JtLW9yaWdpbiBvZiBTVkcgbWFudWFsbHlcblx0XHRcdFx0XHRcdHggKz0gdC54T3JpZ2luIC0gKHQueE9yaWdpbiAqIGExMSArIHQueU9yaWdpbiAqIGExMikgKyB0LnhPZmZzZXQ7XG5cdFx0XHRcdFx0XHR5ICs9IHQueU9yaWdpbiAtICh0LnhPcmlnaW4gKiBhMjEgKyB0LnlPcmlnaW4gKiBhMjIpICsgdC55T2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeCA8IG1pbiAmJiB4ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0eCA9IHplcm87XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh5IDwgbWluICYmIHkgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR5ID0gemVybztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHogPCBtaW4gJiYgeiA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHogPSAwOyAvL2Rvbid0IHVzZSBzdHJpbmcgYmVjYXVzZSB3ZSBjYWxjdWxhdGUgcGVyc3BlY3RpdmUgbGF0ZXIgYW5kIG5lZWQgdGhlIG51bWJlci5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL29wdGltaXplZCB3YXkgb2YgY29uY2F0ZW5hdGluZyBhbGwgdGhlIHZhbHVlcyBpbnRvIGEgc3RyaW5nLiBJZiB3ZSBkbyBpdCBhbGwgaW4gb25lIHNob3QsIGl0J3Mgc2xvd2VyIGJlY2F1c2Ugb2YgdGhlIHdheSBicm93c2VycyBoYXZlIHRvIGNyZWF0ZSB0ZW1wIHN0cmluZ3MgYW5kIHRoZSB3YXkgaXQgYWZmZWN0cyBtZW1vcnkuIElmIHdlIGRvIGl0IHBpZWNlLWJ5LXBpZWNlIHdpdGggKz0sIGl0J3MgYSBiaXQgc2xvd2VyIHRvby4gV2UgZm91bmQgdGhhdCBkb2luZyBpdCBpbiB0aGVzZSBzaXplZCBjaHVua3Mgd29ya3MgYmVzdCBvdmVyYWxsOlxuXHRcdFx0XHR0cmFuc2Zvcm0gPSAoKHQueFBlcmNlbnQgfHwgdC55UGVyY2VudCkgPyBcInRyYW5zbGF0ZShcIiArIHQueFBlcmNlbnQgKyBcIiUsXCIgKyB0LnlQZXJjZW50ICsgXCIlKSBtYXRyaXgzZChcIiA6IFwibWF0cml4M2QoXCIpO1xuXHRcdFx0XHR0cmFuc2Zvcm0gKz0gKChhMTEgPCBtaW4gJiYgYTExID4gLW1pbikgPyB6ZXJvIDogYTExKSArIGNvbW1hICsgKChhMjEgPCBtaW4gJiYgYTIxID4gLW1pbikgPyB6ZXJvIDogYTIxKSArIGNvbW1hICsgKChhMzEgPCBtaW4gJiYgYTMxID4gLW1pbikgPyB6ZXJvIDogYTMxKTtcblx0XHRcdFx0dHJhbnNmb3JtICs9IGNvbW1hICsgKChhNDEgPCBtaW4gJiYgYTQxID4gLW1pbikgPyB6ZXJvIDogYTQxKSArIGNvbW1hICsgKChhMTIgPCBtaW4gJiYgYTEyID4gLW1pbikgPyB6ZXJvIDogYTEyKSArIGNvbW1hICsgKChhMjIgPCBtaW4gJiYgYTIyID4gLW1pbikgPyB6ZXJvIDogYTIyKTtcblx0XHRcdFx0aWYgKHJvdGF0aW9uWCB8fCByb3RhdGlvblkgfHwgc3ogIT09IDEpIHsgLy9wZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gKG9mdGVuIHRoZXJlJ3Mgbm8gcm90YXRpb25YIG9yIHJvdGF0aW9uWSwgc28gd2UgY2FuIHNraXAgdGhlc2UgY2FsY3VsYXRpb25zKVxuXHRcdFx0XHRcdHRyYW5zZm9ybSArPSBjb21tYSArICgoYTMyIDwgbWluICYmIGEzMiA+IC1taW4pID8gemVybyA6IGEzMikgKyBjb21tYSArICgoYTQyIDwgbWluICYmIGE0MiA+IC1taW4pID8gemVybyA6IGE0MikgKyBjb21tYSArICgoYTEzIDwgbWluICYmIGExMyA+IC1taW4pID8gemVybyA6IGExMyk7XG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IGNvbW1hICsgKChhMjMgPCBtaW4gJiYgYTIzID4gLW1pbikgPyB6ZXJvIDogYTIzKSArIGNvbW1hICsgKChhMzMgPCBtaW4gJiYgYTMzID4gLW1pbikgPyB6ZXJvIDogYTMzKSArIGNvbW1hICsgKChhNDMgPCBtaW4gJiYgYTQzID4gLW1pbikgPyB6ZXJvIDogYTQzKSArIGNvbW1hO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRyYW5zZm9ybSArPSBcIiwwLDAsMCwwLDEsMCxcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0cmFuc2Zvcm0gKz0geCArIGNvbW1hICsgeSArIGNvbW1hICsgeiArIGNvbW1hICsgKHBlcnNwZWN0aXZlID8gKDEgKyAoLXogLyBwZXJzcGVjdGl2ZSkpIDogMSkgKyBcIilcIjtcblxuXHRcdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cdFx0XHR9O1xuXG5cdFx0cCA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cdFx0cC54ID0gcC55ID0gcC56ID0gcC5za2V3WCA9IHAuc2tld1kgPSBwLnJvdGF0aW9uID0gcC5yb3RhdGlvblggPSBwLnJvdGF0aW9uWSA9IHAuek9yaWdpbiA9IHAueFBlcmNlbnQgPSBwLnlQZXJjZW50ID0gcC54T2Zmc2V0ID0gcC55T2Zmc2V0ID0gMDtcblx0XHRwLnNjYWxlWCA9IHAuc2NhbGVZID0gcC5zY2FsZVogPSAxO1xuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwidHJhbnNmb3JtLHNjYWxlLHNjYWxlWCxzY2FsZVksc2NhbGVaLHgseSx6LHJvdGF0aW9uLHJvdGF0aW9uWCxyb3RhdGlvblkscm90YXRpb25aLHNrZXdYLHNrZXdZLHNob3J0Um90YXRpb24sc2hvcnRSb3RhdGlvblgsc2hvcnRSb3RhdGlvblksc2hvcnRSb3RhdGlvblosdHJhbnNmb3JtT3JpZ2luLHN2Z09yaWdpbix0cmFuc2Zvcm1QZXJzcGVjdGl2ZSxkaXJlY3Rpb25hbFJvdGF0aW9uLHBhcnNlVHJhbnNmb3JtLGZvcmNlM0Qsc2tld1R5cGUseFBlcmNlbnQseVBlcmNlbnQsc21vb3RoT3JpZ2luXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0aWYgKGNzc3AuX2xhc3RQYXJzZWRUcmFuc2Zvcm0gPT09IHZhcnMpIHsgcmV0dXJuIHB0OyB9IC8vb25seSBuZWVkIHRvIHBhcnNlIHRoZSB0cmFuc2Zvcm0gb25jZSwgYW5kIG9ubHkgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQuXG5cdFx0XHRjc3NwLl9sYXN0UGFyc2VkVHJhbnNmb3JtID0gdmFycztcblx0XHRcdHZhciBvcmlnaW5hbEdTVHJhbnNmb3JtID0gdC5fZ3NUcmFuc2Zvcm0sXG5cdFx0XHRcdHN0eWxlID0gdC5zdHlsZSxcblx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdGkgPSBfdHJhbnNmb3JtUHJvcHMubGVuZ3RoLFxuXHRcdFx0XHR2ID0gdmFycyxcblx0XHRcdFx0ZW5kUm90YXRpb25zID0ge30sXG5cdFx0XHRcdHRyYW5zZm9ybU9yaWdpblN0cmluZyA9IFwidHJhbnNmb3JtT3JpZ2luXCIsXG5cdFx0XHRcdG0xLCBtMiwgY29weSwgb3JpZywgaGFzM0QsIGhhc0NoYW5nZSwgZHIsIHgsIHksIG1hdHJpeDtcblx0XHRcdGlmICh2YXJzLmRpc3BsYXkpIHsgLy9pZiB0aGUgdXNlciBpcyBzZXR0aW5nIGRpc3BsYXkgZHVyaW5nIHRoaXMgdHdlZW4sIGl0IG1heSBub3QgYmUgaW5zdGFudGlhdGVkIHlldCBidXQgd2UgbXVzdCBmb3JjZSBpdCBoZXJlIGluIG9yZGVyIHRvIGdldCBhY2N1cmF0ZSByZWFkaW5ncy4gSWYgZGlzcGxheSBpcyBcIm5vbmVcIiwgc29tZSBicm93c2VycyByZWZ1c2UgdG8gcmVwb3J0IHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBjb3JyZWN0bHkuXG5cdFx0XHRcdGNvcHkgPSBfZ2V0U3R5bGUodCwgXCJkaXNwbGF5XCIpO1xuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXHRcdFx0XHRtMSA9IF9nZXRUcmFuc2Zvcm0odCwgX2NzLCB0cnVlLCB2YXJzLnBhcnNlVHJhbnNmb3JtKTtcblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IGNvcHk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtMSA9IF9nZXRUcmFuc2Zvcm0odCwgX2NzLCB0cnVlLCB2YXJzLnBhcnNlVHJhbnNmb3JtKTtcblx0XHRcdH1cblx0XHRcdGNzc3AuX3RyYW5zZm9ybSA9IG0xO1xuXHRcdFx0aWYgKHR5cGVvZih2LnRyYW5zZm9ybSkgPT09IFwic3RyaW5nXCIgJiYgX3RyYW5zZm9ybVByb3ApIHsgLy9mb3IgdmFsdWVzIGxpa2UgdHJhbnNmb3JtOlwicm90YXRlKDYwZGVnKSBzY2FsZSgwLjUsIDAuOClcIlxuXHRcdFx0XHRjb3B5ID0gX3RlbXBEaXYuc3R5bGU7IC8vZG9uJ3QgdXNlIHRoZSBvcmlnaW5hbCB0YXJnZXQgYmVjYXVzZSBpdCBtaWdodCBiZSBTVkcgaW4gd2hpY2ggY2FzZSBzb21lIGJyb3dzZXJzIGRvbid0IHJlcG9ydCBjb21wdXRlZCBzdHlsZSBjb3JyZWN0bHkuXG5cdFx0XHRcdGNvcHlbX3RyYW5zZm9ybVByb3BdID0gdi50cmFuc2Zvcm07XG5cdFx0XHRcdGNvcHkuZGlzcGxheSA9IFwiYmxvY2tcIjsgLy9pZiBkaXNwbGF5IGlzIFwibm9uZVwiLCB0aGUgYnJvd3NlciBvZnRlbiByZWZ1c2VzIHRvIHJlcG9ydCB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgY29ycmVjdGx5LlxuXHRcdFx0XHRjb3B5LnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdFx0XHRfZG9jLmJvZHkuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRtMiA9IF9nZXRUcmFuc2Zvcm0oX3RlbXBEaXYsIG51bGwsIGZhbHNlKTtcblx0XHRcdFx0aWYgKG0xLnN2ZykgeyAvL2lmIGl0J3MgYW4gU1ZHIGVsZW1lbnQsIHgveSBwYXJ0IG9mIHRoZSBtYXRyaXggd2lsbCBiZSBhZmZlY3RlZCBieSB3aGF0ZXZlciB3ZSB1c2UgYXMgdGhlIG9yaWdpbiBhbmQgdGhlIG9mZnNldHMsIHNvIGNvbXBlbnNhdGUgaGVyZS4uLlxuXHRcdFx0XHRcdHggPSBtMS54T3JpZ2luO1xuXHRcdFx0XHRcdHkgPSBtMS55T3JpZ2luO1xuXHRcdFx0XHRcdG0yLnggLT0gbTEueE9mZnNldDtcblx0XHRcdFx0XHRtMi55IC09IG0xLnlPZmZzZXQ7XG5cdFx0XHRcdFx0aWYgKHYudHJhbnNmb3JtT3JpZ2luIHx8IHYuc3ZnT3JpZ2luKSB7IC8vaWYgdGhpcyB0d2VlbiBpcyBhbHRlcmluZyB0aGUgb3JpZ2luLCB3ZSBtdXN0IGZhY3RvciB0aGF0IGluIGhlcmUuIFRoZSBhY3R1YWwgd29yayBvZiByZWNvcmRpbmcgdGhlIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXMgYW5kIHNldHRpbmcgdXAgdGhlIFByb3BUd2VlbiBpcyBkb25lIGxhdGVyIChzdGlsbCBpbnNpZGUgdGhpcyBmdW5jdGlvbikgc28gd2UgY2Fubm90IGxlYXZlIHRoZSBjaGFuZ2VzIGludGFjdCBoZXJlIC0gd2Ugb25seSB3YW50IHRvIHVwZGF0ZSB0aGUgeC95IGFjY29yZGluZ2x5LlxuXHRcdFx0XHRcdFx0b3JpZyA9IHt9O1xuXHRcdFx0XHRcdFx0X3BhcnNlU1ZHT3JpZ2luKHQsIF9wYXJzZVBvc2l0aW9uKHYudHJhbnNmb3JtT3JpZ2luKSwgb3JpZywgdi5zdmdPcmlnaW4sIHYuc21vb3RoT3JpZ2luLCB0cnVlKTtcblx0XHRcdFx0XHRcdHggPSBvcmlnLnhPcmlnaW47XG5cdFx0XHRcdFx0XHR5ID0gb3JpZy55T3JpZ2luO1xuXHRcdFx0XHRcdFx0bTIueCAtPSBvcmlnLnhPZmZzZXQgLSBtMS54T2Zmc2V0O1xuXHRcdFx0XHRcdFx0bTIueSAtPSBvcmlnLnlPZmZzZXQgLSBtMS55T2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeCB8fCB5KSB7XG5cdFx0XHRcdFx0XHRtYXRyaXggPSBfZ2V0TWF0cml4KF90ZW1wRGl2KTtcblx0XHRcdFx0XHRcdG0yLnggLT0geCAtICh4ICogbWF0cml4WzBdICsgeSAqIG1hdHJpeFsyXSk7XG5cdFx0XHRcdFx0XHRtMi55IC09IHkgLSAoeCAqIG1hdHJpeFsxXSArIHkgKiBtYXRyaXhbM10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfZG9jLmJvZHkucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRpZiAoIW0yLnBlcnNwZWN0aXZlKSB7XG5cdFx0XHRcdFx0bTIucGVyc3BlY3RpdmUgPSBtMS5wZXJzcGVjdGl2ZTsgLy90d2VlbmluZyB0byBubyBwZXJzcGVjdGl2ZSBnaXZlcyB2ZXJ5IHVuaW50dWl0aXZlIHJlc3VsdHMgLSBqdXN0IGtlZXAgdGhlIHNhbWUgcGVyc3BlY3RpdmUgaW4gdGhhdCBjYXNlLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LnhQZXJjZW50ICE9IG51bGwpIHtcblx0XHRcdFx0XHRtMi54UGVyY2VudCA9IF9wYXJzZVZhbCh2LnhQZXJjZW50LCBtMS54UGVyY2VudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYueVBlcmNlbnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdG0yLnlQZXJjZW50ID0gX3BhcnNlVmFsKHYueVBlcmNlbnQsIG0xLnlQZXJjZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodikgPT09IFwib2JqZWN0XCIpIHsgLy9mb3IgdmFsdWVzIGxpa2Ugc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCB4LCB5LCBza2V3WCwgYW5kIHNrZXdZIG9yIHRyYW5zZm9ybTp7Li4ufSAob2JqZWN0KVxuXHRcdFx0XHRtMiA9IHtzY2FsZVg6X3BhcnNlVmFsKCh2LnNjYWxlWCAhPSBudWxsKSA/IHYuc2NhbGVYIDogdi5zY2FsZSwgbTEuc2NhbGVYKSxcblx0XHRcdFx0XHRzY2FsZVk6X3BhcnNlVmFsKCh2LnNjYWxlWSAhPSBudWxsKSA/IHYuc2NhbGVZIDogdi5zY2FsZSwgbTEuc2NhbGVZKSxcblx0XHRcdFx0XHRzY2FsZVo6X3BhcnNlVmFsKHYuc2NhbGVaLCBtMS5zY2FsZVopLFxuXHRcdFx0XHRcdHg6X3BhcnNlVmFsKHYueCwgbTEueCksXG5cdFx0XHRcdFx0eTpfcGFyc2VWYWwodi55LCBtMS55KSxcblx0XHRcdFx0XHR6Ol9wYXJzZVZhbCh2LnosIG0xLnopLFxuXHRcdFx0XHRcdHhQZXJjZW50Ol9wYXJzZVZhbCh2LnhQZXJjZW50LCBtMS54UGVyY2VudCksXG5cdFx0XHRcdFx0eVBlcmNlbnQ6X3BhcnNlVmFsKHYueVBlcmNlbnQsIG0xLnlQZXJjZW50KSxcblx0XHRcdFx0XHRwZXJzcGVjdGl2ZTpfcGFyc2VWYWwodi50cmFuc2Zvcm1QZXJzcGVjdGl2ZSwgbTEucGVyc3BlY3RpdmUpfTtcblx0XHRcdFx0ZHIgPSB2LmRpcmVjdGlvbmFsUm90YXRpb247XG5cdFx0XHRcdGlmIChkciAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZihkcikgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRcdGZvciAoY29weSBpbiBkcikge1xuXHRcdFx0XHRcdFx0XHR2W2NvcHldID0gZHJbY29weV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHYucm90YXRpb24gPSBkcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZih2LngpID09PSBcInN0cmluZ1wiICYmIHYueC5pbmRleE9mKFwiJVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRtMi54ID0gMDtcblx0XHRcdFx0XHRtMi54UGVyY2VudCA9IF9wYXJzZVZhbCh2LngsIG0xLnhQZXJjZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mKHYueSkgPT09IFwic3RyaW5nXCIgJiYgdi55LmluZGV4T2YoXCIlXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdG0yLnkgPSAwO1xuXHRcdFx0XHRcdG0yLnlQZXJjZW50ID0gX3BhcnNlVmFsKHYueSwgbTEueVBlcmNlbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bTIucm90YXRpb24gPSBfcGFyc2VBbmdsZSgoXCJyb3RhdGlvblwiIGluIHYpID8gdi5yb3RhdGlvbiA6IChcInNob3J0Um90YXRpb25cIiBpbiB2KSA/IHYuc2hvcnRSb3RhdGlvbiArIFwiX3Nob3J0XCIgOiAoXCJyb3RhdGlvblpcIiBpbiB2KSA/IHYucm90YXRpb25aIDogbTEucm90YXRpb24gLSBtMS5za2V3WSwgbTEucm90YXRpb24gLSBtMS5za2V3WSwgXCJyb3RhdGlvblwiLCBlbmRSb3RhdGlvbnMpOyAvL3NlZSBub3RlcyBiZWxvdyBhYm91dCBza2V3WSBmb3Igd2h5IHdlIHN1YnRyYWN0IGl0IGZyb20gcm90YXRpb24gaGVyZVxuXHRcdFx0XHRpZiAoX3N1cHBvcnRzM0QpIHtcblx0XHRcdFx0XHRtMi5yb3RhdGlvblggPSBfcGFyc2VBbmdsZSgoXCJyb3RhdGlvblhcIiBpbiB2KSA/IHYucm90YXRpb25YIDogKFwic2hvcnRSb3RhdGlvblhcIiBpbiB2KSA/IHYuc2hvcnRSb3RhdGlvblggKyBcIl9zaG9ydFwiIDogbTEucm90YXRpb25YIHx8IDAsIG0xLnJvdGF0aW9uWCwgXCJyb3RhdGlvblhcIiwgZW5kUm90YXRpb25zKTtcblx0XHRcdFx0XHRtMi5yb3RhdGlvblkgPSBfcGFyc2VBbmdsZSgoXCJyb3RhdGlvbllcIiBpbiB2KSA/IHYucm90YXRpb25ZIDogKFwic2hvcnRSb3RhdGlvbllcIiBpbiB2KSA/IHYuc2hvcnRSb3RhdGlvblkgKyBcIl9zaG9ydFwiIDogbTEucm90YXRpb25ZIHx8IDAsIG0xLnJvdGF0aW9uWSwgXCJyb3RhdGlvbllcIiwgZW5kUm90YXRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtMi5za2V3WCA9IF9wYXJzZUFuZ2xlKHYuc2tld1gsIG0xLnNrZXdYIC0gbTEuc2tld1kpOyAvL3NlZSBub3RlcyBiZWxvdyBhYm91dCBza2V3WSBhbmQgd2h5IHdlIHN1YnRyYWN0IGl0IGZyb20gc2tld1ggaGVyZVxuXG5cdFx0XHRcdC8vbm90ZTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGNvbWJpbmUgYWxsIHNrZXdpbmcgaW50byB0aGUgc2tld1ggYW5kIHJvdGF0aW9uIHZhbHVlcywgaWdub3Jpbmcgc2tld1kgYnV0IHdlIG11c3Qgc3RpbGwgcmVjb3JkIGl0IHNvIHRoYXQgd2UgY2FuIGRpc2Nlcm4gaG93IG11Y2ggb2YgdGhlIG92ZXJhbGwgc2tldyBpcyBhdHRyaWJ1dGVkIHRvIHNrZXdYIHZzLiBza2V3WS4gT3RoZXJ3aXNlLCBpZiB0aGUgc2tld1kgd291bGQgYWx3YXlzIGFjdCByZWxhdGl2ZSAodHdlZW4gc2tld1kgdG8gMTBkZWcsIGZvciBleGFtcGxlLCBtdWx0aXBsZSB0aW1lcyBhbmQgaWYgd2UgYWx3YXlzIGNvbWJpbmUgdGhpbmdzIGludG8gc2tld1gsIHdlIGNhbid0IHJlbWVtYmVyIHRoYXQgc2tld1kgd2FzIDEwIGZyb20gbGFzdCB0aW1lKS4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgZGVncmVlcyBsb29rcyB0aGUgc2FtZSBhcyBhIHJvdGF0aW9uIG9mIDEwIGRlZ3JlZXMgcGx1cyBhIHNrZXdYIG9mIC0xMCBkZWdyZWVzLlxuXHRcdFx0XHRpZiAoKG0yLnNrZXdZID0gX3BhcnNlQW5nbGUodi5za2V3WSwgbTEuc2tld1kpKSkge1xuXHRcdFx0XHRcdG0yLnNrZXdYICs9IG0yLnNrZXdZO1xuXHRcdFx0XHRcdG0yLnJvdGF0aW9uICs9IG0yLnNrZXdZO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoX3N1cHBvcnRzM0QgJiYgdi5mb3JjZTNEICE9IG51bGwpIHtcblx0XHRcdFx0bTEuZm9yY2UzRCA9IHYuZm9yY2UzRDtcblx0XHRcdFx0aGFzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0bTEuc2tld1R5cGUgPSB2LnNrZXdUeXBlIHx8IG0xLnNrZXdUeXBlIHx8IENTU1BsdWdpbi5kZWZhdWx0U2tld1R5cGU7XG5cblx0XHRcdGhhczNEID0gKG0xLmZvcmNlM0QgfHwgbTEueiB8fCBtMS5yb3RhdGlvblggfHwgbTEucm90YXRpb25ZIHx8IG0yLnogfHwgbTIucm90YXRpb25YIHx8IG0yLnJvdGF0aW9uWSB8fCBtMi5wZXJzcGVjdGl2ZSk7XG5cdFx0XHRpZiAoIWhhczNEICYmIHYuc2NhbGUgIT0gbnVsbCkge1xuXHRcdFx0XHRtMi5zY2FsZVogPSAxOyAvL25vIG5lZWQgdG8gdHdlZW4gc2NhbGVaLlxuXHRcdFx0fVxuXG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0cCA9IF90cmFuc2Zvcm1Qcm9wc1tpXTtcblx0XHRcdFx0b3JpZyA9IG0yW3BdIC0gbTFbcF07XG5cdFx0XHRcdGlmIChvcmlnID4gbWluIHx8IG9yaWcgPCAtbWluIHx8IHZbcF0gIT0gbnVsbCB8fCBfZm9yY2VQVFtwXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aGFzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4obTEsIHAsIG0xW3BdLCBvcmlnLCBwdCk7XG5cdFx0XHRcdFx0aWYgKHAgaW4gZW5kUm90YXRpb25zKSB7XG5cdFx0XHRcdFx0XHRwdC5lID0gZW5kUm90YXRpb25zW3BdOyAvL2RpcmVjdGlvbmFsIHJvdGF0aW9ucyB0eXBpY2FsbHkgaGF2ZSBjb21wZW5zYXRlZCB2YWx1ZXMgZHVyaW5nIHRoZSB0d2VlbiwgYnV0IHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXkgZW5kIGF0IGV4YWN0bHkgd2hhdCB0aGUgdXNlciByZXF1ZXN0ZWRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQueHMwID0gMDsgLy9lbnN1cmVzIHRoZSB2YWx1ZSBzdGF5cyBudW1lcmljIGluIHNldFJhdGlvKClcblx0XHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdFx0Y3NzcC5fb3ZlcndyaXRlUHJvcHMucHVzaChwdC5uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRvcmlnID0gdi50cmFuc2Zvcm1PcmlnaW47XG5cdFx0XHRpZiAobTEuc3ZnICYmIChvcmlnIHx8IHYuc3ZnT3JpZ2luKSkge1xuXHRcdFx0XHR4ID0gbTEueE9mZnNldDsgLy93aGVuIHdlIGNoYW5nZSB0aGUgb3JpZ2luLCBpbiBvcmRlciB0byBwcmV2ZW50IHRoaW5ncyBmcm9tIGp1bXBpbmcgd2UgYWRqdXN0IHRoZSB4L3kgc28gd2UgbXVzdCByZWNvcmQgdGhvc2UgaGVyZSBzbyB0aGF0IHdlIGNhbiBjcmVhdGUgUHJvcFR3ZWVucyBmb3IgdGhlbSBhbmQgZmxpcCB0aGVtIGF0IHRoZSBzYW1lIHRpbWUgYXMgdGhlIG9yaWdpblxuXHRcdFx0XHR5ID0gbTEueU9mZnNldDtcblx0XHRcdFx0X3BhcnNlU1ZHT3JpZ2luKHQsIF9wYXJzZVBvc2l0aW9uKG9yaWcpLCBtMiwgdi5zdmdPcmlnaW4sIHYuc21vb3RoT3JpZ2luKTtcblx0XHRcdFx0cHQgPSBfYWRkTm9uVHdlZW5pbmdOdW1lcmljUFQobTEsIFwieE9yaWdpblwiLCAob3JpZ2luYWxHU1RyYW5zZm9ybSA/IG0xIDogbTIpLnhPcmlnaW4sIG0yLnhPcmlnaW4sIHB0LCB0cmFuc2Zvcm1PcmlnaW5TdHJpbmcpOyAvL25vdGU6IGlmIHRoZXJlIHdhc24ndCBhIHRyYW5zZm9ybU9yaWdpbiBkZWZpbmVkIHlldCwganVzdCBzdGFydCB3aXRoIHRoZSBkZXN0aW5hdGlvbiBvbmU7IGl0J3Mgd2FzdGVmdWwgb3RoZXJ3aXNlLCBhbmQgaXQgY2F1c2VzIHByb2JsZW1zIHdpdGggZnJvbVRvKCkgdHdlZW5zLiBGb3IgZXhhbXBsZSwgVHdlZW5MaXRlLnRvKFwiI3doZWVsXCIsIDMsIHtyb3RhdGlvbjoxODAsIHRyYW5zZm9ybU9yaWdpbjpcIjUwJSA1MCVcIiwgZGVsYXk6MX0pOyBUd2VlbkxpdGUuZnJvbVRvKFwiI3doZWVsXCIsIDMsIHtzY2FsZTowLjUsIHRyYW5zZm9ybU9yaWdpbjpcIjUwJSA1MCVcIn0sIHtzY2FsZToxLCBkZWxheToyfSk7IHdvdWxkIGNhdXNlIGEganVtcCB3aGVuIHRoZSBmcm9tIHZhbHVlcyByZXZlcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgMm5kIHR3ZWVuLlxuXHRcdFx0XHRwdCA9IF9hZGROb25Ud2VlbmluZ051bWVyaWNQVChtMSwgXCJ5T3JpZ2luXCIsIChvcmlnaW5hbEdTVHJhbnNmb3JtID8gbTEgOiBtMikueU9yaWdpbiwgbTIueU9yaWdpbiwgcHQsIHRyYW5zZm9ybU9yaWdpblN0cmluZyk7XG5cdFx0XHRcdGlmICh4ICE9PSBtMS54T2Zmc2V0IHx8IHkgIT09IG0xLnlPZmZzZXQpIHtcblx0XHRcdFx0XHRwdCA9IF9hZGROb25Ud2VlbmluZ051bWVyaWNQVChtMSwgXCJ4T2Zmc2V0XCIsIChvcmlnaW5hbEdTVHJhbnNmb3JtID8geCA6IG0xLnhPZmZzZXQpLCBtMS54T2Zmc2V0LCBwdCwgdHJhbnNmb3JtT3JpZ2luU3RyaW5nKTtcblx0XHRcdFx0XHRwdCA9IF9hZGROb25Ud2VlbmluZ051bWVyaWNQVChtMSwgXCJ5T2Zmc2V0XCIsIChvcmlnaW5hbEdTVHJhbnNmb3JtID8geSA6IG0xLnlPZmZzZXQpLCBtMS55T2Zmc2V0LCBwdCwgdHJhbnNmb3JtT3JpZ2luU3RyaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcmlnID0gX3VzZVNWR1RyYW5zZm9ybUF0dHIgPyBudWxsIDogXCIwcHggMHB4XCI7IC8vY2VydGFpbiBicm93c2VycyAobGlrZSBmaXJlZm94KSBjb21wbGV0ZWx5IGJvdGNoIHRyYW5zZm9ybS1vcmlnaW4sIHNvIHdlIG11c3QgcmVtb3ZlIGl0IHRvIHByZXZlbnQgaXQgZnJvbSBjb250YW1pbmF0aW5nIHRyYW5zZm9ybXMuIFdlIG1hbmFnZSBpdCBvdXJzZWx2ZXMgd2l0aCB4T3JpZ2luIGFuZCB5T3JpZ2luXG5cdFx0XHR9XG5cdFx0XHRpZiAob3JpZyB8fCAoX3N1cHBvcnRzM0QgJiYgaGFzM0QgJiYgbTEuek9yaWdpbikpIHsgLy9pZiBhbnl0aGluZyAzRCBpcyBoYXBwZW5pbmcgYW5kIHRoZXJlJ3MgYSB0cmFuc2Zvcm1PcmlnaW4gd2l0aCBhIHogY29tcG9uZW50IHRoYXQncyBub24temVybywgd2UgbXVzdCBlbnN1cmUgdGhhdCB0aGUgdHJhbnNmb3JtT3JpZ2luJ3Mgei1jb21wb25lbnQgaXMgc2V0IHRvIDAgc28gdGhhdCB3ZSBjYW4gbWFudWFsbHkgZG8gdGhvc2UgY2FsY3VsYXRpb25zIHRvIGdldCBhcm91bmQgU2FmYXJpIGJ1Z3MuIEV2ZW4gaWYgdGhlIHVzZXIgZGlkbid0IHNwZWNpZmljYWxseSBkZWZpbmUgYSBcInRyYW5zZm9ybU9yaWdpblwiIGluIHRoaXMgcGFydGljdWxhciB0d2VlbiAobWF5YmUgdGhleSBkaWQgaXQgdmlhIGNzcyBkaXJlY3RseSkuXG5cdFx0XHRcdGlmIChfdHJhbnNmb3JtUHJvcCkge1xuXHRcdFx0XHRcdGhhc0NoYW5nZSA9IHRydWU7XG5cdFx0XHRcdFx0cCA9IF90cmFuc2Zvcm1PcmlnaW5Qcm9wO1xuXHRcdFx0XHRcdG9yaWcgPSAob3JpZyB8fCBfZ2V0U3R5bGUodCwgcCwgX2NzLCBmYWxzZSwgXCI1MCUgNTAlXCIpKSArIFwiXCI7IC8vY2FzdCBhcyBzdHJpbmcgdG8gYXZvaWQgZXJyb3JzXG5cdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBwLCAwLCAwLCBwdCwgLTEsIHRyYW5zZm9ybU9yaWdpblN0cmluZyk7XG5cdFx0XHRcdFx0cHQuYiA9IHN0eWxlW3BdO1xuXHRcdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0XHRpZiAoX3N1cHBvcnRzM0QpIHtcblx0XHRcdFx0XHRcdGNvcHkgPSBtMS56T3JpZ2luO1xuXHRcdFx0XHRcdFx0b3JpZyA9IG9yaWcuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdFx0bTEuek9yaWdpbiA9ICgob3JpZy5sZW5ndGggPiAyICYmICEoY29weSAhPT0gMCAmJiBvcmlnWzJdID09PSBcIjBweFwiKSkgPyBwYXJzZUZsb2F0KG9yaWdbMl0pIDogY29weSkgfHwgMDsgLy9TYWZhcmkgZG9lc24ndCBoYW5kbGUgdGhlIHogcGFydCBvZiB0cmFuc2Zvcm1PcmlnaW4gY29ycmVjdGx5LCBzbyB3ZSdsbCBtYW51YWxseSBoYW5kbGUgaXQgaW4gdGhlIF9zZXQzRFRyYW5zZm9ybVJhdGlvKCkgbWV0aG9kLlxuXHRcdFx0XHRcdFx0cHQueHMwID0gcHQuZSA9IG9yaWdbMF0gKyBcIiBcIiArIChvcmlnWzFdIHx8IFwiNTAlXCIpICsgXCIgMHB4XCI7IC8vd2UgbXVzdCBkZWZpbmUgYSB6IHZhbHVlIG9mIDBweCBzcGVjaWZpY2FsbHkgb3RoZXJ3aXNlIGlPUyA1IFNhZmFyaSB3aWxsIHN0aWNrIHdpdGggdGhlIG9sZCBvbmUgKGlmIG9uZSB3YXMgZGVmaW5lZCkhXG5cdFx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4obTEsIFwiek9yaWdpblwiLCAwLCAwLCBwdCwgLTEsIHB0Lm4pOyAvL3dlIG11c3QgY3JlYXRlIGEgQ1NTUHJvcFR3ZWVuIGZvciB0aGUgX2dzVHJhbnNmb3JtLnpPcmlnaW4gc28gdGhhdCBpdCBnZXRzIHJlc2V0IHByb3Blcmx5IGF0IHRoZSBiZWdpbm5pbmcgaWYgdGhlIHR3ZWVuIHJ1bnMgYmFja3dhcmQgKGFzIG9wcG9zZWQgdG8ganVzdCBzZXR0aW5nIG0xLnpPcmlnaW4gaGVyZSlcblx0XHRcdFx0XHRcdHB0LmIgPSBjb3B5O1xuXHRcdFx0XHRcdFx0cHQueHMwID0gcHQuZSA9IG0xLnpPcmlnaW47XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnhzMCA9IHB0LmUgPSBvcmlnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vZm9yIG9sZGVyIHZlcnNpb25zIG9mIElFICg2LTgpLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNhbGN1bGF0ZSB0aGluZ3MgaW5zaWRlIHRoZSBzZXRSYXRpbygpIGZ1bmN0aW9uLiBXZSByZWNvcmQgb3JpZ2luIHggYW5kIHkgKG94IGFuZCBveSkgYW5kIHdoZXRoZXIgb3Igbm90IHRoZSB2YWx1ZXMgYXJlIHBlcmNlbnRhZ2VzIChveHAgYW5kIG95cCkuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3BhcnNlUG9zaXRpb24ob3JpZyArIFwiXCIsIG0xKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc0NoYW5nZSkge1xuXHRcdFx0XHRjc3NwLl90cmFuc2Zvcm1UeXBlID0gKCEobTEuc3ZnICYmIF91c2VTVkdUcmFuc2Zvcm1BdHRyKSAmJiAoaGFzM0QgfHwgdGhpcy5fdHJhbnNmb3JtVHlwZSA9PT0gMykpID8gMyA6IDI7IC8vcXVpY2tlciB0aGFuIGNhbGxpbmcgY3NzcC5fZW5hYmxlVHJhbnNmb3JtcygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH0sIHByZWZpeDp0cnVlfSk7XG5cblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3hTaGFkb3dcIiwge2RlZmF1bHRWYWx1ZTpcIjBweCAwcHggMHB4IDBweCAjOTk5XCIsIHByZWZpeDp0cnVlLCBjb2xvcjp0cnVlLCBtdWx0aTp0cnVlLCBrZXl3b3JkOlwiaW5zZXRcIn0pO1xuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyUmFkaXVzXCIsIHtkZWZhdWx0VmFsdWU6XCIwcHhcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdGUgPSB0aGlzLmZvcm1hdChlKTtcblx0XHRcdHZhciBwcm9wcyA9IFtcImJvcmRlclRvcExlZnRSYWRpdXNcIixcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXCJib3JkZXJCb3R0b21SaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiXSxcblx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRlYTEsIGksIGVzMiwgYnMyLCBicywgZXMsIGJuLCBlbiwgdywgaCwgZXNmeCwgYnNmeCwgcmVsLCBobiwgdm4sIGVtO1xuXHRcdFx0dyA9IHBhcnNlRmxvYXQodC5vZmZzZXRXaWR0aCk7XG5cdFx0XHRoID0gcGFyc2VGbG9hdCh0Lm9mZnNldEhlaWdodCk7XG5cdFx0XHRlYTEgPSBlLnNwbGl0KFwiIFwiKTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyAvL2lmIHdlJ3JlIGRlYWxpbmcgd2l0aCBwZXJjZW50YWdlcywgd2UgbXVzdCBjb252ZXJ0IHRoaW5ncyBzZXBhcmF0ZWx5IGZvciB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgYXhpcyFcblx0XHRcdFx0aWYgKHRoaXMucC5pbmRleE9mKFwiYm9yZGVyXCIpKSB7IC8vb2xkZXIgYnJvd3NlcnMgdXNlZCBhIHByZWZpeFxuXHRcdFx0XHRcdHByb3BzW2ldID0gX2NoZWNrUHJvcFByZWZpeChwcm9wc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnMgPSBiczIgPSBfZ2V0U3R5bGUodCwgcHJvcHNbaV0sIF9jcywgZmFsc2UsIFwiMHB4XCIpO1xuXHRcdFx0XHRpZiAoYnMuaW5kZXhPZihcIiBcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0YnMyID0gYnMuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGJzID0gYnMyWzBdO1xuXHRcdFx0XHRcdGJzMiA9IGJzMlsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlcyA9IGVzMiA9IGVhMVtpXTtcblx0XHRcdFx0Ym4gPSBwYXJzZUZsb2F0KGJzKTtcblx0XHRcdFx0YnNmeCA9IGJzLnN1YnN0cigoYm4gKyBcIlwiKS5sZW5ndGgpO1xuXHRcdFx0XHRyZWwgPSAoZXMuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRlbiA9IHBhcnNlSW50KGVzLmNoYXJBdCgwKStcIjFcIiwgMTApO1xuXHRcdFx0XHRcdGVzID0gZXMuc3Vic3RyKDIpO1xuXHRcdFx0XHRcdGVuICo9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdGVzZnggPSBlcy5zdWJzdHIoKGVuICsgXCJcIikubGVuZ3RoIC0gKGVuIDwgMCA/IDEgOiAwKSkgfHwgXCJcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbiA9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdGVzZnggPSBlcy5zdWJzdHIoKGVuICsgXCJcIikubGVuZ3RoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZXNmeCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdGVzZnggPSBfc3VmZml4TWFwW3BdIHx8IGJzZng7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVzZnggIT09IGJzZngpIHtcblx0XHRcdFx0XHRobiA9IF9jb252ZXJ0VG9QaXhlbHModCwgXCJib3JkZXJMZWZ0XCIsIGJuLCBic2Z4KTsgLy9ob3Jpem9udGFsIG51bWJlciAod2UgdXNlIGEgYm9ndXMgXCJib3JkZXJMZWZ0XCIgcHJvcGVydHkganVzdCBiZWNhdXNlIHRoZSBfY29udmVydFRvUGl4ZWxzKCkgbWV0aG9kIHNlYXJjaGVzIGZvciB0aGUga2V5d29yZHMgXCJMZWZ0XCIsIFwiUmlnaHRcIiwgXCJUb3BcIiwgYW5kIFwiQm90dG9tXCIgdG8gZGV0ZXJtaW5lIG9mIGl0J3MgYSBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnR5LCBhbmQgd2UgbmVlZCBcImJvcmRlclwiIGluIHRoZSBuYW1lIHNvIHRoYXQgaXQga25vd3MgaXQgc2hvdWxkIG1lYXN1cmUgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQgaXRzZWxmLCBub3QgaXRzIHBhcmVudC5cblx0XHRcdFx0XHR2biA9IF9jb252ZXJ0VG9QaXhlbHModCwgXCJib3JkZXJUb3BcIiwgYm4sIGJzZngpOyAvL3ZlcnRpY2FsIG51bWJlclxuXHRcdFx0XHRcdGlmIChlc2Z4ID09PSBcIiVcIikge1xuXHRcdFx0XHRcdFx0YnMgPSAoaG4gLyB3ICogMTAwKSArIFwiJVwiO1xuXHRcdFx0XHRcdFx0YnMyID0gKHZuIC8gaCAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVzZnggPT09IFwiZW1cIikge1xuXHRcdFx0XHRcdFx0ZW0gPSBfY29udmVydFRvUGl4ZWxzKHQsIFwiYm9yZGVyTGVmdFwiLCAxLCBcImVtXCIpO1xuXHRcdFx0XHRcdFx0YnMgPSAoaG4gLyBlbSkgKyBcImVtXCI7XG5cdFx0XHRcdFx0XHRiczIgPSAodm4gLyBlbSkgKyBcImVtXCI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJzID0gaG4gKyBcInB4XCI7XG5cdFx0XHRcdFx0XHRiczIgPSB2biArIFwicHhcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdFx0ZXMgPSAocGFyc2VGbG9hdChicykgKyBlbikgKyBlc2Z4O1xuXHRcdFx0XHRcdFx0ZXMyID0gKHBhcnNlRmxvYXQoYnMyKSArIGVuKSArIGVzZng7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gX3BhcnNlQ29tcGxleChzdHlsZSwgcHJvcHNbaV0sIGJzICsgXCIgXCIgKyBiczIsIGVzICsgXCIgXCIgKyBlczIsIGZhbHNlLCBcIjBweFwiLCBwdCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fSwgcHJlZml4OnRydWUsIGZvcm1hdHRlcjpfZ2V0Rm9ybWF0dGVyKFwiMHB4IDBweCAwcHggMHB4XCIsIGZhbHNlLCB0cnVlKX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJvcmRlckJvdHRvbUxlZnRSYWRpdXMsYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMsYm9yZGVyVG9wTGVmdFJhZGl1cyxib3JkZXJUb3BSaWdodFJhZGl1c1wiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4XCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHRyZXR1cm4gX3BhcnNlQ29tcGxleCh0LnN0eWxlLCBwLCB0aGlzLmZvcm1hdChfZ2V0U3R5bGUodCwgcCwgX2NzLCBmYWxzZSwgXCIwcHggMHB4XCIpKSwgdGhpcy5mb3JtYXQoZSksIGZhbHNlLCBcIjBweFwiLCBwdCk7XG5cdFx0fSwgcHJlZml4OnRydWUsIGZvcm1hdHRlcjpfZ2V0Rm9ybWF0dGVyKFwiMHB4IDBweFwiLCBmYWxzZSwgdHJ1ZSl9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiYWNrZ3JvdW5kUG9zaXRpb25cIiwge2RlZmF1bHRWYWx1ZTpcIjAgMFwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0dmFyIGJwID0gXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsXG5cdFx0XHRcdGNzID0gKF9jcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0LCBudWxsKSksXG5cdFx0XHRcdGJzID0gdGhpcy5mb3JtYXQoICgoY3MpID8gX2llVmVycyA/IGNzLmdldFByb3BlcnR5VmFsdWUoYnAgKyBcIi14XCIpICsgXCIgXCIgKyBjcy5nZXRQcm9wZXJ0eVZhbHVlKGJwICsgXCIteVwiKSA6IGNzLmdldFByb3BlcnR5VmFsdWUoYnApIDogdC5jdXJyZW50U3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWCArIFwiIFwiICsgdC5jdXJyZW50U3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWSkgfHwgXCIwIDBcIiksIC8vSW50ZXJuZXQgRXhwbG9yZXIgZG9lc24ndCByZXBvcnQgYmFja2dyb3VuZC1wb3NpdGlvbiBjb3JyZWN0bHkgLSB3ZSBtdXN0IHF1ZXJ5IGJhY2tncm91bmQtcG9zaXRpb24teCBhbmQgYmFja2dyb3VuZC1wb3NpdGlvbi15IGFuZCBjb21iaW5lIHRoZW0gKGV2ZW4gaW4gSUUxMCkuIEJlZm9yZSBJRTksIHdlIG11c3QgZG8gdGhlIHNhbWUgd2l0aCB0aGUgY3VycmVudFN0eWxlIG9iamVjdCBhbmQgdXNlIGNhbWVsQ2FzZVxuXHRcdFx0XHRlcyA9IHRoaXMuZm9ybWF0KGUpLFxuXHRcdFx0XHRiYSwgZWEsIGksIHBjdCwgb3ZlcmxhcCwgc3JjO1xuXHRcdFx0aWYgKChicy5pbmRleE9mKFwiJVwiKSAhPT0gLTEpICE9PSAoZXMuaW5kZXhPZihcIiVcIikgIT09IC0xKSAmJiBlcy5zcGxpdChcIixcIikubGVuZ3RoIDwgMikge1xuXHRcdFx0XHRzcmMgPSBfZ2V0U3R5bGUodCwgXCJiYWNrZ3JvdW5kSW1hZ2VcIikucmVwbGFjZShfdXJsRXhwLCBcIlwiKTtcblx0XHRcdFx0aWYgKHNyYyAmJiBzcmMgIT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0YmEgPSBicy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0ZWEgPSBlcy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0X3RlbXBJbWcuc2V0QXR0cmlidXRlKFwic3JjXCIsIHNyYyk7IC8vc2V0IHRoZSB0ZW1wIElNRydzIHNyYyB0byB0aGUgYmFja2dyb3VuZC1pbWFnZSBzbyB0aGF0IHdlIGNhbiBtZWFzdXJlIGl0cyB3aWR0aC9oZWlnaHRcblx0XHRcdFx0XHRpID0gMjtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGJzID0gYmFbaV07XG5cdFx0XHRcdFx0XHRwY3QgPSAoYnMuaW5kZXhPZihcIiVcIikgIT09IC0xKTtcblx0XHRcdFx0XHRcdGlmIChwY3QgIT09IChlYVtpXS5pbmRleE9mKFwiJVwiKSAhPT0gLTEpKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJsYXAgPSAoaSA9PT0gMCkgPyB0Lm9mZnNldFdpZHRoIC0gX3RlbXBJbWcud2lkdGggOiB0Lm9mZnNldEhlaWdodCAtIF90ZW1wSW1nLmhlaWdodDtcblx0XHRcdFx0XHRcdFx0YmFbaV0gPSBwY3QgPyAocGFyc2VGbG9hdChicykgLyAxMDAgKiBvdmVybGFwKSArIFwicHhcIiA6IChwYXJzZUZsb2F0KGJzKSAvIG92ZXJsYXAgKiAxMDApICsgXCIlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJzID0gYmEuam9pbihcIiBcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLCBicywgZXMsIHB0LCBwbHVnaW4pO1xuXHRcdH0sIGZvcm1hdHRlcjpfcGFyc2VQb3NpdGlvbn0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJhY2tncm91bmRTaXplXCIsIHtkZWZhdWx0VmFsdWU6XCIwIDBcIiwgZm9ybWF0dGVyOl9wYXJzZVBvc2l0aW9ufSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwicGVyc3BlY3RpdmVcIiwge2RlZmF1bHRWYWx1ZTpcIjBweFwiLCBwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInBlcnNwZWN0aXZlT3JpZ2luXCIsIHtkZWZhdWx0VmFsdWU6XCI1MCUgNTAlXCIsIHByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwidHJhbnNmb3JtU3R5bGVcIiwge3ByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmFja2ZhY2VWaXNpYmlsaXR5XCIsIHtwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInVzZXJTZWxlY3RcIiwge3ByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwibWFyZ2luXCIsIHtwYXJzZXI6X2dldEVkZ2VQYXJzZXIoXCJtYXJnaW5Ub3AsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLG1hcmdpbkxlZnRcIil9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJwYWRkaW5nXCIsIHtwYXJzZXI6X2dldEVkZ2VQYXJzZXIoXCJwYWRkaW5nVG9wLHBhZGRpbmdSaWdodCxwYWRkaW5nQm90dG9tLHBhZGRpbmdMZWZ0XCIpfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiY2xpcFwiLCB7ZGVmYXVsdFZhbHVlOlwicmVjdCgwcHgsMHB4LDBweCwwcHgpXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKXtcblx0XHRcdHZhciBiLCBjcywgZGVsaW07XG5cdFx0XHRpZiAoX2llVmVycyA8IDkpIHsgLy9JRTggYW5kIGVhcmxpZXIgZG9uJ3QgcmVwb3J0IGEgXCJjbGlwXCIgdmFsdWUgaW4gdGhlIGN1cnJlbnRTdHlsZSAtIGluc3RlYWQsIHRoZSB2YWx1ZXMgYXJlIHNwbGl0IGFwYXJ0IGludG8gY2xpcFRvcCwgY2xpcFJpZ2h0LCBjbGlwQm90dG9tLCBhbmQgY2xpcExlZnQuIEFsc28sIGluIElFNyBhbmQgZWFybGllciwgdGhlIHZhbHVlcyBpbnNpZGUgcmVjdCgpIGFyZSBzcGFjZS1kZWxpbWl0ZWQsIG5vdCBjb21tYS1kZWxpbWl0ZWQuXG5cdFx0XHRcdGNzID0gdC5jdXJyZW50U3R5bGU7XG5cdFx0XHRcdGRlbGltID0gX2llVmVycyA8IDggPyBcIiBcIiA6IFwiLFwiO1xuXHRcdFx0XHRiID0gXCJyZWN0KFwiICsgY3MuY2xpcFRvcCArIGRlbGltICsgY3MuY2xpcFJpZ2h0ICsgZGVsaW0gKyBjcy5jbGlwQm90dG9tICsgZGVsaW0gKyBjcy5jbGlwTGVmdCArIFwiKVwiO1xuXHRcdFx0XHRlID0gdGhpcy5mb3JtYXQoZSkuc3BsaXQoXCIsXCIpLmpvaW4oZGVsaW0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YiA9IHRoaXMuZm9ybWF0KF9nZXRTdHlsZSh0LCB0aGlzLnAsIF9jcywgZmFsc2UsIHRoaXMuZGZsdCkpO1xuXHRcdFx0XHRlID0gdGhpcy5mb3JtYXQoZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgYiwgZSwgcHQsIHBsdWdpbik7XG5cdFx0fX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInRleHRTaGFkb3dcIiwge2RlZmF1bHRWYWx1ZTpcIjBweCAwcHggMHB4ICM5OTlcIiwgY29sb3I6dHJ1ZSwgbXVsdGk6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImF1dG9Sb3VuZCxzdHJpY3RVbml0c1wiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0KSB7cmV0dXJuIHB0O319KTsgLy9qdXN0IHNvIHRoYXQgd2UgY2FuIGlnbm9yZSB0aGVzZSBwcm9wZXJ0aWVzIChub3QgdHdlZW4gdGhlbSlcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3JkZXJcIiwge2RlZmF1bHRWYWx1ZTpcIjBweCBzb2xpZCAjMDAwXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLCB0aGlzLmZvcm1hdChfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BXaWR0aFwiLCBfY3MsIGZhbHNlLCBcIjBweFwiKSArIFwiIFwiICsgX2dldFN0eWxlKHQsIFwiYm9yZGVyVG9wU3R5bGVcIiwgX2NzLCBmYWxzZSwgXCJzb2xpZFwiKSArIFwiIFwiICsgX2dldFN0eWxlKHQsIFwiYm9yZGVyVG9wQ29sb3JcIiwgX2NzLCBmYWxzZSwgXCIjMDAwXCIpKSwgdGhpcy5mb3JtYXQoZSksIHB0LCBwbHVnaW4pO1xuXHRcdFx0fSwgY29sb3I6dHJ1ZSwgZm9ybWF0dGVyOmZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIGEgPSB2LnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0cmV0dXJuIGFbMF0gKyBcIiBcIiArIChhWzFdIHx8IFwic29saWRcIikgKyBcIiBcIiArICh2Lm1hdGNoKF9jb2xvckV4cCkgfHwgW1wiIzAwMFwiXSlbMF07XG5cdFx0XHR9fSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyV2lkdGhcIiwge3BhcnNlcjpfZ2V0RWRnZVBhcnNlcihcImJvcmRlclRvcFdpZHRoLGJvcmRlclJpZ2h0V2lkdGgsYm9yZGVyQm90dG9tV2lkdGgsYm9yZGVyTGVmdFdpZHRoXCIpfSk7IC8vRmlyZWZveCBkb2Vzbid0IHBpY2sgdXAgb24gYm9yZGVyV2lkdGggc2V0IGluIHN0eWxlIHNoZWV0cyAob25seSBpbmxpbmUpLlxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImZsb2F0LGNzc0Zsb2F0LHN0eWxlRmxvYXRcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgcyA9IHQuc3R5bGUsXG5cdFx0XHRcdHByb3AgPSAoXCJjc3NGbG9hdFwiIGluIHMpID8gXCJjc3NGbG9hdFwiIDogXCJzdHlsZUZsb2F0XCI7XG5cdFx0XHRyZXR1cm4gbmV3IENTU1Byb3BUd2VlbihzLCBwcm9wLCAwLCAwLCBwdCwgLTEsIHAsIGZhbHNlLCAwLCBzW3Byb3BdLCBlKTtcblx0XHR9fSk7XG5cblx0XHQvL29wYWNpdHktcmVsYXRlZFxuXHRcdHZhciBfc2V0SUVPcGFjaXR5UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy50LCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHByb3BlcnR5XG5cdFx0XHRcdFx0ZmlsdGVycyA9IHQuZmlsdGVyIHx8IF9nZXRTdHlsZSh0aGlzLmRhdGEsIFwiZmlsdGVyXCIpIHx8IFwiXCIsXG5cdFx0XHRcdFx0dmFsID0gKHRoaXMucyArIHRoaXMuYyAqIHYpIHwgMCxcblx0XHRcdFx0XHRza2lwO1xuXHRcdFx0XHRpZiAodmFsID09PSAxMDApIHsgLy9mb3Igb2xkZXIgdmVyc2lvbnMgb2YgSUUgdGhhdCBuZWVkIHRvIHVzZSBhIGZpbHRlciB0byBhcHBseSBvcGFjaXR5LCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBmaWx0ZXIgaWYgb3BhY2l0eSBoaXRzIDEgaW4gb3JkZXIgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgYnV0IG1ha2Ugc3VyZSB0aGVyZSBpc24ndCBhIHRyYW5zZm9ybSAobWF0cml4KSBvciBncmFkaWVudCBpbiB0aGUgZmlsdGVycy5cblx0XHRcdFx0XHRpZiAoZmlsdGVycy5pbmRleE9mKFwiYXRyaXgoXCIpID09PSAtMSAmJiBmaWx0ZXJzLmluZGV4T2YoXCJyYWRpZW50KFwiKSA9PT0gLTEgJiYgZmlsdGVycy5pbmRleE9mKFwib2FkZXIoXCIpID09PSAtMSkge1xuXHRcdFx0XHRcdFx0dC5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG5cdFx0XHRcdFx0XHRza2lwID0gKCFfZ2V0U3R5bGUodGhpcy5kYXRhLCBcImZpbHRlclwiKSk7IC8vaWYgYSBjbGFzcyBpcyBhcHBsaWVkIHRoYXQgaGFzIGFuIGFscGhhIGZpbHRlciwgaXQgd2lsbCB0YWtlIGVmZmVjdCAod2UgZG9uJ3Qgd2FudCB0aGF0KSwgc28gcmUtYXBwbHkgb3VyIGFscGhhIGZpbHRlciBpbiB0aGF0IGNhc2UuIFdlIG11c3QgZmlyc3QgcmVtb3ZlIGl0IGFuZCB0aGVuIGNoZWNrLlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMucmVwbGFjZShfYWxwaGFGaWx0ZXJFeHAsIFwiXCIpO1xuXHRcdFx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2tpcCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLnhuMSkge1xuXHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzID0gZmlsdGVycyB8fCAoXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsICsgXCIpXCIpOyAvL3dvcmtzIGFyb3VuZCBidWcgaW4gSUU3LzggdGhhdCBwcmV2ZW50cyBjaGFuZ2VzIHRvIFwidmlzaWJpbGl0eVwiIGZyb20gYmVpbmcgYXBwbGllZCBwcm9wZXJseSBpZiB0aGUgZmlsdGVyIGlzIGNoYW5nZWQgdG8gYSBkaWZmZXJlbnQgYWxwaGEgb24gdGhlIHNhbWUgZnJhbWUuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChmaWx0ZXJzLmluZGV4T2YoXCJwYWNpdHlcIikgPT09IC0xKSB7IC8vb25seSB1c2VkIGlmIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBzdGFuZGFyZCBvcGFjaXR5IHN0eWxlIHByb3BlcnR5IChJRSA3IGFuZCA4KS4gV2Ugb21pdCB0aGUgXCJPXCIgdG8gYXZvaWQgY2FzZS1zZW5zaXRpdml0eSBpc3N1ZXNcblx0XHRcdFx0XHRcdGlmICh2YWwgIT09IDAgfHwgIXRoaXMueG4xKSB7IC8vYnVncyBpbiBJRTcvOCB3b24ndCByZW5kZXIgdGhlIGZpbHRlciBwcm9wZXJseSBpZiBvcGFjaXR5IGlzIEFEREVEIG9uIHRoZSBzYW1lIGZyYW1lL3JlbmRlciBhcyBcInZpc2liaWxpdHlcIiBjaGFuZ2VzICh0aGlzLnhuMSBpcyAxIGlmIHRoaXMgdHdlZW4gaXMgYW4gXCJhdXRvQWxwaGFcIiB0d2Vlbilcblx0XHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzICsgXCIgYWxwaGEob3BhY2l0eT1cIiArIHZhbCArIFwiKVwiOyAvL3dlIHJvdW5kIHRoZSB2YWx1ZSBiZWNhdXNlIG90aGVyd2lzZSwgYnVncyBpbiBJRTcvOCBjYW4gcHJldmVudCBcInZpc2liaWxpdHlcIiBjaGFuZ2VzIGZyb20gYmVpbmcgYXBwbGllZCBwcm9wZXJseS5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzLnJlcGxhY2UoX29wYWNpdHlFeHAsIFwib3BhY2l0eT1cIiArIHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcIm9wYWNpdHksYWxwaGEsYXV0b0FscGhhXCIsIHtkZWZhdWx0VmFsdWU6XCIxXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgYiA9IHBhcnNlRmxvYXQoX2dldFN0eWxlKHQsIFwib3BhY2l0eVwiLCBfY3MsIGZhbHNlLCBcIjFcIikpLFxuXHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdGlzQXV0b0FscGhhID0gKHAgPT09IFwiYXV0b0FscGhhXCIpO1xuXHRcdFx0aWYgKHR5cGVvZihlKSA9PT0gXCJzdHJpbmdcIiAmJiBlLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcblx0XHRcdFx0ZSA9ICgoZS5jaGFyQXQoMCkgPT09IFwiLVwiKSA/IC0xIDogMSkgKiBwYXJzZUZsb2F0KGUuc3Vic3RyKDIpKSArIGI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNBdXRvQWxwaGEgJiYgYiA9PT0gMSAmJiBfZ2V0U3R5bGUodCwgXCJ2aXNpYmlsaXR5XCIsIF9jcykgPT09IFwiaGlkZGVuXCIgJiYgZSAhPT0gMCkgeyAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuXHRcdFx0XHRiID0gMDtcblx0XHRcdH1cblx0XHRcdGlmIChfc3VwcG9ydHNPcGFjaXR5KSB7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJvcGFjaXR5XCIsIGIsIGUgLSBiLCBwdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIFwib3BhY2l0eVwiLCBiICogMTAwLCAoZSAtIGIpICogMTAwLCBwdCk7XG5cdFx0XHRcdHB0LnhuMSA9IGlzQXV0b0FscGhhID8gMSA6IDA7IC8vd2UgbmVlZCB0byByZWNvcmQgd2hldGhlciBvciBub3QgdGhpcyBpcyBhbiBhdXRvQWxwaGEgc28gdGhhdCBpbiB0aGUgc2V0UmF0aW8oKSwgd2Uga25vdyB0byBkdXBsaWNhdGUgdGhlIHNldHRpbmcgb2YgdGhlIGFscGhhIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFNyBhbmQgSUU4IHRoYXQgcHJldmVudHMgY2hhbmdlcyB0byBcInZpc2liaWxpdHlcIiBmcm9tIHRha2luZyBlZmZlY3QgaWYgdGhlIGZpbHRlciBpcyBjaGFuZ2VkIHRvIGEgZGlmZmVyZW50IGFscGhhKG9wYWNpdHkpIGF0IHRoZSBzYW1lIHRpbWUuIFNldHRpbmcgaXQgdG8gdGhlIFNBTUUgdmFsdWUgZmlyc3QsIHRoZW4gdGhlIG5ldyB2YWx1ZSB3b3JrcyBhcm91bmQgdGhlIElFNy84IGJ1Zy5cblx0XHRcdFx0c3R5bGUuem9vbSA9IDE7IC8vaGVscHMgY29ycmVjdCBhbiBJRSBpc3N1ZS5cblx0XHRcdFx0cHQudHlwZSA9IDI7XG5cdFx0XHRcdHB0LmIgPSBcImFscGhhKG9wYWNpdHk9XCIgKyBwdC5zICsgXCIpXCI7XG5cdFx0XHRcdHB0LmUgPSBcImFscGhhKG9wYWNpdHk9XCIgKyAocHQucyArIHB0LmMpICsgXCIpXCI7XG5cdFx0XHRcdHB0LmRhdGEgPSB0O1xuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gX3NldElFT3BhY2l0eVJhdGlvO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXV0b0FscGhhKSB7IC8vd2UgaGF2ZSB0byBjcmVhdGUgdGhlIFwidmlzaWJpbGl0eVwiIFByb3BUd2VlbiBhZnRlciB0aGUgb3BhY2l0eSBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0IHNvIHRoYXQgdGhleSBydW4gaW4gdGhlIG9yZGVyIHRoYXQgd29ya3MgcHJvcGVybHkgaW4gSUU4IGFuZCBlYXJsaWVyXG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJ2aXNpYmlsaXR5XCIsIDAsIDAsIHB0LCAtMSwgbnVsbCwgZmFsc2UsIDAsICgoYiAhPT0gMCkgPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIpLCAoKGUgPT09IDApID8gXCJoaWRkZW5cIiA6IFwiaW5oZXJpdFwiKSk7XG5cdFx0XHRcdHB0LnhzMCA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHB0Lm4pO1xuXHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH19KTtcblxuXG5cdFx0dmFyIF9yZW1vdmVQcm9wID0gZnVuY3Rpb24ocywgcCkge1xuXHRcdFx0XHRpZiAocCkge1xuXHRcdFx0XHRcdGlmIChzLnJlbW92ZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRpZiAocC5zdWJzdHIoMCwyKSA9PT0gXCJtc1wiIHx8IHAuc3Vic3RyKDAsNikgPT09IFwid2Via2l0XCIpIHsgLy9NaWNyb3NvZnQgYW5kIHNvbWUgV2Via2l0IGJyb3dzZXJzIGRvbid0IGNvbmZvcm0gdG8gdGhlIHN0YW5kYXJkIG9mIGNhcGl0YWxpemluZyB0aGUgZmlyc3QgcHJlZml4IGNoYXJhY3Rlciwgc28gd2UgYWRqdXN0IHNvIHRoYXQgd2hlbiB3ZSBwcmVmaXggdGhlIGNhcHMgd2l0aCBhIGRhc2gsIGl0J3MgY29ycmVjdCAob3RoZXJ3aXNlIGl0J2QgYmUgXCJtcy10cmFuc2Zvcm1cIiBpbnN0ZWFkIG9mIFwiLW1zLXRyYW5zZm9ybVwiIGZvciBJRTksIGZvciBleGFtcGxlKVxuXHRcdFx0XHRcdFx0XHRwID0gXCItXCIgKyBwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cy5yZW1vdmVQcm9wZXJ0eShwLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7IC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHVzZSBcInJlbW92ZUF0dHJpYnV0ZSgpXCIgaW5zdGVhZCBvZiBcInJlbW92ZVByb3BlcnR5KClcIlxuXHRcdFx0XHRcdFx0cy5yZW1vdmVBdHRyaWJ1dGUocCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3NldENsYXNzTmFtZVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR0aGlzLnQuX2dzQ2xhc3NQVCA9IHRoaXM7XG5cdFx0XHRcdGlmICh2ID09PSAxIHx8IHYgPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgKHYgPT09IDApID8gdGhpcy5iIDogdGhpcy5lKTtcblx0XHRcdFx0XHR2YXIgbXB0ID0gdGhpcy5kYXRhLCAvL2ZpcnN0IE1pbmlQcm9wVHdlZW5cblx0XHRcdFx0XHRcdHMgPSB0aGlzLnQuc3R5bGU7XG5cdFx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdFx0aWYgKCFtcHQudikge1xuXHRcdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBtcHQucCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzW21wdC5wXSA9IG1wdC52O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodiA9PT0gMSAmJiB0aGlzLnQuX2dzQ2xhc3NQVCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dGhpcy50Ll9nc0NsYXNzUFQgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgIT09IHRoaXMuZSkge1xuXHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsYXNzTmFtZVwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdHZhciBiID0gdC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiLCAvL2Rvbid0IHVzZSB0LmNsYXNzTmFtZSBiZWNhdXNlIGl0IGRvZXNuJ3Qgd29yayBjb25zaXN0ZW50bHkgb24gU1ZHIGVsZW1lbnRzOyBnZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSBhbmQgc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdmFsdWVcIikgaXMgbW9yZSByZWxpYWJsZS5cblx0XHRcdFx0Y3NzVGV4dCA9IHQuc3R5bGUuY3NzVGV4dCxcblx0XHRcdFx0ZGlmRGF0YSwgYnMsIGNucHQsIGNucHRMb29rdXAsIG1wdDtcblx0XHRcdHB0ID0gY3NzcC5fY2xhc3NOYW1lUFQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyKTtcblx0XHRcdHB0LnNldFJhdGlvID0gX3NldENsYXNzTmFtZVJhdGlvO1xuXHRcdFx0cHQucHIgPSAtMTE7XG5cdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0cHQuYiA9IGI7XG5cdFx0XHRicyA9IF9nZXRBbGxTdHlsZXModCwgX2NzKTtcblx0XHRcdC8vaWYgdGhlcmUncyBhIGNsYXNzTmFtZSB0d2VlbiBhbHJlYWR5IG9wZXJhdGluZyBvbiB0aGUgdGFyZ2V0LCBmb3JjZSBpdCB0byBpdHMgZW5kIHNvIHRoYXQgdGhlIG5lY2Vzc2FyeSBpbmxpbmUgc3R5bGVzIGFyZSByZW1vdmVkIGFuZCB0aGUgY2xhc3MgbmFtZSBpcyBhcHBsaWVkIGJlZm9yZSB3ZSBkZXRlcm1pbmUgdGhlIGVuZCBzdGF0ZSAod2UgZG9uJ3Qgd2FudCBpbmxpbmUgc3R5bGVzIGludGVyZmVyaW5nIHRoYXQgd2VyZSB0aGVyZSBqdXN0IGZvciBjbGFzcy1zcGVjaWZpYyB2YWx1ZXMpXG5cdFx0XHRjbnB0ID0gdC5fZ3NDbGFzc1BUO1xuXHRcdFx0aWYgKGNucHQpIHtcblx0XHRcdFx0Y25wdExvb2t1cCA9IHt9O1xuXHRcdFx0XHRtcHQgPSBjbnB0LmRhdGE7IC8vZmlyc3QgTWluaVByb3BUd2VlbiB3aGljaCBzdG9yZXMgdGhlIGlubGluZSBzdHlsZXMgLSB3ZSBuZWVkIHRvIGZvcmNlIHRoZXNlIHNvIHRoYXQgdGhlIGlubGluZSBzdHlsZXMgZG9uJ3QgY29udGFtaW5hdGUgdGhpbmdzLiBPdGhlcndpc2UsIHRoZXJlJ3MgYSBzbWFsbCBjaGFuY2UgdGhhdCBhIHR3ZWVuIGNvdWxkIHN0YXJ0IGFuZCB0aGUgaW5saW5lIHZhbHVlcyBtYXRjaCB0aGUgZGVzdGluYXRpb24gdmFsdWVzIGFuZCB0aGV5IG5ldmVyIGdldCBjbGVhbmVkLlxuXHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0Y25wdExvb2t1cFttcHQucF0gPSAxO1xuXHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbnB0LnNldFJhdGlvKDEpO1xuXHRcdFx0fVxuXHRcdFx0dC5fZ3NDbGFzc1BUID0gcHQ7XG5cdFx0XHRwdC5lID0gKGUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlIDogYi5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoPzpcXFxcc3xeKVwiICsgZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGUuY2hhckF0KDApID09PSBcIitcIikgPyBcIiBcIiArIGUuc3Vic3RyKDIpIDogXCJcIik7XG5cdFx0XHR0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHB0LmUpO1xuXHRcdFx0ZGlmRGF0YSA9IF9jc3NEaWYodCwgYnMsIF9nZXRBbGxTdHlsZXModCksIHZhcnMsIGNucHRMb29rdXApO1xuXHRcdFx0dC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBiKTtcblx0XHRcdHB0LmRhdGEgPSBkaWZEYXRhLmZpcnN0TVBUO1xuXHRcdFx0dC5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDsgLy93ZSByZWNvcmRlZCBjc3NUZXh0IGJlZm9yZSB3ZSBzd2FwcGVkIGNsYXNzZXMgYW5kIHJhbiBfZ2V0QWxsU3R5bGVzKCkgYmVjYXVzZSBpbiBjYXNlcyB3aGVuIGEgY2xhc3NOYW1lIHR3ZWVuIGlzIG92ZXJ3cml0dGVuLCB3ZSByZW1vdmUgYWxsIHRoZSByZWxhdGVkIHR3ZWVuaW5nIHByb3BlcnRpZXMgZnJvbSB0aGF0IGNsYXNzIGNoYW5nZSAob3RoZXJ3aXNlIGNsYXNzLXNwZWNpZmljIHN0dWZmIGNhbid0IG92ZXJyaWRlIHByb3BlcnRpZXMgd2UndmUgZGlyZWN0bHkgc2V0IG9uIHRoZSB0YXJnZXQncyBzdHlsZSBvYmplY3QgZHVlIHRvIHNwZWNpZmljaXR5KS5cblx0XHRcdHB0ID0gcHQueGZpcnN0ID0gY3NzcC5wYXJzZSh0LCBkaWZEYXRhLmRpZnMsIHB0LCBwbHVnaW4pOyAvL3dlIHJlY29yZCB0aGUgQ1NTUHJvcFR3ZWVuIGFzIHRoZSB4Zmlyc3Qgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIG92ZXJ3cml0aW5nIHByb3BlcnRseSAoaWYgXCJjbGFzc05hbWVcIiBnZXRzIG92ZXJ3cml0dGVuLCB3ZSBtdXN0IGtpbGwgYWxsIHRoZSBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2xhc3NOYW1lIHBhcnQgb2YgdGhlIHR3ZWVuLCBzbyB3ZSBjYW4gbG9vcCB0aHJvdWdoIGZyb20geGZpcnN0IHRvIHRoZSBwdCBpdHNlbGYpXG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fX0pO1xuXG5cblx0XHR2YXIgX3NldENsZWFyUHJvcHNSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdGlmICh2ID09PSAxIHx8IHYgPT09IDApIGlmICh0aGlzLmRhdGEuX3RvdGFsVGltZSA9PT0gdGhpcy5kYXRhLl90b3RhbER1cmF0aW9uICYmIHRoaXMuZGF0YS5kYXRhICE9PSBcImlzRnJvbVN0YXJ0XCIpIHsgLy90aGlzLmRhdGEgcmVmZXJzIHRvIHRoZSB0d2Vlbi4gT25seSBjbGVhciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgbWFrZSB0aGUgcmF0aW8gZ28gZnJvbSAxIHRvIDAsIHNvIHdlIGNhbid0IGp1c3QgY2hlY2sgdGhhdCBhbmQgaWYgdGhlIHR3ZWVuIGlzIHRoZSB6ZXJvLWR1cmF0aW9uIG9uZSB0aGF0J3MgY3JlYXRlZCBpbnRlcm5hbGx5IHRvIHJlbmRlciB0aGUgc3RhcnRpbmcgdmFsdWVzIGluIGEgZnJvbSgpIHR3ZWVuLCBpZ25vcmUgdGhhdCBiZWNhdXNlIG90aGVyd2lzZSwgZm9yIGV4YW1wbGUsIGZyb20oLi4ue2hlaWdodDoxMDAsIGNsZWFyUHJvcHM6XCJoZWlnaHRcIiwgZGVsYXk6MX0pIHdvdWxkIHdpcGUgdGhlIGhlaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiBhbmQgYWZ0ZXIgMSBzZWNvbmQsIGl0J2Qga2ljayBiYWNrIGluKS5cblx0XHRcdFx0dmFyIHMgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0dHJhbnNmb3JtUGFyc2UgPSBfc3BlY2lhbFByb3BzLnRyYW5zZm9ybS5wYXJzZSxcblx0XHRcdFx0XHRhLCBwLCBpLCBjbGVhclRyYW5zZm9ybSwgdHJhbnNmb3JtO1xuXHRcdFx0XHRpZiAodGhpcy5lID09PSBcImFsbFwiKSB7XG5cdFx0XHRcdFx0cy5jc3NUZXh0ID0gXCJcIjtcblx0XHRcdFx0XHRjbGVhclRyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YSA9IHRoaXMuZS5zcGxpdChcIiBcIikuam9pbihcIlwiKS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cCA9IGFbaV07XG5cdFx0XHRcdFx0XHRpZiAoX3NwZWNpYWxQcm9wc1twXSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoX3NwZWNpYWxQcm9wc1twXS5wYXJzZSA9PT0gdHJhbnNmb3JtUGFyc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRjbGVhclRyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IChwID09PSBcInRyYW5zZm9ybU9yaWdpblwiKSA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3NwZWNpYWxQcm9wc1twXS5wOyAvL2Vuc3VyZXMgdGhhdCBzcGVjaWFsIHByb3BlcnRpZXMgdXNlIHRoZSBwcm9wZXIgYnJvd3Nlci1zcGVjaWZpYyBwcm9wZXJ0eSBuYW1lLCBsaWtlIFwic2NhbGVYXCIgbWlnaHQgYmUgXCItd2Via2l0LXRyYW5zZm9ybVwiIG9yIFwiYm94U2hhZG93XCIgbWlnaHQgYmUgXCItbW96LWJveC1zaGFkb3dcIlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNsZWFyVHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0X3JlbW92ZVByb3AocywgX3RyYW5zZm9ybVByb3ApO1xuXHRcdFx0XHRcdHRyYW5zZm9ybSA9IHRoaXMudC5fZ3NUcmFuc2Zvcm07XG5cdFx0XHRcdFx0aWYgKHRyYW5zZm9ybSkge1xuXHRcdFx0XHRcdFx0aWYgKHRyYW5zZm9ybS5zdmcpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTtcblx0XHRcdFx0XHRcdFx0dGhpcy50LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnQuX2dzVHJhbnNmb3JtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJjbGVhclByb3BzXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQpIHtcblx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgMik7XG5cdFx0XHRwdC5zZXRSYXRpbyA9IF9zZXRDbGVhclByb3BzUmF0aW87XG5cdFx0XHRwdC5lID0gZTtcblx0XHRcdHB0LnByID0gLTEwO1xuXHRcdFx0cHQuZGF0YSA9IGNzc3AuX3R3ZWVuO1xuXHRcdFx0X2hhc1ByaW9yaXR5ID0gdHJ1ZTtcblx0XHRcdHJldHVybiBwdDtcblx0XHR9fSk7XG5cblx0XHRwID0gXCJiZXppZXIsdGhyb3dQcm9wcyxwaHlzaWNzUHJvcHMscGh5c2ljczJEXCIuc3BsaXQoXCIsXCIpO1xuXHRcdGkgPSBwLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRfcmVnaXN0ZXJQbHVnaW5Qcm9wKHBbaV0pO1xuXHRcdH1cblxuXG5cblxuXG5cblxuXG5cdFx0cCA9IENTU1BsdWdpbi5wcm90b3R5cGU7XG5cdFx0cC5fZmlyc3RQVCA9IHAuX2xhc3RQYXJzZWRUcmFuc2Zvcm0gPSBwLl90cmFuc2Zvcm0gPSBudWxsO1xuXG5cdFx0Ly9nZXRzIGNhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBraWNrcyBldmVyeXRoaW5nIG9mZiwgcmVjb3JkaW5nIHN0YXJ0L2VuZCB2YWx1ZXMsIGV0Yy5cblx0XHRwLl9vbkluaXRUd2VlbiA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgdHdlZW4pIHtcblx0XHRcdGlmICghdGFyZ2V0Lm5vZGVUeXBlKSB7IC8vY3NzIGlzIG9ubHkgZm9yIGRvbSBlbGVtZW50c1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHR0aGlzLl90d2VlbiA9IHR3ZWVuO1xuXHRcdFx0dGhpcy5fdmFycyA9IHZhcnM7XG5cdFx0XHRfYXV0b1JvdW5kID0gdmFycy5hdXRvUm91bmQ7XG5cdFx0XHRfaGFzUHJpb3JpdHkgPSBmYWxzZTtcblx0XHRcdF9zdWZmaXhNYXAgPSB2YXJzLnN1ZmZpeE1hcCB8fCBDU1NQbHVnaW4uc3VmZml4TWFwO1xuXHRcdFx0X2NzID0gX2dldENvbXB1dGVkU3R5bGUodGFyZ2V0LCBcIlwiKTtcblx0XHRcdF9vdmVyd3JpdGVQcm9wcyA9IHRoaXMuX292ZXJ3cml0ZVByb3BzO1xuXHRcdFx0dmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuXHRcdFx0XHR2LCBwdCwgcHQyLCBmaXJzdCwgbGFzdCwgbmV4dCwgekluZGV4LCB0cHQsIHRocmVlRDtcblx0XHRcdGlmIChfcmVxU2FmYXJpRml4KSBpZiAoc3R5bGUuekluZGV4ID09PSBcIlwiKSB7XG5cdFx0XHRcdHYgPSBfZ2V0U3R5bGUodGFyZ2V0LCBcInpJbmRleFwiLCBfY3MpO1xuXHRcdFx0XHRpZiAodiA9PT0gXCJhdXRvXCIgfHwgdiA9PT0gXCJcIikge1xuXHRcdFx0XHRcdC8vY29ycmVjdHMgYSBidWcgaW4gW25vbi1BbmRyb2lkXSBTYWZhcmkgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIHJlcGFpbnRpbmcgZWxlbWVudHMgaW4gdGhlaXIgbmV3IHBvc2l0aW9ucyBpZiB0aGV5IGRvbid0IGhhdmUgYSB6SW5kZXggc2V0LiBXZSBhbHNvIGNhbid0IGp1c3QgYXBwbHkgdGhpcyBpbnNpZGUgX3BhcnNlVHJhbnNmb3JtKCkgYmVjYXVzZSBhbnl0aGluZyB0aGF0J3MgbW92ZWQgaW4gYW55IHdheSAobGlrZSB1c2luZyBcImxlZnRcIiBvciBcInRvcFwiIGluc3RlYWQgb2YgdHJhbnNmb3JtcyBsaWtlIFwieFwiIGFuZCBcInlcIikgY2FuIGJlIGFmZmVjdGVkLCBzbyBpdCBpcyBiZXN0IHRvIGVuc3VyZSB0aGF0IGFueXRoaW5nIHRoYXQncyB0d2VlbmluZyBoYXMgYSB6LWluZGV4LiBTZXR0aW5nIFwiV2Via2l0UGVyc3BlY3RpdmVcIiB0byBhIG5vbi16ZXJvIHZhbHVlIHdvcmtlZCB0b28gZXhjZXB0IHRoYXQgb24gaU9TIFNhZmFyaSB0aGluZ3Mgd291bGQgZmxpY2tlciByYW5kb21seS4gUGx1cyB6SW5kZXggaXMgbGVzcyBtZW1vcnktaW50ZW5zaXZlLlxuXHRcdFx0XHRcdHRoaXMuX2FkZExhenlTZXQoc3R5bGUsIFwiekluZGV4XCIsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YodmFycykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zmlyc3QgPSBzdHlsZS5jc3NUZXh0O1xuXHRcdFx0XHR2ID0gX2dldEFsbFN0eWxlcyh0YXJnZXQsIF9jcyk7XG5cdFx0XHRcdHN0eWxlLmNzc1RleHQgPSBmaXJzdCArIFwiO1wiICsgdmFycztcblx0XHRcdFx0diA9IF9jc3NEaWYodGFyZ2V0LCB2LCBfZ2V0QWxsU3R5bGVzKHRhcmdldCkpLmRpZnM7XG5cdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSAmJiBfb3BhY2l0eVZhbEV4cC50ZXN0KHZhcnMpKSB7XG5cdFx0XHRcdFx0di5vcGFjaXR5ID0gcGFyc2VGbG9hdCggUmVnRXhwLiQxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFycyA9IHY7XG5cdFx0XHRcdHN0eWxlLmNzc1RleHQgPSBmaXJzdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhcnMuY2xhc3NOYW1lKSB7IC8vY2xhc3NOYW1lIHR3ZWVucyB3aWxsIGNvbWJpbmUgYW55IGRpZmZlcmVuY2VzIHRoZXkgZmluZCBpbiB0aGUgY3NzIHdpdGggdGhlIHZhcnMgdGhhdCBhcmUgcGFzc2VkIGluLCBzbyB7Y2xhc3NOYW1lOlwibXlDbGFzc1wiLCBzY2FsZTowLjUsIGxlZnQ6MjB9IHdvdWxkIHdvcmsuXG5cdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdCA9IF9zcGVjaWFsUHJvcHMuY2xhc3NOYW1lLnBhcnNlKHRhcmdldCwgdmFycy5jbGFzc05hbWUsIFwiY2xhc3NOYW1lXCIsIHRoaXMsIG51bGwsIG51bGwsIHZhcnMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0ID0gdGhpcy5wYXJzZSh0YXJnZXQsIHZhcnMsIG51bGwpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdHJhbnNmb3JtVHlwZSkge1xuXHRcdFx0XHR0aHJlZUQgPSAodGhpcy5fdHJhbnNmb3JtVHlwZSA9PT0gMyk7XG5cdFx0XHRcdGlmICghX3RyYW5zZm9ybVByb3ApIHtcblx0XHRcdFx0XHRzdHlsZS56b29tID0gMTsgLy9oZWxwcyBjb3JyZWN0IGFuIElFIGlzc3VlLlxuXHRcdFx0XHR9IGVsc2UgaWYgKF9pc1NhZmFyaSkge1xuXHRcdFx0XHRcdF9yZXFTYWZhcmlGaXggPSB0cnVlO1xuXHRcdFx0XHRcdC8vaWYgekluZGV4IGlzbid0IHNldCwgaU9TIFNhZmFyaSBkb2Vzbid0IHJlcGFpbnQgdGhpbmdzIGNvcnJlY3RseSBzb21ldGltZXMgKHNlZW1pbmdseSBhdCByYW5kb20pLlxuXHRcdFx0XHRcdGlmIChzdHlsZS56SW5kZXggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdHpJbmRleCA9IF9nZXRTdHlsZSh0YXJnZXQsIFwiekluZGV4XCIsIF9jcyk7XG5cdFx0XHRcdFx0XHRpZiAoekluZGV4ID09PSBcImF1dG9cIiB8fCB6SW5kZXggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWRkTGF6eVNldChzdHlsZSwgXCJ6SW5kZXhcIiwgMCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vU2V0dGluZyBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgY29ycmVjdHMgMyBidWdzOlxuXHRcdFx0XHRcdC8vIDEpIFtub24tQW5kcm9pZF0gU2FmYXJpIHNraXBzIHJlbmRlcmluZyBjaGFuZ2VzIHRvIFwidG9wXCIgYW5kIFwibGVmdFwiIHRoYXQgYXJlIG1hZGUgb24gdGhlIHNhbWUgZnJhbWUvcmVuZGVyIGFzIGEgdHJhbnNmb3JtIHVwZGF0ZS5cblx0XHRcdFx0XHQvLyAyKSBpT1MgU2FmYXJpIHNvbWV0aW1lcyBuZWdsZWN0cyB0byByZXBhaW50IGVsZW1lbnRzIGluIHRoZWlyIG5ldyBwb3NpdGlvbnMuIFNldHRpbmcgXCJXZWJraXRQZXJzcGVjdGl2ZVwiIHRvIGEgbm9uLXplcm8gdmFsdWUgd29ya2VkIHRvbyBleGNlcHQgdGhhdCBvbiBpT1MgU2FmYXJpIHRoaW5ncyB3b3VsZCBmbGlja2VyIHJhbmRvbWx5LlxuXHRcdFx0XHRcdC8vIDMpIFNhZmFyaSBzb21ldGltZXMgZGlzcGxheWVkIG9kZCBhcnRpZmFjdHMgd2hlbiB0d2VlbmluZyB0aGUgdHJhbnNmb3JtIChvciBXZWJraXRUcmFuc2Zvcm0pIHByb3BlcnR5LCBsaWtlIGdob3N0cyBvZiB0aGUgZWRnZXMgb2YgdGhlIGVsZW1lbnQgcmVtYWluZWQuIERlZmluaXRlbHkgYSBicm93c2VyIGJ1Zy5cblx0XHRcdFx0XHQvL05vdGU6IHdlIGFsbG93IHRoZSB1c2VyIHRvIG92ZXJyaWRlIHRoZSBhdXRvLXNldHRpbmcgYnkgZGVmaW5pbmcgV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IGluIHRoZSB2YXJzIG9mIHRoZSB0d2Vlbi5cblx0XHRcdFx0XHRpZiAoX2lzU2FmYXJpTFQ2KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRMYXp5U2V0KHN0eWxlLCBcIldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eVwiLCB0aGlzLl92YXJzLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSB8fCAodGhyZWVEID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHB0MiA9IHB0O1xuXHRcdFx0XHR3aGlsZSAocHQyICYmIHB0Mi5fbmV4dCkge1xuXHRcdFx0XHRcdHB0MiA9IHB0Mi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHRhcmdldCwgXCJ0cmFuc2Zvcm1cIiwgMCwgMCwgbnVsbCwgMik7XG5cdFx0XHRcdHRoaXMuX2xpbmtDU1NQKHRwdCwgbnVsbCwgcHQyKTtcblx0XHRcdFx0dHB0LnNldFJhdGlvID0gX3RyYW5zZm9ybVByb3AgPyBfc2V0VHJhbnNmb3JtUmF0aW8gOiBfc2V0SUVUcmFuc2Zvcm1SYXRpbztcblx0XHRcdFx0dHB0LmRhdGEgPSB0aGlzLl90cmFuc2Zvcm0gfHwgX2dldFRyYW5zZm9ybSh0YXJnZXQsIF9jcywgdHJ1ZSk7XG5cdFx0XHRcdHRwdC50d2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHR0cHQucHIgPSAtMTsgLy9lbnN1cmVzIHRoYXQgdGhlIHRyYW5zZm9ybXMgZ2V0IGFwcGxpZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQuXG5cdFx0XHRcdF9vdmVyd3JpdGVQcm9wcy5wb3AoKTsgLy93ZSBkb24ndCB3YW50IHRvIGZvcmNlIHRoZSBvdmVyd3JpdGUgb2YgYWxsIFwidHJhbnNmb3JtXCIgdHdlZW5zIG9mIHRoZSB0YXJnZXQgLSB3ZSBvbmx5IGNhcmUgYWJvdXQgaW5kaXZpZHVhbCB0cmFuc2Zvcm0gcHJvcGVydGllcyBsaWtlIHNjYWxlWCwgcm90YXRpb24sIGV0Yy4gVGhlIENTU1Byb3BUd2VlbiBjb25zdHJ1Y3RvciBhdXRvbWF0aWNhbGx5IGFkZHMgdGhlIHByb3BlcnR5IHRvIF9vdmVyd3JpdGVQcm9wcyB3aGljaCBpcyB3aHkgd2UgbmVlZCB0byBwb3AoKSBoZXJlLlxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2hhc1ByaW9yaXR5KSB7XG5cdFx0XHRcdC8vcmVvcmRlcnMgdGhlIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByIChwcmlvcml0eSlcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0bmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdHB0MiA9IGZpcnN0O1xuXHRcdFx0XHRcdHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcblx0XHRcdFx0XHRcdHB0MiA9IHB0Mi5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpKSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9uZXh0ID0gcHQyKSkge1xuXHRcdFx0XHRcdFx0cHQyLl9wcmV2ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxhc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBmaXJzdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblxuXHRcdHAucGFyc2UgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdFx0cCwgc3AsIGJuLCBlbiwgYnMsIGVzLCBic2Z4LCBlc2Z4LCBpc1N0ciwgcmVsO1xuXHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0ZXMgPSB2YXJzW3BdOyAvL2VuZGluZyB2YWx1ZSBzdHJpbmdcblx0XHRcdFx0c3AgPSBfc3BlY2lhbFByb3BzW3BdOyAvL1NwZWNpYWxQcm9wIGxvb2t1cC5cblx0XHRcdFx0aWYgKHNwKSB7XG5cdFx0XHRcdFx0cHQgPSBzcC5wYXJzZSh0YXJnZXQsIGVzLCBwLCB0aGlzLCBwdCwgcGx1Z2luLCB2YXJzKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJzID0gX2dldFN0eWxlKHRhcmdldCwgcCwgX2NzKSArIFwiXCI7XG5cdFx0XHRcdFx0aXNTdHIgPSAodHlwZW9mKGVzKSA9PT0gXCJzdHJpbmdcIik7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFwiY29sb3JcIiB8fCBwID09PSBcImZpbGxcIiB8fCBwID09PSBcInN0cm9rZVwiIHx8IHAuaW5kZXhPZihcIkNvbG9yXCIpICE9PSAtMSB8fCAoaXNTdHIgJiYgX3JnYmhzbEV4cC50ZXN0KGVzKSkpIHsgLy9PcGVyYSB1c2VzIGJhY2tncm91bmQ6IHRvIGRlZmluZSBjb2xvciBzb21ldGltZXMgaW4gYWRkaXRpb24gdG8gYmFja2dyb3VuZENvbG9yOlxuXHRcdFx0XHRcdFx0aWYgKCFpc1N0cikge1xuXHRcdFx0XHRcdFx0XHRlcyA9IF9wYXJzZUNvbG9yKGVzKTtcblx0XHRcdFx0XHRcdFx0ZXMgPSAoKGVzLmxlbmd0aCA+IDMpID8gXCJyZ2JhKFwiIDogXCJyZ2IoXCIpICsgZXMuam9pbihcIixcIikgKyBcIilcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHB0ID0gX3BhcnNlQ29tcGxleChzdHlsZSwgcCwgYnMsIGVzLCB0cnVlLCBcInRyYW5zcGFyZW50XCIsIHB0LCAwLCBwbHVnaW4pO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpc1N0ciAmJiBfY29tcGxleEV4cC50ZXN0KGVzKSkge1xuXHRcdFx0XHRcdFx0cHQgPSBfcGFyc2VDb21wbGV4KHN0eWxlLCBwLCBicywgZXMsIHRydWUsIG51bGwsIHB0LCAwLCBwbHVnaW4pO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJuID0gcGFyc2VGbG9hdChicyk7XG5cdFx0XHRcdFx0XHRic2Z4ID0gKGJuIHx8IGJuID09PSAwKSA/IGJzLnN1YnN0cigoYm4gKyBcIlwiKS5sZW5ndGgpIDogXCJcIjsgLy9yZW1lbWJlciwgYnMgY291bGQgYmUgbm9uLW51bWVyaWMgbGlrZSBcIm5vcm1hbFwiIGZvciBmb250V2VpZ2h0LCBzbyB3ZSBzaG91bGQgZGVmYXVsdCB0byBhIGJsYW5rIHN1ZmZpeCBpbiB0aGF0IGNhc2UuXG5cblx0XHRcdFx0XHRcdGlmIChicyA9PT0gXCJcIiB8fCBicyA9PT0gXCJhdXRvXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHAgPT09IFwid2lkdGhcIiB8fCBwID09PSBcImhlaWdodFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gPSBfZ2V0RGltZW5zaW9uKHRhcmdldCwgcCwgX2NzKTtcblx0XHRcdFx0XHRcdFx0XHRic2Z4ID0gXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwibGVmdFwiIHx8IHAgPT09IFwidG9wXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiA9IF9jYWxjdWxhdGVPZmZzZXQodGFyZ2V0LCBwLCBfY3MpO1xuXHRcdFx0XHRcdFx0XHRcdGJzZnggPSBcInB4XCI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gPSAocCAhPT0gXCJvcGFjaXR5XCIpID8gMCA6IDE7XG5cdFx0XHRcdFx0XHRcdFx0YnNmeCA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmVsID0gKGlzU3RyICYmIGVzLmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdFx0XHRlbiA9IHBhcnNlSW50KGVzLmNoYXJBdCgwKSArIFwiMVwiLCAxMCk7XG5cdFx0XHRcdFx0XHRcdGVzID0gZXMuc3Vic3RyKDIpO1xuXHRcdFx0XHRcdFx0XHRlbiAqPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRcdFx0ZXNmeCA9IGVzLnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbiA9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdFx0XHRlc2Z4ID0gaXNTdHIgPyBlcy5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpIDogXCJcIjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGVzZnggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0ZXNmeCA9IChwIGluIF9zdWZmaXhNYXApID8gX3N1ZmZpeE1hcFtwXSA6IGJzZng7IC8vcG9wdWxhdGUgdGhlIGVuZCBzdWZmaXgsIHByaW9yaXRpemluZyB0aGUgbWFwLCB0aGVuIGlmIG5vbmUgaXMgZm91bmQsIHVzZSB0aGUgYmVnaW5uaW5nIHN1ZmZpeC5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZXMgPSAoZW4gfHwgZW4gPT09IDApID8gKHJlbCA/IGVuICsgYm4gOiBlbikgKyBlc2Z4IDogdmFyc1twXTsgLy9lbnN1cmVzIHRoYXQgYW55ICs9IG9yIC09IHByZWZpeGVzIGFyZSB0YWtlbiBjYXJlIG9mLiBSZWNvcmQgdGhlIGVuZCB2YWx1ZSBiZWZvcmUgbm9ybWFsaXppbmcgdGhlIHN1ZmZpeCBiZWNhdXNlIHdlIGFsd2F5cyB3YW50IHRvIGVuZCB0aGUgdHdlZW4gb24gZXhhY3RseSB3aGF0IHRoZXkgaW50ZW5kZWQgZXZlbiBpZiBpdCBkb2Vzbid0IG1hdGNoIHRoZSBiZWdpbm5pbmcgdmFsdWUncyBzdWZmaXguXG5cblx0XHRcdFx0XHRcdC8vaWYgdGhlIGJlZ2lubmluZy9lbmRpbmcgc3VmZml4ZXMgZG9uJ3QgbWF0Y2gsIG5vcm1hbGl6ZSB0aGVtLi4uXG5cdFx0XHRcdFx0XHRpZiAoYnNmeCAhPT0gZXNmeCkgaWYgKGVzZnggIT09IFwiXCIpIGlmIChlbiB8fCBlbiA9PT0gMCkgaWYgKGJuKSB7IC8vbm90ZTogaWYgdGhlIGJlZ2lubmluZyB2YWx1ZSAoYm4pIGlzIDAsIHdlIGRvbid0IG5lZWQgdG8gY29udmVydCB1bml0cyFcblx0XHRcdFx0XHRcdFx0Ym4gPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgYm4sIGJzZngpO1xuXHRcdFx0XHRcdFx0XHRpZiAoZXNmeCA9PT0gXCIlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiAvPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgMTAwLCBcIiVcIikgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHZhcnMuc3RyaWN0VW5pdHMgIT09IHRydWUpIHsgLy9zb21lIGJyb3dzZXJzIHJlcG9ydCBvbmx5IFwicHhcIiB2YWx1ZXMgaW5zdGVhZCBvZiBhbGxvd2luZyBcIiVcIiB3aXRoIGdldENvbXB1dGVkU3R5bGUoKSwgc28gd2UgYXNzdW1lIHRoYXQgaWYgd2UncmUgdHdlZW5pbmcgdG8gYSAlLCB3ZSBzaG91bGQgc3RhcnQgdGhlcmUgdG9vIHVubGVzcyBzdHJpY3RVbml0czp0cnVlIGlzIGRlZmluZWQuIFRoaXMgYXBwcm9hY2ggaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgcmVzcG9uc2l2ZSBkZXNpZ25zIHRoYXQgdXNlIGZyb20oKSB0d2VlbnMuXG5cdFx0XHRcdFx0XHRcdFx0XHRicyA9IGJuICsgXCIlXCI7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZXNmeCA9PT0gXCJlbVwiIHx8IGVzZnggPT09IFwicmVtXCIgfHwgZXNmeCA9PT0gXCJ2d1wiIHx8IGVzZnggPT09IFwidmhcIikge1xuXHRcdFx0XHRcdFx0XHRcdGJuIC89IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCAxLCBlc2Z4KTtcblxuXHRcdFx0XHRcdFx0XHQvL290aGVyd2lzZSBjb252ZXJ0IHRvIHBpeGVscy5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlc2Z4ICE9PSBcInB4XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRlbiA9IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCBlbiwgZXNmeCk7XG5cdFx0XHRcdFx0XHRcdFx0ZXNmeCA9IFwicHhcIjsgLy93ZSBkb24ndCB1c2UgYnNmeCBhZnRlciB0aGlzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHNldCBpdCB0byBweCB0b28uXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHJlbCkgaWYgKGVuIHx8IGVuID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZXMgPSAoZW4gKyBibikgKyBlc2Z4OyAvL3RoZSBjaGFuZ2VzIHdlIG1hZGUgYWZmZWN0IHJlbGF0aXZlIGNhbGN1bGF0aW9ucywgc28gYWRqdXN0IHRoZSBlbmQgdmFsdWUgaGVyZS5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAocmVsKSB7XG5cdFx0XHRcdFx0XHRcdGVuICs9IGJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoKGJuIHx8IGJuID09PSAwKSAmJiAoZW4gfHwgZW4gPT09IDApKSB7IC8vZmFzdGVyIHRoYW4gaXNOYU4oKS4gQWxzbywgcHJldmlvdXNseSB3ZSByZXF1aXJlZCBlbiAhPT0gYm4gYnV0IHRoYXQgZG9lc24ndCByZWFsbHkgZ2FpbiBtdWNoIHBlcmZvcm1hbmNlIGFuZCBpdCBwcmV2ZW50cyBfcGFyc2VUb1Byb3h5KCkgZnJvbSB3b3JraW5nIHByb3Blcmx5IGlmIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBtYXRjaCBidXQgbmVlZCB0byBnZXQgdHdlZW5lZCBieSBhbiBleHRlcm5hbCBwbHVnaW4gYW55d2F5LiBGb3IgZXhhbXBsZSwgYSBiZXppZXIgdHdlZW4gd2hlcmUgdGhlIHRhcmdldCBzdGFydHMgYXQgbGVmdDowIGFuZCBoYXMgdGhlc2UgcG9pbnRzOiBbe2xlZnQ6NTB9LHtsZWZ0OjB9XSB3b3VsZG4ndCB3b3JrIHByb3Blcmx5IGJlY2F1c2Ugd2hlbiBwYXJzaW5nIHRoZSBsYXN0IHBvaW50LCBpdCdkIG1hdGNoIHRoZSBmaXJzdCAoY3VycmVudCkgb25lIGFuZCBhIG5vbi10d2VlbmluZyBDU1NQcm9wVHdlZW4gd291bGQgYmUgcmVjb3JkZWQgd2hlbiB3ZSBhY3R1YWxseSBuZWVkIGEgbm9ybWFsIHR3ZWVuICh0eXBlOjApIHNvIHRoYXQgdGhpbmdzIGdldCB1cGRhdGVkIGR1cmluZyB0aGUgdHdlZW4gcHJvcGVybHkuXG5cdFx0XHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgcCwgYm4sIGVuIC0gYm4sIHB0LCAwLCBwLCAoX2F1dG9Sb3VuZCAhPT0gZmFsc2UgJiYgKGVzZnggPT09IFwicHhcIiB8fCBwID09PSBcInpJbmRleFwiKSksIDAsIGJzLCBlcyk7XG5cdFx0XHRcdFx0XHRcdHB0LnhzMCA9IGVzZng7XG5cdFx0XHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJ0d2VlbiBcIitwK1wiIGZyb20gXCIrcHQuYitcIiAoXCIrYm4rZXNmeCtcIikgdG8gXCIrcHQuZStcIiB3aXRoIHN1ZmZpeDogXCIrcHQueHMwKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc3R5bGVbcF0gPT09IHVuZGVmaW5lZCB8fCAhZXMgJiYgKGVzICsgXCJcIiA9PT0gXCJOYU5cIiB8fCBlcyA9PSBudWxsKSkge1xuXHRcdFx0XHRcdFx0XHRfbG9nKFwiaW52YWxpZCBcIiArIHAgKyBcIiB0d2VlbiB2YWx1ZTogXCIgKyB2YXJzW3BdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgcCwgZW4gfHwgYm4gfHwgMCwgMCwgcHQsIC0xLCBwLCBmYWxzZSwgMCwgYnMsIGVzKTtcblx0XHRcdFx0XHRcdFx0cHQueHMwID0gKGVzID09PSBcIm5vbmVcIiAmJiAocCA9PT0gXCJkaXNwbGF5XCIgfHwgcC5pbmRleE9mKFwiU3R5bGVcIikgIT09IC0xKSkgPyBicyA6IGVzOyAvL2ludGVybWVkaWF0ZSB2YWx1ZSBzaG91bGQgdHlwaWNhbGx5IGJlIHNldCBpbW1lZGlhdGVseSAoZW5kIHZhbHVlKSBleGNlcHQgZm9yIFwiZGlzcGxheVwiIG9yIHRoaW5ncyBsaWtlIGJvcmRlclRvcFN0eWxlLCBib3JkZXJCb3R0b21TdHlsZSwgZXRjLiB3aGljaCBzaG91bGQgdXNlIHRoZSBiZWdpbm5pbmcgdmFsdWUgZHVyaW5nIHRoZSB0d2Vlbi5cblx0XHRcdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcIm5vbi10d2VlbmluZyB2YWx1ZSBcIitwK1wiOiBcIitwdC54czApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGx1Z2luKSBpZiAocHQgJiYgIXB0LnBsdWdpbikge1xuXHRcdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH07XG5cblxuXHRcdC8vZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB0aGUgdHdlZW4gdXBkYXRlcywgcGFzc2luZyB0aGUgbmV3IHJhdGlvICh0eXBpY2FsbHkgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGJ1dCBub3QgYWx3YXlzIChmb3IgZXhhbXBsZSwgaWYgYW4gRWxhc3RpYy5lYXNlT3V0IGlzIHVzZWQsIHRoZSB2YWx1ZSBjYW4ganVtcCBhYm92ZSAxIG1pZC10d2VlbikuIEl0IHdpbGwgYWx3YXlzIHN0YXJ0IGFuZCAwIGFuZCBlbmQgYXQgMS5cblx0XHRwLnNldFJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVCxcblx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdHZhbCwgc3RyLCBpO1xuXHRcdFx0Ly9hdCB0aGUgZW5kIG9mIHRoZSB0d2Vlbiwgd2Ugc2V0IHRoZSB2YWx1ZXMgdG8gZXhhY3RseSB3aGF0IHdlIHJlY2VpdmVkIGluIG9yZGVyIHRvIG1ha2Ugc3VyZSBub24tdHdlZW5pbmcgdmFsdWVzIChsaWtlIFwicG9zaXRpb25cIiBvciBcImZsb2F0XCIgb3Igd2hhdGV2ZXIpIGFyZSBzZXQgYW5kIHNvIHRoYXQgaWYgdGhlIGJlZ2lubmluZy9lbmRpbmcgc3VmZml4ZXMgKHVuaXRzKSBkaWRuJ3QgbWF0Y2ggYW5kIHdlIG5vcm1hbGl6ZWQgdG8gcHgsIHRoZSB2YWx1ZSB0aGF0IHRoZSB1c2VyIHBhc3NlZCBpbiBpcyB1c2VkIGhlcmUuIFdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgdHdlZW4gaXMgYXQgaXRzIGJlZ2lubmluZyBpbiBjYXNlIGl0J3MgYSBmcm9tKCkgdHdlZW4gaW4gd2hpY2ggY2FzZSB0aGUgcmF0aW8gd2lsbCBhY3R1YWxseSBnbyBmcm9tIDEgdG8gMCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHR3ZWVuIChiYWNrd2FyZHMpLlxuXHRcdFx0aWYgKHYgPT09IDEgJiYgKHRoaXMuX3R3ZWVuLl90aW1lID09PSB0aGlzLl90d2Vlbi5fZHVyYXRpb24gfHwgdGhpcy5fdHdlZW4uX3RpbWUgPT09IDApKSB7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdGlmIChwdC50eXBlICE9PSAyKSB7XG5cdFx0XHRcdFx0XHRpZiAocHQuciAmJiBwdC50eXBlICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHB0LnMgKyBwdC5jKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFwdC50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHZhbCArIHB0LnhzMDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwdC50eXBlID09PSAxKSB7IC8vY29tcGxleCB2YWx1ZSAob25lIHRoYXQgdHlwaWNhbGx5IGhhcyBtdWx0aXBsZSBudW1iZXJzIGluc2lkZSBhIHN0cmluZywgbGlrZSBcInJlY3QoNXB4LDEwcHgsMjBweCwyNXB4KVwiXG5cdFx0XHRcdFx0XHRcdFx0aSA9IHB0Lmw7XG5cdFx0XHRcdFx0XHRcdFx0c3RyID0gcHQueHMwICsgdmFsICsgcHQueHMxO1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBwdC5sOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhuXCIraV0gKyBwdFtcInhzXCIrKGkrMSldO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gc3RyO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQuc2V0UmF0aW8odik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICh2IHx8ICEodGhpcy5fdHdlZW4uX3RpbWUgPT09IHRoaXMuX3R3ZWVuLl9kdXJhdGlvbiB8fCB0aGlzLl90d2Vlbi5fdGltZSA9PT0gMCkgfHwgdGhpcy5fdHdlZW4uX3Jhd1ByZXZUaW1lID09PSAtMC4wMDAwMDEpIHtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0dmFsID0gcHQuYyAqIHYgKyBwdC5zO1xuXHRcdFx0XHRcdGlmIChwdC5yKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWwgPCBtaW4pIGlmICh2YWwgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXB0LnR5cGUpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSB2YWwgKyBwdC54czA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC50eXBlID09PSAxKSB7IC8vY29tcGxleCB2YWx1ZSAob25lIHRoYXQgdHlwaWNhbGx5IGhhcyBtdWx0aXBsZSBudW1iZXJzIGluc2lkZSBhIHN0cmluZywgbGlrZSBcInJlY3QoNXB4LDEwcHgsMjBweCwyNXB4KVwiXG5cdFx0XHRcdFx0XHRpID0gcHQubDtcblx0XHRcdFx0XHRcdGlmIChpID09PSAyKSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czI7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IDMpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMiArIHB0LnhuMiArIHB0LnhzMztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gNCkge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyICsgcHQueG4yICsgcHQueHMzICsgcHQueG4zICsgcHQueHM0O1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpID09PSA1KSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czIgKyBwdC54bjIgKyBwdC54czMgKyBwdC54bjMgKyBwdC54czQgKyBwdC54bjQgKyBwdC54czU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyB2YWwgKyBwdC54czE7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBwdC5sOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gcHRbXCJ4blwiK2ldICsgcHRbXCJ4c1wiKyhpKzEpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gc3RyO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC50eXBlID09PSAtMSkgeyAvL25vbi10d2VlbmluZyB2YWx1ZVxuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMDtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQuc2V0UmF0aW8pIHsgLy9jdXN0b20gc2V0UmF0aW8oKSBmb3IgdGhpbmdzIGxpa2UgU3BlY2lhbFByb3BzLCBleHRlcm5hbCBwbHVnaW5zLCBldGMuXG5cdFx0XHRcdFx0XHRwdC5zZXRSYXRpbyh2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHQvL2lmIHRoZSB0d2VlbiBpcyByZXZlcnNlZCBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgdmFsdWVzIHdoaWNoIG1heSBoYXZlIGRpZmZlcmVudCB1bml0cyAobGlrZSAlIGluc3RlYWQgb2YgcHggb3IgZW0gb3Igd2hhdGV2ZXIpLlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LnR5cGUgIT09IDIpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC5iO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC5zZXRSYXRpbyh2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEZvcmNlcyByZW5kZXJpbmcgb2YgdGhlIHRhcmdldCdzIHRyYW5zZm9ybXMgKHJvdGF0aW9uLCBzY2FsZSwgZXRjLikgd2hlbmV2ZXIgdGhlIENTU1BsdWdpbidzIHNldFJhdGlvKCkgaXMgY2FsbGVkLlxuXHRcdCAqIEJhc2ljYWxseSwgdGhpcyB0ZWxscyB0aGUgQ1NTUGx1Z2luIHRvIGNyZWF0ZSBhIENTU1Byb3BUd2VlbiAodHlwZSAyKSBhZnRlciBpbnN0YW50aWF0aW9uIHRoYXQgcnVucyBsYXN0IGluIHRoZSBsaW5rZWRcblx0XHQgKiBsaXN0IGFuZCBjYWxscyB0aGUgYXBwcm9wcmlhdGUgKDNEIG9yIDJEKSByZW5kZXJpbmcgZnVuY3Rpb24uIFdlIHNlcGFyYXRlIHRoaXMgaW50byBpdHMgb3duIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiBjYWxsXG5cdFx0ICogaXQgZnJvbSBvdGhlciBwbHVnaW5zIGxpa2UgQmV6aWVyUGx1Z2luIGlmLCBmb3IgZXhhbXBsZSwgaXQgbmVlZHMgdG8gYXBwbHkgYW4gYXV0b1JvdGF0aW9uIGFuZCB0aGlzIENTU1BsdWdpblxuXHRcdCAqIGRvZXNuJ3QgaGF2ZSBhbnkgdHJhbnNmb3JtLXJlbGF0ZWQgcHJvcGVydGllcyBvZiBpdHMgb3duLiBZb3UgY2FuIGNhbGwgdGhpcyBtZXRob2QgYXMgbWFueSB0aW1lcyBhcyB5b3Vcblx0XHQgKiB3YW50IGFuZCBpdCB3b24ndCBjcmVhdGUgZHVwbGljYXRlIENTU1Byb3BUd2VlbnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IHRocmVlRCBpZiB0cnVlLCBpdCBzaG91bGQgYXBwbHkgM0QgdHdlZW5zIChvdGhlcndpc2UsIGp1c3QgMkQgb25lcyBhcmUgZmluZSBhbmQgdHlwaWNhbGx5IGZhc3Rlcilcblx0XHQgKi9cblx0XHRwLl9lbmFibGVUcmFuc2Zvcm1zID0gZnVuY3Rpb24odGhyZWVEKSB7XG5cdFx0XHR0aGlzLl90cmFuc2Zvcm0gPSB0aGlzLl90cmFuc2Zvcm0gfHwgX2dldFRyYW5zZm9ybSh0aGlzLl90YXJnZXQsIF9jcywgdHJ1ZSk7IC8vZW5zdXJlcyB0aGF0IHRoZSBlbGVtZW50IGhhcyBhIF9nc1RyYW5zZm9ybSBwcm9wZXJ0eSB3aXRoIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXMuXG5cdFx0XHR0aGlzLl90cmFuc2Zvcm1UeXBlID0gKCEodGhpcy5fdHJhbnNmb3JtLnN2ZyAmJiBfdXNlU1ZHVHJhbnNmb3JtQXR0cikgJiYgKHRocmVlRCB8fCB0aGlzLl90cmFuc2Zvcm1UeXBlID09PSAzKSkgPyAzIDogMjtcblx0XHR9O1xuXG5cdFx0dmFyIGxhenlTZXQgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHR0aGlzLnRbdGhpcy5wXSA9IHRoaXMuZTtcblx0XHRcdHRoaXMuZGF0YS5fbGlua0NTU1AodGhpcywgdGhpcy5fbmV4dCwgbnVsbCwgdHJ1ZSk7IC8vd2UgcHVycG9zZWZ1bGx5IGtlZXAgdGhpcy5fbmV4dCBldmVuIHRob3VnaCBpdCdkIG1ha2Ugc2Vuc2UgdG8gbnVsbCBpdCwgYnV0IHRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIGFzIHRoaXMgaGFwcGVucyBkdXJpbmcgdGhlIHdoaWxlIChwdCkge30gbG9vcCBpbiBzZXRSYXRpbygpIGF0IHRoZSBib3R0b20gb2Ygd2hpY2ggaXQgc2V0cyBwdCA9IHB0Ll9uZXh0LCBzbyBpZiB3ZSBudWxsIGl0LCB0aGUgbGlua2VkIGxpc3Qgd2lsbCBiZSBicm9rZW4gaW4gdGhhdCBsb29wLlxuXHRcdH07XG5cdFx0LyoqIEBwcml2YXRlIEdpdmVzIHVzIGEgd2F5IHRvIHNldCBhIHZhbHVlIG9uIHRoZSBmaXJzdCByZW5kZXIgKGFuZCBvbmx5IHRoZSBmaXJzdCByZW5kZXIpLiAqKi9cblx0XHRwLl9hZGRMYXp5U2V0ID0gZnVuY3Rpb24odCwgcCwgdikge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgdGhpcy5fZmlyc3RQVCwgMik7XG5cdFx0XHRwdC5lID0gdjtcblx0XHRcdHB0LnNldFJhdGlvID0gbGF6eVNldDtcblx0XHRcdHB0LmRhdGEgPSB0aGlzO1xuXHRcdH07XG5cblx0XHQvKiogQHByaXZhdGUgKiovXG5cdFx0cC5fbGlua0NTU1AgPSBmdW5jdGlvbihwdCwgbmV4dCwgcHJldiwgcmVtb3ZlKSB7XG5cdFx0XHRpZiAocHQpIHtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2ZpcnN0UFQgPT09IHB0KSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdHJlbW92ZSA9IHRydWU7IC8vanVzdCB0byBwcmV2ZW50IHJlc2V0dGluZyB0aGlzLl9maXJzdFBUIDUgbGluZXMgZG93biBpbiBjYXNlIHB0Ll9uZXh0IGlzIG51bGwuIChvcHRpbWl6ZWQgZm9yIHNwZWVkKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcmV2KSB7XG5cdFx0XHRcdFx0cHJldi5fbmV4dCA9IHB0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFyZW1vdmUgJiYgdGhpcy5fZmlyc3RQVCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdC5fbmV4dCA9IG5leHQ7XG5cdFx0XHRcdHB0Ll9wcmV2ID0gcHJldjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9O1xuXG5cdFx0Ly93ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIGFscGhhIG9yIGF1dG9BbHBoYSBpcyBraWxsZWQsIG9wYWNpdHkgaXMgdG9vLiBBbmQgYXV0b0FscGhhIGFmZmVjdHMgdGhlIFwidmlzaWJpbGl0eVwiIHByb3BlcnR5LlxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbihsb29rdXApIHtcblx0XHRcdHZhciBjb3B5ID0gbG9va3VwLFxuXHRcdFx0XHRwdCwgcCwgeGZpcnN0O1xuXHRcdFx0aWYgKGxvb2t1cC5hdXRvQWxwaGEgfHwgbG9va3VwLmFscGhhKSB7XG5cdFx0XHRcdGNvcHkgPSB7fTtcblx0XHRcdFx0Zm9yIChwIGluIGxvb2t1cCkgeyAvL2NvcHkgdGhlIGxvb2t1cCBzbyB0aGF0IHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgb3JpZ2luYWwgd2hpY2ggbWF5IGJlIHBhc3NlZCBlbHNld2hlcmUuXG5cdFx0XHRcdFx0Y29weVtwXSA9IGxvb2t1cFtwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb3B5Lm9wYWNpdHkgPSAxO1xuXHRcdFx0XHRpZiAoY29weS5hdXRvQWxwaGEpIHtcblx0XHRcdFx0XHRjb3B5LnZpc2liaWxpdHkgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobG9va3VwLmNsYXNzTmFtZSAmJiAocHQgPSB0aGlzLl9jbGFzc05hbWVQVCkpIHsgLy9mb3IgY2xhc3NOYW1lIHR3ZWVucywgd2UgbmVlZCB0byBraWxsIGFueSBhc3NvY2lhdGVkIENTU1Byb3BUd2VlbnMgdG9vOyBhIGxpbmtlZCBsaXN0IHN0YXJ0cyBhdCB0aGUgY2xhc3NOYW1lJ3MgXCJ4Zmlyc3RcIi5cblx0XHRcdFx0eGZpcnN0ID0gcHQueGZpcnN0O1xuXHRcdFx0XHRpZiAoeGZpcnN0ICYmIHhmaXJzdC5fcHJldikge1xuXHRcdFx0XHRcdHRoaXMuX2xpbmtDU1NQKHhmaXJzdC5fcHJldiwgcHQuX25leHQsIHhmaXJzdC5fcHJldi5fcHJldik7IC8vYnJlYWsgb2ZmIHRoZSBwcmV2XG5cdFx0XHRcdH0gZWxzZSBpZiAoeGZpcnN0ID09PSB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdHRoaXMuX2xpbmtDU1NQKHB0Ll9uZXh0LCBwdC5fbmV4dC5fbmV4dCwgeGZpcnN0Ll9wcmV2KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jbGFzc05hbWVQVCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gVHdlZW5QbHVnaW4ucHJvdG90eXBlLl9raWxsLmNhbGwodGhpcywgY29weSk7XG5cdFx0fTtcblxuXG5cblx0XHQvL3VzZWQgYnkgY2FzY2FkZVRvKCkgZm9yIGdhdGhlcmluZyBhbGwgdGhlIHN0eWxlIHByb3BlcnRpZXMgb2YgZWFjaCBjaGlsZCBlbGVtZW50IGludG8gYW4gYXJyYXkgZm9yIGNvbXBhcmlzb24uXG5cdFx0dmFyIF9nZXRDaGlsZFN0eWxlcyA9IGZ1bmN0aW9uKGUsIHByb3BzLCB0YXJnZXRzKSB7XG5cdFx0XHRcdHZhciBjaGlsZHJlbiwgaSwgY2hpbGQsIHR5cGU7XG5cdFx0XHRcdGlmIChlLnNsaWNlKSB7XG5cdFx0XHRcdFx0aSA9IGUubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0X2dldENoaWxkU3R5bGVzKGVbaV0sIHByb3BzLCB0YXJnZXRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoaWxkcmVuID0gZS5jaGlsZE5vZGVzO1xuXHRcdFx0XHRpID0gY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0XHRcdHR5cGUgPSBjaGlsZC50eXBlO1xuXHRcdFx0XHRcdGlmIChjaGlsZC5zdHlsZSkge1xuXHRcdFx0XHRcdFx0cHJvcHMucHVzaChfZ2V0QWxsU3R5bGVzKGNoaWxkKSk7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0cykge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHR5cGUgPT09IDEgfHwgdHlwZSA9PT0gOSB8fCB0eXBlID09PSAxMSkgJiYgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdF9nZXRDaGlsZFN0eWxlcyhjaGlsZCwgcHJvcHMsIHRhcmdldHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFR5cGljYWxseSBvbmx5IHVzZWZ1bCBmb3IgY2xhc3NOYW1lIHR3ZWVucyB0aGF0IG1heSBhZmZlY3QgY2hpbGQgZWxlbWVudHMsIHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBUd2VlbkxpdGVcblx0XHQgKiBhbmQgdGhlbiBjb21wYXJlcyB0aGUgc3R5bGUgcHJvcGVydGllcyBvZiBhbGwgdGhlIHRhcmdldCdzIGNoaWxkIGVsZW1lbnRzIGF0IHRoZSB0d2VlbidzIHN0YXJ0IGFuZCBlbmQsIGFuZFxuXHRcdCAqIGlmIGFueSBhcmUgZGlmZmVyZW50LCBpdCBhbHNvIGNyZWF0ZXMgdHdlZW5zIGZvciB0aG9zZSBhbmQgcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIEFMTCBvZiB0aGUgcmVzdWx0aW5nXG5cdFx0ICogdHdlZW5zIChzbyB0aGF0IHlvdSBjYW4gZWFzaWx5IGFkZCgpIHRoZW0gdG8gYSBUaW1lbGluZUxpdGUsIGZvciBleGFtcGxlKS4gVGhlIHJlYXNvbiB0aGlzIGZ1bmN0aW9uYWxpdHkgaXNcblx0XHQgKiB3cmFwcGVkIGludG8gYSBzZXBhcmF0ZSBzdGF0aWMgbWV0aG9kIG9mIENTU1BsdWdpbiBpbnN0ZWFkIG9mIGJlaW5nIGludGVncmF0ZWQgaW50byBhbGwgcmVndWxhciBjbGFzc05hbWUgdHdlZW5zXG5cdFx0ICogaXMgYmVjYXVzZSBpdCBjcmVhdGVzIGVudGlyZWx5IG5ldyB0d2VlbnMgdGhhdCBtYXkgaGF2ZSBjb21wbGV0ZWx5IGRpZmZlcmVudCB0YXJnZXRzIHRoYW4gdGhlIG9yaWdpbmFsIHR3ZWVuLFxuXHRcdCAqIHNvIGlmIHRoZXkgd2VyZSBhbGwgbHVtcGVkIGludG8gdGhlIG9yaWdpbmFsIHR3ZWVuIGluc3RhbmNlLCBpdCB3b3VsZCBiZSBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgQVBJXG5cdFx0ICogYW5kIGl0IHdvdWxkIGNyZWF0ZSBvdGhlciBwcm9ibGVtcy4gRm9yIGV4YW1wbGU6XG5cdFx0ICogIC0gSWYgSSBjcmVhdGUgYSB0d2VlbiBvZiBlbGVtZW50QSwgdGhhdCB0d2VlbiBpbnN0YW5jZSBtYXkgc3VkZGVubHkgY2hhbmdlIGl0cyB0YXJnZXQgdG8gaW5jbHVkZSA1MCBvdGhlciBlbGVtZW50cyAodW5pbnR1aXRpdmUgaWYgSSBzcGVjaWZpY2FsbHkgZGVmaW5lZCB0aGUgdGFyZ2V0IEkgd2FudGVkKVxuXHRcdCAqICAtIFdlIGNhbid0IGp1c3QgY3JlYXRlIG5ldyBpbmRlcGVuZGVudCB0d2VlbnMgYmVjYXVzZSBvdGhlcndpc2UsIHdoYXQgaGFwcGVucyBpZiB0aGUgb3JpZ2luYWwvcGFyZW50IHR3ZWVuIGlzIHJldmVyc2VkIG9yIHBhdXNlIG9yIGRyb3BwZWQgaW50byBhIFRpbWVsaW5lTGl0ZSBmb3IgdGlnaHQgY29udHJvbD8gWW91J2QgZXhwZWN0IHRoYXQgdHdlZW4ncyBiZWhhdmlvciB0byBhZmZlY3QgYWxsIHRoZSBvdGhlcnMuXG5cdFx0ICogIC0gQW5hbHl6aW5nIGV2ZXJ5IHN0eWxlIHByb3BlcnR5IG9mIGV2ZXJ5IGNoaWxkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHR3ZWVuIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24gd2hlbiB0aGVyZSBhcmUgbWFueSBjaGlsZHJlbiwgc28gdGhpcyBiZWhhdmlvciBzaG91bGRuJ3QgYmUgaW1wb3NlZCBvbiBhbGwgY2xhc3NOYW1lIHR3ZWVucyBieSBkZWZhdWx0LCBlc3BlY2lhbGx5IHNpbmNlIGl0J3MgcHJvYmFibHkgcmFyZSB0aGF0IHRoaXMgZXh0cmEgZnVuY3Rpb25hbGl0eSBpcyBuZWVkZWQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IG9iamVjdCB0byBiZSB0d2VlbmVkXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IER1cmF0aW9uIGluIHNlY29uZHMgKG9yIGZyYW1lcyBmb3IgZnJhbWVzLWJhc2VkIHR3ZWVucylcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuZCB2YWx1ZXMsIGxpa2Uge2NsYXNzTmFtZTpcIm5ld0NsYXNzXCIsIGVhc2U6TGluZWFyLmVhc2VOb25lfVxuXHRcdCAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBUd2VlbkxpdGUgaW5zdGFuY2VzXG5cdFx0ICovXG5cdFx0Q1NTUGx1Z2luLmNhc2NhZGVUbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHZhciB0d2VlbiA9IFR3ZWVuTGl0ZS50byh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSxcblx0XHRcdFx0cmVzdWx0cyA9IFt0d2Vlbl0sXG5cdFx0XHRcdGIgPSBbXSxcblx0XHRcdFx0ZSA9IFtdLFxuXHRcdFx0XHR0YXJnZXRzID0gW10sXG5cdFx0XHRcdF9yZXNlcnZlZFByb3BzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMucmVzZXJ2ZWRQcm9wcyxcblx0XHRcdFx0aSwgZGlmcywgcCwgZnJvbTtcblx0XHRcdHRhcmdldCA9IHR3ZWVuLl90YXJnZXRzIHx8IHR3ZWVuLnRhcmdldDtcblx0XHRcdF9nZXRDaGlsZFN0eWxlcyh0YXJnZXQsIGIsIHRhcmdldHMpO1xuXHRcdFx0dHdlZW4ucmVuZGVyKGR1cmF0aW9uLCB0cnVlLCB0cnVlKTtcblx0XHRcdF9nZXRDaGlsZFN0eWxlcyh0YXJnZXQsIGUpO1xuXHRcdFx0dHdlZW4ucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuXHRcdFx0dHdlZW4uX2VuYWJsZWQodHJ1ZSk7XG5cdFx0XHRpID0gdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0ZGlmcyA9IF9jc3NEaWYodGFyZ2V0c1tpXSwgYltpXSwgZVtpXSk7XG5cdFx0XHRcdGlmIChkaWZzLmZpcnN0TVBUKSB7XG5cdFx0XHRcdFx0ZGlmcyA9IGRpZnMuZGlmcztcblx0XHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdFx0aWYgKF9yZXNlcnZlZFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0XHRcdGRpZnNbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmcm9tID0ge307XG5cdFx0XHRcdFx0Zm9yIChwIGluIGRpZnMpIHtcblx0XHRcdFx0XHRcdGZyb21bcF0gPSBiW2ldW3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHRzLnB1c2goVHdlZW5MaXRlLmZyb21Ubyh0YXJnZXRzW2ldLCBkdXJhdGlvbiwgZnJvbSwgZGlmcykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUoW0NTU1BsdWdpbl0pO1xuXHRcdHJldHVybiBDU1NQbHVnaW47XG5cblx0fSwgdHJ1ZSk7XG5cblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUm91bmRQcm9wc1BsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdChmdW5jdGlvbigpIHtcblxuXHRcdHZhciBSb3VuZFByb3BzUGx1Z2luID0gX2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0XHRcdHByb3BOYW1lOiBcInJvdW5kUHJvcHNcIixcblx0XHRcdFx0dmVyc2lvbjogXCIxLjVcIixcblx0XHRcdFx0cHJpb3JpdHk6IC0xLFxuXHRcdFx0XHRBUEk6IDIsXG5cblx0XHRcdFx0Ly9jYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgaXMgd2hlcmUgaW5pdGlhbCB2YWx1ZXMgc2hvdWxkIGJlIHJlY29yZGVkIGFuZCBhbnkgc2V0dXAgcm91dGluZXMgc2hvdWxkIHJ1bi5cblx0XHRcdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4pIHtcblx0XHRcdFx0XHR0aGlzLl90d2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pLFxuXHRcdFx0X3JvdW5kTGlua2VkTGlzdCA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0d2hpbGUgKG5vZGUpIHtcblx0XHRcdFx0XHRpZiAoIW5vZGUuZiAmJiAhbm9kZS5ibG9iKSB7XG5cdFx0XHRcdFx0XHRub2RlLnIgPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlID0gbm9kZS5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHAgPSBSb3VuZFByb3BzUGx1Z2luLnByb3RvdHlwZTtcblxuXHRcdHAuX29uSW5pdEFsbFByb3BzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl90d2Vlbixcblx0XHRcdFx0cnAgPSAodHdlZW4udmFycy5yb3VuZFByb3BzLmpvaW4pID8gdHdlZW4udmFycy5yb3VuZFByb3BzIDogdHdlZW4udmFycy5yb3VuZFByb3BzLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0aSA9IHJwLmxlbmd0aCxcblx0XHRcdFx0bG9va3VwID0ge30sXG5cdFx0XHRcdHJwdCA9IHR3ZWVuLl9wcm9wTG9va3VwLnJvdW5kUHJvcHMsXG5cdFx0XHRcdHByb3AsIHB0LCBuZXh0O1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGxvb2t1cFtycFtpXV0gPSAxO1xuXHRcdFx0fVxuXHRcdFx0aSA9IHJwLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRwcm9wID0gcnBbaV07XG5cdFx0XHRcdHB0ID0gdHdlZW4uX2ZpcnN0UFQ7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdG5leHQgPSBwdC5fbmV4dDsgLy9yZWNvcmQgaGVyZSwgYmVjYXVzZSBpdCBtYXkgZ2V0IHJlbW92ZWRcblx0XHRcdFx0XHRpZiAocHQucGcpIHtcblx0XHRcdFx0XHRcdHB0LnQuX3JvdW5kUHJvcHMobG9va3VwLCB0cnVlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0Lm4gPT09IHByb3ApIHtcblx0XHRcdFx0XHRcdGlmIChwdC5mID09PSAyICYmIHB0LnQpIHsgLy9hIGJsb2IgKHRleHQgY29udGFpbmluZyBtdWx0aXBsZSBudW1lcmljIHZhbHVlcylcblx0XHRcdFx0XHRcdFx0X3JvdW5kTGlua2VkTGlzdChwdC50Ll9maXJzdFBUKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2FkZChwdC50LCBwcm9wLCBwdC5zLCBwdC5jKTtcblx0XHRcdFx0XHRcdFx0Ly9yZW1vdmUgZnJvbSBsaW5rZWQgbGlzdFxuXHRcdFx0XHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdFx0XHRcdG5leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IG5leHQ7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2ZpcnN0UFQgPT09IHB0KSB7XG5cdFx0XHRcdFx0XHRcdFx0dHdlZW4uX2ZpcnN0UFQgPSBuZXh0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHB0Ll9uZXh0ID0gcHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5fcHJvcExvb2t1cFtwcm9wXSA9IHJwdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuX2FkZCA9IGZ1bmN0aW9uKHRhcmdldCwgcCwgcywgYykge1xuXHRcdFx0dGhpcy5fYWRkVHdlZW4odGFyZ2V0LCBwLCBzLCBzICsgYywgcCwgdHJ1ZSk7XG5cdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdH07XG5cblx0fSgpKTtcblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEF0dHJQbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cdChmdW5jdGlvbigpIHtcblxuXHRcdF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdFx0cHJvcE5hbWU6IFwiYXR0clwiLFxuXHRcdFx0QVBJOiAyLFxuXHRcdFx0dmVyc2lvbjogXCIwLjUuMFwiLFxuXG5cdFx0XHQvL2NhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4pIHtcblx0XHRcdFx0dmFyIHA7XG5cdFx0XHRcdGlmICh0eXBlb2YodGFyZ2V0LnNldEF0dHJpYnV0ZSkgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHAgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHR0aGlzLl9hZGRUd2Vlbih0YXJnZXQsIFwic2V0QXR0cmlidXRlXCIsIHRhcmdldC5nZXRBdHRyaWJ1dGUocCkgKyBcIlwiLCB2YWx1ZVtwXSArIFwiXCIsIHAsIGZhbHNlLCBwKTtcblx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0fSk7XG5cblx0fSgpKTtcblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERpcmVjdGlvbmFsUm90YXRpb25QbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRwcm9wTmFtZTogXCJkaXJlY3Rpb25hbFJvdGF0aW9uXCIsXG5cdFx0dmVyc2lvbjogXCIwLjIuMVwiLFxuXHRcdEFQSTogMixcblxuXHRcdC8vY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4pIHtcblx0XHRcdGlmICh0eXBlb2YodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdHZhbHVlID0ge3JvdGF0aW9uOnZhbHVlfTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZmluYWxzID0ge307XG5cdFx0XHR2YXIgY2FwID0gKHZhbHVlLnVzZVJhZGlhbnMgPT09IHRydWUpID8gTWF0aC5QSSAqIDIgOiAzNjAsXG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRwLCB2LCBzdGFydCwgZW5kLCBkaWYsIHNwbGl0O1xuXHRcdFx0Zm9yIChwIGluIHZhbHVlKSB7XG5cdFx0XHRcdGlmIChwICE9PSBcInVzZVJhZGlhbnNcIikge1xuXHRcdFx0XHRcdHNwbGl0ID0gKHZhbHVlW3BdICsgXCJcIikuc3BsaXQoXCJfXCIpO1xuXHRcdFx0XHRcdHYgPSBzcGxpdFswXTtcblx0XHRcdFx0XHRzdGFydCA9IHBhcnNlRmxvYXQoICh0eXBlb2YodGFyZ2V0W3BdKSAhPT0gXCJmdW5jdGlvblwiKSA/IHRhcmdldFtwXSA6IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0oKSApO1xuXHRcdFx0XHRcdGVuZCA9IHRoaXMuZmluYWxzW3BdID0gKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIiAmJiB2LmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gc3RhcnQgKyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBOdW1iZXIodi5zdWJzdHIoMikpIDogTnVtYmVyKHYpIHx8IDA7XG5cdFx0XHRcdFx0ZGlmID0gZW5kIC0gc3RhcnQ7XG5cdFx0XHRcdFx0aWYgKHNwbGl0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0diA9IHNwbGl0LmpvaW4oXCJfXCIpO1xuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcInNob3J0XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSBkaWYgJSBjYXA7XG5cdFx0XHRcdFx0XHRcdGlmIChkaWYgIT09IGRpZiAlIChjYXAgLyAyKSkge1xuXHRcdFx0XHRcdFx0XHRcdGRpZiA9IChkaWYgPCAwKSA/IGRpZiArIGNhcCA6IGRpZiAtIGNhcDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcIl9jd1wiKSAhPT0gLTEgJiYgZGlmIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiArIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2LmluZGV4T2YoXCJjY3dcIikgIT09IC0xICYmIGRpZiA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgLSBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRpZiA+IG1pbiB8fCBkaWYgPCAtbWluKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRUd2Vlbih0YXJnZXQsIHAsIHN0YXJ0LCBzdGFydCArIGRpZiwgcCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8vY2FsbGVkIGVhY2ggdGltZSB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkLCBhbmQgdGhlIHJhdGlvIGdldHMgcGFzc2VkIGFzIHRoZSBvbmx5IHBhcmFtZXRlciAodHlwaWNhbGx5IGl0J3MgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGJ1dCBpdCBjYW4gZXhjZWVkIHRob3NlIHdoZW4gdXNpbmcgYW4gZWFzZSBsaWtlIEVsYXN0aWMuZWFzZU91dCBvciBCYWNrLmVhc2VPdXQsIGV0Yy4pXG5cdFx0c2V0OiBmdW5jdGlvbihyYXRpbykge1xuXHRcdFx0dmFyIHB0O1xuXHRcdFx0aWYgKHJhdGlvICE9PSAxKSB7XG5cdFx0XHRcdHRoaXMuX3N1cGVyLnNldFJhdGlvLmNhbGwodGhpcywgcmF0aW8pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSh0aGlzLmZpbmFsc1twdC5wXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSB0aGlzLmZpbmFsc1twdC5wXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHR9KS5fYXV0b0NTUyA9IHRydWU7XG5cblxuXG5cblxuXG5cblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRWFzZVBhY2tcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJlYXNpbmcuQmFja1wiLCBbXCJlYXNpbmcuRWFzZVwiXSwgZnVuY3Rpb24oRWFzZSkge1xuXHRcdFxuXHRcdHZhciB3ID0gKF9nc1Njb3BlLkdyZWVuU29ja0dsb2JhbHMgfHwgX2dzU2NvcGUpLFxuXHRcdFx0Z3MgPSB3LmNvbS5ncmVlbnNvY2ssXG5cdFx0XHRfMlBJID0gTWF0aC5QSSAqIDIsXG5cdFx0XHRfSEFMRl9QSSA9IE1hdGguUEkgLyAyLFxuXHRcdFx0X2NsYXNzID0gZ3MuX2NsYXNzLFxuXHRcdFx0X2NyZWF0ZSA9IGZ1bmN0aW9uKG4sIGYpIHtcblx0XHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbigpe30sIHRydWUpLFxuXHRcdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXHRcdFx0X2Vhc2VSZWcgPSBFYXNlLnJlZ2lzdGVyIHx8IGZ1bmN0aW9uKCl7fSwgLy9wdXQgYW4gZW1wdHkgZnVuY3Rpb24gaW4gcGxhY2UganVzdCBhcyBhIHNhZmV0eSBtZWFzdXJlIGluIGNhc2Ugc29tZW9uZSBsb2FkcyBhbiBPTEQgdmVyc2lvbiBvZiBUd2VlbkxpdGUuanMgd2hlcmUgRWFzZS5yZWdpc3RlciBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0X3dyYXAgPSBmdW5jdGlvbihuYW1lLCBFYXNlT3V0LCBFYXNlSW4sIEVhc2VJbk91dCwgYWxpYXNlcykge1xuXHRcdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIituYW1lLCB7XG5cdFx0XHRcdFx0ZWFzZU91dDpuZXcgRWFzZU91dCgpLFxuXHRcdFx0XHRcdGVhc2VJbjpuZXcgRWFzZUluKCksXG5cdFx0XHRcdFx0ZWFzZUluT3V0Om5ldyBFYXNlSW5PdXQoKVxuXHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdFx0X2Vhc2VSZWcoQywgbmFtZSk7XG5cdFx0XHRcdHJldHVybiBDO1xuXHRcdFx0fSxcblx0XHRcdEVhc2VQb2ludCA9IGZ1bmN0aW9uKHRpbWUsIHZhbHVlLCBuZXh0KSB7XG5cdFx0XHRcdHRoaXMudCA9IHRpbWU7XG5cdFx0XHRcdHRoaXMudiA9IHZhbHVlO1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdHRoaXMubmV4dCA9IG5leHQ7XG5cdFx0XHRcdFx0bmV4dC5wcmV2ID0gdGhpcztcblx0XHRcdFx0XHR0aGlzLmMgPSBuZXh0LnYgLSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLmdhcCA9IG5leHQudCAtIHRpbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vQmFja1xuXHRcdFx0X2NyZWF0ZUJhY2sgPSBmdW5jdGlvbihuLCBmKSB7XG5cdFx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiICsgbiwgZnVuY3Rpb24ob3ZlcnNob290KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9wMSA9IChvdmVyc2hvb3QgfHwgb3ZlcnNob290ID09PSAwKSA/IG92ZXJzaG9vdCA6IDEuNzAxNTg7XG5cdFx0XHRcdFx0XHR0aGlzLl9wMiA9IHRoaXMuX3AxICogMS41MjU7XG5cdFx0XHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdFx0cC5jb25zdHJ1Y3RvciA9IEM7XG5cdFx0XHRcdHAuZ2V0UmF0aW8gPSBmO1xuXHRcdFx0XHRwLmNvbmZpZyA9IGZ1bmN0aW9uKG92ZXJzaG9vdCkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgQyhvdmVyc2hvb3QpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gQztcblx0XHRcdH0sXG5cblx0XHRcdEJhY2sgPSBfd3JhcChcIkJhY2tcIixcblx0XHRcdFx0X2NyZWF0ZUJhY2soXCJCYWNrT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRyZXR1cm4gKChwID0gcCAtIDEpICogcCAqICgodGhpcy5fcDEgKyAxKSAqIHAgKyB0aGlzLl9wMSkgKyAxKTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRyZXR1cm4gcCAqIHAgKiAoKHRoaXMuX3AxICsgMSkgKiBwIC0gdGhpcy5fcDEpO1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0X2NyZWF0ZUJhY2soXCJCYWNrSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRcdHJldHVybiAoKHAgKj0gMikgPCAxKSA/IDAuNSAqIHAgKiBwICogKCh0aGlzLl9wMiArIDEpICogcCAtIHRoaXMuX3AyKSA6IDAuNSAqICgocCAtPSAyKSAqIHAgKiAoKHRoaXMuX3AyICsgMSkgKiBwICsgdGhpcy5fcDIpICsgMik7XG5cdFx0XHRcdH0pXG5cdFx0XHQpLFxuXG5cblx0XHRcdC8vU2xvd01vXG5cdFx0XHRTbG93TW8gPSBfY2xhc3MoXCJlYXNpbmcuU2xvd01vXCIsIGZ1bmN0aW9uKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpIHtcblx0XHRcdFx0cG93ZXIgPSAocG93ZXIgfHwgcG93ZXIgPT09IDApID8gcG93ZXIgOiAwLjc7XG5cdFx0XHRcdGlmIChsaW5lYXJSYXRpbyA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bGluZWFyUmF0aW8gPSAwLjc7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZWFyUmF0aW8gPiAxKSB7XG5cdFx0XHRcdFx0bGluZWFyUmF0aW8gPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3AgPSAobGluZWFyUmF0aW8gIT09IDEpID8gcG93ZXIgOiAwO1xuXHRcdFx0XHR0aGlzLl9wMSA9ICgxIC0gbGluZWFyUmF0aW8pIC8gMjtcblx0XHRcdFx0dGhpcy5fcDIgPSBsaW5lYXJSYXRpbztcblx0XHRcdFx0dGhpcy5fcDMgPSB0aGlzLl9wMSArIHRoaXMuX3AyO1xuXHRcdFx0XHR0aGlzLl9jYWxjRW5kID0gKHlveW9Nb2RlID09PSB0cnVlKTtcblx0XHRcdH0sIHRydWUpLFxuXHRcdFx0cCA9IFNsb3dNby5wcm90b3R5cGUgPSBuZXcgRWFzZSgpLFxuXHRcdFx0U3RlcHBlZEVhc2UsIFJvdWdoRWFzZSwgX2NyZWF0ZUVsYXN0aWM7XG5cblx0XHRwLmNvbnN0cnVjdG9yID0gU2xvd01vO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHR2YXIgciA9IHAgKyAoMC41IC0gcCkgKiB0aGlzLl9wO1xuXHRcdFx0aWYgKHAgPCB0aGlzLl9wMSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FsY0VuZCA/IDEgLSAoKHAgPSAxIC0gKHAgLyB0aGlzLl9wMSkpICogcCkgOiByIC0gKChwID0gMSAtIChwIC8gdGhpcy5fcDEpKSAqIHAgKiBwICogcCAqIHIpO1xuXHRcdFx0fSBlbHNlIGlmIChwID4gdGhpcy5fcDMpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbGNFbmQgPyAxIC0gKHAgPSAocCAtIHRoaXMuX3AzKSAvIHRoaXMuX3AxKSAqIHAgOiByICsgKChwIC0gcikgKiAocCA9IChwIC0gdGhpcy5fcDMpIC8gdGhpcy5fcDEpICogcCAqIHAgKiBwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gMSA6IHI7XG5cdFx0fTtcblx0XHRTbG93TW8uZWFzZSA9IG5ldyBTbG93TW8oMC43LCAwLjcpO1xuXG5cdFx0cC5jb25maWcgPSBTbG93TW8uY29uZmlnID0gZnVuY3Rpb24obGluZWFyUmF0aW8sIHBvd2VyLCB5b3lvTW9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTbG93TW8obGluZWFyUmF0aW8sIHBvd2VyLCB5b3lvTW9kZSk7XG5cdFx0fTtcblxuXG5cdFx0Ly9TdGVwcGVkRWFzZVxuXHRcdFN0ZXBwZWRFYXNlID0gX2NsYXNzKFwiZWFzaW5nLlN0ZXBwZWRFYXNlXCIsIGZ1bmN0aW9uKHN0ZXBzKSB7XG5cdFx0XHRcdHN0ZXBzID0gc3RlcHMgfHwgMTtcblx0XHRcdFx0dGhpcy5fcDEgPSAxIC8gc3RlcHM7XG5cdFx0XHRcdHRoaXMuX3AyID0gc3RlcHMgKyAxO1xuXHRcdFx0fSwgdHJ1ZSk7XG5cdFx0cCA9IFN0ZXBwZWRFYXNlLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFN0ZXBwZWRFYXNlO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHRpZiAocCA8IDApIHtcblx0XHRcdFx0cCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHAgPj0gMSkge1xuXHRcdFx0XHRwID0gMC45OTk5OTk5OTk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKCh0aGlzLl9wMiAqIHApID4+IDApICogdGhpcy5fcDE7XG5cdFx0fTtcblx0XHRwLmNvbmZpZyA9IFN0ZXBwZWRFYXNlLmNvbmZpZyA9IGZ1bmN0aW9uKHN0ZXBzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFN0ZXBwZWRFYXNlKHN0ZXBzKTtcblx0XHR9O1xuXG5cblx0XHQvL1JvdWdoRWFzZVxuXHRcdFJvdWdoRWFzZSA9IF9jbGFzcyhcImVhc2luZy5Sb3VnaEVhc2VcIiwgZnVuY3Rpb24odmFycykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHR2YXIgdGFwZXIgPSB2YXJzLnRhcGVyIHx8IFwibm9uZVwiLFxuXHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdHBvaW50cyA9ICh2YXJzLnBvaW50cyB8fCAyMCkgfCAwLFxuXHRcdFx0XHRpID0gcG9pbnRzLFxuXHRcdFx0XHRyYW5kb21pemUgPSAodmFycy5yYW5kb21pemUgIT09IGZhbHNlKSxcblx0XHRcdFx0Y2xhbXAgPSAodmFycy5jbGFtcCA9PT0gdHJ1ZSksXG5cdFx0XHRcdHRlbXBsYXRlID0gKHZhcnMudGVtcGxhdGUgaW5zdGFuY2VvZiBFYXNlKSA/IHZhcnMudGVtcGxhdGUgOiBudWxsLFxuXHRcdFx0XHRzdHJlbmd0aCA9ICh0eXBlb2YodmFycy5zdHJlbmd0aCkgPT09IFwibnVtYmVyXCIpID8gdmFycy5zdHJlbmd0aCAqIDAuNCA6IDAuNCxcblx0XHRcdFx0eCwgeSwgYnVtcCwgaW52WCwgb2JqLCBwbnQ7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0eCA9IHJhbmRvbWl6ZSA/IE1hdGgucmFuZG9tKCkgOiAoMSAvIHBvaW50cykgKiBpO1xuXHRcdFx0XHR5ID0gdGVtcGxhdGUgPyB0ZW1wbGF0ZS5nZXRSYXRpbyh4KSA6IHg7XG5cdFx0XHRcdGlmICh0YXBlciA9PT0gXCJub25lXCIpIHtcblx0XHRcdFx0XHRidW1wID0gc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFwZXIgPT09IFwib3V0XCIpIHtcblx0XHRcdFx0XHRpbnZYID0gMSAtIHg7XG5cdFx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFwZXIgPT09IFwiaW5cIikge1xuXHRcdFx0XHRcdGJ1bXAgPSB4ICogeCAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHggPCAwLjUpIHsgIC8vXCJib3RoXCIgKHN0YXJ0KVxuXHRcdFx0XHRcdGludlggPSB4ICogMjtcblx0XHRcdFx0XHRidW1wID0gaW52WCAqIGludlggKiAwLjUgKiBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcdFx0XHRcdC8vXCJib3RoXCIgKGVuZClcblx0XHRcdFx0XHRpbnZYID0gKDEgLSB4KSAqIDI7XG5cdFx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogMC41ICogc3RyZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJhbmRvbWl6ZSkge1xuXHRcdFx0XHRcdHkgKz0gKE1hdGgucmFuZG9tKCkgKiBidW1wKSAtIChidW1wICogMC41KTtcblx0XHRcdFx0fSBlbHNlIGlmIChpICUgMikge1xuXHRcdFx0XHRcdHkgKz0gYnVtcCAqIDAuNTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5IC09IGJ1bXAgKiAwLjU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNsYW1wKSB7XG5cdFx0XHRcdFx0aWYgKHkgPiAxKSB7XG5cdFx0XHRcdFx0XHR5ID0gMTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHkgPCAwKSB7XG5cdFx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtjbnQrK10gPSB7eDp4LCB5Onl9O1xuXHRcdFx0fVxuXHRcdFx0YS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuIGEueCAtIGIueDtcblx0XHRcdH0pO1xuXG5cdFx0XHRwbnQgPSBuZXcgRWFzZVBvaW50KDEsIDEsIG51bGwpO1xuXHRcdFx0aSA9IHBvaW50cztcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRvYmogPSBhW2ldO1xuXHRcdFx0XHRwbnQgPSBuZXcgRWFzZVBvaW50KG9iai54LCBvYmoueSwgcG50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcHJldiA9IG5ldyBFYXNlUG9pbnQoMCwgMCwgKHBudC50ICE9PSAwKSA/IHBudCA6IHBudC5uZXh0KTtcblx0XHR9LCB0cnVlKTtcblx0XHRwID0gUm91Z2hFYXNlLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFJvdWdoRWFzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0dmFyIHBudCA9IHRoaXMuX3ByZXY7XG5cdFx0XHRpZiAocCA+IHBudC50KSB7XG5cdFx0XHRcdHdoaWxlIChwbnQubmV4dCAmJiBwID49IHBudC50KSB7XG5cdFx0XHRcdFx0cG50ID0gcG50Lm5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG50ID0gcG50LnByZXY7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAocG50LnByZXYgJiYgcCA8PSBwbnQudCkge1xuXHRcdFx0XHRcdHBudCA9IHBudC5wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9wcmV2ID0gcG50O1xuXHRcdFx0cmV0dXJuIChwbnQudiArICgocCAtIHBudC50KSAvIHBudC5nYXApICogcG50LmMpO1xuXHRcdH07XG5cdFx0cC5jb25maWcgPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFJvdWdoRWFzZSh2YXJzKTtcblx0XHR9O1xuXHRcdFJvdWdoRWFzZS5lYXNlID0gbmV3IFJvdWdoRWFzZSgpO1xuXG5cblx0XHQvL0JvdW5jZVxuXHRcdF93cmFwKFwiQm91bmNlXCIsXG5cdFx0XHRfY3JlYXRlKFwiQm91bmNlT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKHAgPCAxIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiBwICogcDtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMiAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMi41IC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1O1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQm91bmNlSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAoKHAgPSAxIC0gcCkgPCAxIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIHAgKiBwKTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMiAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAxLjUgLyAyLjc1KSAqIHAgKyAwLjc1KTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMi41IC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIChwIC09IDIuMjUgLyAyLjc1KSAqIHAgKyAwLjkzNzUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIChwIC09IDIuNjI1IC8gMi43NSkgKiBwICsgMC45ODQzNzUpO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQm91bmNlSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHR2YXIgaW52ZXJ0ID0gKHAgPCAwLjUpO1xuXHRcdFx0XHRpZiAoaW52ZXJ0KSB7XG5cdFx0XHRcdFx0cCA9IDEgLSAocCAqIDIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHAgPSAocCAqIDIpIC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocCA8IDEgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIHAgKiBwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyIC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAxLjUgLyAyLjc1KSAqIHAgKyAwLjc1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyLjUgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIChwIC09IDIuMjUgLyAyLjc1KSAqIHAgKyAwLjkzNzU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIChwIC09IDIuNjI1IC8gMi43NSkgKiBwICsgMC45ODQzNzU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGludmVydCA/ICgxIC0gcCkgKiAwLjUgOiBwICogMC41ICsgMC41O1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cblx0XHQvL0NJUkNcblx0XHRfd3JhcChcIkNpcmNcIixcblx0XHRcdF9jcmVhdGUoXCJDaXJjT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydCgxIC0gKHAgPSBwIC0gMSkgKiBwKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkNpcmNJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtKE1hdGguc3FydCgxIC0gKHAgKiBwKSkgLSAxKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkNpcmNJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAoKHAqPTIpIDwgMSkgPyAtMC41ICogKE1hdGguc3FydCgxIC0gcCAqIHApIC0gMSkgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAocCAtPSAyKSAqIHApICsgMSk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblxuXHRcdC8vRWxhc3RpY1xuXHRcdF9jcmVhdGVFbGFzdGljID0gZnVuY3Rpb24obiwgZiwgZGVmKSB7XG5cdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIiArIG4sIGZ1bmN0aW9uKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG5cdFx0XHRcdFx0dGhpcy5fcDEgPSAoYW1wbGl0dWRlID49IDEpID8gYW1wbGl0dWRlIDogMTsgLy9ub3RlOiBpZiBhbXBsaXR1ZGUgaXMgPCAxLCB3ZSBzaW1wbHkgYWRqdXN0IHRoZSBwZXJpb2QgZm9yIGEgbW9yZSBuYXR1cmFsIGZlZWwuIE90aGVyd2lzZSB0aGUgbWF0aCBkb2Vzbid0IHdvcmsgcmlnaHQgYW5kIHRoZSBjdXJ2ZSBzdGFydHMgYXQgMS5cblx0XHRcdFx0XHR0aGlzLl9wMiA9IChwZXJpb2QgfHwgZGVmKSAvIChhbXBsaXR1ZGUgPCAxID8gYW1wbGl0dWRlIDogMSk7XG5cdFx0XHRcdFx0dGhpcy5fcDMgPSB0aGlzLl9wMiAvIF8yUEkgKiAoTWF0aC5hc2luKDEgLyB0aGlzLl9wMSkgfHwgMCk7XG5cdFx0XHRcdFx0dGhpcy5fcDIgPSBfMlBJIC8gdGhpcy5fcDI7IC8vcHJlY2FsY3VsYXRlIHRvIG9wdGltaXplXG5cdFx0XHRcdH0sIHRydWUpLFxuXHRcdFx0XHRwID0gQy5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdFx0cC5jb25zdHJ1Y3RvciA9IEM7XG5cdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdHAuY29uZmlnID0gZnVuY3Rpb24oYW1wbGl0dWRlLCBwZXJpb2QpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBDKGFtcGxpdHVkZSwgcGVyaW9kKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gQztcblx0XHR9O1xuXHRcdF93cmFwKFwiRWxhc3RpY1wiLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3AxICogTWF0aC5wb3coMiwgLTEwICogcCkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMiApICsgMTtcblx0XHRcdH0sIDAuMyksXG5cdFx0XHRfY3JlYXRlRWxhc3RpYyhcIkVsYXN0aWNJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtKHRoaXMuX3AxICogTWF0aC5wb3coMiwgMTAgKiAocCAtPSAxKSkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMiApKTtcblx0XHRcdH0sIDAuMyksXG5cdFx0XHRfY3JlYXRlRWxhc3RpYyhcIkVsYXN0aWNJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAoKHAgKj0gMikgPCAxKSA/IC0wLjUgKiAodGhpcy5fcDEgKiBNYXRoLnBvdygyLCAxMCAqIChwIC09IDEpKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyKSkgOiB0aGlzLl9wMSAqIE1hdGgucG93KDIsIC0xMCAqKHAgLT0gMSkpICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSAqIDAuNSArIDE7XG5cdFx0XHR9LCAwLjQ1KVxuXHRcdCk7XG5cblxuXHRcdC8vRXhwb1xuXHRcdF93cmFwKFwiRXhwb1wiLFxuXHRcdFx0X2NyZWF0ZShcIkV4cG9PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIHApO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiRXhwb0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgLSAwLjAwMTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkV4cG9Jbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAoKHAgKj0gMikgPCAxKSA/IDAuNSAqIE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwIC0gMSkpKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXG5cdFx0Ly9TaW5lXG5cdFx0X3dyYXAoXCJTaW5lXCIsXG5cdFx0XHRfY3JlYXRlKFwiU2luZU91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNpbihwICogX0hBTEZfUEkpO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiU2luZUluXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC1NYXRoLmNvcyhwICogX0hBTEZfUEkpICsgMTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiBwKSAtIDEpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cdFx0X2NsYXNzKFwiZWFzaW5nLkVhc2VMb29rdXBcIiwge1xuXHRcdFx0XHRmaW5kOmZ1bmN0aW9uKHMpIHtcblx0XHRcdFx0XHRyZXR1cm4gRWFzZS5tYXBbc107XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRydWUpO1xuXG5cdFx0Ly9yZWdpc3RlciB0aGUgbm9uLXN0YW5kYXJkIGVhc2VzXG5cdFx0X2Vhc2VSZWcody5TbG93TW8sIFwiU2xvd01vXCIsIFwiZWFzZSxcIik7XG5cdFx0X2Vhc2VSZWcoUm91Z2hFYXNlLCBcIlJvdWdoRWFzZVwiLCBcImVhc2UsXCIpO1xuXHRcdF9lYXNlUmVnKFN0ZXBwZWRFYXNlLCBcIlN0ZXBwZWRFYXNlXCIsIFwiZWFzZSxcIik7XG5cblx0XHRyZXR1cm4gQmFjaztcblx0XHRcblx0fSwgdHJ1ZSk7XG5cblxufSk7XG5cbmlmIChfZ3NTY29wZS5fZ3NEZWZpbmUpIHsgX2dzU2NvcGUuX2dzUXVldWUucG9wKCkoKTsgfSAvL25lY2Vzc2FyeSBpbiBjYXNlIFR3ZWVuTGl0ZSB3YXMgYWxyZWFkeSBsb2FkZWQgc2VwYXJhdGVseS5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQmFzZSBjbGFzc2VzIGxpa2UgVHdlZW5MaXRlLCBTaW1wbGVUaW1lbGluZSwgRWFzZSwgVGlja2VyLCBldGMuXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbihmdW5jdGlvbih3aW5kb3csIG1vZHVsZU5hbWUpIHtcblxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfZ2xvYmFscyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93LkdyZWVuU29ja0dsb2JhbHMgfHwgd2luZG93O1xuXHRcdGlmIChfZ2xvYmFscy5Ud2VlbkxpdGUpIHtcblx0XHRcdHJldHVybjsgLy9pbiBjYXNlIHRoZSBjb3JlIHNldCBvZiBjbGFzc2VzIGlzIGFscmVhZHkgbG9hZGVkLCBkb24ndCBpbnN0YW50aWF0ZSB0d2ljZS5cblx0XHR9XG5cdFx0dmFyIF9uYW1lc3BhY2UgPSBmdW5jdGlvbihucykge1xuXHRcdFx0XHR2YXIgYSA9IG5zLnNwbGl0KFwiLlwiKSxcblx0XHRcdFx0XHRwID0gX2dsb2JhbHMsIGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cFthW2ldXSA9IHAgPSBwW2FbaV1dIHx8IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0fSxcblx0XHRcdGdzID0gX25hbWVzcGFjZShcImNvbS5ncmVlbnNvY2tcIiksXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGFyZ2V0LCAwKSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHR2YXIgYiA9IFtdLFxuXHRcdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpICE9PSBsOyBiLnB1c2goYVtpKytdKSkge31cblx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHR9LFxuXHRcdFx0X2VtcHR5RnVuYyA9IGZ1bmN0aW9uKCkge30sXG5cdFx0XHRfaXNBcnJheSA9IChmdW5jdGlvbigpIHsgLy93b3JrcyBhcm91bmQgaXNzdWVzIGluIGlmcmFtZSBlbnZpcm9ubWVudHMgd2hlcmUgdGhlIEFycmF5IGdsb2JhbCBpc24ndCBzaGFyZWQsIHRodXMgaWYgdGhlIG9iamVjdCBvcmlnaW5hdGVzIGluIGEgZGlmZmVyZW50IHdpbmRvdy9pZnJhbWUsIFwiKG9iaiBpbnN0YW5jZW9mIEFycmF5KVwiIHdpbGwgZXZhbHVhdGUgZmFsc2UuIFdlIGFkZGVkIHNvbWUgc3BlZWQgb3B0aW1pemF0aW9ucyB0byBhdm9pZCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoKSB1bmxlc3MgaXQncyBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSBiZWNhdXNlIGl0J3MgVkVSWSBzbG93IChsaWtlIDIweCBzbG93ZXIpXG5cdFx0XHRcdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdFx0XHRcdFx0YXJyYXkgPSB0b1N0cmluZy5jYWxsKFtdKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiAob2JqIGluc3RhbmNlb2YgQXJyYXkgfHwgKHR5cGVvZihvYmopID09PSBcIm9iamVjdFwiICYmICEhb2JqLnB1c2ggJiYgdG9TdHJpbmcuY2FsbChvYmopID09PSBhcnJheSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSgpKSxcblx0XHRcdGEsIGksIHAsIF90aWNrZXIsIF90aWNrZXJBY3RpdmUsXG5cdFx0XHRfZGVmTG9va3VwID0ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0XHQgKiBEZWZpbmVzIGEgR3JlZW5Tb2NrIGNsYXNzLCBvcHRpb25hbGx5IHdpdGggYW4gYXJyYXkgb2YgZGVwZW5kZW5jaWVzIHRoYXQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgZmlyc3QgYW5kIHBhc3NlZCBpbnRvIHRoZSBkZWZpbml0aW9uLlxuXHRcdFx0ICogVGhpcyBhbGxvd3MgdXNlcnMgdG8gbG9hZCBHcmVlblNvY2sgSlMgZmlsZXMgaW4gYW55IG9yZGVyIGV2ZW4gaWYgdGhleSBoYXZlIGludGVyZGVwZW5kZW5jaWVzIChsaWtlIENTU1BsdWdpbiBleHRlbmRzIFR3ZWVuUGx1Z2luIHdoaWNoIGlzXG5cdFx0XHQgKiBpbnNpZGUgVHdlZW5MaXRlLmpzLCBidXQgaWYgQ1NTUGx1Z2luIGlzIGxvYWRlZCBmaXJzdCwgaXQgc2hvdWxkIHdhaXQgdG8gcnVuIGl0cyBjb2RlIHVudGlsIFR3ZWVuTGl0ZS5qcyBsb2FkcyBhbmQgaW5zdGFudGlhdGVzIFR3ZWVuUGx1Z2luXG5cdFx0XHQgKiBhbmQgdGhlbiBwYXNzIFR3ZWVuUGx1Z2luIHRvIENTU1BsdWdpbidzIGRlZmluaXRpb24pLiBUaGlzIGlzIGFsbCBkb25lIGF1dG9tYXRpY2FsbHkgYW5kIGludGVybmFsbHkuXG5cdFx0XHQgKlxuXHRcdFx0ICogRXZlcnkgZGVmaW5pdGlvbiB3aWxsIGJlIGFkZGVkIHRvIGEgXCJjb20uZ3JlZW5zb2NrXCIgZ2xvYmFsIG9iamVjdCAodHlwaWNhbGx5IHdpbmRvdywgYnV0IGlmIGEgd2luZG93LkdyZWVuU29ja0dsb2JhbHMgb2JqZWN0IGlzIGZvdW5kLFxuXHRcdFx0ICogaXQgd2lsbCBnbyB0aGVyZSBhcyBvZiB2MS43KS4gRm9yIGV4YW1wbGUsIFR3ZWVuTGl0ZSB3aWxsIGJlIGZvdW5kIGF0IHdpbmRvdy5jb20uZ3JlZW5zb2NrLlR3ZWVuTGl0ZSBhbmQgc2luY2UgaXQncyBhIGdsb2JhbCBjbGFzcyB0aGF0IHNob3VsZCBiZSBhdmFpbGFibGUgYW55d2hlcmUsXG5cdFx0XHQgKiBpdCBpcyBBTFNPIHJlZmVyZW5jZWQgYXQgd2luZG93LlR3ZWVuTGl0ZS4gSG93ZXZlciBzb21lIGNsYXNzZXMgYXJlbid0IGNvbnNpZGVyZWQgZ2xvYmFsLCBsaWtlIHRoZSBiYXNlIGNvbS5ncmVlbnNvY2suY29yZS5BbmltYXRpb24gY2xhc3MsIHNvXG5cdFx0XHQgKiB0aG9zZSB3aWxsIG9ubHkgYmUgYXQgdGhlIHBhY2thZ2UgbGlrZSB3aW5kb3cuY29tLmdyZWVuc29jay5jb3JlLkFuaW1hdGlvbi4gQWdhaW4sIGlmIHlvdSBkZWZpbmUgYSBHcmVlblNvY2tHbG9iYWxzIG9iamVjdCBvbiB0aGUgd2luZG93LCBldmVyeXRoaW5nXG5cdFx0XHQgKiBnZXRzIHR1Y2tlZCBuZWF0bHkgaW5zaWRlIHRoZXJlIGluc3RlYWQgb2Ygb24gdGhlIHdpbmRvdyBkaXJlY3RseS4gVGhpcyBhbGxvd3MgeW91IHRvIGRvIGFkdmFuY2VkIHRoaW5ncyBsaWtlIGxvYWQgbXVsdGlwbGUgdmVyc2lvbnMgb2YgR3JlZW5Tb2NrXG5cdFx0XHQgKiBmaWxlcyBhbmQgcHV0IHRoZW0gaW50byBkaXN0aW5jdCBvYmplY3RzIChpbWFnaW5lIGEgYmFubmVyIGFkIHVzZXMgYSBuZXdlciB2ZXJzaW9uIGJ1dCB0aGUgbWFpbiBzaXRlIHVzZXMgYW4gb2xkZXIgb25lKS4gSW4gdGhhdCBjYXNlLCB5b3UgY291bGRcblx0XHRcdCAqIHNhbmRib3ggdGhlIGJhbm5lciBvbmUgbGlrZTpcblx0XHRcdCAqXG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIHZhciBncyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0ge307IC8vdGhlIG5ld2VyIHZlcnNpb24gd2UncmUgYWJvdXQgdG8gbG9hZCBjb3VsZCBub3cgYmUgcmVmZXJlbmNlZCBpbiBhIFwiZ3NcIiBvYmplY3QsIGxpa2UgZ3MuVHdlZW5MaXRlLnRvKC4uLikuIFVzZSB3aGF0ZXZlciBhbGlhcyB5b3Ugd2FudCBhcyBsb25nIGFzIGl0J3MgdW5pcXVlLCBcImdzXCIgb3IgXCJiYW5uZXJcIiBvciB3aGF0ZXZlci5cblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdCBzcmM9XCJqcy9ncmVlbnNvY2svdjEuNy9Ud2Vlbk1heC5qc1wiPjwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdD5cblx0XHRcdCAqICAgICB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHdpbmRvdy5fZ3NRdWV1ZSA9IHdpbmRvdy5fZ3NEZWZpbmUgPSBudWxsOyAvL3Jlc2V0IGl0IGJhY2sgdG8gbnVsbCAoYWxvbmcgd2l0aCB0aGUgc3BlY2lhbCBfZ3NRdWV1ZSB2YXJpYWJsZSkgc28gdGhhdCB0aGUgbmV4dCBsb2FkIG9mIFR3ZWVuTWF4IGFmZmVjdHMgdGhlIHdpbmRvdyBhbmQgd2UgY2FuIHJlZmVyZW5jZSB0aGluZ3MgZGlyZWN0bHkgbGlrZSBUd2VlbkxpdGUudG8oLi4uKVxuXHRcdFx0ICogPC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0IHNyYz1cImpzL2dyZWVuc29jay92MS42L1R3ZWVuTWF4LmpzXCI+PC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIGdzLlR3ZWVuTGl0ZS50byguLi4pOyAvL3dvdWxkIHVzZSB2MS43XG5cdFx0XHQgKiAgICAgVHdlZW5MaXRlLnRvKC4uLik7IC8vd291bGQgdXNlIHYxLjZcblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gbnMgVGhlIG5hbWVzcGFjZSBvZiB0aGUgY2xhc3MgZGVmaW5pdGlvbiwgbGVhdmluZyBvZmYgXCJjb20uZ3JlZW5zb2NrLlwiIGFzIHRoYXQncyBhc3N1bWVkLiBGb3IgZXhhbXBsZSwgXCJUd2VlbkxpdGVcIiBvciBcInBsdWdpbnMuQ1NTUGx1Z2luXCIgb3IgXCJlYXNpbmcuQmFja1wiLlxuXHRcdFx0ICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGRlcGVuZGVuY2llcyBBbiBhcnJheSBvZiBkZXBlbmRlbmNpZXMgKGRlc2NyaWJlZCBhcyB0aGVpciBuYW1lc3BhY2VzIG1pbnVzIFwiY29tLmdyZWVuc29jay5cIiBwcmVmaXgpLiBGb3IgZXhhbXBsZSBbXCJUd2VlbkxpdGVcIixcInBsdWdpbnMuVHdlZW5QbHVnaW5cIixcImNvcmUuQW5pbWF0aW9uXCJdXG5cdFx0XHQgKiBAcGFyYW0geyFmdW5jdGlvbigpOk9iamVjdH0gZnVuYyBUaGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIGFuZCBwYXNzZWQgdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llcyB3aGljaCB3aWxsIHJldHVybiB0aGUgYWN0dWFsIGNsYXNzIGZvciB0aGlzIGRlZmluaXRpb24uXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBnbG9iYWwgSWYgdHJ1ZSwgdGhlIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGdsb2JhbCBzY29wZSAodHlwaWNhbGx5IHdpbmRvdyB1bmxlc3MgeW91IGRlZmluZSBhIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzIG9iamVjdClcblx0XHRcdCAqL1xuXHRcdFx0RGVmaW5pdGlvbiA9IGZ1bmN0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHR0aGlzLnNjID0gKF9kZWZMb29rdXBbbnNdKSA/IF9kZWZMb29rdXBbbnNdLnNjIDogW107IC8vc3ViY2xhc3Nlc1xuXHRcdFx0XHRfZGVmTG9va3VwW25zXSA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZ3NDbGFzcyA9IG51bGw7XG5cdFx0XHRcdHRoaXMuZnVuYyA9IGZ1bmM7XG5cdFx0XHRcdHZhciBfY2xhc3NlcyA9IFtdO1xuXHRcdFx0XHR0aGlzLmNoZWNrID0gZnVuY3Rpb24oaW5pdCkge1xuXHRcdFx0XHRcdHZhciBpID0gZGVwZW5kZW5jaWVzLmxlbmd0aCxcblx0XHRcdFx0XHRcdG1pc3NpbmcgPSBpLFxuXHRcdFx0XHRcdFx0Y3VyLCBhLCBuLCBjbCwgaGFzTW9kdWxlO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKChjdXIgPSBfZGVmTG9va3VwW2RlcGVuZGVuY2llc1tpXV0gfHwgbmV3IERlZmluaXRpb24oZGVwZW5kZW5jaWVzW2ldLCBbXSkpLmdzQ2xhc3MpIHtcblx0XHRcdFx0XHRcdFx0X2NsYXNzZXNbaV0gPSBjdXIuZ3NDbGFzcztcblx0XHRcdFx0XHRcdFx0bWlzc2luZy0tO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpbml0KSB7XG5cdFx0XHRcdFx0XHRcdGN1ci5zYy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWlzc2luZyA9PT0gMCAmJiBmdW5jKSB7XG5cdFx0XHRcdFx0XHRhID0gKFwiY29tLmdyZWVuc29jay5cIiArIG5zKS5zcGxpdChcIi5cIik7XG5cdFx0XHRcdFx0XHRuID0gYS5wb3AoKTtcblx0XHRcdFx0XHRcdGNsID0gX25hbWVzcGFjZShhLmpvaW4oXCIuXCIpKVtuXSA9IHRoaXMuZ3NDbGFzcyA9IGZ1bmMuYXBwbHkoZnVuYywgX2NsYXNzZXMpO1xuXG5cdFx0XHRcdFx0XHQvL2V4cG9ydHMgdG8gbXVsdGlwbGUgZW52aXJvbm1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoZ2xvYmFsKSB7XG5cdFx0XHRcdFx0XHRcdF9nbG9iYWxzW25dID0gY2w7IC8vcHJvdmlkZXMgYSB3YXkgdG8gYXZvaWQgZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb24uIEJ5IGRlZmF1bHQsIHRoZSBtYWluIGNsYXNzZXMgbGlrZSBUd2VlbkxpdGUsIFBvd2VyMSwgU3Ryb25nLCBldGMuIGFyZSBhZGRlZCB0byB3aW5kb3cgdW5sZXNzIGEgR3JlZW5Tb2NrR2xvYmFscyBpcyBkZWZpbmVkLiBTbyBpZiB5b3Ugd2FudCB0byBoYXZlIHRoaW5ncyBhZGRlZCB0byBhIGN1c3RvbSBvYmplY3QgaW5zdGVhZCwganVzdCBkbyBzb21ldGhpbmcgbGlrZSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHt9IGJlZm9yZSBsb2FkaW5nIGFueSBHcmVlblNvY2sgZmlsZXMuIFlvdSBjYW4gZXZlbiBzZXQgdXAgYW4gYWxpYXMgbGlrZSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHdpbmRvd3MuZ3MgPSB7fSBzbyB0aGF0IHlvdSBjYW4gYWNjZXNzIGV2ZXJ5dGhpbmcgbGlrZSBncy5Ud2VlbkxpdGUuIEFsc28gcmVtZW1iZXIgdGhhdCBBTEwgY2xhc3NlcyBhcmUgYWRkZWQgdG8gdGhlIHdpbmRvdy5jb20uZ3JlZW5zb2NrIG9iamVjdCAoaW4gdGhlaXIgcmVzcGVjdGl2ZSBwYWNrYWdlcywgbGlrZSBjb20uZ3JlZW5zb2NrLmVhc2luZy5Qb3dlcjEsIGNvbS5ncmVlbnNvY2suVHdlZW5MaXRlLCBldGMuKVxuXHRcdFx0XHRcdFx0XHRoYXNNb2R1bGUgPSAodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIWhhc01vZHVsZSAmJiB0eXBlb2YoZGVmaW5lKSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpeyAvL0FNRFxuXHRcdFx0XHRcdFx0XHRcdGRlZmluZSgod2luZG93LkdyZWVuU29ja0FNRFBhdGggPyB3aW5kb3cuR3JlZW5Tb2NrQU1EUGF0aCArIFwiL1wiIDogXCJcIikgKyBucy5zcGxpdChcIi5cIikucG9wKCksIFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNsOyB9KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChucyA9PT0gbW9kdWxlTmFtZSAmJiBoYXNNb2R1bGUpeyAvL25vZGVcblx0XHRcdFx0XHRcdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5zYy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNjW2ldLmNoZWNrKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmNoZWNrKHRydWUpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly91c2VkIHRvIGNyZWF0ZSBEZWZpbml0aW9uIGluc3RhbmNlcyAod2hpY2ggYmFzaWNhbGx5IHJlZ2lzdGVycyBhIGNsYXNzIHRoYXQgaGFzIGRlcGVuZGVuY2llcykuXG5cdFx0XHRfZ3NEZWZpbmUgPSB3aW5kb3cuX2dzRGVmaW5lID0gZnVuY3Rpb24obnMsIGRlcGVuZGVuY2llcywgZnVuYywgZ2xvYmFsKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgRGVmaW5pdGlvbihucywgZGVwZW5kZW5jaWVzLCBmdW5jLCBnbG9iYWwpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9hIHF1aWNrIHdheSB0byBjcmVhdGUgYSBjbGFzcyB0aGF0IGRvZXNuJ3QgaGF2ZSBhbnkgZGVwZW5kZW5jaWVzLiBSZXR1cm5zIHRoZSBjbGFzcywgYnV0IGZpcnN0IHJlZ2lzdGVycyBpdCBpbiB0aGUgR3JlZW5Tb2NrIG5hbWVzcGFjZSBzbyB0aGF0IG90aGVyIGNsYXNzZXMgY2FuIGdyYWIgaXQgKG90aGVyIGNsYXNzZXMgbWlnaHQgYmUgZGVwZW5kZW50IG9uIHRoZSBjbGFzcykuXG5cdFx0XHRfY2xhc3MgPSBncy5fY2xhc3MgPSBmdW5jdGlvbihucywgZnVuYywgZ2xvYmFsKSB7XG5cdFx0XHRcdGZ1bmMgPSBmdW5jIHx8IGZ1bmN0aW9uKCkge307XG5cdFx0XHRcdF9nc0RlZmluZShucywgW10sIGZ1bmN0aW9uKCl7IHJldHVybiBmdW5jOyB9LCBnbG9iYWwpO1xuXHRcdFx0XHRyZXR1cm4gZnVuYztcblx0XHRcdH07XG5cblx0XHRfZ3NEZWZpbmUuZ2xvYmFscyA9IF9nbG9iYWxzO1xuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEVhc2VcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBfYmFzZVBhcmFtcyA9IFswLCAwLCAxLCAxXSxcblx0XHRcdF9ibGFua0FycmF5ID0gW10sXG5cdFx0XHRFYXNlID0gX2NsYXNzKFwiZWFzaW5nLkVhc2VcIiwgZnVuY3Rpb24oZnVuYywgZXh0cmFQYXJhbXMsIHR5cGUsIHBvd2VyKSB7XG5cdFx0XHRcdHRoaXMuX2Z1bmMgPSBmdW5jO1xuXHRcdFx0XHR0aGlzLl90eXBlID0gdHlwZSB8fCAwO1xuXHRcdFx0XHR0aGlzLl9wb3dlciA9IHBvd2VyIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3BhcmFtcyA9IGV4dHJhUGFyYW1zID8gX2Jhc2VQYXJhbXMuY29uY2F0KGV4dHJhUGFyYW1zKSA6IF9iYXNlUGFyYW1zO1xuXHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRfZWFzZU1hcCA9IEVhc2UubWFwID0ge30sXG5cdFx0XHRfZWFzZVJlZyA9IEVhc2UucmVnaXN0ZXIgPSBmdW5jdGlvbihlYXNlLCBuYW1lcywgdHlwZXMsIGNyZWF0ZSkge1xuXHRcdFx0XHR2YXIgbmEgPSBuYW1lcy5zcGxpdChcIixcIiksXG5cdFx0XHRcdFx0aSA9IG5hLmxlbmd0aCxcblx0XHRcdFx0XHR0YSA9ICh0eXBlcyB8fCBcImVhc2VJbixlYXNlT3V0LGVhc2VJbk91dFwiKS5zcGxpdChcIixcIiksXG5cdFx0XHRcdFx0ZSwgbmFtZSwgaiwgdHlwZTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0bmFtZSA9IG5hW2ldO1xuXHRcdFx0XHRcdGUgPSBjcmVhdGUgPyBfY2xhc3MoXCJlYXNpbmcuXCIrbmFtZSwgbnVsbCwgdHJ1ZSkgOiBncy5lYXNpbmdbbmFtZV0gfHwge307XG5cdFx0XHRcdFx0aiA9IHRhLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSB0YVtqXTtcblx0XHRcdFx0XHRcdF9lYXNlTWFwW25hbWUgKyBcIi5cIiArIHR5cGVdID0gX2Vhc2VNYXBbdHlwZSArIG5hbWVdID0gZVt0eXBlXSA9IGVhc2UuZ2V0UmF0aW8gPyBlYXNlIDogZWFzZVt0eXBlXSB8fCBuZXcgZWFzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdHAgPSBFYXNlLnByb3RvdHlwZTtcblx0XHRwLl9jYWxjRW5kID0gZmFsc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdGlmICh0aGlzLl9mdW5jKSB7XG5cdFx0XHRcdHRoaXMuX3BhcmFtc1swXSA9IHA7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9mdW5jLmFwcGx5KG51bGwsIHRoaXMuX3BhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdCA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHB3ID0gdGhpcy5fcG93ZXIsXG5cdFx0XHRcdHIgPSAodCA9PT0gMSkgPyAxIC0gcCA6ICh0ID09PSAyKSA/IHAgOiAocCA8IDAuNSkgPyBwICogMiA6ICgxIC0gcCkgKiAyO1xuXHRcdFx0aWYgKHB3ID09PSAxKSB7XG5cdFx0XHRcdHIgKj0gcjtcblx0XHRcdH0gZWxzZSBpZiAocHcgPT09IDIpIHtcblx0XHRcdFx0ciAqPSByICogcjtcblx0XHRcdH0gZWxzZSBpZiAocHcgPT09IDMpIHtcblx0XHRcdFx0ciAqPSByICogciAqIHI7XG5cdFx0XHR9IGVsc2UgaWYgKHB3ID09PSA0KSB7XG5cdFx0XHRcdHIgKj0gciAqIHIgKiByICogcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodCA9PT0gMSkgPyAxIC0gciA6ICh0ID09PSAyKSA/IHIgOiAocCA8IDAuNSkgPyByIC8gMiA6IDEgLSAociAvIDIpO1xuXHRcdH07XG5cblx0XHQvL2NyZWF0ZSBhbGwgdGhlIHN0YW5kYXJkIGVhc2VzIGxpa2UgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgYW5kIFBvd2VyNCAoZWFjaCB3aXRoIGVhc2VJbiwgZWFzZU91dCwgYW5kIGVhc2VJbk91dClcblx0XHRhID0gW1wiTGluZWFyXCIsXCJRdWFkXCIsXCJDdWJpY1wiLFwiUXVhcnRcIixcIlF1aW50LFN0cm9uZ1wiXTtcblx0XHRpID0gYS5sZW5ndGg7XG5cdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRwID0gYVtpXStcIixQb3dlclwiK2k7XG5cdFx0XHRfZWFzZVJlZyhuZXcgRWFzZShudWxsLG51bGwsMSxpKSwgcCwgXCJlYXNlT3V0XCIsIHRydWUpO1xuXHRcdFx0X2Vhc2VSZWcobmV3IEVhc2UobnVsbCxudWxsLDIsaSksIHAsIFwiZWFzZUluXCIgKyAoKGkgPT09IDApID8gXCIsZWFzZU5vbmVcIiA6IFwiXCIpKTtcblx0XHRcdF9lYXNlUmVnKG5ldyBFYXNlKG51bGwsbnVsbCwzLGkpLCBwLCBcImVhc2VJbk91dFwiKTtcblx0XHR9XG5cdFx0X2Vhc2VNYXAubGluZWFyID0gZ3MuZWFzaW5nLkxpbmVhci5lYXNlSW47XG5cdFx0X2Vhc2VNYXAuc3dpbmcgPSBncy5lYXNpbmcuUXVhZC5lYXNlSW5PdXQ7IC8vZm9yIGpRdWVyeSBmb2xrc1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBFdmVudERpc3BhdGNoZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBFdmVudERpc3BhdGNoZXIgPSBfY2xhc3MoXCJldmVudHMuRXZlbnREaXNwYXRjaGVyXCIsIGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdFx0dGhpcy5fbGlzdGVuZXJzID0ge307XG5cdFx0XHR0aGlzLl9ldmVudFRhcmdldCA9IHRhcmdldCB8fCB0aGlzO1xuXHRcdH0pO1xuXHRcdHAgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xuXG5cdFx0cC5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2ssIHNjb3BlLCB1c2VQYXJhbSwgcHJpb3JpdHkpIHtcblx0XHRcdHByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcblx0XHRcdHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxpc3RlbmVyLCBpO1xuXHRcdFx0aWYgKGxpc3QgPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBsaXN0ID0gW107XG5cdFx0XHR9XG5cdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0bGlzdGVuZXIgPSBsaXN0W2ldO1xuXHRcdFx0XHRpZiAobGlzdGVuZXIuYyA9PT0gY2FsbGJhY2sgJiYgbGlzdGVuZXIucyA9PT0gc2NvcGUpIHtcblx0XHRcdFx0XHRsaXN0LnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpbmRleCA9PT0gMCAmJiBsaXN0ZW5lci5wciA8IHByaW9yaXR5KSB7XG5cdFx0XHRcdFx0aW5kZXggPSBpICsgMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGlzdC5zcGxpY2UoaW5kZXgsIDAsIHtjOmNhbGxiYWNrLCBzOnNjb3BlLCB1cDp1c2VQYXJhbSwgcHI6cHJpb3JpdHl9KTtcblx0XHRcdGlmICh0aGlzID09PSBfdGlja2VyICYmICFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sIGk7XG5cdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChsaXN0W2ldLmMgPT09IGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sXG5cdFx0XHRcdGksIHQsIGxpc3RlbmVyO1xuXHRcdFx0aWYgKGxpc3QpIHtcblx0XHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHR0ID0gdGhpcy5fZXZlbnRUYXJnZXQ7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGxpc3RlbmVyID0gbGlzdFtpXTtcblx0XHRcdFx0XHRpZiAobGlzdGVuZXIpIHtcblx0XHRcdFx0XHRcdGlmIChsaXN0ZW5lci51cCkge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5jLmNhbGwobGlzdGVuZXIucyB8fCB0LCB7dHlwZTp0eXBlLCB0YXJnZXQ6dH0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIuYy5jYWxsKGxpc3RlbmVyLnMgfHwgdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVGlja2VyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbiBcdFx0dmFyIF9yZXFBbmltRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuXHRcdFx0X2NhbmNlbEFuaW1GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSxcblx0XHRcdF9nZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO30sXG5cdFx0XHRfbGFzdFVwZGF0ZSA9IF9nZXRUaW1lKCk7XG5cblx0XHQvL25vdyB0cnkgdG8gZGV0ZXJtaW5lIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5kIGNhbmNlbEFuaW1hdGlvbkZyYW1lIGZ1bmN0aW9ucyBhbmQgaWYgbm9uZSBhcmUgZm91bmQsIHdlJ2xsIHVzZSBhIHNldFRpbWVvdXQoKS9jbGVhclRpbWVvdXQoKSBwb2x5ZmlsbC5cblx0XHRhID0gW1wibXNcIixcIm1velwiLFwid2Via2l0XCIsXCJvXCJdO1xuXHRcdGkgPSBhLmxlbmd0aDtcblx0XHR3aGlsZSAoLS1pID4gLTEgJiYgIV9yZXFBbmltRnJhbWUpIHtcblx0XHRcdF9yZXFBbmltRnJhbWUgPSB3aW5kb3dbYVtpXSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuXHRcdFx0X2NhbmNlbEFuaW1GcmFtZSA9IHdpbmRvd1thW2ldICsgXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiXSB8fCB3aW5kb3dbYVtpXSArIFwiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuXHRcdH1cblxuXHRcdF9jbGFzcyhcIlRpY2tlclwiLCBmdW5jdGlvbihmcHMsIHVzZVJBRikge1xuXHRcdFx0dmFyIF9zZWxmID0gdGhpcyxcblx0XHRcdFx0X3N0YXJ0VGltZSA9IF9nZXRUaW1lKCksXG5cdFx0XHRcdF91c2VSQUYgPSAodXNlUkFGICE9PSBmYWxzZSAmJiBfcmVxQW5pbUZyYW1lKSA/IFwiYXV0b1wiIDogZmFsc2UsXG5cdFx0XHRcdF9sYWdUaHJlc2hvbGQgPSA1MDAsXG5cdFx0XHRcdF9hZGp1c3RlZExhZyA9IDMzLFxuXHRcdFx0XHRfdGlja1dvcmQgPSBcInRpY2tcIiwgLy9oZWxwcyByZWR1Y2UgZ2MgYnVyZGVuXG5cdFx0XHRcdF9mcHMsIF9yZXEsIF9pZCwgX2dhcCwgX25leHRUaW1lLFxuXHRcdFx0XHRfdGljayA9IGZ1bmN0aW9uKG1hbnVhbCkge1xuXHRcdFx0XHRcdHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuXHRcdFx0XHRcdFx0b3ZlcmxhcCwgZGlzcGF0Y2g7XG5cdFx0XHRcdFx0aWYgKGVsYXBzZWQgPiBfbGFnVGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0XHRfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9sYXN0VXBkYXRlICs9IGVsYXBzZWQ7XG5cdFx0XHRcdFx0X3NlbGYudGltZSA9IChfbGFzdFVwZGF0ZSAtIF9zdGFydFRpbWUpIC8gMTAwMDtcblx0XHRcdFx0XHRvdmVybGFwID0gX3NlbGYudGltZSAtIF9uZXh0VGltZTtcblx0XHRcdFx0XHRpZiAoIV9mcHMgfHwgb3ZlcmxhcCA+IDAgfHwgbWFudWFsID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRfc2VsZi5mcmFtZSsrO1xuXHRcdFx0XHRcdFx0X25leHRUaW1lICs9IG92ZXJsYXAgKyAob3ZlcmxhcCA+PSBfZ2FwID8gMC4wMDQgOiBfZ2FwIC0gb3ZlcmxhcCk7XG5cdFx0XHRcdFx0XHRkaXNwYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYW51YWwgIT09IHRydWUpIHsgLy9tYWtlIHN1cmUgdGhlIHJlcXVlc3QgaXMgbWFkZSBiZWZvcmUgd2UgZGlzcGF0Y2ggdGhlIFwidGlja1wiIGV2ZW50IHNvIHRoYXQgdGltaW5nIGlzIG1haW50YWluZWQuIE90aGVyd2lzZSwgaWYgcHJvY2Vzc2luZyB0aGUgXCJ0aWNrXCIgcmVxdWlyZXMgYSBidW5jaCBvZiB0aW1lIChsaWtlIDE1bXMpIGFuZCB3ZSdyZSB1c2luZyBhIHNldFRpbWVvdXQoKSB0aGF0J3MgYmFzZWQgb24gMTYuN21zLCBpdCdkIHRlY2huaWNhbGx5IHRha2UgMzEuN21zIGJldHdlZW4gZnJhbWVzIG90aGVyd2lzZS5cblx0XHRcdFx0XHRcdF9pZCA9IF9yZXEoX3RpY2spO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGlzcGF0Y2gpIHtcblx0XHRcdFx0XHRcdF9zZWxmLmRpc3BhdGNoRXZlbnQoX3RpY2tXb3JkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdEV2ZW50RGlzcGF0Y2hlci5jYWxsKF9zZWxmKTtcblx0XHRcdF9zZWxmLnRpbWUgPSBfc2VsZi5mcmFtZSA9IDA7XG5cdFx0XHRfc2VsZi50aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90aWNrKHRydWUpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYubGFnU21vb3RoaW5nID0gZnVuY3Rpb24odGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuXHRcdFx0XHRfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8ICgxIC8gX3RpbnlOdW0pOyAvL3plcm8gc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2ljYWxseSB1bmxpbWl0ZWRcblx0XHRcdFx0X2FkanVzdGVkTGFnID0gTWF0aC5taW4oYWRqdXN0ZWRMYWcsIF9sYWdUaHJlc2hvbGQsIDApO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYuc2xlZXAgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF9pZCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3VzZVJBRiB8fCAhX2NhbmNlbEFuaW1GcmFtZSkge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChfaWQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9jYW5jZWxBbmltRnJhbWUoX2lkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVxID0gX2VtcHR5RnVuYztcblx0XHRcdFx0X2lkID0gbnVsbDtcblx0XHRcdFx0aWYgKF9zZWxmID09PSBfdGlja2VyKSB7XG5cdFx0XHRcdFx0X3RpY2tlckFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi53YWtlID0gZnVuY3Rpb24oc2VhbWxlc3MpIHtcblx0XHRcdFx0aWYgKF9pZCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdF9zZWxmLnNsZWVwKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRfc3RhcnRUaW1lICs9IC1fbGFzdFVwZGF0ZSArIChfbGFzdFVwZGF0ZSA9IF9nZXRUaW1lKCkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKF9zZWxmLmZyYW1lID4gMTApIHsgLy9kb24ndCB0cmlnZ2VyIGxhZ1Ntb290aGluZyBpZiB3ZSdyZSBqdXN0IHdha2luZyB1cCwgYW5kIG1ha2Ugc3VyZSB0aGF0IGF0IGxlYXN0IDEwIGZyYW1lcyBoYXZlIGVsYXBzZWQgYmVjYXVzZSBvZiB0aGUgaU9TIGJ1ZyB0aGF0IHdlIHdvcmsgYXJvdW5kIGJlbG93IHdpdGggdGhlIDEuNS1zZWNvbmQgc2V0VGltb3V0KCkuXG5cdFx0XHRcdFx0X2xhc3RVcGRhdGUgPSBfZ2V0VGltZSgpIC0gX2xhZ1RocmVzaG9sZCArIDU7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3JlcSA9IChfZnBzID09PSAwKSA/IF9lbXB0eUZ1bmMgOiAoIV91c2VSQUYgfHwgIV9yZXFBbmltRnJhbWUpID8gZnVuY3Rpb24oZikgeyByZXR1cm4gc2V0VGltZW91dChmLCAoKF9uZXh0VGltZSAtIF9zZWxmLnRpbWUpICogMTAwMCArIDEpIHwgMCk7IH0gOiBfcmVxQW5pbUZyYW1lO1xuXHRcdFx0XHRpZiAoX3NlbGYgPT09IF90aWNrZXIpIHtcblx0XHRcdFx0XHRfdGlja2VyQWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdGljaygyKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLmZwcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBfZnBzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9mcHMgPSB2YWx1ZTtcblx0XHRcdFx0X2dhcCA9IDEgLyAoX2ZwcyB8fCA2MCk7XG5cdFx0XHRcdF9uZXh0VGltZSA9IHRoaXMudGltZSArIF9nYXA7XG5cdFx0XHRcdF9zZWxmLndha2UoKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLnVzZVJBRiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBfdXNlUkFGO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9zZWxmLnNsZWVwKCk7XG5cdFx0XHRcdF91c2VSQUYgPSB2YWx1ZTtcblx0XHRcdFx0X3NlbGYuZnBzKF9mcHMpO1xuXHRcdFx0fTtcblx0XHRcdF9zZWxmLmZwcyhmcHMpO1xuXG5cdFx0XHQvL2EgYnVnIGluIGlPUyA2IFNhZmFyaSBvY2Nhc2lvbmFsbHkgcHJldmVudHMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tIHdvcmtpbmcgaW5pdGlhbGx5LCBzbyB3ZSB1c2UgYSAxLjUtc2Vjb25kIHRpbWVvdXQgdGhhdCBhdXRvbWF0aWNhbGx5IGZhbGxzIGJhY2sgdG8gc2V0VGltZW91dCgpIGlmIGl0IHNlbnNlcyB0aGlzIGNvbmRpdGlvbi5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfdXNlUkFGID09PSBcImF1dG9cIiAmJiBfc2VsZi5mcmFtZSA8IDUgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiKSB7XG5cdFx0XHRcdFx0X3NlbGYudXNlUkFGKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTUwMCk7XG5cdFx0fSk7XG5cblx0XHRwID0gZ3MuVGlja2VyLnByb3RvdHlwZSA9IG5ldyBncy5ldmVudHMuRXZlbnREaXNwYXRjaGVyKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IGdzLlRpY2tlcjtcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQW5pbWF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgQW5pbWF0aW9uID0gX2NsYXNzKFwiY29yZS5BbmltYXRpb25cIiwgZnVuY3Rpb24oZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdFx0dGhpcy52YXJzID0gdmFycyA9IHZhcnMgfHwge307XG5cdFx0XHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDA7XG5cdFx0XHRcdHRoaXMuX2RlbGF5ID0gTnVtYmVyKHZhcnMuZGVsYXkpIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3RpbWVTY2FsZSA9IDE7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuZGF0YSA9IHZhcnMuZGF0YTtcblx0XHRcdFx0dGhpcy5fcmV2ZXJzZWQgPSAodmFycy5yZXZlcnNlZCA9PT0gdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFfcm9vdFRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkgeyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgaU9TIDYgU2FmYXJpKSBzaHV0IGRvd24gSmF2YVNjcmlwdCBleGVjdXRpb24gd2hlbiB0aGUgdGFiIGlzIGRpc2FibGVkIGFuZCB0aGV5IFtvY2Nhc2lvbmFsbHldIG5lZ2xlY3QgdG8gc3RhcnQgdXAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFnYWluIHdoZW4gcmV0dXJuaW5nIC0gdGhpcyBjb2RlIGVuc3VyZXMgdGhhdCB0aGUgZW5naW5lIHN0YXJ0cyB1cCBhZ2FpbiBwcm9wZXJseS5cblx0XHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0bCA9IHRoaXMudmFycy51c2VGcmFtZXMgPyBfcm9vdEZyYW1lc1RpbWVsaW5lIDogX3Jvb3RUaW1lbGluZTtcblx0XHRcdFx0dGwuYWRkKHRoaXMsIHRsLl90aW1lKTtcblxuXHRcdFx0XHRpZiAodGhpcy52YXJzLnBhdXNlZCkge1xuXHRcdFx0XHRcdHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdF90aWNrZXIgPSBBbmltYXRpb24udGlja2VyID0gbmV3IGdzLlRpY2tlcigpO1xuXHRcdHAgPSBBbmltYXRpb24ucHJvdG90eXBlO1xuXHRcdHAuX2RpcnR5ID0gcC5fZ2MgPSBwLl9pbml0dGVkID0gcC5fcGF1c2VkID0gZmFsc2U7XG5cdFx0cC5fdG90YWxUaW1lID0gcC5fdGltZSA9IDA7XG5cdFx0cC5fcmF3UHJldlRpbWUgPSAtMTtcblx0XHRwLl9uZXh0ID0gcC5fbGFzdCA9IHAuX29uVXBkYXRlID0gcC5fdGltZWxpbmUgPSBwLnRpbWVsaW5lID0gbnVsbDtcblx0XHRwLl9wYXVzZWQgPSBmYWxzZTtcblxuXG5cdFx0Ly9zb21lIGJyb3dzZXJzIChsaWtlIGlPUykgb2NjYXNpb25hbGx5IGRyb3AgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBldmVudCB3aGVuIHRoZSB1c2VyIHN3aXRjaGVzIHRvIGEgZGlmZmVyZW50IHRhYiBhbmQgdGhlbiBjb21lcyBiYWNrIGFnYWluLCBzbyB3ZSB1c2UgYSAyLXNlY29uZCBzZXRUaW1lb3V0KCkgdG8gc2Vuc2UgaWYvd2hlbiB0aGF0IGNvbmRpdGlvbiBvY2N1cnMgYW5kIHRoZW4gd2FrZSgpIHRoZSB0aWNrZXIuXG5cdFx0dmFyIF9jaGVja1RpbWVvdXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF90aWNrZXJBY3RpdmUgJiYgX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlID4gMjAwMCkge1xuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldFRpbWVvdXQoX2NoZWNrVGltZW91dCwgMjAwMCk7XG5cdFx0XHR9O1xuXHRcdF9jaGVja1RpbWVvdXQoKTtcblxuXG5cdFx0cC5wbGF5ID0gZnVuY3Rpb24oZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnBhdXNlID0gZnVuY3Rpb24oYXRUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGF0VGltZSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2VlayhhdFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZCh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXN1bWUgPSBmdW5jdGlvbihmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5zZWVrID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZShOdW1iZXIodGltZSksIHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmVzdGFydCA9IGZ1bmN0aW9uKGluY2x1ZGVEZWxheSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCAoc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKSwgdHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAucmV2ZXJzZSA9IGZ1bmN0aW9uKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2VlaygoZnJvbSB8fCB0aGlzLnRvdGFsRHVyYXRpb24oKSksIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2VkKHRydWUpLnBhdXNlZChmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHQvL3N0dWIgLSB3ZSBvdmVycmlkZSB0aGlzIG1ldGhvZCBpbiBzdWJjbGFzc2VzLlxuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSAwO1xuXHRcdFx0dGhpcy5faW5pdHRlZCA9IHRoaXMuX2djID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IC0xO1xuXHRcdFx0aWYgKHRoaXMuX2djIHx8ICF0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmUsIC8vdGhlIDIgcm9vdCB0aW1lbGluZXMgd29uJ3QgaGF2ZSBhIF90aW1lbGluZTsgdGhleSdyZSBhbHdheXMgYWN0aXZlLlxuXHRcdFx0XHRzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0XHRcdHJhd1RpbWU7XG5cdFx0XHRyZXR1cm4gKCF0bCB8fCAoIXRoaXMuX2djICYmICF0aGlzLl9wYXVzZWQgJiYgdGwuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHRsLnJhd1RpbWUoKSkgPj0gc3RhcnRUaW1lICYmIHJhd1RpbWUgPCBzdGFydFRpbWUgKyB0aGlzLnRvdGFsRHVyYXRpb24oKSAvIHRoaXMuX3RpbWVTY2FsZSkpO1xuXHRcdH07XG5cblx0XHRwLl9lbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9nYyA9ICFlbmFibGVkO1xuXHRcdFx0dGhpcy5fYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpO1xuXHRcdFx0aWYgKGlnbm9yZVRpbWVsaW5lICE9PSB0cnVlKSB7XG5cdFx0XHRcdGlmIChlbmFibGVkICYmICF0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuYWRkKHRoaXMsIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX2RlbGF5KTtcblx0XHRcdFx0fSBlbHNlIGlmICghZW5hYmxlZCAmJiB0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuX3JlbW92ZSh0aGlzLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAua2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0dGhpcy5fa2lsbCh2YXJzLCB0YXJnZXQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3VuY2FjaGUgPSBmdW5jdGlvbihpbmNsdWRlU2VsZikge1xuXHRcdFx0dmFyIHR3ZWVuID0gaW5jbHVkZVNlbGYgPyB0aGlzIDogdGhpcy50aW1lbGluZTtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHR0d2Vlbi5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3N3YXBTZWxmSW5QYXJhbXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHRcdHZhciBpID0gcGFyYW1zLmxlbmd0aCxcblx0XHRcdFx0Y29weSA9IHBhcmFtcy5jb25jYXQoKTtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAocGFyYW1zW2ldID09PSBcIntzZWxmfVwiKSB7XG5cdFx0XHRcdFx0Y29weVtpXSA9IHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH07XG5cblx0XHRwLl9jYWxsYmFjayA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciB2ID0gdGhpcy52YXJzO1xuXHRcdFx0dlt0eXBlXS5hcHBseSh2W3R5cGUgKyBcIlNjb3BlXCJdIHx8IHYuY2FsbGJhY2tTY29wZSB8fCB0aGlzLCB2W3R5cGUgKyBcIlBhcmFtc1wiXSB8fCBfYmxhbmtBcnJheSk7XG5cdFx0fTtcblxuLy8tLS0tQW5pbWF0aW9uIGdldHRlcnMvc2V0dGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdGlmICgodHlwZSB8fCBcIlwiKS5zdWJzdHIoMCwyKSA9PT0gXCJvblwiKSB7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YXJzO1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdHJldHVybiB2W3R5cGVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHZbdHlwZV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dlt0eXBlXSA9IGNhbGxiYWNrO1xuXHRcdFx0XHRcdHZbdHlwZSArIFwiUGFyYW1zXCJdID0gKF9pc0FycmF5KHBhcmFtcykgJiYgcGFyYW1zLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSAhPT0gLTEpID8gdGhpcy5fc3dhcFNlbGZJblBhcmFtcyhwYXJhbXMpIDogcGFyYW1zO1xuXHRcdFx0XHRcdHZbdHlwZSArIFwiU2NvcGVcIl0gPSBzY29wZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZSA9PT0gXCJvblVwZGF0ZVwiKSB7XG5cdFx0XHRcdFx0dGhpcy5fb25VcGRhdGUgPSBjYWxsYmFjaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kZWxheTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHR0aGlzLnN0YXJ0VGltZSggdGhpcy5fc3RhcnRUaW1lICsgdmFsdWUgLSB0aGlzLl9kZWxheSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGVsYXkgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSB2YWx1ZTtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7IC8vdHJ1ZSBpbiBjYXNlIGl0J3MgYSBUd2Vlbk1heCBvciBUaW1lbGluZU1heCB0aGF0IGhhcyBhIHJlcGVhdCAtIHdlJ2xsIG5lZWQgdG8gcmVmcmVzaCB0aGUgdG90YWxEdXJhdGlvbi5cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykgaWYgKHRoaXMuX3RpbWUgPiAwKSBpZiAodGhpcy5fdGltZSA8IHRoaXMuX2R1cmF0aW9uKSBpZiAodmFsdWUgIT09IDApIHtcblx0XHRcdFx0dGhpcy50b3RhbFRpbWUodGhpcy5fdG90YWxUaW1lICogKHZhbHVlIC8gdGhpcy5fZHVyYXRpb24pLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMuZHVyYXRpb24odmFsdWUpO1xuXHRcdH07XG5cblx0XHRwLnRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSgodmFsdWUgPiB0aGlzLl9kdXJhdGlvbikgPyB0aGlzLl9kdXJhdGlvbiA6IHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxUaW1lID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIHVuY2FwcGVkKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsVGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgIXVuY2FwcGVkKSB7XG5cdFx0XHRcdFx0dGltZSArPSB0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgdG90YWxEdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24sXG5cdFx0XHRcdFx0XHR0bCA9IHRoaXMuX3RpbWVsaW5lO1xuXHRcdFx0XHRcdGlmICh0aW1lID4gdG90YWxEdXJhdGlvbiAmJiAhdW5jYXBwZWQpIHtcblx0XHRcdFx0XHRcdHRpbWUgPSB0b3RhbER1cmF0aW9uO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSAodGhpcy5fcGF1c2VkID8gdGhpcy5fcGF1c2VUaW1lIDogdGwuX3RpbWUpIC0gKCghdGhpcy5fcmV2ZXJzZWQgPyB0aW1lIDogdG90YWxEdXJhdGlvbiAtIHRpbWUpIC8gdGhpcy5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRpZiAoIXRsLl9kaXJ0eSkgeyAvL2ZvciBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC4gSWYgdGhlIHBhcmVudCdzIGNhY2hlIGlzIGFscmVhZHkgZGlydHksIGl0IGFscmVhZHkgdG9vayBjYXJlIG9mIG1hcmtpbmcgdGhlIGFuY2VzdG9ycyBhcyBkaXJ0eSB0b28sIHNvIHNraXAgdGhlIGZ1bmN0aW9uIGNhbGwgaGVyZS5cblx0XHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvciB0aW1lbGluZXMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLCB3ZSBzaG91bGQgcmVzZXQgdGhlaXIgdG90YWxUaW1lKCkgd2hpY2ggd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZXkncmUgbGluZWQgdXAgcHJvcGVybHkgYW5kIGVuYWJsZWQuIFNraXAgZm9yIGFuaW1hdGlvbnMgdGhhdCBhcmUgb24gdGhlIHJvb3QgKHdhc3RlZnVsKS4gRXhhbXBsZTogYSBUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCgpIGlzIHBlcmZvcm1lZCB3aGVuIHRoZXJlJ3MgYSBwYXVzZWQgdHdlZW4gb24gdGhlIHJvb3QsIHRoZSBleHBvcnQgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhhdCB0d2VlbiBpcyB1bnBhdXNlZCwgYnV0IGltYWdpbmUgYSBjaGlsZCBnZXRzIHJlc3RhcnRlZCBsYXRlciwgYWZ0ZXIgYWxsIFt1bnBhdXNlZF0gdHdlZW5zIGhhdmUgY29tcGxldGVkLiBUaGUgc3RhcnRUaW1lIG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXG5cdFx0XHRcdFx0aWYgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAodGwuX3RpbWVsaW5lLl90aW1lICE9PSAodGwuX3N0YXJ0VGltZSArIHRsLl90b3RhbFRpbWUpIC8gdGwuX3RpbWVTY2FsZSkge1xuXHRcdFx0XHRcdFx0XHRcdHRsLnRvdGFsVGltZSh0bC5fdG90YWxUaW1lLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gdGltZSB8fCB0aGlzLl9kdXJhdGlvbiA9PT0gMCkge1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmYWxzZSk7XG5cdFx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gc29tZW9uZSBjYWxscyBzZWVrKCkgb3IgdGltZSgpIG9yIHByb2dyZXNzKCksIHRoZXkgZXhwZWN0IGFuIGltbWVkaWF0ZSByZW5kZXIuXG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucHJvZ3Jlc3MgPSBwLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKTtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gKGR1cmF0aW9uID8gdGhpcy5fdGltZSAvIGR1cmF0aW9uIDogdGhpcy5yYXRpbykgOiB0aGlzLnRvdGFsVGltZShkdXJhdGlvbiAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuc3RhcnRUaW1lID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc3RhcnRUaW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlICE9PSB0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdmFsdWU7XG5cdFx0XHRcdGlmICh0aGlzLnRpbWVsaW5lKSBpZiAodGhpcy50aW1lbGluZS5fc29ydENoaWxkcmVuKSB7XG5cdFx0XHRcdFx0dGhpcy50aW1lbGluZS5hZGQodGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7IC8vZW5zdXJlcyB0aGF0IGFueSBuZWNlc3NhcnkgcmUtc2VxdWVuY2luZyBvZiBBbmltYXRpb25zIGluIHRoZSB0aW1lbGluZSBvY2N1cnMgdG8gbWFrZSBzdXJlIHRoZSByZW5kZXJpbmcgb3JkZXIgaXMgY29ycmVjdC5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZW5kVGltZSA9IGZ1bmN0aW9uKGluY2x1ZGVSZXBlYXRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3RhcnRUaW1lICsgKChpbmNsdWRlUmVwZWF0cyAhPSBmYWxzZSkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuZHVyYXRpb24oKSkgLyB0aGlzLl90aW1lU2NhbGU7XG5cdFx0fTtcblxuXHRcdHAudGltZVNjYWxlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZVNjYWxlO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBfdGlueU51bTsgLy9jYW4ndCBhbGxvdyB6ZXJvIGJlY2F1c2UgaXQnbGwgdGhyb3cgdGhlIG1hdGggb2ZmXG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUgJiYgdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0dmFyIHBhdXNlVGltZSA9IHRoaXMuX3BhdXNlVGltZSxcblx0XHRcdFx0XHR0ID0gKHBhdXNlVGltZSB8fCBwYXVzZVRpbWUgPT09IDApID8gcGF1c2VUaW1lIDogdGhpcy5fdGltZWxpbmUudG90YWxUaW1lKCk7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0aGlzLl9zdGFydFRpbWUpICogdGhpcy5fdGltZVNjYWxlIC8gdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdGltZVNjYWxlID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmV2ZXJzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzLl9yZXZlcnNlZCkge1xuXHRcdFx0XHR0aGlzLl9yZXZlcnNlZCA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnRvdGFsVGltZSgoKHRoaXMuX3RpbWVsaW5lICYmICF0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSAtIHRoaXMuX3RvdGFsVGltZSA6IHRoaXMuX3RvdGFsVGltZSksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmUsXG5cdFx0XHRcdHJhdywgZWxhcHNlZDtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzLl9wYXVzZWQpIGlmICh0bCkge1xuXHRcdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUgJiYgIXZhbHVlKSB7XG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmF3ID0gdGwucmF3VGltZSgpO1xuXHRcdFx0XHRlbGFwc2VkID0gcmF3IC0gdGhpcy5fcGF1c2VUaW1lO1xuXHRcdFx0XHRpZiAoIXZhbHVlICYmIHRsLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lICs9IGVsYXBzZWQ7XG5cdFx0XHRcdFx0dGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcGF1c2VUaW1lID0gdmFsdWUgPyByYXcgOiBudWxsO1xuXHRcdFx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpO1xuXHRcdFx0XHRpZiAoIXZhbHVlICYmIGVsYXBzZWQgIT09IDAgJiYgdGhpcy5faW5pdHRlZCAmJiB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0XHRyYXcgPSB0bC5zbW9vdGhDaGlsZFRpbWluZyA/IHRoaXMuX3RvdGFsVGltZSA6IChyYXcgLSB0aGlzLl9zdGFydFRpbWUpIC8gdGhpcy5fdGltZVNjYWxlO1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyKHJhdywgKHJhdyA9PT0gdGhpcy5fdG90YWxUaW1lKSwgdHJ1ZSk7IC8vaW4gY2FzZSB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcyBjaGFuZ2VkIHZpYSBzb21lIG90aGVyIHR3ZWVuIG9yIG1hbnVhbCB1cGRhdGUgYnkgdGhlIHVzZXIsIHdlIHNob3VsZCBmb3JjZSBhIHJlbmRlci5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2djICYmICF2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFNpbXBsZVRpbWVsaW5lXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgU2ltcGxlVGltZWxpbmUgPSBfY2xhc3MoXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsIGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdEFuaW1hdGlvbi5jYWxsKHRoaXMsIDAsIHZhcnMpO1xuXHRcdFx0dGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSB0aGlzLnNtb290aENoaWxkVGltaW5nID0gdHJ1ZTtcblx0XHR9KTtcblxuXHRcdHAgPSBTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUgPSBuZXcgQW5pbWF0aW9uKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFNpbXBsZVRpbWVsaW5lO1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXHRcdHAuX2ZpcnN0ID0gcC5fbGFzdCA9IHAuX3JlY2VudCA9IG51bGw7XG5cdFx0cC5fc29ydENoaWxkcmVuID0gZmFsc2U7XG5cblx0XHRwLmFkZCA9IHAuaW5zZXJ0ID0gZnVuY3Rpb24oY2hpbGQsIHBvc2l0aW9uLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0dmFyIHByZXZUd2Vlbiwgc3Q7XG5cdFx0XHRjaGlsZC5fc3RhcnRUaW1lID0gTnVtYmVyKHBvc2l0aW9uIHx8IDApICsgY2hpbGQuX2RlbGF5O1xuXHRcdFx0aWYgKGNoaWxkLl9wYXVzZWQpIGlmICh0aGlzICE9PSBjaGlsZC5fdGltZWxpbmUpIHsgLy93ZSBvbmx5IGFkanVzdCB0aGUgX3BhdXNlVGltZSBpZiBpdCB3YXNuJ3QgaW4gdGhpcyB0aW1lbGluZSBhbHJlYWR5LiBSZW1lbWJlciwgc29tZXRpbWVzIGEgdHdlZW4gd2lsbCBiZSBpbnNlcnRlZCBhZ2FpbiBpbnRvIHRoZSBzYW1lIHRpbWVsaW5lIHdoZW4gaXRzIHN0YXJ0VGltZSBpcyBjaGFuZ2VkIHNvIHRoYXQgdGhlIHR3ZWVucyBpbiB0aGUgVGltZWxpbmVMaXRlL01heCBhcmUgcmUtb3JkZXJlZCBwcm9wZXJseSBpbiB0aGUgbGlua2VkIGxpc3QgKHNvIGV2ZXJ5dGhpbmcgcmVuZGVycyBpbiB0aGUgcHJvcGVyIG9yZGVyKS5cblx0XHRcdFx0Y2hpbGQuX3BhdXNlVGltZSA9IGNoaWxkLl9zdGFydFRpbWUgKyAoKHRoaXMucmF3VGltZSgpIC0gY2hpbGQuX3N0YXJ0VGltZSkgLyBjaGlsZC5fdGltZVNjYWxlKTtcblx0XHRcdH1cblx0XHRcdGlmIChjaGlsZC50aW1lbGluZSkge1xuXHRcdFx0XHRjaGlsZC50aW1lbGluZS5fcmVtb3ZlKGNoaWxkLCB0cnVlKTsgLy9yZW1vdmVzIGZyb20gZXhpc3RpbmcgdGltZWxpbmUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgYWRkZWQgdG8gdGhpcyBvbmUuXG5cdFx0XHR9XG5cdFx0XHRjaGlsZC50aW1lbGluZSA9IGNoaWxkLl90aW1lbGluZSA9IHRoaXM7XG5cdFx0XHRpZiAoY2hpbGQuX2djKSB7XG5cdFx0XHRcdGNoaWxkLl9lbmFibGVkKHRydWUsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cHJldlR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdGlmICh0aGlzLl9zb3J0Q2hpbGRyZW4pIHtcblx0XHRcdFx0c3QgPSBjaGlsZC5fc3RhcnRUaW1lO1xuXHRcdFx0XHR3aGlsZSAocHJldlR3ZWVuICYmIHByZXZUd2Vlbi5fc3RhcnRUaW1lID4gc3QpIHtcblx0XHRcdFx0XHRwcmV2VHdlZW4gPSBwcmV2VHdlZW4uX3ByZXY7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VHdlZW4pIHtcblx0XHRcdFx0Y2hpbGQuX25leHQgPSBwcmV2VHdlZW4uX25leHQ7XG5cdFx0XHRcdHByZXZUd2Vlbi5fbmV4dCA9IGNoaWxkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQuX25leHQgPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0dGhpcy5fZmlyc3QgPSBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGlmIChjaGlsZC5fbmV4dCkge1xuXHRcdFx0XHRjaGlsZC5fbmV4dC5fcHJldiA9IGNoaWxkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fbGFzdCA9IGNoaWxkO1xuXHRcdFx0fVxuXHRcdFx0Y2hpbGQuX3ByZXYgPSBwcmV2VHdlZW47XG5cdFx0XHR0aGlzLl9yZWNlbnQgPSBjaGlsZDtcblx0XHRcdGlmICh0aGlzLl90aW1lbGluZSkge1xuXHRcdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3JlbW92ZSA9IGZ1bmN0aW9uKHR3ZWVuLCBza2lwRGlzYWJsZSkge1xuXHRcdFx0aWYgKHR3ZWVuLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdGlmICghc2tpcERpc2FibGUpIHtcblx0XHRcdFx0XHR0d2Vlbi5fZW5hYmxlZChmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodHdlZW4uX3ByZXYpIHtcblx0XHRcdFx0XHR0d2Vlbi5fcHJldi5fbmV4dCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2ZpcnN0ID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR3ZWVuLl9uZXh0KSB7XG5cdFx0XHRcdFx0dHdlZW4uX25leHQuX3ByZXYgPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9sYXN0ID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX2xhc3QgPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2Vlbi5fbmV4dCA9IHR3ZWVuLl9wcmV2ID0gdHdlZW4udGltZWxpbmUgPSBudWxsO1xuXHRcdFx0XHRpZiAodHdlZW4gPT09IHRoaXMuX3JlY2VudCkge1xuXHRcdFx0XHRcdHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRuZXh0O1xuXHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRpZiAodHdlZW4uX2FjdGl2ZSB8fCAodGltZSA+PSB0d2Vlbi5fc3RhcnRUaW1lICYmICF0d2Vlbi5fcGF1c2VkKSkge1xuXHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLnJhd1RpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl90b3RhbFRpbWU7XG5cdFx0fTtcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFR3ZWVuTGl0ZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFR3ZWVuTGl0ZSA9IF9jbGFzcyhcIlR3ZWVuTGl0ZVwiLCBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRcdEFuaW1hdGlvbi5jYWxsKHRoaXMsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5yZW5kZXIgPSBUd2VlbkxpdGUucHJvdG90eXBlLnJlbmRlcjsgLy9zcGVlZCBvcHRpbWl6YXRpb24gKGF2b2lkIHByb3RvdHlwZSBsb29rdXAgb24gdGhpcyBcImhvdFwiIG1ldGhvZClcblxuXHRcdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdFx0XHR0aHJvdyBcIkNhbm5vdCB0d2VlbiBhIG51bGwgdGFyZ2V0LlwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQgPSAodHlwZW9mKHRhcmdldCkgIT09IFwic3RyaW5nXCIpID8gdGFyZ2V0IDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXG5cdFx0XHRcdHZhciBpc1NlbGVjdG9yID0gKHRhcmdldC5qcXVlcnkgfHwgKHRhcmdldC5sZW5ndGggJiYgdGFyZ2V0ICE9PSB3aW5kb3cgJiYgdGFyZ2V0WzBdICYmICh0YXJnZXRbMF0gPT09IHdpbmRvdyB8fCAodGFyZ2V0WzBdLm5vZGVUeXBlICYmIHRhcmdldFswXS5zdHlsZSAmJiAhdGFyZ2V0Lm5vZGVUeXBlKSkpKSxcblx0XHRcdFx0XHRvdmVyd3JpdGUgPSB0aGlzLnZhcnMub3ZlcndyaXRlLFxuXHRcdFx0XHRcdGksIHRhcmcsIHRhcmdldHM7XG5cblx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlID0gb3ZlcndyaXRlID0gKG92ZXJ3cml0ZSA9PSBudWxsKSA/IF9vdmVyd3JpdGVMb29rdXBbVHdlZW5MaXRlLmRlZmF1bHRPdmVyd3JpdGVdIDogKHR5cGVvZihvdmVyd3JpdGUpID09PSBcIm51bWJlclwiKSA/IG92ZXJ3cml0ZSA+PiAwIDogX292ZXJ3cml0ZUxvb2t1cFtvdmVyd3JpdGVdO1xuXG5cdFx0XHRcdGlmICgoaXNTZWxlY3RvciB8fCB0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSB8fCAodGFyZ2V0LnB1c2ggJiYgX2lzQXJyYXkodGFyZ2V0KSkpICYmIHR5cGVvZih0YXJnZXRbMF0pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGFyZ2V0cyA9IHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0KTsgIC8vZG9uJ3QgdXNlIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRhcmdldCwgMCkgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0XHR0aGlzLl9wcm9wTG9va3VwID0gW107XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBbXTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dGFyZyA9IHRhcmdldHNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIXRhcmcpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih0YXJnKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0XHR0YXJnID0gdGFyZ2V0c1tpLS1dID0gVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmcpOyAvL2luIGNhc2UgaXQncyBhbiBhcnJheSBvZiBzdHJpbmdzXG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YodGFyZykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpKzEsIDEpOyAvL3RvIGF2b2lkIGFuIGVuZGxlc3MgbG9vcCAoY2FuJ3QgaW1hZ2luZSB3aHkgdGhlIHNlbGVjdG9yIHdvdWxkIHJldHVybiBhIHN0cmluZywgYnV0IGp1c3QgaW4gY2FzZSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGFyZy5sZW5ndGggJiYgdGFyZyAhPT0gd2luZG93ICYmIHRhcmdbMF0gJiYgKHRhcmdbMF0gPT09IHdpbmRvdyB8fCAodGFyZ1swXS5ub2RlVHlwZSAmJiB0YXJnWzBdLnN0eWxlICYmICF0YXJnLm5vZGVUeXBlKSkpIHsgLy9pbiBjYXNlIHRoZSB1c2VyIGlzIHBhc3NpbmcgaW4gYW4gYXJyYXkgb2Ygc2VsZWN0b3Igb2JqZWN0cyAobGlrZSBqUXVlcnkgb2JqZWN0cyksIHdlIG5lZWQgdG8gY2hlY2sgb25lIG1vcmUgbGV2ZWwgYW5kIHB1bGwgdGhpbmdzIG91dCBpZiBuZWNlc3NhcnkuIEFsc28gbm90ZSB0aGF0IDxzZWxlY3Q+IGVsZW1lbnRzIHBhc3MgYWxsIHRoZSBjcml0ZXJpYSByZWdhcmRpbmcgbGVuZ3RoIGFuZCB0aGUgZmlyc3QgY2hpbGQgaGF2aW5nIHN0eWxlLCBzbyB3ZSBtdXN0IGFsc28gY2hlY2sgdG8gZW5zdXJlIHRoZSB0YXJnZXQgaXNuJ3QgYW4gSFRNTCBub2RlIGl0c2VsZi5cblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGFyZ2V0cyA9IHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdChfc2xpY2UodGFyZykpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzW2ldID0gX3JlZ2lzdGVyKHRhcmcsIHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0XHRcdGlmIChvdmVyd3JpdGUgPT09IDEpIGlmICh0aGlzLl9zaWJsaW5nc1tpXS5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHRcdF9hcHBseU92ZXJ3cml0ZSh0YXJnLCB0aGlzLCBudWxsLCAxLCB0aGlzLl9zaWJsaW5nc1tpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcExvb2t1cCA9IHt9O1xuXHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzID0gX3JlZ2lzdGVyKHRhcmdldCwgdGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdGlmIChvdmVyd3JpdGUgPT09IDEpIGlmICh0aGlzLl9zaWJsaW5ncy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHRfYXBwbHlPdmVyd3JpdGUodGFyZ2V0LCB0aGlzLCBudWxsLCAxLCB0aGlzLl9zaWJsaW5ncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyIHx8IChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9kZWxheSA9PT0gMCAmJiB0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSkpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblx0XHRcdFx0XHR0aGlzLnJlbmRlcihNYXRoLm1pbigwLCAtdGhpcy5fZGVsYXkpKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlXG5cdFx0XHRcdH1cblx0XHRcdH0sIHRydWUpLFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHJldHVybiAodiAmJiB2Lmxlbmd0aCAmJiB2ICE9PSB3aW5kb3cgJiYgdlswXSAmJiAodlswXSA9PT0gd2luZG93IHx8ICh2WzBdLm5vZGVUeXBlICYmIHZbMF0uc3R5bGUgJiYgIXYubm9kZVR5cGUpKSk7IC8vd2UgY2Fubm90IGNoZWNrIFwibm9kZVR5cGVcIiBpZiB0aGUgdGFyZ2V0IGlzIHdpbmRvdyBmcm9tIHdpdGhpbiBhbiBpZnJhbWUsIG90aGVyd2lzZSBpdCB3aWxsIHRyaWdnZXIgYSBzZWN1cml0eSBlcnJvciBpbiBzb21lIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cblx0XHRcdH0sXG5cdFx0XHRfYXV0b0NTUyA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0XHR2YXIgY3NzID0ge30sXG5cdFx0XHRcdFx0cDtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRpZiAoIV9yZXNlcnZlZFByb3BzW3BdICYmICghKHAgaW4gdGFyZ2V0KSB8fCBwID09PSBcInRyYW5zZm9ybVwiIHx8IHAgPT09IFwieFwiIHx8IHAgPT09IFwieVwiIHx8IHAgPT09IFwid2lkdGhcIiB8fCBwID09PSBcImhlaWdodFwiIHx8IHAgPT09IFwiY2xhc3NOYW1lXCIgfHwgcCA9PT0gXCJib3JkZXJcIikgJiYgKCFfcGx1Z2luc1twXSB8fCAoX3BsdWdpbnNbcF0gJiYgX3BsdWdpbnNbcF0uX2F1dG9DU1MpKSkgeyAvL25vdGU6IDxpbWc+IGVsZW1lbnRzIGNvbnRhaW4gcmVhZC1vbmx5IFwieFwiIGFuZCBcInlcIiBwcm9wZXJ0aWVzLiBXZSBzaG91bGQgYWxzbyBwcmlvcml0aXplIGVkaXRpbmcgY3NzIHdpZHRoL2hlaWdodCByYXRoZXIgdGhhbiB0aGUgZWxlbWVudCdzIHByb3BlcnRpZXMuXG5cdFx0XHRcdFx0XHRjc3NbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHZhcnNbcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhcnMuY3NzID0gY3NzO1xuXHRcdFx0fTtcblxuXHRcdHAgPSBUd2VlbkxpdGUucHJvdG90eXBlID0gbmV3IEFuaW1hdGlvbigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUd2VlbkxpdGU7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cbi8vLS0tLVR3ZWVuTGl0ZSBkZWZhdWx0cywgb3ZlcndyaXRlIG1hbmFnZW1lbnQsIGFuZCByb290IHVwZGF0ZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5yYXRpbyA9IDA7XG5cdFx0cC5fZmlyc3RQVCA9IHAuX3RhcmdldHMgPSBwLl9vdmVyd3JpdHRlblByb3BzID0gcC5fc3RhcnRBdCA9IG51bGw7XG5cdFx0cC5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCA9IHAuX2xhenkgPSBmYWxzZTtcblxuXHRcdFR3ZWVuTGl0ZS52ZXJzaW9uID0gXCIxLjE4LjRcIjtcblx0XHRUd2VlbkxpdGUuZGVmYXVsdEVhc2UgPSBwLl9lYXNlID0gbmV3IEVhc2UobnVsbCwgbnVsbCwgMSwgMSk7XG5cdFx0VHdlZW5MaXRlLmRlZmF1bHRPdmVyd3JpdGUgPSBcImF1dG9cIjtcblx0XHRUd2VlbkxpdGUudGlja2VyID0gX3RpY2tlcjtcblx0XHRUd2VlbkxpdGUuYXV0b1NsZWVwID0gMTIwO1xuXHRcdFR3ZWVuTGl0ZS5sYWdTbW9vdGhpbmcgPSBmdW5jdGlvbih0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG5cdFx0XHRfdGlja2VyLmxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLnNlbGVjdG9yID0gd2luZG93LiQgfHwgd2luZG93LmpRdWVyeSB8fCBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSB3aW5kb3cuJCB8fCB3aW5kb3cualF1ZXJ5O1xuXHRcdFx0aWYgKHNlbGVjdG9yKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRyZXR1cm4gc2VsZWN0b3IoZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHR5cGVvZihkb2N1bWVudCkgPT09IFwidW5kZWZpbmVkXCIpID8gZSA6IChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKSA6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKChlLmNoYXJBdCgwKSA9PT0gXCIjXCIpID8gZS5zdWJzdHIoMSkgOiBlKSk7XG5cdFx0fTtcblxuXHRcdHZhciBfbGF6eVR3ZWVucyA9IFtdLFxuXHRcdFx0X2xhenlMb29rdXAgPSB7fSxcblx0XHRcdF9udW1iZXJzRXhwID0gLyg/OigtfC09fFxcKz0pP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/KVswLTldL2lnLFxuXHRcdFx0Ly9fbm9uTnVtYmVyc0V4cCA9IC8oPzooW1xcLStdKD8hKFxcZHw9KSkpfFteXFxkXFwtKz1lXXwoZSg/IVtcXC0rXVtcXGRdKSkpKy9pZyxcblx0XHRcdF9zZXRSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVCxcblx0XHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0XHR2YWw7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdHZhbCA9ICFwdC5ibG9iID8gcHQuYyAqIHYgKyBwdC5zIDogdiA/IHRoaXMuam9pbihcIlwiKSA6IHRoaXMuc3RhcnQ7XG5cdFx0XHRcdFx0aWYgKHB0LnIpIHtcblx0XHRcdFx0XHRcdHZhbCA9IE1hdGgucm91bmQodmFsKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbCA8IG1pbikgaWYgKHZhbCA+IC1taW4pIHsgLy9wcmV2ZW50cyBpc3N1ZXMgd2l0aCBjb252ZXJ0aW5nIHZlcnkgc21hbGwgbnVtYmVycyB0byBzdHJpbmdzIGluIHRoZSBicm93c2VyXG5cdFx0XHRcdFx0XHR2YWwgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXB0LmYpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSB2YWw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC5mcCkge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXShwdC5mcCwgdmFsKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSh2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Ly9jb21wYXJlcyB0d28gc3RyaW5ncyAoc3RhcnQvZW5kKSwgZmluZHMgdGhlIG51bWJlcnMgdGhhdCBhcmUgZGlmZmVyZW50IGFuZCBzcGl0cyBiYWNrIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgd2hvbGUgdmFsdWUgYnV0IHdpdGggdGhlIGNoYW5naW5nIHZhbHVlcyBpc29sYXRlZCBhcyBlbGVtZW50cy4gRm9yIGV4YW1wbGUsIFwicmdiKDAsMCwwKVwiIGFuZCBcInJnYigxMDAsNTAsMClcIiB3b3VsZCBiZWNvbWUgW1wicmdiKFwiLCAwLCBcIixcIiwgNTAsIFwiLDApXCJdLiBOb3RpY2UgaXQgbWVyZ2VzIHRoZSBwYXJ0cyB0aGF0IGFyZSBpZGVudGljYWwgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbikuIFRoZSBhcnJheSBhbHNvIGhhcyBhIGxpbmtlZCBsaXN0IG9mIFByb3BUd2VlbnMgYXR0YWNoZWQgc3RhcnRpbmcgd2l0aCBfZmlyc3RQVCB0aGF0IGNvbnRhaW4gdGhlIHR3ZWVuaW5nIGRhdGEgKHQsIHAsIHMsIGMsIGYsIGV0Yy4pLiBJdCBhbHNvIHN0b3JlcyB0aGUgc3RhcnRpbmcgdmFsdWUgYXMgYSBcInN0YXJ0XCIgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gcmV2ZXJ0IHRvIGl0IGlmL3doZW4gbmVjZXNzYXJ5LCBsaWtlIHdoZW4gYSB0d2VlbiByZXdpbmRzIGZ1bGx5LiBJZiB0aGUgcXVhbnRpdHkgb2YgbnVtYmVycyBkaWZmZXJzIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQsIGl0IHdpbGwgYWx3YXlzIHByaW9yaXRpemUgdGhlIGVuZCB2YWx1ZShzKS4gVGhlIHB0IHBhcmFtZXRlciBpcyBvcHRpb25hbCAtIGl0J3MgZm9yIGEgUHJvcFR3ZWVuIHRoYXQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBsaW5rZWQgbGlzdCBhbmQgaXMgdHlwaWNhbGx5IGZvciBhY3R1YWxseSBzZXR0aW5nIHRoZSB2YWx1ZSBhZnRlciBhbGwgb2YgdGhlIGVsZW1lbnRzIGhhdmUgYmVlbiB1cGRhdGVkICh3aXRoIGFycmF5LmpvaW4oXCJcIikpLlxuXHRcdFx0X2Jsb2JEaWYgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBmaWx0ZXIsIHB0KSB7XG5cdFx0XHRcdHZhciBhID0gW3N0YXJ0LCBlbmRdLFxuXHRcdFx0XHRcdGNoYXJJbmRleCA9IDAsXG5cdFx0XHRcdFx0cyA9IFwiXCIsXG5cdFx0XHRcdFx0Y29sb3IgPSAwLFxuXHRcdFx0XHRcdHN0YXJ0TnVtcywgZW5kTnVtcywgbnVtLCBpLCBsLCBub25OdW1iZXJzLCBjdXJyZW50TnVtO1xuXHRcdFx0XHRhLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdGlmIChmaWx0ZXIpIHtcblx0XHRcdFx0XHRmaWx0ZXIoYSk7IC8vcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy5cblx0XHRcdFx0XHRzdGFydCA9IGFbMF07XG5cdFx0XHRcdFx0ZW5kID0gYVsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhLmxlbmd0aCA9IDA7XG5cdFx0XHRcdHN0YXJ0TnVtcyA9IHN0YXJ0Lm1hdGNoKF9udW1iZXJzRXhwKSB8fCBbXTtcblx0XHRcdFx0ZW5kTnVtcyA9IGVuZC5tYXRjaChfbnVtYmVyc0V4cCkgfHwgW107XG5cdFx0XHRcdGlmIChwdCkge1xuXHRcdFx0XHRcdHB0Ll9uZXh0ID0gbnVsbDtcblx0XHRcdFx0XHRwdC5ibG9iID0gMTtcblx0XHRcdFx0XHRhLl9maXJzdFBUID0gcHQ7IC8vYXBwbHkgbGFzdCBpbiB0aGUgbGlua2VkIGxpc3QgKHdoaWNoIG1lYW5zIGluc2VydGluZyBpdCBmaXJzdClcblx0XHRcdFx0fVxuXHRcdFx0XHRsID0gZW5kTnVtcy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjdXJyZW50TnVtID0gZW5kTnVtc1tpXTtcblx0XHRcdFx0XHRub25OdW1iZXJzID0gZW5kLnN1YnN0cihjaGFySW5kZXgsIGVuZC5pbmRleE9mKGN1cnJlbnROdW0sIGNoYXJJbmRleCktY2hhckluZGV4KTtcblx0XHRcdFx0XHRzICs9IChub25OdW1iZXJzIHx8ICFpKSA/IG5vbk51bWJlcnMgOiBcIixcIjsgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXG5cdFx0XHRcdFx0Y2hhckluZGV4ICs9IG5vbk51bWJlcnMubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChjb2xvcikgeyAvL3NlbnNlIHJnYmEoKSB2YWx1ZXMgYW5kIHJvdW5kIHRoZW0uXG5cdFx0XHRcdFx0XHRjb2xvciA9IChjb2xvciArIDEpICUgNTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vbk51bWJlcnMuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XG5cdFx0XHRcdFx0XHRjb2xvciA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjdXJyZW50TnVtID09PSBzdGFydE51bXNbaV0gfHwgc3RhcnROdW1zLmxlbmd0aCA8PSBpKSB7XG5cdFx0XHRcdFx0XHRzICs9IGN1cnJlbnROdW07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChzKSB7XG5cdFx0XHRcdFx0XHRcdGEucHVzaChzKTtcblx0XHRcdFx0XHRcdFx0cyA9IFwiXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRudW0gPSBwYXJzZUZsb2F0KHN0YXJ0TnVtc1tpXSk7XG5cdFx0XHRcdFx0XHRhLnB1c2gobnVtKTtcblx0XHRcdFx0XHRcdGEuX2ZpcnN0UFQgPSB7X25leHQ6IGEuX2ZpcnN0UFQsIHQ6YSwgcDogYS5sZW5ndGgtMSwgczpudW0sIGM6KChjdXJyZW50TnVtLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcGFyc2VJbnQoY3VycmVudE51bS5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChjdXJyZW50TnVtLnN1YnN0cigyKSkgOiAocGFyc2VGbG9hdChjdXJyZW50TnVtKSAtIG51bSkpIHx8IDAsIGY6MCwgcjooY29sb3IgJiYgY29sb3IgPCA0KX07XG5cdFx0XHRcdFx0XHQvL25vdGU6IHdlIGRvbid0IHNldCBfcHJldiBiZWNhdXNlIHdlJ2xsIG5ldmVyIG5lZWQgdG8gcmVtb3ZlIGluZGl2aWR1YWwgUHJvcFR3ZWVucyBmcm9tIHRoaXMgbGlzdC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hhckluZGV4ICs9IGN1cnJlbnROdW0ubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHMgKz0gZW5kLnN1YnN0cihjaGFySW5kZXgpO1xuXHRcdFx0XHRpZiAocykge1xuXHRcdFx0XHRcdGEucHVzaChzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhLnNldFJhdGlvID0gX3NldFJhdGlvO1xuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sXG5cdFx0XHQvL25vdGU6IFwiZnVuY1BhcmFtXCIgaXMgb25seSBuZWNlc3NhcnkgZm9yIGZ1bmN0aW9uLWJhc2VkIGdldHRlcnMvc2V0dGVycyB0aGF0IHJlcXVpcmUgYW4gZXh0cmEgcGFyYW1ldGVyIGxpa2UgZ2V0QXR0cmlidXRlKFwid2lkdGhcIikgYW5kIHNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHZhbHVlKS4gSW4gdGhpcyBleGFtcGxlLCBmdW5jUGFyYW0gd291bGQgYmUgXCJ3aWR0aFwiLiBVc2VkIGJ5IEF0dHJQbHVnaW4gZm9yIGV4YW1wbGUuXG5cdFx0XHRfYWRkUHJvcFR3ZWVuID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBvdmVyd3JpdGVQcm9wLCByb3VuZCwgZnVuY1BhcmFtLCBzdHJpbmdGaWx0ZXIpIHtcblx0XHRcdFx0dmFyIHMgPSAoc3RhcnQgPT09IFwiZ2V0XCIpID8gdGFyZ2V0W3Byb3BdIDogc3RhcnQsXG5cdFx0XHRcdFx0dHlwZSA9IHR5cGVvZih0YXJnZXRbcHJvcF0pLFxuXHRcdFx0XHRcdGlzUmVsYXRpdmUgPSAodHlwZW9mKGVuZCkgPT09IFwic3RyaW5nXCIgJiYgZW5kLmNoYXJBdCgxKSA9PT0gXCI9XCIpLFxuXHRcdFx0XHRcdHB0ID0ge3Q6dGFyZ2V0LCBwOnByb3AsIHM6cywgZjoodHlwZSA9PT0gXCJmdW5jdGlvblwiKSwgcGc6MCwgbjpvdmVyd3JpdGVQcm9wIHx8IHByb3AsIHI6cm91bmQsIHByOjAsIGM6aXNSZWxhdGl2ZSA/IHBhcnNlSW50KGVuZC5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChlbmQuc3Vic3RyKDIpKSA6IChwYXJzZUZsb2F0KGVuZCkgLSBzKSB8fCAwfSxcblx0XHRcdFx0XHRibG9iLCBnZXR0ZXJOYW1lO1xuXHRcdFx0XHRpZiAodHlwZSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgc3RhcnQgPT09IFwiZ2V0XCIpIHtcblx0XHRcdFx0XHRcdGdldHRlck5hbWUgPSAoKHByb3AuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwcm9wLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcHJvcCA6IFwiZ2V0XCIgKyBwcm9wLnN1YnN0cigzKSk7XG5cdFx0XHRcdFx0XHRwdC5zID0gcyA9IGZ1bmNQYXJhbSA/IHRhcmdldFtnZXR0ZXJOYW1lXShmdW5jUGFyYW0pIDogdGFyZ2V0W2dldHRlck5hbWVdKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlb2YocykgPT09IFwic3RyaW5nXCIgJiYgKGZ1bmNQYXJhbSB8fCBpc05hTihzKSkpIHtcblx0XHRcdFx0XHRcdC8vYSBibG9iIChzdHJpbmcgdGhhdCBoYXMgbXVsdGlwbGUgbnVtYmVycyBpbiBpdClcblx0XHRcdFx0XHRcdHB0LmZwID0gZnVuY1BhcmFtO1xuXHRcdFx0XHRcdFx0YmxvYiA9IF9ibG9iRGlmKHMsIGVuZCwgc3RyaW5nRmlsdGVyIHx8IFR3ZWVuTGl0ZS5kZWZhdWx0U3RyaW5nRmlsdGVyLCBwdCk7XG5cdFx0XHRcdFx0XHRwdCA9IHt0OmJsb2IsIHA6XCJzZXRSYXRpb1wiLCBzOjAsIGM6MSwgZjoyLCBwZzowLCBuOm92ZXJ3cml0ZVByb3AgfHwgcHJvcCwgcHI6MH07IC8vXCIyXCIgaW5kaWNhdGVzIGl0J3MgYSBCbG9iIHByb3BlcnR5IHR3ZWVuLiBOZWVkZWQgZm9yIFJvdW5kUHJvcHNQbHVnaW4gZm9yIGV4YW1wbGUuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICghaXNSZWxhdGl2ZSkge1xuXHRcdFx0XHRcdFx0cHQucyA9IHBhcnNlRmxvYXQocyk7XG5cdFx0XHRcdFx0XHRwdC5jID0gKHBhcnNlRmxvYXQoZW5kKSAtIHB0LnMpIHx8IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5jKSB7IC8vb25seSBhZGQgaXQgdG8gdGhlIGxpbmtlZCBsaXN0IGlmIHRoZXJlJ3MgYSBjaGFuZ2UuXG5cdFx0XHRcdFx0aWYgKChwdC5fbmV4dCA9IHRoaXMuX2ZpcnN0UFQpKSB7XG5cdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQ7XG5cdFx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X2ludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzID0ge2lzQXJyYXk6X2lzQXJyYXksIGlzU2VsZWN0b3I6X2lzU2VsZWN0b3IsIGxhenlUd2VlbnM6X2xhenlUd2VlbnMsIGJsb2JEaWY6X2Jsb2JEaWZ9LCAvL2dpdmVzIHVzIGEgd2F5IHRvIGV4cG9zZSBjZXJ0YWluIHByaXZhdGUgdmFsdWVzIHRvIG90aGVyIEdyZWVuU29jayBjbGFzc2VzIHdpdGhvdXQgY29udGFtaW5hdGluZyB0aGEgbWFpbiBUd2VlbkxpdGUgb2JqZWN0LlxuXHRcdFx0X3BsdWdpbnMgPSBUd2VlbkxpdGUuX3BsdWdpbnMgPSB7fSxcblx0XHRcdF90d2Vlbkxvb2t1cCA9IF9pbnRlcm5hbHMudHdlZW5Mb29rdXAgPSB7fSxcblx0XHRcdF90d2Vlbkxvb2t1cE51bSA9IDAsXG5cdFx0XHRfcmVzZXJ2ZWRQcm9wcyA9IF9pbnRlcm5hbHMucmVzZXJ2ZWRQcm9wcyA9IHtlYXNlOjEsIGRlbGF5OjEsIG92ZXJ3cml0ZToxLCBvbkNvbXBsZXRlOjEsIG9uQ29tcGxldGVQYXJhbXM6MSwgb25Db21wbGV0ZVNjb3BlOjEsIHVzZUZyYW1lczoxLCBydW5CYWNrd2FyZHM6MSwgc3RhcnRBdDoxLCBvblVwZGF0ZToxLCBvblVwZGF0ZVBhcmFtczoxLCBvblVwZGF0ZVNjb3BlOjEsIG9uU3RhcnQ6MSwgb25TdGFydFBhcmFtczoxLCBvblN0YXJ0U2NvcGU6MSwgb25SZXZlcnNlQ29tcGxldGU6MSwgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6MSwgb25SZXZlcnNlQ29tcGxldGVTY29wZToxLCBvblJlcGVhdDoxLCBvblJlcGVhdFBhcmFtczoxLCBvblJlcGVhdFNjb3BlOjEsIGVhc2VQYXJhbXM6MSwgeW95bzoxLCBpbW1lZGlhdGVSZW5kZXI6MSwgcmVwZWF0OjEsIHJlcGVhdERlbGF5OjEsIGRhdGE6MSwgcGF1c2VkOjEsIHJldmVyc2VkOjEsIGF1dG9DU1M6MSwgbGF6eToxLCBvbk92ZXJ3cml0ZToxLCBjYWxsYmFja1Njb3BlOjEsIHN0cmluZ0ZpbHRlcjoxfSxcblx0XHRcdF9vdmVyd3JpdGVMb29rdXAgPSB7bm9uZTowLCBhbGw6MSwgYXV0bzoyLCBjb25jdXJyZW50OjMsIGFsbE9uU3RhcnQ6NCwgcHJlZXhpc3Rpbmc6NSwgXCJ0cnVlXCI6MSwgXCJmYWxzZVwiOjB9LFxuXHRcdFx0X3Jvb3RGcmFtZXNUaW1lbGluZSA9IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lID0gbmV3IFNpbXBsZVRpbWVsaW5lKCksXG5cdFx0XHRfcm9vdFRpbWVsaW5lID0gQW5pbWF0aW9uLl9yb290VGltZWxpbmUgPSBuZXcgU2ltcGxlVGltZWxpbmUoKSxcblx0XHRcdF9uZXh0R0NGcmFtZSA9IDMwLFxuXHRcdFx0X2xhenlSZW5kZXIgPSBfaW50ZXJuYWxzLmxhenlSZW5kZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGkgPSBfbGF6eVR3ZWVucy5sZW5ndGgsXG5cdFx0XHRcdFx0dHdlZW47XG5cdFx0XHRcdF9sYXp5TG9va3VwID0ge307XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHR3ZWVuID0gX2xhenlUd2VlbnNbaV07XG5cdFx0XHRcdFx0aWYgKHR3ZWVuICYmIHR3ZWVuLl9sYXp5ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfbGF6eVR3ZWVucy5sZW5ndGggPSAwO1xuXHRcdFx0fTtcblxuXHRcdF9yb290VGltZWxpbmUuX3N0YXJ0VGltZSA9IF90aWNrZXIudGltZTtcblx0XHRfcm9vdEZyYW1lc1RpbWVsaW5lLl9zdGFydFRpbWUgPSBfdGlja2VyLmZyYW1lO1xuXHRcdF9yb290VGltZWxpbmUuX2FjdGl2ZSA9IF9yb290RnJhbWVzVGltZWxpbmUuX2FjdGl2ZSA9IHRydWU7XG5cdFx0c2V0VGltZW91dChfbGF6eVJlbmRlciwgMSk7IC8vb24gc29tZSBtb2JpbGUgZGV2aWNlcywgdGhlcmUgaXNuJ3QgYSBcInRpY2tcIiBiZWZvcmUgY29kZSBydW5zIHdoaWNoIG1lYW5zIGFueSBsYXp5IHJlbmRlcnMgd291bGRuJ3QgcnVuIGJlZm9yZSB0aGUgbmV4dCBvZmZpY2lhbCBcInRpY2tcIi5cblxuXHRcdEFuaW1hdGlvbi5fdXBkYXRlUm9vdCA9IFR3ZWVuTGl0ZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGksIGEsIHA7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pZiBjb2RlIGlzIHJ1biBvdXRzaWRlIG9mIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbG9vcCwgdGhlcmUgbWF5IGJlIHR3ZWVucyBxdWV1ZWQgQUZURVIgdGhlIGVuZ2luZSByZWZyZXNoZWQsIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGFueSBwZW5kaW5nIHJlbmRlcnMgb2NjdXIgYmVmb3JlIHdlIHJlZnJlc2ggYWdhaW4uXG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcm9vdFRpbWVsaW5lLnJlbmRlcigoX3RpY2tlci50aW1lIC0gX3Jvb3RUaW1lbGluZS5fc3RhcnRUaW1lKSAqIF9yb290VGltZWxpbmUuX3RpbWVTY2FsZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0X3Jvb3RGcmFtZXNUaW1lbGluZS5yZW5kZXIoKF90aWNrZXIuZnJhbWUgLSBfcm9vdEZyYW1lc1RpbWVsaW5lLl9zdGFydFRpbWUpICogX3Jvb3RGcmFtZXNUaW1lbGluZS5fdGltZVNjYWxlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX3RpY2tlci5mcmFtZSA+PSBfbmV4dEdDRnJhbWUpIHsgLy9kdW1wIGdhcmJhZ2UgZXZlcnkgMTIwIGZyYW1lcyBvciB3aGF0ZXZlciB0aGUgdXNlciBzZXRzIFR3ZWVuTGl0ZS5hdXRvU2xlZXAgdG9cblx0XHRcdFx0XHRfbmV4dEdDRnJhbWUgPSBfdGlja2VyLmZyYW1lICsgKHBhcnNlSW50KFR3ZWVuTGl0ZS5hdXRvU2xlZXAsIDEwKSB8fCAxMjApO1xuXHRcdFx0XHRcdGZvciAocCBpbiBfdHdlZW5Mb29rdXApIHtcblx0XHRcdFx0XHRcdGEgPSBfdHdlZW5Mb29rdXBbcF0udHdlZW5zO1xuXHRcdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhW2ldLl9nYykge1xuXHRcdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoYS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIF90d2Vlbkxvb2t1cFtwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9pZiB0aGVyZSBhcmUgbm8gbW9yZSB0d2VlbnMgaW4gdGhlIHJvb3QgdGltZWxpbmVzLCBvciBpZiB0aGV5J3JlIGFsbCBwYXVzZWQsIG1ha2UgdGhlIF90aW1lciBzbGVlcCB0byByZWR1Y2UgbG9hZCBvbiB0aGUgQ1BVIHNsaWdodGx5XG5cdFx0XHRcdFx0cCA9IF9yb290VGltZWxpbmUuX2ZpcnN0O1xuXHRcdFx0XHRcdGlmICghcCB8fCBwLl9wYXVzZWQpIGlmIChUd2VlbkxpdGUuYXV0b1NsZWVwICYmICFfcm9vdEZyYW1lc1RpbWVsaW5lLl9maXJzdCAmJiBfdGlja2VyLl9saXN0ZW5lcnMudGljay5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRcdHdoaWxlIChwICYmIHAuX3BhdXNlZCkge1xuXHRcdFx0XHRcdFx0XHRwID0gcC5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghcCkge1xuXHRcdFx0XHRcdFx0XHRfdGlja2VyLnNsZWVwKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0X3RpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBBbmltYXRpb24uX3VwZGF0ZVJvb3QpO1xuXG5cdFx0dmFyIF9yZWdpc3RlciA9IGZ1bmN0aW9uKHRhcmdldCwgdHdlZW4sIHNjcnViKSB7XG5cdFx0XHRcdHZhciBpZCA9IHRhcmdldC5fZ3NUd2VlbklELCBhLCBpO1xuXHRcdFx0XHRpZiAoIV90d2Vlbkxvb2t1cFtpZCB8fCAodGFyZ2V0Ll9nc1R3ZWVuSUQgPSBpZCA9IFwidFwiICsgKF90d2Vlbkxvb2t1cE51bSsrKSldKSB7XG5cdFx0XHRcdFx0X3R3ZWVuTG9va3VwW2lkXSA9IHt0YXJnZXQ6dGFyZ2V0LCB0d2VlbnM6W119O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0d2Vlbikge1xuXHRcdFx0XHRcdGEgPSBfdHdlZW5Mb29rdXBbaWRdLnR3ZWVucztcblx0XHRcdFx0XHRhWyhpID0gYS5sZW5ndGgpXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdGlmIChzY3J1Yikge1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhW2ldID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBfdHdlZW5Mb29rdXBbaWRdLnR3ZWVucztcblx0XHRcdH0sXG5cdFx0XHRfb25PdmVyd3JpdGUgPSBmdW5jdGlvbihvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKSB7XG5cdFx0XHRcdHZhciBmdW5jID0gb3ZlcndyaXR0ZW5Ud2Vlbi52YXJzLm9uT3ZlcndyaXRlLCByMSwgcjI7XG5cdFx0XHRcdGlmIChmdW5jKSB7XG5cdFx0XHRcdFx0cjEgPSBmdW5jKG92ZXJ3cml0dGVuVHdlZW4sIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkUHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmMgPSBUd2VlbkxpdGUub25PdmVyd3JpdGU7XG5cdFx0XHRcdGlmIChmdW5jKSB7XG5cdFx0XHRcdFx0cjIgPSBmdW5jKG92ZXJ3cml0dGVuVHdlZW4sIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkUHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAocjEgIT09IGZhbHNlICYmIHIyICE9PSBmYWxzZSk7XG5cdFx0XHR9LFxuXHRcdFx0X2FwcGx5T3ZlcndyaXRlID0gZnVuY3Rpb24odGFyZ2V0LCB0d2VlbiwgcHJvcHMsIG1vZGUsIHNpYmxpbmdzKSB7XG5cdFx0XHRcdHZhciBpLCBjaGFuZ2VkLCBjdXJUd2VlbiwgbDtcblx0XHRcdFx0aWYgKG1vZGUgPT09IDEgfHwgbW9kZSA+PSA0KSB7XG5cdFx0XHRcdFx0bCA9IHNpYmxpbmdzLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoKGN1clR3ZWVuID0gc2libGluZ3NbaV0pICE9PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoIWN1clR3ZWVuLl9nYykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjdXJUd2Vlbi5fa2lsbChudWxsLCB0YXJnZXQsIHR3ZWVuKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG1vZGUgPT09IDUpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vTk9URTogQWRkIDAuMDAwMDAwMDAwMSB0byBvdmVyY29tZSBmbG9hdGluZyBwb2ludCBlcnJvcnMgdGhhdCBjYW4gY2F1c2UgdGhlIHN0YXJ0VGltZSB0byBiZSBWRVJZIHNsaWdodGx5IG9mZiAod2hlbiBhIHR3ZWVuJ3MgdGltZSgpIGlzIHNldCBmb3IgZXhhbXBsZSlcblx0XHRcdFx0dmFyIHN0YXJ0VGltZSA9IHR3ZWVuLl9zdGFydFRpbWUgKyBfdGlueU51bSxcblx0XHRcdFx0XHRvdmVybGFwcyA9IFtdLFxuXHRcdFx0XHRcdG9Db3VudCA9IDAsXG5cdFx0XHRcdFx0emVyb0R1ciA9ICh0d2Vlbi5fZHVyYXRpb24gPT09IDApLFxuXHRcdFx0XHRcdGdsb2JhbFN0YXJ0O1xuXHRcdFx0XHRpID0gc2libGluZ3MubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoKGN1clR3ZWVuID0gc2libGluZ3NbaV0pID09PSB0d2VlbiB8fCBjdXJUd2Vlbi5fZ2MgfHwgY3VyVHdlZW4uX3BhdXNlZCkge1xuXHRcdFx0XHRcdFx0Ly9pZ25vcmVcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGN1clR3ZWVuLl90aW1lbGluZSAhPT0gdHdlZW4uX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0XHRnbG9iYWxTdGFydCA9IGdsb2JhbFN0YXJ0IHx8IF9jaGVja092ZXJsYXAodHdlZW4sIDAsIHplcm9EdXIpO1xuXHRcdFx0XHRcdFx0aWYgKF9jaGVja092ZXJsYXAoY3VyVHdlZW4sIGdsb2JhbFN0YXJ0LCB6ZXJvRHVyKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRvdmVybGFwc1tvQ291bnQrK10gPSBjdXJUd2Vlbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGN1clR3ZWVuLl9zdGFydFRpbWUgPD0gc3RhcnRUaW1lKSBpZiAoY3VyVHdlZW4uX3N0YXJ0VGltZSArIGN1clR3ZWVuLnRvdGFsRHVyYXRpb24oKSAvIGN1clR3ZWVuLl90aW1lU2NhbGUgPiBzdGFydFRpbWUpIGlmICghKCh6ZXJvRHVyIHx8ICFjdXJUd2Vlbi5faW5pdHRlZCkgJiYgc3RhcnRUaW1lIC0gY3VyVHdlZW4uX3N0YXJ0VGltZSA8PSAwLjAwMDAwMDAwMDIpKSB7XG5cdFx0XHRcdFx0XHRvdmVybGFwc1tvQ291bnQrK10gPSBjdXJUd2Vlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpID0gb0NvdW50O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRjdXJUd2VlbiA9IG92ZXJsYXBzW2ldO1xuXHRcdFx0XHRcdGlmIChtb2RlID09PSAyKSBpZiAoY3VyVHdlZW4uX2tpbGwocHJvcHMsIHRhcmdldCwgdHdlZW4pKSB7XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1vZGUgIT09IDIgfHwgKCFjdXJUd2Vlbi5fZmlyc3RQVCAmJiBjdXJUd2Vlbi5faW5pdHRlZCkpIHtcblx0XHRcdFx0XHRcdGlmIChtb2RlICE9PSAyICYmICFfb25PdmVyd3JpdGUoY3VyVHdlZW4sIHR3ZWVuKSkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChjdXJUd2Vlbi5fZW5hYmxlZChmYWxzZSwgZmFsc2UpKSB7IC8vaWYgYWxsIHByb3BlcnR5IHR3ZWVucyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4sIGtpbGwgdGhlIHR3ZWVuLlxuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0XHR9LFxuXHRcdFx0X2NoZWNrT3ZlcmxhcCA9IGZ1bmN0aW9uKHR3ZWVuLCByZWZlcmVuY2UsIHplcm9EdXIpIHtcblx0XHRcdFx0dmFyIHRsID0gdHdlZW4uX3RpbWVsaW5lLFxuXHRcdFx0XHRcdHRzID0gdGwuX3RpbWVTY2FsZSxcblx0XHRcdFx0XHR0ID0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdHQgKz0gdGwuX3N0YXJ0VGltZTtcblx0XHRcdFx0XHR0cyAqPSB0bC5fdGltZVNjYWxlO1xuXHRcdFx0XHRcdGlmICh0bC5fcGF1c2VkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gLTEwMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dCAvPSB0cztcblx0XHRcdFx0cmV0dXJuICh0ID4gcmVmZXJlbmNlKSA/IHQgLSByZWZlcmVuY2UgOiAoKHplcm9EdXIgJiYgdCA9PT0gcmVmZXJlbmNlKSB8fCAoIXR3ZWVuLl9pbml0dGVkICYmIHQgLSByZWZlcmVuY2UgPCAyICogX3RpbnlOdW0pKSA/IF90aW55TnVtIDogKCh0ICs9IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSAvIHR3ZWVuLl90aW1lU2NhbGUgLyB0cykgPiByZWZlcmVuY2UgKyBfdGlueU51bSkgPyAwIDogdCAtIHJlZmVyZW5jZSAtIF90aW55TnVtO1xuXHRcdFx0fTtcblxuXG4vLy0tLS0gVHdlZW5MaXRlIGluc3RhbmNlIG1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAuX2luaXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB2ID0gdGhpcy52YXJzLFxuXHRcdFx0XHRvcCA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMsXG5cdFx0XHRcdGR1ciA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRpbW1lZGlhdGUgPSAhIXYuaW1tZWRpYXRlUmVuZGVyLFxuXHRcdFx0XHRlYXNlID0gdi5lYXNlLFxuXHRcdFx0XHRpLCBpbml0UGx1Z2lucywgcHQsIHAsIHN0YXJ0VmFycztcblx0XHRcdGlmICh2LnN0YXJ0QXQpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7IC8vaWYgd2UndmUgcnVuIGEgc3RhcnRBdCBwcmV2aW91c2x5ICh3aGVuIHRoZSB0d2VlbiBpbnN0YW50aWF0ZWQpLCB3ZSBzaG91bGQgcmV2ZXJ0IGl0IHNvIHRoYXQgdGhlIHZhbHVlcyByZS1pbnN0YW50aWF0ZSBjb3JyZWN0bHkgcGFydGljdWxhcmx5IGZvciByZWxhdGl2ZSB0d2VlbnMuIFdpdGhvdXQgdGhpcywgYSBUd2VlbkxpdGUuZnJvbVRvKG9iaiwgMSwge3g6XCIrPTEwMFwifSwge3g6XCItPTEwMFwifSksIGZvciBleGFtcGxlLCB3b3VsZCBhY3R1YWxseSBqdW1wIHRvICs9MjAwIGJlY2F1c2UgdGhlIHN0YXJ0QXQgd291bGQgcnVuIHR3aWNlLCBkb3VibGluZyB0aGUgcmVsYXRpdmUgY2hhbmdlLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQua2lsbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0VmFycyA9IHt9O1xuXHRcdFx0XHRmb3IgKHAgaW4gdi5zdGFydEF0KSB7IC8vY29weSB0aGUgcHJvcGVydGllcy92YWx1ZXMgaW50byBhIG5ldyBvYmplY3QgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSB2YXIgdG8gPSB7eDowfSwgZnJvbSA9IHt4OjUwMH07IHRpbWVsaW5lLmZyb21UbyhlLCAxLCBmcm9tLCB0bykuZnJvbVRvKGUsIDEsIHRvLCBmcm9tKTtcblx0XHRcdFx0XHRzdGFydFZhcnNbcF0gPSB2LnN0YXJ0QXRbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhcnRWYXJzLm92ZXJ3cml0ZSA9IGZhbHNlO1xuXHRcdFx0XHRzdGFydFZhcnMuaW1tZWRpYXRlUmVuZGVyID0gdHJ1ZTtcblx0XHRcdFx0c3RhcnRWYXJzLmxhenkgPSAoaW1tZWRpYXRlICYmIHYubGF6eSAhPT0gZmFsc2UpO1xuXHRcdFx0XHRzdGFydFZhcnMuc3RhcnRBdCA9IHN0YXJ0VmFycy5kZWxheSA9IG51bGw7IC8vbm8gbmVzdGluZyBvZiBzdGFydEF0IG9iamVjdHMgYWxsb3dlZCAob3RoZXJ3aXNlIGl0IGNvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3ApLlxuXHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gVHdlZW5MaXRlLnRvKHRoaXMudGFyZ2V0LCAwLCBzdGFydFZhcnMpO1xuXHRcdFx0XHRpZiAoaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgPiAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDsgLy90d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgKGxpa2UgbW9zdCBmcm9tKCkgYW5kIGZyb21UbygpIHR3ZWVucykgc2hvdWxkbid0IHJldmVydCB3aGVuIHRoZWlyIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgc3RhcnRUaW1lIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIGNvdWxkIGhhdmUgaGFwcGVuZWQgYW55dGltZSBhbmQgaXQgc2hvdWxkbid0IGJlIGRpcmVjdGx5IGNvcnJlbGF0ZWQgdG8gdGhpcyB0d2VlbidzIHN0YXJ0VGltZS4gSW1hZ2luZSBzZXR0aW5nIHVwIGEgY29tcGxleCBhbmltYXRpb24gd2hlcmUgdGhlIGJlZ2lubmluZyBzdGF0ZXMgb2YgdmFyaW91cyBvYmplY3RzIGFyZSByZW5kZXJlZCBpbW1lZGlhdGVseSBidXQgdGhlIHR3ZWVuIGRvZXNuJ3QgaGFwcGVuIGZvciBxdWl0ZSBzb21lIHRpbWUgLSBpZiB3ZSByZXZlcnQgdG8gdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcyBzb29uIGFzIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHR3ZWVuJ3Mgc3RhcnRUaW1lLCBpdCB3aWxsIHRocm93IHRoaW5ncyBvZmYgdmlzdWFsbHkuIFJldmVyc2lvbiBzaG91bGQgb25seSBoYXBwZW4gaW4gVGltZWxpbmVMaXRlL01heCBpbnN0YW5jZXMgd2hlcmUgaW1tZWRpYXRlUmVuZGVyIHdhcyBmYWxzZSAod2hpY2ggaXMgdGhlIGRlZmF1bHQgaW4gdGhlIGNvbnZlbmllbmNlIG1ldGhvZHMgbGlrZSBmcm9tKCkpLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZHVyICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmVMaXRlIG9yIFRpbWVsaW5lTWF4LCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh2LnJ1bkJhY2t3YXJkcyAmJiBkdXIgIT09IDApIHtcblx0XHRcdFx0Ly9mcm9tKCkgdHdlZW5zIG11c3QgYmUgaGFuZGxlZCB1bmlxdWVseTogdGhlaXIgYmVnaW5uaW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkIGJ1dCB3ZSBkb24ndCB3YW50IG92ZXJ3cml0aW5nIHRvIG9jY3VyIHlldCAod2hlbiB0aW1lIGlzIHN0aWxsIDApLiBXYWl0IHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMgYmVmb3JlIGRvaW5nIGFsbCB0aGUgcm91dGluZXMgbGlrZSBvdmVyd3JpdGluZy4gQXQgdGhhdCB0aW1lLCB3ZSBzaG91bGQgcmVuZGVyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIHRvIGVuc3VyZSB0aGF0IHRoaW5ncyBpbml0aWFsaXplIGNvcnJlY3RseSAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgZ28gYmFja3dhcmRzKVxuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LmtpbGwoKTtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSAhPT0gMCkgeyAvL2luIHJhcmUgY2FzZXMgKGxpa2UgaWYgYSBmcm9tKCkgdHdlZW4gcnVucyBhbmQgdGhlbiBpcyBpbnZhbGlkYXRlKCktZWQpLCBpbW1lZGlhdGVSZW5kZXIgY291bGQgYmUgdHJ1ZSBidXQgdGhlIGluaXRpYWwgZm9yY2VkLXJlbmRlciBnZXRzIHNraXBwZWQsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSB0aGUgcmVuZGVyIGluIHRoaXMgY29udGV4dCB3aGVuIHRoZSBfdGltZSBpcyBncmVhdGVyIHRoYW4gMFxuXHRcdFx0XHRcdFx0aW1tZWRpYXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0ge307XG5cdFx0XHRcdFx0Zm9yIChwIGluIHYpIHsgLy9jb3B5IHByb3BzIGludG8gYSBuZXcgb2JqZWN0IGFuZCBza2lwIGFueSByZXNlcnZlZCBwcm9wcywgb3RoZXJ3aXNlIG9uQ29tcGxldGUgb3Igb25VcGRhdGUgb3Igb25TdGFydCBjb3VsZCBmaXJlLiBXZSBzaG91bGQsIGhvd2V2ZXIsIHBlcm1pdCBhdXRvQ1NTIHRvIGdvIHRocm91Z2guXG5cdFx0XHRcdFx0XHRpZiAoIV9yZXNlcnZlZFByb3BzW3BdIHx8IHAgPT09IFwiYXV0b0NTU1wiKSB7XG5cdFx0XHRcdFx0XHRcdHB0W3BdID0gdltwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQub3ZlcndyaXRlID0gMDtcblx0XHRcdFx0XHRwdC5kYXRhID0gXCJpc0Zyb21TdGFydFwiOyAvL3dlIHRhZyB0aGUgdHdlZW4gd2l0aCBhcyBcImlzRnJvbVN0YXJ0XCIgc28gdGhhdCBpZiBbaW5zaWRlIGEgcGx1Z2luXSB3ZSBuZWVkIHRvIG9ubHkgZG8gc29tZXRoaW5nIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuLCB3ZSBoYXZlIGEgd2F5IG9mIGlkZW50aWZ5aW5nIHRoaXMgdHdlZW4gYXMgbWVyZWx5IHRoZSBvbmUgdGhhdCdzIHNldHRpbmcgdGhlIGJlZ2lubmluZyB2YWx1ZXMgZm9yIGEgXCJmcm9tKClcIiB0d2Vlbi4gRm9yIGV4YW1wbGUsIGNsZWFyUHJvcHMgaW4gQ1NTUGx1Z2luIHNob3VsZCBvbmx5IGdldCBhcHBsaWVkIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuIGFuZCB3aXRob3V0IHRoaXMgdGFnLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbi5cblx0XHRcdFx0XHRwdC5sYXp5ID0gKGltbWVkaWF0ZSAmJiB2LmxhenkgIT09IGZhbHNlKTtcblx0XHRcdFx0XHRwdC5pbW1lZGlhdGVSZW5kZXIgPSBpbW1lZGlhdGU7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgcmVuZGVyIGltbWVkaWF0ZWx5IGJ5IGRlZmF1bHQsIGJ1dCBpZiB3ZSdyZSBub3Qgc3BlY2lmaWNhbGx5IGluc3RydWN0ZWQgdG8gcmVuZGVyIHRoaXMgdHdlZW4gaW1tZWRpYXRlbHksIHdlIHNob3VsZCBza2lwIHRoaXMgYW5kIG1lcmVseSBfaW5pdCgpIHRvIHJlY29yZCB0aGUgc3RhcnRpbmcgdmFsdWVzIChyZW5kZXJpbmcgdGhlbSBpbW1lZGlhdGVseSB3b3VsZCBwdXNoIHRoZW0gdG8gY29tcGxldGlvbiB3aGljaCBpcyB3YXN0ZWZ1bCBpbiB0aGF0IGNhc2UgLSB3ZSdkIGhhdmUgdG8gcmVuZGVyKC0xKSBpbW1lZGlhdGVseSBhZnRlcilcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gVHdlZW5MaXRlLnRvKHRoaXMudGFyZ2V0LCAwLCBwdCk7XG5cdFx0XHRcdFx0aWYgKCFpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQuX2luaXQoKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgdmFsdWVzIGFyZSByZWNvcmRlZFxuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5fZW5hYmxlZChmYWxzZSk7IC8vbm8gbmVlZCB0byBoYXZlIHRoZSB0d2VlbiByZW5kZXIgb24gdGhlIG5leHQgY3ljbGUuIERpc2FibGUgaXQgYmVjYXVzZSB3ZSdsbCBhbHdheXMgbWFudWFsbHkgY29udHJvbCB0aGUgcmVuZGVycyBvZiB0aGUgX3N0YXJ0QXQgdHdlZW4uXG5cdFx0XHRcdFx0XHRpZiAodGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlcikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPT09IDApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2Vhc2UgPSBlYXNlID0gKCFlYXNlKSA/IFR3ZWVuTGl0ZS5kZWZhdWx0RWFzZSA6IChlYXNlIGluc3RhbmNlb2YgRWFzZSkgPyBlYXNlIDogKHR5cGVvZihlYXNlKSA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyBFYXNlKGVhc2UsIHYuZWFzZVBhcmFtcykgOiBfZWFzZU1hcFtlYXNlXSB8fCBUd2VlbkxpdGUuZGVmYXVsdEVhc2U7XG5cdFx0XHRpZiAodi5lYXNlUGFyYW1zIGluc3RhbmNlb2YgQXJyYXkgJiYgZWFzZS5jb25maWcpIHtcblx0XHRcdFx0dGhpcy5fZWFzZSA9IGVhc2UuY29uZmlnLmFwcGx5KGVhc2UsIHYuZWFzZVBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9lYXNlVHlwZSA9IHRoaXMuX2Vhc2UuX3R5cGU7XG5cdFx0XHR0aGlzLl9lYXNlUG93ZXIgPSB0aGlzLl9lYXNlLl9wb3dlcjtcblx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBudWxsO1xuXG5cdFx0XHRpZiAodGhpcy5fdGFyZ2V0cykge1xuXHRcdFx0XHRpID0gdGhpcy5fdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5faW5pdFByb3BzKCB0aGlzLl90YXJnZXRzW2ldLCAodGhpcy5fcHJvcExvb2t1cFtpXSA9IHt9KSwgdGhpcy5fc2libGluZ3NbaV0sIChvcCA/IG9wW2ldIDogbnVsbCkpICkge1xuXHRcdFx0XHRcdFx0aW5pdFBsdWdpbnMgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5pdFBsdWdpbnMgPSB0aGlzLl9pbml0UHJvcHModGhpcy50YXJnZXQsIHRoaXMuX3Byb3BMb29rdXAsIHRoaXMuX3NpYmxpbmdzLCBvcCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbml0UGx1Z2lucykge1xuXHRcdFx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoXCJfb25Jbml0QWxsUHJvcHNcIiwgdGhpcyk7IC8vcmVvcmRlcnMgdGhlIGFycmF5IGluIG9yZGVyIG9mIHByaW9yaXR5LiBVc2VzIGEgc3RhdGljIFR3ZWVuUGx1Z2luIG1ldGhvZCBpbiBvcmRlciB0byBtaW5pbWl6ZSBmaWxlIHNpemUgaW4gVHdlZW5MaXRlXG5cdFx0XHR9XG5cdFx0XHRpZiAob3ApIGlmICghdGhpcy5fZmlyc3RQVCkgaWYgKHR5cGVvZih0aGlzLnRhcmdldCkgIT09IFwiZnVuY3Rpb25cIikgeyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiwga2lsbCB0aGUgdHdlZW4uIElmIHRoZSB0YXJnZXQgaXMgYSBmdW5jdGlvbiwgaXQncyBwcm9iYWJseSBhIGRlbGF5ZWRDYWxsIHNvIGxldCBpdCBsaXZlLlxuXHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodi5ydW5CYWNrd2FyZHMpIHtcblx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRwdC5zICs9IHB0LmM7XG5cdFx0XHRcdFx0cHQuYyA9IC1wdC5jO1xuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX29uVXBkYXRlID0gdi5vblVwZGF0ZTtcblx0XHRcdHRoaXMuX2luaXR0ZWQgPSB0cnVlO1xuXHRcdH07XG5cblx0XHRwLl9pbml0UHJvcHMgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BMb29rdXAsIHNpYmxpbmdzLCBvdmVyd3JpdHRlblByb3BzKSB7XG5cdFx0XHR2YXIgcCwgaSwgaW5pdFBsdWdpbnMsIHBsdWdpbiwgcHQsIHY7XG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2xhenlMb29rdXBbdGFyZ2V0Ll9nc1R3ZWVuSURdKSB7XG5cdFx0XHRcdF9sYXp5UmVuZGVyKCk7IC8vaWYgb3RoZXIgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldCBoYXZlIHJlY2VudGx5IGluaXR0ZWQgYnV0IGhhdmVuJ3QgcmVuZGVyZWQgeWV0LCB3ZSd2ZSBnb3QgdG8gZm9yY2UgdGhlIHJlbmRlciBzbyB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZXMgYXJlIGNvcnJlY3QgKGltYWdpbmUgcG9wdWxhdGluZyBhIHRpbWVsaW5lIHdpdGggYSBidW5jaCBvZiBzZXF1ZW50aWFsIHR3ZWVucyBhbmQgdGhlbiBqdW1waW5nIHRvIHRoZSBlbmQpXG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy52YXJzLmNzcykgaWYgKHRhcmdldC5zdHlsZSkgaWYgKHRhcmdldCAhPT0gd2luZG93ICYmIHRhcmdldC5ub2RlVHlwZSkgaWYgKF9wbHVnaW5zLmNzcykgaWYgKHRoaXMudmFycy5hdXRvQ1NTICE9PSBmYWxzZSkgeyAvL2l0J3Mgc28gY29tbW9uIHRvIHVzZSBUd2VlbkxpdGUvTWF4IHRvIGFuaW1hdGUgdGhlIGNzcyBvZiBET00gZWxlbWVudHMsIHdlIGFzc3VtZSB0aGF0IGlmIHRoZSB0YXJnZXQgaXMgYSBET00gZWxlbWVudCwgdGhhdCdzIHdoYXQgaXMgaW50ZW5kZWQgKGEgY29udmVuaWVuY2Ugc28gdGhhdCB1c2VycyBkb24ndCBoYXZlIHRvIHdyYXAgdGhpbmdzIGluIGNzczp7fSwgYWx0aG91Z2ggd2Ugc3RpbGwgcmVjb21tZW5kIGl0IGZvciBhIHNsaWdodCBwZXJmb3JtYW5jZSBib29zdCBhbmQgYmV0dGVyIHNwZWNpZmljaXR5KS4gTm90ZTogd2UgY2Fubm90IGNoZWNrIFwibm9kZVR5cGVcIiBvbiB0aGUgd2luZG93IGluc2lkZSBhbiBpZnJhbWUuXG5cdFx0XHRcdF9hdXRvQ1NTKHRoaXMudmFycywgdGFyZ2V0KTtcblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiB0aGlzLnZhcnMpIHtcblx0XHRcdFx0diA9IHRoaXMudmFyc1twXTtcblx0XHRcdFx0aWYgKF9yZXNlcnZlZFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0aWYgKHYpIGlmICgodiBpbnN0YW5jZW9mIEFycmF5KSB8fCAodi5wdXNoICYmIF9pc0FycmF5KHYpKSkgaWYgKHYuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dGhpcy52YXJzW3BdID0gdiA9IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXModiwgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoX3BsdWdpbnNbcF0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twXSgpKS5fb25Jbml0VHdlZW4odGFyZ2V0LCB0aGlzLnZhcnNbcF0sIHRoaXMpKSB7XG5cblx0XHRcdFx0XHQvL3QgLSB0YXJnZXQgXHRcdFtvYmplY3RdXG5cdFx0XHRcdFx0Ly9wIC0gcHJvcGVydHkgXHRcdFtzdHJpbmddXG5cdFx0XHRcdFx0Ly9zIC0gc3RhcnRcdFx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdC8vYyAtIGNoYW5nZVx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdC8vZiAtIGlzRnVuY3Rpb25cdFtib29sZWFuXVxuXHRcdFx0XHRcdC8vbiAtIG5hbWVcdFx0XHRbc3RyaW5nXVxuXHRcdFx0XHRcdC8vcGcgLSBpc1BsdWdpbiBcdFtib29sZWFuXVxuXHRcdFx0XHRcdC8vcHIgLSBwcmlvcml0eVx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdCA9IHtfbmV4dDp0aGlzLl9maXJzdFBULCB0OnBsdWdpbiwgcDpcInNldFJhdGlvXCIsIHM6MCwgYzoxLCBmOjEsIG46cCwgcGc6MSwgcHI6cGx1Z2luLl9wcmlvcml0eX07XG5cdFx0XHRcdFx0aSA9IHBsdWdpbi5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cHJvcExvb2t1cFtwbHVnaW4uX292ZXJ3cml0ZVByb3BzW2ldXSA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwbHVnaW4uX3ByaW9yaXR5IHx8IHBsdWdpbi5fb25Jbml0QWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdGluaXRQbHVnaW5zID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBsdWdpbi5fb25EaXNhYmxlIHx8IHBsdWdpbi5fb25FbmFibGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJvcExvb2t1cFtwXSA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0aGlzLCB0YXJnZXQsIHAsIFwiZ2V0XCIsIHYsIHAsIDAsIG51bGwsIHRoaXMudmFycy5zdHJpbmdGaWx0ZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvdmVyd3JpdHRlblByb3BzKSBpZiAodGhpcy5fa2lsbChvdmVyd3JpdHRlblByb3BzLCB0YXJnZXQpKSB7IC8vYW5vdGhlciB0d2VlbiBtYXkgaGF2ZSB0cmllZCB0byBvdmVyd3JpdGUgcHJvcGVydGllcyBvZiB0aGlzIHR3ZWVuIGJlZm9yZSBpbml0KCkgd2FzIGNhbGxlZCAobGlrZSBpZiB0d28gdHdlZW5zIHN0YXJ0IGF0IHRoZSBzYW1lIHRpbWUsIHRoZSBvbmUgY3JlYXRlZCBzZWNvbmQgd2lsbCBydW4gZmlyc3QpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9pbml0UHJvcHModGFyZ2V0LCBwcm9wTG9va3VwLCBzaWJsaW5ncywgb3ZlcndyaXR0ZW5Qcm9wcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fb3ZlcndyaXRlID4gMSkgaWYgKHRoaXMuX2ZpcnN0UFQpIGlmIChzaWJsaW5ncy5sZW5ndGggPiAxKSBpZiAoX2FwcGx5T3ZlcndyaXRlKHRhcmdldCwgdGhpcywgcHJvcExvb2t1cCwgdGhpcy5fb3ZlcndyaXRlLCBzaWJsaW5ncykpIHtcblx0XHRcdFx0dGhpcy5fa2lsbChwcm9wTG9va3VwLCB0YXJnZXQpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5faW5pdFByb3BzKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2ZpcnN0UFQpIGlmICgodGhpcy52YXJzLmxhenkgIT09IGZhbHNlICYmIHRoaXMuX2R1cmF0aW9uKSB8fCAodGhpcy52YXJzLmxhenkgJiYgIXRoaXMuX2R1cmF0aW9uKSkgeyAvL3plcm8gZHVyYXRpb24gdHdlZW5zIGRvbid0IGxhenkgcmVuZGVyIGJ5IGRlZmF1bHQ7IGV2ZXJ5dGhpbmcgZWxzZSBkb2VzLlxuXHRcdFx0XHRfbGF6eUxvb2t1cFt0YXJnZXQuX2dzVHdlZW5JRF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluaXRQbHVnaW5zO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0dmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0ZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdGlzQ29tcGxldGUsIGNhbGxiYWNrLCBwdCwgcmF3UHJldlRpbWU7XG5cdFx0XHRpZiAodGltZSA+PSBkdXJhdGlvbiAtIDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSBkdXJhdGlvbjtcblx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDEpIDogMTtcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXZlcnNlZCApIHtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25Db21wbGV0ZVwiO1xuXHRcdFx0XHRcdGZvcmNlID0gKGZvcmNlIHx8IHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbik7IC8vb3RoZXJ3aXNlLCBpZiB0aGUgYW5pbWF0aW9uIGlzIHVucGF1c2VkL2FjdGl2YXRlZCBhZnRlciBpdCdzIGFscmVhZHkgZmluaXNoZWQsIGl0IGRvZXNuJ3QgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHRpbWVsaW5lLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0VGltZSA9PT0gdGhpcy5fdGltZWxpbmUuX2R1cmF0aW9uKSB7IC8vaWYgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGlzIGF0IHRoZSBWRVJZIGVuZCBvZiBhIHRpbWVsaW5lIGFuZCB0aGF0IHRpbWVsaW5lIHJlbmRlcnMgYXQgaXRzIGVuZCwgaXQgd2lsbCB0eXBpY2FsbHkgYWRkIGEgdGlueSBiaXQgb2YgY3VzaGlvbiB0byB0aGUgcmVuZGVyIHRpbWUgdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnMgZnJvbSBnZXR0aW5nIGluIHRoZSB3YXkgb2YgdHdlZW5zIHJlbmRlcmluZyB0aGVpciBWRVJZIGVuZC4gSWYgd2UgdGhlbiByZXZlcnNlKCkgdGhhdCB0aW1lbGluZSwgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gd2lsbCB0cmlnZ2VyIGl0cyBvblJldmVyc2VDb21wbGV0ZSBldmVuIHRob3VnaCB0ZWNobmljYWxseSB0aGUgcGxheWhlYWQgZGlkbid0IHBhc3Mgb3ZlciBpdCBhZ2Fpbi4gSXQncyBhIHZlcnkgc3BlY2lmaWMgZWRnZSBjYXNlIHdlIG11c3QgYWNjb21tb2RhdGUuXG5cdFx0XHRcdFx0XHR0aW1lID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA8IDAgfHwgKHRpbWUgPD0gMCAmJiB0aW1lID49IC0wLjAwMDAwMDEpIHx8IChwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHRoaXMuZGF0YSAhPT0gXCJpc1BhdXNlXCIpKSBpZiAocHJldlJhd1ByZXZUaW1lICE9PSB0aW1lKSB7IC8vbm90ZTogd2hlbiB0aGlzLmRhdGEgaXMgXCJpc1BhdXNlXCIsIGl0J3MgYSBjYWxsYmFjayBhZGRlZCBieSBhZGRQYXVzZSgpIG9uIGEgdGltZWxpbmUgdGhhdCB3ZSBzaG91bGQgbm90IGJlIHRyaWdnZXJlZCB3aGVuIExFQVZJTkcgaXRzIGV4YWN0IHN0YXJ0IHRpbWUuIEluIG90aGVyIHdvcmRzLCB0bC5hZGRQYXVzZSgxKS5wbGF5KDEpIHNob3VsZG4ndCBwYXVzZS5cblx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDApIDogMDtcblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSAwIHx8IChkdXJhdGlvbiA9PT0gMCAmJiBwcmV2UmF3UHJldlRpbWUgPiAwKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+PSAwICYmICEocHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiB0aGlzLmRhdGEgPT09IFwiaXNQYXVzZVwiKSkge1xuXHRcdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkgeyAvL2lmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cblx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9lYXNlVHlwZSkge1xuXHRcdFx0XHRcdHZhciByID0gdGltZSAvIGR1cmF0aW9uLCB0eXBlID0gdGhpcy5fZWFzZVR5cGUsIHBvdyA9IHRoaXMuX2Vhc2VQb3dlcjtcblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSB8fCAodHlwZSA9PT0gMyAmJiByID49IDAuNSkpIHtcblx0XHRcdFx0XHRcdHIgPSAxIC0gcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBvdyA9PT0gMSkge1xuXHRcdFx0XHRcdFx0ciAqPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAyKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gNCkge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHIgKiByO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAyKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRpbWUgLyBkdXJhdGlvbiA8IDAuNSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHIgLyAyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIChyIC8gMik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdGltZSA9PT0gcHJldlRpbWUgJiYgIWZvcmNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdCgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQgfHwgdGhpcy5fZ2MpIHsgLy9pbW1lZGlhdGVSZW5kZXIgdHdlZW5zIHR5cGljYWxseSB3b24ndCBpbml0aWFsaXplIHVudGlsIHRoZSBwbGF5aGVhZCBhZHZhbmNlcyAoX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDApIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IG92ZXJ3cml0aW5nIG9jY3VycyBwcm9wZXJseS4gQWxzbywgaWYgYWxsIG9mIHRoZSB0d2VlbmluZyBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiAod2hpY2ggd291bGQgY2F1c2UgX2djIHRvIGJlIHRydWUsIGFzIHNldCBpbiBfaW5pdCgpKSwgd2Ugc2hvdWxkbid0IGNvbnRpbnVlIG90aGVyd2lzZSBhbiBvblN0YXJ0IGNhbGxiYWNrIGNvdWxkIGJlIGNhbGxlZCBmb3IgZXhhbXBsZS5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWZvcmNlICYmIHRoaXMuX2ZpcnN0UFQgJiYgKCh0aGlzLnZhcnMubGF6eSAhPT0gZmFsc2UgJiYgdGhpcy5fZHVyYXRpb24pIHx8ICh0aGlzLnZhcnMubGF6eSAmJiAhdGhpcy5fZHVyYXRpb24pKSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSBwcmV2VGltZTtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHByZXZSYXdQcmV2VGltZTtcblx0XHRcdFx0XHRfbGF6eVR3ZWVucy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdHRoaXMuX2xhenkgPSBbdGltZSwgc3VwcHJlc3NFdmVudHNdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL19lYXNlIGlzIGluaXRpYWxseSBzZXQgdG8gZGVmYXVsdEVhc2UsIHNvIG5vdyB0aGF0IGluaXQoKSBoYXMgcnVuLCBfZWFzZSBpcyBzZXQgcHJvcGVybHkgYW5kIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhlIHJhdGlvLiBPdmVyYWxsIHRoaXMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY29uZGl0aW9uYWwgbG9naWMgZWFybGllciBpbiB0aGUgbWV0aG9kIHRvIGF2b2lkIGhhdmluZyB0byBzZXQgcmF0aW8gdHdpY2UgYmVjYXVzZSB3ZSBvbmx5IGluaXQoKSBvbmNlIGJ1dCByZW5kZXJUaW1lKCkgZ2V0cyBjYWxsZWQgVkVSWSBmcmVxdWVudGx5LlxuXHRcdFx0XHRpZiAodGhpcy5fdGltZSAmJiAhaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNDb21wbGV0ZSAmJiB0aGlzLl9lYXNlLl9jYWxjRW5kKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oKHRoaXMuX3RpbWUgPT09IDApID8gMCA6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fbGF6eSAhPT0gZmFsc2UpIHsgLy9pbiBjYXNlIGEgbGF6eSByZW5kZXIgaXMgcGVuZGluZywgd2Ugc2hvdWxkIGZsdXNoIGl0IGJlY2F1c2UgdGhlIG5ldyByZW5kZXIgaXMgb2NjdXJyaW5nIG5vdyAoaW1hZ2luZSBhIGxhenkgdHdlZW4gaW5zdGFudGlhdGluZyBhbmQgdGhlbiBpbW1lZGlhdGVseSB0aGUgdXNlciBjYWxscyB0d2Vlbi5zZWVrKHR3ZWVuLmR1cmF0aW9uKCkpLCBza2lwcGluZyB0byB0aGUgZW5kIC0gdGhlIGVuZCByZW5kZXIgd291bGQgYmUgZm9yY2VkLCBhbmQgdGhlbiBpZiB3ZSBkaWRuJ3QgZmx1c2ggdGhlIGxhenkgcmVuZGVyLCBpdCdkIGZpcmUgQUZURVIgdGhlIHNlZWsoKSwgcmVuZGVyaW5nIGl0IGF0IHRoZSB3cm9uZyB0aW1lLlxuXHRcdFx0XHR0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdGltZSAhPT0gcHJldlRpbWUgJiYgdGltZSA+PSAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7ICAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBhIHR3ZWVuIChhcyBvcHBvc2VkIHRvIHRoZSB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCB0aGUgdGltZWxpbmUgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdHdlZW4gYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUuXG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlRpbWUgPT09IDApIHtcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHRpZiAodGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwiX2R1bW15R1NcIjsgLy9pZiBubyBjYWxsYmFjayBpcyBkZWZpbmVkLCB1c2UgYSBkdW1teSB2YWx1ZSBqdXN0IHNvIHRoYXQgdGhlIGNvbmRpdGlvbiBhdCB0aGUgZW5kIGV2YWx1YXRlcyBhcyB0cnVlIGJlY2F1c2UgX3N0YXJ0QXQgc2hvdWxkIHJlbmRlciBBRlRFUiB0aGUgbm9ybWFsIHJlbmRlciBsb29wIHdoZW4gdGhlIHRpbWUgaXMgbmVnYXRpdmUuIFdlIGNvdWxkIGhhbmRsZSB0aGlzIGluIGEgbW9yZSBpbnR1aXRpdmUgd2F5LCBvZiBjb3Vyc2UsIGJ1dCB0aGUgcmVuZGVyIGxvb3AgaXMgdGhlIE1PU1QgaW1wb3J0YW50IHRoaW5nIHRvIG9wdGltaXplLCBzbyB0aGlzIHRlY2huaXF1ZSBhbGxvd3MgdXMgdG8gYXZvaWQgYWRkaW5nIGV4dHJhIGNvbmRpdGlvbmFsIGxvZ2ljIGluIGEgaGlnaC1mcmVxdWVuY3kgYXJlYS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdGltZSAhPT0gMCB8fCBkdXJhdGlvbiA9PT0gMCkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25TdGFydFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXShwdC5jICogdGhpcy5yYXRpbyArIHB0LnMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC5jICogdGhpcy5yYXRpbyArIHB0LnM7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlKSB7XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkgaWYgKHRoaXMuX3N0YXJ0QXQgJiYgdGltZSAhPT0gLTAuMDAwMSkgeyAvL2lmIHRoZSB0d2VlbiBpcyBwb3NpdGlvbmVkIGF0IHRoZSBWRVJZIGJlZ2lubmluZyAoX3N0YXJ0VGltZSAwKSBvZiBpdHMgcGFyZW50IHRpbWVsaW5lLCBpdCdzIGlsbGVnYWwgZm9yIHRoZSBwbGF5aGVhZCB0byBnbyBiYWNrIGZ1cnRoZXIsIHNvIHdlIHNob3VsZCBub3QgcmVuZGVyIHRoZSByZWNvcmRlZCBzdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIGlmICh0aGlzLl90aW1lICE9PSBwcmV2VGltZSB8fCBpc0NvbXBsZXRlIHx8IGZvcmNlKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2djIHx8IGZvcmNlKSB7IC8vY2hlY2sgX2djIGJlY2F1c2UgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGtpbGwoKSBjb3VsZCBiZSBjYWxsZWQgaW4gYW4gb25VcGRhdGVcblx0XHRcdFx0aWYgKHRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQgJiYgIXRoaXMuX29uVXBkYXRlICYmIHRpbWUgIT09IC0wLjAwMDEpIHsgLy8tMC4wMDAxIGlzIGEgc3BlY2lhbCB2YWx1ZSB0aGF0IHdlIHVzZSB3aGVuIGxvb3BpbmcgYmFjayB0byB0aGUgYmVnaW5uaW5nIG9mIGEgcmVwZWF0ZWQgVGltZWxpbmVNYXgsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkbid0IHJlbmRlciB0aGUgX3N0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKGNhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHJhd1ByZXZUaW1lICE9PSBfdGlueU51bSkgeyAvL3RoZSBvbkNvbXBsZXRlIG9yIG9uUmV2ZXJzZUNvbXBsZXRlIGNvdWxkIHRyaWdnZXIgbW92ZW1lbnQgb2YgdGhlIHBsYXloZWFkIGFuZCBmb3IgemVyby1kdXJhdGlvbiB0d2VlbnMgKHdoaWNoIG11c3QgZGlzY2VybiBkaXJlY3Rpb24pIHRoYXQgbGFuZCBkaXJlY3RseSBiYWNrIG9uIHRoZWlyIHN0YXJ0IHRpbWUsIHdlIGRvbid0IHdhbnQgdG8gZmlyZSBhZ2FpbiBvbiB0aGUgbmV4dCByZW5kZXIuIFRoaW5rIG9mIHNldmVyYWwgYWRkUGF1c2UoKSdzIGluIGEgdGltZWxpbmUgdGhhdCBmb3JjZXMgdGhlIHBsYXloZWFkIHRvIGEgY2VydGFpbiBzcG90LCBidXQgd2hhdCBpZiBpdCdzIGFscmVhZHkgcGF1c2VkIGFuZCBhbm90aGVyIHR3ZWVuIGlzIHR3ZWVuaW5nIHRoZSBcInRpbWVcIiBvZiB0aGUgdGltZWxpbmU/IEVhY2ggdGltZSBpdCBtb3ZlcyBbZm9yd2FyZF0gcGFzdCB0aGF0IHNwb3QsIGl0IHdvdWxkIG1vdmUgYmFjaywgYW5kIHNpbmNlIHN1cHByZXNzRXZlbnRzIGlzIHRydWUsIGl0J2QgcmVzZXQgX3Jhd1ByZXZUaW1lIHRvIF90aW55TnVtIHNvIHRoYXQgd2hlbiBpdCBiZWdpbnMgYWdhaW4sIHRoZSBjYWxsYmFjayB3b3VsZCBmaXJlIChzbyB1bHRpbWF0ZWx5IGl0IGNvdWxkIGJvdW5jZSBiYWNrIGFuZCBmb3J0aCBkdXJpbmcgdGhhdCB0d2VlbikuIEFnYWluLCB0aGlzIGlzIGEgdmVyeSB1bmNvbW1vbiBzY2VuYXJpbywgYnV0IHBvc3NpYmxlIG5vbmV0aGVsZXNzLlxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0LCBvdmVyd3JpdGluZ1R3ZWVuKSB7XG5cdFx0XHRpZiAodmFycyA9PT0gXCJhbGxcIikge1xuXHRcdFx0XHR2YXJzID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICh2YXJzID09IG51bGwpIGlmICh0YXJnZXQgPT0gbnVsbCB8fCB0YXJnZXQgPT09IHRoaXMudGFyZ2V0KSB7XG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldCA9ICh0eXBlb2YodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIikgPyAodGFyZ2V0IHx8IHRoaXMuX3RhcmdldHMgfHwgdGhpcy50YXJnZXQpIDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXHRcdFx0dmFyIHNpbXVsdGFuZW91c092ZXJ3cml0ZSA9IChvdmVyd3JpdGluZ1R3ZWVuICYmIHRoaXMuX3RpbWUgJiYgb3ZlcndyaXRpbmdUd2Vlbi5fc3RhcnRUaW1lID09PSB0aGlzLl9zdGFydFRpbWUgJiYgdGhpcy5fdGltZWxpbmUgPT09IG92ZXJ3cml0aW5nVHdlZW4uX3RpbWVsaW5lKSxcblx0XHRcdFx0aSwgb3ZlcndyaXR0ZW5Qcm9wcywgcCwgcHQsIHByb3BMb29rdXAsIGNoYW5nZWQsIGtpbGxQcm9wcywgcmVjb3JkLCBraWxsZWQ7XG5cdFx0XHRpZiAoKF9pc0FycmF5KHRhcmdldCkgfHwgX2lzU2VsZWN0b3IodGFyZ2V0KSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0aSA9IHRhcmdldC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9raWxsKHZhcnMsIHRhcmdldFtpXSwgb3ZlcndyaXRpbmdUd2VlbikpIHtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX3RhcmdldHMpIHtcblx0XHRcdFx0XHRpID0gdGhpcy5fdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0ID09PSB0aGlzLl90YXJnZXRzW2ldKSB7XG5cdFx0XHRcdFx0XHRcdHByb3BMb29rdXAgPSB0aGlzLl9wcm9wTG9va3VwW2ldIHx8IHt9O1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyB8fCBbXTtcblx0XHRcdFx0XHRcdFx0b3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHNbaV0gPSB2YXJzID8gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc1tpXSB8fCB7fSA6IFwiYWxsXCI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXQgIT09IHRoaXMudGFyZ2V0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByb3BMb29rdXAgPSB0aGlzLl9wcm9wTG9va3VwO1xuXHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdmFycyA/IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgfHwge30gOiBcImFsbFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByb3BMb29rdXApIHtcblx0XHRcdFx0XHRraWxsUHJvcHMgPSB2YXJzIHx8IHByb3BMb29rdXA7XG5cdFx0XHRcdFx0cmVjb3JkID0gKHZhcnMgIT09IG92ZXJ3cml0dGVuUHJvcHMgJiYgb3ZlcndyaXR0ZW5Qcm9wcyAhPT0gXCJhbGxcIiAmJiB2YXJzICE9PSBwcm9wTG9va3VwICYmICh0eXBlb2YodmFycykgIT09IFwib2JqZWN0XCIgfHwgIXZhcnMuX3RlbXBLaWxsKSk7IC8vX3RlbXBLaWxsIGlzIGEgc3VwZXItc2VjcmV0IHdheSB0byBkZWxldGUgYSBwYXJ0aWN1bGFyIHR3ZWVuaW5nIHByb3BlcnR5IGJ1dCBOT1QgaGF2ZSBpdCByZW1lbWJlcmVkIGFzIGFuIG9mZmljaWFsIG92ZXJ3cml0dGVuIHByb3BlcnR5IChsaWtlIGluIEJlemllclBsdWdpbilcblx0XHRcdFx0XHRpZiAob3ZlcndyaXRpbmdUd2VlbiAmJiAoVHdlZW5MaXRlLm9uT3ZlcndyaXRlIHx8IHRoaXMudmFycy5vbk92ZXJ3cml0ZSkpIHtcblx0XHRcdFx0XHRcdGZvciAocCBpbiBraWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHByb3BMb29rdXBbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIWtpbGxlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0a2lsbGVkID0gW107XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGtpbGxlZC5wdXNoKHApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoKGtpbGxlZCB8fCAhdmFycykgJiYgIV9vbk92ZXJ3cml0ZSh0aGlzLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZCkpIHsgLy9pZiB0aGUgb25PdmVyd3JpdGUgcmV0dXJuZWQgZmFsc2UsIHRoYXQgbWVhbnMgdGhlIHVzZXIgd2FudHMgdG8gb3ZlcnJpZGUgdGhlIG92ZXJ3cml0aW5nIChjYW5jZWwgaXQpLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChwIGluIGtpbGxQcm9wcykge1xuXHRcdFx0XHRcdFx0aWYgKChwdCA9IHByb3BMb29rdXBbcF0pKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzaW11bHRhbmVvdXNPdmVyd3JpdGUpIHsgLy9pZiBhbm90aGVyIHR3ZWVuIG92ZXJ3cml0ZXMgdGhpcyBvbmUgYW5kIHRoZXkgYm90aCBzdGFydCBhdCBleGFjdGx5IHRoZSBzYW1lIHRpbWUsIHlldCB0aGlzIHR3ZWVuIGhhcyBhbHJlYWR5IHJlbmRlcmVkIG9uY2UgKGZvciBleGFtcGxlLCBhdCAwLjAwMSkgYmVjYXVzZSBpdCdzIGZpcnN0IGluIHRoZSBxdWV1ZSwgd2Ugc2hvdWxkIHJldmVydCB0aGUgdmFsdWVzIHRvIHdoZXJlIHRoZXkgd2VyZSBhdCAwIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmVuJ3QgY29udGFtaW5hdGVkIG9uIHRoZSBvdmVyd3JpdGluZyB0d2Vlbi5cblx0XHRcdFx0XHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXShwdC5zKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnM7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChwdC5wZyAmJiBwdC50Ll9raWxsKGtpbGxQcm9wcykpIHtcblx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTsgLy9zb21lIHBsdWdpbnMgbmVlZCB0byBiZSBub3RpZmllZCBzbyB0aGV5IGNhbiBwZXJmb3JtIGNsZWFudXAgdGFza3MgZmlyc3Rcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIXB0LnBnIHx8IHB0LnQuX292ZXJ3cml0ZVByb3BzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0ID09PSB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cHQuX25leHQgPSBwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHByb3BMb29rdXBbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocmVjb3JkKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHNbcF0gPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXRoaXMuX2ZpcnN0UFQgJiYgdGhpcy5faW5pdHRlZCkgeyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGFyZSBraWxsZWQsIGtpbGwgdGhlIHR3ZWVuLiBXaXRob3V0IHRoaXMgbGluZSwgaWYgdGhlcmUncyBhIHR3ZWVuIHdpdGggbXVsdGlwbGUgdGFyZ2V0cyBhbmQgdGhlbiB5b3Uga2lsbFR3ZWVuc09mKCkgZWFjaCB0YXJnZXQgaW5kaXZpZHVhbGx5LCB0aGUgdHdlZW4gd291bGQgdGVjaG5pY2FsbHkgc3RpbGwgcmVtYWluIGFjdGl2ZSBhbmQgZmlyZSBpdHMgb25Db21wbGV0ZSBldmVuIHRob3VnaCB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgcHJvcGVydGllcyB0d2VlbmluZy5cblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudChcIl9vbkRpc2FibGVcIiwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9maXJzdFBUID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX3N0YXJ0QXQgPSB0aGlzLl9vblVwZGF0ZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gdGhpcy5fYWN0aXZlID0gdGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcHJvcExvb2t1cCA9ICh0aGlzLl90YXJnZXRzKSA/IHt9IDogW107XG5cdFx0XHRBbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcblx0XHRcdGlmICh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyKSB7XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSAtX3RpbnlOdW07IC8vZm9yY2VzIGEgcmVuZGVyIHdpdGhvdXQgaGF2aW5nIHRvIHNldCB0aGUgcmVuZGVyKCkgXCJmb3JjZVwiIHBhcmFtZXRlciB0byB0cnVlIGJlY2F1c2Ugd2Ugd2FudCB0byBhbGxvdyBsYXp5aW5nIGJ5IGRlZmF1bHQgKHVzaW5nIHRoZSBcImZvcmNlXCIgcGFyYW1ldGVyIGFsd2F5cyBmb3JjZXMgYW4gaW1tZWRpYXRlIGZ1bGwgcmVuZGVyKVxuXHRcdFx0XHR0aGlzLnJlbmRlcihNYXRoLm1pbigwLCAtdGhpcy5fZGVsYXkpKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlLlxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbihlbmFibGVkLCBpZ25vcmVUaW1lbGluZSkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVuYWJsZWQgJiYgdGhpcy5fZ2MpIHtcblx0XHRcdFx0dmFyIHRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGlmICh0YXJnZXRzKSB7XG5cdFx0XHRcdFx0aSA9IHRhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc2libGluZ3NbaV0gPSBfcmVnaXN0ZXIodGFyZ2V0c1tpXSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzID0gX3JlZ2lzdGVyKHRoaXMudGFyZ2V0LCB0aGlzLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0QW5pbWF0aW9uLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsIGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKTtcblx0XHRcdGlmICh0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkKSBpZiAodGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRyZXR1cm4gVHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KChlbmFibGVkID8gXCJfb25FbmFibGVcIiA6IFwiX29uRGlzYWJsZVwiKSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXG4vLy0tLS1Ud2VlbkxpdGUgc3RhdGljIG1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdFR3ZWVuTGl0ZS50byA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZnJvbSA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycykge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdG9WYXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24oZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlLCB1c2VGcmFtZXMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKGNhbGxiYWNrLCAwLCB7ZGVsYXk6ZGVsYXksIG9uQ29tcGxldGU6Y2FsbGJhY2ssIG9uQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBjYWxsYmFja1Njb3BlOnNjb3BlLCBvblJldmVyc2VDb21wbGV0ZTpjYWxsYmFjaywgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBpbW1lZGlhdGVSZW5kZXI6ZmFsc2UsIGxhenk6ZmFsc2UsIHVzZUZyYW1lczp1c2VGcmFtZXMsIG92ZXJ3cml0ZTowfSk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgMCwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZiA9IGZ1bmN0aW9uKHRhcmdldCwgb25seUFjdGl2ZSkge1xuXHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7IHJldHVybiBbXTsgfVxuXHRcdFx0dGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/IHRhcmdldCA6IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXQpIHx8IHRhcmdldDtcblx0XHRcdHZhciBpLCBhLCBqLCB0O1xuXHRcdFx0aWYgKChfaXNBcnJheSh0YXJnZXQpIHx8IF9pc1NlbGVjdG9yKHRhcmdldCkpICYmIHR5cGVvZih0YXJnZXRbMF0pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdGkgPSB0YXJnZXQubGVuZ3RoO1xuXHRcdFx0XHRhID0gW107XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGEgPSBhLmNvbmNhdChUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0W2ldLCBvbmx5QWN0aXZlKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHQvL25vdyBnZXQgcmlkIG9mIGFueSBkdXBsaWNhdGVzICh0d2VlbnMgb2YgYXJyYXlzIG9mIG9iamVjdHMgY291bGQgY2F1c2UgZHVwbGljYXRlcylcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0dCA9IGFbaV07XG5cdFx0XHRcdFx0aiA9IGk7XG5cdFx0XHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodCA9PT0gYVtqXSkge1xuXHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGEgPSBfcmVnaXN0ZXIodGFyZ2V0KS5jb25jYXQoKTtcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoYVtpXS5fZ2MgfHwgKG9ubHlBY3RpdmUgJiYgIWFbaV0uaXNBY3RpdmUoKSkpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5raWxsVHdlZW5zT2YgPSBUd2VlbkxpdGUua2lsbERlbGF5ZWRDYWxsc1RvID0gZnVuY3Rpb24odGFyZ2V0LCBvbmx5QWN0aXZlLCB2YXJzKSB7XG5cdFx0XHRpZiAodHlwZW9mKG9ubHlBY3RpdmUpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdHZhcnMgPSBvbmx5QWN0aXZlOyAvL2ZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoYmVmb3JlIFwib25seUFjdGl2ZVwiIHBhcmFtZXRlciB3YXMgaW5zZXJ0ZWQpXG5cdFx0XHRcdG9ubHlBY3RpdmUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBhID0gVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldCwgb25seUFjdGl2ZSksXG5cdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRhW2ldLl9raWxsKHZhcnMsIHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUd2VlblBsdWdpbiAgIChjb3VsZCBlYXNpbHkgYmUgc3BsaXQgb3V0IGFzIGEgc2VwYXJhdGUgZmlsZS9jbGFzcywgYnV0IGluY2x1ZGVkIGZvciBlYXNlIG9mIHVzZSAoc28gdGhhdCBwZW9wbGUgZG9uJ3QgbmVlZCB0byBpbmNsdWRlIGFub3RoZXIgc2NyaXB0IGNhbGwgYmVmb3JlIGxvYWRpbmcgcGx1Z2lucyB3aGljaCBpcyBlYXN5IHRvIGZvcmdldClcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBUd2VlblBsdWdpbiA9IF9jbGFzcyhcInBsdWdpbnMuVHdlZW5QbHVnaW5cIiwgZnVuY3Rpb24ocHJvcHMsIHByaW9yaXR5KSB7XG5cdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMgPSAocHJvcHMgfHwgXCJcIikuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BOYW1lID0gdGhpcy5fb3ZlcndyaXRlUHJvcHNbMF07XG5cdFx0XHRcdFx0dGhpcy5fcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuXHRcdFx0XHRcdHRoaXMuX3N1cGVyID0gVHdlZW5QbHVnaW4ucHJvdG90eXBlO1xuXHRcdFx0XHR9LCB0cnVlKTtcblxuXHRcdHAgPSBUd2VlblBsdWdpbi5wcm90b3R5cGU7XG5cdFx0VHdlZW5QbHVnaW4udmVyc2lvbiA9IFwiMS4xOC4wXCI7XG5cdFx0VHdlZW5QbHVnaW4uQVBJID0gMjtcblx0XHRwLl9maXJzdFBUID0gbnVsbDtcblx0XHRwLl9hZGRUd2VlbiA9IF9hZGRQcm9wVHdlZW47XG5cdFx0cC5zZXRSYXRpbyA9IF9zZXRSYXRpbztcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbihsb29rdXApIHtcblx0XHRcdHZhciBhID0gdGhpcy5fb3ZlcndyaXRlUHJvcHMsXG5cdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVCxcblx0XHRcdFx0aTtcblx0XHRcdGlmIChsb29rdXBbdGhpcy5fcHJvcE5hbWVdICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGxvb2t1cFthW2ldXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAobG9va3VwW3B0Lm5dICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQuX3ByZXY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdHB0Ll9wcmV2ID0gbnVsbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2ZpcnN0UFQgPT09IHB0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuX3JvdW5kUHJvcHMgPSBmdW5jdGlvbihsb29rdXAsIHZhbHVlKSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChsb29rdXBbdGhpcy5fcHJvcE5hbWVdIHx8IChwdC5uICE9IG51bGwgJiYgbG9va3VwWyBwdC5uLnNwbGl0KHRoaXMuX3Byb3BOYW1lICsgXCJfXCIpLmpvaW4oXCJcIikgXSkpIHsgLy9zb21lIHByb3BlcnRpZXMgdGhhdCBhcmUgdmVyeSBwbHVnaW4tc3BlY2lmaWMgYWRkIGEgcHJlZml4IG5hbWVkIGFmdGVyIHRoZSBfcHJvcE5hbWUgcGx1cyBhbiB1bmRlcnNjb3JlLCBzbyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGF0IGV4dHJhIHN0dWZmIGhlcmUuXG5cdFx0XHRcdFx0cHQuciA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudCA9IGZ1bmN0aW9uKHR5cGUsIHR3ZWVuKSB7XG5cdFx0XHR2YXIgcHQgPSB0d2Vlbi5fZmlyc3RQVCxcblx0XHRcdFx0Y2hhbmdlZCwgcHQyLCBmaXJzdCwgbGFzdCwgbmV4dDtcblx0XHRcdGlmICh0eXBlID09PSBcIl9vbkluaXRBbGxQcm9wc1wiKSB7XG5cdFx0XHRcdC8vc29ydHMgdGhlIFByb3BUd2VlbiBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwcmlvcml0eSBiZWNhdXNlIHNvbWUgcGx1Z2lucyBuZWVkIHRvIHJlbmRlciBlYXJsaWVyL2xhdGVyIHRoYW4gb3RoZXJzLCBsaWtlIE1vdGlvbkJsdXJQbHVnaW4gYXBwbGllcyBpdHMgZWZmZWN0cyBhZnRlciBhbGwgeC95L2FscGhhIHR3ZWVucyBoYXZlIHJlbmRlcmVkIG9uIGVhY2ggZnJhbWUuXG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdG5leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRwdDIgPSBmaXJzdDtcblx0XHRcdFx0XHR3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG5cdFx0XHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSkge1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zmlyc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fbmV4dCA9IHB0MikpIHtcblx0XHRcdFx0XHRcdHB0Mi5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsYXN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHR3ZWVuLl9maXJzdFBUID0gZmlyc3Q7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LnBnKSBpZiAodHlwZW9mKHB0LnRbdHlwZV0pID09PSBcImZ1bmN0aW9uXCIpIGlmIChwdC50W3R5cGVdKCkpIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdFR3ZWVuUGx1Z2luLmFjdGl2YXRlID0gZnVuY3Rpb24ocGx1Z2lucykge1xuXHRcdFx0dmFyIGkgPSBwbHVnaW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAocGx1Z2luc1tpXS5BUEkgPT09IFR3ZWVuUGx1Z2luLkFQSSkge1xuXHRcdFx0XHRcdF9wbHVnaW5zWyhuZXcgcGx1Z2luc1tpXSgpKS5fcHJvcE5hbWVdID0gcGx1Z2luc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8vcHJvdmlkZXMgYSBtb3JlIGNvbmNpc2Ugd2F5IHRvIGRlZmluZSBwbHVnaW5zIHRoYXQgaGF2ZSBubyBkZXBlbmRlbmNpZXMgYmVzaWRlcyBUd2VlblBsdWdpbiBhbmQgVHdlZW5MaXRlLCB3cmFwcGluZyBjb21tb24gYm9pbGVycGxhdGUgc3R1ZmYgaW50byBvbmUgZnVuY3Rpb24gKGFkZGVkIGluIDEuOS4wKS4gWW91IGRvbid0IE5FRUQgdG8gdXNlIHRoaXMgdG8gZGVmaW5lIGEgcGx1Z2luIC0gdGhlIG9sZCB3YXkgc3RpbGwgd29ya3MgYW5kIGNhbiBiZSB1c2VmdWwgaW4gY2VydGFpbiAocmFyZSkgc2l0dWF0aW9ucy5cblx0XHRfZ3NEZWZpbmUucGx1Z2luID0gZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0XHRpZiAoIWNvbmZpZyB8fCAhY29uZmlnLnByb3BOYW1lIHx8ICFjb25maWcuaW5pdCB8fCAhY29uZmlnLkFQSSkgeyB0aHJvdyBcImlsbGVnYWwgcGx1Z2luIGRlZmluaXRpb24uXCI7IH1cblx0XHRcdHZhciBwcm9wTmFtZSA9IGNvbmZpZy5wcm9wTmFtZSxcblx0XHRcdFx0cHJpb3JpdHkgPSBjb25maWcucHJpb3JpdHkgfHwgMCxcblx0XHRcdFx0b3ZlcndyaXRlUHJvcHMgPSBjb25maWcub3ZlcndyaXRlUHJvcHMsXG5cdFx0XHRcdG1hcCA9IHtpbml0OlwiX29uSW5pdFR3ZWVuXCIsIHNldDpcInNldFJhdGlvXCIsIGtpbGw6XCJfa2lsbFwiLCByb3VuZDpcIl9yb3VuZFByb3BzXCIsIGluaXRBbGw6XCJfb25Jbml0QWxsUHJvcHNcIn0sXG5cdFx0XHRcdFBsdWdpbiA9IF9jbGFzcyhcInBsdWdpbnMuXCIgKyBwcm9wTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BOYW1lLnN1YnN0cigxKSArIFwiUGx1Z2luXCIsXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRUd2VlblBsdWdpbi5jYWxsKHRoaXMsIHByb3BOYW1lLCBwcmlvcml0eSk7XG5cdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IG92ZXJ3cml0ZVByb3BzIHx8IFtdO1xuXHRcdFx0XHRcdH0sIChjb25maWcuZ2xvYmFsID09PSB0cnVlKSksXG5cdFx0XHRcdHAgPSBQbHVnaW4ucHJvdG90eXBlID0gbmV3IFR3ZWVuUGx1Z2luKHByb3BOYW1lKSxcblx0XHRcdFx0cHJvcDtcblx0XHRcdHAuY29uc3RydWN0b3IgPSBQbHVnaW47XG5cdFx0XHRQbHVnaW4uQVBJID0gY29uZmlnLkFQSTtcblx0XHRcdGZvciAocHJvcCBpbiBtYXApIHtcblx0XHRcdFx0aWYgKHR5cGVvZihjb25maWdbcHJvcF0pID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRwW21hcFtwcm9wXV0gPSBjb25maWdbcHJvcF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFBsdWdpbi52ZXJzaW9uID0gY29uZmlnLnZlcnNpb247XG5cdFx0XHRUd2VlblBsdWdpbi5hY3RpdmF0ZShbUGx1Z2luXSk7XG5cdFx0XHRyZXR1cm4gUGx1Z2luO1xuXHRcdH07XG5cblxuXHRcdC8vbm93IHJ1biB0aHJvdWdoIGFsbCB0aGUgZGVwZW5kZW5jaWVzIGRpc2NvdmVyZWQgYW5kIGlmIGFueSBhcmUgbWlzc2luZywgbG9nIHRoYXQgdG8gdGhlIGNvbnNvbGUgYXMgYSB3YXJuaW5nLiBUaGlzIGlzIHdoeSBpdCdzIGJlc3QgdG8gaGF2ZSBUd2VlbkxpdGUgbG9hZCBsYXN0IC0gaXQgY2FuIGNoZWNrIGFsbCB0aGUgZGVwZW5kZW5jaWVzIGZvciB5b3UuXG5cdFx0YSA9IHdpbmRvdy5fZ3NRdWV1ZTtcblx0XHRpZiAoYSkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0YVtpXSgpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChwIGluIF9kZWZMb29rdXApIHtcblx0XHRcdFx0aWYgKCFfZGVmTG9va3VwW3BdLmZ1bmMpIHtcblx0XHRcdFx0XHR3aW5kb3cuY29uc29sZS5sb2coXCJHU0FQIGVuY291bnRlcmVkIG1pc3NpbmcgZGVwZW5kZW5jeTogY29tLmdyZWVuc29jay5cIiArIHApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X3RpY2tlckFjdGl2ZSA9IGZhbHNlOyAvL2Vuc3VyZXMgdGhhdCB0aGUgZmlyc3Qgb2ZmaWNpYWwgYW5pbWF0aW9uIGZvcmNlcyBhIHRpY2tlci50aWNrKCkgdG8gdXBkYXRlIHRoZSB0aW1lIHdoZW4gaXQgaXMgaW5zdGFudGlhdGVkXG5cbn0pKCh0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YoZ2xvYmFsKSAhPT0gXCJ1bmRlZmluZWRcIikgPyBnbG9iYWwgOiB0aGlzIHx8IHdpbmRvdywgXCJUd2Vlbk1heFwiKTsiLCIvKiFcbiAqIFNjcm9sbE1hZ2ljIHYyLjAuNSAoMjAxNS0wNC0yOSlcbiAqIFRoZSBqYXZhc2NyaXB0IGxpYnJhcnkgZm9yIG1hZ2ljYWwgc2Nyb2xsIGludGVyYWN0aW9ucy5cbiAqIChjKSAyMDE1IEphbiBQYWVwa2UgKEBqYW5wYWVwa2UpXG4gKiBQcm9qZWN0IFdlYnNpdGU6IGh0dHA6Ly9zY3JvbGxtYWdpYy5pb1xuICogXG4gKiBAdmVyc2lvbiAyLjAuNVxuICogQGxpY2Vuc2UgRHVhbCBsaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZSBhbmQgR1BMLlxuICogQGF1dGhvciBKYW4gUGFlcGtlIC0gZS1tYWlsQGphbnBhZXBrZS5kZVxuICpcbiAqIEBmaWxlIFNjcm9sbE1hZ2ljIG1haW4gbGlicmFyeS5cbiAqL1xuLyoqXG4gKiBAbmFtZXNwYWNlIFNjcm9sbE1hZ2ljXG4gKi9cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsXG5cdFx0cm9vdC5TY3JvbGxNYWdpYyA9IGZhY3RvcnkoKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBTY3JvbGxNYWdpYyA9IGZ1bmN0aW9uICgpIHtcblx0XHRfdXRpbC5sb2coMiwgJyhDT01QQVRJQklMSVRZIE5PVElDRSkgLT4gQXMgb2YgU2Nyb2xsTWFnaWMgMi4wLjAgeW91IG5lZWQgdG8gdXNlIFxcJ25ldyBTY3JvbGxNYWdpYy5Db250cm9sbGVyKClcXCcgdG8gY3JlYXRlIGEgbmV3IGNvbnRyb2xsZXIgaW5zdGFuY2UuIFVzZSBcXCduZXcgU2Nyb2xsTWFnaWMuU2NlbmUoKVxcJyB0byBpbnN0YW5jZSBhIHNjZW5lLicpO1xuXHR9O1xuXG5cdFNjcm9sbE1hZ2ljLnZlcnNpb24gPSBcIjIuMC41XCI7XG5cblx0Ly8gVE9ETzogdGVtcG9yYXJ5IHdvcmthcm91bmQgZm9yIGNocm9tZSdzIHNjcm9sbCBqaXR0ZXIgYnVnXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLCBmdW5jdGlvbiAoKSB7fSk7XG5cblx0Ly8gZ2xvYmFsIGNvbnN0XG5cdHZhciBQSU5fU1BBQ0VSX0FUVFJJQlVURSA9IFwiZGF0YS1zY3JvbGxtYWdpYy1waW4tc3BhY2VyXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBtYWluIGNsYXNzIHRoYXQgaXMgbmVlZGVkIG9uY2UgcGVyIHNjcm9sbCBjb250YWluZXIuXG5cdCAqXG5cdCAqIEBjbGFzc1xuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBiYXNpYyBpbml0aWFsaXphdGlvblxuXHQgKiB2YXIgY29udHJvbGxlciA9IG5ldyBTY3JvbGxNYWdpYy5Db250cm9sbGVyKCk7XG5cdCAqXG5cdCAqIC8vIHBhc3Npbmcgb3B0aW9uc1xuXHQgKiB2YXIgY29udHJvbGxlciA9IG5ldyBTY3JvbGxNYWdpYy5Db250cm9sbGVyKHtjb250YWluZXI6IFwiI215Q29udGFpbmVyXCIsIGxvZ2xldmVsOiAzfSk7XG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBBbiBvYmplY3QgY29udGFpbmluZyBvbmUgb3IgbW9yZSBvcHRpb25zIGZvciB0aGUgY29udHJvbGxlci5cblx0ICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IFtvcHRpb25zLmNvbnRhaW5lcj13aW5kb3ddIC0gQSBzZWxlY3RvciwgRE9NIG9iamVjdCB0aGF0IHJlZmVyZW5jZXMgdGhlIG1haW4gY29udGFpbmVyIGZvciBzY3JvbGxpbmcuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudmVydGljYWw9dHJ1ZV0gLSBTZXRzIHRoZSBzY3JvbGwgbW9kZSB0byB2ZXJ0aWNhbCAoYHRydWVgKSBvciBob3Jpem9udGFsIChgZmFsc2VgKSBzY3JvbGxpbmcuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5nbG9iYWxTY2VuZU9wdGlvbnM9e31dIC0gVGhlc2Ugb3B0aW9ucyB3aWxsIGJlIHBhc3NlZCB0byBldmVyeSBTY2VuZSB0aGF0IGlzIGFkZGVkIHRvIHRoZSBjb250cm9sbGVyIHVzaW5nIHRoZSBhZGRTY2VuZSBtZXRob2QuIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIFNjZW5lIG9wdGlvbnMgc2VlIHtAbGluayBTY3JvbGxNYWdpYy5TY2VuZX0uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sb2dsZXZlbD0yXSBMb2dsZXZlbCBmb3IgZGVidWdnaW5nLiBOb3RlIHRoYXQgbG9nZ2luZyBpcyBkaXNhYmxlZCBpbiB0aGUgbWluaWZpZWQgdmVyc2lvbiBvZiBTY3JvbGxNYWdpYy5cblx0ICoqIGAwYCA9PiBzaWxlbnRcblx0ICoqIGAxYCA9PiBlcnJvcnNcblx0ICoqIGAyYCA9PiBlcnJvcnMsIHdhcm5pbmdzXG5cdCAqKiBgM2AgPT4gZXJyb3JzLCB3YXJuaW5ncywgZGVidWdpbmZvXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVmcmVzaEludGVydmFsPTEwMF0gLSBTb21lIGNoYW5nZXMgZG9uJ3QgY2FsbCBldmVudHMgYnkgZGVmYXVsdCwgbGlrZSBjaGFuZ2luZyB0aGUgY29udGFpbmVyIHNpemUgb3IgbW92aW5nIGEgc2NlbmUgdHJpZ2dlciBlbGVtZW50LiAgXG5cdCBUaGlzIGludGVydmFsIHBvbGxzIHRoZXNlIHBhcmFtZXRlcnMgdG8gZmlyZSB0aGUgbmVjZXNzYXJ5IGV2ZW50cy4gIFxuXHQgSWYgeW91IGRvbid0IHVzZSBjdXN0b20gY29udGFpbmVycywgdHJpZ2dlciBlbGVtZW50cyBvciBoYXZlIHN0YXRpYyBsYXlvdXRzLCB3aGVyZSB0aGUgcG9zaXRpb25zIG9mIHRoZSB0cmlnZ2VyIGVsZW1lbnRzIGRvbid0IGNoYW5nZSwgeW91IGNhbiBzZXQgdGhpcyB0byAwIGRpc2FibGUgaW50ZXJ2YWwgY2hlY2tpbmcgYW5kIGltcHJvdmUgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqL1xuXHRTY3JvbGxNYWdpYy5Db250cm9sbGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbi8qXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogc2V0dGluZ3Ncblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKi9cblx0XHR2YXJcblx0XHROQU1FU1BBQ0UgPSAnU2Nyb2xsTWFnaWMuQ29udHJvbGxlcicsXG5cdFx0XHRTQ1JPTExfRElSRUNUSU9OX0ZPUldBUkQgPSAnRk9SV0FSRCcsXG5cdFx0XHRTQ1JPTExfRElSRUNUSU9OX1JFVkVSU0UgPSAnUkVWRVJTRScsXG5cdFx0XHRTQ1JPTExfRElSRUNUSU9OX1BBVVNFRCA9ICdQQVVTRUQnLFxuXHRcdFx0REVGQVVMVF9PUFRJT05TID0gQ09OVFJPTExFUl9PUFRJT05TLmRlZmF1bHRzO1xuXG4vKlxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIHByaXZhdGUgdmFyc1xuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqL1xuXHRcdHZhclxuXHRcdENvbnRyb2xsZXIgPSB0aGlzLFxuXHRcdFx0X29wdGlvbnMgPSBfdXRpbC5leHRlbmQoe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyksXG5cdFx0XHRfc2NlbmVPYmplY3RzID0gW10sXG5cdFx0XHRfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUgPSBmYWxzZSxcblx0XHRcdC8vIGNhbiBiZSBib29sZWFuICh0cnVlID0+IGFsbCBzY2VuZXMpIG9yIGFuIGFycmF5IG9mIHNjZW5lcyB0byBiZSB1cGRhdGVkXG5cdFx0XHRfc2Nyb2xsUG9zID0gMCxcblx0XHRcdF9zY3JvbGxEaXJlY3Rpb24gPSBTQ1JPTExfRElSRUNUSU9OX1BBVVNFRCxcblx0XHRcdF9pc0RvY3VtZW50ID0gdHJ1ZSxcblx0XHRcdF92aWV3UG9ydFNpemUgPSAwLFxuXHRcdFx0X2VuYWJsZWQgPSB0cnVlLFxuXHRcdFx0X3VwZGF0ZVRpbWVvdXQsIF9yZWZyZXNoVGltZW91dDtcblxuLypcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQgKiBwcml2YXRlIGZ1bmN0aW9uc1xuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogSW50ZXJuYWwgY29uc3RydWN0b3IgZnVuY3Rpb24gb2YgdGhlIFNjcm9sbE1hZ2ljIENvbnRyb2xsZXJcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gX29wdGlvbnMpIHtcblx0XHRcdFx0aWYgKCFERUZBVUxUX09QVElPTlMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdGxvZygyLCBcIldBUk5JTkc6IFVua25vd24gb3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIlwiKTtcblx0XHRcdFx0XHRkZWxldGUgX29wdGlvbnNba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0X29wdGlvbnMuY29udGFpbmVyID0gX3V0aWwuZ2V0LmVsZW1lbnRzKF9vcHRpb25zLmNvbnRhaW5lcilbMF07XG5cdFx0XHQvLyBjaGVjayBTY3JvbGxDb250YWluZXJcblx0XHRcdGlmICghX29wdGlvbnMuY29udGFpbmVyKSB7XG5cdFx0XHRcdGxvZygxLCBcIkVSUk9SIGNyZWF0aW5nIG9iamVjdCBcIiArIE5BTUVTUEFDRSArIFwiOiBObyB2YWxpZCBzY3JvbGwgY29udGFpbmVyIHN1cHBsaWVkXCIpO1xuXHRcdFx0XHR0aHJvdyBOQU1FU1BBQ0UgKyBcIiBpbml0IGZhaWxlZC5cIjsgLy8gY2FuY2VsXG5cdFx0XHR9XG5cdFx0XHRfaXNEb2N1bWVudCA9IF9vcHRpb25zLmNvbnRhaW5lciA9PT0gd2luZG93IHx8IF9vcHRpb25zLmNvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSB8fCAhZG9jdW1lbnQuYm9keS5jb250YWlucyhfb3B0aW9ucy5jb250YWluZXIpO1xuXHRcdFx0Ly8gbm9ybWFsaXplIHRvIHdpbmRvd1xuXHRcdFx0aWYgKF9pc0RvY3VtZW50KSB7XG5cdFx0XHRcdF9vcHRpb25zLmNvbnRhaW5lciA9IHdpbmRvdztcblx0XHRcdH1cblx0XHRcdC8vIHVwZGF0ZSBjb250YWluZXIgc2l6ZSBpbW1lZGlhdGVseVxuXHRcdFx0X3ZpZXdQb3J0U2l6ZSA9IGdldFZpZXdwb3J0U2l6ZSgpO1xuXHRcdFx0Ly8gc2V0IGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRfb3B0aW9ucy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvbkNoYW5nZSk7XG5cdFx0XHRfb3B0aW9ucy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBvbkNoYW5nZSk7XG5cblx0XHRcdF9vcHRpb25zLnJlZnJlc2hJbnRlcnZhbCA9IHBhcnNlSW50KF9vcHRpb25zLnJlZnJlc2hJbnRlcnZhbCkgfHwgREVGQVVMVF9PUFRJT05TLnJlZnJlc2hJbnRlcnZhbDtcblx0XHRcdHNjaGVkdWxlUmVmcmVzaCgpO1xuXG5cdFx0XHRsb2coMywgXCJhZGRlZCBuZXcgXCIgKyBOQU1FU1BBQ0UgKyBcIiBjb250cm9sbGVyICh2XCIgKyBTY3JvbGxNYWdpYy52ZXJzaW9uICsgXCIpXCIpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBTY2hlZHVsZSB0aGUgbmV4dCBleGVjdXRpb24gb2YgdGhlIHJlZnJlc2ggZnVuY3Rpb25cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciBzY2hlZHVsZVJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoX29wdGlvbnMucmVmcmVzaEludGVydmFsID4gMCkge1xuXHRcdFx0XHRfcmVmcmVzaFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChyZWZyZXNoLCBfb3B0aW9ucy5yZWZyZXNoSW50ZXJ2YWwpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBEZWZhdWx0IGZ1bmN0aW9uIHRvIGdldCBzY3JvbGwgcG9zIC0gb3ZlcndyaXRlYWJsZSB1c2luZyBgQ29udHJvbGxlci5zY3JvbGxQb3MobmV3RnVuY3Rpb24pYFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIGdldFNjcm9sbFBvcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBfb3B0aW9ucy52ZXJ0aWNhbCA/IF91dGlsLmdldC5zY3JvbGxUb3AoX29wdGlvbnMuY29udGFpbmVyKSA6IF91dGlsLmdldC5zY3JvbGxMZWZ0KF9vcHRpb25zLmNvbnRhaW5lcik7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmlld3BvcnQgU2l6ZSAod2lkdGggdm9yIGhvcml6b250YWwsIGhlaWdodCBmb3IgdmVydGljYWwpXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgZ2V0Vmlld3BvcnRTaXplID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIF9vcHRpb25zLnZlcnRpY2FsID8gX3V0aWwuZ2V0LmhlaWdodChfb3B0aW9ucy5jb250YWluZXIpIDogX3V0aWwuZ2V0LndpZHRoKF9vcHRpb25zLmNvbnRhaW5lcik7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmF1bHQgZnVuY3Rpb24gdG8gc2V0IHNjcm9sbCBwb3MgLSBvdmVyd3JpdGVhYmxlIHVzaW5nIGBDb250cm9sbGVyLnNjcm9sbFRvKG5ld0Z1bmN0aW9uKWBcblx0XHQgKiBNYWtlIGF2YWlsYWJsZSBwdWJsaWNseSBmb3IgcGlubmVkIG1vdXNld2hlZWwgd29ya2Fyb3VuZC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciBzZXRTY3JvbGxQb3MgPSB0aGlzLl9zZXRTY3JvbGxQb3MgPSBmdW5jdGlvbiAocG9zKSB7XG5cdFx0XHRpZiAoX29wdGlvbnMudmVydGljYWwpIHtcblx0XHRcdFx0aWYgKF9pc0RvY3VtZW50KSB7XG5cdFx0XHRcdFx0d2luZG93LnNjcm9sbFRvKF91dGlsLmdldC5zY3JvbGxMZWZ0KCksIHBvcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X29wdGlvbnMuY29udGFpbmVyLnNjcm9sbFRvcCA9IHBvcztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKF9pc0RvY3VtZW50KSB7XG5cdFx0XHRcdFx0d2luZG93LnNjcm9sbFRvKHBvcywgX3V0aWwuZ2V0LnNjcm9sbFRvcCgpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfb3B0aW9ucy5jb250YWluZXIuc2Nyb2xsTGVmdCA9IHBvcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGUgdXBkYXRlcyBpbiBjeWNsZXMgaW5zdGVhZCBvZiBvbiBzY3JvbGwgKHBlcmZvcm1hbmNlKVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHVwZGF0ZVNjZW5lcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChfZW5hYmxlZCAmJiBfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUpIHtcblx0XHRcdFx0Ly8gZGV0ZXJtaW5lIHNjZW5lcyB0byB1cGRhdGVcblx0XHRcdFx0dmFyIHNjZW5lc1RvVXBkYXRlID0gX3V0aWwudHlwZS5BcnJheShfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUpID8gX3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlIDogX3NjZW5lT2JqZWN0cy5zbGljZSgwKTtcblx0XHRcdFx0Ly8gcmVzZXQgc2NlbmVzXG5cdFx0XHRcdF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSA9IGZhbHNlO1xuXHRcdFx0XHR2YXIgb2xkU2Nyb2xsUG9zID0gX3Njcm9sbFBvcztcblx0XHRcdFx0Ly8gdXBkYXRlIHNjcm9sbCBwb3Mgbm93IGluc3RlYWQgb2Ygb25DaGFuZ2UsIGFzIGl0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzaW5jZSBzY2hlZHVsaW5nIChpLmUuIGluLWJyb3dzZXIgc21vb3RoIHNjcm9sbClcblx0XHRcdFx0X3Njcm9sbFBvcyA9IENvbnRyb2xsZXIuc2Nyb2xsUG9zKCk7XG5cdFx0XHRcdHZhciBkZWx0YVNjcm9sbCA9IF9zY3JvbGxQb3MgLSBvbGRTY3JvbGxQb3M7XG5cdFx0XHRcdGlmIChkZWx0YVNjcm9sbCAhPT0gMCkgeyAvLyBzY3JvbGwgcG9zaXRpb24gY2hhbmdlZD9cblx0XHRcdFx0XHRfc2Nyb2xsRGlyZWN0aW9uID0gKGRlbHRhU2Nyb2xsID4gMCkgPyBTQ1JPTExfRElSRUNUSU9OX0ZPUldBUkQgOiBTQ1JPTExfRElSRUNUSU9OX1JFVkVSU0U7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gcmV2ZXJzZSBvcmRlciBvZiBzY2VuZXMgaWYgc2Nyb2xsaW5nIHJldmVyc2Vcblx0XHRcdFx0aWYgKF9zY3JvbGxEaXJlY3Rpb24gPT09IFNDUk9MTF9ESVJFQ1RJT05fUkVWRVJTRSkge1xuXHRcdFx0XHRcdHNjZW5lc1RvVXBkYXRlLnJldmVyc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB1cGRhdGUgc2NlbmVzXG5cdFx0XHRcdHNjZW5lc1RvVXBkYXRlLmZvckVhY2goZnVuY3Rpb24gKHNjZW5lLCBpbmRleCkge1xuXHRcdFx0XHRcdGxvZygzLCBcInVwZGF0aW5nIFNjZW5lIFwiICsgKGluZGV4ICsgMSkgKyBcIi9cIiArIHNjZW5lc1RvVXBkYXRlLmxlbmd0aCArIFwiIChcIiArIF9zY2VuZU9iamVjdHMubGVuZ3RoICsgXCIgdG90YWwpXCIpO1xuXHRcdFx0XHRcdHNjZW5lLnVwZGF0ZSh0cnVlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChzY2VuZXNUb1VwZGF0ZS5sZW5ndGggPT09IDAgJiYgX29wdGlvbnMubG9nbGV2ZWwgPj0gMykge1xuXHRcdFx0XHRcdGxvZygzLCBcInVwZGF0aW5nIDAgU2NlbmVzIChub3RoaW5nIGFkZGVkIHRvIGNvbnRyb2xsZXIpXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemVzIHJBRiBjYWxsYmFja1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIGRlYm91bmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0X3VwZGF0ZVRpbWVvdXQgPSBfdXRpbC5yQUYodXBkYXRlU2NlbmVzKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlcyBDb250YWluZXIgY2hhbmdlc1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIG9uQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdGxvZygzLCBcImV2ZW50IGZpcmVkIGNhdXNpbmcgYW4gdXBkYXRlOlwiLCBlLnR5cGUpO1xuXHRcdFx0aWYgKGUudHlwZSA9PSBcInJlc2l6ZVwiKSB7XG5cdFx0XHRcdC8vIHJlc2l6ZVxuXHRcdFx0XHRfdmlld1BvcnRTaXplID0gZ2V0Vmlld3BvcnRTaXplKCk7XG5cdFx0XHRcdF9zY3JvbGxEaXJlY3Rpb24gPSBTQ1JPTExfRElSRUNUSU9OX1BBVVNFRDtcblx0XHRcdH1cblx0XHRcdC8vIHNjaGVkdWxlIHVwZGF0ZVxuXHRcdFx0aWYgKF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUgPSB0cnVlO1xuXHRcdFx0XHRkZWJvdW5jZVVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgcmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghX2lzRG9jdW1lbnQpIHtcblx0XHRcdFx0Ly8gc2ltdWxhdGUgcmVzaXplIGV2ZW50LiBPbmx5IHdvcmtzIGZvciB2aWV3cG9ydCByZWxldmFudCBwYXJhbSAocGVyZm9ybWFuY2UpXG5cdFx0XHRcdGlmIChfdmlld1BvcnRTaXplICE9IGdldFZpZXdwb3J0U2l6ZSgpKSB7XG5cdFx0XHRcdFx0dmFyIHJlc2l6ZUV2ZW50O1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXNpemVFdmVudCA9IG5ldyBFdmVudCgncmVzaXplJywge1xuXHRcdFx0XHRcdFx0XHRidWJibGVzOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0Y2FuY2VsYWJsZTogZmFsc2Vcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHsgLy8gc3R1cGlkIElFXG5cdFx0XHRcdFx0XHRyZXNpemVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG5cdFx0XHRcdFx0XHRyZXNpemVFdmVudC5pbml0RXZlbnQoXCJyZXNpemVcIiwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X29wdGlvbnMuY29udGFpbmVyLmRpc3BhdGNoRXZlbnQocmVzaXplRXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRfc2NlbmVPYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKHNjZW5lLCBpbmRleCkgeyAvLyByZWZyZXNoIGFsbCBzY2VuZXNcblx0XHRcdFx0c2NlbmUucmVmcmVzaCgpO1xuXHRcdFx0fSk7XG5cdFx0XHRzY2hlZHVsZVJlZnJlc2goKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogU2VuZCBhIGRlYnVnIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGUuXG5cdFx0ICogcHJvdmlkZWQgcHVibGljbHkgd2l0aCBfbG9nIGZvciBwbHVnaW5zXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBsb2dsZXZlbCAtIFRoZSBsb2dsZXZlbCByZXF1aXJlZCB0byBpbml0aWF0ZSBvdXRwdXQgZm9yIHRoZSBtZXNzYWdlLlxuXHRcdCAqIEBwYXJhbSB7Li4ubWl4ZWR9IG91dHB1dCAtIE9uZSBvciBtb3JlIHZhcmlhYmxlcyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGNvbnNvbGUuXG5cdFx0ICovXG5cdFx0dmFyIGxvZyA9IHRoaXMuX2xvZyA9IGZ1bmN0aW9uIChsb2dsZXZlbCwgb3V0cHV0KSB7XG5cdFx0XHRpZiAoX29wdGlvbnMubG9nbGV2ZWwgPj0gbG9nbGV2ZWwpIHtcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgMCwgXCIoXCIgKyBOQU1FU1BBQ0UgKyBcIikgLT5cIik7XG5cdFx0XHRcdF91dGlsLmxvZy5hcHBseSh3aW5kb3csIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvLyBmb3Igc2NlbmVzIHdlIGhhdmUgZ2V0dGVycyBmb3IgZWFjaCBvcHRpb24sIGJ1dCBmb3IgdGhlIGNvbnRyb2xsZXIgd2UgZG9uJ3QsIHNvIHdlIG5lZWQgdG8gbWFrZSBpdCBhdmFpbGFibGUgZXh0ZXJuYWxseSBmb3IgcGx1Z2luc1xuXHRcdHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcblxuXHRcdC8qKlxuXHRcdCAqIFNvcnQgc2NlbmVzIGluIGFzY2VuZGluZyBvcmRlciBvZiB0aGVpciBzdGFydCBvZmZzZXQuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IFNjZW5lc0FycmF5IC0gYW4gYXJyYXkgb2YgU2Nyb2xsTWFnaWMgU2NlbmVzIHRoYXQgc2hvdWxkIGJlIHNvcnRlZFxuXHRcdCAqIEByZXR1cm4ge2FycmF5fSBUaGUgc29ydGVkIGFycmF5IG9mIFNjZW5lcy5cblx0XHQgKi9cblx0XHR2YXIgc29ydFNjZW5lcyA9IGZ1bmN0aW9uIChTY2VuZXNBcnJheSkge1xuXHRcdFx0aWYgKFNjZW5lc0FycmF5Lmxlbmd0aCA8PSAxKSB7XG5cdFx0XHRcdHJldHVybiBTY2VuZXNBcnJheTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzY2VuZXMgPSBTY2VuZXNBcnJheS5zbGljZSgwKTtcblx0XHRcdFx0c2NlbmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gYS5zY3JvbGxPZmZzZXQoKSA+IGIuc2Nyb2xsT2Zmc2V0KCkgPyAxIDogLTE7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gc2NlbmVzO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICogcHVibGljIGZ1bmN0aW9uc1xuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBvbmUgb3JlIG1vcmUgc2NlbmUocykgdG8gdGhlIGNvbnRyb2xsZXIuICBcblx0XHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IHRvIGBTY2VuZS5hZGRUbyhjb250cm9sbGVyKWAuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gd2l0aCBhIHByZXZpb3VzbHkgZGVmaW5lZCBzY2VuZVxuXHRcdCAqIGNvbnRyb2xsZXIuYWRkU2NlbmUoc2NlbmUpO1xuXHRcdCAqXG5cdFx0ICogLy8gd2l0aCBhIG5ld2x5IGNyZWF0ZWQgc2NlbmUuXG5cdFx0ICogY29udHJvbGxlci5hZGRTY2VuZShuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe2R1cmF0aW9uIDogMH0pKTtcblx0XHQgKlxuXHRcdCAqIC8vIGFkZGluZyBtdWx0aXBsZSBzY2VuZXNcblx0XHQgKiBjb250cm9sbGVyLmFkZFNjZW5lKFtzY2VuZSwgc2NlbmUyLCBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe2R1cmF0aW9uIDogMH0pXSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyhTY3JvbGxNYWdpYy5TY2VuZXxhcnJheSl9IG5ld1NjZW5lIC0gU2Nyb2xsTWFnaWMgU2NlbmUgb3IgQXJyYXkgb2YgU2NlbmVzIHRvIGJlIGFkZGVkIHRvIHRoZSBjb250cm9sbGVyLlxuXHRcdCAqIEByZXR1cm4ge0NvbnRyb2xsZXJ9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMuYWRkU2NlbmUgPSBmdW5jdGlvbiAobmV3U2NlbmUpIHtcblx0XHRcdGlmIChfdXRpbC50eXBlLkFycmF5KG5ld1NjZW5lKSkge1xuXHRcdFx0XHRuZXdTY2VuZS5mb3JFYWNoKGZ1bmN0aW9uIChzY2VuZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRDb250cm9sbGVyLmFkZFNjZW5lKHNjZW5lKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgaWYgKG5ld1NjZW5lIGluc3RhbmNlb2YgU2Nyb2xsTWFnaWMuU2NlbmUpIHtcblx0XHRcdFx0aWYgKG5ld1NjZW5lLmNvbnRyb2xsZXIoKSAhPT0gQ29udHJvbGxlcikge1xuXHRcdFx0XHRcdG5ld1NjZW5lLmFkZFRvKENvbnRyb2xsZXIpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKF9zY2VuZU9iamVjdHMuaW5kZXhPZihuZXdTY2VuZSkgPCAwKSB7XG5cdFx0XHRcdFx0Ly8gbmV3IHNjZW5lXG5cdFx0XHRcdFx0X3NjZW5lT2JqZWN0cy5wdXNoKG5ld1NjZW5lKTsgLy8gYWRkIHRvIGFycmF5XG5cdFx0XHRcdFx0X3NjZW5lT2JqZWN0cyA9IHNvcnRTY2VuZXMoX3NjZW5lT2JqZWN0cyk7IC8vIHNvcnRcblx0XHRcdFx0XHRuZXdTY2VuZS5vbihcInNoaWZ0LmNvbnRyb2xsZXJfc29ydFwiLCBmdW5jdGlvbiAoKSB7IC8vIHJlc29ydCB3aGVuZXZlciBzY2VuZSBtb3Zlc1xuXHRcdFx0XHRcdFx0X3NjZW5lT2JqZWN0cyA9IHNvcnRTY2VuZXMoX3NjZW5lT2JqZWN0cyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly8gaW5zZXJ0IEdsb2JhbCBkZWZhdWx0cy5cblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gX29wdGlvbnMuZ2xvYmFsU2NlbmVPcHRpb25zKSB7XG5cdFx0XHRcdFx0XHRpZiAobmV3U2NlbmVba2V5XSkge1xuXHRcdFx0XHRcdFx0XHRuZXdTY2VuZVtrZXldLmNhbGwobmV3U2NlbmUsIF9vcHRpb25zLmdsb2JhbFNjZW5lT3B0aW9uc1trZXldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bG9nKDMsIFwiYWRkaW5nIFNjZW5lIChub3cgXCIgKyBfc2NlbmVPYmplY3RzLmxlbmd0aCArIFwiIHRvdGFsKVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bG9nKDEsIFwiRVJST1I6IGludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgZm9yICcuYWRkU2NlbmUoKSdcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQ29udHJvbGxlcjtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIG9uZSBvcmUgbW9yZSBzY2VuZShzKSBmcm9tIHRoZSBjb250cm9sbGVyLiAgXG5cdFx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCB0byBgU2NlbmUucmVtb3ZlKClgLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHJlbW92ZSBhIHNjZW5lIGZyb20gdGhlIGNvbnRyb2xsZXJcblx0XHQgKiBjb250cm9sbGVyLnJlbW92ZVNjZW5lKHNjZW5lKTtcblx0XHQgKlxuXHRcdCAqIC8vIHJlbW92ZSBtdWx0aXBsZSBzY2VuZXMgZnJvbSB0aGUgY29udHJvbGxlclxuXHRcdCAqIGNvbnRyb2xsZXIucmVtb3ZlU2NlbmUoW3NjZW5lLCBzY2VuZTIsIHNjZW5lM10pO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsoU2Nyb2xsTWFnaWMuU2NlbmV8YXJyYXkpfSBTY2VuZSAtIFNjcm9sbE1hZ2ljIFNjZW5lIG9yIEFycmF5IG9mIFNjZW5lcyB0byBiZSByZW1vdmVkIGZyb20gdGhlIGNvbnRyb2xsZXIuXG5cdFx0ICogQHJldHVybnMge0NvbnRyb2xsZXJ9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMucmVtb3ZlU2NlbmUgPSBmdW5jdGlvbiAoU2NlbmUpIHtcblx0XHRcdGlmIChfdXRpbC50eXBlLkFycmF5KFNjZW5lKSkge1xuXHRcdFx0XHRTY2VuZS5mb3JFYWNoKGZ1bmN0aW9uIChzY2VuZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRDb250cm9sbGVyLnJlbW92ZVNjZW5lKHNjZW5lKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgaW5kZXggPSBfc2NlbmVPYmplY3RzLmluZGV4T2YoU2NlbmUpO1xuXHRcdFx0XHRpZiAoaW5kZXggPiAtMSkge1xuXHRcdFx0XHRcdFNjZW5lLm9mZihcInNoaWZ0LmNvbnRyb2xsZXJfc29ydFwiKTtcblx0XHRcdFx0XHRfc2NlbmVPYmplY3RzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0bG9nKDMsIFwicmVtb3ZpbmcgU2NlbmUgKG5vdyBcIiArIF9zY2VuZU9iamVjdHMubGVuZ3RoICsgXCIgbGVmdClcIik7XG5cdFx0XHRcdFx0U2NlbmUucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBDb250cm9sbGVyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgb25lIG9yZSBtb3JlIHNjZW5lKHMpIGFjY29yZGluZyB0byB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIuICBcblx0XHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IHRvIGBTY2VuZS51cGRhdGUoKWAuICBcblx0XHQgKiBUaGUgdXBkYXRlIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBzY2VuZSdzIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24gKGJhc2VkIG9uIHRoZSB0cmlnZ2VyIGVsZW1lbnQsIHRyaWdnZXIgaG9vaywgZHVyYXRpb24gYW5kIG9mZnNldCkgYW5kIGNoZWNrcyBpdCBhZ2FpbnN0IHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyLiAgXG5cdFx0ICogSXQgdGhlbiB1cGRhdGVzIHRoZSBjdXJyZW50IHNjZW5lIHN0YXRlIGFjY29yZGluZ2x5IChvciBkb2VzIG5vdGhpbmcsIGlmIHRoZSBzdGF0ZSBpcyBhbHJlYWR5IGNvcnJlY3QpIOKAkyBQaW5zIHdpbGwgYmUgc2V0IHRvIHRoZWlyIGNvcnJlY3QgcG9zaXRpb24gYW5kIHR3ZWVucyB3aWxsIGJlIHVwZGF0ZWQgdG8gdGhlaXIgY29ycmVjdCBwcm9ncmVzcy4gIFxuXHRcdCAqIF8qKk5vdGU6KiogVGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQgY29uc3RhbnRseSB3aGVuZXZlciBDb250cm9sbGVyIGRldGVjdHMgYSBjaGFuZ2UuIFRoZSBvbmx5IGFwcGxpY2F0aW9uIGZvciB5b3UgaXMgaWYgeW91IGNoYW5nZSBzb21ldGhpbmcgb3V0c2lkZSBvZiB0aGUgcmVhbG0gb2YgU2Nyb2xsTWFnaWMsIGxpa2UgbW92aW5nIHRoZSB0cmlnZ2VyIG9yIGNoYW5naW5nIHR3ZWVuIHBhcmFtZXRlcnMuX1xuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHVwZGF0ZSBhIHNwZWNpZmljIHNjZW5lIG9uIG5leHQgY3ljbGVcblx0XHQgKiBjb250cm9sbGVyLnVwZGF0ZVNjZW5lKHNjZW5lKTtcblx0XHQgKlxuXHRcdCAqIC8vIHVwZGF0ZSBhIHNwZWNpZmljIHNjZW5lIGltbWVkaWF0ZWx5XG5cdFx0ICogY29udHJvbGxlci51cGRhdGVTY2VuZShzY2VuZSwgdHJ1ZSk7XG5cdFx0ICpcblx0XHQgKiAvLyB1cGRhdGUgbXVsdGlwbGUgc2NlbmVzIHNjZW5lIG9uIG5leHQgY3ljbGVcblx0XHQgKiBjb250cm9sbGVyLnVwZGF0ZVNjZW5lKFtzY2VuZTEsIHNjZW5lMiwgc2NlbmUzXSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1Njcm9sbE1hZ2ljLlNjZW5lfSBTY2VuZSAtIFNjcm9sbE1hZ2ljIFNjZW5lIG9yIEFycmF5IG9mIFNjZW5lcyB0aGF0IGlzL2FyZSBzdXBwb3NlZCB0byBiZSB1cGRhdGVkLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbWVkaWF0ZWx5PWZhbHNlXSAtIElmIGB0cnVlYCB0aGUgdXBkYXRlIHdpbGwgYmUgaW5zdGFudCwgaWYgYGZhbHNlYCBpdCB3aWxsIHdhaXQgdW50aWwgbmV4dCB1cGRhdGUgY3ljbGUuICBcblx0XHQgVGhpcyBpcyB1c2VmdWwgd2hlbiBjaGFuZ2luZyBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzY2VuZSAtIHRoaXMgd2F5IGl0IHdpbGwgb25seSBiZSB1cGRhdGVkIG9uY2UgYWxsIG5ldyBwcm9wZXJ0aWVzIGFyZSBzZXQgKHVwZGF0ZVNjZW5lcykuXG5cdFx0ICogQHJldHVybiB7Q29udHJvbGxlcn0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy51cGRhdGVTY2VuZSA9IGZ1bmN0aW9uIChTY2VuZSwgaW1tZWRpYXRlbHkpIHtcblx0XHRcdGlmIChfdXRpbC50eXBlLkFycmF5KFNjZW5lKSkge1xuXHRcdFx0XHRTY2VuZS5mb3JFYWNoKGZ1bmN0aW9uIChzY2VuZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRDb250cm9sbGVyLnVwZGF0ZVNjZW5lKHNjZW5lLCBpbW1lZGlhdGVseSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGltbWVkaWF0ZWx5KSB7XG5cdFx0XHRcdFx0U2NlbmUudXBkYXRlKHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSAhPT0gdHJ1ZSAmJiBTY2VuZSBpbnN0YW5jZW9mIFNjcm9sbE1hZ2ljLlNjZW5lKSB7IC8vIGlmIF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZSBpcyB0cnVlLCBhbGwgY29ubmVjdGVkIHNjZW5lcyBhcmUgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIHVwZGF0ZVxuXHRcdFx0XHRcdC8vIHByZXAgYXJyYXkgZm9yIG5leHQgdXBkYXRlIGN5Y2xlXG5cdFx0XHRcdFx0X3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlID0gX3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlIHx8IFtdO1xuXHRcdFx0XHRcdGlmIChfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUuaW5kZXhPZihTY2VuZSkgPT0gLTEpIHtcblx0XHRcdFx0XHRcdF91cGRhdGVTY2VuZXNPbk5leHRDeWNsZS5wdXNoKFNjZW5lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X3VwZGF0ZVNjZW5lc09uTmV4dEN5Y2xlID0gc29ydFNjZW5lcyhfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUpOyAvLyBzb3J0XG5cdFx0XHRcdFx0ZGVib3VuY2VVcGRhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIENvbnRyb2xsZXI7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIGNvbnRyb2xsZXIgcGFyYW1zIGFuZCBjYWxscyB1cGRhdGVTY2VuZSBvbiBldmVyeSBzY2VuZSwgdGhhdCBpcyBhdHRhY2hlZCB0byB0aGUgY29udHJvbGxlci4gIFxuXHRcdCAqIFNlZSBgQ29udHJvbGxlci51cGRhdGVTY2VuZSgpYCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IHRoaXMgbWVhbnMuICBcblx0XHQgKiBJbiBtb3N0IGNhc2VzIHlvdSB3aWxsIG5vdCBuZWVkIHRoaXMgZnVuY3Rpb24sIGFzIGl0IGlzIGNhbGxlZCBjb25zdGFudGx5LCB3aGVuZXZlciBTY3JvbGxNYWdpYyBkZXRlY3RzIGEgc3RhdGUgY2hhbmdlIGV2ZW50LCBsaWtlIHJlc2l6ZSBvciBzY3JvbGwuICBcblx0XHQgKiBUaGUgb25seSBhcHBsaWNhdGlvbiBmb3IgdGhpcyBtZXRob2QgaXMgd2hlbiBTY3JvbGxNYWdpYyBmYWlscyB0byBkZXRlY3QgdGhlc2UgZXZlbnRzLiAgXG5cdFx0ICogT25lIGFwcGxpY2F0aW9uIGlzIHdpdGggc29tZSBleHRlcm5hbCBzY3JvbGwgbGlicmFyaWVzIChsaWtlIGlTY3JvbGwpIHRoYXQgbW92ZSBhbiBpbnRlcm5hbCBjb250YWluZXIgdG8gYSBuZWdhdGl2ZSBvZmZzZXQgaW5zdGVhZCBvZiBhY3R1YWxseSBzY3JvbGxpbmcuIEluIHRoaXMgY2FzZSB0aGUgdXBkYXRlIG9uIHRoZSBjb250cm9sbGVyIG5lZWRzIHRvIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgY2hpbGQgY29udGFpbmVyJ3MgcG9zaXRpb24gY2hhbmdlcy5cblx0XHQgKiBGb3IgdGhpcyBjYXNlIHRoZXJlIHdpbGwgYWxzbyBiZSB0aGUgbmVlZCB0byBwcm92aWRlIGEgY3VzdG9tIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCBzY3JvbGwgcG9zaXRpb24uIFNlZSBgQ29udHJvbGxlci5zY3JvbGxQb3MoKWAgZm9yIGRldGFpbHMuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gdXBkYXRlIHRoZSBjb250cm9sbGVyIG9uIG5leHQgY3ljbGUgKHNhdmVzIHBlcmZvcm1hbmNlIGR1ZSB0byBlbGltaW5hdGlvbiBvZiByZWR1bmRhbnQgdXBkYXRlcylcblx0XHQgKiBjb250cm9sbGVyLnVwZGF0ZSgpO1xuXHRcdCAqXG5cdFx0ICogLy8gdXBkYXRlIHRoZSBjb250cm9sbGVyIGltbWVkaWF0ZWx5XG5cdFx0ICogY29udHJvbGxlci51cGRhdGUodHJ1ZSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbW1lZGlhdGVseT1mYWxzZV0gLSBJZiBgdHJ1ZWAgdGhlIHVwZGF0ZSB3aWxsIGJlIGluc3RhbnQsIGlmIGBmYWxzZWAgaXQgd2lsbCB3YWl0IHVudGlsIG5leHQgdXBkYXRlIGN5Y2xlIChiZXR0ZXIgcGVyZm9ybWFuY2UpXG5cdFx0ICogQHJldHVybiB7Q29udHJvbGxlcn0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoaW1tZWRpYXRlbHkpIHtcblx0XHRcdG9uQ2hhbmdlKHtcblx0XHRcdFx0dHlwZTogXCJyZXNpemVcIlxuXHRcdFx0fSk7IC8vIHdpbGwgdXBkYXRlIHNpemUgYW5kIHNldCBfdXBkYXRlU2NlbmVzT25OZXh0Q3ljbGUgdG8gdHJ1ZVxuXHRcdFx0aWYgKGltbWVkaWF0ZWx5KSB7XG5cdFx0XHRcdHVwZGF0ZVNjZW5lcygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIENvbnRyb2xsZXI7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFNjcm9sbCB0byBhIG51bWVyaWMgc2Nyb2xsIG9mZnNldCwgYSBET00gZWxlbWVudCwgdGhlIHN0YXJ0IG9mIGEgc2NlbmUgb3IgcHJvdmlkZSBhbiBhbHRlcm5hdGUgbWV0aG9kIGZvciBzY3JvbGxpbmcuICBcblx0XHQgKiBGb3IgdmVydGljYWwgY29udHJvbGxlcnMgaXQgd2lsbCBjaGFuZ2UgdGhlIHRvcCBzY3JvbGwgb2Zmc2V0IGFuZCBmb3IgaG9yaXpvbnRhbCBhcHBsaWNhdGlvbnMgaXQgd2lsbCBjaGFuZ2UgdGhlIGxlZnQgb2Zmc2V0LlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKlxuXHRcdCAqIEBzaW5jZSAxLjEuMFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gc2Nyb2xsIHRvIGFuIG9mZnNldCBvZiAxMDBcblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFRvKDEwMCk7XG5cdFx0ICpcblx0XHQgKiAvLyBzY3JvbGwgdG8gYSBET00gZWxlbWVudFxuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsVG8oXCIjYW5jaG9yXCIpO1xuXHRcdCAqXG5cdFx0ICogLy8gc2Nyb2xsIHRvIHRoZSBiZWdpbm5pbmcgb2YgYSBzY2VuZVxuXHRcdCAqIHZhciBzY2VuZSA9IG5ldyBTY3JvbGxNYWdpYy5TY2VuZSh7b2Zmc2V0OiAyMDB9KTtcblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFRvKHNjZW5lKTtcblx0XHQgKlxuXHRcdCAqIC8vIGRlZmluZSBhIG5ldyBzY3JvbGwgcG9zaXRpb24gbW9kaWZpY2F0aW9uIGZ1bmN0aW9uIChqUXVlcnkgYW5pbWF0ZSBpbnN0ZWFkIG9mIGp1bXApXG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxUbyhmdW5jdGlvbiAobmV3U2Nyb2xsUG9zKSB7XG5cdFx0ICpcdCQoXCJodG1sLCBib2R5XCIpLmFuaW1hdGUoe3Njcm9sbFRvcDogbmV3U2Nyb2xsUG9zfSk7XG5cdFx0ICogfSk7XG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxUbygxMDApOyAvLyBjYWxsIGFzIHVzdWFsLCBidXQgdGhlIG5ldyBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgaW5zdGVhZFxuXHRcdCAqXG5cdFx0ICogLy8gZGVmaW5lIGEgbmV3IHNjcm9sbCBmdW5jdGlvbiB3aXRoIGFuIGFkZGl0aW9uYWwgcGFyYW1ldGVyXG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxUbyhmdW5jdGlvbiAobmV3U2Nyb2xsUG9zLCBtZXNzYWdlKSB7XG5cdFx0ICogIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuXHRcdCAqXHQkKHRoaXMpLmFuaW1hdGUoe3Njcm9sbFRvcDogbmV3U2Nyb2xsUG9zfSk7XG5cdFx0ICogfSk7XG5cdFx0ICogLy8gY2FsbCBhcyB1c3VhbCwgYnV0IHN1cHBseSBhbiBleHRyYSBwYXJhbWV0ZXIgdG8gdGhlIGRlZmluZWQgY3VzdG9tIGZ1bmN0aW9uXG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxUbygxMDAsIFwibXkgbWVzc2FnZVwiKTtcblx0XHQgKlxuXHRcdCAqIC8vIGRlZmluZSBhIG5ldyBzY3JvbGwgZnVuY3Rpb24gd2l0aCBhbiBhZGRpdGlvbmFsIHBhcmFtZXRlciBjb250YWluaW5nIG11bHRpcGxlIHZhcmlhYmxlc1xuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsVG8oZnVuY3Rpb24gKG5ld1Njcm9sbFBvcywgb3B0aW9ucykge1xuXHRcdCAqICBzb21lR2xvYmFsVmFyID0gb3B0aW9ucy5hICsgb3B0aW9ucy5iO1xuXHRcdCAqXHQkKHRoaXMpLmFuaW1hdGUoe3Njcm9sbFRvcDogbmV3U2Nyb2xsUG9zfSk7XG5cdFx0ICogfSk7XG5cdFx0ICogLy8gY2FsbCBhcyB1c3VhbCwgYnV0IHN1cHBseSBhbiBleHRyYSBwYXJhbWV0ZXIgY29udGFpbmluZyBtdWx0aXBsZSBvcHRpb25zXG5cdFx0ICogY29udHJvbGxlci5zY3JvbGxUbygxMDAsIHthOiAxLCBiOiAyfSk7XG5cdFx0ICpcblx0XHQgKiAvLyBkZWZpbmUgYSBuZXcgc2Nyb2xsIGZ1bmN0aW9uIHdpdGggYSBjYWxsYmFjayBzdXBwbGllZCBhcyBhbiBhZGRpdGlvbmFsIHBhcmFtZXRlclxuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsVG8oZnVuY3Rpb24gKG5ld1Njcm9sbFBvcywgY2FsbGJhY2spIHtcblx0XHQgKlx0JCh0aGlzKS5hbmltYXRlKHtzY3JvbGxUb3A6IG5ld1Njcm9sbFBvc30sIDQwMCwgXCJzd2luZ1wiLCBjYWxsYmFjayk7XG5cdFx0ICogfSk7XG5cdFx0ICogLy8gY2FsbCBhcyB1c3VhbCwgYnV0IHN1cHBseSBhbiBleHRyYSBwYXJhbWV0ZXIsIHdoaWNoIGlzIHVzZWQgYXMgYSBjYWxsYmFjayBpbiB0aGUgcHJldmlvdXNseSBkZWZpbmVkIGN1c3RvbSBzY3JvbGwgZnVuY3Rpb25cblx0XHQgKiBjb250cm9sbGVyLnNjcm9sbFRvKDEwMCwgZnVuY3Rpb24oKSB7XG5cdFx0ICpcdGNvbnNvbGUubG9nKFwic2Nyb2xsIGhhcyBmaW5pc2hlZC5cIik7XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge21peGVkfSBzY3JvbGxUYXJnZXQgLSBUaGUgc3VwcGxpZWQgYXJndW1lbnQgY2FuIGJlIG9uZSBvZiB0aGVzZSB0eXBlczpcblx0XHQgKiAxLiBgbnVtYmVyYCAtPiBUaGUgY29udGFpbmVyIHdpbGwgc2Nyb2xsIHRvIHRoaXMgbmV3IHNjcm9sbCBvZmZzZXQuXG5cdFx0ICogMi4gYHN0cmluZ2Agb3IgYG9iamVjdGAgLT4gQ2FuIGJlIGEgc2VsZWN0b3Igb3IgYSBET00gb2JqZWN0LiAgXG5cdFx0ICogIFRoZSBjb250YWluZXIgd2lsbCBzY3JvbGwgdG8gdGhlIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudC5cblx0XHQgKiAzLiBgU2Nyb2xsTWFnaWMgU2NlbmVgIC0+IFRoZSBjb250YWluZXIgd2lsbCBzY3JvbGwgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgc2NlbmUuXG5cdFx0ICogNC4gYGZ1bmN0aW9uYCAtPiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCBmb3IgZnV0dXJlIHNjcm9sbCBwb3NpdGlvbiBtb2RpZmljYXRpb25zLiAgXG5cdFx0ICogIFRoaXMgcHJvdmlkZXMgYSB3YXkgZm9yIHlvdSB0byBjaGFuZ2UgdGhlIGJlaGF2aW91ciBvZiBzY3JvbGxpbmcgYW5kIGFkZGluZyBuZXcgYmVoYXZpb3VyIGxpa2UgYW5pbWF0aW9uLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG5ldyBzY3JvbGwgcG9zaXRpb24gYXMgYSBwYXJhbWV0ZXIgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBjb250YWluZXIgZWxlbWVudCB1c2luZyBgdGhpc2AuICBcblx0XHQgKiAgSXQgbWF5IGFsc28gb3B0aW9uYWxseSByZWNlaXZlIGFuIG9wdGlvbmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVyIChzZWUgYmVsb3cpICBcblx0XHQgKiAgXyoqTk9URToqKiAgXG5cdFx0ICogIEFsbCBvdGhlciBvcHRpb25zIHdpbGwgc3RpbGwgd29yayBhcyBleHBlY3RlZCwgdXNpbmcgdGhlIG5ldyBmdW5jdGlvbiB0byBzY3JvbGwuX1xuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IFthZGRpdGlvbmFsUGFyYW1ldGVyXSAtIElmIGEgY3VzdG9tIHNjcm9sbCBmdW5jdGlvbiB3YXMgZGVmaW5lZCAoc2VlIGFib3ZlIDQuKSwgeW91IG1heSB3YW50IHRvIHN1cHBseSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gaXQsIHdoZW4gY2FsbGluZyBpdC4gWW91IGNhbiBkbyB0aGlzIHVzaW5nIHRoaXMgcGFyYW1ldGVyIOKAkyBzZWUgZXhhbXBsZXMgZm9yIGRldGFpbHMuIFBsZWFzZSBub3RlLCB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgaGF2ZSBubyBlZmZlY3QsIGlmIHlvdSB1c2UgdGhlIGRlZmF1bHQgc2Nyb2xsaW5nIGZ1bmN0aW9uLlxuXHRcdCAqIEByZXR1cm5zIHtDb250cm9sbGVyfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLnNjcm9sbFRvID0gZnVuY3Rpb24gKHNjcm9sbFRhcmdldCwgYWRkaXRpb25hbFBhcmFtZXRlcikge1xuXHRcdFx0aWYgKF91dGlsLnR5cGUuTnVtYmVyKHNjcm9sbFRhcmdldCkpIHsgLy8gZXhjZWN1dGVcblx0XHRcdFx0c2V0U2Nyb2xsUG9zLmNhbGwoX29wdGlvbnMuY29udGFpbmVyLCBzY3JvbGxUYXJnZXQsIGFkZGl0aW9uYWxQYXJhbWV0ZXIpO1xuXHRcdFx0fSBlbHNlIGlmIChzY3JvbGxUYXJnZXQgaW5zdGFuY2VvZiBTY3JvbGxNYWdpYy5TY2VuZSkgeyAvLyBzY3JvbGwgdG8gc2NlbmVcblx0XHRcdFx0aWYgKHNjcm9sbFRhcmdldC5jb250cm9sbGVyKCkgPT09IENvbnRyb2xsZXIpIHsgLy8gY2hlY2sgaWYgdGhlIGNvbnRyb2xsZXIgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2NlbmVcblx0XHRcdFx0XHRDb250cm9sbGVyLnNjcm9sbFRvKHNjcm9sbFRhcmdldC5zY3JvbGxPZmZzZXQoKSwgYWRkaXRpb25hbFBhcmFtZXRlcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bG9nKDIsIFwic2Nyb2xsVG8oKTogVGhlIHN1cHBsaWVkIHNjZW5lIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGNvbnRyb2xsZXIuIFNjcm9sbCBjYW5jZWxsZWQuXCIsIHNjcm9sbFRhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoX3V0aWwudHlwZS5GdW5jdGlvbihzY3JvbGxUYXJnZXQpKSB7IC8vIGFzc2lnbiBuZXcgc2Nyb2xsIGZ1bmN0aW9uXG5cdFx0XHRcdHNldFNjcm9sbFBvcyA9IHNjcm9sbFRhcmdldDtcblx0XHRcdH0gZWxzZSB7IC8vIHNjcm9sbCB0byBlbGVtZW50XG5cdFx0XHRcdHZhciBlbGVtID0gX3V0aWwuZ2V0LmVsZW1lbnRzKHNjcm9sbFRhcmdldClbMF07XG5cdFx0XHRcdGlmIChlbGVtKSB7XG5cdFx0XHRcdFx0Ly8gaWYgcGFyZW50IGlzIHBpbiBzcGFjZXIsIHVzZSBzcGFjZXIgcG9zaXRpb24gaW5zdGVhZCBzbyBjb3JyZWN0IHN0YXJ0IHBvc2l0aW9uIGlzIHJldHVybmVkIGZvciBwaW5uZWQgZWxlbWVudHMuXG5cdFx0XHRcdFx0d2hpbGUgKGVsZW0ucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoUElOX1NQQUNFUl9BVFRSSUJVVEUpKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdHBhcmFtID0gX29wdGlvbnMudmVydGljYWwgPyBcInRvcFwiIDogXCJsZWZ0XCIsXG5cdFx0XHRcdFx0XHQvLyB3aGljaCBwYXJhbSBpcyBvZiBpbnRlcmVzdCA/XG5cdFx0XHRcdFx0XHRjb250YWluZXJPZmZzZXQgPSBfdXRpbC5nZXQub2Zmc2V0KF9vcHRpb25zLmNvbnRhaW5lciksXG5cdFx0XHRcdFx0XHQvLyBjb250YWluZXIgcG9zaXRpb24gaXMgbmVlZGVkIGJlY2F1c2UgZWxlbWVudCBvZmZzZXQgaXMgcmV0dXJuZWQgaW4gcmVsYXRpb24gdG8gZG9jdW1lbnQsIG5vdCBpbiByZWxhdGlvbiB0byBjb250YWluZXIuXG5cdFx0XHRcdFx0XHRlbGVtZW50T2Zmc2V0ID0gX3V0aWwuZ2V0Lm9mZnNldChlbGVtKTtcblxuXHRcdFx0XHRcdGlmICghX2lzRG9jdW1lbnQpIHsgLy8gY29udGFpbmVyIGlzIG5vdCB0aGUgZG9jdW1lbnQgcm9vdCwgc28gc3Vic3RyYWN0IHNjcm9sbCBQb3NpdGlvbiB0byBnZXQgY29ycmVjdCB0cmlnZ2VyIGVsZW1lbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gc2Nyb2xsY29udGVudFxuXHRcdFx0XHRcdFx0Y29udGFpbmVyT2Zmc2V0W3BhcmFtXSAtPSBDb250cm9sbGVyLnNjcm9sbFBvcygpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdENvbnRyb2xsZXIuc2Nyb2xsVG8oZWxlbWVudE9mZnNldFtwYXJhbV0gLSBjb250YWluZXJPZmZzZXRbcGFyYW1dLCBhZGRpdGlvbmFsUGFyYW1ldGVyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2coMiwgXCJzY3JvbGxUbygpOiBUaGUgc3VwcGxpZWQgYXJndW1lbnQgaXMgaW52YWxpZC4gU2Nyb2xsIGNhbmNlbGxlZC5cIiwgc2Nyb2xsVGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIENvbnRyb2xsZXI7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0KiogdGhlIGN1cnJlbnQgc2Nyb2xsUG9zaXRpb24gb3IgKipTZXQqKiBhIG5ldyBtZXRob2QgdG8gY2FsY3VsYXRlIGl0LiAgXG5cdFx0ICogLT4gKipHRVQqKjpcblx0XHQgKiBXaGVuIHVzZWQgYXMgYSBnZXR0ZXIgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24uICBcblx0XHQgKiBUbyBnZXQgYSBjYWNoZWQgdmFsdWUgdXNlIENvbnRyb2xsZXIuaW5mbyhcInNjcm9sbFBvc1wiKSwgd2hpY2ggd2lsbCBiZSB1cGRhdGVkIGluIHRoZSB1cGRhdGUgY3ljbGUuICBcblx0XHQgKiBGb3IgdmVydGljYWwgY29udHJvbGxlcnMgaXQgd2lsbCByZXR1cm4gdGhlIHRvcCBzY3JvbGwgb2Zmc2V0IGFuZCBmb3IgaG9yaXpvbnRhbCBhcHBsaWNhdGlvbnMgaXQgd2lsbCByZXR1cm4gdGhlIGxlZnQgb2Zmc2V0LlxuXHRcdCAqXG5cdFx0ICogLT4gKipTRVQqKjpcblx0XHQgKiBXaGVuIHVzZWQgYXMgYSBzZXR0ZXIgdGhpcyBtZXRob2QgcHJvZGVzIGEgd2F5IHRvIHBlcm1hbmVudGx5IG92ZXJ3cml0ZSB0aGUgY29udHJvbGxlcidzIHNjcm9sbCBwb3NpdGlvbiBjYWxjdWxhdGlvbi4gIFxuXHRcdCAqIEEgdHlwaWNhbCB1c2VjYXNlIGlzIHdoZW4gdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyBub3QgcmVmbGVjdGVkIGJ5IHRoZSBjb250YWluZXJzIHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0IHZhbHVlcywgYnV0IGZvciBleGFtcGxlIGJ5IHRoZSBpbm5lciBvZmZzZXQgb2YgYSBjaGlsZCBjb250YWluZXIuICBcblx0XHQgKiBNb3ZpbmcgYSBjaGlsZCBjb250YWluZXIgaW5zaWRlIGEgcGFyZW50IGlzIGEgY29tbW9ubHkgdXNlZCBtZXRob2QgZm9yIHNldmVyYWwgc2Nyb2xsaW5nIGZyYW1ld29ya3MsIGluY2x1ZGluZyBpU2Nyb2xsLiAgXG5cdFx0ICogQnkgcHJvdmlkaW5nIGFuIGFsdGVybmF0ZSBjYWxjdWxhdGlvbiBmdW5jdGlvbiB5b3UgY2FuIG1ha2Ugc3VyZSBTY3JvbGxNYWdpYyByZWNlaXZlcyB0aGUgY29ycmVjdCBzY3JvbGwgcG9zaXRpb24uICBcblx0XHQgKiBQbGVhc2UgYWxzbyBiZWFyIGluIG1pbmQgdGhhdCB5b3VyIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4geSB2YWx1ZXMgZm9yIHZlcnRpY2FsIHNjcm9sbHMgYW4geCBmb3IgaG9yaXpvbnRhbHMuXG5cdFx0ICpcblx0XHQgKiBUbyBjaGFuZ2UgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHBsZWFzZSB1c2UgYENvbnRyb2xsZXIuc2Nyb2xsVG8oKWAuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgc2Nyb2xsIFBvc2l0aW9uXG5cdFx0ICogdmFyIHNjcm9sbFBvcyA9IGNvbnRyb2xsZXIuc2Nyb2xsUG9zKCk7XG5cdFx0ICpcblx0XHQgKiAvLyBzZXQgYSBuZXcgc2Nyb2xsIHBvc2l0aW9uIGNhbGN1bGF0aW9uIG1ldGhvZFxuXHRcdCAqIGNvbnRyb2xsZXIuc2Nyb2xsUG9zKGZ1bmN0aW9uICgpIHtcblx0XHQgKlx0cmV0dXJuIHRoaXMuaW5mbyhcInZlcnRpY2FsXCIpID8gLW15Y2hpbGRjb250YWluZXIueSA6IC1teWNoaWxkY29udGFpbmVyLnhcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IFtzY3JvbGxQb3NNZXRob2RdIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIHRoZSBzY3JvbGwgcG9zaXRpb24gY2FsY3VsYXRpb24gb2YgdGhlIGNvbnRhaW5lci5cblx0XHQgKiBAcmV0dXJucyB7KG51bWJlcnxDb250cm9sbGVyKX0gQ3VycmVudCBzY3JvbGwgcG9zaXRpb24gb3IgcGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5zY3JvbGxQb3MgPSBmdW5jdGlvbiAoc2Nyb2xsUG9zTWV0aG9kKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHsgLy8gZ2V0XG5cdFx0XHRcdHJldHVybiBnZXRTY3JvbGxQb3MuY2FsbChDb250cm9sbGVyKTtcblx0XHRcdH0gZWxzZSB7IC8vIHNldFxuXHRcdFx0XHRpZiAoX3V0aWwudHlwZS5GdW5jdGlvbihzY3JvbGxQb3NNZXRob2QpKSB7XG5cdFx0XHRcdFx0Z2V0U2Nyb2xsUG9zID0gc2Nyb2xsUG9zTWV0aG9kO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxvZygyLCBcIlByb3ZpZGVkIHZhbHVlIGZvciBtZXRob2QgJ3Njcm9sbFBvcycgaXMgbm90IGEgZnVuY3Rpb24uIFRvIGNoYW5nZSB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gdXNlICdzY3JvbGxUbygpJy5cIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBDb250cm9sbGVyO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIGFsbCBpbmZvcyBvciBvbmUgaW4gcGFydGljdWxhciBhYm91dCB0aGUgY29udHJvbGxlci5cblx0XHQgKiBAcHVibGljXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyByZXR1cm5zIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiAobnVtYmVyKVxuXHRcdCAqIHZhciBzY3JvbGxQb3MgPSBjb250cm9sbGVyLmluZm8oXCJzY3JvbGxQb3NcIik7XG5cdFx0ICpcblx0XHQgKiAvLyByZXR1cm5zIGFsbCBpbmZvcyBhcyBhbiBvYmplY3Rcblx0XHQgKiB2YXIgaW5mb3MgPSBjb250cm9sbGVyLmluZm8oKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbYWJvdXRdIC0gSWYgcGFzc2VkIG9ubHkgdGhpcyBpbmZvIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBvYmplY3QgY29udGFpbmluZyBhbGwuICBcblx0XHQgVmFsaWQgb3B0aW9ucyBhcmU6XG5cdFx0ICoqIGBcInNpemVcImAgPT4gdGhlIGN1cnJlbnQgdmlld3BvcnQgc2l6ZSBvZiB0aGUgY29udGFpbmVyXG5cdFx0ICoqIGBcInZlcnRpY2FsXCJgID0+IHRydWUgaWYgdmVydGljYWwgc2Nyb2xsaW5nLCBvdGhlcndpc2UgZmFsc2Vcblx0XHQgKiogYFwic2Nyb2xsUG9zXCJgID0+IHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuXHRcdCAqKiBgXCJzY3JvbGxEaXJlY3Rpb25cImAgPT4gdGhlIGxhc3Qga25vd24gZGlyZWN0aW9uIG9mIHRoZSBzY3JvbGxcblx0XHQgKiogYFwiY29udGFpbmVyXCJgID0+IHRoZSBjb250YWluZXIgZWxlbWVudFxuXHRcdCAqKiBgXCJpc0RvY3VtZW50XCJgID0+IHRydWUgaWYgY29udGFpbmVyIGVsZW1lbnQgaXMgdGhlIGRvY3VtZW50LlxuXHRcdCAqIEByZXR1cm5zIHsobWl4ZWR8b2JqZWN0KX0gVGhlIHJlcXVlc3RlZCBpbmZvKHMpLlxuXHRcdCAqL1xuXHRcdHRoaXMuaW5mbyA9IGZ1bmN0aW9uIChhYm91dCkge1xuXHRcdFx0dmFyIHZhbHVlcyA9IHtcblx0XHRcdFx0c2l6ZTogX3ZpZXdQb3J0U2l6ZSxcblx0XHRcdFx0Ly8gY29udGFpbnMgaGVpZ2h0IG9yIHdpZHRoIChpbiByZWdhcmQgdG8gb3JpZW50YXRpb24pO1xuXHRcdFx0XHR2ZXJ0aWNhbDogX29wdGlvbnMudmVydGljYWwsXG5cdFx0XHRcdHNjcm9sbFBvczogX3Njcm9sbFBvcyxcblx0XHRcdFx0c2Nyb2xsRGlyZWN0aW9uOiBfc2Nyb2xsRGlyZWN0aW9uLFxuXHRcdFx0XHRjb250YWluZXI6IF9vcHRpb25zLmNvbnRhaW5lcixcblx0XHRcdFx0aXNEb2N1bWVudDogX2lzRG9jdW1lbnRcblx0XHRcdH07XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHsgLy8gZ2V0IGFsbCBhcyBhbiBvYmplY3Rcblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0gZWxzZSBpZiAodmFsdWVzW2Fib3V0XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZXNbYWJvdXRdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bG9nKDEsIFwiRVJST1I6IG9wdGlvbiBcXFwiXCIgKyBhYm91dCArIFwiXFxcIiBpcyBub3QgYXZhaWxhYmxlXCIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0Kiogb3IgKipTZXQqKiB0aGUgY3VycmVudCBsb2dsZXZlbCBvcHRpb24gdmFsdWUuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgdmFsdWVcblx0XHQgKiB2YXIgbG9nbGV2ZWwgPSBjb250cm9sbGVyLmxvZ2xldmVsKCk7XG5cdFx0ICpcblx0XHQgKiAvLyBzZXQgYSBuZXcgdmFsdWVcblx0XHQgKiBjb250cm9sbGVyLmxvZ2xldmVsKDMpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IFtuZXdMb2dsZXZlbF0gLSBUaGUgbmV3IGxvZ2xldmVsIHNldHRpbmcgb2YgdGhlIENvbnRyb2xsZXIuIGBbMC0zXWBcblx0XHQgKiBAcmV0dXJucyB7KG51bWJlcnxDb250cm9sbGVyKX0gQ3VycmVudCBsb2dsZXZlbCBvciBwYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLmxvZ2xldmVsID0gZnVuY3Rpb24gKG5ld0xvZ2xldmVsKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHsgLy8gZ2V0XG5cdFx0XHRcdHJldHVybiBfb3B0aW9ucy5sb2dsZXZlbDtcblx0XHRcdH0gZWxzZSBpZiAoX29wdGlvbnMubG9nbGV2ZWwgIT0gbmV3TG9nbGV2ZWwpIHsgLy8gc2V0XG5cdFx0XHRcdF9vcHRpb25zLmxvZ2xldmVsID0gbmV3TG9nbGV2ZWw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQ29udHJvbGxlcjtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiBvciAqKlNldCoqIHRoZSBjdXJyZW50IGVuYWJsZWQgc3RhdGUgb2YgdGhlIGNvbnRyb2xsZXIuICBcblx0XHQgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGRpc2FibGUgYWxsIFNjZW5lcyBjb25uZWN0ZWQgdG8gdGhlIGNvbnRyb2xsZXIgd2l0aG91dCBkZXN0cm95aW5nIG9yIHJlbW92aW5nIHRoZW0uXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgdmFsdWVcblx0XHQgKiB2YXIgZW5hYmxlZCA9IGNvbnRyb2xsZXIuZW5hYmxlZCgpO1xuXHRcdCAqXG5cdFx0ICogLy8gZGlzYWJsZSB0aGUgY29udHJvbGxlclxuXHRcdCAqIGNvbnRyb2xsZXIuZW5hYmxlZChmYWxzZSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtuZXdTdGF0ZV0gLSBUaGUgbmV3IGVuYWJsZWQgc3RhdGUgb2YgdGhlIGNvbnRyb2xsZXIgYHRydWVgIG9yIGBmYWxzZWAuXG5cdFx0ICogQHJldHVybnMgeyhib29sZWFufENvbnRyb2xsZXIpfSBDdXJyZW50IGVuYWJsZWQgc3RhdGUgb3IgcGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5lbmFibGVkID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHsgLy8gZ2V0XG5cdFx0XHRcdHJldHVybiBfZW5hYmxlZDtcblx0XHRcdH0gZWxzZSBpZiAoX2VuYWJsZWQgIT0gbmV3U3RhdGUpIHsgLy8gc2V0XG5cdFx0XHRcdF9lbmFibGVkID0gISEgbmV3U3RhdGU7XG5cdFx0XHRcdENvbnRyb2xsZXIudXBkYXRlU2NlbmUoX3NjZW5lT2JqZWN0cywgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQ29udHJvbGxlcjtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSB0aGUgQ29udHJvbGxlciwgYWxsIFNjZW5lcyBhbmQgZXZlcnl0aGluZy5cblx0XHQgKiBAcHVibGljXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHdpdGhvdXQgcmVzZXR0aW5nIHRoZSBzY2VuZXNcblx0XHQgKiBjb250cm9sbGVyID0gY29udHJvbGxlci5kZXN0cm95KCk7XG5cdFx0ICpcblx0XHQgKiAvLyB3aXRoIHNjZW5lIHJlc2V0XG5cdFx0ICogY29udHJvbGxlciA9IGNvbnRyb2xsZXIuZGVzdHJveSh0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0U2NlbmVzPWZhbHNlXSAtIElmIGB0cnVlYCB0aGUgcGlucyBhbmQgdHdlZW5zIChpZiBleGlzdGVudCkgb2YgYWxsIHNjZW5lcyB3aWxsIGJlIHJlc2V0LlxuXHRcdCAqIEByZXR1cm5zIHtudWxsfSBOdWxsIHRvIHVuc2V0IGhhbmRsZXIgdmFyaWFibGVzLlxuXHRcdCAqL1xuXHRcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uIChyZXNldFNjZW5lcykge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dChfcmVmcmVzaFRpbWVvdXQpO1xuXHRcdFx0dmFyIGkgPSBfc2NlbmVPYmplY3RzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0X3NjZW5lT2JqZWN0c1tpXS5kZXN0cm95KHJlc2V0U2NlbmVzKTtcblx0XHRcdH1cblx0XHRcdF9vcHRpb25zLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uQ2hhbmdlKTtcblx0XHRcdF9vcHRpb25zLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIG9uQ2hhbmdlKTtcblx0XHRcdF91dGlsLmNBRihfdXBkYXRlVGltZW91dCk7XG5cdFx0XHRsb2coMywgXCJkZXN0cm95ZWQgXCIgKyBOQU1FU1BBQ0UgKyBcIiAocmVzZXQ6IFwiICsgKHJlc2V0U2NlbmVzID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpICsgXCIpXCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblxuXHRcdC8vIElOSVRcblx0XHRjb25zdHJ1Y3QoKTtcblx0XHRyZXR1cm4gQ29udHJvbGxlcjtcblx0fTtcblxuXHQvLyBzdG9yZSBwYWdld2lkZSBjb250cm9sbGVyIG9wdGlvbnNcblx0dmFyIENPTlRST0xMRVJfT1BUSU9OUyA9IHtcblx0XHRkZWZhdWx0czoge1xuXHRcdFx0Y29udGFpbmVyOiB3aW5kb3csXG5cdFx0XHR2ZXJ0aWNhbDogdHJ1ZSxcblx0XHRcdGdsb2JhbFNjZW5lT3B0aW9uczoge30sXG5cdFx0XHRsb2dsZXZlbDogMixcblx0XHRcdHJlZnJlc2hJbnRlcnZhbDogMTAwXG5cdFx0fVxuXHR9O1xuLypcbiAqIG1ldGhvZCB1c2VkIHRvIGFkZCBhbiBvcHRpb24gdG8gU2Nyb2xsTWFnaWMgU2NlbmVzLlxuICovXG5cdFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIuYWRkT3B0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdENPTlRST0xMRVJfT1BUSU9OUy5kZWZhdWx0c1tuYW1lXSA9IGRlZmF1bHRWYWx1ZTtcblx0fTtcblx0Ly8gaW5zdGFuY2UgZXh0ZW5zaW9uIGZ1bmN0aW9uIGZvciBwbHVnaW5zXG5cdFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuXHRcdHZhciBvbGRDbGFzcyA9IHRoaXM7XG5cdFx0U2Nyb2xsTWFnaWMuQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdG9sZENsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLiRzdXBlciA9IF91dGlsLmV4dGVuZCh7fSwgdGhpcyk7IC8vIGNvcHkgcGFyZW50IHN0YXRlXG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0XHR9O1xuXHRcdF91dGlsLmV4dGVuZChTY3JvbGxNYWdpYy5Db250cm9sbGVyLCBvbGRDbGFzcyk7IC8vIGNvcHkgcHJvcGVydGllc1xuXHRcdFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIucHJvdG90eXBlID0gb2xkQ2xhc3MucHJvdG90eXBlOyAvLyBjb3B5IHByb3RvdHlwZVxuXHRcdFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2Nyb2xsTWFnaWMuQ29udHJvbGxlcjsgLy8gcmVzdG9yZSBjb25zdHJ1Y3RvclxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEEgU2NlbmUgZGVmaW5lcyB3aGVyZSB0aGUgY29udHJvbGxlciBzaG91bGQgcmVhY3QgYW5kIGhvdy5cblx0ICpcblx0ICogQGNsYXNzXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIGNyZWF0ZSBhIHN0YW5kYXJkIHNjZW5lIGFuZCBhZGQgaXQgdG8gYSBjb250cm9sbGVyXG5cdCAqIG5ldyBTY3JvbGxNYWdpYy5TY2VuZSgpXG5cdCAqXHRcdC5hZGRUbyhjb250cm9sbGVyKTtcblx0ICpcblx0ICogLy8gY3JlYXRlIGEgc2NlbmUgd2l0aCBjdXN0b20gb3B0aW9ucyBhbmQgYXNzaWduIGEgaGFuZGxlciB0byBpdC5cblx0ICogdmFyIHNjZW5lID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtcblx0ICogXHRcdGR1cmF0aW9uOiAxMDAsXG5cdCAqXHRcdG9mZnNldDogMjAwLFxuXHQgKlx0XHR0cmlnZ2VySG9vazogXCJvbkVudGVyXCIsXG5cdCAqXHRcdHJldmVyc2U6IGZhbHNlXG5cdCAqIH0pO1xuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgdGhlIFNjZW5lLiBUaGUgb3B0aW9ucyBjYW4gYmUgdXBkYXRlZCBhdCBhbnkgdGltZS4gIFxuXHQgSW5zdGVhZCBvZiBzZXR0aW5nIHRoZSBvcHRpb25zIGZvciBlYWNoIHNjZW5lIGluZGl2aWR1YWxseSB5b3UgY2FuIGFsc28gc2V0IHRoZW0gZ2xvYmFsbHkgaW4gdGhlIGNvbnRyb2xsZXIgYXMgdGhlIGNvbnRyb2xsZXJzIGBnbG9iYWxTY2VuZU9wdGlvbnNgIG9wdGlvbi4gVGhlIG9iamVjdCBhY2NlcHRzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgdGhlIG9uZXMgYmVsb3cuICBcblx0IFdoZW4gYSBzY2VuZSBpcyBhZGRlZCB0byB0aGUgY29udHJvbGxlciB0aGUgb3B0aW9ucyBkZWZpbmVkIHVzaW5nIHRoZSBTY2VuZSBjb25zdHJ1Y3RvciB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRob3NlIHNldCBpbiBgZ2xvYmFsU2NlbmVPcHRpb25zYC5cblx0ICogQHBhcmFtIHsobnVtYmVyfGZ1bmN0aW9uKX0gW29wdGlvbnMuZHVyYXRpb249MF0gLSBUaGUgZHVyYXRpb24gb2YgdGhlIHNjZW5lLiBcblx0IElmIGAwYCB0d2VlbnMgd2lsbCBhdXRvLXBsYXkgd2hlbiByZWFjaGluZyB0aGUgc2NlbmUgc3RhcnQgcG9pbnQsIHBpbnMgd2lsbCBiZSBwaW5uZWQgaW5kZWZpbmV0bHkgc3RhcnRpbmcgYXQgdGhlIHN0YXJ0IHBvc2l0aW9uLiAgXG5cdCBBIGZ1bmN0aW9uIHJldHVuaW5nIHRoZSBkdXJhdGlvbiB2YWx1ZSBpcyBhbHNvIHN1cHBvcnRlZC4gUGxlYXNlIHNlZSBgU2NlbmUuZHVyYXRpb24oKWAgZm9yIGRldGFpbHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5vZmZzZXQ9MF0gLSBPZmZzZXQgVmFsdWUgZm9yIHRoZSBUcmlnZ2VyIFBvc2l0aW9uLiBJZiBubyB0cmlnZ2VyRWxlbWVudCBpcyBkZWZpbmVkIHRoaXMgd2lsbCBiZSB0aGUgc2Nyb2xsIGRpc3RhbmNlIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYWdlLCBhZnRlciB3aGljaCB0aGUgc2NlbmUgd2lsbCBzdGFydC5cblx0ICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IFtvcHRpb25zLnRyaWdnZXJFbGVtZW50PW51bGxdIC0gU2VsZWN0b3Igb3IgRE9NIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIHN0YXJ0IG9mIHRoZSBzY2VuZS4gSWYgdW5kZWZpbmVkIHRoZSBzY2VuZSB3aWxsIHN0YXJ0IHJpZ2h0IGF0IHRoZSBzdGFydCBvZiB0aGUgcGFnZSAodW5sZXNzIGFuIG9mZnNldCBpcyBzZXQpLlxuXHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gW29wdGlvbnMudHJpZ2dlckhvb2s9XCJvbkNlbnRlclwiXSAtIENhbiBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgZGVmaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSB0cmlnZ2VyIEhvb2sgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXdwb3J0LiAgXG5cdCBDYW4gYWxzbyBiZSBkZWZpbmVkIHVzaW5nIGEgc3RyaW5nOlxuXHQgKiogYFwib25FbnRlclwiYCA9PiBgMWBcblx0ICoqIGBcIm9uQ2VudGVyXCJgID0+IGAwLjVgXG5cdCAqKiBgXCJvbkxlYXZlXCJgID0+IGAwYFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJldmVyc2U9dHJ1ZV0gLSBTaG91bGQgdGhlIHNjZW5lIHJldmVyc2UsIHdoZW4gc2Nyb2xsaW5nIHVwP1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9nbGV2ZWw9Ml0gLSBMb2dsZXZlbCBmb3IgZGVidWdnaW5nLiBOb3RlIHRoYXQgbG9nZ2luZyBpcyBkaXNhYmxlZCBpbiB0aGUgbWluaWZpZWQgdmVyc2lvbiBvZiBTY3JvbGxNYWdpYy5cblx0ICoqIGAwYCA9PiBzaWxlbnRcblx0ICoqIGAxYCA9PiBlcnJvcnNcblx0ICoqIGAyYCA9PiBlcnJvcnMsIHdhcm5pbmdzXG5cdCAqKiBgM2AgPT4gZXJyb3JzLCB3YXJuaW5ncywgZGVidWdpbmZvXG5cdCAqIFxuXHQgKi9cblx0U2Nyb2xsTWFnaWMuU2NlbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4vKlxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIHNldHRpbmdzXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICovXG5cblx0XHR2YXJcblx0XHROQU1FU1BBQ0UgPSAnU2Nyb2xsTWFnaWMuU2NlbmUnLFxuXHRcdFx0U0NFTkVfU1RBVEVfQkVGT1JFID0gJ0JFRk9SRScsXG5cdFx0XHRTQ0VORV9TVEFURV9EVVJJTkcgPSAnRFVSSU5HJyxcblx0XHRcdFNDRU5FX1NUQVRFX0FGVEVSID0gJ0FGVEVSJyxcblx0XHRcdERFRkFVTFRfT1BUSU9OUyA9IFNDRU5FX09QVElPTlMuZGVmYXVsdHM7XG5cbi8qXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogcHJpdmF0ZSB2YXJzXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICovXG5cblx0XHR2YXJcblx0XHRTY2VuZSA9IHRoaXMsXG5cdFx0XHRfb3B0aW9ucyA9IF91dGlsLmV4dGVuZCh7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKSxcblx0XHRcdF9zdGF0ZSA9IFNDRU5FX1NUQVRFX0JFRk9SRSxcblx0XHRcdF9wcm9ncmVzcyA9IDAsXG5cdFx0XHRfc2Nyb2xsT2Zmc2V0ID0ge1xuXHRcdFx0XHRzdGFydDogMCxcblx0XHRcdFx0ZW5kOiAwXG5cdFx0XHR9LFxuXHRcdFx0Ly8gcmVmbGVjdHMgdGhlIGNvbnRyb2xsZXJzJ3Mgc2Nyb2xsIHBvc2l0aW9uIGZvciB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc2NlbmUgcmVzcGVjdGl2ZWx5XG5cdFx0XHRfdHJpZ2dlclBvcyA9IDAsXG5cdFx0XHRfZW5hYmxlZCA9IHRydWUsXG5cdFx0XHRfZHVyYXRpb25VcGRhdGVNZXRob2QsIF9jb250cm9sbGVyO1xuXG5cdFx0LyoqXG5cdFx0ICogSW50ZXJuYWwgY29uc3RydWN0b3IgZnVuY3Rpb24gb2YgdGhlIFNjcm9sbE1hZ2ljIFNjZW5lXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIF9vcHRpb25zKSB7IC8vIGNoZWNrIHN1cHBsaWVkIG9wdGlvbnNcblx0XHRcdFx0aWYgKCFERUZBVUxUX09QVElPTlMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdGxvZygyLCBcIldBUk5JTkc6IFVua25vd24gb3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIlwiKTtcblx0XHRcdFx0XHRkZWxldGUgX29wdGlvbnNba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHBvc3NpYmxlIG9wdGlvbnNcblx0XHRcdGZvciAodmFyIG9wdGlvbk5hbWUgaW4gREVGQVVMVF9PUFRJT05TKSB7XG5cdFx0XHRcdGFkZFNjZW5lT3B0aW9uKG9wdGlvbk5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdmFsaWRhdGUgYWxsIG9wdGlvbnNcblx0XHRcdHZhbGlkYXRlT3B0aW9uKCk7XG5cdFx0fTtcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEV2ZW50IE1hbmFnZW1lbnRcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cdFx0dmFyIF9saXN0ZW5lcnMgPSB7fTtcblx0XHQvKipcblx0XHQgKiBTY2VuZSBzdGFydCBldmVudC4gIFxuXHRcdCAqIEZpcmVzIHdoZW5ldmVyIHRoZSBzY3JvbGwgcG9zaXRpb24gaXRzIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgc2NlbmUuICBcblx0XHQgKiBJdCB3aWxsIGFsc28gZmlyZSB3aGVuIHNjcm9sbGluZyBiYWNrIHVwIGdvaW5nIG92ZXIgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzY2VuZS4gSWYgeW91IHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbmx5IHdoZW4gc2Nyb2xsaW5nIGRvd24vcmlnaHQsIHVzZSB0aGUgc2Nyb2xsRGlyZWN0aW9uIHBhcmFtZXRlciBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLlxuXHRcdCAqXG5cdFx0ICogRm9yIGRldGFpbHMgb24gdGhpcyBldmVudCBhbmQgdGhlIG9yZGVyIGluIHdoaWNoIGl0IGlzIGZpcmVkLCBwbGVhc2UgcmV2aWV3IHRoZSB7QGxpbmsgU2NlbmUucHJvZ3Jlc3N9IG1ldGhvZC5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBTY3JvbGxNYWdpYy5TY2VuZSNzdGFydFxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZS5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqIFx0Y29uc29sZS5sb2coXCJIaXQgc3RhcnQgcG9pbnQgb2Ygc2NlbmUuXCIpO1xuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IE9iamVjdCBwYXNzZWQgdG8gZWFjaCBjYWxsYmFja1xuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtTY2VuZX0gZXZlbnQudGFyZ2V0IC0gVGhlIFNjZW5lIG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50LnByb2dyZXNzIC0gUmVmbGVjdHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIHNjZW5lXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnN0YXRlIC0gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNjZW5lIGBcIkJFRk9SRVwiYCBvciBgXCJEVVJJTkdcImBcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQuc2Nyb2xsRGlyZWN0aW9uIC0gSW5kaWNhdGVzIHdoaWNoIHdheSB3ZSBhcmUgc2Nyb2xsaW5nIGBcIlBBVVNFRFwiYCwgYFwiRk9SV0FSRFwiYCBvciBgXCJSRVZFUlNFXCJgXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogU2NlbmUgZW5kIGV2ZW50LiAgXG5cdFx0ICogRmlyZXMgd2hlbmV2ZXIgdGhlIHNjcm9sbCBwb3NpdGlvbiBpdHMgdGhlIGVuZGluZyBwb2ludCBvZiB0aGUgc2NlbmUuICBcblx0XHQgKiBJdCB3aWxsIGFsc28gZmlyZSB3aGVuIHNjcm9sbGluZyBiYWNrIHVwIGZyb20gYWZ0ZXIgdGhlIHNjZW5lIGFuZCBnb2luZyBvdmVyIGl0cyBlbmQgcG9zaXRpb24uIElmIHlvdSB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb25seSB3aGVuIHNjcm9sbGluZyBkb3duL3JpZ2h0LCB1c2UgdGhlIHNjcm9sbERpcmVjdGlvbiBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cblx0XHQgKlxuXHRcdCAqIEZvciBkZXRhaWxzIG9uIHRoaXMgZXZlbnQgYW5kIHRoZSBvcmRlciBpbiB3aGljaCBpdCBpcyBmaXJlZCwgcGxlYXNlIHJldmlldyB0aGUge0BsaW5rIFNjZW5lLnByb2dyZXNzfSBtZXRob2QuXG5cdFx0ICpcblx0XHQgKiBAZXZlbnQgU2Nyb2xsTWFnaWMuU2NlbmUjZW5kXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lLm9uKFwiZW5kXCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqIFx0Y29uc29sZS5sb2coXCJIaXQgZW5kIHBvaW50IG9mIHNjZW5lLlwiKTtcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBPYmplY3QgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2tcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7U2NlbmV9IGV2ZW50LnRhcmdldCAtIFRoZSBTY2VuZSBvYmplY3QgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudC5wcm9ncmVzcyAtIFJlZmxlY3RzIHRoZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoZSBzY2VuZVxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5zdGF0ZSAtIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzY2VuZSBgXCJEVVJJTkdcImAgb3IgYFwiQUZURVJcImBcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQuc2Nyb2xsRGlyZWN0aW9uIC0gSW5kaWNhdGVzIHdoaWNoIHdheSB3ZSBhcmUgc2Nyb2xsaW5nIGBcIlBBVVNFRFwiYCwgYFwiRk9SV0FSRFwiYCBvciBgXCJSRVZFUlNFXCJgXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogU2NlbmUgZW50ZXIgZXZlbnQuICBcblx0XHQgKiBGaXJlcyB3aGVuZXZlciB0aGUgc2NlbmUgZW50ZXJzIHRoZSBcIkRVUklOR1wiIHN0YXRlLiAgXG5cdFx0ICogS2VlcCBpbiBtaW5kIHRoYXQgaXQgZG9lc24ndCBtYXR0ZXIgaWYgdGhlIHNjZW5lIHBsYXlzIGZvcndhcmQgb3IgYmFja3dhcmQ6IFRoaXMgZXZlbnQgYWx3YXlzIGZpcmVzIHdoZW4gdGhlIHNjZW5lIGVudGVycyBpdHMgYWN0aXZlIHNjcm9sbCB0aW1lZnJhbWUsIHJlZ2FyZGxlc3Mgb2YgdGhlIHNjcm9sbC1kaXJlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBGb3IgZGV0YWlscyBvbiB0aGlzIGV2ZW50IGFuZCB0aGUgb3JkZXIgaW4gd2hpY2ggaXQgaXMgZmlyZWQsIHBsZWFzZSByZXZpZXcgdGhlIHtAbGluayBTY2VuZS5wcm9ncmVzc30gbWV0aG9kLlxuXHRcdCAqXG5cdFx0ICogQGV2ZW50IFNjcm9sbE1hZ2ljLlNjZW5lI2VudGVyXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lLm9uKFwiZW50ZXJcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogXHRjb25zb2xlLmxvZyhcIlNjZW5lIGVudGVyZWQuXCIpO1xuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IE9iamVjdCBwYXNzZWQgdG8gZWFjaCBjYWxsYmFja1xuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtTY2VuZX0gZXZlbnQudGFyZ2V0IC0gVGhlIFNjZW5lIG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50LnByb2dyZXNzIC0gUmVmbGVjdHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIHNjZW5lXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnN0YXRlIC0gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNjZW5lIC0gYWx3YXlzIGBcIkRVUklOR1wiYFxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5zY3JvbGxEaXJlY3Rpb24gLSBJbmRpY2F0ZXMgd2hpY2ggd2F5IHdlIGFyZSBzY3JvbGxpbmcgYFwiUEFVU0VEXCJgLCBgXCJGT1JXQVJEXCJgIG9yIGBcIlJFVkVSU0VcImBcblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBTY2VuZSBsZWF2ZSBldmVudC4gIFxuXHRcdCAqIEZpcmVzIHdoZW5ldmVyIHRoZSBzY2VuZSdzIHN0YXRlIGdvZXMgZnJvbSBcIkRVUklOR1wiIHRvIGVpdGhlciBcIkJFRk9SRVwiIG9yIFwiQUZURVJcIi4gIFxuXHRcdCAqIEtlZXAgaW4gbWluZCB0aGF0IGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHRoZSBzY2VuZSBwbGF5cyBmb3J3YXJkIG9yIGJhY2t3YXJkOiBUaGlzIGV2ZW50IGFsd2F5cyBmaXJlcyB3aGVuIHRoZSBzY2VuZSBsZWF2ZXMgaXRzIGFjdGl2ZSBzY3JvbGwgdGltZWZyYW1lLCByZWdhcmRsZXNzIG9mIHRoZSBzY3JvbGwtZGlyZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogRm9yIGRldGFpbHMgb24gdGhpcyBldmVudCBhbmQgdGhlIG9yZGVyIGluIHdoaWNoIGl0IGlzIGZpcmVkLCBwbGVhc2UgcmV2aWV3IHRoZSB7QGxpbmsgU2NlbmUucHJvZ3Jlc3N9IG1ldGhvZC5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBTY3JvbGxNYWdpYy5TY2VuZSNsZWF2ZVxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZS5vbihcImxlYXZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqIFx0Y29uc29sZS5sb2coXCJTY2VuZSBsZWZ0LlwiKTtcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBPYmplY3QgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2tcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7U2NlbmV9IGV2ZW50LnRhcmdldCAtIFRoZSBTY2VuZSBvYmplY3QgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudC5wcm9ncmVzcyAtIFJlZmxlY3RzIHRoZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoZSBzY2VuZVxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5zdGF0ZSAtIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzY2VuZSBgXCJCRUZPUkVcImAgb3IgYFwiQUZURVJcImBcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQuc2Nyb2xsRGlyZWN0aW9uIC0gSW5kaWNhdGVzIHdoaWNoIHdheSB3ZSBhcmUgc2Nyb2xsaW5nIGBcIlBBVVNFRFwiYCwgYFwiRk9SV0FSRFwiYCBvciBgXCJSRVZFUlNFXCJgXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogU2NlbmUgdXBkYXRlIGV2ZW50LiAgXG5cdFx0ICogRmlyZXMgd2hlbmV2ZXIgdGhlIHNjZW5lIGlzIHVwZGF0ZWQgKGJ1dCBub3QgbmVjZXNzYXJpbHkgY2hhbmdlcyB0aGUgcHJvZ3Jlc3MpLlxuXHRcdCAqXG5cdFx0ICogQGV2ZW50IFNjcm9sbE1hZ2ljLlNjZW5lI3VwZGF0ZVxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZS5vbihcInVwZGF0ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiBcdGNvbnNvbGUubG9nKFwiU2NlbmUgdXBkYXRlZC5cIik7XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgT2JqZWN0IHBhc3NlZCB0byBlYWNoIGNhbGxiYWNrXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge1NjZW5lfSBldmVudC50YXJnZXQgLSBUaGUgU2NlbmUgb2JqZWN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnQuc3RhcnRQb3MgLSBUaGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgdGhlIHNjZW5lIChpbiByZWxhdGlvbiB0byB0aGUgY29uYWluZXIpXG5cdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50LmVuZFBvcyAtIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIHNjZW5lIChpbiByZWxhdGlvbiB0byB0aGUgY29uYWluZXIpXG5cdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50LnNjcm9sbFBvcyAtIFRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogU2NlbmUgcHJvZ3Jlc3MgZXZlbnQuICBcblx0XHQgKiBGaXJlcyB3aGVuZXZlciB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIHNjZW5lIGNoYW5nZXMuXG5cdFx0ICpcblx0XHQgKiBGb3IgZGV0YWlscyBvbiB0aGlzIGV2ZW50IGFuZCB0aGUgb3JkZXIgaW4gd2hpY2ggaXQgaXMgZmlyZWQsIHBsZWFzZSByZXZpZXcgdGhlIHtAbGluayBTY2VuZS5wcm9ncmVzc30gbWV0aG9kLlxuXHRcdCAqXG5cdFx0ICogQGV2ZW50IFNjcm9sbE1hZ2ljLlNjZW5lI3Byb2dyZXNzXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lLm9uKFwicHJvZ3Jlc3NcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogXHRjb25zb2xlLmxvZyhcIlNjZW5lIHByb2dyZXNzIGNoYW5nZWQgdG8gXCIgKyBldmVudC5wcm9ncmVzcyk7XG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgT2JqZWN0IHBhc3NlZCB0byBlYWNoIGNhbGxiYWNrXG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge1NjZW5lfSBldmVudC50YXJnZXQgLSBUaGUgU2NlbmUgb2JqZWN0IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnRcblx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnQucHJvZ3Jlc3MgLSBSZWZsZWN0cyB0aGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgc2NlbmVcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQuc3RhdGUgLSBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2NlbmUgYFwiQkVGT1JFXCJgLCBgXCJEVVJJTkdcImAgb3IgYFwiQUZURVJcImBcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQuc2Nyb2xsRGlyZWN0aW9uIC0gSW5kaWNhdGVzIHdoaWNoIHdheSB3ZSBhcmUgc2Nyb2xsaW5nIGBcIlBBVVNFRFwiYCwgYFwiRk9SV0FSRFwiYCBvciBgXCJSRVZFUlNFXCJgXG5cdFx0ICovXG5cdFx0LyoqXG5cdFx0ICogU2NlbmUgY2hhbmdlIGV2ZW50LiAgXG5cdFx0ICogRmlyZXMgd2hlbnZldmVyIGEgcHJvcGVydHkgb2YgdGhlIHNjZW5lIGlzIGNoYW5nZWQuXG5cdFx0ICpcblx0XHQgKiBAZXZlbnQgU2Nyb2xsTWFnaWMuU2NlbmUjY2hhbmdlXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqIFx0Y29uc29sZS5sb2coXCJTY2VuZSBQcm9wZXJ0eSBcXFwiXCIgKyBldmVudC53aGF0ICsgXCJcXFwiIGNoYW5nZWQgdG8gXCIgKyBldmVudC5uZXd2YWwpO1xuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IE9iamVjdCBwYXNzZWQgdG8gZWFjaCBjYWxsYmFja1xuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtTY2VuZX0gZXZlbnQudGFyZ2V0IC0gVGhlIFNjZW5lIG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50LndoYXQgLSBJbmRpY2F0ZXMgd2hhdCB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkXG5cdFx0ICogQHByb3BlcnR5IHttaXhlZH0gZXZlbnQubmV3dmFsIC0gVGhlIG5ldyB2YWx1ZSBvZiB0aGUgY2hhbmdlZCBwcm9wZXJ0eVxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFNjZW5lIHNoaWZ0IGV2ZW50LiAgXG5cdFx0ICogRmlyZXMgd2hlbnZldmVyIHRoZSBzdGFydCBvciBlbmQgKipzY3JvbGwgb2Zmc2V0Kiogb2YgdGhlIHNjZW5lIGNoYW5nZS5cblx0XHQgKiBUaGlzIGhhcHBlbnMgZXhwbGljaXRlbHksIHdoZW4gb25lIG9mIHRoZXNlIHZhbHVlcyBjaGFuZ2U6IGBvZmZzZXRgLCBgZHVyYXRpb25gIG9yIGB0cmlnZ2VySG9va2AuXG5cdFx0ICogSXQgd2lsbCBmaXJlIGltcGxpY2l0bHkgd2hlbiB0aGUgYHRyaWdnZXJFbGVtZW50YCBjaGFuZ2VzLCBpZiB0aGUgbmV3IGVsZW1lbnQgaGFzIGEgZGlmZmVyZW50IHBvc2l0aW9uIChtb3N0IGNhc2VzKS5cblx0XHQgKiBJdCB3aWxsIGFsc28gZmlyZSBpbXBsaWNpdGx5IHdoZW4gdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lciBjaGFuZ2VzIGFuZCB0aGUgdHJpZ2dlckhvb2sgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBgb25MZWF2ZWAuXG5cdFx0ICpcblx0XHQgKiBAZXZlbnQgU2Nyb2xsTWFnaWMuU2NlbmUjc2hpZnRcblx0XHQgKiBAc2luY2UgMS4xLjBcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc2NlbmUub24oXCJzaGlmdFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiBcdGNvbnNvbGUubG9nKFwiU2NlbmUgbW92ZWQsIGJlY2F1c2UgdGhlIFwiICsgZXZlbnQucmVhc29uICsgXCIgaGFzIGNoYW5nZWQuKVwiKTtcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBPYmplY3QgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2tcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7U2NlbmV9IGV2ZW50LnRhcmdldCAtIFRoZSBTY2VuZSBvYmplY3QgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5yZWFzb24gLSBJbmRpY2F0ZXMgd2h5IHRoZSBzY2VuZSBoYXMgc2hpZnRlZFxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFNjZW5lIGRlc3Ryb3kgZXZlbnQuICBcblx0XHQgKiBGaXJlcyB3aGVudmV2ZXIgdGhlIHNjZW5lIGlzIGRlc3Ryb3llZC5cblx0XHQgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIHRpZHkgdXAgY3VzdG9tIGJlaGF2aW91ciB1c2VkIGluIGV2ZW50cy5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBTY3JvbGxNYWdpYy5TY2VuZSNkZXN0cm95XG5cdFx0ICogQHNpbmNlIDEuMS4wXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lLm9uKFwiZW50ZXJcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogICAgICAgIC8vIGFkZCBjdXN0b20gYWN0aW9uXG5cdFx0ICogICAgICAgICQoXCIjbXktZWxlbVwiKS5sZWZ0KFwiMjAwXCIpO1xuXHRcdCAqICAgICAgfSlcblx0XHQgKiAgICAgIC5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogICAgICAgIC8vIHJlc2V0IG15IGVsZW1lbnQgdG8gc3RhcnQgcG9zaXRpb25cblx0XHQgKiAgICAgICAgaWYgKGV2ZW50LnJlc2V0KSB7XG5cdFx0ICogICAgICAgICAgJChcIiNteS1lbGVtXCIpLmxlZnQoXCIwXCIpO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBPYmplY3QgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2tcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7U2NlbmV9IGV2ZW50LnRhcmdldCAtIFRoZSBTY2VuZSBvYmplY3QgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXZlbnQucmVzZXQgLSBJbmRpY2F0ZXMgaWYgdGhlIGRlc3Ryb3kgbWV0aG9kIHdhcyBjYWxsZWQgd2l0aCByZXNldCBgdHJ1ZWAgb3IgYGZhbHNlYC5cblx0XHQgKi9cblx0XHQvKipcblx0XHQgKiBTY2VuZSBhZGQgZXZlbnQuICBcblx0XHQgKiBGaXJlcyB3aGVuIHRoZSBzY2VuZSBpcyBhZGRlZCB0byBhIGNvbnRyb2xsZXIuXG5cdFx0ICogVGhpcyBpcyBtb3N0bHkgdXNlZCBieSBwbHVnaW5zIHRvIGtub3cgdGhhdCBjaGFuZ2UgbWlnaHQgYmUgZHVlLlxuXHRcdCAqXG5cdFx0ICogQGV2ZW50IFNjcm9sbE1hZ2ljLlNjZW5lI2FkZFxuXHRcdCAqIEBzaW5jZSAyLjAuMFxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZS5vbihcImFkZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiBcdGNvbnNvbGUubG9nKCdTY2VuZSB3YXMgYWRkZWQgdG8gYSBuZXcgY29udHJvbGxlci4nKTtcblx0XHQgKiB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBPYmplY3QgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2tcblx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7U2NlbmV9IGV2ZW50LnRhcmdldCAtIFRoZSBTY2VuZSBvYmplY3QgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudFxuXHRcdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXZlbnQuY29udHJvbGxlciAtIFRoZSBjb250cm9sbGVyIG9iamVjdCB0aGUgc2NlbmUgd2FzIGFkZGVkIHRvLlxuXHRcdCAqL1xuXHRcdC8qKlxuXHRcdCAqIFNjZW5lIHJlbW92ZSBldmVudC4gIFxuXHRcdCAqIEZpcmVzIHdoZW4gdGhlIHNjZW5lIGlzIHJlbW92ZWQgZnJvbSBhIGNvbnRyb2xsZXIuXG5cdFx0ICogVGhpcyBpcyBtb3N0bHkgdXNlZCBieSBwbHVnaW5zIHRvIGtub3cgdGhhdCBjaGFuZ2UgbWlnaHQgYmUgZHVlLlxuXHRcdCAqXG5cdFx0ICogQGV2ZW50IFNjcm9sbE1hZ2ljLlNjZW5lI3JlbW92ZVxuXHRcdCAqIEBzaW5jZSAyLjAuMFxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBzY2VuZS5vbihcInJlbW92ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgKiBcdGNvbnNvbGUubG9nKCdTY2VuZSB3YXMgcmVtb3ZlZCBmcm9tIGl0cyBjb250cm9sbGVyLicpO1xuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IE9iamVjdCBwYXNzZWQgdG8gZWFjaCBjYWxsYmFja1xuXHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHByb3BlcnR5IHtTY2VuZX0gZXZlbnQudGFyZ2V0IC0gVGhlIFNjZW5lIG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50XG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBBZGQgb25lIG9yZSBtb3JlIGV2ZW50IGxpc3RlbmVyLiAgXG5cdFx0ICogVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgZmlyZWQgYXQgdGhlIHJlc3BlY3RpdmUgZXZlbnQsIGFuZCBhbiBvYmplY3QgY29udGFpbmluZyByZWxldmFudCBkYXRhIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI29uXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIGZ1bmN0aW9uIGNhbGxiYWNrIChldmVudCkge1xuXHRcdCAqIFx0XHRjb25zb2xlLmxvZyhcIkV2ZW50IGZpcmVkISAoXCIgKyBldmVudC50eXBlICsgXCIpXCIpO1xuXHRcdCAqIH1cblx0XHQgKiAvLyBhZGQgbGlzdGVuZXJzXG5cdFx0ICogc2NlbmUub24oXCJjaGFuZ2UgdXBkYXRlIHByb2dyZXNzIHN0YXJ0IGVuZCBlbnRlciBsZWF2ZVwiLCBjYWxsYmFjayk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXMgLSBUaGUgbmFtZSBvciBuYW1lcyBvZiB0aGUgZXZlbnQgdGhlIGNhbGxiYWNrIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQsIHdoZW4gdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuIEFuIGV2ZW50IG9iamVjdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLm9uID0gZnVuY3Rpb24gKG5hbWVzLCBjYWxsYmFjaykge1xuXHRcdFx0aWYgKF91dGlsLnR5cGUuRnVuY3Rpb24oY2FsbGJhY2spKSB7XG5cdFx0XHRcdG5hbWVzID0gbmFtZXMudHJpbSgpLnNwbGl0KCcgJyk7XG5cdFx0XHRcdG5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGZ1bGxuYW1lKSB7XG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0bmFtZXBhcnRzID0gZnVsbG5hbWUuc3BsaXQoJy4nKSxcblx0XHRcdFx0XHRcdGV2ZW50bmFtZSA9IG5hbWVwYXJ0c1swXSxcblx0XHRcdFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVwYXJ0c1sxXTtcblx0XHRcdFx0XHRpZiAoZXZlbnRuYW1lICE9IFwiKlwiKSB7IC8vIGRpc2FsbG93IHdpbGRjYXJkc1xuXHRcdFx0XHRcdFx0aWYgKCFfbGlzdGVuZXJzW2V2ZW50bmFtZV0pIHtcblx0XHRcdFx0XHRcdFx0X2xpc3RlbmVyc1tldmVudG5hbWVdID0gW107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRfbGlzdGVuZXJzW2V2ZW50bmFtZV0ucHVzaCh7XG5cdFx0XHRcdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlIHx8ICcnLFxuXHRcdFx0XHRcdFx0XHRjYWxsYmFjazogY2FsbGJhY2tcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsb2coMSwgXCJFUlJPUiB3aGVuIGNhbGxpbmcgJy5vbigpJzogU3VwcGxpZWQgY2FsbGJhY2sgZm9yICdcIiArIG5hbWVzICsgXCInIGlzIG5vdCBhIHZhbGlkIGZ1bmN0aW9uIVwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIG9uZSBvciBtb3JlIGV2ZW50IGxpc3RlbmVyLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjb2ZmXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIGZ1bmN0aW9uIGNhbGxiYWNrIChldmVudCkge1xuXHRcdCAqIFx0XHRjb25zb2xlLmxvZyhcIkV2ZW50IGZpcmVkISAoXCIgKyBldmVudC50eXBlICsgXCIpXCIpO1xuXHRcdCAqIH1cblx0XHQgKiAvLyBhZGQgbGlzdGVuZXJzXG5cdFx0ICogc2NlbmUub24oXCJjaGFuZ2UgdXBkYXRlXCIsIGNhbGxiYWNrKTtcblx0XHQgKiAvLyByZW1vdmUgbGlzdGVuZXJzXG5cdFx0ICogc2NlbmUub2ZmKFwiY2hhbmdlIHVwZGF0ZVwiLCBjYWxsYmFjayk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXMgLSBUaGUgbmFtZSBvciBuYW1lcyBvZiB0aGUgZXZlbnQgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBzcGVjaWZpYyBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSByZW1vdmVkLiBJZiBub25lIGlzIHBhc3NlZCBhbGwgY2FsbGJhY2tzIHRvIHRoZSBldmVudCBsaXN0ZW5lciB3aWxsIGJlIHJlbW92ZWQuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLm9mZiA9IGZ1bmN0aW9uIChuYW1lcywgY2FsbGJhY2spIHtcblx0XHRcdGlmICghbmFtZXMpIHtcblx0XHRcdFx0bG9nKDEsIFwiRVJST1I6IEludmFsaWQgZXZlbnQgbmFtZSBzdXBwbGllZC5cIik7XG5cdFx0XHRcdHJldHVybiBTY2VuZTtcblx0XHRcdH1cblx0XHRcdG5hbWVzID0gbmFtZXMudHJpbSgpLnNwbGl0KCcgJyk7XG5cdFx0XHRuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmdWxsbmFtZSwga2V5KSB7XG5cdFx0XHRcdHZhclxuXHRcdFx0XHRuYW1lcGFydHMgPSBmdWxsbmFtZS5zcGxpdCgnLicpLFxuXHRcdFx0XHRcdGV2ZW50bmFtZSA9IG5hbWVwYXJ0c1swXSxcblx0XHRcdFx0XHRuYW1lc3BhY2UgPSBuYW1lcGFydHNbMV0gfHwgJycsXG5cdFx0XHRcdFx0cmVtb3ZlTGlzdCA9IGV2ZW50bmFtZSA9PT0gJyonID8gT2JqZWN0LmtleXMoX2xpc3RlbmVycykgOiBbZXZlbnRuYW1lXTtcblx0XHRcdFx0cmVtb3ZlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChyZW1vdmUpIHtcblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRsaXN0ID0gX2xpc3RlbmVyc1tyZW1vdmVdIHx8IFtdLFxuXHRcdFx0XHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRcdHZhciBsaXN0ZW5lciA9IGxpc3RbaV07XG5cdFx0XHRcdFx0XHRpZiAobGlzdGVuZXIgJiYgKG5hbWVzcGFjZSA9PT0gbGlzdGVuZXIubmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gJyonKSAmJiAoIWNhbGxiYWNrIHx8IGNhbGxiYWNrID09IGxpc3RlbmVyLmNhbGxiYWNrKSkge1xuXHRcdFx0XHRcdFx0XHRsaXN0LnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFsaXN0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIF9saXN0ZW5lcnNbcmVtb3ZlXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRyaWdnZXIgYW4gZXZlbnQuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSN0cmlnZ2VyXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHRoaXMudHJpZ2dlcihcImNoYW5nZVwiKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRoYXQgc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhcnNdIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mbyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy50cmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUsIHZhcnMpIHtcblx0XHRcdGlmIChuYW1lKSB7XG5cdFx0XHRcdHZhclxuXHRcdFx0XHRuYW1lcGFydHMgPSBuYW1lLnRyaW0oKS5zcGxpdCgnLicpLFxuXHRcdFx0XHRcdGV2ZW50bmFtZSA9IG5hbWVwYXJ0c1swXSxcblx0XHRcdFx0XHRuYW1lc3BhY2UgPSBuYW1lcGFydHNbMV0sXG5cdFx0XHRcdFx0bGlzdGVuZXJzID0gX2xpc3RlbmVyc1tldmVudG5hbWVdO1xuXHRcdFx0XHRsb2coMywgJ2V2ZW50IGZpcmVkOicsIGV2ZW50bmFtZSwgdmFycyA/IFwiLT5cIiA6ICcnLCB2YXJzIHx8ICcnKTtcblx0XHRcdFx0aWYgKGxpc3RlbmVycykge1xuXHRcdFx0XHRcdGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lciwga2V5KSB7XG5cdFx0XHRcdFx0XHRpZiAoIW5hbWVzcGFjZSB8fCBuYW1lc3BhY2UgPT09IGxpc3RlbmVyLm5hbWVzcGFjZSkge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5jYWxsYmFjay5jYWxsKFNjZW5lLCBuZXcgU2Nyb2xsTWFnaWMuRXZlbnQoZXZlbnRuYW1lLCBsaXN0ZW5lci5uYW1lc3BhY2UsIFNjZW5lLCB2YXJzKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvZygxLCBcIkVSUk9SOiBJbnZhbGlkIGV2ZW50IG5hbWUgc3VwcGxpZWQuXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvLyBzZXQgZXZlbnQgbGlzdGVuZXJzXG5cdFx0U2NlbmUub24oXCJjaGFuZ2UuaW50ZXJuYWxcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChlLndoYXQgIT09IFwibG9nbGV2ZWxcIiAmJiBlLndoYXQgIT09IFwidHdlZW5DaGFuZ2VzXCIpIHsgLy8gbm8gbmVlZCBmb3IgYSBzY2VuZSB1cGRhdGUgc2NlbmUgd2l0aCB0aGVzZSBvcHRpb25zLi4uXG5cdFx0XHRcdGlmIChlLndoYXQgPT09IFwidHJpZ2dlckVsZW1lbnRcIikge1xuXHRcdFx0XHRcdHVwZGF0ZVRyaWdnZXJFbGVtZW50UG9zaXRpb24oKTtcblx0XHRcdFx0fSBlbHNlIGlmIChlLndoYXQgPT09IFwicmV2ZXJzZVwiKSB7IC8vIHRoZSBvbmx5IHByb3BlcnR5IGxlZnQgdGhhdCBtYXkgaGF2ZSBhbiBpbXBhY3Qgb24gdGhlIGN1cnJlbnQgc2NlbmUgc3RhdGUuIEV2ZXJ5dGhpbmcgZWxzZSBpcyBoYW5kbGVkIGJ5IHRoZSBzaGlmdCBldmVudC5cblx0XHRcdFx0XHRTY2VuZS51cGRhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pLm9uKFwic2hpZnQuaW50ZXJuYWxcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdHVwZGF0ZVNjcm9sbE9mZnNldCgpO1xuXHRcdFx0U2NlbmUudXBkYXRlKCk7IC8vIHVwZGF0ZSBzY2VuZSB0byByZWZsZWN0IG5ldyBwb3NpdGlvblxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogU2VuZCBhIGRlYnVnIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGUuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBidXQgcHJvdmlkZWQgcHVibGljbHkgd2l0aCBfbG9nIGZvciBwbHVnaW5zXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gbG9nbGV2ZWwgLSBUaGUgbG9nbGV2ZWwgcmVxdWlyZWQgdG8gaW5pdGlhdGUgb3V0cHV0IGZvciB0aGUgbWVzc2FnZS5cblx0XHQgKiBAcGFyYW0gey4uLm1peGVkfSBvdXRwdXQgLSBPbmUgb3IgbW9yZSB2YXJpYWJsZXMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBjb25zb2xlLlxuXHRcdCAqL1xuXHRcdHZhciBsb2cgPSB0aGlzLl9sb2cgPSBmdW5jdGlvbiAobG9nbGV2ZWwsIG91dHB1dCkge1xuXHRcdFx0aWYgKF9vcHRpb25zLmxvZ2xldmVsID49IGxvZ2xldmVsKSB7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDEsIDAsIFwiKFwiICsgTkFNRVNQQUNFICsgXCIpIC0+XCIpO1xuXHRcdFx0XHRfdXRpbC5sb2cuYXBwbHkod2luZG93LCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBBZGQgdGhlIHNjZW5lIHRvIGEgY29udHJvbGxlci4gIFxuXHRcdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgdG8gYENvbnRyb2xsZXIuYWRkU2NlbmUoc2NlbmUpYC5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI2FkZFRvXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGFkZCBhIHNjZW5lIHRvIGEgU2Nyb2xsTWFnaWMgQ29udHJvbGxlclxuXHRcdCAqIHNjZW5lLmFkZFRvKGNvbnRyb2xsZXIpO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTY3JvbGxNYWdpYy5Db250cm9sbGVyfSBjb250cm9sbGVyIC0gVGhlIGNvbnRyb2xsZXIgdG8gd2hpY2ggdGhlIHNjZW5lIHNob3VsZCBiZSBhZGRlZC5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMuYWRkVG8gPSBmdW5jdGlvbiAoY29udHJvbGxlcikge1xuXHRcdFx0aWYgKCEoY29udHJvbGxlciBpbnN0YW5jZW9mIFNjcm9sbE1hZ2ljLkNvbnRyb2xsZXIpKSB7XG5cdFx0XHRcdGxvZygxLCBcIkVSUk9SOiBzdXBwbGllZCBhcmd1bWVudCBvZiAnYWRkVG8oKScgaXMgbm90IGEgdmFsaWQgU2Nyb2xsTWFnaWMgQ29udHJvbGxlclwiKTtcblx0XHRcdH0gZWxzZSBpZiAoX2NvbnRyb2xsZXIgIT0gY29udHJvbGxlcikge1xuXHRcdFx0XHQvLyBuZXcgY29udHJvbGxlclxuXHRcdFx0XHRpZiAoX2NvbnRyb2xsZXIpIHsgLy8gd2FzIGFzc29jaWF0ZWQgdG8gYSBkaWZmZXJlbnQgY29udHJvbGxlciBiZWZvcmUsIHNvIHJlbW92ZSBpdC4uLlxuXHRcdFx0XHRcdF9jb250cm9sbGVyLnJlbW92ZVNjZW5lKFNjZW5lKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cdFx0XHRcdHZhbGlkYXRlT3B0aW9uKCk7XG5cdFx0XHRcdHVwZGF0ZUR1cmF0aW9uKHRydWUpO1xuXHRcdFx0XHR1cGRhdGVUcmlnZ2VyRWxlbWVudFBvc2l0aW9uKHRydWUpO1xuXHRcdFx0XHR1cGRhdGVTY3JvbGxPZmZzZXQoKTtcblx0XHRcdFx0X2NvbnRyb2xsZXIuaW5mbyhcImNvbnRhaW5lclwiKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbkNvbnRhaW5lclJlc2l6ZSk7XG5cdFx0XHRcdGNvbnRyb2xsZXIuYWRkU2NlbmUoU2NlbmUpO1xuXHRcdFx0XHRTY2VuZS50cmlnZ2VyKFwiYWRkXCIsIHtcblx0XHRcdFx0XHRjb250cm9sbGVyOiBfY29udHJvbGxlclxuXHRcdFx0XHR9KTtcblx0XHRcdFx0bG9nKDMsIFwiYWRkZWQgXCIgKyBOQU1FU1BBQ0UgKyBcIiB0byBjb250cm9sbGVyXCIpO1xuXHRcdFx0XHRTY2VuZS51cGRhdGUoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiBvciAqKlNldCoqIHRoZSBjdXJyZW50IGVuYWJsZWQgc3RhdGUgb2YgdGhlIHNjZW5lLiAgXG5cdFx0ICogVGhpcyBjYW4gYmUgdXNlZCB0byBkaXNhYmxlIHRoaXMgc2NlbmUgd2l0aG91dCByZW1vdmluZyBvciBkZXN0cm95aW5nIGl0LlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjZW5hYmxlZFxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgdmFsdWVcblx0XHQgKiB2YXIgZW5hYmxlZCA9IHNjZW5lLmVuYWJsZWQoKTtcblx0XHQgKlxuXHRcdCAqIC8vIGRpc2FibGUgdGhlIHNjZW5lXG5cdFx0ICogc2NlbmUuZW5hYmxlZChmYWxzZSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtuZXdTdGF0ZV0gLSBUaGUgbmV3IGVuYWJsZWQgc3RhdGUgb2YgdGhlIHNjZW5lIGB0cnVlYCBvciBgZmFsc2VgLlxuXHRcdCAqIEByZXR1cm5zIHsoYm9vbGVhbnxTY2VuZSl9IEN1cnJlbnQgZW5hYmxlZCBzdGF0ZSBvciBwYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblx0XHR0aGlzLmVuYWJsZWQgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkgeyAvLyBnZXRcblx0XHRcdFx0cmV0dXJuIF9lbmFibGVkO1xuXHRcdFx0fSBlbHNlIGlmIChfZW5hYmxlZCAhPSBuZXdTdGF0ZSkgeyAvLyBzZXRcblx0XHRcdFx0X2VuYWJsZWQgPSAhISBuZXdTdGF0ZTtcblx0XHRcdFx0U2NlbmUudXBkYXRlKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgdGhlIHNjZW5lIGZyb20gdGhlIGNvbnRyb2xsZXIuICBcblx0XHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IHRvIGBDb250cm9sbGVyLnJlbW92ZVNjZW5lKHNjZW5lKWAuXG5cdFx0ICogVGhlIHNjZW5lIHdpbGwgbm90IGJlIHVwZGF0ZWQgYW55bW9yZSB1bnRpbCB5b3UgcmVhZGQgaXQgdG8gYSBjb250cm9sbGVyLlxuXHRcdCAqIFRvIHJlbW92ZSB0aGUgcGluIG9yIHRoZSB0d2VlbiB5b3UgbmVlZCB0byBjYWxsIHJlbW92ZVR3ZWVuKCkgb3IgcmVtb3ZlUGluKCkgcmVzcGVjdGl2ZWx5LlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjcmVtb3ZlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyByZW1vdmUgdGhlIHNjZW5lIGZyb20gaXRzIGNvbnRyb2xsZXJcblx0XHQgKiBzY2VuZS5yZW1vdmUoKTtcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoX2NvbnRyb2xsZXIpIHtcblx0XHRcdFx0X2NvbnRyb2xsZXIuaW5mbyhcImNvbnRhaW5lclwiKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbkNvbnRhaW5lclJlc2l6ZSk7XG5cdFx0XHRcdHZhciB0bXBQYXJlbnQgPSBfY29udHJvbGxlcjtcblx0XHRcdFx0X2NvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHRtcFBhcmVudC5yZW1vdmVTY2VuZShTY2VuZSk7XG5cdFx0XHRcdFNjZW5lLnRyaWdnZXIoXCJyZW1vdmVcIik7XG5cdFx0XHRcdGxvZygzLCBcInJlbW92ZWQgXCIgKyBOQU1FU1BBQ0UgKyBcIiBmcm9tIGNvbnRyb2xsZXJcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3kgdGhlIHNjZW5lIGFuZCBldmVyeXRoaW5nLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjZGVzdHJveVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZGVzdHJveSB0aGUgc2NlbmUgd2l0aG91dCByZXNldHRpbmcgdGhlIHBpbiBhbmQgdHdlZW4gdG8gdGhlaXIgaW5pdGlhbCBwb3NpdGlvbnNcblx0XHQgKiBzY2VuZSA9IHNjZW5lLmRlc3Ryb3koKTtcblx0XHQgKlxuXHRcdCAqIC8vIGRlc3Ryb3kgdGhlIHNjZW5lIGFuZCByZXNldCB0aGUgcGluIGFuZCB0d2VlblxuXHRcdCAqIHNjZW5lID0gc2NlbmUuZGVzdHJveSh0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0PWZhbHNlXSAtIElmIGB0cnVlYCB0aGUgcGluIGFuZCB0d2VlbiAoaWYgZXhpc3RlbnQpIHdpbGwgYmUgcmVzZXQuXG5cdFx0ICogQHJldHVybnMge251bGx9IE51bGwgdG8gdW5zZXQgaGFuZGxlciB2YXJpYWJsZXMuXG5cdFx0ICovXG5cdFx0dGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKHJlc2V0KSB7XG5cdFx0XHRTY2VuZS50cmlnZ2VyKFwiZGVzdHJveVwiLCB7XG5cdFx0XHRcdHJlc2V0OiByZXNldFxuXHRcdFx0fSk7XG5cdFx0XHRTY2VuZS5yZW1vdmUoKTtcblx0XHRcdFNjZW5lLm9mZihcIiouKlwiKTtcblx0XHRcdGxvZygzLCBcImRlc3Ryb3llZCBcIiArIE5BTUVTUEFDRSArIFwiIChyZXNldDogXCIgKyAocmVzZXQgPyBcInRydWVcIiA6IFwiZmFsc2VcIikgKyBcIilcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBTY2VuZSB0byByZWZsZWN0IHRoZSBjdXJyZW50IHN0YXRlLiAgXG5cdFx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCB0byBgQ29udHJvbGxlci51cGRhdGVTY2VuZShzY2VuZSwgaW1tZWRpYXRlbHkpYC4gIFxuXHRcdCAqIFRoZSB1cGRhdGUgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIHNjZW5lJ3Mgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbiAoYmFzZWQgb24gdGhlIHRyaWdnZXIgZWxlbWVudCwgdHJpZ2dlciBob29rLCBkdXJhdGlvbiBhbmQgb2Zmc2V0KSBhbmQgY2hlY2tzIGl0IGFnYWluc3QgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIuICBcblx0XHQgKiBJdCB0aGVuIHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2NlbmUgc3RhdGUgYWNjb3JkaW5nbHkgKG9yIGRvZXMgbm90aGluZywgaWYgdGhlIHN0YXRlIGlzIGFscmVhZHkgY29ycmVjdCkg4oCTIFBpbnMgd2lsbCBiZSBzZXQgdG8gdGhlaXIgY29ycmVjdCBwb3NpdGlvbiBhbmQgdHdlZW5zIHdpbGwgYmUgdXBkYXRlZCB0byB0aGVpciBjb3JyZWN0IHByb2dyZXNzLlxuXHRcdCAqIFRoaXMgbWVhbnMgYW4gdXBkYXRlIGRvZXNuJ3QgbmVjZXNzYXJpbHkgcmVzdWx0IGluIGEgcHJvZ3Jlc3MgY2hhbmdlLiBUaGUgYHByb2dyZXNzYCBldmVudCB3aWxsIGJlIGZpcmVkIGlmIHRoZSBwcm9ncmVzcyBoYXMgaW5kZWVkIGNoYW5nZWQgYmV0d2VlbiB0aGlzIHVwZGF0ZSBhbmQgdGhlIGxhc3QuICBcblx0XHQgKiBfKipOT1RFOioqIFRoaXMgbWV0aG9kIGdldHMgY2FsbGVkIGNvbnN0YW50bHkgd2hlbmV2ZXIgU2Nyb2xsTWFnaWMgZGV0ZWN0cyBhIGNoYW5nZS4gVGhlIG9ubHkgYXBwbGljYXRpb24gZm9yIHlvdSBpcyBpZiB5b3UgY2hhbmdlIHNvbWV0aGluZyBvdXRzaWRlIG9mIHRoZSByZWFsbSBvZiBTY3JvbGxNYWdpYywgbGlrZSBtb3ZpbmcgdGhlIHRyaWdnZXIgb3IgY2hhbmdpbmcgdHdlZW4gcGFyYW1ldGVycy5fXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSN1cGRhdGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHVwZGF0ZSB0aGUgc2NlbmUgb24gbmV4dCB0aWNrXG5cdFx0ICogc2NlbmUudXBkYXRlKCk7XG5cdFx0ICpcblx0XHQgKiAvLyB1cGRhdGUgdGhlIHNjZW5lIGltbWVkaWF0ZWx5XG5cdFx0ICogc2NlbmUudXBkYXRlKHRydWUpO1xuXHRcdCAqXG5cdFx0ICogQGZpcmVzIFNjZW5lLnVwZGF0ZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbaW1tZWRpYXRlbHk9ZmFsc2VdIC0gSWYgYHRydWVgIHRoZSB1cGRhdGUgd2lsbCBiZSBpbnN0YW50LCBpZiBgZmFsc2VgIGl0IHdpbGwgd2FpdCB1bnRpbCBuZXh0IHVwZGF0ZSBjeWNsZSAoYmV0dGVyIHBlcmZvcm1hbmNlKS5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKGltbWVkaWF0ZWx5KSB7XG5cdFx0XHRpZiAoX2NvbnRyb2xsZXIpIHtcblx0XHRcdFx0aWYgKGltbWVkaWF0ZWx5KSB7XG5cdFx0XHRcdFx0aWYgKF9jb250cm9sbGVyLmVuYWJsZWQoKSAmJiBfZW5hYmxlZCkge1xuXHRcdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHRzY3JvbGxQb3MgPSBfY29udHJvbGxlci5pbmZvKFwic2Nyb2xsUG9zXCIpLFxuXHRcdFx0XHRcdFx0XHRuZXdQcm9ncmVzcztcblxuXHRcdFx0XHRcdFx0aWYgKF9vcHRpb25zLmR1cmF0aW9uID4gMCkge1xuXHRcdFx0XHRcdFx0XHRuZXdQcm9ncmVzcyA9IChzY3JvbGxQb3MgLSBfc2Nyb2xsT2Zmc2V0LnN0YXJ0KSAvIChfc2Nyb2xsT2Zmc2V0LmVuZCAtIF9zY3JvbGxPZmZzZXQuc3RhcnQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bmV3UHJvZ3Jlc3MgPSBzY3JvbGxQb3MgPj0gX3Njcm9sbE9mZnNldC5zdGFydCA/IDEgOiAwO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRTY2VuZS50cmlnZ2VyKFwidXBkYXRlXCIsIHtcblx0XHRcdFx0XHRcdFx0c3RhcnRQb3M6IF9zY3JvbGxPZmZzZXQuc3RhcnQsXG5cdFx0XHRcdFx0XHRcdGVuZFBvczogX3Njcm9sbE9mZnNldC5lbmQsXG5cdFx0XHRcdFx0XHRcdHNjcm9sbFBvczogc2Nyb2xsUG9zXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0U2NlbmUucHJvZ3Jlc3MobmV3UHJvZ3Jlc3MpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoX3BpbiAmJiBfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0RVUklORykge1xuXHRcdFx0XHRcdFx0dXBkYXRlUGluU3RhdGUodHJ1ZSk7IC8vIHVucGluIGluIHBvc2l0aW9uXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9jb250cm9sbGVyLnVwZGF0ZVNjZW5lKFNjZW5lLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyBkeW5hbWljIHNjZW5lIHZhcmlhYmxlcyBsaWtlIHRoZSB0cmlnZ2VyIGVsZW1lbnQgcG9zaXRpb24gb3IgdGhlIGR1cmF0aW9uLlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGluIHJlZ3VsYXIgaW50ZXJ2YWxzIGZyb20gdGhlIGNvbnRyb2xsZXIuIFNlZSB7QGxpbmsgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcn0gb3B0aW9uIGByZWZyZXNoSW50ZXJ2YWxgLlxuXHRcdCAqIFxuXHRcdCAqIFlvdSBjYW4gY2FsbCBpdCB0byBtaW5pbWl6ZSBsYWcsIGZvciBleGFtcGxlIHdoZW4geW91IGludGVudGlvbmFsbHkgY2hhbmdlIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHJpZ2dlckVsZW1lbnQuXG5cdFx0ICogSWYgeW91IGRvbid0IGl0IHdpbGwgc2ltcGx5IGJlIHVwZGF0ZWQgaW4gdGhlIG5leHQgcmVmcmVzaCBpbnRlcnZhbCBvZiB0aGUgY29udGFpbmVyLCB3aGljaCBpcyB1c3VhbGx5IHN1ZmZpY2llbnQuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3JlZnJlc2hcblx0XHQgKiBAc2luY2UgMS4xLjBcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNjZW5lID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHt0cmlnZ2VyRWxlbWVudDogXCIjdHJpZ2dlclwifSk7XG5cdFx0ICogXG5cdFx0ICogLy8gY2hhbmdlIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHJpZ2dlclxuXHRcdCAqICQoXCIjdHJpZ2dlclwiKS5jc3MoXCJ0b3BcIiwgNTAwKTtcblx0XHQgKiAvLyBpbW1lZGlhdGVseSBsZXQgdGhlIHNjZW5lIGtub3cgb2YgdGhpcyBjaGFuZ2Vcblx0XHQgKiBzY2VuZS5yZWZyZXNoKCk7XG5cdFx0ICpcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLnNoaWZ0fSwgaWYgdGhlIHRyaWdnZXIgZWxlbWVudCBwb3NpdGlvbiBvciB0aGUgZHVyYXRpb24gY2hhbmdlZFxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuY2hhbmdlfSwgaWYgdGhlIGR1cmF0aW9uIGNoYW5nZWRcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dXBkYXRlRHVyYXRpb24oKTtcblx0XHRcdHVwZGF0ZVRyaWdnZXJFbGVtZW50UG9zaXRpb24oKTtcblx0XHRcdC8vIHVwZGF0ZSB0cmlnZ2VyIGVsZW1lbnQgcG9zaXRpb25cblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiBvciAqKlNldCoqIHRoZSBzY2VuZSdzIHByb2dyZXNzLiAgXG5cdFx0ICogVXN1YWxseSBpdCBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IHRvIHVzZSB0aGlzIGFzIGEgc2V0dGVyLCBhcyBpdCBpcyBzZXQgYXV0b21hdGljYWxseSBieSBzY2VuZS51cGRhdGUoKS4gIFxuXHRcdCAqIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgZXZlbnRzIGFyZSBmaXJlZCBkZXBlbmRzIG9uIHRoZSBkdXJhdGlvbiBvZiB0aGUgc2NlbmU6XG5cdFx0ICogIDEuIFNjZW5lcyB3aXRoIGBkdXJhdGlvbiA9PSAwYDogIFxuXHRcdCAqICBTY2VuZXMgdGhhdCBoYXZlIG5vIGR1cmF0aW9uIGJ5IGRlZmluaXRpb24gaGF2ZSBubyBlbmRpbmcuIFRodXMgdGhlIGBlbmRgIGV2ZW50IHdpbGwgbmV2ZXIgYmUgZmlyZWQuICBcblx0XHQgKiAgV2hlbiB0aGUgdHJpZ2dlciBwb3NpdGlvbiBvZiB0aGUgc2NlbmUgaXMgcGFzc2VkIHRoZSBldmVudHMgYXJlIGFsd2F5cyBmaXJlZCBpbiB0aGlzIG9yZGVyOiAgXG5cdFx0ICogIGBlbnRlcmAsIGBzdGFydGAsIGBwcm9ncmVzc2Agd2hlbiBzY3JvbGxpbmcgZm9yd2FyZCAgXG5cdFx0ICogIGFuZCAgXG5cdFx0ICogIGBwcm9ncmVzc2AsIGBzdGFydGAsIGBsZWF2ZWAgd2hlbiBzY3JvbGxpbmcgaW4gcmV2ZXJzZVxuXHRcdCAqICAyLiBTY2VuZXMgd2l0aCBgZHVyYXRpb24gPiAwYDogIFxuXHRcdCAqICBTY2VuZXMgd2l0aCBhIHNldCBkdXJhdGlvbiBoYXZlIGEgZGVmaW5lZCBzdGFydCBhbmQgZW5kIHBvaW50LiAgXG5cdFx0ICogIFdoZW4gc2Nyb2xsaW5nIHBhc3QgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzY2VuZSBpdCB3aWxsIGZpcmUgdGhlc2UgZXZlbnRzIGluIHRoaXMgb3JkZXI6ICBcblx0XHQgKiAgYGVudGVyYCwgYHN0YXJ0YCwgYHByb2dyZXNzYCAgXG5cdFx0ICogIFdoZW4gY29udGludWluZyB0byBzY3JvbGwgYW5kIHBhc3NpbmcgdGhlIGVuZCBwb2ludCBpdCB3aWxsIGZpcmUgdGhlc2UgZXZlbnRzOiAgXG5cdFx0ICogIGBwcm9ncmVzc2AsIGBlbmRgLCBgbGVhdmVgICBcblx0XHQgKiAgV2hlbiByZXZlcnNpbmcgdGhyb3VnaCB0aGUgZW5kIHBvaW50IHRoZXNlIGV2ZW50cyBhcmUgZmlyZWQ6ICBcblx0XHQgKiAgYGVudGVyYCwgYGVuZGAsIGBwcm9ncmVzc2AgIFxuXHRcdCAqICBBbmQgd2hlbiBjb250aW51aW5nIHRvIHNjcm9sbCBwYXN0IHRoZSBzdGFydCBwb3NpdGlvbiBpbiByZXZlcnNlIGl0IHdpbGwgZmlyZTogIFxuXHRcdCAqICBgcHJvZ3Jlc3NgLCBgc3RhcnRgLCBgbGVhdmVgICBcblx0XHQgKiAgSW4gYmV0d2VlbiBzdGFydCBhbmQgZW5kIHRoZSBgcHJvZ3Jlc3NgIGV2ZW50IHdpbGwgYmUgY2FsbGVkIGNvbnN0YW50bHksIHdoZW5ldmVyIHRoZSBwcm9ncmVzcyBjaGFuZ2VzLlxuXHRcdCAqIFxuXHRcdCAqIEluIHNob3J0OiAgXG5cdFx0ICogYGVudGVyYCBldmVudHMgd2lsbCBhbHdheXMgdHJpZ2dlciAqKmJlZm9yZSoqIHRoZSBwcm9ncmVzcyB1cGRhdGUgYW5kIGBsZWF2ZWAgZW52ZW50cyB3aWxsIHRyaWdnZXIgKiphZnRlcioqIHRoZSBwcm9ncmVzcyB1cGRhdGUuICBcblx0XHQgKiBgc3RhcnRgIGFuZCBgZW5kYCB3aWxsIGFsd2F5cyB0cmlnZ2VyIGF0IHRoZWlyIHJlc3BlY3RpdmUgcG9zaXRpb24uXG5cdFx0ICogXG5cdFx0ICogUGxlYXNlIHJldmlldyB0aGUgZXZlbnQgZGVzY3JpcHRpb25zIGZvciBkZXRhaWxzIG9uIHRoZSBldmVudHMgYW5kIHRoZSBldmVudCBvYmplY3QgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLlxuXHRcdCAqIFxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjcHJvZ3Jlc3Ncblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCBzY2VuZSBwcm9ncmVzc1xuXHRcdCAqIHZhciBwcm9ncmVzcyA9IHNjZW5lLnByb2dyZXNzKCk7XG5cdFx0ICpcblx0XHQgKiAvLyBzZXQgbmV3IHNjZW5lIHByb2dyZXNzXG5cdFx0ICogc2NlbmUucHJvZ3Jlc3MoMC4zKTtcblx0XHQgKlxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuZW50ZXJ9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5zdGFydH0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLnByb2dyZXNzfSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuZW5kfSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUubGVhdmV9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gW3Byb2dyZXNzXSAtIFRoZSBuZXcgcHJvZ3Jlc3MgdmFsdWUgb2YgdGhlIHNjZW5lIGBbMC0xXWAuXG5cdFx0ICogQHJldHVybnMge251bWJlcn0gYGdldGAgLSAgQ3VycmVudCBzY2VuZSBwcm9ncmVzcy5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IGBzZXRgIC0gIFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkgeyAvLyBnZXRcblx0XHRcdFx0cmV0dXJuIF9wcm9ncmVzcztcblx0XHRcdH0gZWxzZSB7IC8vIHNldFxuXHRcdFx0XHR2YXJcblx0XHRcdFx0ZG9VcGRhdGUgPSBmYWxzZSxcblx0XHRcdFx0XHRvbGRTdGF0ZSA9IF9zdGF0ZSxcblx0XHRcdFx0XHRzY3JvbGxEaXJlY3Rpb24gPSBfY29udHJvbGxlciA/IF9jb250cm9sbGVyLmluZm8oXCJzY3JvbGxEaXJlY3Rpb25cIikgOiAnUEFVU0VEJyxcblx0XHRcdFx0XHRyZXZlcnNlT3JGb3J3YXJkID0gX29wdGlvbnMucmV2ZXJzZSB8fCBwcm9ncmVzcyA+PSBfcHJvZ3Jlc3M7XG5cdFx0XHRcdGlmIChfb3B0aW9ucy5kdXJhdGlvbiA9PT0gMCkge1xuXHRcdFx0XHRcdC8vIHplcm8gZHVyYXRpb24gc2NlbmVzXG5cdFx0XHRcdFx0ZG9VcGRhdGUgPSBfcHJvZ3Jlc3MgIT0gcHJvZ3Jlc3M7XG5cdFx0XHRcdFx0X3Byb2dyZXNzID0gcHJvZ3Jlc3MgPCAxICYmIHJldmVyc2VPckZvcndhcmQgPyAwIDogMTtcblx0XHRcdFx0XHRfc3RhdGUgPSBfcHJvZ3Jlc3MgPT09IDAgPyBTQ0VORV9TVEFURV9CRUZPUkUgOiBTQ0VORV9TVEFURV9EVVJJTkc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gc2NlbmVzIHdpdGggc3RhcnQgYW5kIGVuZFxuXHRcdFx0XHRcdGlmIChwcm9ncmVzcyA8IDAgJiYgX3N0YXRlICE9PSBTQ0VORV9TVEFURV9CRUZPUkUgJiYgcmV2ZXJzZU9yRm9yd2FyZCkge1xuXHRcdFx0XHRcdFx0Ly8gZ28gYmFjayB0byBpbml0aWFsIHN0YXRlXG5cdFx0XHRcdFx0XHRfcHJvZ3Jlc3MgPSAwO1xuXHRcdFx0XHRcdFx0X3N0YXRlID0gU0NFTkVfU1RBVEVfQkVGT1JFO1xuXHRcdFx0XHRcdFx0ZG9VcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHJvZ3Jlc3MgPj0gMCAmJiBwcm9ncmVzcyA8IDEgJiYgcmV2ZXJzZU9yRm9yd2FyZCkge1xuXHRcdFx0XHRcdFx0X3Byb2dyZXNzID0gcHJvZ3Jlc3M7XG5cdFx0XHRcdFx0XHRfc3RhdGUgPSBTQ0VORV9TVEFURV9EVVJJTkc7XG5cdFx0XHRcdFx0XHRkb1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwcm9ncmVzcyA+PSAxICYmIF9zdGF0ZSAhPT0gU0NFTkVfU1RBVEVfQUZURVIpIHtcblx0XHRcdFx0XHRcdF9wcm9ncmVzcyA9IDE7XG5cdFx0XHRcdFx0XHRfc3RhdGUgPSBTQ0VORV9TVEFURV9BRlRFUjtcblx0XHRcdFx0XHRcdGRvVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfRFVSSU5HICYmICFyZXZlcnNlT3JGb3J3YXJkKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVQaW5TdGF0ZSgpOyAvLyBpbiBjYXNlIHdlIHNjcm9sbGVkIGJhY2t3YXJkcyBtaWQtc2NlbmUgYW5kIHJldmVyc2UgaXMgZGlzYWJsZWQgPT4gdXBkYXRlIHRoZSBwaW4gcG9zaXRpb24sIHNvIGl0IGRvZXNuJ3QgbW92ZSBiYWNrIGFzIHdlbGwuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkb1VwZGF0ZSkge1xuXHRcdFx0XHRcdC8vIGZpcmUgZXZlbnRzXG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0ZXZlbnRWYXJzID0ge1xuXHRcdFx0XHRcdFx0cHJvZ3Jlc3M6IF9wcm9ncmVzcyxcblx0XHRcdFx0XHRcdHN0YXRlOiBfc3RhdGUsXG5cdFx0XHRcdFx0XHRzY3JvbGxEaXJlY3Rpb246IHNjcm9sbERpcmVjdGlvblxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRzdGF0ZUNoYW5nZWQgPSBfc3RhdGUgIT0gb2xkU3RhdGU7XG5cblx0XHRcdFx0XHR2YXIgdHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHsgLy8gdG1wIGhlbHBlciB0byBzaW1wbGlmeSBjb2RlXG5cdFx0XHRcdFx0XHRTY2VuZS50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRWYXJzKTtcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYgKHN0YXRlQ2hhbmdlZCkgeyAvLyBlbnRlciBldmVudHNcblx0XHRcdFx0XHRcdGlmIChvbGRTdGF0ZSAhPT0gU0NFTkVfU1RBVEVfRFVSSU5HKSB7XG5cdFx0XHRcdFx0XHRcdHRyaWdnZXIoXCJlbnRlclwiKTtcblx0XHRcdFx0XHRcdFx0dHJpZ2dlcihvbGRTdGF0ZSA9PT0gU0NFTkVfU1RBVEVfQkVGT1JFID8gXCJzdGFydFwiIDogXCJlbmRcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRyaWdnZXIoXCJwcm9ncmVzc1wiKTtcblx0XHRcdFx0XHRpZiAoc3RhdGVDaGFuZ2VkKSB7IC8vIGxlYXZlIGV2ZW50c1xuXHRcdFx0XHRcdFx0aWYgKF9zdGF0ZSAhPT0gU0NFTkVfU1RBVEVfRFVSSU5HKSB7XG5cdFx0XHRcdFx0XHRcdHRyaWdnZXIoX3N0YXRlID09PSBTQ0VORV9TVEFURV9CRUZPUkUgPyBcInN0YXJ0XCIgOiBcImVuZFwiKTtcblx0XHRcdFx0XHRcdFx0dHJpZ2dlcihcImxlYXZlXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBTY2VuZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdGhlIHN0YXJ0IGFuZCBlbmQgc2Nyb2xsT2Zmc2V0IG9mIHRoZSBjb250YWluZXIuXG5cdFx0ICogVGhlIHBvc2l0aW9ucyByZWZsZWN0IHdoYXQgdGhlIGNvbnRyb2xsZXIncyBzY3JvbGwgcG9zaXRpb24gd2lsbCBiZSBhdCB0aGUgc3RhcnQgYW5kIGVuZCByZXNwZWN0aXZlbHkuXG5cdFx0ICogSXMgY2FsbGVkLCB3aGVuOlxuXHRcdCAqICAgLSBTY2VuZSBldmVudCBcImNoYW5nZVwiIGlzIGNhbGxlZCB3aXRoOiBvZmZzZXQsIHRyaWdnZXJIb29rLCBkdXJhdGlvbiBcblx0XHQgKiAgIC0gc2Nyb2xsIGNvbnRhaW5lciBldmVudCBcInJlc2l6ZVwiIGlzIGNhbGxlZFxuXHRcdCAqICAgLSB0aGUgcG9zaXRpb24gb2YgdGhlIHRyaWdnZXJFbGVtZW50IGNoYW5nZXNcblx0XHQgKiAgIC0gdGhlIGNvbnRyb2xsZXIgY2hhbmdlcyAtPiBhZGRUbygpXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgdXBkYXRlU2Nyb2xsT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0X3Njcm9sbE9mZnNldCA9IHtcblx0XHRcdFx0c3RhcnQ6IF90cmlnZ2VyUG9zICsgX29wdGlvbnMub2Zmc2V0XG5cdFx0XHR9O1xuXHRcdFx0aWYgKF9jb250cm9sbGVyICYmIF9vcHRpb25zLnRyaWdnZXJFbGVtZW50KSB7XG5cdFx0XHRcdC8vIHRha2UgYXdheSB0cmlnZ2VySG9vayBwb3J0aW9uIHRvIGdldCByZWxhdGl2ZSB0byB0b3Bcblx0XHRcdFx0X3Njcm9sbE9mZnNldC5zdGFydCAtPSBfY29udHJvbGxlci5pbmZvKFwic2l6ZVwiKSAqIF9vcHRpb25zLnRyaWdnZXJIb29rO1xuXHRcdFx0fVxuXHRcdFx0X3Njcm9sbE9mZnNldC5lbmQgPSBfc2Nyb2xsT2Zmc2V0LnN0YXJ0ICsgX29wdGlvbnMuZHVyYXRpb247XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIGR1cmF0aW9uIGlmIHNldCB0byBhIGR5bmFtaWMgZnVuY3Rpb24uXG5cdFx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIGFkZGVkIHRvIGEgY29udHJvbGxlciBhbmQgaW4gcmVndWxhciBpbnRlcnZhbHMgZnJvbSB0aGUgY29udHJvbGxlciB0aHJvdWdoIHNjZW5lLnJlZnJlc2goKS5cblx0XHQgKiBcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmNoYW5nZX0sIGlmIHRoZSBkdXJhdGlvbiBjaGFuZ2VkXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5zaGlmdH0sIGlmIHRoZSBkdXJhdGlvbiBjaGFuZ2VkXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdXBwcmVzc0V2ZW50cz1mYWxzZV0gLSBJZiB0cnVlIHRoZSBzaGlmdCBldmVudCB3aWxsIGJlIHN1cHByZXNzZWQuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgdXBkYXRlRHVyYXRpb24gPSBmdW5jdGlvbiAoc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdC8vIHVwZGF0ZSBkdXJhdGlvblxuXHRcdFx0aWYgKF9kdXJhdGlvblVwZGF0ZU1ldGhvZCkge1xuXHRcdFx0XHR2YXIgdmFybmFtZSA9IFwiZHVyYXRpb25cIjtcblx0XHRcdFx0aWYgKGNoYW5nZU9wdGlvbih2YXJuYW1lLCBfZHVyYXRpb25VcGRhdGVNZXRob2QuY2FsbChTY2VuZSkpICYmICFzdXBwcmVzc0V2ZW50cykgeyAvLyBzZXRcblx0XHRcdFx0XHRTY2VuZS50cmlnZ2VyKFwiY2hhbmdlXCIsIHtcblx0XHRcdFx0XHRcdHdoYXQ6IHZhcm5hbWUsXG5cdFx0XHRcdFx0XHRuZXd2YWw6IF9vcHRpb25zW3Zhcm5hbWVdXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0U2NlbmUudHJpZ2dlcihcInNoaWZ0XCIsIHtcblx0XHRcdFx0XHRcdHJlYXNvbjogdmFybmFtZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0cmlnZ2VyRWxlbWVudCwgaWYgcHJlc2VudC5cblx0XHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgLi4uXG5cdFx0ICogIC0gLi4uIHdoZW4gdGhlIHRyaWdnZXJFbGVtZW50IGlzIGNoYW5nZWRcblx0XHQgKiAgLSAuLi4gd2hlbiB0aGUgc2NlbmUgaXMgYWRkZWQgdG8gYSAobmV3KSBjb250cm9sbGVyXG5cdFx0ICogIC0gLi4uIGluIHJlZ3VsYXIgaW50ZXJ2YWxzIGZyb20gdGhlIGNvbnRyb2xsZXIgdGhyb3VnaCBzY2VuZS5yZWZyZXNoKCkuXG5cdFx0ICogXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5zaGlmdH0sIGlmIHRoZSBwb3NpdGlvbiBjaGFuZ2VkXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdXBwcmVzc0V2ZW50cz1mYWxzZV0gLSBJZiB0cnVlIHRoZSBzaGlmdCBldmVudCB3aWxsIGJlIHN1cHByZXNzZWQuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgdXBkYXRlVHJpZ2dlckVsZW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0dmFyXG5cdFx0XHRlbGVtZW50UG9zID0gMCxcblx0XHRcdFx0dGVsZW0gPSBfb3B0aW9ucy50cmlnZ2VyRWxlbWVudDtcblx0XHRcdGlmIChfY29udHJvbGxlciAmJiB0ZWxlbSkge1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0Y29udHJvbGxlckluZm8gPSBfY29udHJvbGxlci5pbmZvKCksXG5cdFx0XHRcdFx0Y29udGFpbmVyT2Zmc2V0ID0gX3V0aWwuZ2V0Lm9mZnNldChjb250cm9sbGVySW5mby5jb250YWluZXIpLFxuXHRcdFx0XHRcdC8vIGNvbnRhaW5lciBwb3NpdGlvbiBpcyBuZWVkZWQgYmVjYXVzZSBlbGVtZW50IG9mZnNldCBpcyByZXR1cm5lZCBpbiByZWxhdGlvbiB0byBkb2N1bWVudCwgbm90IGluIHJlbGF0aW9uIHRvIGNvbnRhaW5lci5cblx0XHRcdFx0XHRwYXJhbSA9IGNvbnRyb2xsZXJJbmZvLnZlcnRpY2FsID8gXCJ0b3BcIiA6IFwibGVmdFwiOyAvLyB3aGljaCBwYXJhbSBpcyBvZiBpbnRlcmVzdCA/XG5cdFx0XHRcdC8vIGlmIHBhcmVudCBpcyBzcGFjZXIsIHVzZSBzcGFjZXIgcG9zaXRpb24gaW5zdGVhZCBzbyBjb3JyZWN0IHN0YXJ0IHBvc2l0aW9uIGlzIHJldHVybmVkIGZvciBwaW5uZWQgZWxlbWVudHMuXG5cdFx0XHRcdHdoaWxlICh0ZWxlbS5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShQSU5fU1BBQ0VSX0FUVFJJQlVURSkpIHtcblx0XHRcdFx0XHR0ZWxlbSA9IHRlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZWxlbWVudE9mZnNldCA9IF91dGlsLmdldC5vZmZzZXQodGVsZW0pO1xuXG5cdFx0XHRcdGlmICghY29udHJvbGxlckluZm8uaXNEb2N1bWVudCkgeyAvLyBjb250YWluZXIgaXMgbm90IHRoZSBkb2N1bWVudCByb290LCBzbyBzdWJzdHJhY3Qgc2Nyb2xsIFBvc2l0aW9uIHRvIGdldCBjb3JyZWN0IHRyaWdnZXIgZWxlbWVudCBwb3NpdGlvbiByZWxhdGl2ZSB0byBzY3JvbGxjb250ZW50XG5cdFx0XHRcdFx0Y29udGFpbmVyT2Zmc2V0W3BhcmFtXSAtPSBfY29udHJvbGxlci5zY3JvbGxQb3MoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW1lbnRQb3MgPSBlbGVtZW50T2Zmc2V0W3BhcmFtXSAtIGNvbnRhaW5lck9mZnNldFtwYXJhbV07XG5cdFx0XHR9XG5cdFx0XHR2YXIgY2hhbmdlZCA9IGVsZW1lbnRQb3MgIT0gX3RyaWdnZXJQb3M7XG5cdFx0XHRfdHJpZ2dlclBvcyA9IGVsZW1lbnRQb3M7XG5cdFx0XHRpZiAoY2hhbmdlZCAmJiAhc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0U2NlbmUudHJpZ2dlcihcInNoaWZ0XCIsIHtcblx0XHRcdFx0XHRyZWFzb246IFwidHJpZ2dlckVsZW1lbnRQb3NpdGlvblwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBUcmlnZ2VyIGEgc2hpZnQgZXZlbnQsIHdoZW4gdGhlIGNvbnRhaW5lciBpcyByZXNpemVkIGFuZCB0aGUgdHJpZ2dlckhvb2sgaXMgPiAxLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIG9uQ29udGFpbmVyUmVzaXplID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChfb3B0aW9ucy50cmlnZ2VySG9vayA+IDApIHtcblx0XHRcdFx0U2NlbmUudHJpZ2dlcihcInNoaWZ0XCIsIHtcblx0XHRcdFx0XHRyZWFzb246IFwiY29udGFpbmVyUmVzaXplXCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBfdmFsaWRhdGUgPSBfdXRpbC5leHRlbmQoU0NFTkVfT1BUSU9OUy52YWxpZGF0ZSwge1xuXHRcdFx0Ly8gdmFsaWRhdGlvbiBmb3IgZHVyYXRpb24gaGFuZGxlZCBpbnRlcm5hbGx5IGZvciByZWZlcmVuY2UgdG8gcHJpdmF0ZSB2YXIgX2R1cmF0aW9uTWV0aG9kXG5cdFx0XHRkdXJhdGlvbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHRpZiAoX3V0aWwudHlwZS5TdHJpbmcodmFsKSAmJiB2YWwubWF0Y2goL14oXFwufFxcZCkqXFxkKyUkLykpIHtcblx0XHRcdFx0XHQvLyBwZXJjZW50YWdlIHZhbHVlXG5cdFx0XHRcdFx0dmFyIHBlcmMgPSBwYXJzZUZsb2F0KHZhbCkgLyAxMDA7XG5cdFx0XHRcdFx0dmFsID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9jb250cm9sbGVyID8gX2NvbnRyb2xsZXIuaW5mbyhcInNpemVcIikgKiBwZXJjIDogMDtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfdXRpbC50eXBlLkZ1bmN0aW9uKHZhbCkpIHtcblx0XHRcdFx0XHQvLyBmdW5jdGlvblxuXHRcdFx0XHRcdF9kdXJhdGlvblVwZGF0ZU1ldGhvZCA9IHZhbDtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFsID0gcGFyc2VGbG9hdChfZHVyYXRpb25VcGRhdGVNZXRob2QoKSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0dmFsID0gLTE7IC8vIHdpbGwgY2F1c2UgZXJyb3IgYmVsb3dcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdmFsIGhhcyB0byBiZSBmbG9hdFxuXHRcdFx0XHR2YWwgPSBwYXJzZUZsb2F0KHZhbCk7XG5cdFx0XHRcdGlmICghX3V0aWwudHlwZS5OdW1iZXIodmFsKSB8fCB2YWwgPCAwKSB7XG5cdFx0XHRcdFx0aWYgKF9kdXJhdGlvblVwZGF0ZU1ldGhvZCkge1xuXHRcdFx0XHRcdFx0X2R1cmF0aW9uVXBkYXRlTWV0aG9kID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0dGhyb3cgW1wiSW52YWxpZCByZXR1cm4gdmFsdWUgb2Ygc3VwcGxpZWQgZnVuY3Rpb24gZm9yIG9wdGlvbiBcXFwiZHVyYXRpb25cXFwiOlwiLCB2YWxdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBbXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImR1cmF0aW9uXFxcIjpcIiwgdmFsXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyB0aGUgdmFsaWRpdHkgb2YgYSBzcGVjaWZpYyBvciBhbGwgb3B0aW9ucyBhbmQgcmVzZXQgdG8gZGVmYXVsdCBpZiBuZWNjZXNzYXJ5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHZhbGlkYXRlT3B0aW9uID0gZnVuY3Rpb24gKGNoZWNrKSB7XG5cdFx0XHRjaGVjayA9IGFyZ3VtZW50cy5sZW5ndGggPyBbY2hlY2tdIDogT2JqZWN0LmtleXMoX3ZhbGlkYXRlKTtcblx0XHRcdGNoZWNrLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbk5hbWUsIGtleSkge1xuXHRcdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRcdGlmIChfdmFsaWRhdGVbb3B0aW9uTmFtZV0pIHsgLy8gdGhlcmUgaXMgYSB2YWxpZGF0aW9uIG1ldGhvZCBmb3IgdGhpcyBvcHRpb25cblx0XHRcdFx0XHR0cnkgeyAvLyB2YWxpZGF0ZSB2YWx1ZVxuXHRcdFx0XHRcdFx0dmFsdWUgPSBfdmFsaWRhdGVbb3B0aW9uTmFtZV0oX29wdGlvbnNbb3B0aW9uTmFtZV0pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHsgLy8gdmFsaWRhdGlvbiBmYWlsZWQgLT4gcmVzZXQgdG8gZGVmYXVsdFxuXHRcdFx0XHRcdFx0dmFsdWUgPSBERUZBVUxUX09QVElPTlNbb3B0aW9uTmFtZV07XG5cdFx0XHRcdFx0XHR2YXIgbG9nTVNHID0gX3V0aWwudHlwZS5TdHJpbmcoZSkgPyBbZV0gOiBlO1xuXHRcdFx0XHRcdFx0aWYgKF91dGlsLnR5cGUuQXJyYXkobG9nTVNHKSkge1xuXHRcdFx0XHRcdFx0XHRsb2dNU0dbMF0gPSBcIkVSUk9SOiBcIiArIGxvZ01TR1swXTtcblx0XHRcdFx0XHRcdFx0bG9nTVNHLnVuc2hpZnQoMSk7IC8vIGxvZ2xldmVsIDEgZm9yIGVycm9yIG1zZ1xuXHRcdFx0XHRcdFx0XHRsb2cuYXBwbHkodGhpcywgbG9nTVNHKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxvZygxLCBcIkVSUk9SOiBQcm9ibGVtIGV4ZWN1dGluZyB2YWxpZGF0aW9uIGNhbGxiYWNrIGZvciBvcHRpb24gJ1wiICsgb3B0aW9uTmFtZSArIFwiJzpcIiwgZS5tZXNzYWdlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0X29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIZWxwZXIgdXNlZCBieSB0aGUgc2V0dGVyL2dldHRlcnMgZm9yIHNjZW5lIG9wdGlvbnNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciBjaGFuZ2VPcHRpb24gPSBmdW5jdGlvbiAodmFybmFtZSwgbmV3dmFsKSB7XG5cdFx0XHR2YXJcblx0XHRcdGNoYW5nZWQgPSBmYWxzZSxcblx0XHRcdFx0b2xkdmFsID0gX29wdGlvbnNbdmFybmFtZV07XG5cdFx0XHRpZiAoX29wdGlvbnNbdmFybmFtZV0gIT0gbmV3dmFsKSB7XG5cdFx0XHRcdF9vcHRpb25zW3Zhcm5hbWVdID0gbmV3dmFsO1xuXHRcdFx0XHR2YWxpZGF0ZU9wdGlvbih2YXJuYW1lKTsgLy8gcmVzZXRzIHRvIGRlZmF1bHQgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdGNoYW5nZWQgPSBvbGR2YWwgIT0gX29wdGlvbnNbdmFybmFtZV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0Ly8gZ2VuZXJhdGUgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgb3B0aW9uc1xuXHRcdHZhciBhZGRTY2VuZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25OYW1lKSB7XG5cdFx0XHRpZiAoIVNjZW5lW29wdGlvbk5hbWVdKSB7XG5cdFx0XHRcdFNjZW5lW29wdGlvbk5hbWVdID0gZnVuY3Rpb24gKG5ld1ZhbCkge1xuXHRcdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkgeyAvLyBnZXRcblx0XHRcdFx0XHRcdHJldHVybiBfb3B0aW9uc1tvcHRpb25OYW1lXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbk5hbWUgPT09IFwiZHVyYXRpb25cIikgeyAvLyBuZXcgZHVyYXRpb24gaXMgc2V0LCBzbyBhbnkgcHJldmlvdXNseSBzZXQgZnVuY3Rpb24gbXVzdCBiZSB1bnNldFxuXHRcdFx0XHRcdFx0XHRfZHVyYXRpb25VcGRhdGVNZXRob2QgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoY2hhbmdlT3B0aW9uKG9wdGlvbk5hbWUsIG5ld1ZhbCkpIHsgLy8gc2V0XG5cdFx0XHRcdFx0XHRcdFNjZW5lLnRyaWdnZXIoXCJjaGFuZ2VcIiwge1xuXHRcdFx0XHRcdFx0XHRcdHdoYXQ6IG9wdGlvbk5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0bmV3dmFsOiBfb3B0aW9uc1tvcHRpb25OYW1lXVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0aWYgKFNDRU5FX09QVElPTlMuc2hpZnRzLmluZGV4T2Yob3B0aW9uTmFtZSkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdFNjZW5lLnRyaWdnZXIoXCJzaGlmdFwiLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFzb246IG9wdGlvbk5hbWVcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0Kiogb3IgKipTZXQqKiB0aGUgZHVyYXRpb24gb3B0aW9uIHZhbHVlLlxuXHRcdCAqIEFzIGEgc2V0dGVyIGl0IGFsc28gYWNjZXB0cyBhIGZ1bmN0aW9uIHJldHVybmluZyBhIG51bWVyaWMgdmFsdWUuICBcblx0XHQgKiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHJlc3BvbnNpdmUgc2V0dXBzLlxuXHRcdCAqXG5cdFx0ICogVGhlIGR1cmF0aW9uIGlzIHVwZGF0ZWQgdXNpbmcgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUgYFNjZW5lLnJlZnJlc2goKWAgaXMgY2FsbGVkLCB3aGljaCBoYXBwZW5zIHBlcmlvZGljYWxseSBmcm9tIHRoZSBjb250cm9sbGVyIChzZWUgU2Nyb2xsTWFnaWMuQ29udHJvbGxlciBvcHRpb24gYHJlZnJlc2hJbnRlcnZhbGApLiAgXG5cdFx0ICogXyoqTk9URToqKiBCZSBhd2FyZSB0aGF0IGl0J3MgYW4gZWFzeSB3YXkgdG8ga2lsbCBwZXJmb3JtYW5jZSwgaWYgeW91IHN1cHBseSBhIGZ1bmN0aW9uIHRoYXQgaGFzIGhpZ2ggQ1BVIGRlbWFuZC4gIFxuXHRcdCAqIEV2ZW4gZm9yIHNpemUgYW5kIHBvc2l0aW9uIGNhbGN1bGF0aW9ucyBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYSB2YXJpYWJsZSB0byBjYWNoZSB0aGUgdmFsdWUuIChzZWUgZXhhbXBsZSkgIFxuXHRcdCAqIFRoaXMgY291bnRzIGRvdWJsZSBpZiB5b3UgdXNlIHRoZSBzYW1lIGZ1bmN0aW9uIGZvciBtdWx0aXBsZSBzY2VuZXMuX1xuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNkdXJhdGlvblxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IGR1cmF0aW9uIHZhbHVlXG5cdFx0ICogdmFyIGR1cmF0aW9uID0gc2NlbmUuZHVyYXRpb24oKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNldCBhIG5ldyBkdXJhdGlvblxuXHRcdCAqIHNjZW5lLmR1cmF0aW9uKDMwMCk7XG5cdFx0ICpcblx0XHQgKiAvLyB1c2UgYSBmdW5jdGlvbiB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB0aGUgZHVyYXRpb24gdG8gdGhlIHdpbmRvdyBoZWlnaHQuXG5cdFx0ICogdmFyIGR1cmF0aW9uVmFsdWVDYWNoZTtcblx0XHQgKiBmdW5jdGlvbiBnZXREdXJhdGlvbiAoKSB7XG5cdFx0ICogICByZXR1cm4gZHVyYXRpb25WYWx1ZUNhY2hlO1xuXHRcdCAqIH1cblx0XHQgKiBmdW5jdGlvbiB1cGRhdGVEdXJhdGlvbiAoZSkge1xuXHRcdCAqICAgZHVyYXRpb25WYWx1ZUNhY2hlID0gd2luZG93LmlubmVySGVpZ2h0O1xuXHRcdCAqIH1cblx0XHQgKiAkKHdpbmRvdykub24oXCJyZXNpemVcIiwgdXBkYXRlRHVyYXRpb24pOyAvLyB1cGRhdGUgdGhlIGR1cmF0aW9uIHdoZW4gdGhlIHdpbmRvdyBzaXplIGNoYW5nZXNcblx0XHQgKiAkKHdpbmRvdykudHJpZ2dlckhhbmRsZXIoXCJyZXNpemVcIik7IC8vIHNldCB0byBpbml0aWFsIHZhbHVlXG5cdFx0ICogc2NlbmUuZHVyYXRpb24oZ2V0RHVyYXRpb24pOyAvLyBzdXBwbHkgZHVyYXRpb24gbWV0aG9kXG5cdFx0ICpcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmNoYW5nZX0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLnNoaWZ0fSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBwYXJhbSB7KG51bWJlcnxmdW5jdGlvbil9IFtuZXdEdXJhdGlvbl0gLSBUaGUgbmV3IGR1cmF0aW9uIG9mIHRoZSBzY2VuZS5cblx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfSBgZ2V0YCAtICBDdXJyZW50IHNjZW5lIGR1cmF0aW9uLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gYHNldGAgLSAgUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIG9yICoqU2V0KiogdGhlIG9mZnNldCBvcHRpb24gdmFsdWUuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNvZmZzZXRcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCBvZmZzZXRcblx0XHQgKiB2YXIgb2Zmc2V0ID0gc2NlbmUub2Zmc2V0KCk7XG5cdFx0ICpcblx0XHQgKiAvLyBzZXQgYSBuZXcgb2Zmc2V0XG5cdFx0ICogc2NlbmUub2Zmc2V0KDEwMCk7XG5cdFx0ICpcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmNoYW5nZX0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLnNoaWZ0fSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3T2Zmc2V0XSAtIFRoZSBuZXcgb2Zmc2V0IG9mIHRoZSBzY2VuZS5cblx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfSBgZ2V0YCAtICBDdXJyZW50IHNjZW5lIG9mZnNldC5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IGBzZXRgIC0gIFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiBvciAqKlNldCoqIHRoZSB0cmlnZ2VyRWxlbWVudCBvcHRpb24gdmFsdWUuXG5cdFx0ICogRG9lcyAqKm5vdCoqIGZpcmUgYFNjZW5lLnNoaWZ0YCwgYmVjYXVzZSBjaGFuZ2luZyB0aGUgdHJpZ2dlciBFbGVtZW50IGRvZXNuJ3QgbmVjZXNzYXJpbHkgbWVhbiB0aGUgc3RhcnQgcG9zaXRpb24gY2hhbmdlcy4gVGhpcyB3aWxsIGJlIGRldGVybWluZWQgaW4gYFNjZW5lLnJlZnJlc2goKWAsIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgdHJpZ2dlcmVkLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjdHJpZ2dlckVsZW1lbnRcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIGdldCB0aGUgY3VycmVudCB0cmlnZ2VyRWxlbWVudFxuXHRcdCAqIHZhciB0cmlnZ2VyRWxlbWVudCA9IHNjZW5lLnRyaWdnZXJFbGVtZW50KCk7XG5cdFx0ICpcblx0XHQgKiAvLyBzZXQgYSBuZXcgdHJpZ2dlckVsZW1lbnQgdXNpbmcgYSBzZWxlY3RvclxuXHRcdCAqIHNjZW5lLnRyaWdnZXJFbGVtZW50KFwiI3RyaWdnZXJcIik7XG5cdFx0ICogLy8gc2V0IGEgbmV3IHRyaWdnZXJFbGVtZW50IHVzaW5nIGEgRE9NIG9iamVjdFxuXHRcdCAqIHNjZW5lLnRyaWdnZXJFbGVtZW50KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHJpZ2dlclwiKSk7XG5cdFx0ICpcblx0XHQgKiBAZmlyZXMge0BsaW5rIFNjZW5lLmNoYW5nZX0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gW25ld1RyaWdnZXJFbGVtZW50XSAtIFRoZSBuZXcgdHJpZ2dlciBlbGVtZW50IGZvciB0aGUgc2NlbmUuXG5cdFx0ICogQHJldHVybnMgeyhzdHJpbmd8b2JqZWN0KX0gYGdldGAgLSAgQ3VycmVudCB0cmlnZ2VyRWxlbWVudC5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IGBzZXRgIC0gIFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiBvciAqKlNldCoqIHRoZSB0cmlnZ2VySG9vayBvcHRpb24gdmFsdWUuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSN0cmlnZ2VySG9va1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IHRyaWdnZXJIb29rIHZhbHVlXG5cdFx0ICogdmFyIHRyaWdnZXJIb29rID0gc2NlbmUudHJpZ2dlckhvb2soKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNldCBhIG5ldyB0cmlnZ2VySG9vayB1c2luZyBhIHN0cmluZ1xuXHRcdCAqIHNjZW5lLnRyaWdnZXJIb29rKFwib25MZWF2ZVwiKTtcblx0XHQgKiAvLyBzZXQgYSBuZXcgdHJpZ2dlckhvb2sgdXNpbmcgYSBudW1iZXJcblx0XHQgKiBzY2VuZS50cmlnZ2VySG9vaygwLjcpO1xuXHRcdCAqXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5jaGFuZ2V9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5zaGlmdH0sIHdoZW4gdXNlZCBhcyBzZXR0ZXJcblx0XHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gW25ld1RyaWdnZXJIb29rXSAtIFRoZSBuZXcgdHJpZ2dlckhvb2sgb2YgdGhlIHNjZW5lLiBTZWUge0BsaW5rIFNjZW5lfSBwYXJhbWV0ZXIgZGVzY3JpcHRpb24gZm9yIHZhbHVlIG9wdGlvbnMuXG5cdFx0ICogQHJldHVybnMge251bWJlcn0gYGdldGAgLSAgQ3VycmVudCB0cmlnZ2VySG9vayAoQUxXQVlTIG51bWVyaWNhbCkuXG5cdFx0ICogQHJldHVybnMge1NjZW5lfSBgc2V0YCAtICBQYXJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqICoqR2V0Kiogb3IgKipTZXQqKiB0aGUgcmV2ZXJzZSBvcHRpb24gdmFsdWUuXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNyZXZlcnNlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgcmV2ZXJzZSBvcHRpb25cblx0XHQgKiB2YXIgcmV2ZXJzZSA9IHNjZW5lLnJldmVyc2UoKTtcblx0XHQgKlxuXHRcdCAqIC8vIHNldCBuZXcgcmV2ZXJzZSBvcHRpb25cblx0XHQgKiBzY2VuZS5yZXZlcnNlKGZhbHNlKTtcblx0XHQgKlxuXHRcdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuY2hhbmdlfSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW25ld1JldmVyc2VdIC0gVGhlIG5ldyByZXZlcnNlIHNldHRpbmcgb2YgdGhlIHNjZW5lLlxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufSBgZ2V0YCAtICBDdXJyZW50IHJldmVyc2Ugb3B0aW9uIHZhbHVlLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gYHNldGAgLSAgUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiAqKkdldCoqIG9yICoqU2V0KiogdGhlIGxvZ2xldmVsIG9wdGlvbiB2YWx1ZS5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI2xvZ2xldmVsXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgbG9nbGV2ZWxcblx0XHQgKiB2YXIgbG9nbGV2ZWwgPSBzY2VuZS5sb2dsZXZlbCgpO1xuXHRcdCAqXG5cdFx0ICogLy8gc2V0IG5ldyBsb2dsZXZlbFxuXHRcdCAqIHNjZW5lLmxvZ2xldmVsKDMpO1xuXHRcdCAqXG5cdFx0ICogQGZpcmVzIHtAbGluayBTY2VuZS5jaGFuZ2V9LCB3aGVuIHVzZWQgYXMgc2V0dGVyXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IFtuZXdMb2dsZXZlbF0gLSBUaGUgbmV3IGxvZ2xldmVsIHNldHRpbmcgb2YgdGhlIHNjZW5lLiBgWzAtM11gXG5cdFx0ICogQHJldHVybnMge251bWJlcn0gYGdldGAgLSAgQ3VycmVudCBsb2dsZXZlbC5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IGBzZXRgIC0gIFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiB0aGUgYXNzb2NpYXRlZCBjb250cm9sbGVyLlxuXHRcdCAqIEBtZXRob2QgU2Nyb2xsTWFnaWMuU2NlbmUjY29udHJvbGxlclxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjb250cm9sbGVyIG9mIGEgc2NlbmVcblx0XHQgKiB2YXIgY29udHJvbGxlciA9IHNjZW5lLmNvbnRyb2xsZXIoKTtcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtTY3JvbGxNYWdpYy5Db250cm9sbGVyfSBQYXJlbnQgY29udHJvbGxlciBvciBgdW5kZWZpbmVkYFxuXHRcdCAqL1xuXHRcdHRoaXMuY29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBfY29udHJvbGxlcjtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiB0aGUgY3VycmVudCBzdGF0ZS5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3N0YXRlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgc3RhdGVcblx0XHQgKiB2YXIgc3RhdGUgPSBzY2VuZS5zdGF0ZSgpO1xuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge3N0cmluZ30gYFwiQkVGT1JFXCJgLCBgXCJEVVJJTkdcImAgb3IgYFwiQUZURVJcImBcblx0XHQgKi9cblx0XHR0aGlzLnN0YXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIF9zdGF0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiB0aGUgY3VycmVudCBzY3JvbGwgb2Zmc2V0IGZvciB0aGUgc3RhcnQgb2YgdGhlIHNjZW5lLiAgXG5cdFx0ICogTWluZCwgdGhhdCB0aGUgc2Nyb2xsT2Zmc2V0IGlzIHJlbGF0ZWQgdG8gdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lciwgaWYgYHRyaWdnZXJIb29rYCBpcyBiaWdnZXIgdGhhbiBgMGAgKG9yIGBcIm9uTGVhdmVcImApLiAgXG5cdFx0ICogVGhpcyBtZWFucywgdGhhdCByZXNpemluZyB0aGUgY29udGFpbmVyIG9yIGNoYW5naW5nIHRoZSBgdHJpZ2dlckhvb2tgIHdpbGwgaW5mbHVlbmNlIHRoZSBzY2VuZSdzIHN0YXJ0IG9mZnNldC5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3Njcm9sbE9mZnNldFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBjdXJyZW50IHNjcm9sbCBvZmZzZXQgZm9yIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBzY2VuZS5cblx0XHQgKiB2YXIgc3RhcnQgPSBzY2VuZS5zY3JvbGxPZmZzZXQoKTtcblx0XHQgKiB2YXIgZW5kID0gc2NlbmUuc2Nyb2xsT2Zmc2V0KCkgKyBzY2VuZS5kdXJhdGlvbigpO1xuXHRcdCAqIGNvbnNvbGUubG9nKFwidGhlIHNjZW5lIHN0YXJ0cyBhdFwiLCBzdGFydCwgXCJhbmQgZW5kcyBhdFwiLCBlbmQpO1xuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHNjcm9sbCBvZmZzZXQgKG9mIHRoZSBjb250YWluZXIpIGF0IHdoaWNoIHRoZSBzY2VuZSB3aWxsIHRyaWdnZXIuIFkgdmFsdWUgZm9yIHZlcnRpY2FsIGFuZCBYIHZhbHVlIGZvciBob3Jpem9udGFsIHNjcm9sbHMuXG5cdFx0ICovXG5cdFx0dGhpcy5zY3JvbGxPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gX3Njcm9sbE9mZnNldC5zdGFydDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogKipHZXQqKiB0aGUgdHJpZ2dlciBwb3NpdGlvbiBvZiB0aGUgc2NlbmUgKGluY2x1ZGluZyB0aGUgdmFsdWUgb2YgdGhlIGBvZmZzZXRgIG9wdGlvbikuICBcblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3RyaWdnZXJQb3NpdGlvblxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gZ2V0IHRoZSBzY2VuZSdzIHRyaWdnZXIgcG9zaXRpb25cblx0XHQgKiB2YXIgdHJpZ2dlclBvc2l0aW9uID0gc2NlbmUudHJpZ2dlclBvc2l0aW9uKCk7XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfSBTdGFydCBwb3NpdGlvbiBvZiB0aGUgc2NlbmUuIFRvcCBwb3NpdGlvbiB2YWx1ZSBmb3IgdmVydGljYWwgYW5kIGxlZnQgcG9zaXRpb24gdmFsdWUgZm9yIGhvcml6b250YWwgc2Nyb2xscy5cblx0XHQgKi9cblx0XHR0aGlzLnRyaWdnZXJQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBwb3MgPSBfb3B0aW9ucy5vZmZzZXQ7IC8vIHRoZSBvZmZzZXQgaXMgdGhlIGJhc2lzXG5cdFx0XHRpZiAoX2NvbnRyb2xsZXIpIHtcblx0XHRcdFx0Ly8gZ2V0IHRoZSB0cmlnZ2VyIHBvc2l0aW9uXG5cdFx0XHRcdGlmIChfb3B0aW9ucy50cmlnZ2VyRWxlbWVudCkge1xuXHRcdFx0XHRcdC8vIEVsZW1lbnQgYXMgdHJpZ2dlclxuXHRcdFx0XHRcdHBvcyArPSBfdHJpZ2dlclBvcztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdHJpZ2dlckhvb2sgdG8gc3RhcnQgYXQgdGhlIGJlZ2lubmluZ1xuXHRcdFx0XHRcdHBvcyArPSBfY29udHJvbGxlci5pbmZvKFwic2l6ZVwiKSAqIFNjZW5lLnRyaWdnZXJIb29rKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBwb3M7XG5cdFx0fTtcblxuXHRcdHZhclxuXHRcdF9waW4sIF9waW5PcHRpb25zO1xuXG5cdFx0U2NlbmUub24oXCJzaGlmdC5pbnRlcm5hbFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGR1cmF0aW9uQ2hhbmdlZCA9IGUucmVhc29uID09PSBcImR1cmF0aW9uXCI7XG5cdFx0XHRpZiAoKF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfQUZURVIgJiYgZHVyYXRpb25DaGFuZ2VkKSB8fCAoX3N0YXRlID09PSBTQ0VORV9TVEFURV9EVVJJTkcgJiYgX29wdGlvbnMuZHVyYXRpb24gPT09IDApKSB7XG5cdFx0XHRcdC8vIGlmIFtkdXJhdGlvbiBjaGFuZ2VkIGFmdGVyIGEgc2NlbmUgKGluc2lkZSBzY2VuZSBwcm9ncmVzcyB1cGRhdGVzIHBpbiBwb3NpdGlvbildIG9yIFtkdXJhdGlvbiBpcyAwLCB3ZSBhcmUgaW4gcGluIHBoYXNlIGFuZCBzb21lIG90aGVyIHZhbHVlIGNoYW5nZWRdLlxuXHRcdFx0XHR1cGRhdGVQaW5TdGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGR1cmF0aW9uQ2hhbmdlZCkge1xuXHRcdFx0XHR1cGRhdGVQaW5EaW1lbnNpb25zKCk7XG5cdFx0XHR9XG5cdFx0fSkub24oXCJwcm9ncmVzcy5pbnRlcm5hbFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dXBkYXRlUGluU3RhdGUoKTtcblx0XHR9KS5vbihcImFkZC5pbnRlcm5hbFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dXBkYXRlUGluRGltZW5zaW9ucygpO1xuXHRcdH0pLm9uKFwiZGVzdHJveS5pbnRlcm5hbFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0U2NlbmUucmVtb3ZlUGluKGUucmVzZXQpO1xuXHRcdH0pO1xuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSB0aGUgcGluIHN0YXRlLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIHVwZGF0ZVBpblN0YXRlID0gZnVuY3Rpb24gKGZvcmNlVW5waW4pIHtcblx0XHRcdGlmIChfcGluICYmIF9jb250cm9sbGVyKSB7XG5cdFx0XHRcdHZhclxuXHRcdFx0XHRjb250YWluZXJJbmZvID0gX2NvbnRyb2xsZXIuaW5mbygpLFxuXHRcdFx0XHRcdHBpblRhcmdldCA9IF9waW5PcHRpb25zLnNwYWNlci5maXJzdENoaWxkOyAvLyBtYXkgYmUgcGluIGVsZW1lbnQgb3IgYW5vdGhlciBzcGFjZXIsIGlmIGNhc2NhZGluZyBwaW5zXG5cdFx0XHRcdGlmICghZm9yY2VVbnBpbiAmJiBfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0RVUklORykgeyAvLyBkdXJpbmcgc2NlbmUgb3IgaWYgZHVyYXRpb24gaXMgMCBhbmQgd2UgYXJlIHBhc3QgdGhlIHRyaWdnZXJcblx0XHRcdFx0XHQvLyBwaW5uZWQgc3RhdGVcblx0XHRcdFx0XHRpZiAoX3V0aWwuY3NzKHBpblRhcmdldCwgXCJwb3NpdGlvblwiKSAhPSBcImZpeGVkXCIpIHtcblx0XHRcdFx0XHRcdC8vIGNoYW5nZSBzdGF0ZSBiZWZvcmUgdXBkYXRpbmcgcGluIHNwYWNlciAocG9zaXRpb24gY2hhbmdlcyBkdWUgdG8gZml4ZWQgY29sbGFwc2luZyBtaWdodCBvY2N1ci4pXG5cdFx0XHRcdFx0XHRfdXRpbC5jc3MocGluVGFyZ2V0LCB7XG5cdFx0XHRcdFx0XHRcdFwicG9zaXRpb25cIjogXCJmaXhlZFwiXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdC8vIHVwZGF0ZSBwaW4gc3BhY2VyXG5cdFx0XHRcdFx0XHR1cGRhdGVQaW5EaW1lbnNpb25zKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0Zml4ZWRQb3MgPSBfdXRpbC5nZXQub2Zmc2V0KF9waW5PcHRpb25zLnNwYWNlciwgdHJ1ZSksXG5cdFx0XHRcdFx0XHQvLyBnZXQgdmlld3BvcnQgcG9zaXRpb24gb2Ygc3BhY2VyXG5cdFx0XHRcdFx0XHRzY3JvbGxEaXN0YW5jZSA9IF9vcHRpb25zLnJldmVyc2UgfHwgX29wdGlvbnMuZHVyYXRpb24gPT09IDAgPyBjb250YWluZXJJbmZvLnNjcm9sbFBvcyAtIF9zY3JvbGxPZmZzZXQuc3RhcnQgLy8gcXVpY2tlclxuXHRcdFx0XHRcdFx0OiBNYXRoLnJvdW5kKF9wcm9ncmVzcyAqIF9vcHRpb25zLmR1cmF0aW9uICogMTApIC8gMTA7IC8vIGlmIG5vIHJldmVyc2UgYW5kIGR1cmluZyBwaW4gdGhlIHBvc2l0aW9uIG5lZWRzIHRvIGJlIHJlY2FsY3VsYXRlZCB1c2luZyB0aGUgcHJvZ3Jlc3Ncblx0XHRcdFx0XHQvLyBhZGQgc2Nyb2xsRGlzdGFuY2Vcblx0XHRcdFx0XHRmaXhlZFBvc1tjb250YWluZXJJbmZvLnZlcnRpY2FsID8gXCJ0b3BcIiA6IFwibGVmdFwiXSArPSBzY3JvbGxEaXN0YW5jZTtcblxuXHRcdFx0XHRcdC8vIHNldCBuZXcgdmFsdWVzXG5cdFx0XHRcdFx0X3V0aWwuY3NzKF9waW5PcHRpb25zLnNwYWNlci5maXJzdENoaWxkLCB7XG5cdFx0XHRcdFx0XHR0b3A6IGZpeGVkUG9zLnRvcCxcblx0XHRcdFx0XHRcdGxlZnQ6IGZpeGVkUG9zLmxlZnRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bnBpbm5lZCBzdGF0ZVxuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdG5ld0NTUyA9IHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiBfcGluT3B0aW9ucy5pbkZsb3cgPyBcInJlbGF0aXZlXCIgOiBcImFic29sdXRlXCIsXG5cdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHRsZWZ0OiAwXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGNoYW5nZSA9IF91dGlsLmNzcyhwaW5UYXJnZXQsIFwicG9zaXRpb25cIikgIT0gbmV3Q1NTLnBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0aWYgKCFfcGluT3B0aW9ucy5wdXNoRm9sbG93ZXJzKSB7XG5cdFx0XHRcdFx0XHRuZXdDU1NbY29udGFpbmVySW5mby52ZXJ0aWNhbCA/IFwidG9wXCIgOiBcImxlZnRcIl0gPSBfb3B0aW9ucy5kdXJhdGlvbiAqIF9wcm9ncmVzcztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKF9vcHRpb25zLmR1cmF0aW9uID4gMCkgeyAvLyBvbmx5IGNvbmNlcm5zIHNjZW5lcyB3aXRoIGR1cmF0aW9uXG5cdFx0XHRcdFx0XHRpZiAoX3N0YXRlID09PSBTQ0VORV9TVEFURV9BRlRFUiAmJiBwYXJzZUZsb2F0KF91dGlsLmNzcyhfcGluT3B0aW9ucy5zcGFjZXIsIFwicGFkZGluZy10b3BcIikpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGNoYW5nZSA9IHRydWU7IC8vIGlmIGluIGFmdGVyIHN0YXRlIGJ1dCBoYXZlbnQgdXBkYXRlZCBzcGFjZXIgeWV0IChqdW1wZWQgcGFzdCBwaW4pXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfQkVGT1JFICYmIHBhcnNlRmxvYXQoX3V0aWwuY3NzKF9waW5PcHRpb25zLnNwYWNlciwgXCJwYWRkaW5nLWJvdHRvbVwiKSkgPT09IDApIHsgLy8gYmVmb3JlXG5cdFx0XHRcdFx0XHRcdGNoYW5nZSA9IHRydWU7IC8vIGp1bXBlZCBwYXN0IGZpeGVkIHN0YXRlIHVwd2FyZCBkaXJlY3Rpb25cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc2V0IG5ldyB2YWx1ZXNcblx0XHRcdFx0XHRfdXRpbC5jc3MocGluVGFyZ2V0LCBuZXdDU1MpO1xuXHRcdFx0XHRcdGlmIChjaGFuZ2UpIHtcblx0XHRcdFx0XHRcdC8vIHVwZGF0ZSBwaW4gc3BhY2VyIGlmIHN0YXRlIGNoYW5nZWRcblx0XHRcdFx0XHRcdHVwZGF0ZVBpbkRpbWVuc2lvbnMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBwaW4gc3BhY2VyIGFuZC9vciBlbGVtZW50IHNpemUuXG5cdFx0ICogVGhlIHNpemUgb2YgdGhlIHNwYWNlciBuZWVkcyB0byBiZSB1cGRhdGVkIHdoZW5ldmVyIHRoZSBkdXJhdGlvbiBvZiB0aGUgc2NlbmUgY2hhbmdlcywgaWYgaXQgaXMgdG8gcHVzaCBkb3duIGZvbGxvd2luZyBlbGVtZW50cy5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciB1cGRhdGVQaW5EaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKF9waW4gJiYgX2NvbnRyb2xsZXIgJiYgX3Bpbk9wdGlvbnMuaW5GbG93KSB7IC8vIG5vIHNwYWNlcnJlc2l6ZSwgaWYgb3JpZ2luYWwgcG9zaXRpb24gaXMgYWJzb2x1dGVcblx0XHRcdFx0dmFyXG5cdFx0XHRcdGFmdGVyID0gKF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfQUZURVIpLFxuXHRcdFx0XHRcdGJlZm9yZSA9IChfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0JFRk9SRSksXG5cdFx0XHRcdFx0ZHVyaW5nID0gKF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfRFVSSU5HKSxcblx0XHRcdFx0XHR2ZXJ0aWNhbCA9IF9jb250cm9sbGVyLmluZm8oXCJ2ZXJ0aWNhbFwiKSxcblx0XHRcdFx0XHRwaW5UYXJnZXQgPSBfcGluT3B0aW9ucy5zcGFjZXIuZmlyc3RDaGlsZCxcblx0XHRcdFx0XHQvLyB1c3VhbGx5IHRoZSBwaW5lZCBlbGVtZW50IGJ1dCBjYW4gYWxzbyBiZSBhbm90aGVyIHNwYWNlciAoY2FzY2FkZWQgcGlucylcblx0XHRcdFx0XHRtYXJnaW5Db2xsYXBzZSA9IF91dGlsLmlzTWFyZ2luQ29sbGFwc2VUeXBlKF91dGlsLmNzcyhfcGluT3B0aW9ucy5zcGFjZXIsIFwiZGlzcGxheVwiKSksXG5cdFx0XHRcdFx0Y3NzID0ge307XG5cblx0XHRcdFx0Ly8gc2V0IG5ldyBzaXplXG5cdFx0XHRcdC8vIGlmIHJlbHNpemU6IHNwYWNlciAtPiBwaW4gfCBlbHNlOiBwaW4gLT4gc3BhY2VyXG5cdFx0XHRcdGlmIChfcGluT3B0aW9ucy5yZWxTaXplLndpZHRoIHx8IF9waW5PcHRpb25zLnJlbFNpemUuYXV0b0Z1bGxXaWR0aCkge1xuXHRcdFx0XHRcdGlmIChkdXJpbmcpIHtcblx0XHRcdFx0XHRcdF91dGlsLmNzcyhfcGluLCB7XG5cdFx0XHRcdFx0XHRcdFwid2lkdGhcIjogX3V0aWwuZ2V0LndpZHRoKF9waW5PcHRpb25zLnNwYWNlcilcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfdXRpbC5jc3MoX3Bpbiwge1xuXHRcdFx0XHRcdFx0XHRcIndpZHRoXCI6IFwiMTAwJVwiXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbWlud2lkdGggaXMgbmVlZGVkIGZvciBjYXNjYWRlZCBwaW5zLlxuXHRcdFx0XHRcdGNzc1tcIm1pbi13aWR0aFwiXSA9IF91dGlsLmdldC53aWR0aCh2ZXJ0aWNhbCA/IF9waW4gOiBwaW5UYXJnZXQsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdGNzcy53aWR0aCA9IGR1cmluZyA/IGNzc1tcIm1pbi13aWR0aFwiXSA6IFwiYXV0b1wiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfcGluT3B0aW9ucy5yZWxTaXplLmhlaWdodCkge1xuXHRcdFx0XHRcdGlmIChkdXJpbmcpIHtcblx0XHRcdFx0XHRcdC8vIHRoZSBvbmx5IHBhZGRpbmcgdGhlIHNwYWNlciBzaG91bGQgZXZlciBpbmNsdWRlIGlzIHRoZSBkdXJhdGlvbiAoaWYgcHVzaEZvbGxvd2VycyA9IHRydWUpLCBzbyB3ZSBuZWVkIHRvIHN1YnN0cmFjdCB0aGF0LlxuXHRcdFx0XHRcdFx0X3V0aWwuY3NzKF9waW4sIHtcblx0XHRcdFx0XHRcdFx0XCJoZWlnaHRcIjogX3V0aWwuZ2V0LmhlaWdodChfcGluT3B0aW9ucy5zcGFjZXIpIC0gKF9waW5PcHRpb25zLnB1c2hGb2xsb3dlcnMgPyBfb3B0aW9ucy5kdXJhdGlvbiA6IDApXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0X3V0aWwuY3NzKF9waW4sIHtcblx0XHRcdFx0XHRcdFx0XCJoZWlnaHRcIjogXCIxMDAlXCJcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBtYXJnaW4gaXMgb25seSBpbmNsdWRlZCBpZiBpdCdzIGEgY2FzY2FkZWQgcGluIHRvIHJlc29sdmUgYW4gSUU5IGJ1Z1xuXHRcdFx0XHRcdGNzc1tcIm1pbi1oZWlnaHRcIl0gPSBfdXRpbC5nZXQuaGVpZ2h0KHZlcnRpY2FsID8gcGluVGFyZ2V0IDogX3BpbiwgdHJ1ZSwgIW1hcmdpbkNvbGxhcHNlKTsgLy8gbmVlZGVkIGZvciBjYXNjYWRpbmcgcGluc1xuXHRcdFx0XHRcdGNzcy5oZWlnaHQgPSBkdXJpbmcgPyBjc3NbXCJtaW4taGVpZ2h0XCJdIDogXCJhdXRvXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhZGQgc3BhY2UgZm9yIGR1cmF0aW9uIGlmIHB1c2hGb2xsb3dlcnMgaXMgdHJ1ZVxuXHRcdFx0XHRpZiAoX3Bpbk9wdGlvbnMucHVzaEZvbGxvd2Vycykge1xuXHRcdFx0XHRcdGNzc1tcInBhZGRpbmdcIiArICh2ZXJ0aWNhbCA/IFwiVG9wXCIgOiBcIkxlZnRcIildID0gX29wdGlvbnMuZHVyYXRpb24gKiBfcHJvZ3Jlc3M7XG5cdFx0XHRcdFx0Y3NzW1wicGFkZGluZ1wiICsgKHZlcnRpY2FsID8gXCJCb3R0b21cIiA6IFwiUmlnaHRcIildID0gX29wdGlvbnMuZHVyYXRpb24gKiAoMSAtIF9wcm9ncmVzcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3V0aWwuY3NzKF9waW5PcHRpb25zLnNwYWNlciwgY3NzKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgUGluIHN0YXRlIChpbiBjZXJ0YWluIHNjZW5hcmlvcylcblx0XHQgKiBJZiB0aGUgY29udHJvbGxlciBjb250YWluZXIgaXMgbm90IHRoZSBkb2N1bWVudCBhbmQgd2UgYXJlIG1pZC1waW4tcGhhc2Ugc2Nyb2xsaW5nIG9yIHJlc2l6aW5nIHRoZSBtYWluIGRvY3VtZW50IGNhbiByZXN1bHQgdG8gd3JvbmcgcGluIHBvc2l0aW9ucy5cblx0XHQgKiBTbyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiByZXNpemUgYW5kIHNjcm9sbCBvZiB0aGUgZG9jdW1lbnQuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgdXBkYXRlUGluSW5Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoX2NvbnRyb2xsZXIgJiYgX3BpbiAmJiBfc3RhdGUgPT09IFNDRU5FX1NUQVRFX0RVUklORyAmJiAhX2NvbnRyb2xsZXIuaW5mbyhcImlzRG9jdW1lbnRcIikpIHtcblx0XHRcdFx0dXBkYXRlUGluU3RhdGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgUGluIHNwYWNlciBzaXplIHN0YXRlIChpbiBjZXJ0YWluIHNjZW5hcmlvcylcblx0XHQgKiBJZiBjb250YWluZXIgaXMgcmVzaXplZCBkdXJpbmcgcGluIGFuZCByZWxhdGl2ZWx5IHNpemVkIHRoZSBzaXplIG9mIHRoZSBwaW4gbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkLi4uXG5cdFx0ICogU28gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gcmVzaXplIG9mIHRoZSBjb250YWluZXIuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR2YXIgdXBkYXRlUmVsYXRpdmVQaW5TcGFjZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoX2NvbnRyb2xsZXIgJiYgX3BpbiAmJiAvLyB3ZWxsLCBkdWhcblx0XHRcdF9zdGF0ZSA9PT0gU0NFTkVfU1RBVEVfRFVSSU5HICYmIC8vIGVsZW1lbnQgaW4gcGlubmVkIHN0YXRlP1xuXHRcdFx0KCAvLyBpcyB3aWR0aCBvciBoZWlnaHQgcmVsYXRpdmVseSBzaXplZCwgYnV0IG5vdCBpbiByZWxhdGlvbiB0byBib2R5PyB0aGVuIHdlIG5lZWQgdG8gcmVjYWxjLlxuXHRcdFx0KChfcGluT3B0aW9ucy5yZWxTaXplLndpZHRoIHx8IF9waW5PcHRpb25zLnJlbFNpemUuYXV0b0Z1bGxXaWR0aCkgJiYgX3V0aWwuZ2V0LndpZHRoKHdpbmRvdykgIT0gX3V0aWwuZ2V0LndpZHRoKF9waW5PcHRpb25zLnNwYWNlci5wYXJlbnROb2RlKSkgfHwgKF9waW5PcHRpb25zLnJlbFNpemUuaGVpZ2h0ICYmIF91dGlsLmdldC5oZWlnaHQod2luZG93KSAhPSBfdXRpbC5nZXQuaGVpZ2h0KF9waW5PcHRpb25zLnNwYWNlci5wYXJlbnROb2RlKSkpKSB7XG5cdFx0XHRcdHVwZGF0ZVBpbkRpbWVuc2lvbnMoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSXMgY2FsbGVkLCB3aGVuIHRoZSBtb3VzZXdoZWwgaXMgdXNlZCB3aGlsZSBvdmVyIGEgcGlubmVkIGVsZW1lbnQgaW5zaWRlIGEgZGl2IGNvbnRhaW5lci5cblx0XHQgKiBJZiB0aGUgc2NlbmUgaXMgaW4gZml4ZWQgc3RhdGUgc2Nyb2xsIGV2ZW50cyB3b3VsZCBiZSBjb3VudGVkIHRvd2FyZHMgdGhlIGJvZHkuIFRoaXMgZm9yd2FyZHMgdGhlIGV2ZW50IHRvIHRoZSBzY3JvbGwgY29udGFpbmVyLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dmFyIG9uTW91c2V3aGVlbE92ZXJQaW4gPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0aWYgKF9jb250cm9sbGVyICYmIF9waW4gJiYgX3N0YXRlID09PSBTQ0VORV9TVEFURV9EVVJJTkcgJiYgIV9jb250cm9sbGVyLmluZm8oXCJpc0RvY3VtZW50XCIpKSB7IC8vIGluIHBpbiBzdGF0ZVxuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdF9jb250cm9sbGVyLl9zZXRTY3JvbGxQb3MoX2NvbnRyb2xsZXIuaW5mbyhcInNjcm9sbFBvc1wiKSAtICgoZS53aGVlbERlbHRhIHx8IGVbX2NvbnRyb2xsZXIuaW5mbyhcInZlcnRpY2FsXCIpID8gXCJ3aGVlbERlbHRhWVwiIDogXCJ3aGVlbERlbHRhWFwiXSkgLyAzIHx8IC1lLmRldGFpbCAqIDMwKSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFBpbiBhbiBlbGVtZW50IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHR3ZWVuLiAgXG5cdFx0ICogSWYgdGhlIHNjZW5lIGR1cmF0aW9uIGlzIDAgdGhlIGVsZW1lbnQgd2lsbCBvbmx5IGJlIHVucGlubmVkLCBpZiB0aGUgdXNlciBzY3JvbGxzIGJhY2sgcGFzdCB0aGUgc3RhcnQgcG9zaXRpb24uICBcblx0XHQgKiBNYWtlIHN1cmUgb25seSBvbmUgcGluIGlzIGFwcGxpZWQgdG8gYW4gZWxlbWVudCBhdCB0aGUgc2FtZSB0aW1lLlxuXHRcdCAqIEFuIGVsZW1lbnQgY2FuIGJlIHBpbm5lZCBtdWx0aXBsZSB0aW1lcywgYnV0IG9ubHkgc3VjY2Vzc2l2ZWx5LlxuXHRcdCAqIF8qKk5PVEU6KiogVGhlIG9wdGlvbiBgcHVzaEZvbGxvd2Vyc2AgaGFzIG5vIGVmZmVjdCwgd2hlbiB0aGUgc2NlbmUgZHVyYXRpb24gaXMgMC5fXG5cdFx0ICogQG1ldGhvZCBTY3JvbGxNYWdpYy5TY2VuZSNzZXRQaW5cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIHBpbiBlbGVtZW50IGFuZCBwdXNoIGFsbCBmb2xsb3dpbmcgZWxlbWVudHMgZG93biBieSB0aGUgYW1vdW50IG9mIHRoZSBwaW4gZHVyYXRpb24uXG5cdFx0ICogc2NlbmUuc2V0UGluKFwiI3BpblwiKTtcblx0XHQgKlxuXHRcdCAqIC8vIHBpbiBlbGVtZW50IGFuZCBrZWVwaW5nIGFsbCBmb2xsb3dpbmcgZWxlbWVudHMgaW4gdGhlaXIgcGxhY2UuIFRoZSBwaW5uZWQgZWxlbWVudCB3aWxsIG1vdmUgcGFzdCB0aGVtLlxuXHRcdCAqIHNjZW5lLnNldFBpbihcIiNwaW5cIiwge3B1c2hGb2xsb3dlcnM6IGZhbHNlfSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gZWxlbWVudCAtIEEgU2VsZWN0b3IgdGFyZ2V0aW5nIGFuIGVsZW1lbnQgb3IgYSBET00gb2JqZWN0IHRoYXQgaXMgc3VwcG9zZWQgdG8gYmUgcGlubmVkLlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBbc2V0dGluZ3NdIC0gc2V0dGluZ3MgZm9yIHRoZSBwaW5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXR0aW5ncy5wdXNoRm9sbG93ZXJzPXRydWVdIC0gSWYgYHRydWVgIGZvbGxvd2luZyBlbGVtZW50cyB3aWxsIGJlIFwicHVzaGVkXCIgZG93biBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBwaW4sIGlmIGBmYWxzZWAgdGhlIHBpbm5lZCBlbGVtZW50IHdpbGwganVzdCBzY3JvbGwgcGFzdCB0aGVtLiAgXG5cdFx0IElnbm9yZWQsIHdoZW4gZHVyYXRpb24gaXMgYDBgLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbc2V0dGluZ3Muc3BhY2VyQ2xhc3M9XCJzY3JvbGxtYWdpYy1waW4tc3BhY2VyXCJdIC0gQ2xhc3NuYW1lIG9mIHRoZSBwaW4gc3BhY2VyIGVsZW1lbnQsIHdoaWNoIGlzIHVzZWQgdG8gcmVwbGFjZSB0aGUgZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5zZXRQaW4gPSBmdW5jdGlvbiAoZWxlbWVudCwgc2V0dGluZ3MpIHtcblx0XHRcdHZhclxuXHRcdFx0ZGVmYXVsdFNldHRpbmdzID0ge1xuXHRcdFx0XHRwdXNoRm9sbG93ZXJzOiB0cnVlLFxuXHRcdFx0XHRzcGFjZXJDbGFzczogXCJzY3JvbGxtYWdpYy1waW4tc3BhY2VyXCJcblx0XHRcdH07XG5cdFx0XHRzZXR0aW5ncyA9IF91dGlsLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCBzZXR0aW5ncyk7XG5cblx0XHRcdC8vIHZhbGlkYXRlIEVsZW1lbnRcblx0XHRcdGVsZW1lbnQgPSBfdXRpbC5nZXQuZWxlbWVudHMoZWxlbWVudClbMF07XG5cdFx0XHRpZiAoIWVsZW1lbnQpIHtcblx0XHRcdFx0bG9nKDEsIFwiRVJST1IgY2FsbGluZyBtZXRob2QgJ3NldFBpbigpJzogSW52YWxpZCBwaW4gZWxlbWVudCBzdXBwbGllZC5cIik7XG5cdFx0XHRcdHJldHVybiBTY2VuZTsgLy8gY2FuY2VsXG5cdFx0XHR9IGVsc2UgaWYgKF91dGlsLmNzcyhlbGVtZW50LCBcInBvc2l0aW9uXCIpID09PSBcImZpeGVkXCIpIHtcblx0XHRcdFx0bG9nKDEsIFwiRVJST1IgY2FsbGluZyBtZXRob2QgJ3NldFBpbigpJzogUGluIGRvZXMgbm90IHdvcmsgd2l0aCBlbGVtZW50cyB0aGF0IGFyZSBwb3NpdGlvbmVkICdmaXhlZCcuXCIpO1xuXHRcdFx0XHRyZXR1cm4gU2NlbmU7IC8vIGNhbmNlbFxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX3BpbikgeyAvLyBwcmVleGlzdGluZyBwaW4/XG5cdFx0XHRcdGlmIChfcGluID09PSBlbGVtZW50KSB7XG5cdFx0XHRcdFx0Ly8gc2FtZSBwaW4gd2UgYWxyZWFkeSBoYXZlIC0+IGRvIG5vdGhpbmdcblx0XHRcdFx0XHRyZXR1cm4gU2NlbmU7IC8vIGNhbmNlbFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGtpbGwgb2xkIHBpblxuXHRcdFx0XHRcdFNjZW5lLnJlbW92ZVBpbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHRcdF9waW4gPSBlbGVtZW50O1xuXG5cdFx0XHR2YXJcblx0XHRcdHBhcmVudERpc3BsYXkgPSBfcGluLnBhcmVudE5vZGUuc3R5bGUuZGlzcGxheSxcblx0XHRcdFx0Ym91bmRzUGFyYW1zID0gW1widG9wXCIsIFwibGVmdFwiLCBcImJvdHRvbVwiLCBcInJpZ2h0XCIsIFwibWFyZ2luXCIsIFwibWFyZ2luTGVmdFwiLCBcIm1hcmdpblJpZ2h0XCIsIFwibWFyZ2luVG9wXCIsIFwibWFyZ2luQm90dG9tXCJdO1xuXG5cdFx0XHRfcGluLnBhcmVudE5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gaGFjayBzdGFydCB0byBmb3JjZSBjc3MgdG8gcmV0dXJuIHN0eWxlc2hlZXQgdmFsdWVzIGluc3RlYWQgb2YgY2FsY3VsYXRlZCBweCB2YWx1ZXMuXG5cdFx0XHR2YXJcblx0XHRcdGluRmxvdyA9IF91dGlsLmNzcyhfcGluLCBcInBvc2l0aW9uXCIpICE9IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0cGluQ1NTID0gX3V0aWwuY3NzKF9waW4sIGJvdW5kc1BhcmFtcy5jb25jYXQoW1wiZGlzcGxheVwiXSkpLFxuXHRcdFx0XHRzaXplQ1NTID0gX3V0aWwuY3NzKF9waW4sIFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdKTtcblx0XHRcdF9waW4ucGFyZW50Tm9kZS5zdHlsZS5kaXNwbGF5ID0gcGFyZW50RGlzcGxheTsgLy8gaGFjayBlbmQuXG5cdFx0XHRpZiAoIWluRmxvdyAmJiBzZXR0aW5ncy5wdXNoRm9sbG93ZXJzKSB7XG5cdFx0XHRcdGxvZygyLCBcIldBUk5JTkc6IElmIHRoZSBwaW5uZWQgZWxlbWVudCBpcyBwb3NpdGlvbmVkIGFic29sdXRlbHkgcHVzaEZvbGxvd2VycyB3aWxsIGJlIGRpc2FibGVkLlwiKTtcblx0XHRcdFx0c2V0dGluZ3MucHVzaEZvbGxvd2VycyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyAvLyB3YWl0IHVudGlsIGFsbCBmaW5pc2hlZCwgYmVjYXVzZSB3aXRoIHJlc3BvbnNpdmUgZHVyYXRpb24gaXQgd2lsbCBvbmx5IGJlIHNldCBhZnRlciBzY2VuZSBpcyBhZGRlZCB0byBjb250cm9sbGVyXG5cdFx0XHRcdGlmIChfcGluICYmIF9vcHRpb25zLmR1cmF0aW9uID09PSAwICYmIHNldHRpbmdzLnB1c2hGb2xsb3dlcnMpIHtcblx0XHRcdFx0XHRsb2coMiwgXCJXQVJOSU5HOiBwdXNoRm9sbG93ZXJzID1cIiwgdHJ1ZSwgXCJoYXMgbm8gZWZmZWN0LCB3aGVuIHNjZW5lIGR1cmF0aW9uIGlzIDAuXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAwKTtcblxuXHRcdFx0Ly8gY3JlYXRlIHNwYWNlciBhbmQgaW5zZXJ0XG5cdFx0XHR2YXJcblx0XHRcdHNwYWNlciA9IF9waW4ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIF9waW4pLFxuXHRcdFx0XHRzcGFjZXJDU1MgPSBfdXRpbC5leHRlbmQocGluQ1NTLCB7XG5cdFx0XHRcdFx0cG9zaXRpb246IGluRmxvdyA/IFwicmVsYXRpdmVcIiA6IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0XHRib3hTaXppbmc6IFwiY29udGVudC1ib3hcIixcblx0XHRcdFx0XHRtb3pCb3hTaXppbmc6IFwiY29udGVudC1ib3hcIixcblx0XHRcdFx0XHR3ZWJraXRCb3hTaXppbmc6IFwiY29udGVudC1ib3hcIlxuXHRcdFx0XHR9KTtcblxuXHRcdFx0aWYgKCFpbkZsb3cpIHsgLy8gY29weSBzaXplIGlmIHBvc2l0aW9uZWQgYWJzb2x1dGVseSwgdG8gd29yayBmb3IgYm90dG9tL3JpZ2h0IHBvc2l0aW9uZWQgZWxlbWVudHMuXG5cdFx0XHRcdF91dGlsLmV4dGVuZChzcGFjZXJDU1MsIF91dGlsLmNzcyhfcGluLCBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRfdXRpbC5jc3Moc3BhY2VyLCBzcGFjZXJDU1MpO1xuXHRcdFx0c3BhY2VyLnNldEF0dHJpYnV0ZShQSU5fU1BBQ0VSX0FUVFJJQlVURSwgXCJcIik7XG5cdFx0XHRfdXRpbC5hZGRDbGFzcyhzcGFjZXIsIHNldHRpbmdzLnNwYWNlckNsYXNzKTtcblxuXHRcdFx0Ly8gc2V0IHRoZSBwaW4gT3B0aW9uc1xuXHRcdFx0X3Bpbk9wdGlvbnMgPSB7XG5cdFx0XHRcdHNwYWNlcjogc3BhY2VyLFxuXHRcdFx0XHRyZWxTaXplOiB7IC8vIHNhdmUgaWYgc2l6ZSBpcyBkZWZpbmVkIHVzaW5nICUgdmFsdWVzLiBpZiBzbywgaGFuZGxlIHNwYWNlciByZXNpemUgZGlmZmVyZW50bHkuLi5cblx0XHRcdFx0XHR3aWR0aDogc2l6ZUNTUy53aWR0aC5zbGljZSgtMSkgPT09IFwiJVwiLFxuXHRcdFx0XHRcdGhlaWdodDogc2l6ZUNTUy5oZWlnaHQuc2xpY2UoLTEpID09PSBcIiVcIixcblx0XHRcdFx0XHRhdXRvRnVsbFdpZHRoOiBzaXplQ1NTLndpZHRoID09PSBcImF1dG9cIiAmJiBpbkZsb3cgJiYgX3V0aWwuaXNNYXJnaW5Db2xsYXBzZVR5cGUocGluQ1NTLmRpc3BsYXkpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHB1c2hGb2xsb3dlcnM6IHNldHRpbmdzLnB1c2hGb2xsb3dlcnMsXG5cdFx0XHRcdGluRmxvdzogaW5GbG93LFxuXHRcdFx0XHQvLyBzdG9yZXMgaWYgdGhlIGVsZW1lbnQgdGFrZXMgdXAgc3BhY2UgaW4gdGhlIGRvY3VtZW50IGZsb3dcblx0XHRcdH07XG5cblx0XHRcdGlmICghX3Bpbi5fX19vcmlnU3R5bGUpIHtcblx0XHRcdFx0X3Bpbi5fX19vcmlnU3R5bGUgPSB7fTtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdHBpbklubGluZUNTUyA9IF9waW4uc3R5bGUsXG5cdFx0XHRcdFx0Y29weVN0eWxlcyA9IGJvdW5kc1BhcmFtcy5jb25jYXQoW1wid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJwb3NpdGlvblwiLCBcImJveFNpemluZ1wiLCBcIm1vekJveFNpemluZ1wiLCBcIndlYmtpdEJveFNpemluZ1wiXSk7XG5cdFx0XHRcdGNvcHlTdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdFx0X3Bpbi5fX19vcmlnU3R5bGVbdmFsXSA9IHBpbklubGluZUNTU1t2YWxdIHx8IFwiXCI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiByZWxhdGl2ZSBzaXplLCB0cmFuc2ZlciBpdCB0byBzcGFjZXIgYW5kIG1ha2UgcGluIGNhbGN1bGF0ZSBpdC4uLlxuXHRcdFx0aWYgKF9waW5PcHRpb25zLnJlbFNpemUud2lkdGgpIHtcblx0XHRcdFx0X3V0aWwuY3NzKHNwYWNlciwge1xuXHRcdFx0XHRcdHdpZHRoOiBzaXplQ1NTLndpZHRoXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9waW5PcHRpb25zLnJlbFNpemUuaGVpZ2h0KSB7XG5cdFx0XHRcdF91dGlsLmNzcyhzcGFjZXIsIHtcblx0XHRcdFx0XHRoZWlnaHQ6IHNpemVDU1MuaGVpZ2h0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBub3cgcGxhY2UgdGhlIHBpbiBlbGVtZW50IGluc2lkZSB0aGUgc3BhY2VyXHRcblx0XHRcdHNwYWNlci5hcHBlbmRDaGlsZChfcGluKTtcblx0XHRcdC8vIGFuZCBzZXQgbmV3IGNzc1xuXHRcdFx0X3V0aWwuY3NzKF9waW4sIHtcblx0XHRcdFx0cG9zaXRpb246IGluRmxvdyA/IFwicmVsYXRpdmVcIiA6IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0bWFyZ2luOiBcImF1dG9cIixcblx0XHRcdFx0dG9wOiBcImF1dG9cIixcblx0XHRcdFx0bGVmdDogXCJhdXRvXCIsXG5cdFx0XHRcdGJvdHRvbTogXCJhdXRvXCIsXG5cdFx0XHRcdHJpZ2h0OiBcImF1dG9cIlxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChfcGluT3B0aW9ucy5yZWxTaXplLndpZHRoIHx8IF9waW5PcHRpb25zLnJlbFNpemUuYXV0b0Z1bGxXaWR0aCkge1xuXHRcdFx0XHRfdXRpbC5jc3MoX3Bpbiwge1xuXHRcdFx0XHRcdGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0bW96Qm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHR3ZWJraXRCb3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgbGlzdGVuZXIgdG8gZG9jdW1lbnQgdG8gdXBkYXRlIHBpbiBwb3NpdGlvbiBpbiBjYXNlIGNvbnRyb2xsZXIgaXMgbm90IHRoZSBkb2N1bWVudC5cblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGVQaW5JbkNvbnRhaW5lcik7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlUGluSW5Db250YWluZXIpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZVJlbGF0aXZlUGluU3BhY2VyKTtcblx0XHRcdC8vIGFkZCBtb3VzZXdoZWVsIGxpc3RlbmVyIHRvIGNhdGNoIHNjcm9sbHMgb3ZlciBmaXhlZCBlbGVtZW50c1xuXHRcdFx0X3Bpbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLCBvbk1vdXNld2hlZWxPdmVyUGluKTtcblx0XHRcdF9waW4uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU1vdXNlU2Nyb2xsXCIsIG9uTW91c2V3aGVlbE92ZXJQaW4pO1xuXG5cdFx0XHRsb2coMywgXCJhZGRlZCBwaW5cIik7XG5cblx0XHRcdC8vIGZpbmFsbHkgdXBkYXRlIHRoZSBwaW4gdG8gaW5pdFxuXHRcdFx0dXBkYXRlUGluU3RhdGUoKTtcblxuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgdGhlIHBpbiBmcm9tIHRoZSBzY2VuZS5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3JlbW92ZVBpblxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gcmVtb3ZlIHRoZSBwaW4gZnJvbSB0aGUgc2NlbmUgd2l0aG91dCByZXNldHRpbmcgaXQgKHRoZSBzcGFjZXIgaXMgbm90IHJlbW92ZWQpXG5cdFx0ICogc2NlbmUucmVtb3ZlUGluKCk7XG5cdFx0ICpcblx0XHQgKiAvLyByZW1vdmUgdGhlIHBpbiBmcm9tIHRoZSBzY2VuZSBhbmQgcmVzZXQgdGhlIHBpbiBlbGVtZW50IHRvIGl0cyBpbml0aWFsIHBvc2l0aW9uIChzcGFjZXIgaXMgcmVtb3ZlZClcblx0XHQgKiBzY2VuZS5yZW1vdmVQaW4odHJ1ZSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD1mYWxzZV0gLSBJZiBgZmFsc2VgIHRoZSBzcGFjZXIgd2lsbCBub3QgYmUgcmVtb3ZlZCBhbmQgdGhlIGVsZW1lbnQncyBwb3NpdGlvbiB3aWxsIG5vdCBiZSByZXNldC5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMucmVtb3ZlUGluID0gZnVuY3Rpb24gKHJlc2V0KSB7XG5cdFx0XHRpZiAoX3Bpbikge1xuXHRcdFx0XHRpZiAoX3N0YXRlID09PSBTQ0VORV9TVEFURV9EVVJJTkcpIHtcblx0XHRcdFx0XHR1cGRhdGVQaW5TdGF0ZSh0cnVlKTsgLy8gZm9yY2UgdW5waW4gYXQgcG9zaXRpb25cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzZXQgfHwgIV9jb250cm9sbGVyKSB7IC8vIGlmIHRoZXJlJ3Mgbm8gY29udHJvbGxlciBubyBwcm9ncmVzcyB3YXMgbWFkZSBhbnl3YXkuLi5cblx0XHRcdFx0XHR2YXIgcGluVGFyZ2V0ID0gX3Bpbk9wdGlvbnMuc3BhY2VyLmZpcnN0Q2hpbGQ7IC8vIHVzdWFsbHkgdGhlIHBpbiBlbGVtZW50LCBidXQgbWF5IGJlIGFub3RoZXIgc3BhY2VyIChjYXNjYWRlZCBwaW5zKS4uLlxuXHRcdFx0XHRcdGlmIChwaW5UYXJnZXQuaGFzQXR0cmlidXRlKFBJTl9TUEFDRVJfQVRUUklCVVRFKSkgeyAvLyBjb3B5IG1hcmdpbnMgdG8gY2hpbGQgc3BhY2VyXG5cdFx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdHN0eWxlID0gX3Bpbk9wdGlvbnMuc3BhY2VyLnN0eWxlLFxuXHRcdFx0XHRcdFx0XHR2YWx1ZXMgPSBbXCJtYXJnaW5cIiwgXCJtYXJnaW5MZWZ0XCIsIFwibWFyZ2luUmlnaHRcIiwgXCJtYXJnaW5Ub3BcIiwgXCJtYXJnaW5Cb3R0b21cIl07XG5cdFx0XHRcdFx0XHRtYXJnaW5zID0ge307XG5cdFx0XHRcdFx0XHR2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdFx0XHRcdG1hcmdpbnNbdmFsXSA9IHN0eWxlW3ZhbF0gfHwgXCJcIjtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0X3V0aWwuY3NzKHBpblRhcmdldCwgbWFyZ2lucyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9waW5PcHRpb25zLnNwYWNlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwaW5UYXJnZXQsIF9waW5PcHRpb25zLnNwYWNlcik7XG5cdFx0XHRcdFx0X3Bpbk9wdGlvbnMuc3BhY2VyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX3Bpbk9wdGlvbnMuc3BhY2VyKTtcblx0XHRcdFx0XHRpZiAoIV9waW4ucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoUElOX1NQQUNFUl9BVFRSSUJVVEUpKSB7IC8vIGlmIGl0J3MgdGhlIGxhc3QgcGluIGZvciB0aGlzIGVsZW1lbnQgLT4gcmVzdG9yZSBpbmxpbmUgc3R5bGVzXG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBvbmx5IGNvcnJlY3RseSBzZXQgZm9yIGZpcnN0IHBpbiAod2hlbiBjYXNjYWRpbmcpIC0gaG93IHRvIGZpeD9cblx0XHRcdFx0XHRcdF91dGlsLmNzcyhfcGluLCBfcGluLl9fX29yaWdTdHlsZSk7XG5cdFx0XHRcdFx0XHRkZWxldGUgX3Bpbi5fX19vcmlnU3R5bGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGVQaW5JbkNvbnRhaW5lcik7XG5cdFx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVQaW5JbkNvbnRhaW5lcik7XG5cdFx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVSZWxhdGl2ZVBpblNwYWNlcik7XG5cdFx0XHRcdF9waW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNld2hlZWxcIiwgb25Nb3VzZXdoZWVsT3ZlclBpbik7XG5cdFx0XHRcdF9waW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTU1vdXNlU2Nyb2xsXCIsIG9uTW91c2V3aGVlbE92ZXJQaW4pO1xuXHRcdFx0XHRfcGluID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRsb2coMywgXCJyZW1vdmVkIHBpbiAocmVzZXQ6IFwiICsgKHJlc2V0ID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpICsgXCIpXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdH07XG5cblxuXHRcdHZhclxuXHRcdF9jc3NDbGFzc2VzLCBfY3NzQ2xhc3NFbGVtcyA9IFtdO1xuXG5cdFx0U2NlbmUub24oXCJkZXN0cm95LmludGVybmFsXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRTY2VuZS5yZW1vdmVDbGFzc1RvZ2dsZShlLnJlc2V0KTtcblx0XHR9KTtcblx0XHQvKipcblx0XHQgKiBEZWZpbmUgYSBjc3MgY2xhc3MgbW9kaWZpY2F0aW9uIHdoaWxlIHRoZSBzY2VuZSBpcyBhY3RpdmUuICBcblx0XHQgKiBXaGVuIHRoZSBzY2VuZSB0cmlnZ2VycyB0aGUgY2xhc3NlcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzdXBwbGllZCBlbGVtZW50IGFuZCByZW1vdmVkLCB3aGVuIHRoZSBzY2VuZSBpcyBvdmVyLlxuXHRcdCAqIElmIHRoZSBzY2VuZSBkdXJhdGlvbiBpcyAwIHRoZSBjbGFzc2VzIHdpbGwgb25seSBiZSByZW1vdmVkIGlmIHRoZSB1c2VyIHNjcm9sbHMgYmFjayBwYXN0IHRoZSBzdGFydCBwb3NpdGlvbi5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3NldENsYXNzVG9nZ2xlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyBhZGQgdGhlIGNsYXNzICdteWNsYXNzJyB0byB0aGUgZWxlbWVudCB3aXRoIHRoZSBpZCAnbXktZWxlbScgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgc2NlbmVcblx0XHQgKiBzY2VuZS5zZXRDbGFzc1RvZ2dsZShcIiNteS1lbGVtXCIsIFwibXljbGFzc1wiKTtcblx0XHQgKlxuXHRcdCAqIC8vIGFkZCBtdWx0aXBsZSBjbGFzc2VzIHRvIG11bHRpcGxlIGVsZW1lbnRzIGRlZmluZWQgYnkgdGhlIHNlbGVjdG9yICcuY2xhc3NDaGFuZ2UnXG5cdFx0ICogc2NlbmUuc2V0Q2xhc3NUb2dnbGUoXCIuY2xhc3NDaGFuZ2VcIiwgXCJjbGFzczEgY2xhc3MyIGNsYXNzM1wiKTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSBlbGVtZW50IC0gQSBTZWxlY3RvciB0YXJnZXRpbmcgb25lIG9yIG1vcmUgZWxlbWVudHMgb3IgYSBET00gb2JqZWN0IHRoYXQgaXMgc3VwcG9zZWQgdG8gYmUgbW9kaWZpZWQuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzZXMgLSBPbmUgb3IgbW9yZSBDbGFzc25hbWVzIChzZXBhcmF0ZWQgYnkgc3BhY2UpIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBlbGVtZW50IGR1cmluZyB0aGUgc2NlbmUuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdHRoaXMuc2V0Q2xhc3NUb2dnbGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3Nlcykge1xuXHRcdFx0dmFyIGVsZW1zID0gX3V0aWwuZ2V0LmVsZW1lbnRzKGVsZW1lbnQpO1xuXHRcdFx0aWYgKGVsZW1zLmxlbmd0aCA9PT0gMCB8fCAhX3V0aWwudHlwZS5TdHJpbmcoY2xhc3NlcykpIHtcblx0XHRcdFx0bG9nKDEsIFwiRVJST1IgY2FsbGluZyBtZXRob2QgJ3NldENsYXNzVG9nZ2xlKCknOiBJbnZhbGlkIFwiICsgKGVsZW1zLmxlbmd0aCA9PT0gMCA/IFwiZWxlbWVudFwiIDogXCJjbGFzc2VzXCIpICsgXCIgc3VwcGxpZWQuXCIpO1xuXHRcdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX2Nzc0NsYXNzRWxlbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyByZW1vdmUgb2xkIG9uZXNcblx0XHRcdFx0U2NlbmUucmVtb3ZlQ2xhc3NUb2dnbGUoKTtcblx0XHRcdH1cblx0XHRcdF9jc3NDbGFzc2VzID0gY2xhc3Nlcztcblx0XHRcdF9jc3NDbGFzc0VsZW1zID0gZWxlbXM7XG5cdFx0XHRTY2VuZS5vbihcImVudGVyLmludGVybmFsX2NsYXNzIGxlYXZlLmludGVybmFsX2NsYXNzXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHZhciB0b2dnbGUgPSBlLnR5cGUgPT09IFwiZW50ZXJcIiA/IF91dGlsLmFkZENsYXNzIDogX3V0aWwucmVtb3ZlQ2xhc3M7XG5cdFx0XHRcdF9jc3NDbGFzc0VsZW1zLmZvckVhY2goZnVuY3Rpb24gKGVsZW0sIGtleSkge1xuXHRcdFx0XHRcdHRvZ2dsZShlbGVtLCBfY3NzQ2xhc3Nlcyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSB0aGUgY2xhc3MgYmluZGluZyBmcm9tIHRoZSBzY2VuZS5cblx0XHQgKiBAbWV0aG9kIFNjcm9sbE1hZ2ljLlNjZW5lI3JlbW92ZUNsYXNzVG9nZ2xlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvLyByZW1vdmUgY2xhc3MgYmluZGluZyBmcm9tIHRoZSBzY2VuZSB3aXRob3V0IHJlc2V0XG5cdFx0ICogc2NlbmUucmVtb3ZlQ2xhc3NUb2dnbGUoKTtcblx0XHQgKlxuXHRcdCAqIC8vIHJlbW92ZSBjbGFzcyBiaW5kaW5nIGFuZCByZW1vdmUgdGhlIGNoYW5nZXMgaXQgY2F1c2VkXG5cdFx0ICogc2NlbmUucmVtb3ZlQ2xhc3NUb2dnbGUodHJ1ZSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD1mYWxzZV0gLSBJZiBgZmFsc2VgIGFuZCB0aGUgY2xhc3NlcyBhcmUgY3VycmVudGx5IGFjdGl2ZSwgdGhleSB3aWxsIHJlbWFpbiBvbiB0aGUgZWxlbWVudC4gSWYgYHRydWVgIHRoZXkgd2lsbCBiZSByZW1vdmVkLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0dGhpcy5yZW1vdmVDbGFzc1RvZ2dsZSA9IGZ1bmN0aW9uIChyZXNldCkge1xuXHRcdFx0aWYgKHJlc2V0KSB7XG5cdFx0XHRcdF9jc3NDbGFzc0VsZW1zLmZvckVhY2goZnVuY3Rpb24gKGVsZW0sIGtleSkge1xuXHRcdFx0XHRcdF91dGlsLnJlbW92ZUNsYXNzKGVsZW0sIF9jc3NDbGFzc2VzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRTY2VuZS5vZmYoXCJzdGFydC5pbnRlcm5hbF9jbGFzcyBlbmQuaW50ZXJuYWxfY2xhc3NcIik7XG5cdFx0XHRfY3NzQ2xhc3NlcyA9IHVuZGVmaW5lZDtcblx0XHRcdF9jc3NDbGFzc0VsZW1zID0gW107XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHRcdC8vIElOSVRcblx0XHRjb25zdHJ1Y3QoKTtcblx0XHRyZXR1cm4gU2NlbmU7XG5cdH07XG5cblx0Ly8gc3RvcmUgcGFnZXdpZGUgc2NlbmUgb3B0aW9uc1xuXHR2YXIgU0NFTkVfT1BUSU9OUyA9IHtcblx0XHRkZWZhdWx0czoge1xuXHRcdFx0ZHVyYXRpb246IDAsXG5cdFx0XHRvZmZzZXQ6IDAsXG5cdFx0XHR0cmlnZ2VyRWxlbWVudDogdW5kZWZpbmVkLFxuXHRcdFx0dHJpZ2dlckhvb2s6IDAuNSxcblx0XHRcdHJldmVyc2U6IHRydWUsXG5cdFx0XHRsb2dsZXZlbDogMlxuXHRcdH0sXG5cdFx0dmFsaWRhdGU6IHtcblx0XHRcdG9mZnNldDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHR2YWwgPSBwYXJzZUZsb2F0KHZhbCk7XG5cdFx0XHRcdGlmICghX3V0aWwudHlwZS5OdW1iZXIodmFsKSkge1xuXHRcdFx0XHRcdHRocm93IFtcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwib2Zmc2V0XFxcIjpcIiwgdmFsXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXJFbGVtZW50OiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdHZhbCA9IHZhbCB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdGlmICh2YWwpIHtcblx0XHRcdFx0XHR2YXIgZWxlbSA9IF91dGlsLmdldC5lbGVtZW50cyh2YWwpWzBdO1xuXHRcdFx0XHRcdGlmIChlbGVtKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBlbGVtO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBbXCJFbGVtZW50IGRlZmluZWQgaW4gb3B0aW9uIFxcXCJ0cmlnZ2VyRWxlbWVudFxcXCIgd2FzIG5vdCBmb3VuZDpcIiwgdmFsXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH0sXG5cdFx0XHR0cmlnZ2VySG9vazogZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHR2YXIgdHJhbnNsYXRlID0ge1xuXHRcdFx0XHRcdFwib25DZW50ZXJcIjogMC41LFxuXHRcdFx0XHRcdFwib25FbnRlclwiOiAxLFxuXHRcdFx0XHRcdFwib25MZWF2ZVwiOiAwXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChfdXRpbC50eXBlLk51bWJlcih2YWwpKSB7XG5cdFx0XHRcdFx0dmFsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFyc2VGbG9hdCh2YWwpLCAxKSk7IC8vICBtYWtlIHN1cmUgaXRzIGJldHdlZWVuIDAgYW5kIDFcblx0XHRcdFx0fSBlbHNlIGlmICh2YWwgaW4gdHJhbnNsYXRlKSB7XG5cdFx0XHRcdFx0dmFsID0gdHJhbnNsYXRlW3ZhbF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgW1wiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJ0cmlnZ2VySG9va1xcXCI6IFwiLCB2YWxdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9LFxuXHRcdFx0cmV2ZXJzZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHRyZXR1cm4gISF2YWw7IC8vIGZvcmNlIGJvb2xlYW5cblx0XHRcdH0sXG5cdFx0XHRsb2dsZXZlbDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHR2YWwgPSBwYXJzZUludCh2YWwpO1xuXHRcdFx0XHRpZiAoIV91dGlsLnR5cGUuTnVtYmVyKHZhbCkgfHwgdmFsIDwgMCB8fCB2YWwgPiAzKSB7XG5cdFx0XHRcdFx0dGhyb3cgW1wiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJsb2dsZXZlbFxcXCI6XCIsIHZhbF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8vIGhvbGRlciBmb3IgIHZhbGlkYXRpb24gbWV0aG9kcy4gZHVyYXRpb24gdmFsaWRhdGlvbiBpcyBoYW5kbGVkIGluICdnZXR0ZXJzLXNldHRlcnMuanMnXG5cdFx0c2hpZnRzOiBbXCJkdXJhdGlvblwiLCBcIm9mZnNldFwiLCBcInRyaWdnZXJIb29rXCJdLFxuXHRcdC8vIGxpc3Qgb2Ygb3B0aW9ucyB0aGF0IHRyaWdnZXIgYSBgc2hpZnRgIGV2ZW50XG5cdH07XG4vKlxuICogbWV0aG9kIHVzZWQgdG8gYWRkIGFuIG9wdGlvbiB0byBTY3JvbGxNYWdpYyBTY2VuZXMuXG4gKiBUT0RPOiBET0MgKHByaXZhdGUgZm9yIGRldilcbiAqL1xuXHRTY3JvbGxNYWdpYy5TY2VuZS5hZGRPcHRpb24gPSBmdW5jdGlvbiAobmFtZSwgZGVmYXVsdFZhbHVlLCB2YWxpZGF0aW9uQ2FsbGJhY2ssIHNoaWZ0cykge1xuXHRcdGlmICghKG5hbWUgaW4gU0NFTkVfT1BUSU9OUy5kZWZhdWx0cykpIHtcblx0XHRcdFNDRU5FX09QVElPTlMuZGVmYXVsdHNbbmFtZV0gPSBkZWZhdWx0VmFsdWU7XG5cdFx0XHRTQ0VORV9PUFRJT05TLnZhbGlkYXRlW25hbWVdID0gdmFsaWRhdGlvbkNhbGxiYWNrO1xuXHRcdFx0aWYgKHNoaWZ0cykge1xuXHRcdFx0XHRTQ0VORV9PUFRJT05TLnNoaWZ0cy5wdXNoKG5hbWUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRTY3JvbGxNYWdpYy5fdXRpbC5sb2coMSwgXCJbc3RhdGljXSBTY3JvbGxNYWdpYy5TY2VuZSAtPiBDYW5ub3QgYWRkIFNjZW5lIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInLCBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlwiKTtcblx0XHR9XG5cdH07XG5cdC8vIGluc3RhbmNlIGV4dGVuc2lvbiBmdW5jdGlvbiBmb3IgcGx1Z2luc1xuXHQvLyBUT0RPOiBET0MgKHByaXZhdGUgZm9yIGRldilcblx0U2Nyb2xsTWFnaWMuU2NlbmUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuXHRcdHZhciBvbGRDbGFzcyA9IHRoaXM7XG5cdFx0U2Nyb2xsTWFnaWMuU2NlbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRvbGRDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy4kc3VwZXIgPSBfdXRpbC5leHRlbmQoe30sIHRoaXMpOyAvLyBjb3B5IHBhcmVudCBzdGF0ZVxuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdFx0fTtcblx0XHRfdXRpbC5leHRlbmQoU2Nyb2xsTWFnaWMuU2NlbmUsIG9sZENsYXNzKTsgLy8gY29weSBwcm9wZXJ0aWVzXG5cdFx0U2Nyb2xsTWFnaWMuU2NlbmUucHJvdG90eXBlID0gb2xkQ2xhc3MucHJvdG90eXBlOyAvLyBjb3B5IHByb3RvdHlwZVxuXHRcdFNjcm9sbE1hZ2ljLlNjZW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjcm9sbE1hZ2ljLlNjZW5lOyAvLyByZXN0b3JlIGNvbnN0cnVjdG9yXG5cdH07XG5cblxuXHQvKipcblx0ICogVE9ETzogRE9DUyAocHJpdmF0ZSBmb3IgZGV2KVxuXHQgKiBAY2xhc3Ncblx0ICogQHByaXZhdGVcblx0ICovXG5cblx0U2Nyb2xsTWFnaWMuRXZlbnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZXNwYWNlLCB0YXJnZXQsIHZhcnMpIHtcblx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRmb3IgKHZhciBrZXkgaW4gdmFycykge1xuXHRcdFx0dGhpc1trZXldID0gdmFyc1trZXldO1xuXHRcdH1cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMudGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlIHx8ICcnO1xuXHRcdHRoaXMudGltZVN0YW1wID0gdGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG4vKlxuICogVE9ETzogRE9DUyAocHJpdmF0ZSBmb3IgZGV2KVxuICovXG5cblx0dmFyIF91dGlsID0gU2Nyb2xsTWFnaWMuX3V0aWwgPSAoZnVuY3Rpb24gKHdpbmRvdykge1xuXHRcdHZhciBVID0ge30sXG5cdFx0XHRpO1xuXG5cdFx0LyoqXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICogaW50ZXJuYWwgaGVscGVyc1xuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqL1xuXG5cdFx0Ly8gcGFyc2UgZmxvYXQgYW5kIGZhbGwgYmFjayB0byAwLlxuXHRcdHZhciBmbG9hdHZhbCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcblx0XHRcdHJldHVybiBwYXJzZUZsb2F0KG51bWJlcikgfHwgMDtcblx0XHR9O1xuXHRcdC8vIGdldCBjdXJyZW50IHN0eWxlIElFIHNhZmUgKG90aGVyd2lzZSBJRSB3b3VsZCByZXR1cm4gY2FsY3VsYXRlZCB2YWx1ZXMgZm9yICdhdXRvJylcblx0XHR2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlbSkge1xuXHRcdFx0cmV0dXJuIGVsZW0uY3VycmVudFN0eWxlID8gZWxlbS5jdXJyZW50U3R5bGUgOiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcblx0XHR9O1xuXG5cdFx0Ly8gZ2V0IGVsZW1lbnQgZGltZW5zaW9uICh3aWR0aCBvciBoZWlnaHQpXG5cdFx0dmFyIF9kaW1lbnNpb24gPSBmdW5jdGlvbiAod2hpY2gsIGVsZW0sIG91dGVyLCBpbmNsdWRlTWFyZ2luKSB7XG5cdFx0XHRlbGVtID0gKGVsZW0gPT09IGRvY3VtZW50KSA/IHdpbmRvdyA6IGVsZW07XG5cdFx0XHRpZiAoZWxlbSA9PT0gd2luZG93KSB7XG5cdFx0XHRcdGluY2x1ZGVNYXJnaW4gPSBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIV90eXBlLkRvbUVsZW1lbnQoZWxlbSkpIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHR3aGljaCA9IHdoaWNoLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd2hpY2guc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgZGltZW5zaW9uID0gKG91dGVyID8gZWxlbVsnb2Zmc2V0JyArIHdoaWNoXSB8fCBlbGVtWydvdXRlcicgKyB3aGljaF0gOiBlbGVtWydjbGllbnQnICsgd2hpY2hdIHx8IGVsZW1bJ2lubmVyJyArIHdoaWNoXSkgfHwgMDtcblx0XHRcdGlmIChvdXRlciAmJiBpbmNsdWRlTWFyZ2luKSB7XG5cdFx0XHRcdHZhciBzdHlsZSA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuXHRcdFx0XHRkaW1lbnNpb24gKz0gd2hpY2ggPT09ICdIZWlnaHQnID8gZmxvYXR2YWwoc3R5bGUubWFyZ2luVG9wKSArIGZsb2F0dmFsKHN0eWxlLm1hcmdpbkJvdHRvbSkgOiBmbG9hdHZhbChzdHlsZS5tYXJnaW5MZWZ0KSArIGZsb2F0dmFsKHN0eWxlLm1hcmdpblJpZ2h0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkaW1lbnNpb247XG5cdFx0fTtcblx0XHQvLyBjb252ZXJ0cyAnbWFyZ2luLXRvcCcgaW50byAnbWFyZ2luVG9wJ1xuXHRcdHZhciBfY2FtZWxDYXNlID0gZnVuY3Rpb24gKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eW15hLXpdKyhbYS16XSkvZywgJyQxJykucmVwbGFjZSgvLShbYS16XSkvZywgZnVuY3Rpb24gKGcpIHtcblx0XHRcdFx0cmV0dXJuIGdbMV0udG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKiBleHRlcm5hbCBoZWxwZXJzXG5cdFx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0ICovXG5cblx0XHQvLyBleHRlbmQgb2JqIOKAkyBzYW1lIGFzIGpRdWVyeS5leHRlbmQoe30sIG9iakEsIG9iakIpXG5cdFx0VS5leHRlbmQgPSBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSBvYmogfHwge307XG5cdFx0XHRmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzW2ldKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1tpXSkge1xuXHRcdFx0XHRcdGlmIChhcmd1bWVudHNbaV0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0b2JqW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fTtcblxuXHRcdC8vIGNoZWNrIGlmIGEgY3NzIGRpc3BsYXkgdHlwZSByZXN1bHRzIGluIG1hcmdpbi1jb2xsYXBzZSBvciBub3Rcblx0XHRVLmlzTWFyZ2luQ29sbGFwc2VUeXBlID0gZnVuY3Rpb24gKHN0cikge1xuXHRcdFx0cmV0dXJuIFtcImJsb2NrXCIsIFwiZmxleFwiLCBcImxpc3QtaXRlbVwiLCBcInRhYmxlXCIsIFwiLXdlYmtpdC1ib3hcIl0uaW5kZXhPZihzdHIpID4gLTE7XG5cdFx0fTtcblxuXHRcdC8vIGltcGxlbWVudGF0aW9uIG9mIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuXHRcdC8vIGJhc2VkIG9uIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG5cdFx0dmFyXG5cdFx0bGFzdFRpbWUgPSAwLFxuXHRcdFx0dmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XG5cdFx0dmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdHZhciBfY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cdFx0Ly8gdHJ5IHZlbmRvciBwcmVmaXhlcyBpZiB0aGUgYWJvdmUgZG9lc24ndCB3b3JrXG5cdFx0Zm9yIChpID0gMDsgIV9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgaSA8IHZlbmRvcnMubGVuZ3RoOyArK2kpIHtcblx0XHRcdF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1tpXSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcblx0XHRcdF9jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW2ldICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgd2luZG93W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG5cdFx0fVxuXG5cdFx0Ly8gZmFsbGJhY2tzXG5cdFx0aWYgKCFfcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHRfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhclxuXHRcdFx0XHRjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuXHRcdFx0XHRcdHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSksXG5cdFx0XHRcdFx0aWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuXHRcdFx0XHRcdH0sIHRpbWVUb0NhbGwpO1xuXHRcdFx0XHRsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcblx0XHRcdFx0cmV0dXJuIGlkO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0aWYgKCFfY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcblx0XHRcdF9jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdFUuckFGID0gX3JlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyk7XG5cdFx0VS5jQUYgPSBfY2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpO1xuXG5cdFx0dmFyXG5cdFx0bG9nbGV2ZWxzID0gW1wiZXJyb3JcIiwgXCJ3YXJuXCIsIFwibG9nXCJdLFxuXHRcdFx0Y29uc29sZSA9IHdpbmRvdy5jb25zb2xlIHx8IHt9O1xuXG5cdFx0Y29uc29sZS5sb2cgPSBjb25zb2xlLmxvZyB8fFxuXHRcdGZ1bmN0aW9uICgpIHt9OyAvLyBubyBjb25zb2xlIGxvZywgd2VsbCAtIGRvIG5vdGhpbmcgdGhlbi4uLlxuXHRcdC8vIG1ha2Ugc3VyZSBtZXRob2RzIGZvciBhbGwgbGV2ZWxzIGV4aXN0LlxuXHRcdGZvciAoaSA9IDA7IGkgPCBsb2dsZXZlbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBtZXRob2QgPSBsb2dsZXZlbHNbaV07XG5cdFx0XHRpZiAoIWNvbnNvbGVbbWV0aG9kXSkge1xuXHRcdFx0XHRjb25zb2xlW21ldGhvZF0gPSBjb25zb2xlLmxvZzsgLy8gcHJlZmVyIC5sb2cgb3ZlciBub3RoaW5nXG5cdFx0XHR9XG5cdFx0fVxuXHRcdFUubG9nID0gZnVuY3Rpb24gKGxvZ2xldmVsKSB7XG5cdFx0XHRpZiAobG9nbGV2ZWwgPiBsb2dsZXZlbHMubGVuZ3RoIHx8IGxvZ2xldmVsIDw9IDApIGxvZ2xldmVsID0gbG9nbGV2ZWxzLmxlbmd0aDtcblx0XHRcdHZhciBub3cgPSBuZXcgRGF0ZSgpLFxuXHRcdFx0XHR0aW1lID0gKFwiMFwiICsgbm93LmdldEhvdXJzKCkpLnNsaWNlKC0yKSArIFwiOlwiICsgKFwiMFwiICsgbm93LmdldE1pbnV0ZXMoKSkuc2xpY2UoLTIpICsgXCI6XCIgKyAoXCIwXCIgKyBub3cuZ2V0U2Vjb25kcygpKS5zbGljZSgtMikgKyBcIjpcIiArIChcIjAwXCIgKyBub3cuZ2V0TWlsbGlzZWNvbmRzKCkpLnNsaWNlKC0zKSxcblx0XHRcdFx0bWV0aG9kID0gbG9nbGV2ZWxzW2xvZ2xldmVsIC0gMV0sXG5cdFx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcblx0XHRcdFx0ZnVuYyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZVttZXRob2RdLCBjb25zb2xlKTtcblx0XHRcdGFyZ3MudW5zaGlmdCh0aW1lKTtcblx0XHRcdGZ1bmMuYXBwbHkoY29uc29sZSwgYXJncyk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqIHR5cGUgdGVzdGluZ1xuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqL1xuXG5cdFx0dmFyIF90eXBlID0gVS50eXBlID0gZnVuY3Rpb24gKHYpIHtcblx0XHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikucmVwbGFjZSgvXlxcW29iamVjdCAoLispXFxdJC8sIFwiJDFcIikudG9Mb3dlckNhc2UoKTtcblx0XHR9O1xuXHRcdF90eXBlLlN0cmluZyA9IGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRyZXR1cm4gX3R5cGUodikgPT09ICdzdHJpbmcnO1xuXHRcdH07XG5cdFx0X3R5cGUuRnVuY3Rpb24gPSBmdW5jdGlvbiAodikge1xuXHRcdFx0cmV0dXJuIF90eXBlKHYpID09PSAnZnVuY3Rpb24nO1xuXHRcdH07XG5cdFx0X3R5cGUuQXJyYXkgPSBmdW5jdGlvbiAodikge1xuXHRcdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkodik7XG5cdFx0fTtcblx0XHRfdHlwZS5OdW1iZXIgPSBmdW5jdGlvbiAodikge1xuXHRcdFx0cmV0dXJuICFfdHlwZS5BcnJheSh2KSAmJiAodiAtIHBhcnNlRmxvYXQodikgKyAxKSA+PSAwO1xuXHRcdH07XG5cdFx0X3R5cGUuRG9tRWxlbWVudCA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0dHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogLy9ET00yXG5cdFx0XHRvICYmIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmIG8gIT09IG51bGwgJiYgby5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIik7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdCAqIERPTSBFbGVtZW50IGluZm9cblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKi9cblx0XHQvLyBhbHdheXMgcmV0dXJucyBhIGxpc3Qgb2YgbWF0Y2hpbmcgRE9NIGVsZW1lbnRzLCBmcm9tIGEgc2VsZWN0b3IsIGEgRE9NIGVsZW1lbnQgb3IgYW4gbGlzdCBvZiBlbGVtZW50cyBvciBldmVuIGFuIGFycmF5IG9mIHNlbGVjdG9yc1xuXHRcdHZhciBfZ2V0ID0gVS5nZXQgPSB7fTtcblx0XHRfZ2V0LmVsZW1lbnRzID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdFx0XHR2YXIgYXJyID0gW107XG5cdFx0XHRpZiAoX3R5cGUuU3RyaW5nKHNlbGVjdG9yKSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHsgLy8gaW52YWxpZCBzZWxlY3RvclxuXHRcdFx0XHRcdHJldHVybiBhcnI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChfdHlwZShzZWxlY3RvcikgPT09ICdub2RlbGlzdCcgfHwgX3R5cGUuQXJyYXkoc2VsZWN0b3IpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCByZWYgPSBhcnIubGVuZ3RoID0gc2VsZWN0b3IubGVuZ3RoOyBpIDwgcmVmOyBpKyspIHsgLy8gbGlzdCBvZiBlbGVtZW50c1xuXHRcdFx0XHRcdHZhciBlbGVtID0gc2VsZWN0b3JbaV07XG5cdFx0XHRcdFx0YXJyW2ldID0gX3R5cGUuRG9tRWxlbWVudChlbGVtKSA/IGVsZW0gOiBfZ2V0LmVsZW1lbnRzKGVsZW0pOyAvLyBpZiBub3QgYW4gZWxlbWVudCwgdHJ5IHRvIHJlc29sdmUgcmVjdXJzaXZlbHlcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChfdHlwZS5Eb21FbGVtZW50KHNlbGVjdG9yKSB8fCBzZWxlY3RvciA9PT0gZG9jdW1lbnQgfHwgc2VsZWN0b3IgPT09IHdpbmRvdykge1xuXHRcdFx0XHRhcnIgPSBbc2VsZWN0b3JdOyAvLyBvbmx5IHRoZSBlbGVtZW50XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXJyO1xuXHRcdH07XG5cdFx0Ly8gZ2V0IHNjcm9sbCB0b3AgdmFsdWVcblx0XHRfZ2V0LnNjcm9sbFRvcCA9IGZ1bmN0aW9uIChlbGVtKSB7XG5cdFx0XHRyZXR1cm4gKGVsZW0gJiYgdHlwZW9mIGVsZW0uc2Nyb2xsVG9wID09PSAnbnVtYmVyJykgPyBlbGVtLnNjcm9sbFRvcCA6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCAwO1xuXHRcdH07XG5cdFx0Ly8gZ2V0IHNjcm9sbCBsZWZ0IHZhbHVlXG5cdFx0X2dldC5zY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKGVsZW0pIHtcblx0XHRcdHJldHVybiAoZWxlbSAmJiB0eXBlb2YgZWxlbS5zY3JvbGxMZWZ0ID09PSAnbnVtYmVyJykgPyBlbGVtLnNjcm9sbExlZnQgOiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgMDtcblx0XHR9O1xuXHRcdC8vIGdldCBlbGVtZW50IGhlaWdodFxuXHRcdF9nZXQud2lkdGggPSBmdW5jdGlvbiAoZWxlbSwgb3V0ZXIsIGluY2x1ZGVNYXJnaW4pIHtcblx0XHRcdHJldHVybiBfZGltZW5zaW9uKCd3aWR0aCcsIGVsZW0sIG91dGVyLCBpbmNsdWRlTWFyZ2luKTtcblx0XHR9O1xuXHRcdC8vIGdldCBlbGVtZW50IHdpZHRoXG5cdFx0X2dldC5oZWlnaHQgPSBmdW5jdGlvbiAoZWxlbSwgb3V0ZXIsIGluY2x1ZGVNYXJnaW4pIHtcblx0XHRcdHJldHVybiBfZGltZW5zaW9uKCdoZWlnaHQnLCBlbGVtLCBvdXRlciwgaW5jbHVkZU1hcmdpbik7XG5cdFx0fTtcblxuXHRcdC8vIGdldCBlbGVtZW50IHBvc2l0aW9uIChvcHRpb25hbGx5IHJlbGF0aXZlIHRvIHZpZXdwb3J0KVxuXHRcdF9nZXQub2Zmc2V0ID0gZnVuY3Rpb24gKGVsZW0sIHJlbGF0aXZlVG9WaWV3cG9ydCkge1xuXHRcdFx0dmFyIG9mZnNldCA9IHtcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRsZWZ0OiAwXG5cdFx0XHR9O1xuXHRcdFx0aWYgKGVsZW0gJiYgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHsgLy8gY2hlY2sgaWYgYXZhaWxhYmxlXG5cdFx0XHRcdHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0b2Zmc2V0LnRvcCA9IHJlY3QudG9wO1xuXHRcdFx0XHRvZmZzZXQubGVmdCA9IHJlY3QubGVmdDtcblx0XHRcdFx0aWYgKCFyZWxhdGl2ZVRvVmlld3BvcnQpIHsgLy8gY2xpZW50UmVjdCBpcyBieSBkZWZhdWx0IHJlbGF0aXZlIHRvIHZpZXdwb3J0Li4uXG5cdFx0XHRcdFx0b2Zmc2V0LnRvcCArPSBfZ2V0LnNjcm9sbFRvcCgpO1xuXHRcdFx0XHRcdG9mZnNldC5sZWZ0ICs9IF9nZXQuc2Nyb2xsTGVmdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKiBET00gRWxlbWVudCBtYW5pcHVsYXRpb25cblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQgKi9cblxuXHRcdFUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbSwgY2xhc3NuYW1lKSB7XG5cdFx0XHRpZiAoY2xhc3NuYW1lKSB7XG5cdFx0XHRcdGlmIChlbGVtLmNsYXNzTGlzdCkgZWxlbS5jbGFzc0xpc3QuYWRkKGNsYXNzbmFtZSk7XG5cdFx0XHRcdGVsc2UgZWxlbS5jbGFzc05hbWUgKz0gJyAnICsgY2xhc3NuYW1lO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0VS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbGVtLCBjbGFzc25hbWUpIHtcblx0XHRcdGlmIChjbGFzc25hbWUpIHtcblx0XHRcdFx0aWYgKGVsZW0uY2xhc3NMaXN0KSBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NuYW1lKTtcblx0XHRcdFx0ZWxzZSBlbGVtLmNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgnKF58XFxcXGIpJyArIGNsYXNzbmFtZS5zcGxpdCgnICcpLmpvaW4oJ3wnKSArICcoXFxcXGJ8JCknLCAnZ2knKSwgJyAnKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdC8vIGlmIG9wdGlvbnMgaXMgc3RyaW5nIC0+IHJldHVybnMgY3NzIHZhbHVlXG5cdFx0Ly8gaWYgb3B0aW9ucyBpcyBhcnJheSAtPiByZXR1cm5zIG9iamVjdCB3aXRoIGNzcyB2YWx1ZSBwYWlyc1xuXHRcdC8vIGlmIG9wdGlvbnMgaXMgb2JqZWN0IC0+IHNldCBuZXcgY3NzIHZhbHVlc1xuXHRcdFUuY3NzID0gZnVuY3Rpb24gKGVsZW0sIG9wdGlvbnMpIHtcblx0XHRcdGlmIChfdHlwZS5TdHJpbmcob3B0aW9ucykpIHtcblx0XHRcdFx0cmV0dXJuIF9nZXRDb21wdXRlZFN0eWxlKGVsZW0pW19jYW1lbENhc2Uob3B0aW9ucyldO1xuXHRcdFx0fSBlbHNlIGlmIChfdHlwZS5BcnJheShvcHRpb25zKSkge1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0b2JqID0ge30sXG5cdFx0XHRcdFx0c3R5bGUgPSBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcblx0XHRcdFx0b3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24sIGtleSkge1xuXHRcdFx0XHRcdG9ialtvcHRpb25dID0gc3R5bGVbX2NhbWVsQ2FzZShvcHRpb24pXTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBvcHRpb25zW29wdGlvbl07XG5cdFx0XHRcdFx0aWYgKHZhbCA9PSBwYXJzZUZsb2F0KHZhbCkpIHsgLy8gYXNzdW1lIHBpeGVsIGZvciBzZWVtaW5nbHkgbnVtZXJpY2FsIHZhbHVlc1xuXHRcdFx0XHRcdFx0dmFsICs9ICdweCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsZW0uc3R5bGVbX2NhbWVsQ2FzZShvcHRpb24pXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRyZXR1cm4gVTtcblx0fSh3aW5kb3cgfHwge30pKTtcblxuXHRTY3JvbGxNYWdpYy5TY2VuZS5wcm90b3R5cGUuYWRkSW5kaWNhdG9ycyA9IGZ1bmN0aW9uICgpIHtcblx0XHRTY3JvbGxNYWdpYy5fdXRpbC5sb2coMSwgJyhTY3JvbGxNYWdpYy5TY2VuZSkgLT4gRVJST1IgY2FsbGluZyBhZGRJbmRpY2F0b3JzKCkgZHVlIHRvIG1pc3NpbmcgUGx1Z2luIFxcJ2RlYnVnLmFkZEluZGljYXRvcnNcXCcuIFBsZWFzZSBtYWtlIHN1cmUgdG8gaW5jbHVkZSBwbHVnaW5zL2RlYnVnLmFkZEluZGljYXRvcnMuanMnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRTY3JvbGxNYWdpYy5TY2VuZS5wcm90b3R5cGUucmVtb3ZlSW5kaWNhdG9ycyA9IGZ1bmN0aW9uICgpIHtcblx0XHRTY3JvbGxNYWdpYy5fdXRpbC5sb2coMSwgJyhTY3JvbGxNYWdpYy5TY2VuZSkgLT4gRVJST1IgY2FsbGluZyByZW1vdmVJbmRpY2F0b3JzKCkgZHVlIHRvIG1pc3NpbmcgUGx1Z2luIFxcJ2RlYnVnLmFkZEluZGljYXRvcnNcXCcuIFBsZWFzZSBtYWtlIHN1cmUgdG8gaW5jbHVkZSBwbHVnaW5zL2RlYnVnLmFkZEluZGljYXRvcnMuanMnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRTY3JvbGxNYWdpYy5TY2VuZS5wcm90b3R5cGUuc2V0VHdlZW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0U2Nyb2xsTWFnaWMuX3V0aWwubG9nKDEsICcoU2Nyb2xsTWFnaWMuU2NlbmUpIC0+IEVSUk9SIGNhbGxpbmcgc2V0VHdlZW4oKSBkdWUgdG8gbWlzc2luZyBQbHVnaW4gXFwnYW5pbWF0aW9uLmdzYXBcXCcuIFBsZWFzZSBtYWtlIHN1cmUgdG8gaW5jbHVkZSBwbHVnaW5zL2FuaW1hdGlvbi5nc2FwLmpzJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0U2Nyb2xsTWFnaWMuU2NlbmUucHJvdG90eXBlLnJlbW92ZVR3ZWVuID0gZnVuY3Rpb24gKCkge1xuXHRcdFNjcm9sbE1hZ2ljLl91dGlsLmxvZygxLCAnKFNjcm9sbE1hZ2ljLlNjZW5lKSAtPiBFUlJPUiBjYWxsaW5nIHJlbW92ZVR3ZWVuKCkgZHVlIHRvIG1pc3NpbmcgUGx1Z2luIFxcJ2FuaW1hdGlvbi5nc2FwXFwnLiBQbGVhc2UgbWFrZSBzdXJlIHRvIGluY2x1ZGUgcGx1Z2lucy9hbmltYXRpb24uZ3NhcC5qcycpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdFNjcm9sbE1hZ2ljLlNjZW5lLnByb3RvdHlwZS5zZXRWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcblx0XHRTY3JvbGxNYWdpYy5fdXRpbC5sb2coMSwgJyhTY3JvbGxNYWdpYy5TY2VuZSkgLT4gRVJST1IgY2FsbGluZyBzZXRWZWxvY2l0eSgpIGR1ZSB0byBtaXNzaW5nIFBsdWdpbiBcXCdhbmltYXRpb24udmVsb2NpdHlcXCcuIFBsZWFzZSBtYWtlIHN1cmUgdG8gaW5jbHVkZSBwbHVnaW5zL2FuaW1hdGlvbi52ZWxvY2l0eS5qcycpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdFNjcm9sbE1hZ2ljLlNjZW5lLnByb3RvdHlwZS5yZW1vdmVWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcblx0XHRTY3JvbGxNYWdpYy5fdXRpbC5sb2coMSwgJyhTY3JvbGxNYWdpYy5TY2VuZSkgLT4gRVJST1IgY2FsbGluZyByZW1vdmVWZWxvY2l0eSgpIGR1ZSB0byBtaXNzaW5nIFBsdWdpbiBcXCdhbmltYXRpb24udmVsb2NpdHlcXCcuIFBsZWFzZSBtYWtlIHN1cmUgdG8gaW5jbHVkZSBwbHVnaW5zL2FuaW1hdGlvbi52ZWxvY2l0eS5qcycpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cmV0dXJuIFNjcm9sbE1hZ2ljO1xufSkpOyIsIi8qIVxuICogU2Nyb2xsTWFnaWMgdjIuMC41ICgyMDE1LTA0LTI5KVxuICogVGhlIGphdmFzY3JpcHQgbGlicmFyeSBmb3IgbWFnaWNhbCBzY3JvbGwgaW50ZXJhY3Rpb25zLlxuICogKGMpIDIwMTUgSmFuIFBhZXBrZSAoQGphbnBhZXBrZSlcbiAqIFByb2plY3QgV2Vic2l0ZTogaHR0cDovL3Njcm9sbG1hZ2ljLmlvXG4gKiBcbiAqIEB2ZXJzaW9uIDIuMC41XG4gKiBAbGljZW5zZSBEdWFsIGxpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlIGFuZCBHUEwuXG4gKiBAYXV0aG9yIEphbiBQYWVwa2UgLSBlLW1haWxAamFucGFlcGtlLmRlXG4gKlxuICogQGZpbGUgU2Nyb2xsTWFnaWMgR1NBUCBBbmltYXRpb24gUGx1Z2luLlxuICpcbiAqIHJlcXVpcmVzOiBHU0FQIH4xLjE0XG4gKiBQb3dlcmVkIGJ5IHRoZSBHcmVlbnNvY2sgQW5pbWF0aW9uIFBsYXRmb3JtIChHU0FQKTogaHR0cDovL3d3dy5ncmVlbnNvY2suY29tL2pzXG4gKiBHcmVlbnNvY2sgTGljZW5zZSBpbmZvIGF0IGh0dHA6Ly93d3cuZ3JlZW5zb2NrLmNvbS9saWNlbnNpbmcvXG4gKi9cbi8qKlxuICogVGhpcyBwbHVnaW4gaXMgbWVhbnQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBHcmVlbnNvY2sgQW5pbWF0aW9uIFBsYXR0Zm9ybS4gIFxuICogSXQgb2ZmZXJzIGFuIGVhc3kgQVBJIHRvIHRyaWdnZXIgVHdlZW5zIG9yIHN5bmNocm9uaXplIHRoZW0gdG8gdGhlIHNjcm9sbGJhciBtb3ZlbWVudC5cbiAqXG4gKiBCb3RoIHRoZSBgbGl0ZWAgYW5kIHRoZSBgbWF4YCB2ZXJzaW9ucyBvZiB0aGUgR1NBUCBsaWJyYXJ5IGFyZSBzdXBwb3J0ZWQuICBcbiAqIFRoZSBtb3N0IGJhc2ljIHJlcXVpcmVtZW50IGlzIGBUd2VlbkxpdGVgLlxuICogXG4gKiBUbyBoYXZlIGFjY2VzcyB0byB0aGlzIGV4dGVuc2lvbiwgcGxlYXNlIGluY2x1ZGUgYHBsdWdpbnMvYW5pbWF0aW9uLmdzYXAuanNgLlxuICogQHJlcXVpcmVzIHtAbGluayBodHRwOi8vZ3JlZW5zb2NrLmNvbS9nc2FwfEdTQVAgfjEuMTQueH1cbiAqIEBtaXhpbiBhbmltYXRpb24uR1NBUFxuICovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoWydTY3JvbGxNYWdpYycsICdUd2Vlbk1heCcsICdUaW1lbGluZU1heCddLCBmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdC8vIExvYWRzIHdob2xlIGdzYXAgcGFja2FnZSBvbnRvIGdsb2JhbCBzY29wZS5cblx0XHRyZXF1aXJlKCdnc2FwJyk7XG5cdFx0ZmFjdG9yeShyZXF1aXJlKCdzY3JvbGxtYWdpYycpLCBUd2Vlbk1heCwgVGltZWxpbmVNYXgpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3Rvcnkocm9vdC5TY3JvbGxNYWdpYyB8fCAocm9vdC5qUXVlcnkgJiYgcm9vdC5qUXVlcnkuU2Nyb2xsTWFnaWMpLCByb290LlR3ZWVuTWF4IHx8IHJvb3QuVHdlZW5MaXRlLCByb290LlRpbWVsaW5lTWF4IHx8IHJvb3QuVGltZWxpbmVMaXRlKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoU2Nyb2xsTWFnaWMsIFR3ZWVuLCBUaW1lbGluZSkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIE5BTUVTUEFDRSA9IFwiYW5pbWF0aW9uLmdzYXBcIjtcblxuXHR2YXJcblx0Y29uc29sZSA9IHdpbmRvdy5jb25zb2xlIHx8IHt9LFxuXHRcdGVyciA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZyB8fFxuXHRcdGZ1bmN0aW9uICgpIHt9LCBjb25zb2xlKTtcblx0aWYgKCFTY3JvbGxNYWdpYykge1xuXHRcdGVycihcIihcIiArIE5BTUVTUEFDRSArIFwiKSAtPiBFUlJPUjogVGhlIFNjcm9sbE1hZ2ljIG1haW4gbW9kdWxlIGNvdWxkIG5vdCBiZSBmb3VuZC4gUGxlYXNlIG1ha2Ugc3VyZSBpdCdzIGxvYWRlZCBiZWZvcmUgdGhpcyBwbHVnaW4gb3IgdXNlIGFuIGFzeW5jaHJvbm91cyBsb2FkZXIgbGlrZSByZXF1aXJlanMuXCIpO1xuXHR9XG5cdGlmICghVHdlZW4pIHtcblx0XHRlcnIoXCIoXCIgKyBOQU1FU1BBQ0UgKyBcIikgLT4gRVJST1I6IFR3ZWVuTGl0ZSBvciBUd2Vlbk1heCBjb3VsZCBub3QgYmUgZm91bmQuIFBsZWFzZSBtYWtlIHN1cmUgR1NBUCBpcyBsb2FkZWQgYmVmb3JlIFNjcm9sbE1hZ2ljIG9yIHVzZSBhbiBhc3luY2hyb25vdXMgbG9hZGVyIGxpa2UgcmVxdWlyZWpzLlwiKTtcblx0fVxuXG4vKlxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIEV4dGVuc2lvbnMgZm9yIFNjZW5lXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICovXG5cdC8qKlxuXHQgKiBFdmVyeSBpbnN0YW5jZSBvZiBTY3JvbGxNYWdpYy5TY2VuZSBub3cgYWNjZXB0cyBhbiBhZGRpdGlvbmFsIG9wdGlvbi4gIFxuXHQgKiBTZWUge0BsaW5rIFNjcm9sbE1hZ2ljLlNjZW5lfSBmb3IgYSBjb21wbGV0ZSBsaXN0IG9mIHRoZSBzdGFuZGFyZCBvcHRpb25zLlxuXHQgKiBAbWVtYmVyb2YhIGFuaW1hdGlvbi5HU0FQI1xuXHQgKiBAbWV0aG9kIG5ldyBTY3JvbGxNYWdpYy5TY2VuZShvcHRpb25zKVxuXHQgKiBAZXhhbXBsZVxuXHQgKiB2YXIgc2NlbmUgPSBuZXcgU2Nyb2xsTWFnaWMuU2NlbmUoe3R3ZWVuQ2hhbmdlczogdHJ1ZX0pO1xuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgdGhlIFNjZW5lLiBUaGUgb3B0aW9ucyBjYW4gYmUgdXBkYXRlZCBhdCBhbnkgdGltZS5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50d2VlbkNoYW5nZXM9ZmFsc2VdIC0gVHdlZW5zIEFuaW1hdGlvbiB0byB0aGUgcHJvZ3Jlc3MgdGFyZ2V0IGluc3RlYWQgb2Ygc2V0dGluZyBpdC4gIFxuXHQgRG9lcyBub3QgYWZmZWN0IGFuaW1hdGlvbnMgd2hlcmUgZHVyYXRpb24gaXMgYDBgLlxuXHQgKi9cblx0LyoqXG5cdCAqICoqR2V0Kiogb3IgKipTZXQqKiB0aGUgdHdlZW5DaGFuZ2VzIG9wdGlvbiB2YWx1ZS4gIFxuXHQgKiBUaGlzIG9ubHkgYWZmZWN0cyBzY2VuZXMgd2l0aCBhIGR1cmF0aW9uLiBJZiBgdHdlZW5DaGFuZ2VzYCBpcyBgdHJ1ZWAsIHRoZSBwcm9ncmVzcyB1cGRhdGUgd2hlbiBzY3JvbGxpbmcgd2lsbCBub3QgYmUgaW1tZWRpYXRlLCBidXQgaW5zdGVhZCB0aGUgYW5pbWF0aW9uIHdpbGwgc21vb3RobHkgYW5pbWF0ZSB0byB0aGUgdGFyZ2V0IHN0YXRlLiAgXG5cdCAqIEZvciBhIGJldHRlciB1bmRlcnN0YW5kaW5nLCB0cnkgZW5hYmxpbmcgYW5kIGRpc2FibGluZyB0aGlzIG9wdGlvbiBpbiB0aGUgW1NjZW5lIE1hbmlwdWxhdGlvbiBFeGFtcGxlXSguLi9leGFtcGxlcy9iYXNpYy9zY2VuZV9tYW5pcHVsYXRpb24uaHRtbCkuXG5cdCAqIEBtZW1iZXJvZiEgYW5pbWF0aW9uLkdTQVAjXG5cdCAqIEBtZXRob2QgU2NlbmUudHdlZW5DaGFuZ2VzXG5cdCAqIFxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBnZXQgdGhlIGN1cnJlbnQgdHdlZW5DaGFuZ2VzIG9wdGlvblxuXHQgKiB2YXIgdHdlZW5DaGFuZ2VzID0gc2NlbmUudHdlZW5DaGFuZ2VzKCk7XG5cdCAqXG5cdCAqIC8vIHNldCBuZXcgdHdlZW5DaGFuZ2VzIG9wdGlvblxuXHQgKiBzY2VuZS50d2VlbkNoYW5nZXModHJ1ZSk7XG5cdCAqXG5cdCAqIEBmaXJlcyB7QGxpbmsgU2NlbmUuY2hhbmdlfSwgd2hlbiB1c2VkIGFzIHNldHRlclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtuZXdUd2VlbkNoYW5nZXNdIC0gVGhlIG5ldyB0d2VlbkNoYW5nZXMgc2V0dGluZyBvZiB0aGUgc2NlbmUuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBgZ2V0YCAtICBDdXJyZW50IHR3ZWVuQ2hhbmdlcyBvcHRpb24gdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtTY2VuZX0gYHNldGAgLSAgUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHQvLyBhZGQgb3B0aW9uIChUT0RPOiBET0MgKHByaXZhdGUgZm9yIGRldikpXG5cdFNjcm9sbE1hZ2ljLlNjZW5lLmFkZE9wdGlvbihcInR3ZWVuQ2hhbmdlc1wiLCAvLyBuYW1lXG5cdGZhbHNlLCAvLyBkZWZhdWx0XG5cblxuXHRmdW5jdGlvbiAodmFsKSB7IC8vIHZhbGlkYXRpb24gY2FsbGJhY2tcblx0XHRyZXR1cm4gISF2YWw7XG5cdH0pO1xuXHQvLyBleHRlbmQgc2NlbmVcblx0U2Nyb2xsTWFnaWMuU2NlbmUuZXh0ZW5kKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgU2NlbmUgPSB0aGlzLFxuXHRcdFx0X3R3ZWVuO1xuXG5cdFx0dmFyIGxvZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChTY2VuZS5fbG9nKSB7IC8vIG5vdCBhdmFpbGFibGUsIHdoZW4gbWFpbiBzb3VyY2UgbWluaWZpZWRcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgMCwgXCIoXCIgKyBOQU1FU1BBQ0UgKyBcIilcIiwgXCItPlwiKTtcblx0XHRcdFx0U2NlbmUuX2xvZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBzZXQgbGlzdGVuZXJzXG5cdFx0U2NlbmUub24oXCJwcm9ncmVzcy5wbHVnaW5fZ3NhcFwiLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR1cGRhdGVUd2VlblByb2dyZXNzKCk7XG5cdFx0fSk7XG5cdFx0U2NlbmUub24oXCJkZXN0cm95LnBsdWdpbl9nc2FwXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRTY2VuZS5yZW1vdmVUd2VlbihlLnJlc2V0KTtcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSB0aGUgdHdlZW4gcHJvZ3Jlc3MgdG8gY3VycmVudCBwb3NpdGlvbi5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHZhciB1cGRhdGVUd2VlblByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKF90d2Vlbikge1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0cHJvZ3Jlc3MgPSBTY2VuZS5wcm9ncmVzcygpLFxuXHRcdFx0XHRcdHN0YXRlID0gU2NlbmUuc3RhdGUoKTtcblx0XHRcdFx0aWYgKF90d2Vlbi5yZXBlYXQgJiYgX3R3ZWVuLnJlcGVhdCgpID09PSAtMSkge1xuXHRcdFx0XHRcdC8vIGluZmluaXRlIGxvb3AsIHNvIG5vdCBpbiByZWxhdGlvbiB0byBwcm9ncmVzc1xuXHRcdFx0XHRcdGlmIChzdGF0ZSA9PT0gJ0RVUklORycgJiYgX3R3ZWVuLnBhdXNlZCgpKSB7XG5cdFx0XHRcdFx0XHRfdHdlZW4ucGxheSgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RhdGUgIT09ICdEVVJJTkcnICYmICFfdHdlZW4ucGF1c2VkKCkpIHtcblx0XHRcdFx0XHRcdF90d2Vlbi5wYXVzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChwcm9ncmVzcyAhPSBfdHdlZW4ucHJvZ3Jlc3MoKSkgeyAvLyBkbyB3ZSBldmVuIG5lZWQgdG8gdXBkYXRlIHRoZSBwcm9ncmVzcz9cblx0XHRcdFx0XHQvLyBubyBpbmZpbml0ZSBsb29wIC0gc28gc2hvdWxkIHdlIGp1c3QgcGxheSBvciBnbyB0byBhIHNwZWNpZmljIHBvaW50IGluIHRpbWU/XG5cdFx0XHRcdFx0aWYgKFNjZW5lLmR1cmF0aW9uKCkgPT09IDApIHtcblx0XHRcdFx0XHRcdC8vIHBsYXkgdGhlIGFuaW1hdGlvblxuXHRcdFx0XHRcdFx0aWYgKHByb2dyZXNzID4gMCkgeyAvLyBwbGF5IGZyb20gMCB0byAxXG5cdFx0XHRcdFx0XHRcdF90d2Vlbi5wbGF5KCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgeyAvLyBwbGF5IGZyb20gMSB0byAwXG5cdFx0XHRcdFx0XHRcdF90d2Vlbi5yZXZlcnNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGdvIHRvIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZVxuXHRcdFx0XHRcdFx0aWYgKFNjZW5lLnR3ZWVuQ2hhbmdlcygpICYmIF90d2Vlbi50d2VlblRvKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGdvIHNtb290aFxuXHRcdFx0XHRcdFx0XHRfdHdlZW4udHdlZW5Ubyhwcm9ncmVzcyAqIF90d2Vlbi5kdXJhdGlvbigpKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIGp1c3QgaGFyZCBzZXQgaXRcblx0XHRcdFx0XHRcdFx0X3R3ZWVuLnByb2dyZXNzKHByb2dyZXNzKS5wYXVzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBBZGQgYSB0d2VlbiB0byB0aGUgc2NlbmUuICBcblx0XHQgKiBJZiB5b3Ugd2FudCB0byBhZGQgbXVsdGlwbGUgdHdlZW5zLCBhZGQgdGhlbSBpbnRvIGEgR1NBUCBUaW1lbGluZSBvYmplY3QgYW5kIHN1cHBseSBpdCBpbnN0ZWFkIChzZWUgZXhhbXBsZSBiZWxvdykuICBcblx0XHQgKiBcblx0XHQgKiBJZiB0aGUgc2NlbmUgaGFzIGEgZHVyYXRpb24sIHRoZSB0d2VlbidzIGR1cmF0aW9uIHdpbGwgYmUgcHJvamVjdGVkIHRvIHRoZSBzY3JvbGwgZGlzdGFuY2Ugb2YgdGhlIHNjZW5lLCBtZWFuaW5nIGl0cyBwcm9ncmVzcyB3aWxsIGJlIHN5bmNlZCB0byBzY3JvbGxiYXIgbW92ZW1lbnQuICBcblx0XHQgKiBGb3IgYSBzY2VuZSB3aXRoIGEgZHVyYXRpb24gb2YgYDBgLCB0aGUgdHdlZW4gd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiBzY3JvbGxpbmcgZm9yd2FyZCBwYXN0IHRoZSBzY2VuZSdzIHRyaWdnZXIgcG9zaXRpb24gYW5kIHJldmVyc2VkLCB3aGVuIHNjcm9sbGluZyBiYWNrLiAgXG5cdFx0ICogVG8gZ2FpbiBiZXR0ZXIgdW5kZXJzdGFuZGluZywgY2hlY2sgb3V0IHRoZSBbU2ltcGxlIFR3ZWVuaW5nIGV4YW1wbGVdKC4uL2V4YW1wbGVzL2Jhc2ljL3NpbXBsZV90d2VlbmluZy5odG1sKS5cblx0XHQgKlxuXHRcdCAqIEluc3RlYWQgb2Ygc3VwcGx5aW5nIGEgdHdlZW4gdGhpcyBtZXRob2QgY2FuIGFsc28gYmUgdXNlZCBhcyBhIHNob3J0aGFuZCBmb3IgYFR3ZWVuTWF4LnRvKClgIChzZWUgZXhhbXBsZSBiZWxvdykuXG5cdFx0ICogQG1lbWJlcm9mISBhbmltYXRpb24uR1NBUCNcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gYWRkIGEgc2luZ2xlIHR3ZWVuIGRpcmVjdGx5XG5cdFx0ICogc2NlbmUuc2V0VHdlZW4oVHdlZW5NYXgudG8oXCJvYmpcIiksIDEsIHt4OiAxMDB9KTtcblx0XHQgKlxuXHRcdCAqIC8vIGFkZCBhIHNpbmdsZSB0d2VlbiB2aWEgdmFyaWFibGVcblx0XHQgKiB2YXIgdHdlZW4gPSBUd2Vlbk1heC50byhcIm9ialwiKSwgMSwge3g6IDEwMH07XG5cdFx0ICogc2NlbmUuc2V0VHdlZW4odHdlZW4pO1xuXHRcdCAqXG5cdFx0ICogLy8gYWRkIG11bHRpcGxlIHR3ZWVucywgd3JhcHBlZCBpbiBhIHRpbWVsaW5lLlxuXHRcdCAqIHZhciB0aW1lbGluZSA9IG5ldyBUaW1lbGluZU1heCgpO1xuXHRcdCAqIHZhciB0d2VlbjEgPSBUd2Vlbk1heC5mcm9tKFwib2JqMVwiLCAxLCB7eDogMTAwfSk7XG5cdFx0ICogdmFyIHR3ZWVuMiA9IFR3ZWVuTWF4LnRvKFwib2JqMlwiLCAxLCB7eTogMTAwfSk7XG5cdFx0ICogdGltZWxpbmVcblx0XHQgKlx0XHQuYWRkKHR3ZWVuMSlcblx0XHQgKlx0XHQuYWRkKHR3ZWVuMik7XG5cdFx0ICogc2NlbmUuYWRkVHdlZW4odGltZWxpbmUpO1xuXHRcdCAqXG5cdFx0ICogLy8gc2hvcnQgaGFuZCB0byBhZGQgYSBUd2Vlbk1heC50bygpIHR3ZWVuXG5cdFx0ICogc2NlbmUuc2V0VHdlZW4oXCJvYmozXCIsIDAuNSwge3k6IDEwMH0pO1xuXHRcdCAqXG5cdFx0ICogLy8gc2hvcnQgaGFuZCB0byBhZGQgYSBUd2Vlbk1heC50bygpIHR3ZWVuIGZvciAxIHNlY29uZFxuXHRcdCAqIC8vIHRoaXMgaXMgdXNlZnVsLCB3aGVuIHRoZSBzY2VuZSBoYXMgYSBkdXJhdGlvbiBhbmQgdGhlIHR3ZWVuIGR1cmF0aW9uIGlzbid0IGltcG9ydGFudCBhbnl3YXlcblx0XHQgKiBzY2VuZS5zZXRUd2VlbihcIm9iajNcIiwge3k6IDEwMH0pO1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsob2JqZWN0fHN0cmluZyl9IFR3ZWVuT2JqZWN0IC0gQSBUd2Vlbk1heCwgVHdlZW5MaXRlLCBUaW1lbGluZU1heCBvciBUaW1lbGluZUxpdGUgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGFuaW1hdGVkIGluIHRoZSBzY2VuZS4gQ2FuIGFsc28gYmUgYSBEb20gRWxlbWVudCBvciBTZWxlY3Rvciwgd2hlbiB1c2luZyBkaXJlY3QgdHdlZW4gZGVmaW5pdGlvbiAoc2VlIGV4YW1wbGVzKS5cblx0XHQgKiBAcGFyYW0geyhudW1iZXJ8b2JqZWN0KX0gZHVyYXRpb24gLSBBIGR1cmF0aW9uIGZvciB0aGUgdHdlZW4sIG9yIHR3ZWVuIHBhcmFtZXRlcnMuIElmIGFuIG9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgYXJlIHN1cHBsaWVkLCBhIGRlZmF1bHQgZHVyYXRpb24gb2YgMSB3aWxsIGJlIHVzZWQuXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgdHdlZW5cblx0XHQgKiBAcmV0dXJucyB7U2NlbmV9IFBhcmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuXHRcdCAqL1xuXHRcdFNjZW5lLnNldFR3ZWVuID0gZnVuY3Rpb24gKFR3ZWVuT2JqZWN0LCBkdXJhdGlvbiwgcGFyYW1zKSB7XG5cdFx0XHR2YXIgbmV3VHdlZW47XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG5cdFx0XHRcdFx0cGFyYW1zID0gZHVyYXRpb247XG5cdFx0XHRcdFx0ZHVyYXRpb24gPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFR3ZWVuT2JqZWN0ID0gVHdlZW4udG8oVHdlZW5PYmplY3QsIGR1cmF0aW9uLCBwYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gd3JhcCBUd2VlbiBpbnRvIGEgVGltZWxpbmUgT2JqZWN0IGlmIGF2YWlsYWJsZSB0byBpbmNsdWRlIGRlbGF5IGFuZCByZXBlYXRzIGluIHRoZSBkdXJhdGlvbiBhbmQgc3RhbmRhcmRpemUgbWV0aG9kcy5cblx0XHRcdFx0aWYgKFRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0bmV3VHdlZW4gPSBuZXcgVGltZWxpbmUoe1xuXHRcdFx0XHRcdFx0c21vb3RoQ2hpbGRUaW1pbmc6IHRydWVcblx0XHRcdFx0XHR9KS5hZGQoVHdlZW5PYmplY3QpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld1R3ZWVuID0gVHdlZW5PYmplY3Q7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3VHdlZW4ucGF1c2UoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0bG9nKDEsIFwiRVJST1IgY2FsbGluZyBtZXRob2QgJ3NldFR3ZWVuKCknOiBTdXBwbGllZCBhcmd1bWVudCBpcyBub3QgYSB2YWxpZCBUd2Vlbk9iamVjdFwiKTtcblx0XHRcdFx0cmV0dXJuIFNjZW5lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF90d2VlbikgeyAvLyBraWxsIG9sZCB0d2Vlbj9cblx0XHRcdFx0U2NlbmUucmVtb3ZlVHdlZW4oKTtcblx0XHRcdH1cblx0XHRcdF90d2VlbiA9IG5ld1R3ZWVuO1xuXG5cdFx0XHQvLyBzb21lIHByb3BlcnRpZXMgbmVlZCB0byBiZSB0cmFuc2ZlcnJlZCBpdCB0byB0aGUgd3JhcHBlciwgb3RoZXJ3aXNlIHRoZXkgd291bGQgZ2V0IGxvc3QuXG5cdFx0XHRpZiAoVHdlZW5PYmplY3QucmVwZWF0ICYmIFR3ZWVuT2JqZWN0LnJlcGVhdCgpID09PSAtMSkgeyAvLyBUd2Vlbk1heCBvciBUaW1lbGluZU1heCBPYmplY3Q/XG5cdFx0XHRcdF90d2Vlbi5yZXBlYXQoLTEpO1xuXHRcdFx0XHRfdHdlZW4ueW95byhUd2Vlbk9iamVjdC55b3lvKCkpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU29tZSB0d2VlbiB2YWxpZGF0aW9ucyBhbmQgZGVidWdnaW5nIGhlbHBlcnNcblx0XHRcdGlmIChTY2VuZS50d2VlbkNoYW5nZXMoKSAmJiAhX3R3ZWVuLnR3ZWVuVG8pIHtcblx0XHRcdFx0bG9nKDIsIFwiV0FSTklORzogdHdlZW5DaGFuZ2VzIHdpbGwgb25seSB3b3JrIGlmIHRoZSBUaW1lbGluZU1heCBvYmplY3QgaXMgYXZhaWxhYmxlIGZvciBTY3JvbGxNYWdpYy5cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBwb3NpdGlvbiB0d2VlbnMgZGVmaW5lZCBmb3IgdGhlIHRyaWdnZXIgYW5kIHdhcm4gYWJvdXQgaXQgOilcblx0XHRcdGlmIChfdHdlZW4gJiYgU2NlbmUuY29udHJvbGxlcigpICYmIFNjZW5lLnRyaWdnZXJFbGVtZW50KCkgJiYgU2NlbmUubG9nbGV2ZWwoKSA+PSAyKSB7IC8vIGNvbnRyb2xsZXIgaXMgbmVlZGVkIHRvIGtub3cgc2Nyb2xsIGRpcmVjdGlvbi5cblx0XHRcdFx0dmFyXG5cdFx0XHRcdHRyaWdnZXJUd2VlbnMgPSBUd2Vlbi5nZXRUd2VlbnNPZihTY2VuZS50cmlnZ2VyRWxlbWVudCgpKSxcblx0XHRcdFx0XHR2ZXJ0aWNhbCA9IFNjZW5lLmNvbnRyb2xsZXIoKS5pbmZvKFwidmVydGljYWxcIik7XG5cdFx0XHRcdHRyaWdnZXJUd2VlbnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0dHdlZW52YXJzID0gdmFsdWUudmFycy5jc3MgfHwgdmFsdWUudmFycyxcblx0XHRcdFx0XHRcdGNvbmRpdGlvbiA9IHZlcnRpY2FsID8gKHR3ZWVudmFycy50b3AgIT09IHVuZGVmaW5lZCB8fCB0d2VlbnZhcnMuYm90dG9tICE9PSB1bmRlZmluZWQpIDogKHR3ZWVudmFycy5sZWZ0ICE9PSB1bmRlZmluZWQgfHwgdHdlZW52YXJzLnJpZ2h0ICE9PSB1bmRlZmluZWQpO1xuXHRcdFx0XHRcdGlmIChjb25kaXRpb24pIHtcblx0XHRcdFx0XHRcdGxvZygyLCBcIldBUk5JTkc6IFR3ZWVuaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHJpZ2dlciBlbGVtZW50IGFmZmVjdHMgdGhlIHNjZW5lIHRpbWluZyBhbmQgc2hvdWxkIGJlIGF2b2lkZWQhXCIpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdhcm4gYWJvdXQgdHdlZW4gb3ZlcndyaXRlcywgd2hlbiBhbiBlbGVtZW50IGlzIHR3ZWVuZWQgbXVsdGlwbGUgdGltZXNcblx0XHRcdGlmIChwYXJzZUZsb2F0KFR3ZWVuTGl0ZS52ZXJzaW9uKSA+PSAxLjE0KSB7IC8vIG9uT3ZlcndyaXRlIG9ubHkgcHJlc2VudCBzaW5jZSBHU0FQIHYxLjE0LjBcblx0XHRcdFx0dmFyXG5cdFx0XHRcdGxpc3QgPSBfdHdlZW4uZ2V0Q2hpbGRyZW4gPyBfdHdlZW4uZ2V0Q2hpbGRyZW4odHJ1ZSwgdHJ1ZSwgZmFsc2UpIDogW190d2Vlbl0sXG5cdFx0XHRcdFx0Ly8gZ2V0IGFsbCBuZXN0ZWQgdHdlZW4gb2JqZWN0c1xuXHRcdFx0XHRcdG5ld0NhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0bG9nKDIsIFwiV0FSTklORzogdHdlZW4gd2FzIG92ZXJ3cml0dGVuIGJ5IGFub3RoZXIuIFRvIGxlYXJuIGhvdyB0byBhdm9pZCB0aGlzIGlzc3VlIHNlZSBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vamFucGFlcGtlL1Njcm9sbE1hZ2ljL3dpa2kvV0FSTklORzotdHdlZW4td2FzLW92ZXJ3cml0dGVuLWJ5LWFub3RoZXJcIik7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIHRoaXNUd2Vlbiwgb2xkQ2FsbGJhY2s7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7IC8qanNoaW50IGxvb3BmdW5jOiB0cnVlICovXG5cdFx0XHRcdFx0dGhpc1R3ZWVuID0gbGlzdFtpXTtcblx0XHRcdFx0XHRpZiAob2xkQ2FsbGJhY2sgIT09IG5ld0NhbGxiYWNrKSB7IC8vIGlmIHR3ZWVucyBpcyBhZGRlZCBtb3JlIHRoYW4gb25jZVxuXHRcdFx0XHRcdFx0b2xkQ2FsbGJhY2sgPSB0aGlzVHdlZW4udmFycy5vbk92ZXJ3cml0ZTtcblx0XHRcdFx0XHRcdHRoaXNUd2Vlbi52YXJzLm9uT3ZlcndyaXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRpZiAob2xkQ2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdFx0XHRvbGRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdG5ld0NhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bG9nKDMsIFwiYWRkZWQgdHdlZW5cIik7XG5cblx0XHRcdHVwZGF0ZVR3ZWVuUHJvZ3Jlc3MoKTtcblx0XHRcdHJldHVybiBTY2VuZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIHRoZSB0d2VlbiBmcm9tIHRoZSBzY2VuZS4gIFxuXHRcdCAqIFRoaXMgd2lsbCB0ZXJtaW5hdGUgdGhlIGNvbnRyb2wgb2YgdGhlIFNjZW5lIG92ZXIgdGhlIHR3ZWVuLlxuXHRcdCAqXG5cdFx0ICogVXNpbmcgdGhlIHJlc2V0IG9wdGlvbiB5b3UgY2FuIGRlY2lkZSBpZiB0aGUgdHdlZW4gc2hvdWxkIHJlbWFpbiBpbiB0aGUgY3VycmVudCBzdGF0ZSBvciBiZSByZXdvdW5kIHRvIHNldCB0aGUgdGFyZ2V0IGVsZW1lbnRzIGJhY2sgdG8gdGhlIHN0YXRlIHRoZXkgd2VyZSBpbiBiZWZvcmUgdGhlIHR3ZWVuIHdhcyBhZGRlZCB0byB0aGUgc2NlbmUuXG5cdFx0ICogQG1lbWJlcm9mISBhbmltYXRpb24uR1NBUCNcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy8gcmVtb3ZlIHRoZSB0d2VlbiBmcm9tIHRoZSBzY2VuZSB3aXRob3V0IHJlc2V0dGluZyBpdFxuXHRcdCAqIHNjZW5lLnJlbW92ZVR3ZWVuKCk7XG5cdFx0ICpcblx0XHQgKiAvLyByZW1vdmUgdGhlIHR3ZWVuIGZyb20gdGhlIHNjZW5lIGFuZCByZXNldCBpdCB0byBpbml0aWFsIHBvc2l0aW9uXG5cdFx0ICogc2NlbmUucmVtb3ZlVHdlZW4odHJ1ZSk7XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD1mYWxzZV0gLSBJZiBgdHJ1ZWAgdGhlIHR3ZWVuIHdpbGwgYmUgcmVzZXQgdG8gaXRzIGluaXRpYWwgdmFsdWVzLlxuXHRcdCAqIEByZXR1cm5zIHtTY2VuZX0gUGFyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG5cdFx0ICovXG5cdFx0U2NlbmUucmVtb3ZlVHdlZW4gPSBmdW5jdGlvbiAocmVzZXQpIHtcblx0XHRcdGlmIChfdHdlZW4pIHtcblx0XHRcdFx0aWYgKHJlc2V0KSB7XG5cdFx0XHRcdFx0X3R3ZWVuLnByb2dyZXNzKDApLnBhdXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3R3ZWVuLmtpbGwoKTtcblx0XHRcdFx0X3R3ZWVuID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRsb2coMywgXCJyZW1vdmVkIHR3ZWVuIChyZXNldDogXCIgKyAocmVzZXQgPyBcInRydWVcIiA6IFwiZmFsc2VcIikgKyBcIilcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2NlbmU7XG5cdFx0fTtcblxuXHR9KTtcbn0pKTsiLCIvKiEgTGF6eSBMb2FkIFhUIHYxLjAuNSAyMDE0LTA2LTA1XG4gKiBodHRwOi8vcmVzc2lvLmdpdGh1Yi5pby9sYXp5LWxvYWQteHRcbiAqIChDKSAyMDE0IFJFU1MuaW9cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAqL1xuXG4oZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuICAgIC8vIG9wdGlvbnNcbiAgICB2YXIgbGF6eUxvYWRYVCA9ICdsYXp5TG9hZFhUJyxcbiAgICAgICAgZGF0YUxhemllZCA9ICdsYXppZWQnLFxuICAgICAgICBsb2FkX2Vycm9yID0gJ2xvYWQgZXJyb3InLFxuICAgICAgICBjbGFzc0xhenlIaWRkZW4gPSAnbGF6eS1oaWRkZW4nLFxuICAgICAgICBkb2NFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHksXG4gICAgLy8gIGZvcmNlIGxvYWQgYWxsIGltYWdlcyBpbiBPcGVyYSBNaW5pIGFuZCBzb21lIG1vYmlsZSBicm93c2VycyB3aXRob3V0IHNjcm9sbCBldmVudCBvciBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICBmb3JjZUxvYWQgPSAod2luZG93Lm9uc2Nyb2xsID09PSB1bmRlZmluZWQgfHwgISF3aW5kb3cub3BlcmFtaW5pIHx8ICFkb2NFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCksXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhdXRvSW5pdDogdHJ1ZSwgLy8gYXV0byBpbml0aWFsaXplIGluICQucmVhZHlcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnaW1nW2RhdGEtc3JjXScsIC8vIHNlbGVjdG9yIGZvciBsYXp5bG9hZGluZyBlbGVtZW50c1xuICAgICAgICAgICAgYmxhbmtJbWFnZTogJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNycsXG4gICAgICAgICAgICB0aHJvdHRsZTogOTksIC8vIGludGVydmFsIChtcykgZm9yIGNoYW5nZXMgY2hlY2tcbiAgICAgICAgICAgIGZvcmNlTG9hZDogZm9yY2VMb2FkLCAvLyBmb3JjZSBhdXRvIGxvYWQgYWxsIGltYWdlc1xuXG4gICAgICAgICAgICBsb2FkRXZlbnQ6ICdwYWdlc2hvdycsIC8vIGNoZWNrIEFKQVgtbG9hZGVkIGNvbnRlbnQgaW4galF1ZXJ5TW9iaWxlXG4gICAgICAgICAgICB1cGRhdGVFdmVudDogJ2xvYWQgb3JpZW50YXRpb25jaGFuZ2UgcmVzaXplIHNjcm9sbCB0b3VjaG1vdmUgZm9jdXMnLCAvLyBwYWdlLW1vZGlmaWVkIGV2ZW50c1xuICAgICAgICAgICAgZm9yY2VFdmVudDogJycsIC8vIGZvcmNlIGxvYWRpbmcgb2YgYWxsIGVsZW1lbnRzXG5cbiAgICAgICAgICAgIC8vb25zdGFydDogbnVsbCxcbiAgICAgICAgICAgIG9uaW5pdDoge3JlbW92ZUNsYXNzOiAnbGF6eSd9LCAvLyBpbml0IGhhbmRsZXJcbiAgICAgICAgICAgIG9uc2hvdzoge2FkZENsYXNzOiBjbGFzc0xhenlIaWRkZW59LCAvLyBzdGFydCBsb2FkaW5nIGhhbmRsZXJcbiAgICAgICAgICAgIG9ubG9hZDoge3JlbW92ZUNsYXNzOiBjbGFzc0xhenlIaWRkZW4sIGFkZENsYXNzOiAnbGF6eS1sb2FkZWQnfSwgLy8gbG9hZCBzdWNjZXNzIGhhbmRsZXJcbiAgICAgICAgICAgIG9uZXJyb3I6IHtyZW1vdmVDbGFzczogY2xhc3NMYXp5SGlkZGVufSwgLy8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgLy9vbmNvbXBsZXRlOiBudWxsLCAvLyBjb21wbGV0ZSBoYW5kbGVyXG5cbiAgICAgICAgICAgIC8vc2Nyb2xsQ29udGFpbmVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGVja0R1cGxpY2F0ZXM6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZWxlbWVudE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzcmNBdHRyOiAnZGF0YS1zcmMnLFxuICAgICAgICAgICAgZWRnZVg6IDAsXG4gICAgICAgICAgICBlZGdlWTogMCxcbiAgICAgICAgICAgIHZpc2libGVPbmx5OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICR3aW5kb3cgPSAkKHdpbmRvdyksXG4gICAgICAgICRpc0Z1bmN0aW9uID0gJC5pc0Z1bmN0aW9uLFxuICAgICAgICAkZXh0ZW5kID0gJC5leHRlbmQsXG4gICAgICAgICRkYXRhID0gJC5kYXRhIHx8IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICQoZWwpLmRhdGEobmFtZSk7XG4gICAgICAgIH0sXG4gICAgLy8gJC5jb250YWlucyBpcyBub3QgaW5jbHVkZWQgaW50byBET010YXN0aWMsIHNvIGltcGxlbWVudCBpdCB0aGVyZVxuICAgICAgICAkY29udGFpbnMgPSAkLmNvbnRhaW5zIHx8IGZ1bmN0aW9uIChwYXJlbnQsIGVsKSB7XG4gICAgICAgICAgICB3aGlsZSAoZWwgPSBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbGVtZW50cyA9IFtdLFxuICAgICAgICB0b3BMYXp5ID0gMCxcbiAgICAvKlxuICAgICB3YWl0aW5nTW9kZT0wIDogbm8gc2V0VGltZW91dFxuICAgICB3YWl0aW5nTW9kZT0xIDogc2V0VGltZW91dCwgbm8gZGVmZXJyZWQgZXZlbnRzXG4gICAgIHdhaXRpbmdNb2RlPTIgOiBzZXRUaW1lb3V0LCBkZWZlcnJlZCBldmVudHNcbiAgICAgKi9cbiAgICAgICAgd2FpdGluZ01vZGUgPSAwO1xuXG4gICAgJFtsYXp5TG9hZFhUXSA9ICRleHRlbmQob3B0aW9ucywgZWxlbWVudE9wdGlvbnMsICRbbGF6eUxvYWRYVF0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIG9wdGlvbnMucHJvcCBpZiBvYmoucHJvcCBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSByZXR1cm4gb2JqLnByb3BcbiAgICAgKiBAcGFyYW0geyp9IG9ialxuICAgICAqIEBwYXJhbSB7Kn0gcHJvcFxuICAgICAqIEByZXR1cm5zICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRPckRlZihvYmosIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdW5kZWZpbmVkID8gb3B0aW9uc1twcm9wXSA6IG9ialtwcm9wXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjcm9sbFRvcCgpIHtcbiAgICAgICAgdmFyIHNjcm9sbCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgcmV0dXJuIChzY3JvbGwgPT09IHVuZGVmaW5lZCkgPyBkb2NFbGVtZW50LnNjcm9sbFRvcCA6IHNjcm9sbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbmV3IGVsZW1lbnRzIHRvIGxhenktbG9hZCBsaXN0OlxuICAgICAqICQoZWxlbWVudHMpLmxhenlMb2FkWFQoKSBvciAkKHdpbmRvdykubGF6eUxvYWRYVCgpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW292ZXJyaWRlc10gb3ZlcnJpZGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgKi9cbiAgICAkLmZuW2xhenlMb2FkWFRdID0gZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBvdmVycmlkZXMgPSBvdmVycmlkZXMgfHwge307XG5cbiAgICAgICAgdmFyIGJsYW5rSW1hZ2UgPSBnZXRPckRlZihvdmVycmlkZXMsICdibGFua0ltYWdlJyksXG4gICAgICAgICAgICBjaGVja0R1cGxpY2F0ZXMgPSBnZXRPckRlZihvdmVycmlkZXMsICdjaGVja0R1cGxpY2F0ZXMnKSxcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lciA9IGdldE9yRGVmKG92ZXJyaWRlcywgJ3Njcm9sbENvbnRhaW5lcicpLFxuICAgICAgICAgICAgZWxlbWVudE9wdGlvbnNPdmVycmlkZXMgPSB7fSxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgLy8gZW1wdHkgb3ZlcnJpZGVzLnNjcm9sbENvbnRhaW5lciBpcyBzdXBwb3J0ZWQgYnkgYm90aCBqUXVlcnkgYW5kIFplcHRvXG4gICAgICAgICQoc2Nyb2xsQ29udGFpbmVyKS5vbignc2Nyb2xsJywgcXVldWVDaGVja0xhenlFbGVtZW50cyk7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGVsZW1lbnRPcHRpb25zKSB7XG4gICAgICAgICAgICBlbGVtZW50T3B0aW9uc092ZXJyaWRlc1twcm9wXSA9IGdldE9yRGVmKG92ZXJyaWRlcywgcHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCA9PT0gd2luZG93KSB7XG4gICAgICAgICAgICAgICAgJChvcHRpb25zLnNlbGVjdG9yKS5sYXp5TG9hZFhUKG92ZXJyaWRlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0R1cGxpY2F0ZXMgJiYgJGRhdGEoZWwsIGRhdGFMYXppZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgJGVsID0gJChlbCkuZGF0YShkYXRhTGF6aWVkLCAxKTtcblxuICAgICAgICAgICAgICAgIGlmIChibGFua0ltYWdlICYmIGVsLnRhZ05hbWUgPT09ICdJTUcnICYmICFlbC5zcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3JjID0gYmxhbmtJbWFnZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjbG9uZSBlbGVtZW50T3B0aW9uc092ZXJyaWRlcyBvYmplY3RcbiAgICAgICAgICAgICAgICAkZWxbbGF6eUxvYWRYVF0gPSAkZXh0ZW5kKHt9LCBlbGVtZW50T3B0aW9uc092ZXJyaWRlcyk7XG5cbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2luaXQnLCAkZWwpO1xuXG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCgkZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGZ1bmN0aW9uL29iamVjdCBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IHN1ZmZpeFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnQsICRlbCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IG9wdGlvbnNbJ29uJyArIGV2ZW50XTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmICgkaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCgkZWxbMF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5hZGRDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAkZWwuYWRkQ2xhc3MoaGFuZGxlci5hZGRDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJlbW92ZUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICRlbC5yZW1vdmVDbGFzcyhoYW5kbGVyLnJlbW92ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkZWwudHJpZ2dlcignbGF6eScgKyBldmVudCwgWyRlbF0pO1xuXG4gICAgICAgIC8vIHF1ZXVlIG5leHQgY2hlY2sgYXMgaW1hZ2VzIG1heSBiZSByZXNpemVkIGFmdGVyIGxvYWRpbmcgb2YgYWN0dWFsIGZpbGVcbiAgICAgICAgcXVldWVDaGVja0xhenlFbGVtZW50cygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBvbmxvYWQvb25lcnJvciBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJMb2FkT3JFcnJvcihlKSB7XG4gICAgICAgIHRyaWdnZXJFdmVudChlLnR5cGUsICQodGhpcykub2ZmKGxvYWRfZXJyb3IsIHRyaWdnZXJMb2FkT3JFcnJvcikpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTG9hZCB2aXNpYmxlIGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtib29sfSBbZm9yY2VdIGxvYWRpbmcgb2YgYWxsIGVsZW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tMYXp5RWxlbWVudHMoZm9yY2UpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcmNlID0gZm9yY2UgfHwgb3B0aW9ucy5mb3JjZUxvYWQ7XG5cbiAgICAgICAgdG9wTGF6eSA9IEluZmluaXR5O1xuXG4gICAgICAgIHZhciB2aWV3cG9ydFRvcCA9IHNjcm9sbFRvcCgpLFxuICAgICAgICAgICAgdmlld3BvcnRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jRWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICB2aWV3cG9ydFdpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgZG9jRWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAkZWwgPSBlbGVtZW50c1tpXSxcbiAgICAgICAgICAgICAgICBlbCA9ICRlbFswXSxcbiAgICAgICAgICAgICAgICBvYmpEYXRhID0gJGVsW2xhenlMb2FkWFRdLFxuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gZm9yY2UsXG4gICAgICAgICAgICAgICAgdG9wRWRnZTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGl0ZW1zIHRoYXQgYXJlIG5vdCBpbiBET01cbiAgICAgICAgICAgIGlmICghJGNvbnRhaW5zKGRvY0VsZW1lbnQsIGVsKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JjZSB8fCAhb2JqRGF0YS52aXNpYmxlT25seSB8fCBlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQpIHtcblxuICAgICAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxQb3MgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VYID0gb2JqRGF0YS5lZGdlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VZID0gb2JqRGF0YS5lZGdlWTtcblxuICAgICAgICAgICAgICAgICAgICB0b3BFZGdlID0gKGVsUG9zLnRvcCArIHZpZXdwb3J0VG9wIC0gZWRnZVkpIC0gdmlld3BvcnRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZSA9ICh0b3BFZGdlIDw9IHZpZXdwb3J0VG9wICYmIGVsUG9zLmJvdHRvbSA+IC1lZGdlWSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZWxQb3MubGVmdCA8PSB2aWV3cG9ydFdpZHRoICsgZWRnZVggJiYgZWxQb3MucmlnaHQgPiAtZWRnZVgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnc2hvdycsICRlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNyY0F0dHIgPSBvYmpEYXRhLnNyY0F0dHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSAkaXNGdW5jdGlvbihzcmNBdHRyKSA/IHNyY0F0dHIoJGVsKSA6IGVsLmdldEF0dHJpYnV0ZShzcmNBdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGVsLm9uKGxvYWRfZXJyb3IsIHRyaWdnZXJMb2FkT3JFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zcmMgPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9wRWRnZSA8IHRvcExhenkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcExhenkgPSB0b3BFZGdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVtb3ZlTm9kZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnY29tcGxldGUnLCAkKGRvY0VsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUnVuIGNoZWNrIG9mIGxhenkgZWxlbWVudHMgYWZ0ZXIgdGltZW91dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVvdXRMYXp5RWxlbWVudHMoKSB7XG4gICAgICAgIGlmICh3YWl0aW5nTW9kZSA+IDEpIHtcbiAgICAgICAgICAgIHdhaXRpbmdNb2RlID0gMTtcbiAgICAgICAgICAgIGNoZWNrTGF6eUVsZW1lbnRzKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVvdXRMYXp5RWxlbWVudHMsIG9wdGlvbnMudGhyb3R0bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FpdGluZ01vZGUgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZSBjaGVjayBvZiBsYXp5IGVsZW1lbnRzIGJlY2F1c2Ugb2YgZXZlbnQgZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1ZXVlQ2hlY2tMYXp5RWxlbWVudHMoZSkge1xuICAgICAgICBpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFzdCBjaGVjayBmb3Igc2Nyb2xsIGV2ZW50IHdpdGhvdXQgbmV3IHZpc2libGUgZWxlbWVudHNcbiAgICAgICAgaWYgKGUgJiYgZS50eXBlID09PSAnc2Nyb2xsJyAmJiBlLmN1cnJlbnRUYXJnZXQgPT09IHdpbmRvdykge1xuICAgICAgICAgICAgaWYgKHRvcExhenkgPj0gc2Nyb2xsVG9wKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXdhaXRpbmdNb2RlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVvdXRMYXp5RWxlbWVudHMsIDApO1xuICAgICAgICB9XG4gICAgICAgIHdhaXRpbmdNb2RlID0gMjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgbGlzdCBvZiBoaWRkZW4gZWxlbWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0TGF6eUVsZW1lbnRzKCkge1xuICAgICAgICAkd2luZG93LmxhenlMb2FkWFQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExvYWRpbmcgb2YgYWxsIGVsZW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yY2VMb2FkQWxsKCkge1xuICAgICAgICBjaGVja0xhenlFbGVtZW50cyh0cnVlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemF0aW9uXG4gICAgICovXG4gICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmlnZ2VyRXZlbnQoJ3N0YXJ0JywgJHdpbmRvdyk7XG5cbiAgICAgICAgJHdpbmRvd1xuICAgICAgICAgICAgLm9uKG9wdGlvbnMubG9hZEV2ZW50LCBpbml0TGF6eUVsZW1lbnRzKVxuICAgICAgICAgICAgLm9uKG9wdGlvbnMudXBkYXRlRXZlbnQsIHF1ZXVlQ2hlY2tMYXp5RWxlbWVudHMpXG4gICAgICAgICAgICAub24ob3B0aW9ucy5mb3JjZUV2ZW50LCBmb3JjZUxvYWRBbGwpO1xuXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKG9wdGlvbnMudXBkYXRlRXZlbnQsIHF1ZXVlQ2hlY2tMYXp5RWxlbWVudHMpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9Jbml0KSB7XG4gICAgICAgICAgICBpbml0TGF6eUVsZW1lbnRzKCk7IC8vIHN0YW5kYXJkIGluaXRpYWxpemF0aW9uXG4gICAgICAgIH1cbiAgICB9KTtcblxufSkod2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG8gfHwgd2luZG93LiQsIHdpbmRvdywgZG9jdW1lbnQpOyIsIi8qISBMYXp5IExvYWQgWFQgdjEuMC41IDIwMTQtMDYtMDVcbiAqIGh0dHA6Ly9yZXNzaW8uZ2l0aHViLmlvL2xhenktbG9hZC14dFxuICogKEMpIDIwMTQgUkVTUy5pb1xuICogTGljZW5zZWQgdW5kZXIgTUlUICovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgIHZhciBvcHRpb25zID0gJC5sYXp5TG9hZFhUO1xuXG4gICAgb3B0aW9ucy5mb3JjZUV2ZW50ICs9ICcgbGF6eWF1dG9sb2FkJztcbiAgICBvcHRpb25zLmF1dG9Mb2FkVGltZSA9IG9wdGlvbnMuYXV0b0xvYWRUaW1lIHx8IDUwO1xuXG4gICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQod2luZG93KS50cmlnZ2VyKCdsYXp5YXV0b2xvYWQnKTtcbiAgICAgICAgfSwgb3B0aW9ucy5hdXRvTG9hZFRpbWUpO1xuICAgIH0pO1xuXG59KSh3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0byB8fCB3aW5kb3cuJCk7XG4iLCIvKiEgTGF6eSBMb2FkIFhUIHYxLjAuNSAyMDE0LTA2LTA1XG4gKiBodHRwOi8vcmVzc2lvLmdpdGh1Yi5pby9sYXp5LWxvYWQteHRcbiAqIChDKSAyMDE0IFJFU1MuaW9cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAqL1xuXG4oZnVuY3Rpb24gKCQpIHtcbiAgICB2YXIgb3B0aW9ucyA9ICQubGF6eUxvYWRYVCxcbiAgICAgICAgYmdBdHRyID0gb3B0aW9ucy5iZ0F0dHIgfHwgJ2RhdGEtYmcnO1xuXG4gICAgb3B0aW9ucy5zZWxlY3RvciArPSAnLFsnICsgYmdBdHRyICsgJ10nO1xuXG4gICAgJChkb2N1bWVudCkub24oJ2xhenlzaG93JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyICR0aGlzID0gJChlLnRhcmdldCk7XG4gICAgICAgICR0aGlzXG4gICAgICAgICAgICAuY3NzKCdiYWNrZ3JvdW5kLWltYWdlJywgXCJ1cmwoJ1wiICsgJHRoaXMuYXR0cihiZ0F0dHIpICsgXCInKVwiKVxuICAgICAgICAgICAgLnJlbW92ZUF0dHIoYmdBdHRyKTtcbiAgICB9KTtcblxufSkod2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG8gfHwgd2luZG93LiQpO1xuIiwiIWZ1bmN0aW9uKCQpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBGT1VOREFUSU9OX1ZFUlNJT04gPSAnNi4yLjEnO1xuXG4vLyBHbG9iYWwgRm91bmRhdGlvbiBvYmplY3Rcbi8vIFRoaXMgaXMgYXR0YWNoZWQgdG8gdGhlIHdpbmRvdywgb3IgdXNlZCBhcyBhIG1vZHVsZSBmb3IgQU1EL0Jyb3dzZXJpZnlcbnZhciBGb3VuZGF0aW9uID0ge1xuICB2ZXJzaW9uOiBGT1VOREFUSU9OX1ZFUlNJT04sXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBpbml0aWFsaXplZCBwbHVnaW5zLlxuICAgKi9cbiAgX3BsdWdpbnM6IHt9LFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgZ2VuZXJhdGVkIHVuaXF1ZSBpZHMgZm9yIHBsdWdpbiBpbnN0YW5jZXNcbiAgICovXG4gIF91dWlkczogW10sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGZvciBSVEwgc3VwcG9ydFxuICAgKi9cbiAgcnRsOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiAkKCdodG1sJykuYXR0cignZGlyJykgPT09ICdydGwnO1xuICB9LFxuICAvKipcbiAgICogRGVmaW5lcyBhIEZvdW5kYXRpb24gcGx1Z2luLCBhZGRpbmcgaXQgdG8gdGhlIGBGb3VuZGF0aW9uYCBuYW1lc3BhY2UgYW5kIHRoZSBsaXN0IG9mIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZSB3aGVuIHJlZmxvd2luZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcGx1Z2luLlxuICAgKi9cbiAgcGx1Z2luOiBmdW5jdGlvbihwbHVnaW4sIG5hbWUpIHtcbiAgICAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIGFkZGluZyB0byBnbG9iYWwgRm91bmRhdGlvbiBvYmplY3RcbiAgICAvLyBFeGFtcGxlczogRm91bmRhdGlvbi5SZXZlYWwsIEZvdW5kYXRpb24uT2ZmQ2FudmFzXG4gICAgdmFyIGNsYXNzTmFtZSA9IChuYW1lIHx8IGZ1bmN0aW9uTmFtZShwbHVnaW4pKTtcbiAgICAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIHN0b3JpbmcgdGhlIHBsdWdpbiwgYWxzbyB1c2VkIHRvIGNyZWF0ZSB0aGUgaWRlbnRpZnlpbmcgZGF0YSBhdHRyaWJ1dGUgZm9yIHRoZSBwbHVnaW5cbiAgICAvLyBFeGFtcGxlczogZGF0YS1yZXZlYWwsIGRhdGEtb2ZmLWNhbnZhc1xuICAgIHZhciBhdHRyTmFtZSAgPSBoeXBoZW5hdGUoY2xhc3NOYW1lKTtcblxuICAgIC8vIEFkZCB0byB0aGUgRm91bmRhdGlvbiBvYmplY3QgYW5kIHRoZSBwbHVnaW5zIGxpc3QgKGZvciByZWZsb3dpbmcpXG4gICAgdGhpcy5fcGx1Z2luc1thdHRyTmFtZV0gPSB0aGlzW2NsYXNzTmFtZV0gPSBwbHVnaW47XG4gIH0sXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogUG9wdWxhdGVzIHRoZSBfdXVpZHMgYXJyYXkgd2l0aCBwb2ludGVycyB0byBlYWNoIGluZGl2aWR1YWwgcGx1Z2luIGluc3RhbmNlLlxuICAgKiBBZGRzIHRoZSBgemZQbHVnaW5gIGRhdGEtYXR0cmlidXRlIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlZCBwbHVnaW5zIHRvIGFsbG93IHVzZSBvZiAkKHNlbGVjdG9yKS5mb3VuZGF0aW9uKG1ldGhvZCkgY2FsbHMuXG4gICAqIEFsc28gZmlyZXMgdGhlIGluaXRpYWxpemF0aW9uIGV2ZW50IGZvciBlYWNoIHBsdWdpbiwgY29uc29saWRhdGluZyByZXBlZGl0aXZlIGNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBhbiBpbnN0YW5jZSBvZiBhIHBsdWdpbiwgdXN1YWxseSBgdGhpc2AgaW4gY29udGV4dC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLCBwYXNzZWQgYXMgYSBjYW1lbENhc2VkIHN0cmluZy5cbiAgICogQGZpcmVzIFBsdWdpbiNpbml0XG4gICAqL1xuICByZWdpc3RlclBsdWdpbjogZnVuY3Rpb24ocGx1Z2luLCBuYW1lKXtcbiAgICB2YXIgcGx1Z2luTmFtZSA9IG5hbWUgPyBoeXBoZW5hdGUobmFtZSkgOiBmdW5jdGlvbk5hbWUocGx1Z2luLmNvbnN0cnVjdG9yKS50b0xvd2VyQ2FzZSgpO1xuICAgIHBsdWdpbi51dWlkID0gdGhpcy5HZXRZb0RpZ2l0cyg2LCBwbHVnaW5OYW1lKTtcblxuICAgIGlmKCFwbHVnaW4uJGVsZW1lbnQuYXR0cihgZGF0YS0ke3BsdWdpbk5hbWV9YCkpeyBwbHVnaW4uJGVsZW1lbnQuYXR0cihgZGF0YS0ke3BsdWdpbk5hbWV9YCwgcGx1Z2luLnV1aWQpOyB9XG4gICAgaWYoIXBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpKXsgcGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJywgcGx1Z2luKTsgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgaW5pdGlhbGl6ZWQuXG4gICAgICAgICAgICogQGV2ZW50IFBsdWdpbiNpbml0XG4gICAgICAgICAgICovXG4gICAgcGx1Z2luLiRlbGVtZW50LnRyaWdnZXIoYGluaXQuemYuJHtwbHVnaW5OYW1lfWApO1xuXG4gICAgdGhpcy5fdXVpZHMucHVzaChwbHVnaW4udXVpZCk7XG5cbiAgICByZXR1cm47XG4gIH0sXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogUmVtb3ZlcyB0aGUgcGx1Z2lucyB1dWlkIGZyb20gdGhlIF91dWlkcyBhcnJheS5cbiAgICogUmVtb3ZlcyB0aGUgemZQbHVnaW4gZGF0YSBhdHRyaWJ1dGUsIGFzIHdlbGwgYXMgdGhlIGRhdGEtcGx1Z2luLW5hbWUgYXR0cmlidXRlLlxuICAgKiBBbHNvIGZpcmVzIHRoZSBkZXN0cm95ZWQgZXZlbnQgZm9yIHRoZSBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZWRpdGl2ZSBjb2RlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIC0gYW4gaW5zdGFuY2Ugb2YgYSBwbHVnaW4sIHVzdWFsbHkgYHRoaXNgIGluIGNvbnRleHQuXG4gICAqIEBmaXJlcyBQbHVnaW4jZGVzdHJveWVkXG4gICAqL1xuICB1bnJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbihwbHVnaW4pe1xuICAgIHZhciBwbHVnaW5OYW1lID0gaHlwaGVuYXRlKGZ1bmN0aW9uTmFtZShwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nKS5jb25zdHJ1Y3RvcikpO1xuXG4gICAgdGhpcy5fdXVpZHMuc3BsaWNlKHRoaXMuX3V1aWRzLmluZGV4T2YocGx1Z2luLnV1aWQpLCAxKTtcbiAgICBwbHVnaW4uJGVsZW1lbnQucmVtb3ZlQXR0cihgZGF0YS0ke3BsdWdpbk5hbWV9YCkucmVtb3ZlRGF0YSgnemZQbHVnaW4nKVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgYmVlbiBkZXN0cm95ZWQuXG4gICAgICAgICAgICogQGV2ZW50IFBsdWdpbiNkZXN0cm95ZWRcbiAgICAgICAgICAgKi9cbiAgICAgICAgICAudHJpZ2dlcihgZGVzdHJveWVkLnpmLiR7cGx1Z2luTmFtZX1gKTtcbiAgICBmb3IodmFyIHByb3AgaW4gcGx1Z2luKXtcbiAgICAgIHBsdWdpbltwcm9wXSA9IG51bGw7Ly9jbGVhbiB1cCBzY3JpcHQgdG8gcHJlcCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgIH1cbiAgICByZXR1cm47XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBDYXVzZXMgb25lIG9yIG1vcmUgYWN0aXZlIHBsdWdpbnMgdG8gcmUtaW5pdGlhbGl6ZSwgcmVzZXR0aW5nIGV2ZW50IGxpc3RlbmVycywgcmVjYWxjdWxhdGluZyBwb3NpdGlvbnMsIGV0Yy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBsdWdpbnMgLSBvcHRpb25hbCBzdHJpbmcgb2YgYW4gaW5kaXZpZHVhbCBwbHVnaW4ga2V5LCBhdHRhaW5lZCBieSBjYWxsaW5nIGAkKGVsZW1lbnQpLmRhdGEoJ3BsdWdpbk5hbWUnKWAsIG9yIHN0cmluZyBvZiBhIHBsdWdpbiBjbGFzcyBpLmUuIGAnZHJvcGRvd24nYFxuICAgKiBAZGVmYXVsdCBJZiBubyBhcmd1bWVudCBpcyBwYXNzZWQsIHJlZmxvdyBhbGwgY3VycmVudGx5IGFjdGl2ZSBwbHVnaW5zLlxuICAgKi9cbiAgIHJlSW5pdDogZnVuY3Rpb24ocGx1Z2lucyl7XG4gICAgIHZhciBpc0pRID0gcGx1Z2lucyBpbnN0YW5jZW9mICQ7XG4gICAgIHRyeXtcbiAgICAgICBpZihpc0pRKXtcbiAgICAgICAgIHBsdWdpbnMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAkKHRoaXMpLmRhdGEoJ3pmUGx1Z2luJykuX2luaXQoKTtcbiAgICAgICAgIH0pO1xuICAgICAgIH1lbHNle1xuICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgcGx1Z2lucyxcbiAgICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgIGZucyA9IHtcbiAgICAgICAgICAgJ29iamVjdCc6IGZ1bmN0aW9uKHBsZ3Mpe1xuICAgICAgICAgICAgIHBsZ3MuZm9yRWFjaChmdW5jdGlvbihwKXtcbiAgICAgICAgICAgICAgIHAgPSBoeXBoZW5hdGUocCk7XG4gICAgICAgICAgICAgICAkKCdbZGF0YS0nKyBwICsnXScpLmZvdW5kYXRpb24oJ19pbml0Jyk7XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgICdzdHJpbmcnOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgIHBsdWdpbnMgPSBoeXBoZW5hdGUocGx1Z2lucyk7XG4gICAgICAgICAgICAgJCgnW2RhdGEtJysgcGx1Z2lucyArJ10nKS5mb3VuZGF0aW9uKCdfaW5pdCcpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICAndW5kZWZpbmVkJzogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICB0aGlzWydvYmplY3QnXShPYmplY3Qua2V5cyhfdGhpcy5fcGx1Z2lucykpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9O1xuICAgICAgICAgZm5zW3R5cGVdKHBsdWdpbnMpO1xuICAgICAgIH1cbiAgICAgfWNhdGNoKGVycil7XG4gICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICB9ZmluYWxseXtcbiAgICAgICByZXR1cm4gcGx1Z2lucztcbiAgICAgfVxuICAgfSxcblxuICAvKipcbiAgICogcmV0dXJucyBhIHJhbmRvbSBiYXNlLTM2IHVpZCB3aXRoIG5hbWVzcGFjaW5nXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gbnVtYmVyIG9mIHJhbmRvbSBiYXNlLTM2IGRpZ2l0cyBkZXNpcmVkLiBJbmNyZWFzZSBmb3IgbW9yZSByYW5kb20gc3RyaW5ncy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIG5hbWUgb2YgcGx1Z2luIHRvIGJlIGluY29ycG9yYXRlZCBpbiB1aWQsIG9wdGlvbmFsLlxuICAgKiBAZGVmYXVsdCB7U3RyaW5nfSAnJyAtIGlmIG5vIHBsdWdpbiBuYW1lIGlzIHByb3ZpZGVkLCBub3RoaW5nIGlzIGFwcGVuZGVkIHRvIHRoZSB1aWQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdW5pcXVlIGlkXG4gICAqL1xuICBHZXRZb0RpZ2l0czogZnVuY3Rpb24obGVuZ3RoLCBuYW1lc3BhY2Upe1xuICAgIGxlbmd0aCA9IGxlbmd0aCB8fCA2O1xuICAgIHJldHVybiBNYXRoLnJvdW5kKChNYXRoLnBvdygzNiwgbGVuZ3RoICsgMSkgLSBNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMzYsIGxlbmd0aCkpKS50b1N0cmluZygzNikuc2xpY2UoMSkgKyAobmFtZXNwYWNlID8gYC0ke25hbWVzcGFjZX1gIDogJycpO1xuICB9LFxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBwbHVnaW5zIG9uIGFueSBlbGVtZW50cyB3aXRoaW4gYGVsZW1gIChhbmQgYGVsZW1gIGl0c2VsZikgdGhhdCBhcmVuJ3QgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgdG8gY2hlY2sgaW5zaWRlLiBBbHNvIGNoZWNrcyB0aGUgZWxlbWVudCBpdHNlbGYsIHVubGVzcyBpdCdzIHRoZSBgZG9jdW1lbnRgIG9iamVjdC5cbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBsdWdpbnMgLSBBIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplLiBMZWF2ZSB0aGlzIG91dCB0byBpbml0aWFsaXplIGV2ZXJ5dGhpbmcuXG4gICAqL1xuICByZWZsb3c6IGZ1bmN0aW9uKGVsZW0sIHBsdWdpbnMpIHtcblxuICAgIC8vIElmIHBsdWdpbnMgaXMgdW5kZWZpbmVkLCBqdXN0IGdyYWIgZXZlcnl0aGluZ1xuICAgIGlmICh0eXBlb2YgcGx1Z2lucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBsdWdpbnMgPSBPYmplY3Qua2V5cyh0aGlzLl9wbHVnaW5zKTtcbiAgICB9XG4gICAgLy8gSWYgcGx1Z2lucyBpcyBhIHN0cmluZywgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIG9uZSBpdGVtXG4gICAgZWxzZSBpZiAodHlwZW9mIHBsdWdpbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwbHVnaW5zID0gW3BsdWdpbnNdO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBwbHVnaW5cbiAgICAkLmVhY2gocGx1Z2lucywgZnVuY3Rpb24oaSwgbmFtZSkge1xuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHBsdWdpblxuICAgICAgdmFyIHBsdWdpbiA9IF90aGlzLl9wbHVnaW5zW25hbWVdO1xuXG4gICAgICAvLyBMb2NhbGl6ZSB0aGUgc2VhcmNoIHRvIGFsbCBlbGVtZW50cyBpbnNpZGUgZWxlbSwgYXMgd2VsbCBhcyBlbGVtIGl0c2VsZiwgdW5sZXNzIGVsZW0gPT09IGRvY3VtZW50XG4gICAgICB2YXIgJGVsZW0gPSAkKGVsZW0pLmZpbmQoJ1tkYXRhLScrbmFtZSsnXScpLmFkZEJhY2soJ1tkYXRhLScrbmFtZSsnXScpO1xuXG4gICAgICAvLyBGb3IgZWFjaCBwbHVnaW4gZm91bmQsIGluaXRpYWxpemUgaXRcbiAgICAgICRlbGVtLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciAkZWwgPSAkKHRoaXMpLFxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICAvLyBEb24ndCBkb3VibGUtZGlwIG9uIHBsdWdpbnNcbiAgICAgICAgaWYgKCRlbC5kYXRhKCd6ZlBsdWdpbicpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gaW5pdGlhbGl6ZSBcIituYW1lK1wiIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIEZvdW5kYXRpb24gcGx1Z2luLlwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZigkZWwuYXR0cignZGF0YS1vcHRpb25zJykpe1xuICAgICAgICAgIHZhciB0aGluZyA9ICRlbC5hdHRyKCdkYXRhLW9wdGlvbnMnKS5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24oZSwgaSl7XG4gICAgICAgICAgICB2YXIgb3B0ID0gZS5zcGxpdCgnOicpLm1hcChmdW5jdGlvbihlbCl7IHJldHVybiBlbC50cmltKCk7IH0pO1xuICAgICAgICAgICAgaWYob3B0WzBdKSBvcHRzW29wdFswXV0gPSBwYXJzZVZhbHVlKG9wdFsxXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5e1xuICAgICAgICAgICRlbC5kYXRhKCd6ZlBsdWdpbicsIG5ldyBwbHVnaW4oJCh0aGlzKSwgb3B0cykpO1xuICAgICAgICB9Y2F0Y2goZXIpe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXIpO1xuICAgICAgICB9ZmluYWxseXtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBnZXRGbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgdHJhbnNpdGlvbmVuZDogZnVuY3Rpb24oJGVsZW0pe1xuICAgIHZhciB0cmFuc2l0aW9ucyA9IHtcbiAgICAgICd0cmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICAnTW96VHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgICdPVHJhbnNpdGlvbic6ICdvdHJhbnNpdGlvbmVuZCdcbiAgICB9O1xuICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgIGVuZDtcblxuICAgIGZvciAodmFyIHQgaW4gdHJhbnNpdGlvbnMpe1xuICAgICAgaWYgKHR5cGVvZiBlbGVtLnN0eWxlW3RdICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIGVuZCA9IHRyYW5zaXRpb25zW3RdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihlbmQpe1xuICAgICAgcmV0dXJuIGVuZDtcbiAgICB9ZWxzZXtcbiAgICAgIGVuZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgJGVsZW0udHJpZ2dlckhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLCBbJGVsZW1dKTtcbiAgICAgIH0sIDEpO1xuICAgICAgcmV0dXJuICd0cmFuc2l0aW9uZW5kJztcbiAgICB9XG4gIH1cbn07XG5cbkZvdW5kYXRpb24udXRpbCA9IHtcbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGZvciBhcHBseWluZyBhIGRlYm91bmNlIGVmZmVjdCB0byBhIGZ1bmN0aW9uIGNhbGwuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGF0IGVuZCBvZiB0aW1lb3V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXkgLSBUaW1lIGluIG1zIHRvIGRlbGF5IHRoZSBjYWxsIG9mIGBmdW5jYC5cbiAgICogQHJldHVybnMgZnVuY3Rpb25cbiAgICovXG4gIHRocm90dGxlOiBmdW5jdGlvbiAoZnVuYywgZGVsYXkpIHtcbiAgICB2YXIgdGltZXIgPSBudWxsO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgaWYgKHRpbWVyID09PSBudWxsKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vLyBUT0RPOiBjb25zaWRlciBub3QgbWFraW5nIHRoaXMgYSBqUXVlcnkgZnVuY3Rpb25cbi8vIFRPRE86IG5lZWQgd2F5IHRvIHJlZmxvdyB2cy4gcmUtaW5pdGlhbGl6ZVxuLyoqXG4gKiBUaGUgRm91bmRhdGlvbiBqUXVlcnkgbWV0aG9kLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IG1ldGhvZCAtIEFuIGFjdGlvbiB0byBwZXJmb3JtIG9uIHRoZSBjdXJyZW50IGpRdWVyeSBvYmplY3QuXG4gKi9cbnZhciBmb3VuZGF0aW9uID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIG1ldGhvZCxcbiAgICAgICRtZXRhID0gJCgnbWV0YS5mb3VuZGF0aW9uLW1xJyksXG4gICAgICAkbm9KUyA9ICQoJy5uby1qcycpO1xuXG4gIGlmKCEkbWV0YS5sZW5ndGgpe1xuICAgICQoJzxtZXRhIGNsYXNzPVwiZm91bmRhdGlvbi1tcVwiPicpLmFwcGVuZFRvKGRvY3VtZW50LmhlYWQpO1xuICB9XG4gIGlmKCRub0pTLmxlbmd0aCl7XG4gICAgJG5vSlMucmVtb3ZlQ2xhc3MoJ25vLWpzJyk7XG4gIH1cblxuICBpZih0eXBlID09PSAndW5kZWZpbmVkJyl7Ly9uZWVkcyB0byBpbml0aWFsaXplIHRoZSBGb3VuZGF0aW9uIG9iamVjdCwgb3IgYW4gaW5kaXZpZHVhbCBwbHVnaW4uXG4gICAgRm91bmRhdGlvbi5NZWRpYVF1ZXJ5Ll9pbml0KCk7XG4gICAgRm91bmRhdGlvbi5yZWZsb3codGhpcyk7XG4gIH1lbHNlIGlmKHR5cGUgPT09ICdzdHJpbmcnKXsvL2FuIGluZGl2aWR1YWwgbWV0aG9kIHRvIGludm9rZSBvbiBhIHBsdWdpbiBvciBncm91cCBvZiBwbHVnaW5zXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOy8vY29sbGVjdCBhbGwgdGhlIGFyZ3VtZW50cywgaWYgbmVjZXNzYXJ5XG4gICAgdmFyIHBsdWdDbGFzcyA9IHRoaXMuZGF0YSgnemZQbHVnaW4nKTsvL2RldGVybWluZSB0aGUgY2xhc3Mgb2YgcGx1Z2luXG5cbiAgICBpZihwbHVnQ2xhc3MgIT09IHVuZGVmaW5lZCAmJiBwbHVnQ2xhc3NbbWV0aG9kXSAhPT0gdW5kZWZpbmVkKXsvL21ha2Ugc3VyZSBib3RoIHRoZSBjbGFzcyBhbmQgbWV0aG9kIGV4aXN0XG4gICAgICBpZih0aGlzLmxlbmd0aCA9PT0gMSl7Ly9pZiB0aGVyZSdzIG9ubHkgb25lLCBjYWxsIGl0IGRpcmVjdGx5LlxuICAgICAgICAgIHBsdWdDbGFzc1ttZXRob2RdLmFwcGx5KHBsdWdDbGFzcywgYXJncyk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGksIGVsKXsvL290aGVyd2lzZSBsb29wIHRocm91Z2ggdGhlIGpRdWVyeSBjb2xsZWN0aW9uIGFuZCBpbnZva2UgdGhlIG1ldGhvZCBvbiBlYWNoXG4gICAgICAgICAgcGx1Z0NsYXNzW21ldGhvZF0uYXBwbHkoJChlbCkuZGF0YSgnemZQbHVnaW4nKSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1lbHNley8vZXJyb3IgZm9yIG5vIGNsYXNzIG9yIG5vIG1ldGhvZFxuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiV2UncmUgc29ycnksICdcIiArIG1ldGhvZCArIFwiJyBpcyBub3QgYW4gYXZhaWxhYmxlIG1ldGhvZCBmb3IgXCIgKyAocGx1Z0NsYXNzID8gZnVuY3Rpb25OYW1lKHBsdWdDbGFzcykgOiAndGhpcyBlbGVtZW50JykgKyAnLicpO1xuICAgIH1cbiAgfWVsc2V7Ly9lcnJvciBmb3IgaW52YWxpZCBhcmd1bWVudCB0eXBlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV2UncmUgc29ycnksICR7dHlwZX0gaXMgbm90IGEgdmFsaWQgcGFyYW1ldGVyLiBZb3UgbXVzdCB1c2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBtZXRob2QgeW91IHdpc2ggdG8gaW52b2tlLmApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxud2luZG93LkZvdW5kYXRpb24gPSBGb3VuZGF0aW9uO1xuJC5mbi5mb3VuZGF0aW9uID0gZm91bmRhdGlvbjtcblxuLy8gUG9seWZpbGwgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuKGZ1bmN0aW9uKCkge1xuICBpZiAoIURhdGUubm93IHx8ICF3aW5kb3cuRGF0ZS5ub3cpXG4gICAgd2luZG93LkRhdGUubm93ID0gRGF0ZS5ub3cgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuXG4gIHZhciB2ZW5kb3JzID0gWyd3ZWJraXQnLCAnbW96J107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsraSkge1xuICAgICAgdmFyIHZwID0gdmVuZG9yc1tpXTtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdnArJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gKHdpbmRvd1t2cCsnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93W3ZwKydDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSk7XG4gIH1cbiAgaWYgKC9pUChhZHxob25lfG9kKS4qT1MgNi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICB8fCAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAhd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBuZXh0VGltZSA9IE1hdGgubWF4KGxhc3RUaW1lICsgMTYsIG5vdyk7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhsYXN0VGltZSA9IG5leHRUaW1lKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFRpbWUgLSBub3cpO1xuICAgIH07XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2xlYXJUaW1lb3V0O1xuICB9XG4gIC8qKlxuICAgKiBQb2x5ZmlsbCBmb3IgcGVyZm9ybWFuY2Uubm93LCByZXF1aXJlZCBieSByQUZcbiAgICovXG4gIGlmKCF3aW5kb3cucGVyZm9ybWFuY2UgfHwgIXdpbmRvdy5wZXJmb3JtYW5jZS5ub3cpe1xuICAgIHdpbmRvdy5wZXJmb3JtYW5jZSA9IHtcbiAgICAgIHN0YXJ0OiBEYXRlLm5vdygpLFxuICAgICAgbm93OiBmdW5jdGlvbigpeyByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnQ7IH1cbiAgICB9O1xuICB9XG59KSgpO1xuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKG9UaGlzKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDVcbiAgICAgIC8vIGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgfVxuXG4gICAgdmFyIGFBcmdzICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgZk5PUCAgICA9IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIGZCb3VuZCAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUFxuICAgICAgICAgICAgICAgICA/IHRoaXNcbiAgICAgICAgICAgICAgICAgOiBvVGhpcyxcbiAgICAgICAgICAgICAgICAgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcblxuICAgIGlmICh0aGlzLnByb3RvdHlwZSkge1xuICAgICAgLy8gbmF0aXZlIGZ1bmN0aW9ucyBkb24ndCBoYXZlIGEgcHJvdG90eXBlXG4gICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgIH1cbiAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcblxuICAgIHJldHVybiBmQm91bmQ7XG4gIH07XG59XG4vLyBQb2x5ZmlsbCB0byBnZXQgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbiBpbiBJRTlcbmZ1bmN0aW9uIGZ1bmN0aW9uTmFtZShmbikge1xuICBpZiAoRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmdW5jTmFtZVJlZ2V4ID0gL2Z1bmN0aW9uXFxzKFteKF17MSx9KVxcKC87XG4gICAgdmFyIHJlc3VsdHMgPSAoZnVuY05hbWVSZWdleCkuZXhlYygoZm4pLnRvU3RyaW5nKCkpO1xuICAgIHJldHVybiAocmVzdWx0cyAmJiByZXN1bHRzLmxlbmd0aCA+IDEpID8gcmVzdWx0c1sxXS50cmltKCkgOiBcIlwiO1xuICB9XG4gIGVsc2UgaWYgKGZuLnByb3RvdHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZuLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlKHN0cil7XG4gIGlmKC90cnVlLy50ZXN0KHN0cikpIHJldHVybiB0cnVlO1xuICBlbHNlIGlmKC9mYWxzZS8udGVzdChzdHIpKSByZXR1cm4gZmFsc2U7XG4gIGVsc2UgaWYoIWlzTmFOKHN0ciAqIDEpKSByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuLy8gQ29udmVydCBQYXNjYWxDYXNlIHRvIGtlYmFiLWNhc2Vcbi8vIFRoYW5rIHlvdTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODk1NTU4MFxuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG59XG5cbn0oalF1ZXJ5KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uKCQpIHtcblxuRm91bmRhdGlvbi5Cb3ggPSB7XG4gIEltTm90VG91Y2hpbmdZb3U6IEltTm90VG91Y2hpbmdZb3UsXG4gIEdldERpbWVuc2lvbnM6IEdldERpbWVuc2lvbnMsXG4gIEdldE9mZnNldHM6IEdldE9mZnNldHNcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50IHRvIGEgY29udGFpbmVyIGFuZCBkZXRlcm1pbmVzIGNvbGxpc2lvbiBldmVudHMgd2l0aCBjb250YWluZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byB0ZXN0IGZvciBjb2xsaXNpb25zLlxuICogQHBhcmFtIHtqUXVlcnl9IHBhcmVudCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGFzIGJvdW5kaW5nIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbHJPbmx5IC0gc2V0IHRvIHRydWUgdG8gY2hlY2sgbGVmdCBhbmQgcmlnaHQgdmFsdWVzIG9ubHkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRiT25seSAtIHNldCB0byB0cnVlIHRvIGNoZWNrIHRvcCBhbmQgYm90dG9tIHZhbHVlcyBvbmx5LlxuICogQGRlZmF1bHQgaWYgbm8gcGFyZW50IG9iamVjdCBwYXNzZWQsIGRldGVjdHMgY29sbGlzaW9ucyB3aXRoIGB3aW5kb3dgLlxuICogQHJldHVybnMge0Jvb2xlYW59IC0gdHJ1ZSBpZiBjb2xsaXNpb24gZnJlZSwgZmFsc2UgaWYgYSBjb2xsaXNpb24gaW4gYW55IGRpcmVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gSW1Ob3RUb3VjaGluZ1lvdShlbGVtZW50LCBwYXJlbnQsIGxyT25seSwgdGJPbmx5KSB7XG4gIHZhciBlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcbiAgICAgIHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodDtcblxuICBpZiAocGFyZW50KSB7XG4gICAgdmFyIHBhckRpbXMgPSBHZXREaW1lbnNpb25zKHBhcmVudCk7XG5cbiAgICBib3R0b20gPSAoZWxlRGltcy5vZmZzZXQudG9wICsgZWxlRGltcy5oZWlnaHQgPD0gcGFyRGltcy5oZWlnaHQgKyBwYXJEaW1zLm9mZnNldC50b3ApO1xuICAgIHRvcCAgICA9IChlbGVEaW1zLm9mZnNldC50b3AgPj0gcGFyRGltcy5vZmZzZXQudG9wKTtcbiAgICBsZWZ0ICAgPSAoZWxlRGltcy5vZmZzZXQubGVmdCA+PSBwYXJEaW1zLm9mZnNldC5sZWZ0KTtcbiAgICByaWdodCAgPSAoZWxlRGltcy5vZmZzZXQubGVmdCArIGVsZURpbXMud2lkdGggPD0gcGFyRGltcy53aWR0aCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgYm90dG9tID0gKGVsZURpbXMub2Zmc2V0LnRvcCArIGVsZURpbXMuaGVpZ2h0IDw9IGVsZURpbXMud2luZG93RGltcy5oZWlnaHQgKyBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCk7XG4gICAgdG9wICAgID0gKGVsZURpbXMub2Zmc2V0LnRvcCA+PSBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCk7XG4gICAgbGVmdCAgID0gKGVsZURpbXMub2Zmc2V0LmxlZnQgPj0gZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC5sZWZ0KTtcbiAgICByaWdodCAgPSAoZWxlRGltcy5vZmZzZXQubGVmdCArIGVsZURpbXMud2lkdGggPD0gZWxlRGltcy53aW5kb3dEaW1zLndpZHRoKTtcbiAgfVxuXG4gIHZhciBhbGxEaXJzID0gW2JvdHRvbSwgdG9wLCBsZWZ0LCByaWdodF07XG5cbiAgaWYgKGxyT25seSkge1xuICAgIHJldHVybiBsZWZ0ID09PSByaWdodCA9PT0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0Yk9ubHkpIHtcbiAgICByZXR1cm4gdG9wID09PSBib3R0b20gPT09IHRydWU7XG4gIH1cblxuICByZXR1cm4gYWxsRGlycy5pbmRleE9mKGZhbHNlKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFVzZXMgbmF0aXZlIG1ldGhvZHMgdG8gcmV0dXJuIGFuIG9iamVjdCBvZiBkaW1lbnNpb24gdmFsdWVzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2pRdWVyeSB8fCBIVE1MfSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCBvciBET00gZWxlbWVudCBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBkaW1lbnNpb25zLiBDYW4gYmUgYW55IGVsZW1lbnQgb3RoZXIgdGhhdCBkb2N1bWVudCBvciB3aW5kb3cuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIG5lc3RlZCBvYmplY3Qgb2YgaW50ZWdlciBwaXhlbCB2YWx1ZXNcbiAqIFRPRE8gLSBpZiBlbGVtZW50IGlzIHdpbmRvdywgcmV0dXJuIG9ubHkgdGhvc2UgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBHZXREaW1lbnNpb25zKGVsZW0sIHRlc3Qpe1xuICBlbGVtID0gZWxlbS5sZW5ndGggPyBlbGVtWzBdIDogZWxlbTtcblxuICBpZiAoZWxlbSA9PT0gd2luZG93IHx8IGVsZW0gPT09IGRvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSSdtIHNvcnJ5LCBEYXZlLiBJJ20gYWZyYWlkIEkgY2FuJ3QgZG8gdGhhdC5cIik7XG4gIH1cblxuICB2YXIgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBwYXJSZWN0ID0gZWxlbS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgd2luUmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB3aW5ZID0gd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgd2luWCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgb2Zmc2V0OiB7XG4gICAgICB0b3A6IHJlY3QudG9wICsgd2luWSxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpblhcbiAgICB9LFxuICAgIHBhcmVudERpbXM6IHtcbiAgICAgIHdpZHRoOiBwYXJSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJSZWN0LmhlaWdodCxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICB0b3A6IHBhclJlY3QudG9wICsgd2luWSxcbiAgICAgICAgbGVmdDogcGFyUmVjdC5sZWZ0ICsgd2luWFxuICAgICAgfVxuICAgIH0sXG4gICAgd2luZG93RGltczoge1xuICAgICAgd2lkdGg6IHdpblJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHdpblJlY3QuaGVpZ2h0LFxuICAgICAgb2Zmc2V0OiB7XG4gICAgICAgIHRvcDogd2luWSxcbiAgICAgICAgbGVmdDogd2luWFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHRvcCBhbmQgbGVmdCBpbnRlZ2VyIHBpeGVsIHZhbHVlcyBmb3IgZHluYW1pY2FsbHkgcmVuZGVyZWQgZWxlbWVudHMsXG4gKiBzdWNoIGFzOiBUb29sdGlwLCBSZXZlYWwsIGFuZCBEcm9wZG93blxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgZm9yIHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gKiBAcGFyYW0ge2pRdWVyeX0gYW5jaG9yIC0galF1ZXJ5IG9iamVjdCBmb3IgdGhlIGVsZW1lbnQncyBhbmNob3IgcG9pbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBhIHN0cmluZyByZWxhdGluZyB0byB0aGUgZGVzaXJlZCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCwgcmVsYXRpdmUgdG8gaXQncyBhbmNob3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB2T2Zmc2V0IC0gaW50ZWdlciBwaXhlbCB2YWx1ZSBvZiBkZXNpcmVkIHZlcnRpY2FsIHNlcGFyYXRpb24gYmV0d2VlbiBhbmNob3IgYW5kIGVsZW1lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gaE9mZnNldCAtIGludGVnZXIgcGl4ZWwgdmFsdWUgb2YgZGVzaXJlZCBob3Jpem9udGFsIHNlcGFyYXRpb24gYmV0d2VlbiBhbmNob3IgYW5kIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3ZlcmZsb3cgLSBpZiBhIGNvbGxpc2lvbiBldmVudCBpcyBkZXRlY3RlZCwgc2V0cyB0byB0cnVlIHRvIGRlZmF1bHQgdGhlIGVsZW1lbnQgdG8gZnVsbCB3aWR0aCAtIGFueSBkZXNpcmVkIG9mZnNldC5cbiAqIFRPRE8gYWx0ZXIvcmV3cml0ZSB0byB3b3JrIHdpdGggYGVtYCB2YWx1ZXMgYXMgd2VsbC9pbnN0ZWFkIG9mIHBpeGVsc1xuICovXG5mdW5jdGlvbiBHZXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgcG9zaXRpb24sIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpIHtcbiAgdmFyICRlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcbiAgICAgICRhbmNob3JEaW1zID0gYW5jaG9yID8gR2V0RGltZW5zaW9ucyhhbmNob3IpIDogbnVsbDtcblxuICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IChGb3VuZGF0aW9uLnJ0bCgpID8gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAkZWxlRGltcy53aWR0aCArICRhbmNob3JEaW1zLndpZHRoIDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQpLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgLSAoJGVsZURpbXMuaGVpZ2h0ICsgdk9mZnNldClcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAoJGVsZURpbXMud2lkdGggKyBoT2Zmc2V0KSxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoICsgaE9mZnNldCxcbiAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXIgdG9wJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICgkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICgkYW5jaG9yRGltcy53aWR0aCAvIDIpKSAtICgkZWxlRGltcy53aWR0aCAvIDIpLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgLSAoJGVsZURpbXMuaGVpZ2h0ICsgdk9mZnNldClcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogaXNPdmVyZmxvdyA/IGhPZmZzZXQgOiAoKCRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgKCRhbmNob3JEaW1zLndpZHRoIC8gMikpIC0gKCRlbGVEaW1zLndpZHRoIC8gMikpLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgKyB2T2Zmc2V0XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXIgbGVmdCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICgkZWxlRGltcy53aWR0aCArIGhPZmZzZXQpLFxuICAgICAgICB0b3A6ICgkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgKCRhbmNob3JEaW1zLmhlaWdodCAvIDIpKSAtICgkZWxlRGltcy5oZWlnaHQgLyAyKVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2VudGVyIHJpZ2h0JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggKyBoT2Zmc2V0ICsgMSxcbiAgICAgICAgdG9wOiAoJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICgkYW5jaG9yRGltcy5oZWlnaHQgLyAyKSkgLSAoJGVsZURpbXMuaGVpZ2h0IC8gMilcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAoJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCArICgkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC8gMikpIC0gKCRlbGVEaW1zLndpZHRoIC8gMiksXG4gICAgICAgIHRvcDogKCRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCArICgkZWxlRGltcy53aW5kb3dEaW1zLmhlaWdodCAvIDIpKSAtICgkZWxlRGltcy5oZWlnaHQgLyAyKVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmV2ZWFsJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICgkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC0gJGVsZURpbXMud2lkdGgpIC8gMixcbiAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3AgKyB2T2Zmc2V0XG4gICAgICB9XG4gICAgY2FzZSAncmV2ZWFsIGZ1bGwnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCxcbiAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3BcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gKCRlbGVEaW1zLndpZHRoICsgaE9mZnNldCksXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0IGJvdHRvbSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoICsgaE9mZnNldCAtICRlbGVEaW1zLndpZHRoLFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogKEZvdW5kYXRpb24ucnRsKCkgPyAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICRlbGVEaW1zLndpZHRoICsgJGFuY2hvckRpbXMud2lkdGggOiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCksXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXRcbiAgICAgIH1cbiAgfVxufVxuXG59KGpRdWVyeSk7XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIFRoaXMgdXRpbCB3YXMgY3JlYXRlZCBieSBNYXJpdXMgT2xiZXJ0eiAqXG4gKiBQbGVhc2UgdGhhbmsgTWFyaXVzIG9uIEdpdEh1YiAvb3dsYmVydHogKlxuICogb3IgdGhlIHdlYiBodHRwOi8vd3d3Lm1hcml1c29sYmVydHouZGUvICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4ndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbmNvbnN0IGtleUNvZGVzID0ge1xuICA5OiAnVEFCJyxcbiAgMTM6ICdFTlRFUicsXG4gIDI3OiAnRVNDQVBFJyxcbiAgMzI6ICdTUEFDRScsXG4gIDM3OiAnQVJST1dfTEVGVCcsXG4gIDM4OiAnQVJST1dfVVAnLFxuICAzOTogJ0FSUk9XX1JJR0hUJyxcbiAgNDA6ICdBUlJPV19ET1dOJ1xufVxuXG52YXIgY29tbWFuZHMgPSB7fVxuXG52YXIgS2V5Ym9hcmQgPSB7XG4gIGtleXM6IGdldEtleUNvZGVzKGtleUNvZGVzKSxcblxuICAvKipcbiAgICogUGFyc2VzIHRoZSAoa2V5Ym9hcmQpIGV2ZW50IGFuZCByZXR1cm5zIGEgU3RyaW5nIHRoYXQgcmVwcmVzZW50cyBpdHMga2V5XG4gICAqIENhbiBiZSB1c2VkIGxpa2UgRm91bmRhdGlvbi5wYXJzZUtleShldmVudCkgPT09IEZvdW5kYXRpb24ua2V5cy5TUEFDRVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIHRoZSBldmVudCBnZW5lcmF0ZWQgYnkgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICogQHJldHVybiBTdHJpbmcga2V5IC0gU3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUga2V5IHByZXNzZWRcbiAgICovXG4gIHBhcnNlS2V5KGV2ZW50KSB7XG4gICAgdmFyIGtleSA9IGtleUNvZGVzW2V2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVdIHx8IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQud2hpY2gpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSBrZXkgPSBgU0hJRlRfJHtrZXl9YDtcbiAgICBpZiAoZXZlbnQuY3RybEtleSkga2V5ID0gYENUUkxfJHtrZXl9YDtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KSBrZXkgPSBgQUxUXyR7a2V5fWA7XG4gICAgcmV0dXJuIGtleTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZ2l2ZW4gKGtleWJvYXJkKSBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIHRoZSBldmVudCBnZW5lcmF0ZWQgYnkgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAtIEZvdW5kYXRpb24gY29tcG9uZW50J3MgbmFtZSwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXG4gICAqIEBwYXJhbSB7T2JqZWN0c30gZnVuY3Rpb25zIC0gY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgdG8gYmUgZXhlY3V0ZWRcbiAgICovXG4gIGhhbmRsZUtleShldmVudCwgY29tcG9uZW50LCBmdW5jdGlvbnMpIHtcbiAgICB2YXIgY29tbWFuZExpc3QgPSBjb21tYW5kc1tjb21wb25lbnRdLFxuICAgICAga2V5Q29kZSA9IHRoaXMucGFyc2VLZXkoZXZlbnQpLFxuICAgICAgY21kcyxcbiAgICAgIGNvbW1hbmQsXG4gICAgICBmbjtcblxuICAgIGlmICghY29tbWFuZExpc3QpIHJldHVybiBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCBub3QgZGVmaW5lZCEnKTtcblxuICAgIGlmICh0eXBlb2YgY29tbWFuZExpc3QubHRyID09PSAndW5kZWZpbmVkJykgeyAvLyB0aGlzIGNvbXBvbmVudCBkb2VzIG5vdCBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbHRyIGFuZCBydGxcbiAgICAgICAgY21kcyA9IGNvbW1hbmRMaXN0OyAvLyB1c2UgcGxhaW4gbGlzdFxuICAgIH0gZWxzZSB7IC8vIG1lcmdlIGx0ciBhbmQgcnRsOiBpZiBkb2N1bWVudCBpcyBydGwsIHJ0bCBvdmVyd3JpdGVzIGx0ciBhbmQgdmljZSB2ZXJzYVxuICAgICAgICBpZiAoRm91bmRhdGlvbi5ydGwoKSkgY21kcyA9ICQuZXh0ZW5kKHt9LCBjb21tYW5kTGlzdC5sdHIsIGNvbW1hbmRMaXN0LnJ0bCk7XG5cbiAgICAgICAgZWxzZSBjbWRzID0gJC5leHRlbmQoe30sIGNvbW1hbmRMaXN0LnJ0bCwgY29tbWFuZExpc3QubHRyKTtcbiAgICB9XG4gICAgY29tbWFuZCA9IGNtZHNba2V5Q29kZV07XG5cbiAgICBmbiA9IGZ1bmN0aW9uc1tjb21tYW5kXTtcbiAgICBpZiAoZm4gJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7IC8vIGV4ZWN1dGUgZnVuY3Rpb24gIGlmIGV4aXN0c1xuICAgICAgZm4uYXBwbHkoKTtcbiAgICAgIGlmIChmdW5jdGlvbnMuaGFuZGxlZCB8fCB0eXBlb2YgZnVuY3Rpb25zLmhhbmRsZWQgPT09ICdmdW5jdGlvbicpIHsgLy8gZXhlY3V0ZSBmdW5jdGlvbiB3aGVuIGV2ZW50IHdhcyBoYW5kbGVkXG4gICAgICAgICAgZnVuY3Rpb25zLmhhbmRsZWQuYXBwbHkoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZ1bmN0aW9ucy51bmhhbmRsZWQgfHwgdHlwZW9mIGZ1bmN0aW9ucy51bmhhbmRsZWQgPT09ICdmdW5jdGlvbicpIHsgLy8gZXhlY3V0ZSBmdW5jdGlvbiB3aGVuIGV2ZW50IHdhcyBub3QgaGFuZGxlZFxuICAgICAgICAgIGZ1bmN0aW9ucy51bmhhbmRsZWQuYXBwbHkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIHRoZSBnaXZlbiBgJGVsZW1lbnRgXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gc2VhcmNoIHdpdGhpblxuICAgKiBAcmV0dXJuIHtqUXVlcnl9ICRmb2N1c2FibGUgLSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGhpbiBgJGVsZW1lbnRgXG4gICAqL1xuICBmaW5kRm9jdXNhYmxlKCRlbGVtZW50KSB7XG4gICAgcmV0dXJuICRlbGVtZW50LmZpbmQoJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCBidXR0b246bm90KFtkaXNhYmxlZF0pLCBpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdLCAqW2NvbnRlbnRlZGl0YWJsZV0nKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoISQodGhpcykuaXMoJzp2aXNpYmxlJykgfHwgJCh0aGlzKS5hdHRyKCd0YWJpbmRleCcpIDwgMCkgeyByZXR1cm4gZmFsc2U7IH0gLy9vbmx5IGhhdmUgdmlzaWJsZSBlbGVtZW50cyBhbmQgdGhvc2UgdGhhdCBoYXZlIGEgdGFiaW5kZXggZ3JlYXRlciBvciBlcXVhbCAwXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29tcG9uZW50IG5hbWUgbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IC0gRm91bmRhdGlvbiBjb21wb25lbnQsIGUuZy4gU2xpZGVyIG9yIFJldmVhbFxuICAgKiBAcmV0dXJuIFN0cmluZyBjb21wb25lbnROYW1lXG4gICAqL1xuXG4gIHJlZ2lzdGVyKGNvbXBvbmVudE5hbWUsIGNtZHMpIHtcbiAgICBjb21tYW5kc1tjb21wb25lbnROYW1lXSA9IGNtZHM7XG4gIH1cbn1cblxuLypcbiAqIENvbnN0YW50cyBmb3IgZWFzaWVyIGNvbXBhcmluZy5cbiAqIENhbiBiZSB1c2VkIGxpa2UgRm91bmRhdGlvbi5wYXJzZUtleShldmVudCkgPT09IEZvdW5kYXRpb24ua2V5cy5TUEFDRVxuICovXG5mdW5jdGlvbiBnZXRLZXlDb2RlcyhrY3MpIHtcbiAgdmFyIGsgPSB7fTtcbiAgZm9yICh2YXIga2MgaW4ga2NzKSBrW2tjc1trY11dID0ga2NzW2tjXTtcbiAgcmV0dXJuIGs7XG59XG5cbkZvdW5kYXRpb24uS2V5Ym9hcmQgPSBLZXlib2FyZDtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vLyBEZWZhdWx0IHNldCBvZiBtZWRpYSBxdWVyaWVzXG5jb25zdCBkZWZhdWx0UXVlcmllcyA9IHtcbiAgJ2RlZmF1bHQnIDogJ29ubHkgc2NyZWVuJyxcbiAgbGFuZHNjYXBlIDogJ29ubHkgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxuICBwb3J0cmFpdCA6ICdvbmx5IHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknLFxuICByZXRpbmEgOiAnb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCcgK1xuICAgICdvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMiksJyArXG4gICAgJ29ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMi8xKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTkyZHBpKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMmRwcHgpJ1xufTtcblxudmFyIE1lZGlhUXVlcnkgPSB7XG4gIHF1ZXJpZXM6IFtdLFxuXG4gIGN1cnJlbnQ6ICcnLFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbWVkaWEgcXVlcnkgaGVscGVyLCBieSBleHRyYWN0aW5nIHRoZSBicmVha3BvaW50IGxpc3QgZnJvbSB0aGUgQ1NTIGFuZCBhY3RpdmF0aW5nIHRoZSBicmVha3BvaW50IHdhdGNoZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBleHRyYWN0ZWRTdHlsZXMgPSAkKCcuZm91bmRhdGlvbi1tcScpLmNzcygnZm9udC1mYW1pbHknKTtcbiAgICB2YXIgbmFtZWRRdWVyaWVzO1xuXG4gICAgbmFtZWRRdWVyaWVzID0gcGFyc2VTdHlsZVRvT2JqZWN0KGV4dHJhY3RlZFN0eWxlcyk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZWRRdWVyaWVzKSB7XG4gICAgICBzZWxmLnF1ZXJpZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgdmFsdWU6IGBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogJHtuYW1lZFF1ZXJpZXNba2V5XX0pYFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKTtcblxuICAgIHRoaXMuX3dhdGNoZXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gaXMgYXQgbGVhc3QgYXMgd2lkZSBhcyBhIGJyZWFrcG9pbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGJyZWFrcG9pbnQgbWF0Y2hlcywgYGZhbHNlYCBpZiBpdCdzIHNtYWxsZXIuXG4gICAqL1xuICBhdExlYXN0KHNpemUpIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLmdldChzaXplKTtcblxuICAgIGlmIChxdWVyeSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KS5tYXRjaGVzO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgbWVkaWEgcXVlcnkgb2YgYSBicmVha3BvaW50LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50IHRvIGdldC5cbiAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSAtIFRoZSBtZWRpYSBxdWVyeSBvZiB0aGUgYnJlYWtwb2ludCwgb3IgYG51bGxgIGlmIHRoZSBicmVha3BvaW50IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBnZXQoc2l6ZSkge1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5xdWVyaWVzKSB7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJpZXNbaV07XG4gICAgICBpZiAoc2l6ZSA9PT0gcXVlcnkubmFtZSkgcmV0dXJuIHF1ZXJ5LnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgbmFtZSBieSB0ZXN0aW5nIGV2ZXJ5IGJyZWFrcG9pbnQgYW5kIHJldHVybmluZyB0aGUgbGFzdCBvbmUgdG8gbWF0Y2ggKHRoZSBiaWdnZXN0IG9uZSkuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBOYW1lIG9mIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQuXG4gICAqL1xuICBfZ2V0Q3VycmVudFNpemUoKSB7XG4gICAgdmFyIG1hdGNoZWQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xuXG4gICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEocXVlcnkudmFsdWUpLm1hdGNoZXMpIHtcbiAgICAgICAgbWF0Y2hlZCA9IHF1ZXJ5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbWF0Y2hlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBtYXRjaGVkLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBicmVha3BvaW50IHdhdGNoZXIsIHdoaWNoIGZpcmVzIGFuIGV2ZW50IG9uIHRoZSB3aW5kb3cgd2hlbmV2ZXIgdGhlIGJyZWFrcG9pbnQgY2hhbmdlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd2F0Y2hlcigpIHtcbiAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS56Zi5tZWRpYXF1ZXJ5JywgKCkgPT4ge1xuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLl9nZXRDdXJyZW50U2l6ZSgpO1xuXG4gICAgICBpZiAobmV3U2l6ZSAhPT0gdGhpcy5jdXJyZW50KSB7XG4gICAgICAgIC8vIEJyb2FkY2FzdCB0aGUgbWVkaWEgcXVlcnkgY2hhbmdlIG9uIHRoZSB3aW5kb3dcbiAgICAgICAgJCh3aW5kb3cpLnRyaWdnZXIoJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIFtuZXdTaXplLCB0aGlzLmN1cnJlbnRdKTtcblxuICAgICAgICAvLyBDaGFuZ2UgdGhlIGN1cnJlbnQgbWVkaWEgcXVlcnlcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3U2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuRm91bmRhdGlvbi5NZWRpYVF1ZXJ5ID0gTWVkaWFRdWVyeTtcblxuLy8gbWF0Y2hNZWRpYSgpIHBvbHlmaWxsIC0gVGVzdCBhIENTUyBtZWRpYSB0eXBlL3F1ZXJ5IGluIEpTLlxuLy8gQXV0aG9ycyAmIGNvcHlyaWdodCAoYykgMjAxMjogU2NvdHQgSmVobCwgUGF1bCBJcmlzaCwgTmljaG9sYXMgWmFrYXMsIERhdmlkIEtuaWdodC4gRHVhbCBNSVQvQlNEIGxpY2Vuc2VcbndpbmRvdy5tYXRjaE1lZGlhIHx8ICh3aW5kb3cubWF0Y2hNZWRpYSA9IGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBtYXRjaE1lZGl1bSBhcGkgc3VjaCBhcyBJRSA5IGFuZCB3ZWJraXRcbiAgdmFyIHN0eWxlTWVkaWEgPSAod2luZG93LnN0eWxlTWVkaWEgfHwgd2luZG93Lm1lZGlhKTtcblxuICAvLyBGb3IgdGhvc2UgdGhhdCBkb24ndCBzdXBwb3J0IG1hdGNoTWVkaXVtXG4gIGlmICghc3R5bGVNZWRpYSkge1xuICAgIHZhciBzdHlsZSAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKSxcbiAgICBzY3JpcHQgICAgICA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXSxcbiAgICBpbmZvICAgICAgICA9IG51bGw7XG5cbiAgICBzdHlsZS50eXBlICA9ICd0ZXh0L2Nzcyc7XG4gICAgc3R5bGUuaWQgICAgPSAnbWF0Y2htZWRpYWpzLXRlc3QnO1xuXG4gICAgc2NyaXB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLCBzY3JpcHQpO1xuXG4gICAgLy8gJ3N0eWxlLmN1cnJlbnRTdHlsZScgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnd2luZG93LmdldENvbXB1dGVkU3R5bGUnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcbiAgICBpbmZvID0gKCdnZXRDb21wdXRlZFN0eWxlJyBpbiB3aW5kb3cpICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHN0eWxlLCBudWxsKSB8fCBzdHlsZS5jdXJyZW50U3R5bGU7XG5cbiAgICBzdHlsZU1lZGlhID0ge1xuICAgICAgbWF0Y2hNZWRpdW0obWVkaWEpIHtcbiAgICAgICAgdmFyIHRleHQgPSBgQG1lZGlhICR7bWVkaWF9eyAjbWF0Y2htZWRpYWpzLXRlc3QgeyB3aWR0aDogMXB4OyB9IH1gO1xuXG4gICAgICAgIC8vICdzdHlsZS5zdHlsZVNoZWV0JyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICdzdHlsZS50ZXh0Q29udGVudCcgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuICAgICAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCBpZiBtZWRpYSBxdWVyeSBpcyB0cnVlIG9yIGZhbHNlXG4gICAgICAgIHJldHVybiBpbmZvLndpZHRoID09PSAnMXB4JztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24obWVkaWEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2hlczogc3R5bGVNZWRpYS5tYXRjaE1lZGl1bShtZWRpYSB8fCAnYWxsJyksXG4gICAgICBtZWRpYTogbWVkaWEgfHwgJ2FsbCdcbiAgICB9O1xuICB9XG59KCkpO1xuXG4vLyBUaGFuayB5b3U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nXG5mdW5jdGlvbiBwYXJzZVN0eWxlVG9PYmplY3Qoc3RyKSB7XG4gIHZhciBzdHlsZU9iamVjdCA9IHt9O1xuXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHlsZU9iamVjdDtcbiAgfVxuXG4gIHN0ciA9IHN0ci50cmltKCkuc2xpY2UoMSwgLTEpOyAvLyBicm93c2VycyByZS1xdW90ZSBzdHJpbmcgc3R5bGUgdmFsdWVzXG5cbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gIH1cblxuICBzdHlsZU9iamVjdCA9IHN0ci5zcGxpdCgnJicpLnJlZHVjZShmdW5jdGlvbihyZXQsIHBhcmFtKSB7XG4gICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcbiAgICB2YXIga2V5ID0gcGFydHNbMF07XG4gICAgdmFyIHZhbCA9IHBhcnRzWzFdO1xuICAgIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpO1xuXG4gICAgLy8gbWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcbiAgICAvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG4gICAgdmFsID0gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XG5cbiAgICBpZiAoIXJldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXRba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0W2tleV0pKSB7XG4gICAgICByZXRba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFtrZXldID0gW3JldFtrZXldLCB2YWxdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIHN0eWxlT2JqZWN0O1xufVxuXG5Gb3VuZGF0aW9uLk1lZGlhUXVlcnkgPSBNZWRpYVF1ZXJ5O1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogTW90aW9uIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5tb3Rpb25cbiAqL1xuXG5jb25zdCBpbml0Q2xhc3NlcyAgID0gWydtdWktZW50ZXInLCAnbXVpLWxlYXZlJ107XG5jb25zdCBhY3RpdmVDbGFzc2VzID0gWydtdWktZW50ZXItYWN0aXZlJywgJ211aS1sZWF2ZS1hY3RpdmUnXTtcblxuY29uc3QgTW90aW9uID0ge1xuICBhbmltYXRlSW46IGZ1bmN0aW9uKGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcbiAgICBhbmltYXRlKHRydWUsIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpO1xuICB9LFxuXG4gIGFuaW1hdGVPdXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcbiAgICBhbmltYXRlKGZhbHNlLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBNb3ZlKGR1cmF0aW9uLCBlbGVtLCBmbil7XG4gIHZhciBhbmltLCBwcm9nLCBzdGFydCA9IG51bGw7XG4gIC8vIGNvbnNvbGUubG9nKCdjYWxsZWQnKTtcblxuICBmdW5jdGlvbiBtb3ZlKHRzKXtcbiAgICBpZighc3RhcnQpIHN0YXJ0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIC8vIGNvbnNvbGUubG9nKHN0YXJ0LCB0cyk7XG4gICAgcHJvZyA9IHRzIC0gc3RhcnQ7XG4gICAgZm4uYXBwbHkoZWxlbSk7XG5cbiAgICBpZihwcm9nIDwgZHVyYXRpb24peyBhbmltID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtb3ZlLCBlbGVtKTsgfVxuICAgIGVsc2V7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbSk7XG4gICAgICBlbGVtLnRyaWdnZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pLnRyaWdnZXJIYW5kbGVyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKTtcbiAgICB9XG4gIH1cbiAgYW5pbSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW92ZSk7XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgYW4gZWxlbWVudCBpbiBvciBvdXQgdXNpbmcgYSBDU1MgdHJhbnNpdGlvbiBjbGFzcy5cbiAqIEBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbiAtIERlZmluZXMgaWYgdGhlIGFuaW1hdGlvbiBpcyBpbiBvciBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvciBIVE1MIG9iamVjdCB0byBhbmltYXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IGFuaW1hdGlvbiAtIENTUyBjbGFzcyB0byB1c2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIENhbGxiYWNrIHRvIHJ1biB3aGVuIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5cbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZShpc0luLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XG4gIGVsZW1lbnQgPSAkKGVsZW1lbnQpLmVxKDApO1xuXG4gIGlmICghZWxlbWVudC5sZW5ndGgpIHJldHVybjtcblxuICB2YXIgaW5pdENsYXNzID0gaXNJbiA/IGluaXRDbGFzc2VzWzBdIDogaW5pdENsYXNzZXNbMV07XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzSW4gPyBhY3RpdmVDbGFzc2VzWzBdIDogYWN0aXZlQ2xhc3Nlc1sxXTtcblxuICAvLyBTZXQgdXAgdGhlIGFuaW1hdGlvblxuICByZXNldCgpO1xuXG4gIGVsZW1lbnRcbiAgICAuYWRkQ2xhc3MoYW5pbWF0aW9uKVxuICAgIC5jc3MoJ3RyYW5zaXRpb24nLCAnbm9uZScpO1xuXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgZWxlbWVudC5hZGRDbGFzcyhpbml0Q2xhc3MpO1xuICAgIGlmIChpc0luKSBlbGVtZW50LnNob3coKTtcbiAgfSk7XG5cbiAgLy8gU3RhcnQgdGhlIGFuaW1hdGlvblxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGg7XG4gICAgZWxlbWVudFxuICAgICAgLmNzcygndHJhbnNpdGlvbicsICcnKVxuICAgICAgLmFkZENsYXNzKGFjdGl2ZUNsYXNzKTtcbiAgfSk7XG5cbiAgLy8gQ2xlYW4gdXAgdGhlIGFuaW1hdGlvbiB3aGVuIGl0IGZpbmlzaGVzXG4gIGVsZW1lbnQub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZChlbGVtZW50KSwgZmluaXNoKTtcblxuICAvLyBIaWRlcyB0aGUgZWxlbWVudCAoZm9yIG91dCBhbmltYXRpb25zKSwgcmVzZXRzIHRoZSBlbGVtZW50LCBhbmQgcnVucyBhIGNhbGxiYWNrXG4gIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICBpZiAoIWlzSW4pIGVsZW1lbnQuaGlkZSgpO1xuICAgIHJlc2V0KCk7XG4gICAgaWYgKGNiKSBjYi5hcHBseShlbGVtZW50KTtcbiAgfVxuXG4gIC8vIFJlc2V0cyB0cmFuc2l0aW9ucyBhbmQgcmVtb3ZlcyBtb3Rpb24tc3BlY2lmaWMgY2xhc3Nlc1xuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBlbGVtZW50WzBdLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IDA7XG4gICAgZWxlbWVudC5yZW1vdmVDbGFzcyhgJHtpbml0Q2xhc3N9ICR7YWN0aXZlQ2xhc3N9ICR7YW5pbWF0aW9ufWApO1xuICB9XG59XG5cbkZvdW5kYXRpb24uTW92ZSA9IE1vdmU7XG5Gb3VuZGF0aW9uLk1vdGlvbiA9IE1vdGlvbjtcblxufShqUXVlcnkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG5jb25zdCBOZXN0ID0ge1xuICBGZWF0aGVyKG1lbnUsIHR5cGUgPSAnemYnKSB7XG4gICAgbWVudS5hdHRyKCdyb2xlJywgJ21lbnViYXInKTtcblxuICAgIHZhciBpdGVtcyA9IG1lbnUuZmluZCgnbGknKS5hdHRyKHsncm9sZSc6ICdtZW51aXRlbSd9KSxcbiAgICAgICAgc3ViTWVudUNsYXNzID0gYGlzLSR7dHlwZX0tc3VibWVudWAsXG4gICAgICAgIHN1Ykl0ZW1DbGFzcyA9IGAke3N1Yk1lbnVDbGFzc30taXRlbWAsXG4gICAgICAgIGhhc1N1YkNsYXNzID0gYGlzLSR7dHlwZX0tc3VibWVudS1wYXJlbnRgO1xuXG4gICAgbWVudS5maW5kKCdhOmZpcnN0JykuYXR0cigndGFiaW5kZXgnLCAwKTtcblxuICAgIGl0ZW1zLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgJGl0ZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICRzdWIgPSAkaXRlbS5jaGlsZHJlbigndWwnKTtcblxuICAgICAgaWYgKCRzdWIubGVuZ3RoKSB7XG4gICAgICAgICRpdGVtXG4gICAgICAgICAgLmFkZENsYXNzKGhhc1N1YkNsYXNzKVxuICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcbiAgICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6ICRpdGVtLmNoaWxkcmVuKCdhOmZpcnN0JykudGV4dCgpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgJHN1YlxuICAgICAgICAgIC5hZGRDbGFzcyhgc3VibWVudSAke3N1Yk1lbnVDbGFzc31gKVxuICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICdkYXRhLXN1Ym1lbnUnOiAnJyxcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgICAgICAgICAncm9sZSc6ICdtZW51J1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGl0ZW0ucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCkge1xuICAgICAgICAkaXRlbS5hZGRDbGFzcyhgaXMtc3VibWVudS1pdGVtICR7c3ViSXRlbUNsYXNzfWApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9LFxuXG4gIEJ1cm4obWVudSwgdHlwZSkge1xuICAgIHZhciBpdGVtcyA9IG1lbnUuZmluZCgnbGknKS5yZW1vdmVBdHRyKCd0YWJpbmRleCcpLFxuICAgICAgICBzdWJNZW51Q2xhc3MgPSBgaXMtJHt0eXBlfS1zdWJtZW51YCxcbiAgICAgICAgc3ViSXRlbUNsYXNzID0gYCR7c3ViTWVudUNsYXNzfS1pdGVtYCxcbiAgICAgICAgaGFzU3ViQ2xhc3MgPSBgaXMtJHt0eXBlfS1zdWJtZW51LXBhcmVudGA7XG5cbiAgICBtZW51XG4gICAgICAuZmluZCgnKicpXG4gICAgICAucmVtb3ZlQ2xhc3MoYCR7c3ViTWVudUNsYXNzfSAke3N1Ykl0ZW1DbGFzc30gJHtoYXNTdWJDbGFzc30gaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUgaXMtYWN0aXZlYClcbiAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXN1Ym1lbnUnKS5jc3MoJ2Rpc3BsYXknLCAnJyk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyggICAgICBtZW51LmZpbmQoJy4nICsgc3ViTWVudUNsYXNzICsgJywgLicgKyBzdWJJdGVtQ2xhc3MgKyAnLCAuaGFzLXN1Ym1lbnUsIC5pcy1zdWJtZW51LWl0ZW0sIC5zdWJtZW51LCBbZGF0YS1zdWJtZW51XScpXG4gICAgLy8gICAgICAgICAgIC5yZW1vdmVDbGFzcyhzdWJNZW51Q2xhc3MgKyAnICcgKyBzdWJJdGVtQ2xhc3MgKyAnIGhhcy1zdWJtZW51IGlzLXN1Ym1lbnUtaXRlbSBzdWJtZW51JylcbiAgICAvLyAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtc3VibWVudScpKTtcbiAgICAvLyBpdGVtcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgLy8gICB2YXIgJGl0ZW0gPSAkKHRoaXMpLFxuICAgIC8vICAgICAgICRzdWIgPSAkaXRlbS5jaGlsZHJlbigndWwnKTtcbiAgICAvLyAgIGlmKCRpdGVtLnBhcmVudCgnW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpe1xuICAgIC8vICAgICAkaXRlbS5yZW1vdmVDbGFzcygnaXMtc3VibWVudS1pdGVtICcgKyBzdWJJdGVtQ2xhc3MpO1xuICAgIC8vICAgfVxuICAgIC8vICAgaWYoJHN1Yi5sZW5ndGgpe1xuICAgIC8vICAgICAkaXRlbS5yZW1vdmVDbGFzcygnaGFzLXN1Ym1lbnUnKTtcbiAgICAvLyAgICAgJHN1Yi5yZW1vdmVDbGFzcygnc3VibWVudSAnICsgc3ViTWVudUNsYXNzKS5yZW1vdmVBdHRyKCdkYXRhLXN1Ym1lbnUnKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9KTtcbiAgfVxufVxuXG5Gb3VuZGF0aW9uLk5lc3QgPSBOZXN0O1xuXG59KGpRdWVyeSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbmZ1bmN0aW9uIFRpbWVyKGVsZW0sIG9wdGlvbnMsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24sLy9vcHRpb25zIGlzIGFuIG9iamVjdCBmb3IgZWFzaWx5IGFkZGluZyBmZWF0dXJlcyBsYXRlci5cbiAgICAgIG5hbWVTcGFjZSA9IE9iamVjdC5rZXlzKGVsZW0uZGF0YSgpKVswXSB8fCAndGltZXInLFxuICAgICAgcmVtYWluID0gLTEsXG4gICAgICBzdGFydCxcbiAgICAgIHRpbWVyO1xuXG4gIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcblxuICB0aGlzLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICByZW1haW4gPSAtMTtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfVxuXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgLy8gaWYoIWVsZW0uZGF0YSgncGF1c2VkJykpeyByZXR1cm4gZmFsc2U7IH0vL21heWJlIGltcGxlbWVudCB0aGlzIHNhbml0eSBjaGVjayBpZiB1c2VkIGZvciBvdGhlciB0aGluZ3MuXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICByZW1haW4gPSByZW1haW4gPD0gMCA/IGR1cmF0aW9uIDogcmVtYWluO1xuICAgIGVsZW0uZGF0YSgncGF1c2VkJywgZmFsc2UpO1xuICAgIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmKG9wdGlvbnMuaW5maW5pdGUpe1xuICAgICAgICBfdGhpcy5yZXN0YXJ0KCk7Ly9yZXJ1biB0aGUgdGltZXIuXG4gICAgICB9XG4gICAgICBjYigpO1xuICAgIH0sIHJlbWFpbik7XG4gICAgZWxlbS50cmlnZ2VyKGB0aW1lcnN0YXJ0LnpmLiR7bmFtZVNwYWNlfWApO1xuICB9XG5cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICAgIC8vaWYoZWxlbS5kYXRhKCdwYXVzZWQnKSl7IHJldHVybiBmYWxzZTsgfS8vbWF5YmUgaW1wbGVtZW50IHRoaXMgc2FuaXR5IGNoZWNrIGlmIHVzZWQgZm9yIG90aGVyIHRoaW5ncy5cbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIGVsZW0uZGF0YSgncGF1c2VkJywgdHJ1ZSk7XG4gICAgdmFyIGVuZCA9IERhdGUubm93KCk7XG4gICAgcmVtYWluID0gcmVtYWluIC0gKGVuZCAtIHN0YXJ0KTtcbiAgICBlbGVtLnRyaWdnZXIoYHRpbWVycGF1c2VkLnpmLiR7bmFtZVNwYWNlfWApO1xuICB9XG59XG5cbi8qKlxuICogUnVucyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gaW1hZ2VzIGFyZSBmdWxseSBsb2FkZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VzIC0gSW1hZ2UocykgdG8gY2hlY2sgaWYgbG9hZGVkLlxuICogQHBhcmFtIHtGdW5jfSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBpbWFnZSBpcyBmdWxseSBsb2FkZWQuXG4gKi9cbmZ1bmN0aW9uIG9uSW1hZ2VzTG9hZGVkKGltYWdlcywgY2FsbGJhY2spe1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICB1bmxvYWRlZCA9IGltYWdlcy5sZW5ndGg7XG5cbiAgaWYgKHVubG9hZGVkID09PSAwKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGltYWdlcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbXBsZXRlKSB7XG4gICAgICBzaW5nbGVJbWFnZUxvYWRlZCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5uYXR1cmFsV2lkdGggIT09ICd1bmRlZmluZWQnICYmIHRoaXMubmF0dXJhbFdpZHRoID4gMCkge1xuICAgICAgc2luZ2xlSW1hZ2VMb2FkZWQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAkKHRoaXMpLm9uZSgnbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzaW5nbGVJbWFnZUxvYWRlZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBzaW5nbGVJbWFnZUxvYWRlZCgpIHtcbiAgICB1bmxvYWRlZC0tO1xuICAgIGlmICh1bmxvYWRlZCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cbn1cblxuRm91bmRhdGlvbi5UaW1lciA9IFRpbWVyO1xuRm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCA9IG9uSW1hZ2VzTG9hZGVkO1xuXG59KGpRdWVyeSk7XG4iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyoqV29yayBpbnNwaXJlZCBieSBtdWx0aXBsZSBqcXVlcnkgc3dpcGUgcGx1Z2lucyoqXG4vLyoqRG9uZSBieSBZb2hhaSBBcmFyYXQgKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4oZnVuY3Rpb24oJCkge1xuXG4gICQuc3BvdFN3aXBlID0ge1xuICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgZW5hYmxlZDogJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcbiAgICBtb3ZlVGhyZXNob2xkOiA3NSxcbiAgICB0aW1lVGhyZXNob2xkOiAyMDBcbiAgfTtcblxuICB2YXIgICBzdGFydFBvc1gsXG4gICAgICAgIHN0YXJ0UG9zWSxcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICBlbGFwc2VkVGltZSxcbiAgICAgICAgaXNNb3ZpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRvdWNoRW5kKCkge1xuICAgIC8vICBhbGVydCh0aGlzKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgaXNNb3ZpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICBpZiAoJC5zcG90U3dpcGUucHJldmVudERlZmF1bHQpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgaWYoaXNNb3ZpbmcpIHtcbiAgICAgIHZhciB4ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgdmFyIHkgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICB2YXIgZHggPSBzdGFydFBvc1ggLSB4O1xuICAgICAgdmFyIGR5ID0gc3RhcnRQb3NZIC0geTtcbiAgICAgIHZhciBkaXI7XG4gICAgICBlbGFwc2VkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lO1xuICAgICAgaWYoTWF0aC5hYnMoZHgpID49ICQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0gJC5zcG90U3dpcGUudGltZVRocmVzaG9sZCkge1xuICAgICAgICBkaXIgPSBkeCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfVxuICAgICAgLy8gZWxzZSBpZihNYXRoLmFicyhkeSkgPj0gJC5zcG90U3dpcGUubW92ZVRocmVzaG9sZCAmJiBlbGFwc2VkVGltZSA8PSAkLnNwb3RTd2lwZS50aW1lVGhyZXNob2xkKSB7XG4gICAgICAvLyAgIGRpciA9IGR5ID4gMCA/ICdkb3duJyA6ICd1cCc7XG4gICAgICAvLyB9XG4gICAgICBpZihkaXIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBvblRvdWNoRW5kLmNhbGwodGhpcyk7XG4gICAgICAgICQodGhpcykudHJpZ2dlcignc3dpcGUnLCBkaXIpLnRyaWdnZXIoYHN3aXBlJHtkaXJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICBzdGFydFBvc1ggPSBlLnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICBzdGFydFBvc1kgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICBpc01vdmluZyA9IHRydWU7XG4gICAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIGZhbHNlKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgJiYgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZWFyZG93bigpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQpO1xuICB9XG5cbiAgJC5ldmVudC5zcGVjaWFsLnN3aXBlID0geyBzZXR1cDogaW5pdCB9O1xuXG4gICQuZWFjaChbJ2xlZnQnLCAndXAnLCAnZG93bicsICdyaWdodCddLCBmdW5jdGlvbiAoKSB7XG4gICAgJC5ldmVudC5zcGVjaWFsW2Bzd2lwZSR7dGhpc31gXSA9IHsgc2V0dXA6IGZ1bmN0aW9uKCl7XG4gICAgICAkKHRoaXMpLm9uKCdzd2lwZScsICQubm9vcCk7XG4gICAgfSB9O1xuICB9KTtcbn0pKGpRdWVyeSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTWV0aG9kIGZvciBhZGRpbmcgcHN1ZWRvIGRyYWcgZXZlbnRzIHRvIGVsZW1lbnRzICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4hZnVuY3Rpb24oJCl7XG4gICQuZm4uYWRkVG91Y2ggPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbihpLGVsKXtcbiAgICAgICQoZWwpLmJpbmQoJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJyxmdW5jdGlvbigpe1xuICAgICAgICAvL3dlIHBhc3MgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdCBiZWNhdXNlIHRoZSBqUXVlcnkgZXZlbnRcbiAgICAgICAgLy9vYmplY3QgaXMgbm9ybWFsaXplZCB0byB3M2Mgc3BlY3MgYW5kIGRvZXMgbm90IHByb3ZpZGUgdGhlIFRvdWNoTGlzdFxuICAgICAgICBoYW5kbGVUb3VjaChldmVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBoYW5kbGVUb3VjaCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgICAgZmlyc3QgPSB0b3VjaGVzWzBdLFxuICAgICAgICAgIGV2ZW50VHlwZXMgPSB7XG4gICAgICAgICAgICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gICAgICAgICAgICB0b3VjaGVuZDogJ21vdXNldXAnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlID0gZXZlbnRUeXBlc1tldmVudC50eXBlXSxcbiAgICAgICAgICBzaW11bGF0ZWRFdmVudFxuICAgICAgICA7XG5cbiAgICAgIGlmKCdNb3VzZUV2ZW50JyBpbiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5Nb3VzZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNpbXVsYXRlZEV2ZW50ID0gd2luZG93Lk1vdXNlRXZlbnQodHlwZSwge1xuICAgICAgICAgICdidWJibGVzJzogdHJ1ZSxcbiAgICAgICAgICAnY2FuY2VsYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ3NjcmVlblgnOiBmaXJzdC5zY3JlZW5YLFxuICAgICAgICAgICdzY3JlZW5ZJzogZmlyc3Quc2NyZWVuWSxcbiAgICAgICAgICAnY2xpZW50WCc6IGZpcnN0LmNsaWVudFgsXG4gICAgICAgICAgJ2NsaWVudFknOiBmaXJzdC5jbGllbnRZXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xuICAgICAgICBzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudCh0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsIGZpcnN0LnNjcmVlblgsIGZpcnN0LnNjcmVlblksIGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLypsZWZ0Ki8sIG51bGwpO1xuICAgICAgfVxuICAgICAgZmlyc3QudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuICAgIH07XG4gIH07XG59KGpRdWVyeSk7XG5cblxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyoqRnJvbSB0aGUgalF1ZXJ5IE1vYmlsZSBMaWJyYXJ5Kipcbi8vKipuZWVkIHRvIHJlY3JlYXRlIGZ1bmN0aW9uYWxpdHkqKlxuLy8qKmFuZCB0cnkgdG8gaW1wcm92ZSBpZiBwb3NzaWJsZSoqXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuLyogUmVtb3ZpbmcgdGhlIGpRdWVyeSBmdW5jdGlvbiAqKioqXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuXHR2YXIgJGRvY3VtZW50ID0gJCggZG9jdW1lbnQgKSxcblx0XHQvLyBzdXBwb3J0VG91Y2ggPSAkLm1vYmlsZS5zdXBwb3J0LnRvdWNoLFxuXHRcdHRvdWNoU3RhcnRFdmVudCA9ICd0b3VjaHN0YXJ0Jy8vc3VwcG9ydFRvdWNoID8gXCJ0b3VjaHN0YXJ0XCIgOiBcIm1vdXNlZG93blwiLFxuXHRcdHRvdWNoU3RvcEV2ZW50ID0gJ3RvdWNoZW5kJy8vc3VwcG9ydFRvdWNoID8gXCJ0b3VjaGVuZFwiIDogXCJtb3VzZXVwXCIsXG5cdFx0dG91Y2hNb3ZlRXZlbnQgPSAndG91Y2htb3ZlJy8vc3VwcG9ydFRvdWNoID8gXCJ0b3VjaG1vdmVcIiA6IFwibW91c2Vtb3ZlXCI7XG5cblx0Ly8gc2V0dXAgbmV3IGV2ZW50IHNob3J0Y3V0c1xuXHQkLmVhY2goICggXCJ0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCBcIiArXG5cdFx0XCJzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodFwiICkuc3BsaXQoIFwiIFwiICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdFx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0cmV0dXJuIGZuID8gdGhpcy5iaW5kKCBuYW1lLCBmbiApIDogdGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblxuXHRcdC8vIGpRdWVyeSA8IDEuOFxuXHRcdGlmICggJC5hdHRyRm4gKSB7XG5cdFx0XHQkLmF0dHJGblsgbmFtZSBdID0gdHJ1ZTtcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIHRyaWdnZXJDdXN0b21FdmVudCggb2JqLCBldmVudFR5cGUsIGV2ZW50LCBidWJibGUgKSB7XG5cdFx0dmFyIG9yaWdpbmFsVHlwZSA9IGV2ZW50LnR5cGU7XG5cdFx0ZXZlbnQudHlwZSA9IGV2ZW50VHlwZTtcblx0XHRpZiAoIGJ1YmJsZSApIHtcblx0XHRcdCQuZXZlbnQudHJpZ2dlciggZXZlbnQsIHVuZGVmaW5lZCwgb2JqICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQuZXZlbnQuZGlzcGF0Y2guY2FsbCggb2JqLCBldmVudCApO1xuXHRcdH1cblx0XHRldmVudC50eXBlID0gb3JpZ2luYWxUeXBlO1xuXHR9XG5cblx0Ly8gYWxzbyBoYW5kbGVzIHRhcGhvbGRcblxuXHQvLyBBbHNvIGhhbmRsZXMgc3dpcGVsZWZ0LCBzd2lwZXJpZ2h0XG5cdCQuZXZlbnQuc3BlY2lhbC5zd2lwZSA9IHtcblxuXHRcdC8vIE1vcmUgdGhhbiB0aGlzIGhvcml6b250YWwgZGlzcGxhY2VtZW50LCBhbmQgd2Ugd2lsbCBzdXBwcmVzcyBzY3JvbGxpbmcuXG5cdFx0c2Nyb2xsU3VwcmVzc2lvblRocmVzaG9sZDogMzAsXG5cblx0XHQvLyBNb3JlIHRpbWUgdGhhbiB0aGlzLCBhbmQgaXQgaXNuJ3QgYSBzd2lwZS5cblx0XHRkdXJhdGlvblRocmVzaG9sZDogMTAwMCxcblxuXHRcdC8vIFN3aXBlIGhvcml6b250YWwgZGlzcGxhY2VtZW50IG11c3QgYmUgbW9yZSB0aGFuIHRoaXMuXG5cdFx0aG9yaXpvbnRhbERpc3RhbmNlVGhyZXNob2xkOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+PSAyID8gMTUgOiAzMCxcblxuXHRcdC8vIFN3aXBlIHZlcnRpY2FsIGRpc3BsYWNlbWVudCBtdXN0IGJlIGxlc3MgdGhhbiB0aGlzLlxuXHRcdHZlcnRpY2FsRGlzdGFuY2VUaHJlc2hvbGQ6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID49IDIgPyAxNSA6IDMwLFxuXG5cdFx0Z2V0TG9jYXRpb246IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdFx0XHR2YXIgd2luUGFnZVggPSB3aW5kb3cucGFnZVhPZmZzZXQsXG5cdFx0XHRcdHdpblBhZ2VZID0gd2luZG93LnBhZ2VZT2Zmc2V0LFxuXHRcdFx0XHR4ID0gZXZlbnQuY2xpZW50WCxcblx0XHRcdFx0eSA9IGV2ZW50LmNsaWVudFk7XG5cblx0XHRcdGlmICggZXZlbnQucGFnZVkgPT09IDAgJiYgTWF0aC5mbG9vciggeSApID4gTWF0aC5mbG9vciggZXZlbnQucGFnZVkgKSB8fFxuXHRcdFx0XHRldmVudC5wYWdlWCA9PT0gMCAmJiBNYXRoLmZsb29yKCB4ICkgPiBNYXRoLmZsb29yKCBldmVudC5wYWdlWCApICkge1xuXG5cdFx0XHRcdC8vIGlPUzQgY2xpZW50WC9jbGllbnRZIGhhdmUgdGhlIHZhbHVlIHRoYXQgc2hvdWxkIGhhdmUgYmVlblxuXHRcdFx0XHQvLyBpbiBwYWdlWC9wYWdlWS4gV2hpbGUgcGFnZVgvcGFnZS8gaGF2ZSB0aGUgdmFsdWUgMFxuXHRcdFx0XHR4ID0geCAtIHdpblBhZ2VYO1xuXHRcdFx0XHR5ID0geSAtIHdpblBhZ2VZO1xuXHRcdFx0fSBlbHNlIGlmICggeSA8ICggZXZlbnQucGFnZVkgLSB3aW5QYWdlWSkgfHwgeCA8ICggZXZlbnQucGFnZVggLSB3aW5QYWdlWCApICkge1xuXG5cdFx0XHRcdC8vIFNvbWUgQW5kcm9pZCBicm93c2VycyBoYXZlIHRvdGFsbHkgYm9ndXMgdmFsdWVzIGZvciBjbGllbnRYL1lcblx0XHRcdFx0Ly8gd2hlbiBzY3JvbGxpbmcvem9vbWluZyBhIHBhZ2UuIERldGVjdGFibGUgc2luY2UgY2xpZW50WC9jbGllbnRZXG5cdFx0XHRcdC8vIHNob3VsZCBuZXZlciBiZSBzbWFsbGVyIHRoYW4gcGFnZVgvcGFnZVkgbWludXMgcGFnZSBzY3JvbGxcblx0XHRcdFx0eCA9IGV2ZW50LnBhZ2VYIC0gd2luUGFnZVg7XG5cdFx0XHRcdHkgPSBldmVudC5wYWdlWSAtIHdpblBhZ2VZO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiB4LFxuXHRcdFx0XHR5OiB5XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRzdGFydDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGRhdGEgPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgP1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1sgMCBdIDogZXZlbnQsXG5cdFx0XHRcdGxvY2F0aW9uID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLmdldExvY2F0aW9uKCBkYXRhICk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dGltZTogKCBuZXcgRGF0ZSgpICkuZ2V0VGltZSgpLFxuXHRcdFx0XHRcdFx0Y29vcmRzOiBbIGxvY2F0aW9uLngsIGxvY2F0aW9uLnkgXSxcblx0XHRcdFx0XHRcdG9yaWdpbjogJCggZXZlbnQudGFyZ2V0IClcblx0XHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRzdG9wOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgZGF0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyA/XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWyAwIF0gOiBldmVudCxcblx0XHRcdFx0bG9jYXRpb24gPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZ2V0TG9jYXRpb24oIGRhdGEgKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0aW1lOiAoIG5ldyBEYXRlKCkgKS5nZXRUaW1lKCksXG5cdFx0XHRcdFx0XHRjb29yZHM6IFsgbG9jYXRpb24ueCwgbG9jYXRpb24ueSBdXG5cdFx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0aGFuZGxlU3dpcGU6IGZ1bmN0aW9uKCBzdGFydCwgc3RvcCwgdGhpc09iamVjdCwgb3JpZ1RhcmdldCApIHtcblx0XHRcdGlmICggc3RvcC50aW1lIC0gc3RhcnQudGltZSA8ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5kdXJhdGlvblRocmVzaG9sZCAmJlxuXHRcdFx0XHRNYXRoLmFicyggc3RhcnQuY29vcmRzWyAwIF0gLSBzdG9wLmNvb3Jkc1sgMCBdICkgPiAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuaG9yaXpvbnRhbERpc3RhbmNlVGhyZXNob2xkICYmXG5cdFx0XHRcdE1hdGguYWJzKCBzdGFydC5jb29yZHNbIDEgXSAtIHN0b3AuY29vcmRzWyAxIF0gKSA8ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS52ZXJ0aWNhbERpc3RhbmNlVGhyZXNob2xkICkge1xuXHRcdFx0XHR2YXIgZGlyZWN0aW9uID0gc3RhcnQuY29vcmRzWzBdID4gc3RvcC5jb29yZHNbIDAgXSA/IFwic3dpcGVsZWZ0XCIgOiBcInN3aXBlcmlnaHRcIjtcblxuXHRcdFx0XHR0cmlnZ2VyQ3VzdG9tRXZlbnQoIHRoaXNPYmplY3QsIFwic3dpcGVcIiwgJC5FdmVudCggXCJzd2lwZVwiLCB7IHRhcmdldDogb3JpZ1RhcmdldCwgc3dpcGVzdGFydDogc3RhcnQsIHN3aXBlc3RvcDogc3RvcCB9KSwgdHJ1ZSApO1xuXHRcdFx0XHR0cmlnZ2VyQ3VzdG9tRXZlbnQoIHRoaXNPYmplY3QsIGRpcmVjdGlvbiwkLkV2ZW50KCBkaXJlY3Rpb24sIHsgdGFyZ2V0OiBvcmlnVGFyZ2V0LCBzd2lwZXN0YXJ0OiBzdGFydCwgc3dpcGVzdG9wOiBzdG9wIH0gKSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH0sXG5cblx0XHQvLyBUaGlzIHNlcnZlcyBhcyBhIGZsYWcgdG8gZW5zdXJlIHRoYXQgYXQgbW9zdCBvbmUgc3dpcGUgZXZlbnQgZXZlbnQgaXNcblx0XHQvLyBpbiB3b3JrIGF0IGFueSBnaXZlbiB0aW1lXG5cdFx0ZXZlbnRJblByb2dyZXNzOiBmYWxzZSxcblxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBldmVudHMsXG5cdFx0XHRcdHRoaXNPYmplY3QgPSB0aGlzLFxuXHRcdFx0XHQkdGhpcyA9ICQoIHRoaXNPYmplY3QgKSxcblx0XHRcdFx0Y29udGV4dCA9IHt9O1xuXG5cdFx0XHQvLyBSZXRyaWV2ZSB0aGUgZXZlbnRzIGRhdGEgZm9yIHRoaXMgZWxlbWVudCBhbmQgYWRkIHRoZSBzd2lwZSBjb250ZXh0XG5cdFx0XHRldmVudHMgPSAkLmRhdGEoIHRoaXMsIFwibW9iaWxlLWV2ZW50c1wiICk7XG5cdFx0XHRpZiAoICFldmVudHMgKSB7XG5cdFx0XHRcdGV2ZW50cyA9IHsgbGVuZ3RoOiAwIH07XG5cdFx0XHRcdCQuZGF0YSggdGhpcywgXCJtb2JpbGUtZXZlbnRzXCIsIGV2ZW50cyApO1xuXHRcdFx0fVxuXHRcdFx0ZXZlbnRzLmxlbmd0aCsrO1xuXHRcdFx0ZXZlbnRzLnN3aXBlID0gY29udGV4dDtcblxuXHRcdFx0Y29udGV4dC5zdGFydCA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBCYWlsIGlmIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvbiBhIHN3aXBlIGV2ZW50XG5cdFx0XHRcdGlmICggJC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0JC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyA9IHRydWU7XG5cblx0XHRcdFx0dmFyIHN0b3AsXG5cdFx0XHRcdFx0c3RhcnQgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuc3RhcnQoIGV2ZW50ICksXG5cdFx0XHRcdFx0b3JpZ1RhcmdldCA9IGV2ZW50LnRhcmdldCxcblx0XHRcdFx0XHRlbWl0dGVkID0gZmFsc2U7XG5cblx0XHRcdFx0Y29udGV4dC5tb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXJ0IHx8IGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHN0b3AgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuc3RvcCggZXZlbnQgKTtcblx0XHRcdFx0XHRpZiAoICFlbWl0dGVkICkge1xuXHRcdFx0XHRcdFx0ZW1pdHRlZCA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5oYW5kbGVTd2lwZSggc3RhcnQsIHN0b3AsIHRoaXNPYmplY3QsIG9yaWdUYXJnZXQgKTtcblx0XHRcdFx0XHRcdGlmICggZW1pdHRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXNldCB0aGUgY29udGV4dCB0byBtYWtlIHdheSBmb3IgdGhlIG5leHQgc3dpcGUgZXZlbnRcblx0XHRcdFx0XHRcdFx0JC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBwcmV2ZW50IHNjcm9sbGluZ1xuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIHN0YXJ0LmNvb3Jkc1sgMCBdIC0gc3RvcC5jb29yZHNbIDAgXSApID4gJC5ldmVudC5zcGVjaWFsLnN3aXBlLnNjcm9sbFN1cHJlc3Npb25UaHJlc2hvbGQgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRjb250ZXh0LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGVtaXR0ZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHQvLyBSZXNldCB0aGUgY29udGV4dCB0byBtYWtlIHdheSBmb3IgdGhlIG5leHQgc3dpcGUgZXZlbnRcblx0XHRcdFx0XHRcdCQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHRcdFx0XHRcdCRkb2N1bWVudC5vZmYoIHRvdWNoTW92ZUV2ZW50LCBjb250ZXh0Lm1vdmUgKTtcblx0XHRcdFx0XHRcdGNvbnRleHQubW92ZSA9IG51bGw7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0JGRvY3VtZW50Lm9uKCB0b3VjaE1vdmVFdmVudCwgY29udGV4dC5tb3ZlIClcblx0XHRcdFx0XHQub25lKCB0b3VjaFN0b3BFdmVudCwgY29udGV4dC5zdG9wICk7XG5cdFx0XHR9O1xuXHRcdFx0JHRoaXMub24oIHRvdWNoU3RhcnRFdmVudCwgY29udGV4dC5zdGFydCApO1xuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZXZlbnRzLCBjb250ZXh0O1xuXG5cdFx0XHRldmVudHMgPSAkLmRhdGEoIHRoaXMsIFwibW9iaWxlLWV2ZW50c1wiICk7XG5cdFx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdFx0Y29udGV4dCA9IGV2ZW50cy5zd2lwZTtcblx0XHRcdFx0ZGVsZXRlIGV2ZW50cy5zd2lwZTtcblx0XHRcdFx0ZXZlbnRzLmxlbmd0aC0tO1xuXHRcdFx0XHRpZiAoIGV2ZW50cy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0JC5yZW1vdmVEYXRhKCB0aGlzLCBcIm1vYmlsZS1ldmVudHNcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggY29udGV4dCApIHtcblx0XHRcdFx0aWYgKCBjb250ZXh0LnN0YXJ0ICkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5vZmYoIHRvdWNoU3RhcnRFdmVudCwgY29udGV4dC5zdGFydCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY29udGV4dC5tb3ZlICkge1xuXHRcdFx0XHRcdCRkb2N1bWVudC5vZmYoIHRvdWNoTW92ZUV2ZW50LCBjb250ZXh0Lm1vdmUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNvbnRleHQuc3RvcCApIHtcblx0XHRcdFx0XHQkZG9jdW1lbnQub2ZmKCB0b3VjaFN0b3BFdmVudCwgY29udGV4dC5zdG9wICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdCQuZWFjaCh7XG5cdFx0c3dpcGVsZWZ0OiBcInN3aXBlLmxlZnRcIixcblx0XHRzd2lwZXJpZ2h0OiBcInN3aXBlLnJpZ2h0XCJcblx0fSwgZnVuY3Rpb24oIGV2ZW50LCBzb3VyY2VFdmVudCApIHtcblxuXHRcdCQuZXZlbnQuc3BlY2lhbFsgZXZlbnQgXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmJpbmQoIHNvdXJjZUV2ZW50LCAkLm5vb3AgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS51bmJpbmQoIHNvdXJjZUV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG59KSggalF1ZXJ5LCB0aGlzICk7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG5jb25zdCBNdXRhdGlvbk9ic2VydmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByZWZpeGVzID0gWydXZWJLaXQnLCAnTW96JywgJ08nLCAnTXMnLCAnJ107XG4gIGZvciAodmFyIGk9MDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGAke3ByZWZpeGVzW2ldfU11dGF0aW9uT2JzZXJ2ZXJgIGluIHdpbmRvdykge1xuICAgICAgcmV0dXJuIHdpbmRvd1tgJHtwcmVmaXhlc1tpXX1NdXRhdGlvbk9ic2VydmVyYF07XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn0oKSk7XG5cbmNvbnN0IHRyaWdnZXJzID0gKGVsLCB0eXBlKSA9PiB7XG4gIGVsLmRhdGEodHlwZSkuc3BsaXQoJyAnKS5mb3JFYWNoKGlkID0+IHtcbiAgICAkKGAjJHtpZH1gKVsgdHlwZSA9PT0gJ2Nsb3NlJyA/ICd0cmlnZ2VyJyA6ICd0cmlnZ2VySGFuZGxlciddKGAke3R5cGV9LnpmLnRyaWdnZXJgLCBbZWxdKTtcbiAgfSk7XG59O1xuLy8gRWxlbWVudHMgd2l0aCBbZGF0YS1vcGVuXSB3aWxsIHJldmVhbCBhIHBsdWdpbiB0aGF0IHN1cHBvcnRzIGl0IHdoZW4gY2xpY2tlZC5cbiQoZG9jdW1lbnQpLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLW9wZW5dJywgZnVuY3Rpb24oKSB7XG4gIHRyaWdnZXJzKCQodGhpcyksICdvcGVuJyk7XG59KTtcblxuLy8gRWxlbWVudHMgd2l0aCBbZGF0YS1jbG9zZV0gd2lsbCBjbG9zZSBhIHBsdWdpbiB0aGF0IHN1cHBvcnRzIGl0IHdoZW4gY2xpY2tlZC5cbi8vIElmIHVzZWQgd2l0aG91dCBhIHZhbHVlIG9uIFtkYXRhLWNsb3NlXSwgdGhlIGV2ZW50IHdpbGwgYnViYmxlLCBhbGxvd2luZyBpdCB0byBjbG9zZSBhIHBhcmVudCBjb21wb25lbnQuXG4kKGRvY3VtZW50KS5vbignY2xpY2suemYudHJpZ2dlcicsICdbZGF0YS1jbG9zZV0nLCBmdW5jdGlvbigpIHtcbiAgbGV0IGlkID0gJCh0aGlzKS5kYXRhKCdjbG9zZScpO1xuICBpZiAoaWQpIHtcbiAgICB0cmlnZ2VycygkKHRoaXMpLCAnY2xvc2UnKTtcbiAgfVxuICBlbHNlIHtcbiAgICAkKHRoaXMpLnRyaWdnZXIoJ2Nsb3NlLnpmLnRyaWdnZXInKTtcbiAgfVxufSk7XG5cbi8vIEVsZW1lbnRzIHdpdGggW2RhdGEtdG9nZ2xlXSB3aWxsIHRvZ2dsZSBhIHBsdWdpbiB0aGF0IHN1cHBvcnRzIGl0IHdoZW4gY2xpY2tlZC5cbiQoZG9jdW1lbnQpLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLXRvZ2dsZV0nLCBmdW5jdGlvbigpIHtcbiAgdHJpZ2dlcnMoJCh0aGlzKSwgJ3RvZ2dsZScpO1xufSk7XG5cbi8vIEVsZW1lbnRzIHdpdGggW2RhdGEtY2xvc2FibGVdIHdpbGwgcmVzcG9uZCB0byBjbG9zZS56Zi50cmlnZ2VyIGV2ZW50cy5cbiQoZG9jdW1lbnQpLm9uKCdjbG9zZS56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NhYmxlXScsIGZ1bmN0aW9uKGUpe1xuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICBsZXQgYW5pbWF0aW9uID0gJCh0aGlzKS5kYXRhKCdjbG9zYWJsZScpO1xuXG4gIGlmKGFuaW1hdGlvbiAhPT0gJycpe1xuICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQoJCh0aGlzKSwgYW5pbWF0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcykudHJpZ2dlcignY2xvc2VkLnpmJyk7XG4gICAgfSk7XG4gIH1lbHNle1xuICAgICQodGhpcykuZmFkZU91dCgpLnRyaWdnZXIoJ2Nsb3NlZC56ZicpO1xuICB9XG59KTtcblxuJChkb2N1bWVudCkub24oJ2ZvY3VzLnpmLnRyaWdnZXIgYmx1ci56Zi50cmlnZ2VyJywgJ1tkYXRhLXRvZ2dsZS1mb2N1c10nLCBmdW5jdGlvbigpIHtcbiAgbGV0IGlkID0gJCh0aGlzKS5kYXRhKCd0b2dnbGUtZm9jdXMnKTtcbiAgJChgIyR7aWR9YCkudHJpZ2dlckhhbmRsZXIoJ3RvZ2dsZS56Zi50cmlnZ2VyJywgWyQodGhpcyldKTtcbn0pO1xuXG4vKipcbiogRmlyZXMgb25jZSBhZnRlciBhbGwgb3RoZXIgc2NyaXB0cyBoYXZlIGxvYWRlZFxuKiBAZnVuY3Rpb25cbiogQHByaXZhdGVcbiovXG4kKHdpbmRvdykubG9hZCgoKSA9PiB7XG4gIGNoZWNrTGlzdGVuZXJzKCk7XG59KTtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcnMoKSB7XG4gIGV2ZW50c0xpc3RlbmVyKCk7XG4gIHJlc2l6ZUxpc3RlbmVyKCk7XG4gIHNjcm9sbExpc3RlbmVyKCk7XG4gIGNsb3NlbWVMaXN0ZW5lcigpO1xufVxuXG4vLyoqKioqKioqIG9ubHkgZmlyZXMgdGhpcyBmdW5jdGlvbiBvbmNlIG9uIGxvYWQsIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIHRvIHdhdGNoICoqKioqKioqXG5mdW5jdGlvbiBjbG9zZW1lTGlzdGVuZXIocGx1Z2luTmFtZSkge1xuICB2YXIgeWV0aUJveGVzID0gJCgnW2RhdGEteWV0aS1ib3hdJyksXG4gICAgICBwbHVnTmFtZXMgPSBbJ2Ryb3Bkb3duJywgJ3Rvb2x0aXAnLCAncmV2ZWFsJ107XG5cbiAgaWYocGx1Z2luTmFtZSl7XG4gICAgaWYodHlwZW9mIHBsdWdpbk5hbWUgPT09ICdzdHJpbmcnKXtcbiAgICAgIHBsdWdOYW1lcy5wdXNoKHBsdWdpbk5hbWUpO1xuICAgIH1lbHNlIGlmKHR5cGVvZiBwbHVnaW5OYW1lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGx1Z2luTmFtZVswXSA9PT0gJ3N0cmluZycpe1xuICAgICAgcGx1Z05hbWVzLmNvbmNhdChwbHVnaW5OYW1lKTtcbiAgICB9ZWxzZXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1BsdWdpbiBuYW1lcyBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gIH1cbiAgaWYoeWV0aUJveGVzLmxlbmd0aCl7XG4gICAgbGV0IGxpc3RlbmVycyA9IHBsdWdOYW1lcy5tYXAoKG5hbWUpID0+IHtcbiAgICAgIHJldHVybiBgY2xvc2VtZS56Zi4ke25hbWV9YDtcbiAgICB9KS5qb2luKCcgJyk7XG5cbiAgICAkKHdpbmRvdykub2ZmKGxpc3RlbmVycykub24obGlzdGVuZXJzLCBmdW5jdGlvbihlLCBwbHVnaW5JZCl7XG4gICAgICBsZXQgcGx1Z2luID0gZS5uYW1lc3BhY2Uuc3BsaXQoJy4nKVswXTtcbiAgICAgIGxldCBwbHVnaW5zID0gJChgW2RhdGEtJHtwbHVnaW59XWApLm5vdChgW2RhdGEteWV0aS1ib3g9XCIke3BsdWdpbklkfVwiXWApO1xuXG4gICAgICBwbHVnaW5zLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IF90aGlzID0gJCh0aGlzKTtcblxuICAgICAgICBfdGhpcy50cmlnZ2VySGFuZGxlcignY2xvc2UuemYudHJpZ2dlcicsIFtfdGhpc10pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzaXplTGlzdGVuZXIoZGVib3VuY2Upe1xuICBsZXQgdGltZXIsXG4gICAgICAkbm9kZXMgPSAkKCdbZGF0YS1yZXNpemVdJyk7XG4gIGlmKCRub2Rlcy5sZW5ndGgpe1xuICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS56Zi50cmlnZ2VyJylcbiAgICAub24oJ3Jlc2l6ZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRpbWVyKSB7IGNsZWFyVGltZW91dCh0aW1lcik7IH1cblxuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgaWYoIU11dGF0aW9uT2JzZXJ2ZXIpey8vZmFsbGJhY2sgZm9yIElFIDlcbiAgICAgICAgICAkbm9kZXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSByZXNpemUgZXZlbnRcbiAgICAgICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXCJyZXNpemVcIik7XG4gICAgICB9LCBkZWJvdW5jZSB8fCAxMCk7Ly9kZWZhdWx0IHRpbWUgdG8gZW1pdCByZXNpemUgZXZlbnRcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxMaXN0ZW5lcihkZWJvdW5jZSl7XG4gIGxldCB0aW1lcixcbiAgICAgICRub2RlcyA9ICQoJ1tkYXRhLXNjcm9sbF0nKTtcbiAgaWYoJG5vZGVzLmxlbmd0aCl7XG4gICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsLnpmLnRyaWdnZXInKVxuICAgIC5vbignc2Nyb2xsLnpmLnRyaWdnZXInLCBmdW5jdGlvbihlKXtcbiAgICAgIGlmKHRpbWVyKXsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfVxuXG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblxuICAgICAgICBpZighTXV0YXRpb25PYnNlcnZlcil7Ly9mYWxsYmFjayBmb3IgSUUgOVxuICAgICAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKCdzY3JvbGxtZS56Zi50cmlnZ2VyJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy90cmlnZ2VyIGFsbCBsaXN0ZW5pbmcgZWxlbWVudHMgYW5kIHNpZ25hbCBhIHNjcm9sbCBldmVudFxuICAgICAgICAkbm9kZXMuYXR0cignZGF0YS1ldmVudHMnLCBcInNjcm9sbFwiKTtcbiAgICAgIH0sIGRlYm91bmNlIHx8IDEwKTsvL2RlZmF1bHQgdGltZSB0byBlbWl0IHNjcm9sbCBldmVudFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50c0xpc3RlbmVyKCkge1xuICBpZighTXV0YXRpb25PYnNlcnZlcil7IHJldHVybiBmYWxzZTsgfVxuICBsZXQgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1yZXNpemVdLCBbZGF0YS1zY3JvbGxdLCBbZGF0YS1tdXRhdGVdJyk7XG5cbiAgLy9lbGVtZW50IGNhbGxiYWNrXG4gIHZhciBsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uID0gZnVuY3Rpb24obXV0YXRpb25SZWNvcmRzTGlzdCkge1xuICAgIHZhciAkdGFyZ2V0ID0gJChtdXRhdGlvblJlY29yZHNMaXN0WzBdLnRhcmdldCk7XG4gICAgLy90cmlnZ2VyIHRoZSBldmVudCBoYW5kbGVyIGZvciB0aGUgZWxlbWVudCBkZXBlbmRpbmcgb24gdHlwZVxuICAgIHN3aXRjaCAoJHRhcmdldC5hdHRyKFwiZGF0YS1ldmVudHNcIikpIHtcblxuICAgICAgY2FzZSBcInJlc2l6ZVwiIDpcbiAgICAgICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBbJHRhcmdldF0pO1xuICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJzY3JvbGxcIiA6XG4gICAgICAkdGFyZ2V0LnRyaWdnZXJIYW5kbGVyKCdzY3JvbGxtZS56Zi50cmlnZ2VyJywgWyR0YXJnZXQsIHdpbmRvdy5wYWdlWU9mZnNldF0pO1xuICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIGNhc2UgXCJtdXRhdGVcIiA6XG4gICAgICAvLyBjb25zb2xlLmxvZygnbXV0YXRlJywgJHRhcmdldCk7XG4gICAgICAvLyAkdGFyZ2V0LnRyaWdnZXJIYW5kbGVyKCdtdXRhdGUuemYudHJpZ2dlcicpO1xuICAgICAgLy9cbiAgICAgIC8vIC8vbWFrZSBzdXJlIHdlIGRvbid0IGdldCBzdHVjayBpbiBhbiBpbmZpbml0ZSBsb29wIGZyb20gc2xvcHB5IGNvZGVpbmdcbiAgICAgIC8vIGlmICgkdGFyZ2V0LmluZGV4KCdbZGF0YS1tdXRhdGVdJykgPT0gJChcIltkYXRhLW11dGF0ZV1cIikubGVuZ3RoLTEpIHtcbiAgICAgIC8vICAgZG9tTXV0YXRpb25PYnNlcnZlcigpO1xuICAgICAgLy8gfVxuICAgICAgLy8gYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQgOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgLy9ub3RoaW5nXG4gICAgfVxuICB9XG5cbiAgaWYobm9kZXMubGVuZ3RoKXtcbiAgICAvL2ZvciBlYWNoIGVsZW1lbnQgdGhhdCBuZWVkcyB0byBsaXN0ZW4gZm9yIHJlc2l6aW5nLCBzY3JvbGxpbmcsIChvciBjb21pbmcgc29vbiBtdXRhdGlvbikgYWRkIGEgc2luZ2xlIG9ic2VydmVyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbm9kZXMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgbGV0IGVsZW1lbnRPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGxpc3RlbmluZ0VsZW1lbnRzTXV0YXRpb24pO1xuICAgICAgZWxlbWVudE9ic2VydmVyLm9ic2VydmUobm9kZXNbaV0sIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiBmYWxzZSwgY2hhcmFjdGVyRGF0YTogZmFsc2UsIHN1YnRyZWU6ZmFsc2UsIGF0dHJpYnV0ZUZpbHRlcjpbXCJkYXRhLWV2ZW50c1wiXX0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gW1BIXVxuLy8gRm91bmRhdGlvbi5DaGVja1dhdGNoZXJzID0gY2hlY2tXYXRjaGVycztcbkZvdW5kYXRpb24uSUhlYXJZb3UgPSBjaGVja0xpc3RlbmVycztcbi8vIEZvdW5kYXRpb24uSVNlZVlvdSA9IHNjcm9sbExpc3RlbmVyO1xuLy8gRm91bmRhdGlvbi5JRmVlbFlvdSA9IGNsb3NlbWVMaXN0ZW5lcjtcblxufShqUXVlcnkpO1xuXG4vLyBmdW5jdGlvbiBkb21NdXRhdGlvbk9ic2VydmVyKGRlYm91bmNlKSB7XG4vLyAgIC8vICEhISBUaGlzIGlzIGNvbWluZyBzb29uIGFuZCBuZWVkcyBtb3JlIHdvcms7IG5vdCBhY3RpdmUgICEhISAvL1xuLy8gICB2YXIgdGltZXIsXG4vLyAgIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbXV0YXRlXScpO1xuLy8gICAvL1xuLy8gICBpZiAobm9kZXMubGVuZ3RoKSB7XG4vLyAgICAgLy8gdmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuLy8gICAgIC8vICAgdmFyIHByZWZpeGVzID0gWydXZWJLaXQnLCAnTW96JywgJ08nLCAnTXMnLCAnJ107XG4vLyAgICAgLy8gICBmb3IgKHZhciBpPTA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuLy8gICAgIC8vICAgICBpZiAocHJlZml4ZXNbaV0gKyAnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4vLyAgICAgLy8gICAgICAgcmV0dXJuIHdpbmRvd1twcmVmaXhlc1tpXSArICdNdXRhdGlvbk9ic2VydmVyJ107XG4vLyAgICAgLy8gICAgIH1cbi8vICAgICAvLyAgIH1cbi8vICAgICAvLyAgIHJldHVybiBmYWxzZTtcbi8vICAgICAvLyB9KCkpO1xuLy9cbi8vXG4vLyAgICAgLy9mb3IgdGhlIGJvZHksIHdlIG5lZWQgdG8gbGlzdGVuIGZvciBhbGwgY2hhbmdlcyBlZmZlY3RpbmcgdGhlIHN0eWxlIGFuZCBjbGFzcyBhdHRyaWJ1dGVzXG4vLyAgICAgdmFyIGJvZHlPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGJvZHlNdXRhdGlvbik7XG4vLyAgICAgYm9keU9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIGNoYXJhY3RlckRhdGE6IGZhbHNlLCBzdWJ0cmVlOnRydWUsIGF0dHJpYnV0ZUZpbHRlcjpbXCJzdHlsZVwiLCBcImNsYXNzXCJdfSk7XG4vL1xuLy9cbi8vICAgICAvL2JvZHkgY2FsbGJhY2tcbi8vICAgICBmdW5jdGlvbiBib2R5TXV0YXRpb24obXV0YXRlKSB7XG4vLyAgICAgICAvL3RyaWdnZXIgYWxsIGxpc3RlbmluZyBlbGVtZW50cyBhbmQgc2lnbmFsIGEgbXV0YXRpb24gZXZlbnRcbi8vICAgICAgIGlmICh0aW1lcikgeyBjbGVhclRpbWVvdXQodGltZXIpOyB9XG4vL1xuLy8gICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICBib2R5T2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuLy8gICAgICAgICAkKCdbZGF0YS1tdXRhdGVdJykuYXR0cignZGF0YS1ldmVudHMnLFwibXV0YXRlXCIpO1xuLy8gICAgICAgfSwgZGVib3VuY2UgfHwgMTUwKTtcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cbiIsIi8qIVxuICogTWFzb25yeSBQQUNLQUdFRCB2NC4xLjFcbiAqIENhc2NhZGluZyBncmlkIGxheW91dCBsaWJyYXJ5XG4gKiBodHRwOi8vbWFzb25yeS5kZXNhbmRyby5jb21cbiAqIE1JVCBMaWNlbnNlXG4gKiBieSBEYXZpZCBEZVNhbmRyb1xuICovXG5cbi8qKlxuICogQnJpZGdldCBtYWtlcyBqUXVlcnkgd2lkZ2V0c1xuICogdjIuMC4xXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qIGpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLypqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKiBnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCAnanF1ZXJ5LWJyaWRnZXQvanF1ZXJ5LWJyaWRnZXQnLFsgJ2pxdWVyeScgXSwgZnVuY3Rpb24oIGpRdWVyeSApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIGpRdWVyeSApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnanF1ZXJ5JylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LmpRdWVyeUJyaWRnZXQgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LmpRdWVyeVxuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIGpRdWVyeSApIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0gdXRpbHMgLS0tLS0gLy9cblxudmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbG9nZ2luZyBlcnJvcnNcbi8vICQuZXJyb3IgYnJlYWtzIGpRdWVyeSBjaGFpbmluZ1xudmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcbnZhciBsb2dFcnJvciA9IHR5cGVvZiBjb25zb2xlID09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24oKSB7fSA6XG4gIGZ1bmN0aW9uKCBtZXNzYWdlICkge1xuICAgIGNvbnNvbGUuZXJyb3IoIG1lc3NhZ2UgKTtcbiAgfTtcblxuLy8gLS0tLS0galF1ZXJ5QnJpZGdldCAtLS0tLSAvL1xuXG5mdW5jdGlvbiBqUXVlcnlCcmlkZ2V0KCBuYW1lc3BhY2UsIFBsdWdpbkNsYXNzLCAkICkge1xuICAkID0gJCB8fCBqUXVlcnkgfHwgd2luZG93LmpRdWVyeTtcbiAgaWYgKCAhJCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhZGQgb3B0aW9uIG1ldGhvZCAtPiAkKCkucGx1Z2luKCdvcHRpb24nLCB7Li4ufSlcbiAgaWYgKCAhUGx1Z2luQ2xhc3MucHJvdG90eXBlLm9wdGlvbiApIHtcbiAgICAvLyBvcHRpb24gc2V0dGVyXG4gICAgUGx1Z2luQ2xhc3MucHJvdG90eXBlLm9wdGlvbiA9IGZ1bmN0aW9uKCBvcHRzICkge1xuICAgICAgLy8gYmFpbCBvdXQgaWYgbm90IGFuIG9iamVjdFxuICAgICAgaWYgKCAhJC5pc1BsYWluT2JqZWN0KCBvcHRzICkgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoIHRydWUsIHRoaXMub3B0aW9ucywgb3B0cyApO1xuICAgIH07XG4gIH1cblxuICAvLyBtYWtlIGpRdWVyeSBwbHVnaW5cbiAgJC5mblsgbmFtZXNwYWNlIF0gPSBmdW5jdGlvbiggYXJnMCAvKiwgYXJnMSAqLyApIHtcbiAgICBpZiAoIHR5cGVvZiBhcmcwID09ICdzdHJpbmcnICkge1xuICAgICAgLy8gbWV0aG9kIGNhbGwgJCgpLnBsdWdpbiggJ21ldGhvZE5hbWUnLCB7IG9wdGlvbnMgfSApXG4gICAgICAvLyBzaGlmdCBhcmd1bWVudHMgYnkgMVxuICAgICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuICAgICAgcmV0dXJuIG1ldGhvZENhbGwoIHRoaXMsIGFyZzAsIGFyZ3MgKTtcbiAgICB9XG4gICAgLy8ganVzdCAkKCkucGx1Z2luKHsgb3B0aW9ucyB9KVxuICAgIHBsYWluQ2FsbCggdGhpcywgYXJnMCApO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vICQoKS5wbHVnaW4oJ21ldGhvZE5hbWUnKVxuICBmdW5jdGlvbiBtZXRob2RDYWxsKCAkZWxlbXMsIG1ldGhvZE5hbWUsIGFyZ3MgKSB7XG4gICAgdmFyIHJldHVyblZhbHVlO1xuICAgIHZhciBwbHVnaW5NZXRob2RTdHIgPSAnJCgpLicgKyBuYW1lc3BhY2UgKyAnKFwiJyArIG1ldGhvZE5hbWUgKyAnXCIpJztcblxuICAgICRlbGVtcy5lYWNoKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcbiAgICAgIC8vIGdldCBpbnN0YW5jZVxuICAgICAgdmFyIGluc3RhbmNlID0gJC5kYXRhKCBlbGVtLCBuYW1lc3BhY2UgKTtcbiAgICAgIGlmICggIWluc3RhbmNlICkge1xuICAgICAgICBsb2dFcnJvciggbmFtZXNwYWNlICsgJyBub3QgaW5pdGlhbGl6ZWQuIENhbm5vdCBjYWxsIG1ldGhvZHMsIGkuZS4gJyArXG4gICAgICAgICAgcGx1Z2luTWV0aG9kU3RyICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1ldGhvZCA9IGluc3RhbmNlWyBtZXRob2ROYW1lIF07XG4gICAgICBpZiAoICFtZXRob2QgfHwgbWV0aG9kTmFtZS5jaGFyQXQoMCkgPT0gJ18nICkge1xuICAgICAgICBsb2dFcnJvciggcGx1Z2luTWV0aG9kU3RyICsgJyBpcyBub3QgYSB2YWxpZCBtZXRob2QnICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgbWV0aG9kLCBnZXQgcmV0dXJuIHZhbHVlXG4gICAgICB2YXIgdmFsdWUgPSBtZXRob2QuYXBwbHkoIGluc3RhbmNlLCBhcmdzICk7XG4gICAgICAvLyBzZXQgcmV0dXJuIHZhbHVlIGlmIHZhbHVlIGlzIHJldHVybmVkLCB1c2Ugb25seSBmaXJzdCB2YWx1ZVxuICAgICAgcmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZSA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiByZXR1cm5WYWx1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkID8gcmV0dXJuVmFsdWUgOiAkZWxlbXM7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFpbkNhbGwoICRlbGVtcywgb3B0aW9ucyApIHtcbiAgICAkZWxlbXMuZWFjaCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIGVsZW0sIG5hbWVzcGFjZSApO1xuICAgICAgaWYgKCBpbnN0YW5jZSApIHtcbiAgICAgICAgLy8gc2V0IG9wdGlvbnMgJiBpbml0XG4gICAgICAgIGluc3RhbmNlLm9wdGlvbiggb3B0aW9ucyApO1xuICAgICAgICBpbnN0YW5jZS5faW5pdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBuZXcgaW5zdGFuY2VcbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgUGx1Z2luQ2xhc3MoIGVsZW0sIG9wdGlvbnMgKTtcbiAgICAgICAgJC5kYXRhKCBlbGVtLCBuYW1lc3BhY2UsIGluc3RhbmNlICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVKUXVlcnkoICQgKTtcblxufVxuXG4vLyAtLS0tLSB1cGRhdGVKUXVlcnkgLS0tLS0gLy9cblxuLy8gc2V0ICQuYnJpZGdldCBmb3IgdjEgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmZ1bmN0aW9uIHVwZGF0ZUpRdWVyeSggJCApIHtcbiAgaWYgKCAhJCB8fCAoICQgJiYgJC5icmlkZ2V0ICkgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gICQuYnJpZGdldCA9IGpRdWVyeUJyaWRnZXQ7XG59XG5cbnVwZGF0ZUpRdWVyeSggalF1ZXJ5IHx8IHdpbmRvdy5qUXVlcnkgKTtcblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbnJldHVybiBqUXVlcnlCcmlkZ2V0O1xuXG59KSk7XG5cbi8qKlxuICogRXZFbWl0dGVyIHYxLjAuM1xuICogTGlsJyBldmVudCBlbWl0dGVyXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbi8qIGpzaGludCB1bnVzZWQ6IHRydWUsIHVuZGVmOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgd2luZG93ICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EIC0gUmVxdWlyZUpTXG4gICAgZGVmaW5lKCAnZXYtZW1pdHRlci9ldi1lbWl0dGVyJyxmYWN0b3J5ICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZ2xvYmFsLkV2RW1pdHRlciA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KCB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oKSB7XG5cblxuXG5mdW5jdGlvbiBFdkVtaXR0ZXIoKSB7fVxuXG52YXIgcHJvdG8gPSBFdkVtaXR0ZXIucHJvdG90eXBlO1xuXG5wcm90by5vbiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzZXQgZXZlbnRzIGhhc2hcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IGxpc3RlbmVycyBhcnJheVxuICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzWyBldmVudE5hbWUgXSA9IGV2ZW50c1sgZXZlbnROYW1lIF0gfHwgW107XG4gIC8vIG9ubHkgYWRkIG9uY2VcbiAgaWYgKCBsaXN0ZW5lcnMuaW5kZXhPZiggbGlzdGVuZXIgKSA9PSAtMSApIHtcbiAgICBsaXN0ZW5lcnMucHVzaCggbGlzdGVuZXIgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ub25jZSA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBhZGQgZXZlbnRcbiAgdGhpcy5vbiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICAvLyBzZXQgb25jZSBmbGFnXG4gIC8vIHNldCBvbmNlRXZlbnRzIGhhc2hcbiAgdmFyIG9uY2VFdmVudHMgPSB0aGlzLl9vbmNlRXZlbnRzID0gdGhpcy5fb25jZUV2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IG9uY2VMaXN0ZW5lcnMgb2JqZWN0XG4gIHZhciBvbmNlTGlzdGVuZXJzID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gPSBvbmNlRXZlbnRzWyBldmVudE5hbWUgXSB8fCB7fTtcbiAgLy8gc2V0IGZsYWdcbiAgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5vZmYgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbIGV2ZW50TmFtZSBdO1xuICBpZiAoICFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKCBsaXN0ZW5lciApO1xuICBpZiAoIGluZGV4ICE9IC0xICkge1xuICAgIGxpc3RlbmVycy5zcGxpY2UoIGluZGV4LCAxICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmVtaXRFdmVudCA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGFyZ3MgKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgaWYgKCAhbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaSA9IDA7XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgYXJncyA9IGFyZ3MgfHwgW107XG4gIC8vIG9uY2Ugc3R1ZmZcbiAgdmFyIG9uY2VMaXN0ZW5lcnMgPSB0aGlzLl9vbmNlRXZlbnRzICYmIHRoaXMuX29uY2VFdmVudHNbIGV2ZW50TmFtZSBdO1xuXG4gIHdoaWxlICggbGlzdGVuZXIgKSB7XG4gICAgdmFyIGlzT25jZSA9IG9uY2VMaXN0ZW5lcnMgJiYgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXTtcbiAgICBpZiAoIGlzT25jZSApIHtcbiAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lclxuICAgICAgLy8gcmVtb3ZlIGJlZm9yZSB0cmlnZ2VyIHRvIHByZXZlbnQgcmVjdXJzaW9uXG4gICAgICB0aGlzLm9mZiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICAgICAgLy8gdW5zZXQgb25jZSBmbGFnXG4gICAgICBkZWxldGUgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXTtcbiAgICB9XG4gICAgLy8gdHJpZ2dlciBsaXN0ZW5lclxuICAgIGxpc3RlbmVyLmFwcGx5KCB0aGlzLCBhcmdzICk7XG4gICAgLy8gZ2V0IG5leHQgbGlzdGVuZXJcbiAgICBpICs9IGlzT25jZSA/IDAgOiAxO1xuICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5yZXR1cm4gRXZFbWl0dGVyO1xuXG59KSk7XG5cbi8qIVxuICogZ2V0U2l6ZSB2Mi4wLjJcbiAqIG1lYXN1cmUgc2l6ZSBvZiBlbGVtZW50c1xuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cbi8qZ2xvYmFsIGRlZmluZTogZmFsc2UsIG1vZHVsZTogZmFsc2UsIGNvbnNvbGU6IGZhbHNlICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCAnZ2V0LXNpemUvZ2V0LXNpemUnLFtdLGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LmdldFNpemUgPSBmYWN0b3J5KCk7XG4gIH1cblxufSkoIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSgpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGVscGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBnZXQgYSBudW1iZXIgZnJvbSBhIHN0cmluZywgbm90IGEgcGVyY2VudGFnZVxuZnVuY3Rpb24gZ2V0U3R5bGVTaXplKCB2YWx1ZSApIHtcbiAgdmFyIG51bSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG4gIC8vIG5vdCBhIHBlcmNlbnQgbGlrZSAnMTAwJScsIGFuZCBhIG51bWJlclxuICB2YXIgaXNWYWxpZCA9IHZhbHVlLmluZGV4T2YoJyUnKSA9PSAtMSAmJiAhaXNOYU4oIG51bSApO1xuICByZXR1cm4gaXNWYWxpZCAmJiBudW07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgbG9nRXJyb3IgPSB0eXBlb2YgY29uc29sZSA9PSAndW5kZWZpbmVkJyA/IG5vb3AgOlxuICBmdW5jdGlvbiggbWVzc2FnZSApIHtcbiAgICBjb25zb2xlLmVycm9yKCBtZXNzYWdlICk7XG4gIH07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1lYXN1cmVtZW50cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG52YXIgbWVhc3VyZW1lbnRzID0gW1xuICAncGFkZGluZ0xlZnQnLFxuICAncGFkZGluZ1JpZ2h0JyxcbiAgJ3BhZGRpbmdUb3AnLFxuICAncGFkZGluZ0JvdHRvbScsXG4gICdtYXJnaW5MZWZ0JyxcbiAgJ21hcmdpblJpZ2h0JyxcbiAgJ21hcmdpblRvcCcsXG4gICdtYXJnaW5Cb3R0b20nLFxuICAnYm9yZGVyTGVmdFdpZHRoJyxcbiAgJ2JvcmRlclJpZ2h0V2lkdGgnLFxuICAnYm9yZGVyVG9wV2lkdGgnLFxuICAnYm9yZGVyQm90dG9tV2lkdGgnXG5dO1xuXG52YXIgbWVhc3VyZW1lbnRzTGVuZ3RoID0gbWVhc3VyZW1lbnRzLmxlbmd0aDtcblxuZnVuY3Rpb24gZ2V0WmVyb1NpemUoKSB7XG4gIHZhciBzaXplID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBpbm5lcldpZHRoOiAwLFxuICAgIGlubmVySGVpZ2h0OiAwLFxuICAgIG91dGVyV2lkdGg6IDAsXG4gICAgb3V0ZXJIZWlnaHQ6IDBcbiAgfTtcbiAgZm9yICggdmFyIGk9MDsgaSA8IG1lYXN1cmVtZW50c0xlbmd0aDsgaSsrICkge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gMDtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZ2V0U3R5bGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBnZXRTdHlsZSwgZ2V0IHN0eWxlIG9mIGVsZW1lbnQsIGNoZWNrIGZvciBGaXJlZm94IGJ1Z1xuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlKCBlbGVtICkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG4gIGlmICggIXN0eWxlICkge1xuICAgIGxvZ0Vycm9yKCAnU3R5bGUgcmV0dXJuZWQgJyArIHN0eWxlICtcbiAgICAgICcuIEFyZSB5b3UgcnVubmluZyB0aGlzIGNvZGUgaW4gYSBoaWRkZW4gaWZyYW1lIG9uIEZpcmVmb3g/ICcgK1xuICAgICAgJ1NlZSBodHRwOi8vYml0Lmx5L2dldHNpemVidWcxJyApO1xuICB9XG4gIHJldHVybiBzdHlsZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gc2V0dXAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxudmFyIGlzU2V0dXAgPSBmYWxzZTtcblxudmFyIGlzQm94U2l6ZU91dGVyO1xuXG4vKipcbiAqIHNldHVwXG4gKiBjaGVjayBpc0JveFNpemVyT3V0ZXJcbiAqIGRvIG9uIGZpcnN0IGdldFNpemUoKSByYXRoZXIgdGhhbiBvbiBwYWdlIGxvYWQgZm9yIEZpcmVmb3ggYnVnXG4gKi9cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAvLyBzZXR1cCBvbmNlXG4gIGlmICggaXNTZXR1cCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaXNTZXR1cCA9IHRydWU7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gYm94IHNpemluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gIC8qKlxuICAgKiBXZWJLaXQgbWVhc3VyZXMgdGhlIG91dGVyLXdpZHRoIG9uIHN0eWxlLndpZHRoIG9uIGJvcmRlci1ib3ggZWxlbXNcbiAgICogSUUgJiBGaXJlZm94PDI5IG1lYXN1cmVzIHRoZSBpbm5lci13aWR0aFxuICAgKi9cbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuc3R5bGUud2lkdGggPSAnMjAwcHgnO1xuICBkaXYuc3R5bGUucGFkZGluZyA9ICcxcHggMnB4IDNweCA0cHgnO1xuICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSAnc29saWQnO1xuICBkaXYuc3R5bGUuYm9yZGVyV2lkdGggPSAnMXB4IDJweCAzcHggNHB4JztcbiAgZGl2LnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcblxuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBib2R5LmFwcGVuZENoaWxkKCBkaXYgKTtcbiAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoIGRpdiApO1xuXG4gIGdldFNpemUuaXNCb3hTaXplT3V0ZXIgPSBpc0JveFNpemVPdXRlciA9IGdldFN0eWxlU2l6ZSggc3R5bGUud2lkdGggKSA9PSAyMDA7XG4gIGJvZHkucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGdldFNpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gZ2V0U2l6ZSggZWxlbSApIHtcbiAgc2V0dXAoKTtcblxuICAvLyB1c2UgcXVlcnlTZWxldG9yIGlmIGVsZW0gaXMgc3RyaW5nXG4gIGlmICggdHlwZW9mIGVsZW0gPT0gJ3N0cmluZycgKSB7XG4gICAgZWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGVsZW0gKTtcbiAgfVxuXG4gIC8vIGRvIG5vdCBwcm9jZWVkIG9uIG5vbi1vYmplY3RzXG4gIGlmICggIWVsZW0gfHwgdHlwZW9mIGVsZW0gIT0gJ29iamVjdCcgfHwgIWVsZW0ubm9kZVR5cGUgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoIGVsZW0gKTtcblxuICAvLyBpZiBoaWRkZW4sIGV2ZXJ5dGhpbmcgaXMgMFxuICBpZiAoIHN0eWxlLmRpc3BsYXkgPT0gJ25vbmUnICkge1xuICAgIHJldHVybiBnZXRaZXJvU2l6ZSgpO1xuICB9XG5cbiAgdmFyIHNpemUgPSB7fTtcbiAgc2l6ZS53aWR0aCA9IGVsZW0ub2Zmc2V0V2lkdGg7XG4gIHNpemUuaGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XG5cbiAgdmFyIGlzQm9yZGVyQm94ID0gc2l6ZS5pc0JvcmRlckJveCA9IHN0eWxlLmJveFNpemluZyA9PSAnYm9yZGVyLWJveCc7XG5cbiAgLy8gZ2V0IGFsbCBtZWFzdXJlbWVudHNcbiAgZm9yICggdmFyIGk9MDsgaSA8IG1lYXN1cmVtZW50c0xlbmd0aDsgaSsrICkge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZVsgbWVhc3VyZW1lbnQgXTtcbiAgICB2YXIgbnVtID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcbiAgICAvLyBhbnkgJ2F1dG8nLCAnbWVkaXVtJyB2YWx1ZSB3aWxsIGJlIDBcbiAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gIWlzTmFOKCBudW0gKSA/IG51bSA6IDA7XG4gIH1cblxuICB2YXIgcGFkZGluZ1dpZHRoID0gc2l6ZS5wYWRkaW5nTGVmdCArIHNpemUucGFkZGluZ1JpZ2h0O1xuICB2YXIgcGFkZGluZ0hlaWdodCA9IHNpemUucGFkZGluZ1RvcCArIHNpemUucGFkZGluZ0JvdHRvbTtcbiAgdmFyIG1hcmdpbldpZHRoID0gc2l6ZS5tYXJnaW5MZWZ0ICsgc2l6ZS5tYXJnaW5SaWdodDtcbiAgdmFyIG1hcmdpbkhlaWdodCA9IHNpemUubWFyZ2luVG9wICsgc2l6ZS5tYXJnaW5Cb3R0b207XG4gIHZhciBib3JkZXJXaWR0aCA9IHNpemUuYm9yZGVyTGVmdFdpZHRoICsgc2l6ZS5ib3JkZXJSaWdodFdpZHRoO1xuICB2YXIgYm9yZGVySGVpZ2h0ID0gc2l6ZS5ib3JkZXJUb3BXaWR0aCArIHNpemUuYm9yZGVyQm90dG9tV2lkdGg7XG5cbiAgdmFyIGlzQm9yZGVyQm94U2l6ZU91dGVyID0gaXNCb3JkZXJCb3ggJiYgaXNCb3hTaXplT3V0ZXI7XG5cbiAgLy8gb3ZlcndyaXRlIHdpZHRoIGFuZCBoZWlnaHQgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHN0eWxlXG4gIHZhciBzdHlsZVdpZHRoID0gZ2V0U3R5bGVTaXplKCBzdHlsZS53aWR0aCApO1xuICBpZiAoIHN0eWxlV2lkdGggIT09IGZhbHNlICkge1xuICAgIHNpemUud2lkdGggPSBzdHlsZVdpZHRoICtcbiAgICAgIC8vIGFkZCBwYWRkaW5nIGFuZCBib3JkZXIgdW5sZXNzIGl0J3MgYWxyZWFkeSBpbmNsdWRpbmcgaXRcbiAgICAgICggaXNCb3JkZXJCb3hTaXplT3V0ZXIgPyAwIDogcGFkZGluZ1dpZHRoICsgYm9yZGVyV2lkdGggKTtcbiAgfVxuXG4gIHZhciBzdHlsZUhlaWdodCA9IGdldFN0eWxlU2l6ZSggc3R5bGUuaGVpZ2h0ICk7XG4gIGlmICggc3R5bGVIZWlnaHQgIT09IGZhbHNlICkge1xuICAgIHNpemUuaGVpZ2h0ID0gc3R5bGVIZWlnaHQgK1xuICAgICAgLy8gYWRkIHBhZGRpbmcgYW5kIGJvcmRlciB1bmxlc3MgaXQncyBhbHJlYWR5IGluY2x1ZGluZyBpdFxuICAgICAgKCBpc0JvcmRlckJveFNpemVPdXRlciA/IDAgOiBwYWRkaW5nSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICk7XG4gIH1cblxuICBzaXplLmlubmVyV2lkdGggPSBzaXplLndpZHRoIC0gKCBwYWRkaW5nV2lkdGggKyBib3JkZXJXaWR0aCApO1xuICBzaXplLmlubmVySGVpZ2h0ID0gc2l6ZS5oZWlnaHQgLSAoIHBhZGRpbmdIZWlnaHQgKyBib3JkZXJIZWlnaHQgKTtcblxuICBzaXplLm91dGVyV2lkdGggPSBzaXplLndpZHRoICsgbWFyZ2luV2lkdGg7XG4gIHNpemUub3V0ZXJIZWlnaHQgPSBzaXplLmhlaWdodCArIG1hcmdpbkhlaWdodDtcblxuICByZXR1cm4gc2l6ZTtcbn1cblxucmV0dXJuIGdldFNpemU7XG5cbn0pO1xuXG4vKipcbiAqIG1hdGNoZXNTZWxlY3RvciB2Mi4wLjFcbiAqIG1hdGNoZXNTZWxlY3RvciggZWxlbWVudCwgJy5zZWxlY3RvcicgKVxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvKmdsb2JhbCBkZWZpbmU6IGZhbHNlLCBtb2R1bGU6IGZhbHNlICovXG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCAnZGVzYW5kcm8tbWF0Y2hlcy1zZWxlY3Rvci9tYXRjaGVzLXNlbGVjdG9yJyxmYWN0b3J5ICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5tYXRjaGVzU2VsZWN0b3IgPSBmYWN0b3J5KCk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIG1hdGNoZXNNZXRob2QgPSAoIGZ1bmN0aW9uKCkge1xuICAgIHZhciBFbGVtUHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcbiAgICAvLyBjaGVjayBmb3IgdGhlIHN0YW5kYXJkIG1ldGhvZCBuYW1lIGZpcnN0XG4gICAgaWYgKCBFbGVtUHJvdG8ubWF0Y2hlcyApIHtcbiAgICAgIHJldHVybiAnbWF0Y2hlcyc7XG4gICAgfVxuICAgIC8vIGNoZWNrIHVuLXByZWZpeGVkXG4gICAgaWYgKCBFbGVtUHJvdG8ubWF0Y2hlc1NlbGVjdG9yICkge1xuICAgICAgcmV0dXJuICdtYXRjaGVzU2VsZWN0b3InO1xuICAgIH1cbiAgICAvLyBjaGVjayB2ZW5kb3IgcHJlZml4ZXNcbiAgICB2YXIgcHJlZml4ZXMgPSBbICd3ZWJraXQnLCAnbW96JywgJ21zJywgJ28nIF07XG5cbiAgICBmb3IgKCB2YXIgaT0wOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgICB2YXIgbWV0aG9kID0gcHJlZml4ICsgJ01hdGNoZXNTZWxlY3Rvcic7XG4gICAgICBpZiAoIEVsZW1Qcm90b1sgbWV0aG9kIF0gKSB7XG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3IoIGVsZW0sIHNlbGVjdG9yICkge1xuICAgIHJldHVybiBlbGVtWyBtYXRjaGVzTWV0aG9kIF0oIHNlbGVjdG9yICk7XG4gIH07XG5cbn0pKTtcblxuLyoqXG4gKiBGaXp6eSBVSSB1dGlscyB2Mi4wLjJcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qanNoaW50IHN0cmljdDogZmFsc2UgKi8gLypnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG5cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoICdmaXp6eS11aS11dGlscy91dGlscycsW1xuICAgICAgJ2Rlc2FuZHJvLW1hdGNoZXMtc2VsZWN0b3IvbWF0Y2hlcy1zZWxlY3RvcidcbiAgICBdLCBmdW5jdGlvbiggbWF0Y2hlc1NlbGVjdG9yICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgbWF0Y2hlc1NlbGVjdG9yICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCdkZXNhbmRyby1tYXRjaGVzLXNlbGVjdG9yJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LmZpenp5VUlVdGlscyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cubWF0Y2hlc1NlbGVjdG9yXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgbWF0Y2hlc1NlbGVjdG9yICkge1xuXG5cblxudmFyIHV0aWxzID0ge307XG5cbi8vIC0tLS0tIGV4dGVuZCAtLS0tLSAvL1xuXG4vLyBleHRlbmRzIG9iamVjdHNcbnV0aWxzLmV4dGVuZCA9IGZ1bmN0aW9uKCBhLCBiICkge1xuICBmb3IgKCB2YXIgcHJvcCBpbiBiICkge1xuICAgIGFbIHByb3AgXSA9IGJbIHByb3AgXTtcbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8vIC0tLS0tIG1vZHVsbyAtLS0tLSAvL1xuXG51dGlscy5tb2R1bG8gPSBmdW5jdGlvbiggbnVtLCBkaXYgKSB7XG4gIHJldHVybiAoICggbnVtICUgZGl2ICkgKyBkaXYgKSAlIGRpdjtcbn07XG5cbi8vIC0tLS0tIG1ha2VBcnJheSAtLS0tLSAvL1xuXG4vLyB0dXJuIGVsZW1lbnQgb3Igbm9kZUxpc3QgaW50byBhbiBhcnJheVxudXRpbHMubWFrZUFycmF5ID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgdmFyIGFyeSA9IFtdO1xuICBpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuICAgIC8vIHVzZSBvYmplY3QgaWYgYWxyZWFkeSBhbiBhcnJheVxuICAgIGFyeSA9IG9iajtcbiAgfSBlbHNlIGlmICggb2JqICYmIHR5cGVvZiBvYmoubGVuZ3RoID09ICdudW1iZXInICkge1xuICAgIC8vIGNvbnZlcnQgbm9kZUxpc3QgdG8gYXJyYXlcbiAgICBmb3IgKCB2YXIgaT0wOyBpIDwgb2JqLmxlbmd0aDsgaSsrICkge1xuICAgICAgYXJ5LnB1c2goIG9ialtpXSApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBhcnJheSBvZiBzaW5nbGUgaW5kZXhcbiAgICBhcnkucHVzaCggb2JqICk7XG4gIH1cbiAgcmV0dXJuIGFyeTtcbn07XG5cbi8vIC0tLS0tIHJlbW92ZUZyb20gLS0tLS0gLy9cblxudXRpbHMucmVtb3ZlRnJvbSA9IGZ1bmN0aW9uKCBhcnksIG9iaiApIHtcbiAgdmFyIGluZGV4ID0gYXJ5LmluZGV4T2YoIG9iaiApO1xuICBpZiAoIGluZGV4ICE9IC0xICkge1xuICAgIGFyeS5zcGxpY2UoIGluZGV4LCAxICk7XG4gIH1cbn07XG5cbi8vIC0tLS0tIGdldFBhcmVudCAtLS0tLSAvL1xuXG51dGlscy5nZXRQYXJlbnQgPSBmdW5jdGlvbiggZWxlbSwgc2VsZWN0b3IgKSB7XG4gIHdoaWxlICggZWxlbSAhPSBkb2N1bWVudC5ib2R5ICkge1xuICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgaWYgKCBtYXRjaGVzU2VsZWN0b3IoIGVsZW0sIHNlbGVjdG9yICkgKSB7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIC0tLS0tIGdldFF1ZXJ5RWxlbWVudCAtLS0tLSAvL1xuXG4vLyB1c2UgZWxlbWVudCBhcyBzZWxlY3RvciBzdHJpbmdcbnV0aWxzLmdldFF1ZXJ5RWxlbWVudCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICBpZiAoIHR5cGVvZiBlbGVtID09ICdzdHJpbmcnICkge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBlbGVtICk7XG4gIH1cbiAgcmV0dXJuIGVsZW07XG59O1xuXG4vLyAtLS0tLSBoYW5kbGVFdmVudCAtLS0tLSAvL1xuXG4vLyBlbmFibGUgLm9udHlwZSB0byB0cmlnZ2VyIGZyb20gLmFkZEV2ZW50TGlzdGVuZXIoIGVsZW0sICd0eXBlJyApXG51dGlscy5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIG1ldGhvZCA9ICdvbicgKyBldmVudC50eXBlO1xuICBpZiAoIHRoaXNbIG1ldGhvZCBdICkge1xuICAgIHRoaXNbIG1ldGhvZCBdKCBldmVudCApO1xuICB9XG59O1xuXG4vLyAtLS0tLSBmaWx0ZXJGaW5kRWxlbWVudHMgLS0tLS0gLy9cblxudXRpbHMuZmlsdGVyRmluZEVsZW1lbnRzID0gZnVuY3Rpb24oIGVsZW1zLCBzZWxlY3RvciApIHtcbiAgLy8gbWFrZSBhcnJheSBvZiBlbGVtc1xuICBlbGVtcyA9IHV0aWxzLm1ha2VBcnJheSggZWxlbXMgKTtcbiAgdmFyIGZmRWxlbXMgPSBbXTtcblxuICBlbGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAvLyBjaGVjayB0aGF0IGVsZW0gaXMgYW4gYWN0dWFsIGVsZW1lbnRcbiAgICBpZiAoICEoIGVsZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCApICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhZGQgZWxlbSBpZiBubyBzZWxlY3RvclxuICAgIGlmICggIXNlbGVjdG9yICkge1xuICAgICAgZmZFbGVtcy5wdXNoKCBlbGVtICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGZpbHRlciAmIGZpbmQgaXRlbXMgaWYgd2UgaGF2ZSBhIHNlbGVjdG9yXG4gICAgLy8gZmlsdGVyXG4gICAgaWYgKCBtYXRjaGVzU2VsZWN0b3IoIGVsZW0sIHNlbGVjdG9yICkgKSB7XG4gICAgICBmZkVsZW1zLnB1c2goIGVsZW0gKTtcbiAgICB9XG4gICAgLy8gZmluZCBjaGlsZHJlblxuICAgIHZhciBjaGlsZEVsZW1zID0gZWxlbS5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApO1xuICAgIC8vIGNvbmNhdCBjaGlsZEVsZW1zIHRvIGZpbHRlckZvdW5kIGFycmF5XG4gICAgZm9yICggdmFyIGk9MDsgaSA8IGNoaWxkRWxlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICBmZkVsZW1zLnB1c2goIGNoaWxkRWxlbXNbaV0gKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmZkVsZW1zO1xufTtcblxuLy8gLS0tLS0gZGVib3VuY2VNZXRob2QgLS0tLS0gLy9cblxudXRpbHMuZGVib3VuY2VNZXRob2QgPSBmdW5jdGlvbiggX2NsYXNzLCBtZXRob2ROYW1lLCB0aHJlc2hvbGQgKSB7XG4gIC8vIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgbWV0aG9kID0gX2NsYXNzLnByb3RvdHlwZVsgbWV0aG9kTmFtZSBdO1xuICB2YXIgdGltZW91dE5hbWUgPSBtZXRob2ROYW1lICsgJ1RpbWVvdXQnO1xuXG4gIF9jbGFzcy5wcm90b3R5cGVbIG1ldGhvZE5hbWUgXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpc1sgdGltZW91dE5hbWUgXTtcbiAgICBpZiAoIHRpbWVvdXQgKSB7XG4gICAgICBjbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXNbIHRpbWVvdXROYW1lIF0gPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgIG1ldGhvZC5hcHBseSggX3RoaXMsIGFyZ3MgKTtcbiAgICAgIGRlbGV0ZSBfdGhpc1sgdGltZW91dE5hbWUgXTtcbiAgICB9LCB0aHJlc2hvbGQgfHwgMTAwICk7XG4gIH07XG59O1xuXG4vLyAtLS0tLSBkb2NSZWFkeSAtLS0tLSAvL1xuXG51dGlscy5kb2NSZWFkeSA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcbiAgdmFyIHJlYWR5U3RhdGUgPSBkb2N1bWVudC5yZWFkeVN0YXRlO1xuICBpZiAoIHJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJyB8fCByZWFkeVN0YXRlID09ICdpbnRlcmFjdGl2ZScgKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBlbHNlIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnRE9NQ29udGVudExvYWRlZCcsIGNhbGxiYWNrICk7XG4gIH1cbn07XG5cbi8vIC0tLS0tIGh0bWxJbml0IC0tLS0tIC8vXG5cbi8vIGh0dHA6Ly9qYW1lc3JvYmVydHMubmFtZS9ibG9nLzIwMTAvMDIvMjIvc3RyaW5nLWZ1bmN0aW9ucy1mb3ItamF2YXNjcmlwdC10cmltLXRvLWNhbWVsLWNhc2UtdG8tZGFzaGVkLWFuZC10by11bmRlcnNjb3JlL1xudXRpbHMudG9EYXNoZWQgPSBmdW5jdGlvbiggc3RyICkge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoIC8oLikoW0EtWl0pL2csIGZ1bmN0aW9uKCBtYXRjaCwgJDEsICQyICkge1xuICAgIHJldHVybiAkMSArICctJyArICQyO1xuICB9KS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcbi8qKlxuICogYWxsb3cgdXNlciB0byBpbml0aWFsaXplIGNsYXNzZXMgdmlhIFtkYXRhLW5hbWVzcGFjZV0gb3IgLmpzLW5hbWVzcGFjZSBjbGFzc1xuICogaHRtbEluaXQoIFdpZGdldCwgJ3dpZGdldE5hbWUnIClcbiAqIG9wdGlvbnMgYXJlIHBhcnNlZCBmcm9tIGRhdGEtbmFtZXNwYWNlLW9wdGlvbnNcbiAqL1xudXRpbHMuaHRtbEluaXQgPSBmdW5jdGlvbiggV2lkZ2V0Q2xhc3MsIG5hbWVzcGFjZSApIHtcbiAgdXRpbHMuZG9jUmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXNoZWROYW1lc3BhY2UgPSB1dGlscy50b0Rhc2hlZCggbmFtZXNwYWNlICk7XG4gICAgdmFyIGRhdGFBdHRyID0gJ2RhdGEtJyArIGRhc2hlZE5hbWVzcGFjZTtcbiAgICB2YXIgZGF0YUF0dHJFbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICdbJyArIGRhdGFBdHRyICsgJ10nICk7XG4gICAgdmFyIGpzRGFzaEVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggJy5qcy0nICsgZGFzaGVkTmFtZXNwYWNlICk7XG4gICAgdmFyIGVsZW1zID0gdXRpbHMubWFrZUFycmF5KCBkYXRhQXR0ckVsZW1zIClcbiAgICAgIC5jb25jYXQoIHV0aWxzLm1ha2VBcnJheSgganNEYXNoRWxlbXMgKSApO1xuICAgIHZhciBkYXRhT3B0aW9uc0F0dHIgPSBkYXRhQXR0ciArICctb3B0aW9ucyc7XG4gICAgdmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XG5cbiAgICBlbGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgIHZhciBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoIGRhdGFBdHRyICkgfHxcbiAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUoIGRhdGFPcHRpb25zQXR0ciApO1xuICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICB0cnkge1xuICAgICAgICBvcHRpb25zID0gYXR0ciAmJiBKU09OLnBhcnNlKCBhdHRyICk7XG4gICAgICB9IGNhdGNoICggZXJyb3IgKSB7XG4gICAgICAgIC8vIGxvZyBlcnJvciwgZG8gbm90IGluaXRpYWxpemVcbiAgICAgICAgaWYgKCBjb25zb2xlICkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdFcnJvciBwYXJzaW5nICcgKyBkYXRhQXR0ciArICcgb24gJyArIGVsZW0uY2xhc3NOYW1lICtcbiAgICAgICAgICAnOiAnICsgZXJyb3IgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBpbml0aWFsaXplXG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgV2lkZ2V0Q2xhc3MoIGVsZW0sIG9wdGlvbnMgKTtcbiAgICAgIC8vIG1ha2UgYXZhaWxhYmxlIHZpYSAkKCkuZGF0YSgnbGF5b3V0bmFtZScpXG4gICAgICBpZiAoIGpRdWVyeSApIHtcbiAgICAgICAgalF1ZXJ5LmRhdGEoIGVsZW0sIG5hbWVzcGFjZSwgaW5zdGFuY2UgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9KTtcbn07XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG5yZXR1cm4gdXRpbHM7XG5cbn0pKTtcblxuLyoqXG4gKiBPdXRsYXllciBJdGVtXG4gKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRCAtIFJlcXVpcmVKU1xuICAgIGRlZmluZSggJ291dGxheWVyL2l0ZW0nLFtcbiAgICAgICAgJ2V2LWVtaXR0ZXIvZXYtZW1pdHRlcicsXG4gICAgICAgICdnZXQtc2l6ZS9nZXQtc2l6ZSdcbiAgICAgIF0sXG4gICAgICBmYWN0b3J5XG4gICAgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KUyAtIEJyb3dzZXJpZnksIFdlYnBhY2tcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICByZXF1aXJlKCdldi1lbWl0dGVyJyksXG4gICAgICByZXF1aXJlKCdnZXQtc2l6ZScpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5PdXRsYXllciA9IHt9O1xuICAgIHdpbmRvdy5PdXRsYXllci5JdGVtID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdy5FdkVtaXR0ZXIsXG4gICAgICB3aW5kb3cuZ2V0U2l6ZVxuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCBFdkVtaXR0ZXIsIGdldFNpemUgKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tIGhlbHBlcnMgLS0tLS0gLy9cblxuZnVuY3Rpb24gaXNFbXB0eU9iaiggb2JqICkge1xuICBmb3IgKCB2YXIgcHJvcCBpbiBvYmogKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByb3AgPSBudWxsO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ1NTMyBzdXBwb3J0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cblxudmFyIGRvY0VsZW1TdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcblxudmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IHR5cGVvZiBkb2NFbGVtU3R5bGUudHJhbnNpdGlvbiA9PSAnc3RyaW5nJyA/XG4gICd0cmFuc2l0aW9uJyA6ICdXZWJraXRUcmFuc2l0aW9uJztcbnZhciB0cmFuc2Zvcm1Qcm9wZXJ0eSA9IHR5cGVvZiBkb2NFbGVtU3R5bGUudHJhbnNmb3JtID09ICdzdHJpbmcnID9cbiAgJ3RyYW5zZm9ybScgOiAnV2Via2l0VHJhbnNmb3JtJztcblxudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9IHtcbiAgV2Via2l0VHJhbnNpdGlvbjogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICB0cmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCdcbn1bIHRyYW5zaXRpb25Qcm9wZXJ0eSBdO1xuXG4vLyBjYWNoZSBhbGwgdmVuZG9yIHByb3BlcnRpZXMgdGhhdCBjb3VsZCBoYXZlIHZlbmRvciBwcmVmaXhcbnZhciB2ZW5kb3JQcm9wZXJ0aWVzID0ge1xuICB0cmFuc2Zvcm06IHRyYW5zZm9ybVByb3BlcnR5LFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uUHJvcGVydHksXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvblByb3BlcnR5ICsgJ0R1cmF0aW9uJyxcbiAgdHJhbnNpdGlvblByb3BlcnR5OiB0cmFuc2l0aW9uUHJvcGVydHkgKyAnUHJvcGVydHknLFxuICB0cmFuc2l0aW9uRGVsYXk6IHRyYW5zaXRpb25Qcm9wZXJ0eSArICdEZWxheSdcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEl0ZW0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gSXRlbSggZWxlbWVudCwgbGF5b3V0ICkge1xuICBpZiAoICFlbGVtZW50ICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIC8vIHBhcmVudCBsYXlvdXQgY2xhc3MsIGkuZS4gTWFzb25yeSwgSXNvdG9wZSwgb3IgUGFja2VyeVxuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICB0aGlzLl9jcmVhdGUoKTtcbn1cblxuLy8gaW5oZXJpdCBFdkVtaXR0ZXJcbnZhciBwcm90byA9IEl0ZW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZFbWl0dGVyLnByb3RvdHlwZSApO1xucHJvdG8uY29uc3RydWN0b3IgPSBJdGVtO1xuXG5wcm90by5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHRyYW5zaXRpb24gb2JqZWN0c1xuICB0aGlzLl90cmFuc24gPSB7XG4gICAgaW5nUHJvcGVydGllczoge30sXG4gICAgY2xlYW46IHt9LFxuICAgIG9uRW5kOiB7fVxuICB9O1xuXG4gIHRoaXMuY3NzKHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICB9KTtcbn07XG5cbi8vIHRyaWdnZXIgc3BlY2lmaWVkIGhhbmRsZXIgZm9yIGV2ZW50IHR5cGVcbnByb3RvLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB2YXIgbWV0aG9kID0gJ29uJyArIGV2ZW50LnR5cGU7XG4gIGlmICggdGhpc1sgbWV0aG9kIF0gKSB7XG4gICAgdGhpc1sgbWV0aG9kIF0oIGV2ZW50ICk7XG4gIH1cbn07XG5cbnByb3RvLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50ICk7XG59O1xuXG4vKipcbiAqIGFwcGx5IENTUyBzdHlsZXMgdG8gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKi9cbnByb3RvLmNzcyA9IGZ1bmN0aW9uKCBzdHlsZSApIHtcbiAgdmFyIGVsZW1TdHlsZSA9IHRoaXMuZWxlbWVudC5zdHlsZTtcblxuICBmb3IgKCB2YXIgcHJvcCBpbiBzdHlsZSApIHtcbiAgICAvLyB1c2UgdmVuZG9yIHByb3BlcnR5IGlmIGF2YWlsYWJsZVxuICAgIHZhciBzdXBwb3J0ZWRQcm9wID0gdmVuZG9yUHJvcGVydGllc1sgcHJvcCBdIHx8IHByb3A7XG4gICAgZWxlbVN0eWxlWyBzdXBwb3J0ZWRQcm9wIF0gPSBzdHlsZVsgcHJvcCBdO1xuICB9XG59O1xuXG4gLy8gbWVhc3VyZSBwb3NpdGlvbiwgYW5kIHNldHMgaXRcbnByb3RvLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoIHRoaXMuZWxlbWVudCApO1xuICB2YXIgaXNPcmlnaW5MZWZ0ID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luTGVmdCcpO1xuICB2YXIgaXNPcmlnaW5Ub3AgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5Ub3AnKTtcbiAgdmFyIHhWYWx1ZSA9IHN0eWxlWyBpc09yaWdpbkxlZnQgPyAnbGVmdCcgOiAncmlnaHQnIF07XG4gIHZhciB5VmFsdWUgPSBzdHlsZVsgaXNPcmlnaW5Ub3AgPyAndG9wJyA6ICdib3R0b20nIF07XG4gIC8vIGNvbnZlcnQgcGVyY2VudCB0byBwaXhlbHNcbiAgdmFyIGxheW91dFNpemUgPSB0aGlzLmxheW91dC5zaXplO1xuICB2YXIgeCA9IHhWYWx1ZS5pbmRleE9mKCclJykgIT0gLTEgP1xuICAgICggcGFyc2VGbG9hdCggeFZhbHVlICkgLyAxMDAgKSAqIGxheW91dFNpemUud2lkdGggOiBwYXJzZUludCggeFZhbHVlLCAxMCApO1xuICB2YXIgeSA9IHlWYWx1ZS5pbmRleE9mKCclJykgIT0gLTEgP1xuICAgICggcGFyc2VGbG9hdCggeVZhbHVlICkgLyAxMDAgKSAqIGxheW91dFNpemUuaGVpZ2h0IDogcGFyc2VJbnQoIHlWYWx1ZSwgMTAgKTtcblxuICAvLyBjbGVhbiB1cCAnYXV0bycgb3Igb3RoZXIgbm9uLWludGVnZXIgdmFsdWVzXG4gIHggPSBpc05hTiggeCApID8gMCA6IHg7XG4gIHkgPSBpc05hTiggeSApID8gMCA6IHk7XG4gIC8vIHJlbW92ZSBwYWRkaW5nIGZyb20gbWVhc3VyZW1lbnRcbiAgeCAtPSBpc09yaWdpbkxlZnQgPyBsYXlvdXRTaXplLnBhZGRpbmdMZWZ0IDogbGF5b3V0U2l6ZS5wYWRkaW5nUmlnaHQ7XG4gIHkgLT0gaXNPcmlnaW5Ub3AgPyBsYXlvdXRTaXplLnBhZGRpbmdUb3AgOiBsYXlvdXRTaXplLnBhZGRpbmdCb3R0b207XG5cbiAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgdGhpcy5wb3NpdGlvbi55ID0geTtcbn07XG5cbi8vIHNldCBzZXR0bGVkIHBvc2l0aW9uLCBhcHBseSBwYWRkaW5nXG5wcm90by5sYXlvdXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGF5b3V0U2l6ZSA9IHRoaXMubGF5b3V0LnNpemU7XG4gIHZhciBzdHlsZSA9IHt9O1xuICB2YXIgaXNPcmlnaW5MZWZ0ID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luTGVmdCcpO1xuICB2YXIgaXNPcmlnaW5Ub3AgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5Ub3AnKTtcblxuICAvLyB4XG4gIHZhciB4UGFkZGluZyA9IGlzT3JpZ2luTGVmdCA/ICdwYWRkaW5nTGVmdCcgOiAncGFkZGluZ1JpZ2h0JztcbiAgdmFyIHhQcm9wZXJ0eSA9IGlzT3JpZ2luTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHZhciB4UmVzZXRQcm9wZXJ0eSA9IGlzT3JpZ2luTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG5cbiAgdmFyIHggPSB0aGlzLnBvc2l0aW9uLnggKyBsYXlvdXRTaXplWyB4UGFkZGluZyBdO1xuICAvLyBzZXQgaW4gcGVyY2VudGFnZSBvciBwaXhlbHNcbiAgc3R5bGVbIHhQcm9wZXJ0eSBdID0gdGhpcy5nZXRYVmFsdWUoIHggKTtcbiAgLy8gcmVzZXQgb3RoZXIgcHJvcGVydHlcbiAgc3R5bGVbIHhSZXNldFByb3BlcnR5IF0gPSAnJztcblxuICAvLyB5XG4gIHZhciB5UGFkZGluZyA9IGlzT3JpZ2luVG9wID8gJ3BhZGRpbmdUb3AnIDogJ3BhZGRpbmdCb3R0b20nO1xuICB2YXIgeVByb3BlcnR5ID0gaXNPcmlnaW5Ub3AgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgeVJlc2V0UHJvcGVydHkgPSBpc09yaWdpblRvcCA/ICdib3R0b20nIDogJ3RvcCc7XG5cbiAgdmFyIHkgPSB0aGlzLnBvc2l0aW9uLnkgKyBsYXlvdXRTaXplWyB5UGFkZGluZyBdO1xuICAvLyBzZXQgaW4gcGVyY2VudGFnZSBvciBwaXhlbHNcbiAgc3R5bGVbIHlQcm9wZXJ0eSBdID0gdGhpcy5nZXRZVmFsdWUoIHkgKTtcbiAgLy8gcmVzZXQgb3RoZXIgcHJvcGVydHlcbiAgc3R5bGVbIHlSZXNldFByb3BlcnR5IF0gPSAnJztcblxuICB0aGlzLmNzcyggc3R5bGUgKTtcbiAgdGhpcy5lbWl0RXZlbnQoICdsYXlvdXQnLCBbIHRoaXMgXSApO1xufTtcblxucHJvdG8uZ2V0WFZhbHVlID0gZnVuY3Rpb24oIHggKSB7XG4gIHZhciBpc0hvcml6b250YWwgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdob3Jpem9udGFsJyk7XG4gIHJldHVybiB0aGlzLmxheW91dC5vcHRpb25zLnBlcmNlbnRQb3NpdGlvbiAmJiAhaXNIb3Jpem9udGFsID9cbiAgICAoICggeCAvIHRoaXMubGF5b3V0LnNpemUud2lkdGggKSAqIDEwMCApICsgJyUnIDogeCArICdweCc7XG59O1xuXG5wcm90by5nZXRZVmFsdWUgPSBmdW5jdGlvbiggeSApIHtcbiAgdmFyIGlzSG9yaXpvbnRhbCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ2hvcml6b250YWwnKTtcbiAgcmV0dXJuIHRoaXMubGF5b3V0Lm9wdGlvbnMucGVyY2VudFBvc2l0aW9uICYmIGlzSG9yaXpvbnRhbCA/XG4gICAgKCAoIHkgLyB0aGlzLmxheW91dC5zaXplLmhlaWdodCApICogMTAwICkgKyAnJScgOiB5ICsgJ3B4Jztcbn07XG5cbnByb3RvLl90cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgdGhpcy5nZXRQb3NpdGlvbigpO1xuICAvLyBnZXQgY3VycmVudCB4ICYgeSBmcm9tIHRvcC9sZWZ0XG4gIHZhciBjdXJYID0gdGhpcy5wb3NpdGlvbi54O1xuICB2YXIgY3VyWSA9IHRoaXMucG9zaXRpb24ueTtcblxuICB2YXIgY29tcGFyZVggPSBwYXJzZUludCggeCwgMTAgKTtcbiAgdmFyIGNvbXBhcmVZID0gcGFyc2VJbnQoIHksIDEwICk7XG4gIHZhciBkaWROb3RNb3ZlID0gY29tcGFyZVggPT09IHRoaXMucG9zaXRpb24ueCAmJiBjb21wYXJlWSA9PT0gdGhpcy5wb3NpdGlvbi55O1xuXG4gIC8vIHNhdmUgZW5kIHBvc2l0aW9uXG4gIHRoaXMuc2V0UG9zaXRpb24oIHgsIHkgKTtcblxuICAvLyBpZiBkaWQgbm90IG1vdmUgYW5kIG5vdCB0cmFuc2l0aW9uaW5nLCBqdXN0IGdvIHRvIGxheW91dFxuICBpZiAoIGRpZE5vdE1vdmUgJiYgIXRoaXMuaXNUcmFuc2l0aW9uaW5nICkge1xuICAgIHRoaXMubGF5b3V0UG9zaXRpb24oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHJhbnNYID0geCAtIGN1clg7XG4gIHZhciB0cmFuc1kgPSB5IC0gY3VyWTtcbiAgdmFyIHRyYW5zaXRpb25TdHlsZSA9IHt9O1xuICB0cmFuc2l0aW9uU3R5bGUudHJhbnNmb3JtID0gdGhpcy5nZXRUcmFuc2xhdGUoIHRyYW5zWCwgdHJhbnNZICk7XG5cbiAgdGhpcy50cmFuc2l0aW9uKHtcbiAgICB0bzogdHJhbnNpdGlvblN0eWxlLFxuICAgIG9uVHJhbnNpdGlvbkVuZDoge1xuICAgICAgdHJhbnNmb3JtOiB0aGlzLmxheW91dFBvc2l0aW9uXG4gICAgfSxcbiAgICBpc0NsZWFuaW5nOiB0cnVlXG4gIH0pO1xufTtcblxucHJvdG8uZ2V0VHJhbnNsYXRlID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gIC8vIGZsaXAgY29vcmlkaW5hdGVzIGlmIG9yaWdpbiBvbiByaWdodCBvciBib3R0b21cbiAgdmFyIGlzT3JpZ2luTGVmdCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpbkxlZnQnKTtcbiAgdmFyIGlzT3JpZ2luVG9wID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luVG9wJyk7XG4gIHggPSBpc09yaWdpbkxlZnQgPyB4IDogLXg7XG4gIHkgPSBpc09yaWdpblRvcCA/IHkgOiAteTtcbiAgcmV0dXJuICd0cmFuc2xhdGUzZCgnICsgeCArICdweCwgJyArIHkgKyAncHgsIDApJztcbn07XG5cbi8vIG5vbiB0cmFuc2l0aW9uICsgdHJhbnNmb3JtIHN1cHBvcnRcbnByb3RvLmdvVG8gPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgdGhpcy5zZXRQb3NpdGlvbiggeCwgeSApO1xuICB0aGlzLmxheW91dFBvc2l0aW9uKCk7XG59O1xuXG5wcm90by5tb3ZlVG8gPSBwcm90by5fdHJhbnNpdGlvblRvO1xuXG5wcm90by5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuICB0aGlzLnBvc2l0aW9uLnggPSBwYXJzZUludCggeCwgMTAgKTtcbiAgdGhpcy5wb3NpdGlvbi55ID0gcGFyc2VJbnQoIHksIDEwICk7XG59O1xuXG4vLyAtLS0tLSB0cmFuc2l0aW9uIC0tLS0tIC8vXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIC0gQ1NTXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblRyYW5zaXRpb25FbmRcbiAqL1xuXG4vLyBub24gdHJhbnNpdGlvbiwganVzdCB0cmlnZ2VyIGNhbGxiYWNrXG5wcm90by5fbm9uVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCBhcmdzICkge1xuICB0aGlzLmNzcyggYXJncy50byApO1xuICBpZiAoIGFyZ3MuaXNDbGVhbmluZyApIHtcbiAgICB0aGlzLl9yZW1vdmVTdHlsZXMoIGFyZ3MudG8gKTtcbiAgfVxuICBmb3IgKCB2YXIgcHJvcCBpbiBhcmdzLm9uVHJhbnNpdGlvbkVuZCApIHtcbiAgICBhcmdzLm9uVHJhbnNpdGlvbkVuZFsgcHJvcCBdLmNhbGwoIHRoaXMgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBwcm9wZXIgdHJhbnNpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBhcmd1bWVudHNcbiAqICAgQHBhcmFtIHtPYmplY3R9IHRvIC0gc3R5bGUgdG8gdHJhbnNpdGlvbiB0b1xuICogICBAcGFyYW0ge09iamVjdH0gZnJvbSAtIHN0eWxlIHRvIHN0YXJ0IHRyYW5zaXRpb24gZnJvbVxuICogICBAcGFyYW0ge0Jvb2xlYW59IGlzQ2xlYW5pbmcgLSByZW1vdmVzIHRyYW5zaXRpb24gc3R5bGVzIGFmdGVyIHRyYW5zaXRpb25cbiAqICAgQHBhcmFtIHtGdW5jdGlvbn0gb25UcmFuc2l0aW9uRW5kIC0gY2FsbGJhY2tcbiAqL1xucHJvdG8udHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCBhcmdzICkge1xuICAvLyByZWRpcmVjdCB0byBub25UcmFuc2l0aW9uIGlmIG5vIHRyYW5zaXRpb24gZHVyYXRpb25cbiAgaWYgKCAhcGFyc2VGbG9hdCggdGhpcy5sYXlvdXQub3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24gKSApIHtcbiAgICB0aGlzLl9ub25UcmFuc2l0aW9uKCBhcmdzICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF90cmFuc2l0aW9uID0gdGhpcy5fdHJhbnNuO1xuICAvLyBrZWVwIHRyYWNrIG9mIG9uVHJhbnNpdGlvbkVuZCBjYWxsYmFjayBieSBjc3MgcHJvcGVydHlcbiAgZm9yICggdmFyIHByb3AgaW4gYXJncy5vblRyYW5zaXRpb25FbmQgKSB7XG4gICAgX3RyYW5zaXRpb24ub25FbmRbIHByb3AgXSA9IGFyZ3Mub25UcmFuc2l0aW9uRW5kWyBwcm9wIF07XG4gIH1cbiAgLy8ga2VlcCB0cmFjayBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIHRyYW5zaXRpb25pbmdcbiAgZm9yICggcHJvcCBpbiBhcmdzLnRvICkge1xuICAgIF90cmFuc2l0aW9uLmluZ1Byb3BlcnRpZXNbIHByb3AgXSA9IHRydWU7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBwcm9wZXJ0aWVzIHRvIGNsZWFuIHVwIHdoZW4gdHJhbnNpdGlvbiBpcyBkb25lXG4gICAgaWYgKCBhcmdzLmlzQ2xlYW5pbmcgKSB7XG4gICAgICBfdHJhbnNpdGlvbi5jbGVhblsgcHJvcCBdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgZnJvbSBzdHlsZXNcbiAgaWYgKCBhcmdzLmZyb20gKSB7XG4gICAgdGhpcy5jc3MoIGFyZ3MuZnJvbSApO1xuICAgIC8vIGZvcmNlIHJlZHJhdy4gaHR0cDovL2Jsb2cuYWxleG1hY2Nhdy5jb20vY3NzLXRyYW5zaXRpb25zXG4gICAgdmFyIGggPSB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIC8vIGhhY2sgZm9yIEpTSGludCB0byBodXNoIGFib3V0IHVudXNlZCB2YXJcbiAgICBoID0gbnVsbDtcbiAgfVxuICAvLyBlbmFibGUgdHJhbnNpdGlvblxuICB0aGlzLmVuYWJsZVRyYW5zaXRpb24oIGFyZ3MudG8gKTtcbiAgLy8gc2V0IHN0eWxlcyB0aGF0IGFyZSB0cmFuc2l0aW9uaW5nXG4gIHRoaXMuY3NzKCBhcmdzLnRvICk7XG5cbiAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuXG59O1xuXG4vLyBkYXNoIGJlZm9yZSBhbGwgY2FwIGxldHRlcnMsIGluY2x1ZGluZyBmaXJzdCBmb3Jcbi8vIFdlYmtpdFRyYW5zZm9ybSA9PiAtd2Via2l0LXRyYW5zZm9ybVxuZnVuY3Rpb24gdG9EYXNoZWRBbGwoIHN0ciApIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKCAvKFtBLVpdKS9nLCBmdW5jdGlvbiggJDEgKSB7XG4gICAgcmV0dXJuICctJyArICQxLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0gJ29wYWNpdHksJyArIHRvRGFzaGVkQWxsKCB0cmFuc2Zvcm1Qcm9wZXJ0eSApO1xuXG5wcm90by5lbmFibGVUcmFuc2l0aW9uID0gZnVuY3Rpb24oLyogc3R5bGUgKi8pIHtcbiAgLy8gSEFDSyBjaGFuZ2luZyB0cmFuc2l0aW9uUHJvcGVydHkgZHVyaW5nIGEgdHJhbnNpdGlvblxuICAvLyB3aWxsIGNhdXNlIHRyYW5zaXRpb24gdG8ganVtcFxuICBpZiAoIHRoaXMuaXNUcmFuc2l0aW9uaW5nICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIG1ha2UgYHRyYW5zaXRpb246IGZvbywgYmFyLCBiYXpgIGZyb20gc3R5bGUgb2JqZWN0XG4gIC8vIEhBQ0sgdW4tY29tbWVudCB0aGlzIHdoZW4gZW5hYmxlVHJhbnNpdGlvbiBjYW4gd29ya1xuICAvLyB3aGlsZSBhIHRyYW5zaXRpb24gaXMgaGFwcGVuaW5nXG4gIC8vIHZhciB0cmFuc2l0aW9uVmFsdWVzID0gW107XG4gIC8vIGZvciAoIHZhciBwcm9wIGluIHN0eWxlICkge1xuICAvLyAgIC8vIGRhc2gtaWZ5IGNhbWVsQ2FzZWQgcHJvcGVydGllcyBsaWtlIFdlYmtpdFRyYW5zaXRpb25cbiAgLy8gICBwcm9wID0gdmVuZG9yUHJvcGVydGllc1sgcHJvcCBdIHx8IHByb3A7XG4gIC8vICAgdHJhbnNpdGlvblZhbHVlcy5wdXNoKCB0b0Rhc2hlZEFsbCggcHJvcCApICk7XG4gIC8vIH1cbiAgLy8gbXVuZ2UgbnVtYmVyIHRvIG1pbGxpc2Vjb25kLCB0byBtYXRjaCBzdGFnZ2VyXG4gIHZhciBkdXJhdGlvbiA9IHRoaXMubGF5b3V0Lm9wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uO1xuICBkdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PSAnbnVtYmVyJyA/IGR1cmF0aW9uICsgJ21zJyA6IGR1cmF0aW9uO1xuICAvLyBlbmFibGUgdHJhbnNpdGlvbiBzdHlsZXNcbiAgdGhpcy5jc3Moe1xuICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogdHJhbnNpdGlvblByb3BzLFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogZHVyYXRpb24sXG4gICAgdHJhbnNpdGlvbkRlbGF5OiB0aGlzLnN0YWdnZXJEZWxheSB8fCAwXG4gIH0pO1xuICAvLyBsaXN0ZW4gZm9yIHRyYW5zaXRpb24gZW5kIGV2ZW50XG4gIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0cmFuc2l0aW9uRW5kRXZlbnQsIHRoaXMsIGZhbHNlICk7XG59O1xuXG4vLyAtLS0tLSBldmVudHMgLS0tLS0gLy9cblxucHJvdG8ub253ZWJraXRUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLm9udHJhbnNpdGlvbmVuZCggZXZlbnQgKTtcbn07XG5cbnByb3RvLm9ub3RyYW5zaXRpb25lbmQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHRoaXMub250cmFuc2l0aW9uZW5kKCBldmVudCApO1xufTtcblxuLy8gcHJvcGVydGllcyB0aGF0IEkgbXVuZ2UgdG8gbWFrZSBteSBsaWZlIGVhc2llclxudmFyIGRhc2hlZFZlbmRvclByb3BlcnRpZXMgPSB7XG4gICctd2Via2l0LXRyYW5zZm9ybSc6ICd0cmFuc2Zvcm0nXG59O1xuXG5wcm90by5vbnRyYW5zaXRpb25lbmQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIC8vIGRpc3JlZ2FyZCBidWJibGVkIGV2ZW50cyBmcm9tIGNoaWxkcmVuXG4gIGlmICggZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBfdHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zbjtcbiAgLy8gZ2V0IHByb3BlcnR5IG5hbWUgb2YgdHJhbnNpdGlvbmVkIHByb3BlcnR5LCBjb252ZXJ0IHRvIHByZWZpeC1mcmVlXG4gIHZhciBwcm9wZXJ0eU5hbWUgPSBkYXNoZWRWZW5kb3JQcm9wZXJ0aWVzWyBldmVudC5wcm9wZXJ0eU5hbWUgXSB8fCBldmVudC5wcm9wZXJ0eU5hbWU7XG5cbiAgLy8gcmVtb3ZlIHByb3BlcnR5IHRoYXQgaGFzIGNvbXBsZXRlZCB0cmFuc2l0aW9uaW5nXG4gIGRlbGV0ZSBfdHJhbnNpdGlvbi5pbmdQcm9wZXJ0aWVzWyBwcm9wZXJ0eU5hbWUgXTtcbiAgLy8gY2hlY2sgaWYgYW55IHByb3BlcnRpZXMgYXJlIHN0aWxsIHRyYW5zaXRpb25pbmdcbiAgaWYgKCBpc0VtcHR5T2JqKCBfdHJhbnNpdGlvbi5pbmdQcm9wZXJ0aWVzICkgKSB7XG4gICAgLy8gYWxsIHByb3BlcnRpZXMgaGF2ZSBjb21wbGV0ZWQgdHJhbnNpdGlvbmluZ1xuICAgIHRoaXMuZGlzYWJsZVRyYW5zaXRpb24oKTtcbiAgfVxuICAvLyBjbGVhbiBzdHlsZVxuICBpZiAoIHByb3BlcnR5TmFtZSBpbiBfdHJhbnNpdGlvbi5jbGVhbiApIHtcbiAgICAvLyBjbGVhbiB1cCBzdHlsZVxuICAgIHRoaXMuZWxlbWVudC5zdHlsZVsgZXZlbnQucHJvcGVydHlOYW1lIF0gPSAnJztcbiAgICBkZWxldGUgX3RyYW5zaXRpb24uY2xlYW5bIHByb3BlcnR5TmFtZSBdO1xuICB9XG4gIC8vIHRyaWdnZXIgb25UcmFuc2l0aW9uRW5kIGNhbGxiYWNrXG4gIGlmICggcHJvcGVydHlOYW1lIGluIF90cmFuc2l0aW9uLm9uRW5kICkge1xuICAgIHZhciBvblRyYW5zaXRpb25FbmQgPSBfdHJhbnNpdGlvbi5vbkVuZFsgcHJvcGVydHlOYW1lIF07XG4gICAgb25UcmFuc2l0aW9uRW5kLmNhbGwoIHRoaXMgKTtcbiAgICBkZWxldGUgX3RyYW5zaXRpb24ub25FbmRbIHByb3BlcnR5TmFtZSBdO1xuICB9XG5cbiAgdGhpcy5lbWl0RXZlbnQoICd0cmFuc2l0aW9uRW5kJywgWyB0aGlzIF0gKTtcbn07XG5cbnByb3RvLmRpc2FibGVUcmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVtb3ZlVHJhbnNpdGlvblN0eWxlcygpO1xuICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHJhbnNpdGlvbkVuZEV2ZW50LCB0aGlzLCBmYWxzZSApO1xuICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiByZW1vdmVzIHN0eWxlIHByb3BlcnR5IGZyb20gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4qKi9cbnByb3RvLl9yZW1vdmVTdHlsZXMgPSBmdW5jdGlvbiggc3R5bGUgKSB7XG4gIC8vIGNsZWFuIHVwIHRyYW5zaXRpb24gc3R5bGVzXG4gIHZhciBjbGVhblN0eWxlID0ge307XG4gIGZvciAoIHZhciBwcm9wIGluIHN0eWxlICkge1xuICAgIGNsZWFuU3R5bGVbIHByb3AgXSA9ICcnO1xuICB9XG4gIHRoaXMuY3NzKCBjbGVhblN0eWxlICk7XG59O1xuXG52YXIgY2xlYW5UcmFuc2l0aW9uU3R5bGUgPSB7XG4gIHRyYW5zaXRpb25Qcm9wZXJ0eTogJycsXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogJycsXG4gIHRyYW5zaXRpb25EZWxheTogJydcbn07XG5cbnByb3RvLnJlbW92ZVRyYW5zaXRpb25TdHlsZXMgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmVtb3ZlIHRyYW5zaXRpb25cbiAgdGhpcy5jc3MoIGNsZWFuVHJhbnNpdGlvblN0eWxlICk7XG59O1xuXG4vLyAtLS0tLSBzdGFnZ2VyIC0tLS0tIC8vXG5cbnByb3RvLnN0YWdnZXIgPSBmdW5jdGlvbiggZGVsYXkgKSB7XG4gIGRlbGF5ID0gaXNOYU4oIGRlbGF5ICkgPyAwIDogZGVsYXk7XG4gIHRoaXMuc3RhZ2dlckRlbGF5ID0gZGVsYXkgKyAnbXMnO1xufTtcblxuLy8gLS0tLS0gc2hvdy9oaWRlL3JlbW92ZSAtLS0tLSAvL1xuXG4vLyByZW1vdmUgZWxlbWVudCBmcm9tIERPTVxucHJvdG8ucmVtb3ZlRWxlbSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGhpcy5lbGVtZW50ICk7XG4gIC8vIHJlbW92ZSBkaXNwbGF5OiBub25lXG4gIHRoaXMuY3NzKHsgZGlzcGxheTogJycgfSk7XG4gIHRoaXMuZW1pdEV2ZW50KCAncmVtb3ZlJywgWyB0aGlzIF0gKTtcbn07XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBqdXN0IHJlbW92ZSBlbGVtZW50IGlmIG5vIHRyYW5zaXRpb24gc3VwcG9ydCBvciBubyB0cmFuc2l0aW9uXG4gIGlmICggIXRyYW5zaXRpb25Qcm9wZXJ0eSB8fCAhcGFyc2VGbG9hdCggdGhpcy5sYXlvdXQub3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24gKSApIHtcbiAgICB0aGlzLnJlbW92ZUVsZW0oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzdGFydCB0cmFuc2l0aW9uXG4gIHRoaXMub25jZSggJ3RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUVsZW0oKTtcbiAgfSk7XG4gIHRoaXMuaGlkZSgpO1xufTtcblxucHJvdG8ucmV2ZWFsID0gZnVuY3Rpb24oKSB7XG4gIGRlbGV0ZSB0aGlzLmlzSGlkZGVuO1xuICAvLyByZW1vdmUgZGlzcGxheTogbm9uZVxuICB0aGlzLmNzcyh7IGRpc3BsYXk6ICcnIH0pO1xuXG4gIHZhciBvcHRpb25zID0gdGhpcy5sYXlvdXQub3B0aW9ucztcblxuICB2YXIgb25UcmFuc2l0aW9uRW5kID0ge307XG4gIHZhciB0cmFuc2l0aW9uRW5kUHJvcGVydHkgPSB0aGlzLmdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkoJ3Zpc2libGVTdHlsZScpO1xuICBvblRyYW5zaXRpb25FbmRbIHRyYW5zaXRpb25FbmRQcm9wZXJ0eSBdID0gdGhpcy5vblJldmVhbFRyYW5zaXRpb25FbmQ7XG5cbiAgdGhpcy50cmFuc2l0aW9uKHtcbiAgICBmcm9tOiBvcHRpb25zLmhpZGRlblN0eWxlLFxuICAgIHRvOiBvcHRpb25zLnZpc2libGVTdHlsZSxcbiAgICBpc0NsZWFuaW5nOiB0cnVlLFxuICAgIG9uVHJhbnNpdGlvbkVuZDogb25UcmFuc2l0aW9uRW5kXG4gIH0pO1xufTtcblxucHJvdG8ub25SZXZlYWxUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNoZWNrIGlmIHN0aWxsIHZpc2libGVcbiAgLy8gZHVyaW5nIHRyYW5zaXRpb24sIGl0ZW0gbWF5IGhhdmUgYmVlbiBoaWRkZW5cbiAgaWYgKCAhdGhpcy5pc0hpZGRlbiApIHtcbiAgICB0aGlzLmVtaXRFdmVudCgncmV2ZWFsJyk7XG4gIH1cbn07XG5cbi8qKlxuICogZ2V0IHN0eWxlIHByb3BlcnR5IHVzZSBmb3IgaGlkZS9yZXZlYWwgdHJhbnNpdGlvbiBlbmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZVByb3BlcnR5IC0gaGlkZGVuU3R5bGUvdmlzaWJsZVN0eWxlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5wcm90by5nZXRIaWRlUmV2ZWFsVHJhbnNpdGlvbkVuZFByb3BlcnR5ID0gZnVuY3Rpb24oIHN0eWxlUHJvcGVydHkgKSB7XG4gIHZhciBvcHRpb25TdHlsZSA9IHRoaXMubGF5b3V0Lm9wdGlvbnNbIHN0eWxlUHJvcGVydHkgXTtcbiAgLy8gdXNlIG9wYWNpdHlcbiAgaWYgKCBvcHRpb25TdHlsZS5vcGFjaXR5ICkge1xuICAgIHJldHVybiAnb3BhY2l0eSc7XG4gIH1cbiAgLy8gZ2V0IGZpcnN0IHByb3BlcnR5XG4gIGZvciAoIHZhciBwcm9wIGluIG9wdGlvblN0eWxlICkge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG5wcm90by5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNldCBmbGFnXG4gIHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xuICAvLyByZW1vdmUgZGlzcGxheTogbm9uZVxuICB0aGlzLmNzcyh7IGRpc3BsYXk6ICcnIH0pO1xuXG4gIHZhciBvcHRpb25zID0gdGhpcy5sYXlvdXQub3B0aW9ucztcblxuICB2YXIgb25UcmFuc2l0aW9uRW5kID0ge307XG4gIHZhciB0cmFuc2l0aW9uRW5kUHJvcGVydHkgPSB0aGlzLmdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkoJ2hpZGRlblN0eWxlJyk7XG4gIG9uVHJhbnNpdGlvbkVuZFsgdHJhbnNpdGlvbkVuZFByb3BlcnR5IF0gPSB0aGlzLm9uSGlkZVRyYW5zaXRpb25FbmQ7XG5cbiAgdGhpcy50cmFuc2l0aW9uKHtcbiAgICBmcm9tOiBvcHRpb25zLnZpc2libGVTdHlsZSxcbiAgICB0bzogb3B0aW9ucy5oaWRkZW5TdHlsZSxcbiAgICAvLyBrZWVwIGhpZGRlbiBzdHVmZiBoaWRkZW5cbiAgICBpc0NsZWFuaW5nOiB0cnVlLFxuICAgIG9uVHJhbnNpdGlvbkVuZDogb25UcmFuc2l0aW9uRW5kXG4gIH0pO1xufTtcblxucHJvdG8ub25IaWRlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKCkge1xuICAvLyBjaGVjayBpZiBzdGlsbCBoaWRkZW5cbiAgLy8gZHVyaW5nIHRyYW5zaXRpb24sIGl0ZW0gbWF5IGhhdmUgYmVlbiB1bi1oaWRkZW5cbiAgaWYgKCB0aGlzLmlzSGlkZGVuICkge1xuICAgIHRoaXMuY3NzKHsgZGlzcGxheTogJ25vbmUnIH0pO1xuICAgIHRoaXMuZW1pdEV2ZW50KCdoaWRlJyk7XG4gIH1cbn07XG5cbnByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jc3Moe1xuICAgIHBvc2l0aW9uOiAnJyxcbiAgICBsZWZ0OiAnJyxcbiAgICByaWdodDogJycsXG4gICAgdG9wOiAnJyxcbiAgICBib3R0b206ICcnLFxuICAgIHRyYW5zaXRpb246ICcnLFxuICAgIHRyYW5zZm9ybTogJydcbiAgfSk7XG59O1xuXG5yZXR1cm4gSXRlbTtcblxufSkpO1xuXG4vKiFcbiAqIE91dGxheWVyIHYyLjEuMFxuICogdGhlIGJyYWlucyBhbmQgZ3V0cyBvZiBhIGxheW91dCBsaWJyYXJ5XG4gKiBNSVQgbGljZW5zZVxuICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRCAtIFJlcXVpcmVKU1xuICAgIGRlZmluZSggJ291dGxheWVyL291dGxheWVyJyxbXG4gICAgICAgICdldi1lbWl0dGVyL2V2LWVtaXR0ZXInLFxuICAgICAgICAnZ2V0LXNpemUvZ2V0LXNpemUnLFxuICAgICAgICAnZml6enktdWktdXRpbHMvdXRpbHMnLFxuICAgICAgICAnLi9pdGVtJ1xuICAgICAgXSxcbiAgICAgIGZ1bmN0aW9uKCBFdkVtaXR0ZXIsIGdldFNpemUsIHV0aWxzLCBJdGVtICkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIsIGdldFNpemUsIHV0aWxzLCBJdGVtKTtcbiAgICAgIH1cbiAgICApO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTIC0gQnJvd3NlcmlmeSwgV2VicGFja1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKSxcbiAgICAgIHJlcXVpcmUoJ2dldC1zaXplJyksXG4gICAgICByZXF1aXJlKCdmaXp6eS11aS11dGlscycpLFxuICAgICAgcmVxdWlyZSgnLi9pdGVtJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93Lk91dGxheWVyID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5FdkVtaXR0ZXIsXG4gICAgICB3aW5kb3cuZ2V0U2l6ZSxcbiAgICAgIHdpbmRvdy5maXp6eVVJVXRpbHMsXG4gICAgICB3aW5kb3cuT3V0bGF5ZXIuSXRlbVxuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIEV2RW1pdHRlciwgZ2V0U2l6ZSwgdXRpbHMsIEl0ZW0gKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tIHZhcnMgLS0tLS0gLy9cblxudmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcbnZhciBqUXVlcnkgPSB3aW5kb3cualF1ZXJ5O1xudmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBPdXRsYXllciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBnbG9iYWxseSB1bmlxdWUgaWRlbnRpZmllcnNcbnZhciBHVUlEID0gMDtcbi8vIGludGVybmFsIHN0b3JlIG9mIGFsbCBPdXRsYXllciBpbnRhbmNlc1xudmFyIGluc3RhbmNlcyA9IHt9O1xuXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50LCBTdHJpbmd9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gT3V0bGF5ZXIoIGVsZW1lbnQsIG9wdGlvbnMgKSB7XG4gIHZhciBxdWVyeUVsZW1lbnQgPSB1dGlscy5nZXRRdWVyeUVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgaWYgKCAhcXVlcnlFbGVtZW50ICkge1xuICAgIGlmICggY29uc29sZSApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoICdCYWQgZWxlbWVudCBmb3IgJyArIHRoaXMuY29uc3RydWN0b3IubmFtZXNwYWNlICtcbiAgICAgICAgJzogJyArICggcXVlcnlFbGVtZW50IHx8IGVsZW1lbnQgKSApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5lbGVtZW50ID0gcXVlcnlFbGVtZW50O1xuICAvLyBhZGQgalF1ZXJ5XG4gIGlmICggalF1ZXJ5ICkge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBqUXVlcnkoIHRoaXMuZWxlbWVudCApO1xuICB9XG5cbiAgLy8gb3B0aW9uc1xuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoIHt9LCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzICk7XG4gIHRoaXMub3B0aW9uKCBvcHRpb25zICk7XG5cbiAgLy8gYWRkIGlkIGZvciBPdXRsYXllci5nZXRGcm9tRWxlbWVudFxuICB2YXIgaWQgPSArK0dVSUQ7XG4gIHRoaXMuZWxlbWVudC5vdXRsYXllckdVSUQgPSBpZDsgLy8gZXhwYW5kb1xuICBpbnN0YW5jZXNbIGlkIF0gPSB0aGlzOyAvLyBhc3NvY2lhdGUgdmlhIGlkXG5cbiAgLy8ga2ljayBpdCBvZmZcbiAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgdmFyIGlzSW5pdExheW91dCA9IHRoaXMuX2dldE9wdGlvbignaW5pdExheW91dCcpO1xuICBpZiAoIGlzSW5pdExheW91dCApIHtcbiAgICB0aGlzLmxheW91dCgpO1xuICB9XG59XG5cbi8vIHNldHRpbmdzIGFyZSBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbk91dGxheWVyLm5hbWVzcGFjZSA9ICdvdXRsYXllcic7XG5PdXRsYXllci5JdGVtID0gSXRlbTtcblxuLy8gZGVmYXVsdCBvcHRpb25zXG5PdXRsYXllci5kZWZhdWx0cyA9IHtcbiAgY29udGFpbmVyU3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICB9LFxuICBpbml0TGF5b3V0OiB0cnVlLFxuICBvcmlnaW5MZWZ0OiB0cnVlLFxuICBvcmlnaW5Ub3A6IHRydWUsXG4gIHJlc2l6ZTogdHJ1ZSxcbiAgcmVzaXplQ29udGFpbmVyOiB0cnVlLFxuICAvLyBpdGVtIG9wdGlvbnNcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiAnMC40cycsXG4gIGhpZGRlblN0eWxlOiB7XG4gICAgb3BhY2l0eTogMCxcbiAgICB0cmFuc2Zvcm06ICdzY2FsZSgwLjAwMSknXG4gIH0sXG4gIHZpc2libGVTdHlsZToge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknXG4gIH1cbn07XG5cbnZhciBwcm90byA9IE91dGxheWVyLnByb3RvdHlwZTtcbi8vIGluaGVyaXQgRXZFbWl0dGVyXG51dGlscy5leHRlbmQoIHByb3RvLCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG5cbi8qKlxuICogc2V0IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnByb3RvLm9wdGlvbiA9IGZ1bmN0aW9uKCBvcHRzICkge1xuICB1dGlscy5leHRlbmQoIHRoaXMub3B0aW9ucywgb3B0cyApO1xufTtcblxuLyoqXG4gKiBnZXQgYmFja3dhcmRzIGNvbXBhdGlibGUgb3B0aW9uIHZhbHVlLCBjaGVjayBvbGQgbmFtZVxuICovXG5wcm90by5fZ2V0T3B0aW9uID0gZnVuY3Rpb24oIG9wdGlvbiApIHtcbiAgdmFyIG9sZE9wdGlvbiA9IHRoaXMuY29uc3RydWN0b3IuY29tcGF0T3B0aW9uc1sgb3B0aW9uIF07XG4gIHJldHVybiBvbGRPcHRpb24gJiYgdGhpcy5vcHRpb25zWyBvbGRPcHRpb24gXSAhPT0gdW5kZWZpbmVkID9cbiAgICB0aGlzLm9wdGlvbnNbIG9sZE9wdGlvbiBdIDogdGhpcy5vcHRpb25zWyBvcHRpb24gXTtcbn07XG5cbk91dGxheWVyLmNvbXBhdE9wdGlvbnMgPSB7XG4gIC8vIGN1cnJlbnROYW1lOiBvbGROYW1lXG4gIGluaXRMYXlvdXQ6ICdpc0luaXRMYXlvdXQnLFxuICBob3Jpem9udGFsOiAnaXNIb3Jpem9udGFsJyxcbiAgbGF5b3V0SW5zdGFudDogJ2lzTGF5b3V0SW5zdGFudCcsXG4gIG9yaWdpbkxlZnQ6ICdpc09yaWdpbkxlZnQnLFxuICBvcmlnaW5Ub3A6ICdpc09yaWdpblRvcCcsXG4gIHJlc2l6ZTogJ2lzUmVzaXplQm91bmQnLFxuICByZXNpemVDb250YWluZXI6ICdpc1Jlc2l6aW5nQ29udGFpbmVyJ1xufTtcblxucHJvdG8uX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBnZXQgaXRlbXMgZnJvbSBjaGlsZHJlblxuICB0aGlzLnJlbG9hZEl0ZW1zKCk7XG4gIC8vIGVsZW1lbnRzIHRoYXQgYWZmZWN0IGxheW91dCwgYnV0IGFyZSBub3QgbGFpZCBvdXRcbiAgdGhpcy5zdGFtcHMgPSBbXTtcbiAgdGhpcy5zdGFtcCggdGhpcy5vcHRpb25zLnN0YW1wICk7XG4gIC8vIHNldCBjb250YWluZXIgc3R5bGVcbiAgdXRpbHMuZXh0ZW5kKCB0aGlzLmVsZW1lbnQuc3R5bGUsIHRoaXMub3B0aW9ucy5jb250YWluZXJTdHlsZSApO1xuXG4gIC8vIGJpbmQgcmVzaXplIG1ldGhvZFxuICB2YXIgY2FuQmluZFJlc2l6ZSA9IHRoaXMuX2dldE9wdGlvbigncmVzaXplJyk7XG4gIGlmICggY2FuQmluZFJlc2l6ZSApIHtcbiAgICB0aGlzLmJpbmRSZXNpemUoKTtcbiAgfVxufTtcblxuLy8gZ29lcyB0aHJvdWdoIGFsbCBjaGlsZHJlbiBhZ2FpbiBhbmQgZ2V0cyBicmlja3MgaW4gcHJvcGVyIG9yZGVyXG5wcm90by5yZWxvYWRJdGVtcyA9IGZ1bmN0aW9uKCkge1xuICAvLyBjb2xsZWN0aW9uIG9mIGl0ZW0gZWxlbWVudHNcbiAgdGhpcy5pdGVtcyA9IHRoaXMuX2l0ZW1pemUoIHRoaXMuZWxlbWVudC5jaGlsZHJlbiApO1xufTtcblxuXG4vKipcbiAqIHR1cm4gZWxlbWVudHMgaW50byBPdXRsYXllci5JdGVtcyB0byBiZSB1c2VkIGluIGxheW91dFxuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBIVE1MRWxlbWVudH0gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXMgLSBjb2xsZWN0aW9uIG9mIG5ldyBPdXRsYXllciBJdGVtc1xuICovXG5wcm90by5faXRlbWl6ZSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuICB2YXIgaXRlbUVsZW1zID0gdGhpcy5fZmlsdGVyRmluZEl0ZW1FbGVtZW50cyggZWxlbXMgKTtcbiAgdmFyIEl0ZW0gPSB0aGlzLmNvbnN0cnVjdG9yLkl0ZW07XG5cbiAgLy8gY3JlYXRlIG5ldyBPdXRsYXllciBJdGVtcyBmb3IgY29sbGVjdGlvblxuICB2YXIgaXRlbXMgPSBbXTtcbiAgZm9yICggdmFyIGk9MDsgaSA8IGl0ZW1FbGVtcy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgZWxlbSA9IGl0ZW1FbGVtc1tpXTtcbiAgICB2YXIgaXRlbSA9IG5ldyBJdGVtKCBlbGVtLCB0aGlzICk7XG4gICAgaXRlbXMucHVzaCggaXRlbSApO1xuICB9XG5cbiAgcmV0dXJuIGl0ZW1zO1xufTtcblxuLyoqXG4gKiBnZXQgaXRlbSBlbGVtZW50cyB0byBiZSB1c2VkIGluIGxheW91dFxuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBIVE1MRWxlbWVudH0gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXMgLSBpdGVtIGVsZW1lbnRzXG4gKi9cbnByb3RvLl9maWx0ZXJGaW5kSXRlbUVsZW1lbnRzID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICByZXR1cm4gdXRpbHMuZmlsdGVyRmluZEVsZW1lbnRzKCBlbGVtcywgdGhpcy5vcHRpb25zLml0ZW1TZWxlY3RvciApO1xufTtcblxuLyoqXG4gKiBnZXR0ZXIgbWV0aG9kIGZvciBnZXR0aW5nIGl0ZW0gZWxlbWVudHNcbiAqIEByZXR1cm5zIHtBcnJheX0gZWxlbXMgLSBjb2xsZWN0aW9uIG9mIGl0ZW0gZWxlbWVudHNcbiAqL1xucHJvdG8uZ2V0SXRlbUVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLml0ZW1zLm1hcCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgcmV0dXJuIGl0ZW0uZWxlbWVudDtcbiAgfSk7XG59O1xuXG4vLyAtLS0tLSBpbml0ICYgbGF5b3V0IC0tLS0tIC8vXG5cbi8qKlxuICogbGF5cyBvdXQgYWxsIGl0ZW1zXG4gKi9cbnByb3RvLmxheW91dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZXNldExheW91dCgpO1xuICB0aGlzLl9tYW5hZ2VTdGFtcHMoKTtcblxuICAvLyBkb24ndCBhbmltYXRlIGZpcnN0IGxheW91dFxuICB2YXIgbGF5b3V0SW5zdGFudCA9IHRoaXMuX2dldE9wdGlvbignbGF5b3V0SW5zdGFudCcpO1xuICB2YXIgaXNJbnN0YW50ID0gbGF5b3V0SW5zdGFudCAhPT0gdW5kZWZpbmVkID9cbiAgICBsYXlvdXRJbnN0YW50IDogIXRoaXMuX2lzTGF5b3V0SW5pdGVkO1xuICB0aGlzLmxheW91dEl0ZW1zKCB0aGlzLml0ZW1zLCBpc0luc3RhbnQgKTtcblxuICAvLyBmbGFnIGZvciBpbml0YWxpemVkXG4gIHRoaXMuX2lzTGF5b3V0SW5pdGVkID0gdHJ1ZTtcbn07XG5cbi8vIF9pbml0IGlzIGFsaWFzIGZvciBsYXlvdXRcbnByb3RvLl9pbml0ID0gcHJvdG8ubGF5b3V0O1xuXG4vKipcbiAqIGxvZ2ljIGJlZm9yZSBhbnkgbmV3IGxheW91dFxuICovXG5wcm90by5fcmVzZXRMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nZXRTaXplKCk7XG59O1xuXG5cbnByb3RvLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50ICk7XG59O1xuXG4vKipcbiAqIGdldCBtZWFzdXJlbWVudCBmcm9tIG9wdGlvbiwgZm9yIGNvbHVtbldpZHRoLCByb3dIZWlnaHQsIGd1dHRlclxuICogaWYgb3B0aW9uIGlzIFN0cmluZyAtPiBnZXQgZWxlbWVudCBmcm9tIHNlbGVjdG9yIHN0cmluZywgJiBnZXQgc2l6ZSBvZiBlbGVtZW50XG4gKiBpZiBvcHRpb24gaXMgRWxlbWVudCAtPiBnZXQgc2l6ZSBvZiBlbGVtZW50XG4gKiBlbHNlIHVzZSBvcHRpb24gYXMgYSBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVhc3VyZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gd2lkdGggb3IgaGVpZ2h0XG4gKiBAcHJpdmF0ZVxuICovXG5wcm90by5fZ2V0TWVhc3VyZW1lbnQgPSBmdW5jdGlvbiggbWVhc3VyZW1lbnQsIHNpemUgKSB7XG4gIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbnNbIG1lYXN1cmVtZW50IF07XG4gIHZhciBlbGVtO1xuICBpZiAoICFvcHRpb24gKSB7XG4gICAgLy8gZGVmYXVsdCB0byAwXG4gICAgdGhpc1sgbWVhc3VyZW1lbnQgXSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG9wdGlvbiBhcyBhbiBlbGVtZW50XG4gICAgaWYgKCB0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnICkge1xuICAgICAgZWxlbSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCBvcHRpb24gKTtcbiAgICB9IGVsc2UgaWYgKCBvcHRpb24gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCApIHtcbiAgICAgIGVsZW0gPSBvcHRpb247XG4gICAgfVxuICAgIC8vIHVzZSBzaXplIG9mIGVsZW1lbnQsIGlmIGVsZW1lbnRcbiAgICB0aGlzWyBtZWFzdXJlbWVudCBdID0gZWxlbSA/IGdldFNpemUoIGVsZW0gKVsgc2l6ZSBdIDogb3B0aW9uO1xuICB9XG59O1xuXG4vKipcbiAqIGxheW91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbSBlbGVtZW50c1xuICogQGFwaSBwdWJsaWNcbiAqL1xucHJvdG8ubGF5b3V0SXRlbXMgPSBmdW5jdGlvbiggaXRlbXMsIGlzSW5zdGFudCApIHtcbiAgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0ZvckxheW91dCggaXRlbXMgKTtcblxuICB0aGlzLl9sYXlvdXRJdGVtcyggaXRlbXMsIGlzSW5zdGFudCApO1xuXG4gIHRoaXMuX3Bvc3RMYXlvdXQoKTtcbn07XG5cbi8qKlxuICogZ2V0IHRoZSBpdGVtcyB0byBiZSBsYWlkIG91dFxuICogeW91IG1heSB3YW50IHRvIHNraXAgb3ZlciBzb21lIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtc1xuICovXG5wcm90by5fZ2V0SXRlbXNGb3JMYXlvdXQgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG4gIHJldHVybiBpdGVtcy5maWx0ZXIoIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIHJldHVybiAhaXRlbS5pc0lnbm9yZWQ7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBsYXlvdXQgaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW5zdGFudFxuICovXG5wcm90by5fbGF5b3V0SXRlbXMgPSBmdW5jdGlvbiggaXRlbXMsIGlzSW5zdGFudCApIHtcbiAgdGhpcy5fZW1pdENvbXBsZXRlT25JdGVtcyggJ2xheW91dCcsIGl0ZW1zICk7XG5cbiAgaWYgKCAhaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCApIHtcbiAgICAvLyBubyBpdGVtcywgZW1pdCBldmVudCB3aXRoIGVtcHR5IGFycmF5XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHF1ZXVlID0gW107XG5cbiAgaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgLy8gZ2V0IHgveSBvYmplY3QgZnJvbSBtZXRob2RcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9nZXRJdGVtTGF5b3V0UG9zaXRpb24oIGl0ZW0gKTtcbiAgICAvLyBlbnF1ZXVlXG4gICAgcG9zaXRpb24uaXRlbSA9IGl0ZW07XG4gICAgcG9zaXRpb24uaXNJbnN0YW50ID0gaXNJbnN0YW50IHx8IGl0ZW0uaXNMYXlvdXRJbnN0YW50O1xuICAgIHF1ZXVlLnB1c2goIHBvc2l0aW9uICk7XG4gIH0sIHRoaXMgKTtcblxuICB0aGlzLl9wcm9jZXNzTGF5b3V0UXVldWUoIHF1ZXVlICk7XG59O1xuXG4vKipcbiAqIGdldCBpdGVtIGxheW91dCBwb3NpdGlvblxuICogQHBhcmFtIHtPdXRsYXllci5JdGVtfSBpdGVtXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB4IGFuZCB5IHBvc2l0aW9uXG4gKi9cbnByb3RvLl9nZXRJdGVtTGF5b3V0UG9zaXRpb24gPSBmdW5jdGlvbiggLyogaXRlbSAqLyApIHtcbiAgcmV0dXJuIHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbn07XG5cbi8qKlxuICogaXRlcmF0ZSBvdmVyIGFycmF5IGFuZCBwb3NpdGlvbiBlYWNoIGl0ZW1cbiAqIFJlYXNvbiBiZWluZyAtIHNlcGFyYXRpbmcgdGhpcyBsb2dpYyBwcmV2ZW50cyAnbGF5b3V0IGludmFsaWRhdGlvbidcbiAqIHRoeCBAcGF1bF9pcmlzaFxuICogQHBhcmFtIHtBcnJheX0gcXVldWVcbiAqL1xucHJvdG8uX3Byb2Nlc3NMYXlvdXRRdWV1ZSA9IGZ1bmN0aW9uKCBxdWV1ZSApIHtcbiAgdGhpcy51cGRhdGVTdGFnZ2VyKCk7XG4gIHF1ZXVlLmZvckVhY2goIGZ1bmN0aW9uKCBvYmosIGkgKSB7XG4gICAgdGhpcy5fcG9zaXRpb25JdGVtKCBvYmouaXRlbSwgb2JqLngsIG9iai55LCBvYmouaXNJbnN0YW50LCBpICk7XG4gIH0sIHRoaXMgKTtcbn07XG5cbi8vIHNldCBzdGFnZ2VyIGZyb20gb3B0aW9uIGluIG1pbGxpc2Vjb25kcyBudW1iZXJcbnByb3RvLnVwZGF0ZVN0YWdnZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YWdnZXIgPSB0aGlzLm9wdGlvbnMuc3RhZ2dlcjtcbiAgaWYgKCBzdGFnZ2VyID09PSBudWxsIHx8IHN0YWdnZXIgPT09IHVuZGVmaW5lZCApIHtcbiAgICB0aGlzLnN0YWdnZXIgPSAwO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnN0YWdnZXIgPSBnZXRNaWxsaXNlY29uZHMoIHN0YWdnZXIgKTtcbiAgcmV0dXJuIHRoaXMuc3RhZ2dlcjtcbn07XG5cbi8qKlxuICogU2V0cyBwb3NpdGlvbiBvZiBpdGVtIGluIERPTVxuICogQHBhcmFtIHtPdXRsYXllci5JdGVtfSBpdGVtXG4gKiBAcGFyYW0ge051bWJlcn0geCAtIGhvcml6b250YWwgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gdmVydGljYWwgcG9zaXRpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbnN0YW50IC0gZGlzYWJsZXMgdHJhbnNpdGlvbnNcbiAqL1xucHJvdG8uX3Bvc2l0aW9uSXRlbSA9IGZ1bmN0aW9uKCBpdGVtLCB4LCB5LCBpc0luc3RhbnQsIGkgKSB7XG4gIGlmICggaXNJbnN0YW50ICkge1xuICAgIC8vIGlmIG5vdCB0cmFuc2l0aW9uLCBqdXN0IHNldCBDU1NcbiAgICBpdGVtLmdvVG8oIHgsIHkgKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtLnN0YWdnZXIoIGkgKiB0aGlzLnN0YWdnZXIgKTtcbiAgICBpdGVtLm1vdmVUbyggeCwgeSApO1xuICB9XG59O1xuXG4vKipcbiAqIEFueSBsb2dpYyB5b3Ugd2FudCB0byBkbyBhZnRlciBlYWNoIGxheW91dCxcbiAqIGkuZS4gc2l6ZSB0aGUgY29udGFpbmVyXG4gKi9cbnByb3RvLl9wb3N0TGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVzaXplQ29udGFpbmVyKCk7XG59O1xuXG5wcm90by5yZXNpemVDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlzUmVzaXppbmdDb250YWluZXIgPSB0aGlzLl9nZXRPcHRpb24oJ3Jlc2l6ZUNvbnRhaW5lcicpO1xuICBpZiAoICFpc1Jlc2l6aW5nQ29udGFpbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2l6ZSA9IHRoaXMuX2dldENvbnRhaW5lclNpemUoKTtcbiAgaWYgKCBzaXplICkge1xuICAgIHRoaXMuX3NldENvbnRhaW5lck1lYXN1cmUoIHNpemUud2lkdGgsIHRydWUgKTtcbiAgICB0aGlzLl9zZXRDb250YWluZXJNZWFzdXJlKCBzaXplLmhlaWdodCwgZmFsc2UgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHdpZHRoIG9yIGhlaWdodCBvZiBjb250YWluZXIgaWYgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IHNpemVcbiAqICAgQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gKiAgIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqL1xucHJvdG8uX2dldENvbnRhaW5lclNpemUgPSBub29wO1xuXG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSBtZWFzdXJlIC0gc2l6ZSBvZiB3aWR0aCBvciBoZWlnaHRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNXaWR0aFxuICovXG5wcm90by5fc2V0Q29udGFpbmVyTWVhc3VyZSA9IGZ1bmN0aW9uKCBtZWFzdXJlLCBpc1dpZHRoICkge1xuICBpZiAoIG1lYXN1cmUgPT09IHVuZGVmaW5lZCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZWxlbVNpemUgPSB0aGlzLnNpemU7XG4gIC8vIGFkZCBwYWRkaW5nIGFuZCBib3JkZXIgd2lkdGggaWYgYm9yZGVyIGJveFxuICBpZiAoIGVsZW1TaXplLmlzQm9yZGVyQm94ICkge1xuICAgIG1lYXN1cmUgKz0gaXNXaWR0aCA/IGVsZW1TaXplLnBhZGRpbmdMZWZ0ICsgZWxlbVNpemUucGFkZGluZ1JpZ2h0ICtcbiAgICAgIGVsZW1TaXplLmJvcmRlckxlZnRXaWR0aCArIGVsZW1TaXplLmJvcmRlclJpZ2h0V2lkdGggOlxuICAgICAgZWxlbVNpemUucGFkZGluZ0JvdHRvbSArIGVsZW1TaXplLnBhZGRpbmdUb3AgK1xuICAgICAgZWxlbVNpemUuYm9yZGVyVG9wV2lkdGggKyBlbGVtU2l6ZS5ib3JkZXJCb3R0b21XaWR0aDtcbiAgfVxuXG4gIG1lYXN1cmUgPSBNYXRoLm1heCggbWVhc3VyZSwgMCApO1xuICB0aGlzLmVsZW1lbnQuc3R5bGVbIGlzV2lkdGggPyAnd2lkdGgnIDogJ2hlaWdodCcgXSA9IG1lYXN1cmUgKyAncHgnO1xufTtcblxuLyoqXG4gKiBlbWl0IGV2ZW50Q29tcGxldGUgb24gYSBjb2xsZWN0aW9uIG9mIGl0ZW1zIGV2ZW50c1xuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICogQHBhcmFtIHtBcnJheX0gaXRlbXMgLSBPdXRsYXllci5JdGVtc1xuICovXG5wcm90by5fZW1pdENvbXBsZXRlT25JdGVtcyA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGl0ZW1zICkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoIGV2ZW50TmFtZSArICdDb21wbGV0ZScsIG51bGwsIFsgaXRlbXMgXSApO1xuICB9XG5cbiAgdmFyIGNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICBpZiAoICFpdGVtcyB8fCAhY291bnQgKSB7XG4gICAgb25Db21wbGV0ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkb25lQ291bnQgPSAwO1xuICBmdW5jdGlvbiB0aWNrKCkge1xuICAgIGRvbmVDb3VudCsrO1xuICAgIGlmICggZG9uZUNvdW50ID09IGNvdW50ICkge1xuICAgICAgb25Db21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJpbmQgY2FsbGJhY2tcbiAgaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgaXRlbS5vbmNlKCBldmVudE5hbWUsIHRpY2sgKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIGVtaXRzIGV2ZW50cyB2aWEgRXZFbWl0dGVyIGFuZCBqUXVlcnkgZXZlbnRzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIG5hbWUgb2YgZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gb3JpZ2luYWwgZXZlbnRcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBleHRyYSBhcmd1bWVudHNcbiAqL1xucHJvdG8uZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgYXJncyApIHtcbiAgLy8gYWRkIG9yaWdpbmFsIGV2ZW50IHRvIGFyZ3VtZW50c1xuICB2YXIgZW1pdEFyZ3MgPSBldmVudCA/IFsgZXZlbnQgXS5jb25jYXQoIGFyZ3MgKSA6IGFyZ3M7XG4gIHRoaXMuZW1pdEV2ZW50KCB0eXBlLCBlbWl0QXJncyApO1xuXG4gIGlmICggalF1ZXJ5ICkge1xuICAgIC8vIHNldCB0aGlzLiRlbGVtZW50XG4gICAgdGhpcy4kZWxlbWVudCA9IHRoaXMuJGVsZW1lbnQgfHwgalF1ZXJ5KCB0aGlzLmVsZW1lbnQgKTtcbiAgICBpZiAoIGV2ZW50ICkge1xuICAgICAgLy8gY3JlYXRlIGpRdWVyeSBldmVudFxuICAgICAgdmFyICRldmVudCA9IGpRdWVyeS5FdmVudCggZXZlbnQgKTtcbiAgICAgICRldmVudC50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlciggJGV2ZW50LCBhcmdzICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGp1c3QgdHJpZ2dlciB3aXRoIHR5cGUgaWYgbm8gZXZlbnQgYXZhaWxhYmxlXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoIHR5cGUsIGFyZ3MgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGlnbm9yZSAmIHN0YW1wcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5cbi8qKlxuICoga2VlcCBpdGVtIGluIGNvbGxlY3Rpb24sIGJ1dCBkbyBub3QgbGF5IGl0IG91dFxuICogaWdub3JlZCBpdGVtcyBkbyBub3QgZ2V0IHNraXBwZWQgaW4gbGF5b3V0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqL1xucHJvdG8uaWdub3JlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKCBlbGVtICk7XG4gIGlmICggaXRlbSApIHtcbiAgICBpdGVtLmlzSWdub3JlZCA9IHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogcmV0dXJuIGl0ZW0gdG8gbGF5b3V0IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICovXG5wcm90by51bmlnbm9yZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbSggZWxlbSApO1xuICBpZiAoIGl0ZW0gKSB7XG4gICAgZGVsZXRlIGl0ZW0uaXNJZ25vcmVkO1xuICB9XG59O1xuXG4vKipcbiAqIGFkZHMgZWxlbWVudHMgdG8gc3RhbXBzXG4gKiBAcGFyYW0ge05vZGVMaXN0LCBBcnJheSwgRWxlbWVudCwgb3IgU3RyaW5nfSBlbGVtc1xuICovXG5wcm90by5zdGFtcCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgZWxlbXMgPSB0aGlzLl9maW5kKCBlbGVtcyApO1xuICBpZiAoICFlbGVtcyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnN0YW1wcyA9IHRoaXMuc3RhbXBzLmNvbmNhdCggZWxlbXMgKTtcbiAgLy8gaWdub3JlXG4gIGVsZW1zLmZvckVhY2goIHRoaXMuaWdub3JlLCB0aGlzICk7XG59O1xuXG4vKipcbiAqIHJlbW92ZXMgZWxlbWVudHMgdG8gc3RhbXBzXG4gKiBAcGFyYW0ge05vZGVMaXN0LCBBcnJheSwgb3IgRWxlbWVudH0gZWxlbXNcbiAqL1xucHJvdG8udW5zdGFtcCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgZWxlbXMgPSB0aGlzLl9maW5kKCBlbGVtcyApO1xuICBpZiAoICFlbGVtcyApe1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgIC8vIGZpbHRlciBvdXQgcmVtb3ZlZCBzdGFtcCBlbGVtZW50c1xuICAgIHV0aWxzLnJlbW92ZUZyb20oIHRoaXMuc3RhbXBzLCBlbGVtICk7XG4gICAgdGhpcy51bmlnbm9yZSggZWxlbSApO1xuICB9LCB0aGlzICk7XG59O1xuXG4vKipcbiAqIGZpbmRzIGNoaWxkIGVsZW1lbnRzXG4gKiBAcGFyYW0ge05vZGVMaXN0LCBBcnJheSwgRWxlbWVudCwgb3IgU3RyaW5nfSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBlbGVtc1xuICovXG5wcm90by5fZmluZCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgaWYgKCAhZWxlbXMgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGlmIHN0cmluZywgdXNlIGFyZ3VtZW50IGFzIHNlbGVjdG9yIHN0cmluZ1xuICBpZiAoIHR5cGVvZiBlbGVtcyA9PSAnc3RyaW5nJyApIHtcbiAgICBlbGVtcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCBlbGVtcyApO1xuICB9XG4gIGVsZW1zID0gdXRpbHMubWFrZUFycmF5KCBlbGVtcyApO1xuICByZXR1cm4gZWxlbXM7XG59O1xuXG5wcm90by5fbWFuYWdlU3RhbXBzID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMuc3RhbXBzIHx8ICF0aGlzLnN0YW1wcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fZ2V0Qm91bmRpbmdSZWN0KCk7XG5cbiAgdGhpcy5zdGFtcHMuZm9yRWFjaCggdGhpcy5fbWFuYWdlU3RhbXAsIHRoaXMgKTtcbn07XG5cbi8vIHVwZGF0ZSBib3VuZGluZ0xlZnQgLyBUb3BcbnByb3RvLl9nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcbiAgLy8gZ2V0IGJvdW5kaW5nIHJlY3QgZm9yIGNvbnRhaW5lciBlbGVtZW50XG4gIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzaXplID0gdGhpcy5zaXplO1xuICB0aGlzLl9ib3VuZGluZ1JlY3QgPSB7XG4gICAgbGVmdDogYm91bmRpbmdSZWN0LmxlZnQgKyBzaXplLnBhZGRpbmdMZWZ0ICsgc2l6ZS5ib3JkZXJMZWZ0V2lkdGgsXG4gICAgdG9wOiBib3VuZGluZ1JlY3QudG9wICsgc2l6ZS5wYWRkaW5nVG9wICsgc2l6ZS5ib3JkZXJUb3BXaWR0aCxcbiAgICByaWdodDogYm91bmRpbmdSZWN0LnJpZ2h0IC0gKCBzaXplLnBhZGRpbmdSaWdodCArIHNpemUuYm9yZGVyUmlnaHRXaWR0aCApLFxuICAgIGJvdHRvbTogYm91bmRpbmdSZWN0LmJvdHRvbSAtICggc2l6ZS5wYWRkaW5nQm90dG9tICsgc2l6ZS5ib3JkZXJCb3R0b21XaWR0aCApXG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gc3RhbXBcbioqL1xucHJvdG8uX21hbmFnZVN0YW1wID0gbm9vcDtcblxuLyoqXG4gKiBnZXQgeC95IHBvc2l0aW9uIG9mIGVsZW1lbnQgcmVsYXRpdmUgdG8gY29udGFpbmVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHJldHVybnMge09iamVjdH0gb2Zmc2V0IC0gaGFzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICovXG5wcm90by5fZ2V0RWxlbWVudE9mZnNldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB2YXIgYm91bmRpbmdSZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHRoaXNSZWN0ID0gdGhpcy5fYm91bmRpbmdSZWN0O1xuICB2YXIgc2l6ZSA9IGdldFNpemUoIGVsZW0gKTtcbiAgdmFyIG9mZnNldCA9IHtcbiAgICBsZWZ0OiBib3VuZGluZ1JlY3QubGVmdCAtIHRoaXNSZWN0LmxlZnQgLSBzaXplLm1hcmdpbkxlZnQsXG4gICAgdG9wOiBib3VuZGluZ1JlY3QudG9wIC0gdGhpc1JlY3QudG9wIC0gc2l6ZS5tYXJnaW5Ub3AsXG4gICAgcmlnaHQ6IHRoaXNSZWN0LnJpZ2h0IC0gYm91bmRpbmdSZWN0LnJpZ2h0IC0gc2l6ZS5tYXJnaW5SaWdodCxcbiAgICBib3R0b206IHRoaXNSZWN0LmJvdHRvbSAtIGJvdW5kaW5nUmVjdC5ib3R0b20gLSBzaXplLm1hcmdpbkJvdHRvbVxuICB9O1xuICByZXR1cm4gb2Zmc2V0O1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gcmVzaXplIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGVuYWJsZSBldmVudCBoYW5kbGVycyBmb3IgbGlzdGVuZXJzXG4vLyBpLmUuIHJlc2l6ZSAtPiBvbnJlc2l6ZVxucHJvdG8uaGFuZGxlRXZlbnQgPSB1dGlscy5oYW5kbGVFdmVudDtcblxuLyoqXG4gKiBCaW5kIGxheW91dCB0byB3aW5kb3cgcmVzaXppbmdcbiAqL1xucHJvdG8uYmluZFJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3Jlc2l6ZScsIHRoaXMgKTtcbiAgdGhpcy5pc1Jlc2l6ZUJvdW5kID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogVW5iaW5kIGxheW91dCB0byB3aW5kb3cgcmVzaXppbmdcbiAqL1xucHJvdG8udW5iaW5kUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAncmVzaXplJywgdGhpcyApO1xuICB0aGlzLmlzUmVzaXplQm91bmQgPSBmYWxzZTtcbn07XG5cbnByb3RvLm9ucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVzaXplKCk7XG59O1xuXG51dGlscy5kZWJvdW5jZU1ldGhvZCggT3V0bGF5ZXIsICdvbnJlc2l6ZScsIDEwMCApO1xuXG5wcm90by5yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgLy8gZG9uJ3QgdHJpZ2dlciBpZiBzaXplIGRpZCBub3QgY2hhbmdlXG4gIC8vIG9yIGlmIHJlc2l6ZSB3YXMgdW5ib3VuZC4gU2VlICM5XG4gIGlmICggIXRoaXMuaXNSZXNpemVCb3VuZCB8fCAhdGhpcy5uZWVkc1Jlc2l6ZUxheW91dCgpICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMubGF5b3V0KCk7XG59O1xuXG4vKipcbiAqIGNoZWNrIGlmIGxheW91dCBpcyBuZWVkZWQgcG9zdCBsYXlvdXRcbiAqIEByZXR1cm5zIEJvb2xlYW5cbiAqL1xucHJvdG8ubmVlZHNSZXNpemVMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbiAgLy8gY2hlY2sgdGhhdCB0aGlzLnNpemUgYW5kIHNpemUgYXJlIHRoZXJlXG4gIC8vIElFOCB0cmlnZ2VycyByZXNpemUgb24gYm9keSBzaXplIGNoYW5nZSwgc28gdGhleSBtaWdodCBub3QgYmVcbiAgdmFyIGhhc1NpemVzID0gdGhpcy5zaXplICYmIHNpemU7XG4gIHJldHVybiBoYXNTaXplcyAmJiBzaXplLmlubmVyV2lkdGggIT09IHRoaXMuc2l6ZS5pbm5lcldpZHRoO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIGFkZCBpdGVtcyB0byBPdXRsYXllciBpbnN0YW5jZVxuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBFbGVtZW50fSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtcyAtIE91dGxheWVyLkl0ZW1zXG4qKi9cbnByb3RvLmFkZEl0ZW1zID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgaXRlbXMgPSB0aGlzLl9pdGVtaXplKCBlbGVtcyApO1xuICAvLyBhZGQgaXRlbXMgdG8gY29sbGVjdGlvblxuICBpZiAoIGl0ZW1zLmxlbmd0aCApIHtcbiAgICB0aGlzLml0ZW1zID0gdGhpcy5pdGVtcy5jb25jYXQoIGl0ZW1zICk7XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgbmV3bHktYXBwZW5kZWQgaXRlbSBlbGVtZW50c1xuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBFbGVtZW50fSBlbGVtc1xuICovXG5wcm90by5hcHBlbmRlZCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIGl0ZW1zID0gdGhpcy5hZGRJdGVtcyggZWxlbXMgKTtcbiAgaWYgKCAhaXRlbXMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBsYXlvdXQgYW5kIHJldmVhbCBqdXN0IHRoZSBuZXcgaXRlbXNcbiAgdGhpcy5sYXlvdXRJdGVtcyggaXRlbXMsIHRydWUgKTtcbiAgdGhpcy5yZXZlYWwoIGl0ZW1zICk7XG59O1xuXG4vKipcbiAqIExheW91dCBwcmVwZW5kZWQgZWxlbWVudHNcbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgRWxlbWVudH0gZWxlbXNcbiAqL1xucHJvdG8ucHJlcGVuZGVkID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgaXRlbXMgPSB0aGlzLl9pdGVtaXplKCBlbGVtcyApO1xuICBpZiAoICFpdGVtcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGFkZCBpdGVtcyB0byBiZWdpbm5pbmcgb2YgY29sbGVjdGlvblxuICB2YXIgcHJldmlvdXNJdGVtcyA9IHRoaXMuaXRlbXMuc2xpY2UoMCk7XG4gIHRoaXMuaXRlbXMgPSBpdGVtcy5jb25jYXQoIHByZXZpb3VzSXRlbXMgKTtcbiAgLy8gc3RhcnQgbmV3IGxheW91dFxuICB0aGlzLl9yZXNldExheW91dCgpO1xuICB0aGlzLl9tYW5hZ2VTdGFtcHMoKTtcbiAgLy8gbGF5b3V0IG5ldyBzdHVmZiB3aXRob3V0IHRyYW5zaXRpb25cbiAgdGhpcy5sYXlvdXRJdGVtcyggaXRlbXMsIHRydWUgKTtcbiAgdGhpcy5yZXZlYWwoIGl0ZW1zICk7XG4gIC8vIGxheW91dCBwcmV2aW91cyBpdGVtc1xuICB0aGlzLmxheW91dEl0ZW1zKCBwcmV2aW91c0l0ZW1zICk7XG59O1xuXG4vKipcbiAqIHJldmVhbCBhIGNvbGxlY3Rpb24gb2YgaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXkgb2YgT3V0bGF5ZXIuSXRlbXN9IGl0ZW1zXG4gKi9cbnByb3RvLnJldmVhbCA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcbiAgdGhpcy5fZW1pdENvbXBsZXRlT25JdGVtcyggJ3JldmVhbCcsIGl0ZW1zICk7XG4gIGlmICggIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzdGFnZ2VyID0gdGhpcy51cGRhdGVTdGFnZ2VyKCk7XG4gIGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtLCBpICkge1xuICAgIGl0ZW0uc3RhZ2dlciggaSAqIHN0YWdnZXIgKTtcbiAgICBpdGVtLnJldmVhbCgpO1xuICB9KTtcbn07XG5cbi8qKlxuICogaGlkZSBhIGNvbGxlY3Rpb24gb2YgaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXkgb2YgT3V0bGF5ZXIuSXRlbXN9IGl0ZW1zXG4gKi9cbnByb3RvLmhpZGUgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG4gIHRoaXMuX2VtaXRDb21wbGV0ZU9uSXRlbXMoICdoaWRlJywgaXRlbXMgKTtcbiAgaWYgKCAhaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHN0YWdnZXIgPSB0aGlzLnVwZGF0ZVN0YWdnZXIoKTtcbiAgaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0sIGkgKSB7XG4gICAgaXRlbS5zdGFnZ2VyKCBpICogc3RhZ2dlciApO1xuICAgIGl0ZW0uaGlkZSgpO1xuICB9KTtcbn07XG5cbi8qKlxuICogcmV2ZWFsIGl0ZW0gZWxlbWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9LCB7RWxlbWVudH0sIHtOb2RlTGlzdH0gaXRlbXNcbiAqL1xucHJvdG8ucmV2ZWFsSXRlbUVsZW1lbnRzID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgaXRlbXMgPSB0aGlzLmdldEl0ZW1zKCBlbGVtcyApO1xuICB0aGlzLnJldmVhbCggaXRlbXMgKTtcbn07XG5cbi8qKlxuICogaGlkZSBpdGVtIGVsZW1lbnRzXG4gKiBAcGFyYW0ge0FycmF5fSwge0VsZW1lbnR9LCB7Tm9kZUxpc3R9IGl0ZW1zXG4gKi9cbnByb3RvLmhpZGVJdGVtRWxlbWVudHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuZ2V0SXRlbXMoIGVsZW1zICk7XG4gIHRoaXMuaGlkZSggaXRlbXMgKTtcbn07XG5cbi8qKlxuICogZ2V0IE91dGxheWVyLkl0ZW0sIGdpdmVuIGFuIEVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtPdXRsYXllci5JdGVtfSBpdGVtXG4gKi9cbnByb3RvLmdldEl0ZW0gPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgLy8gbG9vcCB0aHJvdWdoIGl0ZW1zIHRvIGdldCB0aGUgb25lIHRoYXQgbWF0Y2hlc1xuICBmb3IgKCB2YXIgaT0wOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNbaV07XG4gICAgaWYgKCBpdGVtLmVsZW1lbnQgPT0gZWxlbSApIHtcbiAgICAgIC8vIHJldHVybiBpdGVtXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogZ2V0IGNvbGxlY3Rpb24gb2YgT3V0bGF5ZXIuSXRlbXMsIGdpdmVuIEVsZW1lbnRzXG4gKiBAcGFyYW0ge0FycmF5fSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtcyAtIE91dGxheWVyLkl0ZW1zXG4gKi9cbnByb3RvLmdldEl0ZW1zID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICBlbGVtcyA9IHV0aWxzLm1ha2VBcnJheSggZWxlbXMgKTtcbiAgdmFyIGl0ZW1zID0gW107XG4gIGVsZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKCBlbGVtICk7XG4gICAgaWYgKCBpdGVtICkge1xuICAgICAgaXRlbXMucHVzaCggaXRlbSApO1xuICAgIH1cbiAgfSwgdGhpcyApO1xuXG4gIHJldHVybiBpdGVtcztcbn07XG5cbi8qKlxuICogcmVtb3ZlIGVsZW1lbnQocykgZnJvbSBpbnN0YW5jZSBhbmQgRE9NXG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEVsZW1lbnR9IGVsZW1zXG4gKi9cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIHJlbW92ZUl0ZW1zID0gdGhpcy5nZXRJdGVtcyggZWxlbXMgKTtcblxuICB0aGlzLl9lbWl0Q29tcGxldGVPbkl0ZW1zKCAncmVtb3ZlJywgcmVtb3ZlSXRlbXMgKTtcblxuICAvLyBiYWlsIGlmIG5vIGl0ZW1zIHRvIHJlbW92ZVxuICBpZiAoICFyZW1vdmVJdGVtcyB8fCAhcmVtb3ZlSXRlbXMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlbW92ZUl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgLy8gcmVtb3ZlIGl0ZW0gZnJvbSBjb2xsZWN0aW9uXG4gICAgdXRpbHMucmVtb3ZlRnJvbSggdGhpcy5pdGVtcywgaXRlbSApO1xuICB9LCB0aGlzICk7XG59O1xuXG4vLyAtLS0tLSBkZXN0cm95IC0tLS0tIC8vXG5cbi8vIHJlbW92ZSBhbmQgZGlzYWJsZSBPdXRsYXllciBpbnN0YW5jZVxucHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAvLyBjbGVhbiB1cCBkeW5hbWljIHN0eWxlc1xuICB2YXIgc3R5bGUgPSB0aGlzLmVsZW1lbnQuc3R5bGU7XG4gIHN0eWxlLmhlaWdodCA9ICcnO1xuICBzdHlsZS5wb3NpdGlvbiA9ICcnO1xuICBzdHlsZS53aWR0aCA9ICcnO1xuICAvLyBkZXN0cm95IGl0ZW1zXG4gIHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgaXRlbS5kZXN0cm95KCk7XG4gIH0pO1xuXG4gIHRoaXMudW5iaW5kUmVzaXplKCk7XG5cbiAgdmFyIGlkID0gdGhpcy5lbGVtZW50Lm91dGxheWVyR1VJRDtcbiAgZGVsZXRlIGluc3RhbmNlc1sgaWQgXTsgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBpbnN0YW5jZSBieSBpZFxuICBkZWxldGUgdGhpcy5lbGVtZW50Lm91dGxheWVyR1VJRDtcbiAgLy8gcmVtb3ZlIGRhdGEgZm9yIGpRdWVyeVxuICBpZiAoIGpRdWVyeSApIHtcbiAgICBqUXVlcnkucmVtb3ZlRGF0YSggdGhpcy5lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLm5hbWVzcGFjZSApO1xuICB9XG5cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGRhdGEgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBnZXQgT3V0bGF5ZXIgaW5zdGFuY2UgZnJvbSBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqIEByZXR1cm5zIHtPdXRsYXllcn1cbiAqL1xuT3V0bGF5ZXIuZGF0YSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICBlbGVtID0gdXRpbHMuZ2V0UXVlcnlFbGVtZW50KCBlbGVtICk7XG4gIHZhciBpZCA9IGVsZW0gJiYgZWxlbS5vdXRsYXllckdVSUQ7XG4gIHJldHVybiBpZCAmJiBpbnN0YW5jZXNbIGlkIF07XG59O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGNyZWF0ZSBPdXRsYXllciBjbGFzcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIGNyZWF0ZSBhIGxheW91dCBjbGFzc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICovXG5PdXRsYXllci5jcmVhdGUgPSBmdW5jdGlvbiggbmFtZXNwYWNlLCBvcHRpb25zICkge1xuICAvLyBzdWItY2xhc3MgT3V0bGF5ZXJcbiAgdmFyIExheW91dCA9IHN1YmNsYXNzKCBPdXRsYXllciApO1xuICAvLyBhcHBseSBuZXcgb3B0aW9ucyBhbmQgY29tcGF0T3B0aW9uc1xuICBMYXlvdXQuZGVmYXVsdHMgPSB1dGlscy5leHRlbmQoIHt9LCBPdXRsYXllci5kZWZhdWx0cyApO1xuICB1dGlscy5leHRlbmQoIExheW91dC5kZWZhdWx0cywgb3B0aW9ucyApO1xuICBMYXlvdXQuY29tcGF0T3B0aW9ucyA9IHV0aWxzLmV4dGVuZCgge30sIE91dGxheWVyLmNvbXBhdE9wdGlvbnMgICk7XG5cbiAgTGF5b3V0Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICBMYXlvdXQuZGF0YSA9IE91dGxheWVyLmRhdGE7XG5cbiAgLy8gc3ViLWNsYXNzIEl0ZW1cbiAgTGF5b3V0Lkl0ZW0gPSBzdWJjbGFzcyggSXRlbSApO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGRlY2xhcmF0aXZlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgdXRpbHMuaHRtbEluaXQoIExheW91dCwgbmFtZXNwYWNlICk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0galF1ZXJ5IGJyaWRnZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gIC8vIG1ha2UgaW50byBqUXVlcnkgcGx1Z2luXG4gIGlmICggalF1ZXJ5ICYmIGpRdWVyeS5icmlkZ2V0ICkge1xuICAgIGpRdWVyeS5icmlkZ2V0KCBuYW1lc3BhY2UsIExheW91dCApO1xuICB9XG5cbiAgcmV0dXJuIExheW91dDtcbn07XG5cbmZ1bmN0aW9uIHN1YmNsYXNzKCBQYXJlbnQgKSB7XG4gIGZ1bmN0aW9uIFN1YkNsYXNzKCkge1xuICAgIFBhcmVudC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gIH1cblxuICBTdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG4gIFN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YkNsYXNzO1xuXG4gIHJldHVybiBTdWJDbGFzcztcbn1cblxuLy8gLS0tLS0gaGVscGVycyAtLS0tLSAvL1xuXG4vLyBob3cgbWFueSBtaWxsaXNlY29uZHMgYXJlIGluIGVhY2ggdW5pdFxudmFyIG1zVW5pdHMgPSB7XG4gIG1zOiAxLFxuICBzOiAxMDAwXG59O1xuXG4vLyBtdW5nZSB0aW1lLWxpa2UgcGFyYW1ldGVyIGludG8gbWlsbGlzZWNvbmQgbnVtYmVyXG4vLyAnMC40cycgLT4gNDBcbmZ1bmN0aW9uIGdldE1pbGxpc2Vjb25kcyggdGltZSApIHtcbiAgaWYgKCB0eXBlb2YgdGltZSA9PSAnbnVtYmVyJyApIHtcbiAgICByZXR1cm4gdGltZTtcbiAgfVxuICB2YXIgbWF0Y2hlcyA9IHRpbWUubWF0Y2goIC8oXlxcZCpcXC4/XFxkKikoXFx3KikvICk7XG4gIHZhciBudW0gPSBtYXRjaGVzICYmIG1hdGNoZXNbMV07XG4gIHZhciB1bml0ID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzJdO1xuICBpZiAoICFudW0ubGVuZ3RoICkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIG51bSA9IHBhcnNlRmxvYXQoIG51bSApO1xuICB2YXIgbXVsdCA9IG1zVW5pdHNbIHVuaXQgXSB8fCAxO1xuICByZXR1cm4gbnVtICogbXVsdDtcbn1cblxuLy8gLS0tLS0gZmluIC0tLS0tIC8vXG5cbi8vIGJhY2sgaW4gZ2xvYmFsXG5PdXRsYXllci5JdGVtID0gSXRlbTtcblxucmV0dXJuIE91dGxheWVyO1xuXG59KSk7XG5cbi8qIVxuICogTWFzb25yeSB2NC4xLjFcbiAqIENhc2NhZGluZyBncmlkIGxheW91dCBsaWJyYXJ5XG4gKiBodHRwOi8vbWFzb25yeS5kZXNhbmRyby5jb21cbiAqIE1JVCBMaWNlbnNlXG4gKiBieSBEYXZpZCBEZVNhbmRyb1xuICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggW1xuICAgICAgICAnb3V0bGF5ZXIvb3V0bGF5ZXInLFxuICAgICAgICAnZ2V0LXNpemUvZ2V0LXNpemUnXG4gICAgICBdLFxuICAgICAgZmFjdG9yeSApO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgcmVxdWlyZSgnb3V0bGF5ZXInKSxcbiAgICAgIHJlcXVpcmUoJ2dldC1zaXplJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93Lk1hc29ucnkgPSBmYWN0b3J5KFxuICAgICAgd2luZG93Lk91dGxheWVyLFxuICAgICAgd2luZG93LmdldFNpemVcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggT3V0bGF5ZXIsIGdldFNpemUgKSB7XG5cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBtYXNvbnJ5RGVmaW5pdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gIC8vIGNyZWF0ZSBhbiBPdXRsYXllciBsYXlvdXQgY2xhc3NcbiAgdmFyIE1hc29ucnkgPSBPdXRsYXllci5jcmVhdGUoJ21hc29ucnknKTtcbiAgLy8gaXNGaXRXaWR0aCAtPiBmaXRXaWR0aFxuICBNYXNvbnJ5LmNvbXBhdE9wdGlvbnMuZml0V2lkdGggPSAnaXNGaXRXaWR0aCc7XG5cbiAgTWFzb25yeS5wcm90b3R5cGUuX3Jlc2V0TGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nZXRTaXplKCk7XG4gICAgdGhpcy5fZ2V0TWVhc3VyZW1lbnQoICdjb2x1bW5XaWR0aCcsICdvdXRlcldpZHRoJyApO1xuICAgIHRoaXMuX2dldE1lYXN1cmVtZW50KCAnZ3V0dGVyJywgJ291dGVyV2lkdGgnICk7XG4gICAgdGhpcy5tZWFzdXJlQ29sdW1ucygpO1xuXG4gICAgLy8gcmVzZXQgY29sdW1uIFlcbiAgICB0aGlzLmNvbFlzID0gW107XG4gICAgZm9yICggdmFyIGk9MDsgaSA8IHRoaXMuY29sczsgaSsrICkge1xuICAgICAgdGhpcy5jb2xZcy5wdXNoKCAwICk7XG4gICAgfVxuXG4gICAgdGhpcy5tYXhZID0gMDtcbiAgfTtcblxuICBNYXNvbnJ5LnByb3RvdHlwZS5tZWFzdXJlQ29sdW1ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0Q29udGFpbmVyV2lkdGgoKTtcbiAgICAvLyBpZiBjb2x1bW5XaWR0aCBpcyAwLCBkZWZhdWx0IHRvIG91dGVyV2lkdGggb2YgZmlyc3QgaXRlbVxuICAgIGlmICggIXRoaXMuY29sdW1uV2lkdGggKSB7XG4gICAgICB2YXIgZmlyc3RJdGVtID0gdGhpcy5pdGVtc1swXTtcbiAgICAgIHZhciBmaXJzdEl0ZW1FbGVtID0gZmlyc3RJdGVtICYmIGZpcnN0SXRlbS5lbGVtZW50O1xuICAgICAgLy8gY29sdW1uV2lkdGggZmFsbCBiYWNrIHRvIGl0ZW0gb2YgZmlyc3QgZWxlbWVudFxuICAgICAgdGhpcy5jb2x1bW5XaWR0aCA9IGZpcnN0SXRlbUVsZW0gJiYgZ2V0U2l6ZSggZmlyc3RJdGVtRWxlbSApLm91dGVyV2lkdGggfHxcbiAgICAgICAgLy8gaWYgZmlyc3QgZWxlbSBoYXMgbm8gd2lkdGgsIGRlZmF1bHQgdG8gc2l6ZSBvZiBjb250YWluZXJcbiAgICAgICAgdGhpcy5jb250YWluZXJXaWR0aDtcbiAgICB9XG5cbiAgICB2YXIgY29sdW1uV2lkdGggPSB0aGlzLmNvbHVtbldpZHRoICs9IHRoaXMuZ3V0dGVyO1xuXG4gICAgLy8gY2FsY3VsYXRlIGNvbHVtbnNcbiAgICB2YXIgY29udGFpbmVyV2lkdGggPSB0aGlzLmNvbnRhaW5lcldpZHRoICsgdGhpcy5ndXR0ZXI7XG4gICAgdmFyIGNvbHMgPSBjb250YWluZXJXaWR0aCAvIGNvbHVtbldpZHRoO1xuICAgIC8vIGZpeCByb3VuZGluZyBlcnJvcnMsIHR5cGljYWxseSB3aXRoIGd1dHRlcnNcbiAgICB2YXIgZXhjZXNzID0gY29sdW1uV2lkdGggLSBjb250YWluZXJXaWR0aCAlIGNvbHVtbldpZHRoO1xuICAgIC8vIGlmIG92ZXJzaG9vdCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgcm91bmQgdXAsIG90aGVyd2lzZSBmbG9vciBpdFxuICAgIHZhciBtYXRoTWV0aG9kID0gZXhjZXNzICYmIGV4Y2VzcyA8IDEgPyAncm91bmQnIDogJ2Zsb29yJztcbiAgICBjb2xzID0gTWF0aFsgbWF0aE1ldGhvZCBdKCBjb2xzICk7XG4gICAgdGhpcy5jb2xzID0gTWF0aC5tYXgoIGNvbHMsIDEgKTtcbiAgfTtcblxuICBNYXNvbnJ5LnByb3RvdHlwZS5nZXRDb250YWluZXJXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGNvbnRhaW5lciBpcyBwYXJlbnQgaWYgZml0IHdpZHRoXG4gICAgdmFyIGlzRml0V2lkdGggPSB0aGlzLl9nZXRPcHRpb24oJ2ZpdFdpZHRoJyk7XG4gICAgdmFyIGNvbnRhaW5lciA9IGlzRml0V2lkdGggPyB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSA6IHRoaXMuZWxlbWVudDtcbiAgICAvLyBjaGVjayB0aGF0IHRoaXMuc2l6ZSBhbmQgc2l6ZSBhcmUgdGhlcmVcbiAgICAvLyBJRTggdHJpZ2dlcnMgcmVzaXplIG9uIGJvZHkgc2l6ZSBjaGFuZ2UsIHNvIHRoZXkgbWlnaHQgbm90IGJlXG4gICAgdmFyIHNpemUgPSBnZXRTaXplKCBjb250YWluZXIgKTtcbiAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gc2l6ZSAmJiBzaXplLmlubmVyV2lkdGg7XG4gIH07XG5cbiAgTWFzb25yeS5wcm90b3R5cGUuX2dldEl0ZW1MYXlvdXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIGl0ZW0uZ2V0U2l6ZSgpO1xuICAgIC8vIGhvdyBtYW55IGNvbHVtbnMgZG9lcyB0aGlzIGJyaWNrIHNwYW5cbiAgICB2YXIgcmVtYWluZGVyID0gaXRlbS5zaXplLm91dGVyV2lkdGggJSB0aGlzLmNvbHVtbldpZHRoO1xuICAgIHZhciBtYXRoTWV0aG9kID0gcmVtYWluZGVyICYmIHJlbWFpbmRlciA8IDEgPyAncm91bmQnIDogJ2NlaWwnO1xuICAgIC8vIHJvdW5kIGlmIG9mZiBieSAxIHBpeGVsLCBvdGhlcndpc2UgdXNlIGNlaWxcbiAgICB2YXIgY29sU3BhbiA9IE1hdGhbIG1hdGhNZXRob2QgXSggaXRlbS5zaXplLm91dGVyV2lkdGggLyB0aGlzLmNvbHVtbldpZHRoICk7XG4gICAgY29sU3BhbiA9IE1hdGgubWluKCBjb2xTcGFuLCB0aGlzLmNvbHMgKTtcblxuICAgIHZhciBjb2xHcm91cCA9IHRoaXMuX2dldENvbEdyb3VwKCBjb2xTcGFuICk7XG4gICAgLy8gZ2V0IHRoZSBtaW5pbXVtIFkgdmFsdWUgZnJvbSB0aGUgY29sdW1uc1xuICAgIHZhciBtaW5pbXVtWSA9IE1hdGgubWluLmFwcGx5KCBNYXRoLCBjb2xHcm91cCApO1xuICAgIHZhciBzaG9ydENvbEluZGV4ID0gY29sR3JvdXAuaW5kZXhPZiggbWluaW11bVkgKTtcblxuICAgIC8vIHBvc2l0aW9uIHRoZSBicmlja1xuICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgIHg6IHRoaXMuY29sdW1uV2lkdGggKiBzaG9ydENvbEluZGV4LFxuICAgICAgeTogbWluaW11bVlcbiAgICB9O1xuXG4gICAgLy8gYXBwbHkgc2V0SGVpZ2h0IHRvIG5lY2Vzc2FyeSBjb2x1bW5zXG4gICAgdmFyIHNldEhlaWdodCA9IG1pbmltdW1ZICsgaXRlbS5zaXplLm91dGVySGVpZ2h0O1xuICAgIHZhciBzZXRTcGFuID0gdGhpcy5jb2xzICsgMSAtIGNvbEdyb3VwLmxlbmd0aDtcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzZXRTcGFuOyBpKysgKSB7XG4gICAgICB0aGlzLmNvbFlzWyBzaG9ydENvbEluZGV4ICsgaSBdID0gc2V0SGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbFNwYW4gLSBudW1iZXIgb2YgY29sdW1ucyB0aGUgZWxlbWVudCBzcGFuc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9IGNvbEdyb3VwXG4gICAqL1xuICBNYXNvbnJ5LnByb3RvdHlwZS5fZ2V0Q29sR3JvdXAgPSBmdW5jdGlvbiggY29sU3BhbiApIHtcbiAgICBpZiAoIGNvbFNwYW4gPCAyICkge1xuICAgICAgLy8gaWYgYnJpY2sgc3BhbnMgb25seSBvbmUgY29sdW1uLCB1c2UgYWxsIHRoZSBjb2x1bW4gWXNcbiAgICAgIHJldHVybiB0aGlzLmNvbFlzO1xuICAgIH1cblxuICAgIHZhciBjb2xHcm91cCA9IFtdO1xuICAgIC8vIGhvdyBtYW55IGRpZmZlcmVudCBwbGFjZXMgY291bGQgdGhpcyBicmljayBmaXQgaG9yaXpvbnRhbGx5XG4gICAgdmFyIGdyb3VwQ291bnQgPSB0aGlzLmNvbHMgKyAxIC0gY29sU3BhbjtcbiAgICAvLyBmb3IgZWFjaCBncm91cCBwb3RlbnRpYWwgaG9yaXpvbnRhbCBwb3NpdGlvblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkrKyApIHtcbiAgICAgIC8vIG1ha2UgYW4gYXJyYXkgb2YgY29sWSB2YWx1ZXMgZm9yIHRoYXQgb25lIGdyb3VwXG4gICAgICB2YXIgZ3JvdXBDb2xZcyA9IHRoaXMuY29sWXMuc2xpY2UoIGksIGkgKyBjb2xTcGFuICk7XG4gICAgICAvLyBhbmQgZ2V0IHRoZSBtYXggdmFsdWUgb2YgdGhlIGFycmF5XG4gICAgICBjb2xHcm91cFtpXSA9IE1hdGgubWF4LmFwcGx5KCBNYXRoLCBncm91cENvbFlzICk7XG4gICAgfVxuICAgIHJldHVybiBjb2xHcm91cDtcbiAgfTtcblxuICBNYXNvbnJ5LnByb3RvdHlwZS5fbWFuYWdlU3RhbXAgPSBmdW5jdGlvbiggc3RhbXAgKSB7XG4gICAgdmFyIHN0YW1wU2l6ZSA9IGdldFNpemUoIHN0YW1wICk7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2dldEVsZW1lbnRPZmZzZXQoIHN0YW1wICk7XG4gICAgLy8gZ2V0IHRoZSBjb2x1bW5zIHRoYXQgdGhpcyBzdGFtcCBhZmZlY3RzXG4gICAgdmFyIGlzT3JpZ2luTGVmdCA9IHRoaXMuX2dldE9wdGlvbignb3JpZ2luTGVmdCcpO1xuICAgIHZhciBmaXJzdFggPSBpc09yaWdpbkxlZnQgPyBvZmZzZXQubGVmdCA6IG9mZnNldC5yaWdodDtcbiAgICB2YXIgbGFzdFggPSBmaXJzdFggKyBzdGFtcFNpemUub3V0ZXJXaWR0aDtcbiAgICB2YXIgZmlyc3RDb2wgPSBNYXRoLmZsb29yKCBmaXJzdFggLyB0aGlzLmNvbHVtbldpZHRoICk7XG4gICAgZmlyc3RDb2wgPSBNYXRoLm1heCggMCwgZmlyc3RDb2wgKTtcbiAgICB2YXIgbGFzdENvbCA9IE1hdGguZmxvb3IoIGxhc3RYIC8gdGhpcy5jb2x1bW5XaWR0aCApO1xuICAgIC8vIGxhc3RDb2wgc2hvdWxkIG5vdCBnbyBvdmVyIGlmIG11bHRpcGxlIG9mIGNvbHVtbldpZHRoICM0MjVcbiAgICBsYXN0Q29sIC09IGxhc3RYICUgdGhpcy5jb2x1bW5XaWR0aCA/IDAgOiAxO1xuICAgIGxhc3RDb2wgPSBNYXRoLm1pbiggdGhpcy5jb2xzIC0gMSwgbGFzdENvbCApO1xuICAgIC8vIHNldCBjb2xZcyB0byBib3R0b20gb2YgdGhlIHN0YW1wXG5cbiAgICB2YXIgaXNPcmlnaW5Ub3AgPSB0aGlzLl9nZXRPcHRpb24oJ29yaWdpblRvcCcpO1xuICAgIHZhciBzdGFtcE1heFkgPSAoIGlzT3JpZ2luVG9wID8gb2Zmc2V0LnRvcCA6IG9mZnNldC5ib3R0b20gKSArXG4gICAgICBzdGFtcFNpemUub3V0ZXJIZWlnaHQ7XG4gICAgZm9yICggdmFyIGkgPSBmaXJzdENvbDsgaSA8PSBsYXN0Q29sOyBpKysgKSB7XG4gICAgICB0aGlzLmNvbFlzW2ldID0gTWF0aC5tYXgoIHN0YW1wTWF4WSwgdGhpcy5jb2xZc1tpXSApO1xuICAgIH1cbiAgfTtcblxuICBNYXNvbnJ5LnByb3RvdHlwZS5fZ2V0Q29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4LmFwcGx5KCBNYXRoLCB0aGlzLmNvbFlzICk7XG4gICAgdmFyIHNpemUgPSB7XG4gICAgICBoZWlnaHQ6IHRoaXMubWF4WVxuICAgIH07XG5cbiAgICBpZiAoIHRoaXMuX2dldE9wdGlvbignZml0V2lkdGgnKSApIHtcbiAgICAgIHNpemUud2lkdGggPSB0aGlzLl9nZXRDb250YWluZXJGaXRXaWR0aCgpO1xuICAgIH1cblxuICAgIHJldHVybiBzaXplO1xuICB9O1xuXG4gIE1hc29ucnkucHJvdG90eXBlLl9nZXRDb250YWluZXJGaXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB1bnVzZWRDb2xzID0gMDtcbiAgICAvLyBjb3VudCB1bnVzZWQgY29sdW1uc1xuICAgIHZhciBpID0gdGhpcy5jb2xzO1xuICAgIHdoaWxlICggLS1pICkge1xuICAgICAgaWYgKCB0aGlzLmNvbFlzW2ldICE9PSAwICkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHVudXNlZENvbHMrKztcbiAgICB9XG4gICAgLy8gZml0IGNvbnRhaW5lciB0byBjb2x1bW5zIHRoYXQgaGF2ZSBiZWVuIHVzZWRcbiAgICByZXR1cm4gKCB0aGlzLmNvbHMgLSB1bnVzZWRDb2xzICkgKiB0aGlzLmNvbHVtbldpZHRoIC0gdGhpcy5ndXR0ZXI7XG4gIH07XG5cbiAgTWFzb25yeS5wcm90b3R5cGUubmVlZHNSZXNpemVMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJldmlvdXNXaWR0aCA9IHRoaXMuY29udGFpbmVyV2lkdGg7XG4gICAgdGhpcy5nZXRDb250YWluZXJXaWR0aCgpO1xuICAgIHJldHVybiBwcmV2aW91c1dpZHRoICE9IHRoaXMuY29udGFpbmVyV2lkdGg7XG4gIH07XG5cbiAgcmV0dXJuIE1hc29ucnk7XG5cbn0pKTtcblxuIiwiLy8gJChkb2N1bWVudCkuZm91bmRhdGlvbigpO1xuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuXHRTaXRlLmluaXQoKTtcbn0pO1xuXG52YXIgU2l0ZSA9IHtcblx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAkKHdpbmRvdykud2lkdGgoKSA+IDY0MCApIHtcblx0XHRcdFNpdGUuc2Nyb2xsbWFnaWMoKTtcblx0XHR9XG5cdFx0U2l0ZS5tb2JpbGVNZW51KCk7XG5cdH0sXG5cdG1vYmlsZU1lbnU6IGZ1bmN0aW9uKCl7XG5cdFx0JChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5tZW51LXRvZ2dsZScsIGZ1bmN0aW9uKGV2ZW50KXtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHQkKCdib2R5JykudG9nZ2xlQ2xhc3MoJ21lbnUtb3BlbicpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0pXG5cdFx0JChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5tZW51IGEnLCBmdW5jdGlvbigpe1xuXHRcdFx0JCgnYm9keScpLnJlbW92ZUNsYXNzKCdtZW51LW9wZW4nKTtcblx0XHR9KVxuXHR9LFxuXHRzY3JvbGxtYWdpYzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbnRyb2xsZXIgPSBuZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcigpO1xuXHRcdHZhciBpbWFnZXMgPSAkKCcucGFyYWxsYXgnKTtcblx0XHR2YXIgd2luZG93SGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuXG5cdFx0JC5lYWNoKGltYWdlcywgZnVuY3Rpb24oaW5kZXgsIGltYWdlKXtcblx0XHRcdHZhciB0d2VlbiA9IG5ldyBUd2Vlbk1heC5mcm9tVG8oaW1hZ2UsIDEsIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNGVtKScgfSwgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDEyZW0pJyB9KVxuXHRcdFx0dmFyIHNjZW5lID0gbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtcblx0XHRcdFx0XHRkdXJhdGlvbjogd2luZG93SGVpZ2h0KjIsXG5cdFx0XHRcdFx0dHJpZ2dlckVsZW1lbnQ6IGltYWdlLFxuXHRcdFx0XHRcdHRyaWdnZXJIb29rOiAxLFxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuc2V0VHdlZW4oIHR3ZWVuIClcblx0XHRcdFx0LmFkZFRvKGNvbnRyb2xsZXIpXG5cdFx0fSk7XG5cdH1cbn0iXX0=
